Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Orleans.Core(net5.0)
    #1 Path: D:\a\1\s\src\Orleans.Core\Async\TaskExtensions.cs, Line: 196, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #2 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 295, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 487, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 513, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 536, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 551, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 567, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\src\Orleans.Core\CodeGeneration\TypeUtils.cs, Line: 587, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\src\Orleans.Core\Configuration\LimitValue.cs, Line: 27, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\src\Orleans.Core\Logging\LogFormatter.cs, Line: 18, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #11 Path: D:\a\1\s\src\Orleans.Core\Logging\LogFormatter.cs, Line: 60, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #12 Path: D:\a\1\s\src\Orleans.Core\Messaging\ClientMessageCenter.cs, Line: 338, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\src\Orleans.Core\Messaging\Message.cs, Line: 427, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\src\Orleans.Core\Messaging\Message.cs, Line: 427, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\src\Orleans.Core\Messaging\Message.cs, Line: 438, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\src\Orleans.Core\Providers\IGrainStorage.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\src\Orleans.Core\Runtime\GrainReferenceRuntime.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\src\Orleans.Core\Runtime\HashRing.cs, Line: 49, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 360, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #20 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 373, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #21 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 380, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #22 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 392, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #23 Path: D:\a\1\s\src\Orleans.Core\Runtime\OutsideRuntimeClient.cs, Line: 436, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: D:\a\1\s\src\Orleans.Core\Runtime\RingRange.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\src\Orleans.Core\Runtime\RingRange.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs, Line: 649, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs, Line: 668, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\src\Orleans.Core\Serialization\BinaryTokenStreamReader.cs, Line: 989, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\src\Orleans.Core\Serialization\BinaryTokenStreamWriter.cs, Line: 592, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\src\Orleans.Core\Serialization\ILBasedExceptionSerializer.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\Orleans.Core\Serialization\SerializationManager.cs, Line: 624, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\Orleans.Core\Statistics\AverageValueStatistic.cs, Line: 74, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: D:\a\1\s\src\Orleans.Core\Statistics\AverageValueStatistic.cs, Line: 75, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: D:\a\1\s\src\Orleans.Core\Statistics\HistogramValueStatistic.cs, Line: 26, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\src\Orleans.Core\Statistics\IPerformanceMetrics.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: D:\a\1\s\src\Orleans.Core\Statistics\IPerformanceMetrics.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\src\Orleans.Core\Statistics\IPerformanceMetrics.cs, Line: 245, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\src\Orleans.Core\Statistics\LogStatistics.cs, Line: 54, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #39 Path: D:\a\1\s\src\Orleans.Core\Statistics\SchedulerStatisticsGroup.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: D:\a\1\s\src\Orleans.Core\Statistics\SchedulerStatisticsGroup.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IMembershipTable.cs, Line: 138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IMembershipTable.cs, Line: 194, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IMembershipTable.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #44 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IMembershipTable.cs, Line: 355, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #45 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IReminderTable.cs, Line: 119, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IReminderTable.cs, Line: 144, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: D:\a\1\s\src\Orleans.Core\SystemTargetInterfaces\IReminderTable.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\src\Orleans.Core\Telemetry\Consumers\FileTelemetryConsumer.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 130, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #51 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #52 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #54 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 222, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #55 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 253, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 291, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #58 Path: D:\a\1\s\src\Orleans.Core\Timers\SafeTimerBase.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #59 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 157, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #60 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #61 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #62 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 211, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #63 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #64 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #65 Path: D:\a\1\s\src\Orleans.Core\Transactions\OrleansTransactionException.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #66 Path: D:\a\1\s\src\Orleans.Core\Utils\CachedTypeResolver.cs, Line: 18, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #67 Path: D:\a\1\s\src\Orleans.Core\Utils\CachedTypeResolver.cs, Line: 37, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #68 Path: D:\a\1\s\src\Orleans.Core\Utils\Utils.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Runtime(net5.0)
    #69 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationCollector.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #70 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationCollector.cs, Line: 305, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #71 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationCollector.cs, Line: 320, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #72 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationCollector.cs, Line: 329, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #73 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationData.cs, Line: 760, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #74 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationData.cs, Line: 771, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #75 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationData.cs, Line: 791, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #76 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\ActivationDirectory.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 1192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 1197, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #79 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 673, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 771, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 777, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #82 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 887, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #83 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 912, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #84 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 941, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #85 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 985, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #86 Path: D:\a\1\s\src\Orleans.Runtime\Catalog\Catalog.cs, Line: 990, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #87 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #88 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #89 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 124, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #90 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 144, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #91 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 206, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #92 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\ConsistentRingProvider.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\VirtualBucketsRingProvider.cs, Line: 110, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #94 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\VirtualBucketsRingProvider.cs, Line: 194, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #95 Path: D:\a\1\s\src\Orleans.Runtime\ConsistentRing\VirtualBucketsRingProvider.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #96 Path: D:\a\1\s\src\Orleans.Runtime\Core\Dispatcher.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #97 Path: D:\a\1\s\src\Orleans.Runtime\Core\HostedClient.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #98 Path: D:\a\1\s\src\Orleans.Runtime\Core\InsideRuntimeClient.cs, Line: 334, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\src\Orleans.Runtime\Core\ManagementGrain.cs, Line: 214, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #100 Path: D:\a\1\s\src\Orleans.Runtime\Core\SystemStatus.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\src\Orleans.Runtime\Core\SystemTarget.cs, Line: 169, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\GrainDirectoryCacheFactory.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\GrainDirectoryHandoffManager.cs, Line: 295, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\GrainDirectoryPartition.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs, Line: 153, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs, Line: 199, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #107 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs, Line: 221, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #108 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs, Line: 278, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: D:\a\1\s\src\Orleans.Runtime\GrainDirectory\LocalGrainDirectory.cs, Line: 842, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\ClusterHealthMonitor.cs, Line: 134, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\InMemoryMembershipTable.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #112 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 227, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #114 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 392, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #115 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 516, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #116 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 543, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #117 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 632, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #118 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 640, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #119 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 681, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #120 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 690, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #121 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 720, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\src\Orleans.Runtime\MembershipService\MembershipTableManager.cs, Line: 810, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #123 Path: D:\a\1\s\src\Orleans.Runtime\Networking\GatewayInboundConnection.cs, Line: 154, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #124 Path: D:\a\1\s\src\Orleans.Runtime\Placement\ActivationCountPlacementDirector.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #125 Path: D:\a\1\s\src\Orleans.Runtime\Placement\DeploymentLoadPublisher.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #126 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 105, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #127 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #128 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #129 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #130 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 482, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #131 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 629, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #132 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\LocalReminderService.cs, Line: 637, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #133 Path: D:\a\1\s\src\Orleans.Runtime\ReminderService\ReminderRegistry.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #134 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\ActivationTaskScheduler.cs, Line: 117, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #135 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\ClosureWorkItem.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #136 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\InvokeWorkItem.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #137 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\OrleansTaskScheduler.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #138 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\RequestWorkItem.cs, Line: 40, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #139 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\ResponseWorkItem.cs, Line: 40, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\src\Orleans.Runtime\Scheduler\WorkItemBase.cs, Line: 26, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #141 Path: D:\a\1\s\src\Orleans.Runtime\Silo\Silo.cs, Line: 277, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #142 Path: D:\a\1\s\src\Orleans.Runtime\Silo\Silo.cs, Line: 359, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #143 Path: D:\a\1\s\src\Orleans.Runtime\Timers\GrainTimer.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #144 Path: D:\a\1\s\src\Orleans.Runtime\Timers\GrainTimer.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #145 Path: D:\a\1\s\src\Orleans.Runtime\Timers\GrainTimer.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Persistence.Memory(net5.0)
    #146 Path: D:\a\1\s\src\Orleans.Persistence.Memory\Storage\HierarchicalKeyStore.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #147 Path: D:\a\1\s\src\Orleans.Persistence.Memory\Storage\HierarchicalKeyStore.cs, Line: 32, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #148 Path: D:\a\1\s\src\Orleans.Persistence.Memory\Storage\HierarchicalKeyStore.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #149 Path: D:\a\1\s\src\Orleans.Persistence.Memory\Storage\HierarchicalKeyStore.cs, Line: 82, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #150 Path: D:\a\1\s\src\Orleans.Persistence.Memory\Storage\StorageProviderUtils.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.EventSourcing(net5.0)
    #151 Path: D:\a\1\s\src\Orleans.EventSourcing\Common\PrimaryBasedLogViewAdaptor.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\src\Orleans.EventSourcing\Common\PrimaryBasedLogViewAdaptor.cs, Line: 107, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #153 Path: D:\a\1\s\src\Orleans.EventSourcing\Common\PrimaryBasedLogViewAdaptor.cs, Line: 435, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #154 Path: D:\a\1\s\src\Orleans.EventSourcing\Common\PrimaryBasedLogViewAdaptor.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #155 Path: D:\a\1\s\src\Orleans.EventSourcing\Common\StringEncodedWriteVector.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #156 Path: D:\a\1\s\src\Orleans.EventSourcing\CustomStorage\LogViewAdaptor.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #157 Path: D:\a\1\s\src\Orleans.EventSourcing\CustomStorage\LogViewAdaptor.cs, Line: 278, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\src\Orleans.EventSourcing\LogConsistency\ProtocolServices.cs, Line: 46, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #159 Path: D:\a\1\s\src\Orleans.EventSourcing\LogConsistency\ProtocolServices.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #160 Path: D:\a\1\s\src\Orleans.EventSourcing\LogConsistency\ProtocolServices.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #161 Path: D:\a\1\s\src\Orleans.EventSourcing\LogConsistency\ProtocolServices.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #162 Path: D:\a\1\s\src\Orleans.EventSourcing\LogConsistency\ProtocolServices.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #163 Path: D:\a\1\s\src\Orleans.EventSourcing\LogStorage\LogStateWithMetaData.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #164 Path: D:\a\1\s\src\Orleans.EventSourcing\LogStorage\LogViewAdaptor.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\src\Orleans.EventSourcing\LogStorage\LogViewAdaptor.cs, Line: 278, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\src\Orleans.EventSourcing\LogStorage\LogViewAdaptor.cs, Line: 279, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\Orleans.EventSourcing\LogStorage\LogViewAdaptor.cs, Line: 302, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\src\Orleans.EventSourcing\StateStorage\GrainStateWithMetaData.cs, Line: 64, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\src\Orleans.EventSourcing\StateStorage\LogViewAdaptor.cs, Line: 238, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\src\Orleans.EventSourcing\StateStorage\LogViewAdaptor.cs, Line: 248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #171 Path: D:\a\1\s\src\Orleans.EventSourcing\StateStorage\LogViewAdaptor.cs, Line: 249, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\src\Orleans.EventSourcing\StateStorage\LogViewAdaptor.cs, Line: 272, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Orleans.Streaming.EventHubs(net5.0)
    #173 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #174 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #175 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #177 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #178 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.TestingHost(net5.0)
    #179 Path: D:\a\1\s\src\Orleans.TestingHost\Logging\FileLogger.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #180 Path: D:\a\1\s\src\Orleans.TestingHost\Logging\FileLogger.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: TestGrains
    #181 Path: D:\a\1\s\test\Grains\TestGrains\AdoNet\CustomerGrain.cs, Line: 21, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #182 Path: D:\a\1\s\test\Grains\TestGrains\ChainedGrain.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #183 Path: D:\a\1\s\test\Grains\TestGrains\DeadlockGrain.cs, Line: 42, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #184 Path: D:\a\1\s\test\Grains\TestGrains\DeadlockGrain.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #185 Path: D:\a\1\s\test\Grains\TestGrains\EventSourcing\ChatFormat.cs, Line: 21, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #186 Path: D:\a\1\s\test\Grains\TestGrains\EventSourcing\ChatFormat.cs, Line: 46, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #187 Path: D:\a\1\s\test\Grains\TestGrains\EventSourcing\PersonGrain.cs, Line: 31, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #188 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 117, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #189 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 172, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #191 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #192 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #193 Path: D:\a\1\s\test\Grains\TestGrains\GenericGrains.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #194 Path: D:\a\1\s\test\Grains\TestGrains\LogTestGrain.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #195 Path: D:\a\1\s\test\Grains\TestGrains\MethodInterceptionGrain.cs, Line: 97, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\test\Grains\TestGrains\MultipleSubscriptionConsumerGrain.cs, Line: 124, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #197 Path: D:\a\1\s\test\Grains\TestGrains\MultipleSubscriptionConsumerGrain.cs, Line: 161, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #198 Path: D:\a\1\s\test\Grains\TestGrains\SimpleGenericGrain.cs, Line: 33, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #199 Path: D:\a\1\s\test\Grains\TestGrains\SimpleObserverableGrain.cs, Line: 22, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: TestInternalGrains
    #200 Path: D:\a\1\s\test\Grains\TestInternalGrains\CollectionTestGrain.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #201 Path: D:\a\1\s\test\Grains\TestInternalGrains\CollectionTestGrain.cs, Line: 29, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #202 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 606, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #203 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 904, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #204 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 911, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #205 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 915, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #206 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 919, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #207 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 922, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #208 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 935, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #209 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 938, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #210 Path: D:\a\1\s\test\Grains\TestInternalGrains\PersistenceTestGrains.cs, Line: 940, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #211 Path: D:\a\1\s\test\Grains\TestInternalGrains\ReminderTestGrain2.cs, Line: 155, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #212 Path: D:\a\1\s\test\Grains\TestInternalGrains\ReminderTestGrain2.cs, Line: 206, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #213 Path: D:\a\1\s\test\Grains\TestInternalGrains\ReminderTestGrain2.cs, Line: 392, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #214 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 245, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #215 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #216 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #217 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 32, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #218 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 446, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #219 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #220 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamingGrain.cs, Line: 910, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #221 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamLifecycleTestGrains.cs, Line: 414, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #222 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamLifecycleTestGrains.cs, Line: 425, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #223 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamReliabilityTestGrains.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #224 Path: D:\a\1\s\test\Grains\TestInternalGrains\StreamReliabilityTestGrains.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #225 Path: D:\a\1\s\test\Grains\TestInternalGrains\TimerGrain.cs, Line: 171, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #226 Path: D:\a\1\s\test\Grains\TestInternalGrains\TimerGrain.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #227 Path: D:\a\1\s\test\Grains\TestInternalGrains\TimerGrain.cs, Line: 238, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #228 Path: D:\a\1\s\test\Grains\TestInternalGrains\TimerGrain.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: TestExtensions(net5.0)
    #229 Path: D:\a\1\s\test\TestInfrastructure\TestExtensions\MockStorageProvider.cs, Line: 96, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #230 Path: D:\a\1\s\test\TestInfrastructure\TestExtensions\TestUtils.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tester(net5.0)
    #231 Path: D:\a\1\s\test\Tester\EventSourcingTests\AccountGrainTests.cs, Line: 49, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #232 Path: D:\a\1\s\test\Tester\EventSourcingTests\CountersGrainPerfTests.cs, Line: 112, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #233 Path: D:\a\1\s\test\Tester\MembershipTests\LivenessTests.cs, Line: 64, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: TesterInternal(net5.0)
    #234 Path: D:\a\1\s\test\TesterInternal\ActivationsLifeCycleTests\ActivationCollectorTests.cs, Line: 450, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #235 Path: D:\a\1\s\test\TesterInternal\ActivationsLifeCycleTests\ActivationCollectorTests.cs, Line: 473, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #236 Path: D:\a\1\s\test\TesterInternal\General\ConsistentRingProviderTests_Silo.cs, Line: 221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #237 Path: D:\a\1\s\test\TesterInternal\General\ElasticPlacementTest.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #238 Path: D:\a\1\s\test\TesterInternal\LivenessTests\ConsistentRingProviderTests.cs, Line: 96, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #239 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\DisabledCallChainReentrancyTestRunner.cs, Line: 107, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #240 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\DisabledCallChainReentrancyTestRunner.cs, Line: 41, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #241 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\DisabledCallChainReentrancyTestRunner.cs, Line: 74, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #242 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\ReentrancyTests.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #243 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\ReentrancyTests.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #244 Path: D:\a\1\s\test\TesterInternal\MessageScheduling\ReentrancyTests.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #245 Path: D:\a\1\s\test\TesterInternal\OrleansRuntime\Streams\FixedSizeBufferTests.cs, Line: 63, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #246 Path: D:\a\1\s\test\TesterInternal\OrleansRuntime\Streams\FixedSizeBufferTests.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #247 Path: D:\a\1\s\test\TesterInternal\StreamingTests\StreamTestUtils.cs, Line: 79, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #248 Path: D:\a\1\s\test\TesterInternal\TimerTests\ReminderTests_Base.cs, Line: 408, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: AWSUtils.Tests(net5.0)
    #249 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #250 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #251 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\Base_PersistenceGrainTests_AWSStore.cs, Line: 401, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #252 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\DynamoDBStorageProviderTests.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #253 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\DynamoDBStorageProviderTests.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #254 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\DynamoDBStorageProviderTests.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #255 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\DynamoDBStorageProviderTests.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #256 Path: D:\a\1\s\test\Extensions\AWSUtils.Tests\StorageTests\DynamoDBStorageProviderTests.cs, Line: 91, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: DefaultCluster.Tests(net5.0)
    #257 Path: D:\a\1\s\test\DefaultCluster.Tests\ErrorGrainTest.cs, Line: 225, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #258 Path: D:\a\1\s\test\DefaultCluster.Tests\ErrorGrainTest.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #259 Path: D:\a\1\s\test\DefaultCluster.Tests\GenericGrainTests.cs, Line: 368, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #260 Path: D:\a\1\s\test\DefaultCluster.Tests\GenericGrainTests.cs, Line: 388, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #261 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 143, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #262 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 170, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 175, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #265 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 263, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #266 Path: D:\a\1\s\test\DefaultCluster.Tests\ObserverTests.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: ProtoBuf.Serialization.Tests(net5.0)
    #267 Path: D:\a\1\s\test\Extensions\Serializers\ProtoBuf.Serialization.Tests\OrleansType.cs, Line: 21, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: NonSilo.Tests(net5.0)
    #268 Path: D:\a\1\s\test\NonSilo.Tests\General\RingTests_Standalone.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #269 Path: D:\a\1\s\test\NonSilo.Tests\General\RingTests_Standalone.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #270 Path: D:\a\1\s\test\NonSilo.Tests\General\RingTests_Standalone.cs, Line: 211, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #271 Path: D:\a\1\s\test\NonSilo.Tests\SchedulerTests\OrleansTaskSchedulerAdvancedTests.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #272 Path: D:\a\1\s\test\NonSilo.Tests\SchedulerTests\OrleansTaskSchedulerAdvancedTests.cs, Line: 158, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tester.AzureUtils(net5.0)
    #273 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AsyncPipelineTests.cs, Line: 174, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #274 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AsyncPipelineTests.cs, Line: 177, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #275 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AsyncPipelineTests.cs, Line: 185, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #276 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AzureQueueDataManagerTests.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #277 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AzureQueueDataManagerTests.cs, Line: 170, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #278 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\AzureQueueDataManagerTests.cs, Line: 87, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #279 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceGrainTests_AzureStore.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #280 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #281 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #282 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #283 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #284 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Persistence\PersistenceProviderTests.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #285 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Reminder\ReminderTests_Azure_Standalone.cs, Line: 135, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #286 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Reminder\ReminderTests_Azure_Standalone.cs, Line: 143, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #287 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Reminder\ReminderTests_Azure_Standalone.cs, Line: 97, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #288 Path: D:\a\1\s\test\Extensions\TesterAzureUtils\Streaming\StreamLifecycleTests.cs, Line: 224, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tester.AdoNet(net5.0)
    #289 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #290 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #291 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #292 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 59, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #293 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #295 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #296 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #297 Path: D:\a\1\s\test\Extensions\TesterAdoNet\RelationalUtilities\SqlServerStorageForTesting.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #298 Path: D:\a\1\s\test\Extensions\TesterAdoNet\StorageTests\RelationalStoreTests.cs, Line: 190, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Core.Abstractions(net5.0)
    #299 Path: D:\a\1\s\src\Orleans.Core.Abstractions\CodeGeneration\GrainFactoryBase.cs, Line: 32, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #300 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs, Line: 19, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #301 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs, Line: 22, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #302 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #303 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Core\GrainExtensions.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #304 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Exceptions\DeadlockException.cs, Line: 49, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #305 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Exceptions\LimitExceededException.cs, Line: 25, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #306 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\ActivationAddress.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #307 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\ActivationId.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #308 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\Legacy\LegacyGrainId.cs, Line: 265, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\Legacy\LegacyGrainId.cs, Line: 333, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #310 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\Legacy\UniqueKey.cs, Line: 155, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #311 Path: D:\a\1\s\src\Orleans.Core.Abstractions\IDs\SiloAddress.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #312 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Placement\StatelessWorkerPlacement.cs, Line: 34, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #313 Path: D:\a\1\s\src\Orleans.Core.Abstractions\Timers\IRemindable.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Transactions.AzureStorage(net5.0)
    #314 Path: D:\a\1\s\src\Azure\Orleans.Transactions.AzureStorage\TransactionalState\StateEntity.cs, Line: 166, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #316 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #317 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #319 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #320 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Clustering.AzureStorage(net5.0)
    #321 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\AzureBasedMembershipTable.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #322 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 136, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #323 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #324 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 162, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #325 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 237, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #327 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 240, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #328 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 251, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #329 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 255, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #330 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 257, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #331 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 270, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #332 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\OrleansSiloInstanceManager.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #333 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\SiloInstanceTableEntry.cs, Line: 39, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #334 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\SiloInstanceTableEntry.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #335 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\SiloInstanceTableEntry.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #336 Path: D:\a\1\s\src\Azure\Orleans.Clustering.AzureStorage\SiloInstanceTableEntry.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #337 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #338 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #339 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #341 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #342 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Persistence.AzureStorage(net5.0)
    #343 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureBlobStorage.cs, Line: 106, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #344 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureBlobStorage.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #345 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureBlobStorage.cs, Line: 138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #346 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureBlobStorage.cs, Line: 171, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #347 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs, Line: 154, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #348 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs, Line: 230, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #349 Path: D:\a\1\s\src\Azure\Orleans.Persistence.AzureStorage\Providers\Storage\AzureTableStorage.cs, Line: 389, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #350 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #351 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #352 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #354 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #355 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Reminders.AzureStorage(net5.0)
    #356 Path: D:\a\1\s\src\Azure\Orleans.Reminders.AzureStorage\Storage\AzureBasedReminderTable.cs, Line: 114, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #357 Path: D:\a\1\s\src\Azure\Orleans.Reminders.AzureStorage\Storage\RemindersTableManager.cs, Line: 29, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #358 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #359 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #360 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #361 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #363 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Streaming.AzureStorage(net5.0)
    #364 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Providers\Streams\AzureQueue\AzureQueueBatchContainer.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 392, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #366 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 398, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #367 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 404, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #368 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 410, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #369 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 416, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #370 Path: D:\a\1\s\src\Azure\Orleans.Streaming.AzureStorage\Storage\AzureQueueDataManager.cs, Line: 422, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #371 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #372 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #373 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #375 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #376 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Hosting.AzureCloudServices(net5.0)
    #377 Path: D:\a\1\s\src\Azure\Orleans.Hosting.AzureCloudServices\Hosting\ServiceRuntimeWrapper.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Clustering.DynamoDB(net5.0)
    #378 Path: D:\a\1\s\src\AWS\Orleans.Clustering.DynamoDB\Membership\DynamoDBMembershipTable.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #379 Path: D:\a\1\s\src\AWS\Orleans.Clustering.DynamoDB\Membership\DynamoDBMembershipTable.cs, Line: 474, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #380 Path: D:\a\1\s\src\AWS\Orleans.Clustering.DynamoDB\Membership\SiloInstanceRecord.cs, Line: 153, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #381 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #382 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Persistence.DynamoDB(net5.0)
    #383 Path: D:\a\1\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #384 Path: D:\a\1\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #385 Path: D:\a\1\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #386 Path: D:\a\1\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs, Line: 382, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #387 Path: D:\a\1\s\src\AWS\Orleans.Persistence.DynamoDB\Provider\DynamoDBGrainStorage.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #388 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #389 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Reminders.DynamoDB(net5.0)
    #390 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #391 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Streaming.SQS(net5.0)
    #392 Path: D:\a\1\s\src\AWS\Orleans.Streaming.SQS\Streams\SQSBatchContainer.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #394 Path: D:\a\1\s\src\AWS\Shared\AWSUtils.cs, Line: 56, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Clustering.AdoNet(net5.0)
    #395 Path: D:\a\1\s\src\AdoNet\Orleans.Clustering.AdoNet\Messaging\AdoNetClusteringTable.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #396 Path: D:\a\1\s\src\AdoNet\Orleans.Clustering.AdoNet\Messaging\AdoNetClusteringTable.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #397 Path: D:\a\1\s\src\AdoNet\Orleans.Clustering.AdoNet\Messaging\AdoNetClusteringTable.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #398 Path: D:\a\1\s\src\AdoNet\Orleans.Clustering.AdoNet\Messaging\AdoNetClusteringTable.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #399 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #400 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #401 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #402 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 59, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #403 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #404 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #405 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #406 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Persistence.AdoNet(net5.0)
    #407 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #408 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #409 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #410 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 59, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #411 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #412 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #413 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #414 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Reminders.AdoNet(net5.0)
    #415 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #416 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #417 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #418 Path: D:\a\1\s\src\AdoNet\Shared\Storage\AdoNetFormatProvider.cs, Line: 59, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #419 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #420 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #421 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #422 Path: D:\a\1\s\src\AdoNet\Shared\Storage\RelationalStorageExtensions.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.GrainDirectory.AzureStorage(net5.0)
    #423 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableDataManager.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #424 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #425 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #426 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 285, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #427 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #428 Path: D:\a\1\s\src\Azure\Shared\Storage\AzureTableUtils.cs, Line: 306, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Streaming.Abstractions(net5.0)
    #429 Path: D:\a\1\s\src\Orleans.Streaming.Abstractions\LegacyStreamId.cs, Line: 92, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.Streaming(net5.0)
    #430 Path: D:\a\1\s\src\Orleans.Streaming\Common\EventSequenceToken.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #431 Path: D:\a\1\s\src\Orleans.Streaming\Common\EventSequenceTokenV2.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #432 Path: D:\a\1\s\src\Orleans.Streaming\Internal\StreamImpl.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #433 Path: D:\a\1\s\src\Orleans.Streaming\Internal\StreamImpl.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #434 Path: D:\a\1\s\src\Orleans.Streaming\Internal\StreamSubscriptionHandleImpl.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #435 Path: D:\a\1\s\src\Orleans.Streaming\Internal\StreamSubscriptionHandleImpl.cs, Line: 251, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #436 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamProvider.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #437 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 272, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #438 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #439 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 340, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #440 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 354, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #441 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #442 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 387, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #443 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\PersistentStreamPullingManager.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #444 Path: D:\a\1\s\src\Orleans.Streaming\PersistentStreams\QueueStreamDataStructures.cs, Line: 41, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #445 Path: D:\a\1\s\src\Orleans.Streaming\PubSub\PubSubPublisherState.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #446 Path: D:\a\1\s\src\Orleans.Streaming\PubSub\PubSubRendezvousGrain.cs, Line: 315, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\src\Orleans.Streaming\PubSub\PubSubSubscriptionState.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #448 Path: D:\a\1\s\src\Orleans.Streaming\QueueBalancer\BestFitBalancer.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #449 Path: D:\a\1\s\src\Orleans.Streaming\SimpleMessageStream\SimpleMessageStreamProducer.cs, Line: 100, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #450 Path: D:\a\1\s\src\Orleans.Streaming\SimpleMessageStream\SimpleMessageStreamProducer.cs, Line: 126, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #451 Path: D:\a\1\s\src\Orleans.Streaming\SimpleMessageStream\SimpleMessageStreamProducer.cs, Line: 136, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #452 Path: D:\a\1\s\src\Orleans.Streaming\SimpleMessageStream\SimpleMessageStreamProducer.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Orleans.CodeGenerator.MSBuild
    #453 Path: D:\a\1\s\src\Orleans.CodeGenerator.MSBuild\LogFormatter.cs, Line: 40, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



--- Rules Summary ---
R9: 367
R8: 42
R5: 20
R7: 10
R2: 8
R6: 3
R4: 3

--- Summary ---
Fixed ReSharper issues: 445
Fixed SonarQube issues: 26
Total fixed issues: 453

Finished in: 1 min 8 s

######################################################################
Nr: 1 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\src\Orleans.Core\Serialization\BuiltInTypes.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using Orleans.CodeGeneration;
using Orleans.Concurrency;
using Orleans.Runtime;
using Orleans.Utilities;

namespace Orleans.Serialization
{
    internal static class BuiltInTypes
    {
        private static readonly Type objectType = typeof(object);

        internal static void SerializeGenericReadOnlyCollection(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericReadOnlyCollection(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericReadOnlyCollection(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeReadOnlyCollection<T>(object obj, ISerializationContext context, Type expected)
        {
            var collection = (ReadOnlyCollection<T>)obj;
            context.StreamWriter.Write(collection.Count);
            foreach (var element in collection)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeReadOnlyCollection<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);

            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }

            var ret = new ReadOnlyCollection<T>(list);
            context.RecordObject(ret);
            return ret;
        }

        internal static object DeepCopyReadOnlyCollection<T>(object original, ICopyContext context)
        {
            var collection = (ReadOnlyCollection<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return original;
            }

            var innerList = new List<T>(collection.Count);
            foreach (var element in collection)
            {
                innerList.Add((T)SerializationManager.DeepCopyInner(element, context));
            }

            var retVal = new ReadOnlyCollection<T>(innerList);
            context.RecordCopy(original, retVal);
            return retVal;
        }

        internal static void SerializeGenericList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericList(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeList<T>(object obj, ISerializationContext context, Type expected)
        {
            var list = (List<T>)obj;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);
            context.RecordObject(list);

            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return list;
        }

        internal static object DeepCopyList<T>(object original, ICopyContext context)
        {
            var list = (List<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new List<T>(list);
            }

            // set the list capacity, to avoid list resizing.
            var retVal = new List<T>(list.Count);
            context.RecordCopy(original, retVal);
            foreach (var element in list)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(element, context));
            }

            return retVal;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="original"></param>
        /// <param name="context"></param>
        /// <param name="expected"></param>
        internal static void SerializeGenericLinkedList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericLinkedList(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericLinkedList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeLinkedList<T>(object obj, ISerializationContext context, Type expected)
        {
            var list = (LinkedList<T>)obj;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeLinkedList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new LinkedList<T>();
            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                list.AddLast((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return list;
        }

        internal static object DeepCopyLinkedList<T>(object original, ICopyContext context)
        {
            var list = (LinkedList<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new LinkedList<T>(list);
            }

            var retVal = new LinkedList<T>();
            context.RecordCopy(original, retVal);
            foreach (var item in list)
            {
                retVal.AddLast((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericHashSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericHashSet(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericHashSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeHashSet<T>(object obj, ISerializationContext context, Type expected)
        {
            var set = (HashSet<T>)obj;
            SerializationManager.SerializeInner(set.Comparer.Equals(EqualityComparer<T>.Default) ? null : set.Comparer,
                context, typeof(IEqualityComparer<T>));
            context.StreamWriter.Write(set.Count);
            foreach (var element in set)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeHashSet<T>(Type expected, IDeserializationContext context)
        {
            var comparer =
                (IEqualityComparer<T>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<T>), context);
            var count = context.StreamReader.ReadInt();
            var set = new HashSet<T>(comparer);
            context.RecordObject(set);
            for (var i = 0; i < count; i++)
            {
                set.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return set;
        }

        internal static object DeepCopyHashSet<T>(object original, ICopyContext context)
        {
            var set = (HashSet<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new HashSet<T>(set, set.Comparer);
            }

            var retVal = new HashSet<T>(set.Comparer);
            context.RecordCopy(original, retVal);
            foreach (var item in set)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericSortedSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedSet(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericSortedSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeSortedSet<T>(object obj, ISerializationContext context, Type expected)
        {
            var set = (SortedSet<T>)obj;
            SerializationManager.SerializeInner(set.Comparer.Equals(Comparer<T>.Default) ? null : set.Comparer,
                context, typeof(IComparer<T>));
            context.StreamWriter.Write(set.Count);
            foreach (var element in set)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeSortedSet<T>(Type expected, IDeserializationContext context)
        {
            var comparer =
                (IComparer<T>)SerializationManager.DeserializeInner(typeof(IComparer<T>), context);
            var count = context.StreamReader.ReadInt();
            var set = new SortedSet<T>(comparer);
            context.RecordObject(set);
            for (var i = 0; i < count; i++)
            {
                set.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return set;
        }

        internal static object DeepCopySortedSet<T>(object original, ICopyContext context)
        {
            var set = (SortedSet<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new SortedSet<T>(set, set.Comparer);
            }

            var retVal = new SortedSet<T>(set.Comparer);
            context.RecordCopy(original, retVal);
            foreach (var item in set)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericQueue(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericQueue(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericQueue(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeQueue<T>(object obj, ISerializationContext context, Type expected)
        {
            var queue = (Queue<T>)obj;
            context.StreamWriter.Write(queue.Count);
            foreach (var element in queue)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeQueue<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var queue = new Queue<T>();
            context.RecordObject(queue);
            for (var i = 0; i < count; i++)
            {
                queue.Enqueue((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return queue;
        }

        internal static object DeepCopyQueue<T>(object original, ICopyContext context)
        {
            var queue = (Queue<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new Queue<T>(queue);
            }

            var retVal = new Queue<T>(queue.Count);
            context.RecordCopy(original, retVal);
            foreach (var item in queue)
            {
                retVal.Enqueue((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericStack(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericStack(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericStack(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeStack<T>(object obj, ISerializationContext context, Type expected)
        {
            var stack = (Stack<T>)obj;
            context.StreamWriter.Write(stack.Count);
            foreach (var element in stack)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeStack<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);
            var stack = new Stack<T>(count);
            context.RecordObject(stack);
            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }

            for (var i = count - 1; i >= 0; i--)
            {
                stack.Push(list[i]);
            }

            return stack;
        }

        internal static object DeepCopyStack<T>(object original, ICopyContext context)
        {
            var stack = (Stack<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new Stack<T>(stack.Reverse()); // NOTE: Yes, the Reverse really is required
            }

            var retVal = new Stack<T>();
            context.RecordCopy(original, retVal);
            foreach (var item in stack.Reverse())
            {
                retVal.Push((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();

            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (Dictionary<K, V>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(EqualityComparer<K>.Default) ? null : dict.Comparer,
                                           context, typeof(IEqualityComparer<K>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IEqualityComparer<K>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<K, V>(count, comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopyDictionary<K, V>(object original, ICopyContext context)
        {
            var dict = (Dictionary<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new Dictionary<K, V>(dict, dict.Comparer);
            }

            var result = new Dictionary<K, V>(dict.Count, dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericReadOnlyDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericReadOnlyDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericReadOnlyDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeReadOnlyDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (ReadOnlyDictionary<K, V>)original;
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeReadOnlyDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<K, V>(count);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }

            var retVal = new ReadOnlyDictionary<K, V>(dict);
            context.RecordObject(retVal);
            return retVal;
        }

        internal static object CopyReadOnlyDictionary<K, V>(object original, ICopyContext context)
        {
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return original;
            }

            var dict = (ReadOnlyDictionary<K, V>)original;
            var innerDict = new Dictionary<K, V>(dict.Count);
            foreach (var pair in dict)
            {
                innerDict[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            var retVal = new ReadOnlyDictionary<K, V>(innerDict);
            context.RecordCopy(original, retVal);
            return retVal;
        }

        internal static void SerializeStringObjectDictionary(object original, ISerializationContext context, Type expected)
        {
            var dict = (Dictionary<string, object>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(EqualityComparer<string>.Default) ? null : dict.Comparer,
                                           context, typeof(IEqualityComparer<string>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                //context.Stream.WriteTypeHeader(stringType, stringType);
                context.StreamWriter.Write(pair.Key);
                SerializationManager.SerializeInner(pair.Value, context, objectType);
            }
        }

        internal static object DeserializeStringObjectDictionary(Type expected, IDeserializationContext context)
        {
            var comparer = (IEqualityComparer<string>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<string>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<string, object>(count, comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                //context.Stream.ReadFullTypeHeader(stringType); // Skip the type header, which will be string
                var key = context.StreamReader.ReadString();
                var value = SerializationManager.DeserializeInner(null, context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopyStringObjectDictionary(object original, ICopyContext context)
        {
            var dict = (Dictionary<string, object>)original;
            var result = new Dictionary<string, object>(dict.Count, dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[pair.Key] = SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericSortedDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericSortedDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeSortedDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (SortedDictionary<K, V>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(Comparer<K>.Default) ? null : dict.Comparer, context, typeof(IComparer<K>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeSortedDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IComparer<K>)SerializationManager.DeserializeInner(typeof(IComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new SortedDictionary<K, V>(comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopySortedDictionary<K, V>(object original, ICopyContext context)
        {
            var dict = (SortedDictionary<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new SortedDictionary<K, V>(dict, dict.Comparer);
            }

            var result = new SortedDictionary<K, V>(dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericSortedList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedList(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericSortedList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeSortedList<K, V>(object original, ISerializationContext context, Type expected)
        {
            var list = (SortedList<K, V>)original;
            SerializationManager.SerializeInner(list.Comparer.Equals(Comparer<K>.Default) ? null : list.Comparer, context, typeof(IComparer<K>));
            context.StreamWriter.Write(list.Count);
            foreach (var pair in list)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeSortedList<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IComparer<K>)SerializationManager.DeserializeInner(typeof(IComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var list = new SortedList<K, V>(count, comparer);
            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                list[key] = value;
            }
            return list;
        }

        internal static object CopySortedList<K, V>(object original, ICopyContext context)
        {
            var list = (SortedList<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new SortedList<K, V>(list, list.Comparer);
            }

            var result = new SortedList<K, V>(list.Count, list.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in list)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericImmutableDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutableDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static object CopyImmutableDictionary<K, V>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableDictionary<K, V>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableDictionary<K, V>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(EqualityComparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IEqualityComparer<K>));
            SerializationManager.SerializeInner(dict.ValueComparer.Equals(EqualityComparer<V>.Default) ? null : dict.ValueComparer, context, typeof(IEqualityComparer<V>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeImmutableDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IEqualityComparer<K>>(context);
            var valueComparer = SerializationManager.DeserializeInner<IEqualityComparer<V>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableDictionary.CreateBuilder(keyComparer, valueComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                var value = SerializationManager.DeserializeInner<V>(context);
                dictBuilder.Add(key, value);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static void SerializeGenericImmutableList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableList(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutableList(object original, ICopyContext context)
        {
            var t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeImmutableList<T>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var list = (ImmutableList<T>)untypedInput;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeImmutableList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var listBuilder = ImmutableList.CreateBuilder<T>();

            for (var i = 0; i < count; i++)
            {
                listBuilder.Add(SerializationManager.DeserializeInner<T>(context));
            }
            var list = listBuilder.ToImmutable();
            context.RecordObject(list);
            return list;
        }

        internal static object CopyImmutableList<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static object CopyGenericImmutableHashSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeGenericImmutableHashSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableHashSet(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            return concreteMethods.Item2(expected, context);
        }
        
        internal static object CopyImmutableHashSet<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableHashSet<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableHashSet<K>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(EqualityComparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IEqualityComparer<K>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableHashSet<K>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IEqualityComparer<K>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableHashSet.CreateBuilder(keyComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                dictBuilder.Add(key);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableSortedSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableSortedSet(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableSortedSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableSortedSet<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableSortedSet<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableSortedSet<K>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(Comparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IComparer<K>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableSortedSet<K>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IComparer<K>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableSortedSet.CreateBuilder(keyComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                dictBuilder.Add(key);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableSortedDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableSortedDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableSortedDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableSortedDictionary<K, V>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableSortedDictionary<K, V>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableSortedDictionary<K, V>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(Comparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IComparer<K>));
            SerializationManager.SerializeInner(dict.ValueComparer.Equals(EqualityComparer<V>.Default) ? null : dict.ValueComparer, context, typeof(IEqualityComparer<V>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeImmutableSortedDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IComparer<K>>(context);
            var valueComparer = SerializationManager.DeserializeInner<IEqualityComparer<V>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableSortedDictionary.CreateBuilder(keyComparer, valueComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                var value = SerializationManager.DeserializeInner<V>(context);
                dictBuilder.Add(key, value);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableArray(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableArray(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableArray(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableArray<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableArray<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var array = (ImmutableArray<K>)untypedInput;

            if (array == default)
            {
                context.StreamWriter.Write(-1);
                return;
            }

            context.StreamWriter.Write(array.Length);
            foreach (var element in array)
            {
                SerializationManager.SerializeInner(element, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableArray<K>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();

            if (count == -1)
            {
                context.RecordObject(default(ImmutableArray<K>));
                return default(ImmutableArray<K>);
            }

            var builder = ImmutableArray.CreateBuilder<K>();
            for (var i = 0; i < count; i++)
            {
                var element = SerializationManager.DeserializeInner<K>(context);
                builder.Add(element);
            }
            var array = builder.ToImmutable();
            context.RecordObject(array);

            return array;
        }
        internal static object CopyGenericImmutableQueue(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableQueue(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableQueue(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableQueue<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableQueue<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var queue = (ImmutableQueue<K>)untypedInput;

            context.StreamWriter.Write(queue.Count());
            foreach (var item in queue)
            {
                SerializationManager.SerializeInner(item, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableQueue<K>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var items = new K[count];
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                items[i] = key;
            }
            var queues = ImmutableQueue.CreateRange(items);

            context.RecordObject(queues);

            return queues;
        }

        internal static void SerializeTuple(object raw, ISerializationContext context, Type expected)
        {
            Type t = raw.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            concretes.Item1(raw, context, expected);
        }

        internal static object DeserializeTuple(Type t, IDeserializationContext context)
        {
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            return concretes.Item2(t, context);
        }

        internal static object DeepCopyTuple(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            return concretes.Item3(original, context);
        }

        internal static object DeepCopyTuple1<T1>(object original, ICopyContext context)
        {
            var input = (Tuple<T1>)original;
            var result = new Tuple<T1>((T1)SerializationManager.DeepCopyInner(input.Item1, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple1<T1>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
        }

        internal static object DeserializeTuple1<T1>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            return new Tuple<T1>(item1);
        }

        internal static object DeepCopyTuple2<T1, T2>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2>)original;
            var result = new Tuple<T1, T2>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple2<T1, T2>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
        }

        internal static object DeserializeTuple2<T1, T2>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            return new Tuple<T1, T2>(item1, item2);
        }

        internal static object DeepCopyTuple3<T1, T2, T3>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3>)original;
            var result = new Tuple<T1, T2, T3>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple3<T1, T2, T3>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
        }

        internal static object DeserializeTuple3<T1, T2, T3>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            return new Tuple<T1, T2, T3>(item1, item2, item3);
        }

        internal static object DeepCopyTuple4<T1, T2, T3, T4>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4>)original;
            var result = new Tuple<T1, T2, T3, T4>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple4<T1, T2, T3, T4>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
        }

        internal static object DeserializeTuple4<T1, T2, T3, T4>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);
        }

        internal static object DeepCopyTuple5<T1, T2, T3, T4, T5>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5>)original;
            var result = new Tuple<T1, T2, T3, T4, T5>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple5<T1, T2, T3, T4, T5>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
        }

        internal static object DeserializeTuple5<T1, T2, T3, T4, T5>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
        }

        internal static object DeepCopyTuple6<T1, T2, T3, T4, T5, T6>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6>)original;
            var result = new Tuple<T1, T2, T3, T4, T5, T6>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple6<T1, T2, T3, T4, T5, T6>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
        }

        internal static object DeserializeTuple6<T1, T2, T3, T4, T5, T6>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
        }

        internal static object DeepCopyTuple7<T1, T2, T3, T4, T5, T6, T7>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6, T7>)original;
            var result = new Tuple<T1, T2, T3, T4, T5, T6, T7>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple7<T1, T2, T3, T4, T5, T6, T7>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6, T7>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
        }

        internal static object DeserializeTuple7<T1, T2, T3, T4, T5, T6, T7>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
        }

        internal static void SerializeValueTuple(object raw, ISerializationContext context, Type expected)
        {
            Type t = raw.GetType();
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            concretes.Item1(raw, context, expected);
        }

        internal static object DeserializeValueTuple(Type t, IDeserializationContext context)
        {
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            return concretes.Item2(t, context);
        }

        internal static object DeepCopyValueTuple(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            return concretes.Item3(original, context);
        }

        internal static object DeepCopyValueTuple1<T1>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1>)original;
            var result = new ValueTuple<T1>((T1)SerializationManager.DeepCopyInner(input.Item1, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple1<T1>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
        }

        internal static object DeserializeValueTuple1<T1>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            return new ValueTuple<T1>(item1);
        }

        internal static object DeepCopyValueTuple2<T1, T2>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2>)original;
            var result = new ValueTuple<T1, T2>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple2<T1, T2>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
        }

        internal static object DeserializeValueTuple2<T1, T2>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            return new ValueTuple<T1, T2>(item1, item2);
        }

        internal static object DeepCopyValueTuple3<T1, T2, T3>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3>)original;
            var result = new ValueTuple<T1, T2, T3>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple3<T1, T2, T3>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
        }

        internal static object DeserializeValueTuple3<T1, T2, T3>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            return new ValueTuple<T1, T2, T3>(item1, item2, item3);
        }

        internal static object DeepCopyValueTuple4<T1, T2, T3, T4>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4>)original;
            var result = new ValueTuple<T1, T2, T3, T4>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple4<T1, T2, T3, T4>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
        }

        internal static object DeserializeValueTuple4<T1, T2, T3, T4>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);
        }

        internal static object DeepCopyValueTuple5<T1, T2, T3, T4, T5>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple5<T1, T2, T3, T4, T5>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
        }

        internal static object DeserializeValueTuple5<T1, T2, T3, T4, T5>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
        }

        internal static object DeepCopyValueTuple6<T1, T2, T3, T4, T5, T6>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple6<T1, T2, T3, T4, T5, T6>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
        }

        internal static object DeserializeValueTuple6<T1, T2, T3, T4, T5, T6>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
        }

        internal static object DeepCopyValueTuple7<T1, T2, T3, T4, T5, T6, T7>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple7<T1, T2, T3, T4, T5, T6, T7>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
        }

        internal static object DeserializeValueTuple7<T1, T2, T3, T4, T5, T6, T7>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
        }

        internal static object DeepCopyValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(object original, ICopyContext context) where T8 : struct
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context),
                (T8)SerializationManager.DeepCopyInner(input.Rest, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(object obj, ISerializationContext context, Type expected) where T8 : struct
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
            SerializationManager.SerializeInner(input.Rest, context, typeof(T8));
        }

        internal static object DeserializeValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(Type expected, IDeserializationContext context) where T8 : struct
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            var rest = (T8)SerializationManager.DeserializeInner(typeof(T8), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(item1, item2, item3, item4, item5, item6, item7, rest);
        }

        internal static void SerializeGenericKeyValuePair(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericKeyValuePair(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericKeyValuePair(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeKeyValuePair<TK, TV>(object original, ISerializationContext context, Type expected)
        {
            var pair = (KeyValuePair<TK, TV>)original;
            SerializationManager.SerializeInner(pair.Key, context, typeof(TK));
            SerializationManager.SerializeInner(pair.Value, context, typeof(TV));
        }

        internal static object DeserializeKeyValuePair<K, V>(Type expected, IDeserializationContext context)
        {
            var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
            var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
            return new KeyValuePair<K, V>(key, value);
        }

        internal static object CopyKeyValuePair<TK, TV>(object original, ICopyContext context)
        {
            var pair = (KeyValuePair<TK, TV>)original;
            if (typeof(TK).IsOrleansShallowCopyable() && typeof(TV).IsOrleansShallowCopyable())
            {
                return pair;    // KeyValuePair is a struct, so there's already been a copy at this point
            }

            var result = new KeyValuePair<TK, TV>((TK)SerializationManager.DeepCopyInner(pair.Key, context), (TV)SerializationManager.DeepCopyInner(pair.Value, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeGenericNullable(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericNullable(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericNullable(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeNullable<T>(object original, ISerializationContext context, Type expected) where T : struct
        {
            var obj = (T?)original;
            if (obj.HasValue)
            {
                SerializationManager.SerializeInner(obj.Value, context, typeof(T));
            }
            else
            {
                context.StreamWriter.WriteNull();
            }
        }

        internal static object DeserializeNullable<T>(Type expected, IDeserializationContext context) where T : struct
        {
            if (context.StreamReader.PeekToken() == SerializationTokenType.Null)
            {
                context.StreamReader.ReadToken();
                return new T?();
            }

            var val = (T)SerializationManager.DeserializeInner(typeof(T), context);
            return new Nullable<T>(val);
        }

        internal static object CopyNullable<T>(object original, ICopyContext context) where T : struct
        {
            return original;    // Everything is a struct, so a direct copy is fine
        }

        internal static void SerializeGenericImmutable(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutable(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutable(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeImmutable<T>(object original, ISerializationContext context, Type expected)
        {
            var obj = (Immutable<T>)original;
            SerializationManager.SerializeInner(obj.Value, context, typeof(T));
        }

        internal static object DeserializeImmutable<T>(Type expected, IDeserializationContext context)
        {
            var val = (T)SerializationManager.DeserializeInner(typeof(T), context);
            return new Immutable<T>(val);
        }

        internal static object CopyImmutable<T>(object original, ICopyContext context)
        {
            return original;    // Immutable means never having to make a copy...
        }

        internal static void SerializeTimeSpan(object obj, ISerializationContext context, Type expected)
        {
            var ts = (TimeSpan)obj;
            context.StreamWriter.Write(ts.Ticks);
        }

        internal static object DeserializeTimeSpan(Type expected, IDeserializationContext context)
        {
            return new TimeSpan(context.StreamReader.ReadLong());
        }

        internal static object CopyTimeSpan(object obj, ICopyContext context)
        {
            return obj; // TimeSpan is a value type 
        }

        internal static void SerializeDateTimeOffset(object obj, ISerializationContext context, Type expected)
        {
            var dts = (DateTimeOffset)obj;
            context.StreamWriter.Write(dts.DateTime.Ticks);
            context.StreamWriter.Write(dts.Offset.Ticks);
        }

        internal static object DeserializeDateTimeOffset(Type expected, IDeserializationContext context)
        {
            return new DateTimeOffset(context.StreamReader.ReadLong(), new TimeSpan(context.StreamReader.ReadLong()));
        }

        internal static object CopyDateTimeOffset(object obj, ICopyContext context)
        {
            return obj; // DateTimeOffset is a value type 
        }

        internal class DefaultTypeSerializer
        {
            private readonly ITypeResolver typeResolver;

            public DefaultTypeSerializer(ITypeResolver typeResolver)
            {
                this.typeResolver = typeResolver;
            }

            internal void SerializeType(object obj, ISerializationContext context, Type expected)
            {
                var typeSpecification = RuntimeTypeNameFormatter.Format((Type) obj);
                context.StreamWriter.Write(typeSpecification);
            }

            internal object DeserializeType(Type expected, IDeserializationContext context)
            {
                var typeSpecification = context.StreamReader.ReadString();
                return this.typeResolver.ResolveType(typeSpecification);
            }

            internal object CopyType(object obj, ICopyContext context)
            {
                return obj; // Type objects are effectively immutable
            }
        }

        internal static void SerializeGuid(object obj, ISerializationContext context, Type expected)
        {
            var guid = (Guid)obj;
            context.StreamWriter.Write(guid.ToByteArray());
        }

        internal static object DeserializeGuid(Type expected, IDeserializationContext context)
        {
            var bytes = context.StreamReader.ReadBytes(16);
            return new Guid(bytes);
        }

        internal static object CopyGuid(object obj, ICopyContext context)
        {
            return obj; // Guids are value types
        }

        [ThreadStatic]
        static private System.ComponentModel.TypeConverter uriConverter;

        internal static void SerializeUri(object obj, ISerializationContext context, Type expected)
        {
            if (uriConverter == null) uriConverter = TypeDescriptor.GetConverter(typeof(Uri));
            context.StreamWriter.Write(uriConverter.ConvertToInvariantString(obj));
        }

        internal static object DeserializeUri(Type expected, IDeserializationContext context)
        {
            if (uriConverter == null) uriConverter = TypeDescriptor.GetConverter(typeof(Uri));
            return uriConverter.ConvertFromInvariantString(context.StreamReader.ReadString());
        }

        internal static object CopyUri(object obj, ICopyContext context)
        {
            return obj; // URIs are immutable
        }

        internal static void SerializeCultureInfo(object obj, ISerializationContext context, Type expected)
        {
            var cultureInfo = (CultureInfo)obj;
            context.StreamWriter.Write(cultureInfo.Name);
        }

        internal static object DeserializeCultureInfo(Type expected, IDeserializationContext context)
        {           
            return new CultureInfo(context.StreamReader.ReadString());
        }

        internal static object CopyCultureInfo(object obj, ICopyContext context)
        {
            return obj;
        }

        internal static void SerializeGrainId(object obj, ISerializationContext context, Type expected)
        {
            var id = (GrainId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeGrainId(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadGrainId();
        }

        internal static object CopyGrainId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeActivationId(object obj, ISerializationContext context, Type expected)
        {
            var id = (ActivationId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeActivationId(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadActivationId();
        }

        internal static object CopyActivationId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeActivationAddress(object obj, ISerializationContext context, Type expected)
        {
            var addr = (ActivationAddress)obj;
            context.StreamWriter.Write(addr);
        }

        internal static object DeserializeActivationAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadActivationAddress();
        }

        internal static object CopyActivationAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeIPAddress(object obj, ISerializationContext context, Type expected)
        {
            var ip = (IPAddress)obj;
            context.StreamWriter.Write(ip);
        }

        internal static object DeserializeIPAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadIPAddress();
        }

        internal static object CopyIPAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeIPEndPoint(object obj, ISerializationContext context, Type expected)
        {
            var ep = (IPEndPoint)obj;
            context.StreamWriter.Write(ep);
        }

        internal static object DeserializeIPEndPoint(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadIPEndPoint();
        }

        internal static object CopyIPEndPoint(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeCorrelationId(object obj, ISerializationContext context, Type expected)
        {
            var id = (CorrelationId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeCorrelationId(Type expected, IDeserializationContext context)
        {
            var id = context.StreamReader.ReadLong();
            return new CorrelationId(id);
        }

        internal static object CopyCorrelationId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeSiloAddress(object obj, ISerializationContext context, Type expected)
        {
            var addr = (SiloAddress)obj;
            context.StreamWriter.Write(addr);
        }

        internal static object DeserializeSiloAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadSiloAddress();
        }

        internal static object CopySiloAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static object CopyTaskId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeInvokeMethodRequest(object obj, ISerializationContext context, Type expected)
        {
            var request = (InvokeMethodRequest)obj;

            context.StreamWriter.Write(request.InterfaceTypeCode);
            context.StreamWriter.Write(request.MethodId);
            context.StreamWriter.Write(request.Arguments != null ? request.Arguments.Length : 0);

            if (request.Arguments != null)
            {
                foreach (var arg in request.Arguments)
                {
                    SerializationManager.SerializeInner(arg, context, null);
                }
            }
        }

        internal static object DeserializeInvokeMethodRequest(Type expected, IDeserializationContext context)
        {
            int iid = context.StreamReader.ReadInt();
            int mid = context.StreamReader.ReadInt();

            int argCount = context.StreamReader.ReadInt();
            object[] args = null;

            if (argCount > 0)
            {
                args = new object[argCount];
                for (var i = 0; i < argCount; i++)
                {
                    args[i] = SerializationManager.DeserializeInner(null, context);
                }
            }

            return new InvokeMethodRequest(iid, mid, args);
        }

        internal static object CopyInvokeMethodRequest(object original, ICopyContext context)
        {
            var request = (InvokeMethodRequest)original;

            object[] args = null;
            if (request.Arguments != null)
            {
                args = new object[request.Arguments.Length];
                for (var i = 0; i < request.Arguments.Length; i++)
                {
                    args[i] = SerializationManager.DeepCopyInner(request.Arguments[i], context);
                }
            }

            var result = new InvokeMethodRequest(request.InterfaceTypeCode, request.MethodId, args);
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeOrleansResponse(object obj, ISerializationContext context, Type expected)
        {
            var resp = (Response)obj;

            SerializationManager.SerializeInner(resp.ExceptionFlag ? resp.Exception : resp.Data, context, null);
        }

        internal static object DeserializeOrleansResponse(Type expected, IDeserializationContext context)
        {
            var obj = SerializationManager.DeserializeInner(null, context);
            return new Response(obj);
        }

        internal static object CopyOrleansResponse(object original, ICopyContext context)
        {
            var resp = (Response)original;

            if (resp.ExceptionFlag)
            {
                return original;
            }

            var result = new Response(SerializationManager.DeepCopyInner(resp.Data, context));
            context.RecordCopy(original, result);
            return result;
        }

        private static Tuple<Serializer, Deserializer, DeepCopier>
            RegisterConcreteMethods(SerializationManager serializationManager, Type t, string serializerName, string deserializerName, string copierName, Type[] genericArgs = null)
        {
            if (genericArgs == null)
            {
                genericArgs = t.GetGenericArguments();
            }

            var genericCopier = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == copierName);
            var concreteCopier = genericCopier.MakeGenericMethod(genericArgs);
            var copier = (DeepCopier)concreteCopier.CreateDelegate(typeof(DeepCopier));

            var genericSerializer = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == serializerName);
            var concreteSerializer = genericSerializer.MakeGenericMethod(genericArgs);
            var serializer = (Serializer)concreteSerializer.CreateDelegate(typeof(Serializer));

            var genericDeserializer = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == deserializerName);
            var concreteDeserializer = genericDeserializer.MakeGenericMethod(genericArgs);
            var deserializer =
                (Deserializer)concreteDeserializer.CreateDelegate(typeof(Deserializer));

            serializationManager.Register(t, copier, serializer, deserializer);

            return new Tuple<Serializer, Deserializer, DeepCopier>(serializer, deserializer, copier);
        }

        public static Tuple<Serializer, Deserializer, DeepCopier>
            RegisterConcreteMethods(SerializationManager serializationManager, Type concreteType, Type definingType, string copierName, string serializerName, string deserializerName, Type[] genericArgs = null)
        {
            if (genericArgs == null)
            {
                genericArgs = concreteType.GetGenericArguments();
            }

            var genericCopier = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == copierName);
            var concreteCopier = genericCopier.MakeGenericMethod(genericArgs);
            var copier = (DeepCopier)concreteCopier.CreateDelegate(typeof(DeepCopier));

            var genericSerializer = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == serializerName);
            var concreteSerializer = genericSerializer.MakeGenericMethod(genericArgs);
            var serializer = (Serializer)concreteSerializer.CreateDelegate(typeof(Serializer));

            var genericDeserializer = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == deserializerName);
            var concreteDeserializer = genericDeserializer.MakeGenericMethod(genericArgs);
            var deserializer =
                (Deserializer)concreteDeserializer.CreateDelegate(typeof(Deserializer));

            serializationManager.Register(concreteType, copier, serializer, deserializer);

            return new Tuple<Serializer, Deserializer, DeepCopier>(serializer, deserializer, copier);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using Orleans.CodeGeneration;
using Orleans.Concurrency;
using Orleans.Runtime;
using Orleans.Utilities;

namespace Orleans.Serialization
{
    internal static class BuiltInTypes
    {
        private static readonly Type objectType = typeof(object);

        internal static void SerializeGenericReadOnlyCollection(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericReadOnlyCollection(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericReadOnlyCollection(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyCollection), nameof(DeserializeReadOnlyCollection), nameof(DeepCopyReadOnlyCollection), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeReadOnlyCollection<T>(object obj, ISerializationContext context, Type expected)
        {
            var collection = (ReadOnlyCollection<T>)obj;
            context.StreamWriter.Write(collection.Count);
            foreach (var element in collection)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeReadOnlyCollection<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);

            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }

            var ret = new ReadOnlyCollection<T>(list);
            context.RecordObject(ret);
            return ret;
        }

        internal static object DeepCopyReadOnlyCollection<T>(object original, ICopyContext context)
        {
            var collection = (ReadOnlyCollection<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return original;
            }

            var innerList = new List<T>(collection.Count);
            foreach (var element in collection)
            {
                innerList.Add((T)SerializationManager.DeepCopyInner(element, context));
            }

            var retVal = new ReadOnlyCollection<T>(innerList);
            context.RecordCopy(original, retVal);
            return retVal;
        }

        internal static void SerializeGenericList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericList(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeList), nameof(DeserializeList), nameof(DeepCopyList), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeList<T>(object obj, ISerializationContext context, Type expected)
        {
            var list = (List<T>)obj;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);
            context.RecordObject(list);

            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return list;
        }

        internal static object DeepCopyList<T>(object original, ICopyContext context)
        {
            var list = (List<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new List<T>(list);
            }

            // set the list capacity, to avoid list resizing.
            var retVal = new List<T>(list.Count);
            context.RecordCopy(original, retVal);
            foreach (var element in list)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(element, context));
            }

            return retVal;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="original"></param>
        /// <param name="context"></param>
        /// <param name="expected"></param>
        internal static void SerializeGenericLinkedList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericLinkedList(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericLinkedList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeLinkedList), nameof(DeserializeLinkedList), nameof(DeepCopyLinkedList), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeLinkedList<T>(object obj, ISerializationContext context, Type expected)
        {
            var list = (LinkedList<T>)obj;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeLinkedList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new LinkedList<T>();
            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                list.AddLast((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return list;
        }

        internal static object DeepCopyLinkedList<T>(object original, ICopyContext context)
        {
            var list = (LinkedList<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new LinkedList<T>(list);
            }

            var retVal = new LinkedList<T>();
            context.RecordCopy(original, retVal);
            foreach (var item in list)
            {
                retVal.AddLast((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericHashSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericHashSet(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericHashSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeHashSet), nameof(DeserializeHashSet), nameof(DeepCopyHashSet), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeHashSet<T>(object obj, ISerializationContext context, Type expected)
        {
            var set = (HashSet<T>)obj;
            SerializationManager.SerializeInner(set.Comparer.Equals(EqualityComparer<T>.Default) ? null : set.Comparer,
                context, typeof(IEqualityComparer<T>));
            context.StreamWriter.Write(set.Count);
            foreach (var element in set)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeHashSet<T>(Type expected, IDeserializationContext context)
        {
            var comparer =
                (IEqualityComparer<T>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<T>), context);
            var count = context.StreamReader.ReadInt();
            var set = new HashSet<T>(comparer);
            context.RecordObject(set);
            for (var i = 0; i < count; i++)
            {
                set.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return set;
        }

        internal static object DeepCopyHashSet<T>(object original, ICopyContext context)
        {
            var set = (HashSet<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new HashSet<T>(set, set.Comparer);
            }

            var retVal = new HashSet<T>(set.Comparer);
            context.RecordCopy(original, retVal);
            foreach (var item in set)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericSortedSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedSet(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericSortedSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedSet), nameof(DeserializeSortedSet), nameof(DeepCopySortedSet), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeSortedSet<T>(object obj, ISerializationContext context, Type expected)
        {
            var set = (SortedSet<T>)obj;
            SerializationManager.SerializeInner(set.Comparer.Equals(Comparer<T>.Default) ? null : set.Comparer,
                context, typeof(IComparer<T>));
            context.StreamWriter.Write(set.Count);
            foreach (var element in set)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeSortedSet<T>(Type expected, IDeserializationContext context)
        {
            var comparer =
                (IComparer<T>)SerializationManager.DeserializeInner(typeof(IComparer<T>), context);
            var count = context.StreamReader.ReadInt();
            var set = new SortedSet<T>(comparer);
            context.RecordObject(set);
            for (var i = 0; i < count; i++)
            {
                set.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return set;
        }

        internal static object DeepCopySortedSet<T>(object original, ICopyContext context)
        {
            var set = (SortedSet<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new SortedSet<T>(set, set.Comparer);
            }

            var retVal = new SortedSet<T>(set.Comparer);
            context.RecordCopy(original, retVal);
            foreach (var item in set)
            {
                retVal.Add((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericQueue(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericQueue(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericQueue(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeQueue), nameof(DeserializeQueue), nameof(DeepCopyQueue), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeQueue<T>(object obj, ISerializationContext context, Type expected)
        {
            var queue = (Queue<T>)obj;
            context.StreamWriter.Write(queue.Count);
            foreach (var element in queue)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeQueue<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var queue = new Queue<T>();
            context.RecordObject(queue);
            for (var i = 0; i < count; i++)
            {
                queue.Enqueue((T)SerializationManager.DeserializeInner(typeof(T), context));
            }
            return queue;
        }

        internal static object DeepCopyQueue<T>(object original, ICopyContext context)
        {
            var queue = (Queue<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new Queue<T>(queue);
            }

            var retVal = new Queue<T>(queue.Count);
            context.RecordCopy(original, retVal);
            foreach (var item in queue)
            {
                retVal.Enqueue((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericStack(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            concretes.Item1(original, context, expected);
        }

        internal static object DeserializeGenericStack(Type expected, IDeserializationContext context)
        {
            var generics = expected.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            return concretes.Item2(expected, context);
        }

        internal static object CopyGenericStack(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeStack), nameof(DeserializeStack), nameof(DeepCopyStack), generics);

            return concretes.Item3(original, context);
        }

        internal static void SerializeStack<T>(object obj, ISerializationContext context, Type expected)
        {
            var stack = (Stack<T>)obj;
            context.StreamWriter.Write(stack.Count);
            foreach (var element in stack)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeStack<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var list = new List<T>(count);
            var stack = new Stack<T>(count);
            context.RecordObject(stack);
            for (var i = 0; i < count; i++)
            {
                list.Add((T)SerializationManager.DeserializeInner(typeof(T), context));
            }

            for (var i = count - 1; i >= 0; i--)
            {
                stack.Push(list[i]);
            }

            return stack;
        }

        internal static object DeepCopyStack<T>(object original, ICopyContext context)
        {
            var stack = (Stack<T>)original;

            if (typeof(T).IsOrleansShallowCopyable())
            {
                return new Stack<T>(stack.Reverse()); // NOTE: Yes, the Reverse really is required
            }

            var retVal = new Stack<T>();
            context.RecordCopy(original, retVal);
            foreach (var item in stack.Reverse())
            {
                retVal.Push((T)SerializationManager.DeepCopyInner(item, context));
            }
            return retVal;
        }

        internal static void SerializeGenericDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();

            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeDictionary), nameof(DeserializeDictionary), nameof(CopyDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (Dictionary<K, V>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(EqualityComparer<K>.Default) ? null : dict.Comparer,
                                           context, typeof(IEqualityComparer<K>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IEqualityComparer<K>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<K, V>(count, comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopyDictionary<K, V>(object original, ICopyContext context)
        {
            var dict = (Dictionary<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new Dictionary<K, V>(dict, dict.Comparer);
            }

            var result = new Dictionary<K, V>(dict.Count, dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericReadOnlyDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericReadOnlyDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericReadOnlyDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeReadOnlyDictionary), nameof(DeserializeReadOnlyDictionary), nameof(CopyReadOnlyDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeReadOnlyDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (ReadOnlyDictionary<K, V>)original;
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeReadOnlyDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<K, V>(count);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }

            var retVal = new ReadOnlyDictionary<K, V>(dict);
            context.RecordObject(retVal);
            return retVal;
        }

        internal static object CopyReadOnlyDictionary<K, V>(object original, ICopyContext context)
        {
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return original;
            }

            var dict = (ReadOnlyDictionary<K, V>)original;
            var innerDict = new Dictionary<K, V>(dict.Count);
            foreach (var pair in dict)
            {
                innerDict[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            var retVal = new ReadOnlyDictionary<K, V>(innerDict);
            context.RecordCopy(original, retVal);
            return retVal;
        }

        internal static void SerializeStringObjectDictionary(object original, ISerializationContext context, Type expected)
        {
            var dict = (Dictionary<string, object>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(EqualityComparer<string>.Default) ? null : dict.Comparer,
                                           context, typeof(IEqualityComparer<string>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                //context.Stream.WriteTypeHeader(stringType, stringType);
                context.StreamWriter.Write(pair.Key);
                SerializationManager.SerializeInner(pair.Value, context, objectType);
            }
        }

        internal static object DeserializeStringObjectDictionary(Type expected, IDeserializationContext context)
        {
            var comparer = (IEqualityComparer<string>)SerializationManager.DeserializeInner(typeof(IEqualityComparer<string>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new Dictionary<string, object>(count, comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                //context.Stream.ReadFullTypeHeader(stringType); // Skip the type header, which will be string
                var key = context.StreamReader.ReadString();
                var value = SerializationManager.DeserializeInner(null, context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopyStringObjectDictionary(object original, ICopyContext context)
        {
            var dict = (Dictionary<string, object>)original;
            var result = new Dictionary<string, object>(dict.Count, dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[pair.Key] = SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericSortedDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericSortedDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedDictionary), nameof(DeserializeSortedDictionary), nameof(CopySortedDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeSortedDictionary<K, V>(object original, ISerializationContext context, Type expected)
        {
            var dict = (SortedDictionary<K, V>)original;
            SerializationManager.SerializeInner(dict.Comparer.Equals(Comparer<K>.Default) ? null : dict.Comparer, context, typeof(IComparer<K>));
            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeSortedDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IComparer<K>)SerializationManager.DeserializeInner(typeof(IComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var dict = new SortedDictionary<K, V>(comparer);
            context.RecordObject(dict);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                dict[key] = value;
            }
            return dict;
        }

        internal static object CopySortedDictionary<K, V>(object original, ICopyContext context)
        {
            var dict = (SortedDictionary<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new SortedDictionary<K, V>(dict, dict.Comparer);
            }

            var result = new SortedDictionary<K, V>(dict.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in dict)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericSortedList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericSortedList(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericSortedList(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeSortedList), nameof(DeserializeSortedList), nameof(CopySortedList));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeSortedList<K, V>(object original, ISerializationContext context, Type expected)
        {
            var list = (SortedList<K, V>)original;
            SerializationManager.SerializeInner(list.Comparer.Equals(Comparer<K>.Default) ? null : list.Comparer, context, typeof(IComparer<K>));
            context.StreamWriter.Write(list.Count);
            foreach (var pair in list)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeSortedList<K, V>(Type expected, IDeserializationContext context)
        {
            var comparer = (IComparer<K>)SerializationManager.DeserializeInner(typeof(IComparer<K>), context);
            var count = context.StreamReader.ReadInt();
            var list = new SortedList<K, V>(count, comparer);
            context.RecordObject(list);
            for (var i = 0; i < count; i++)
            {
                var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
                var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
                list[key] = value;
            }
            return list;
        }

        internal static object CopySortedList<K, V>(object original, ICopyContext context)
        {
            var list = (SortedList<K, V>)original;
            if (typeof(K).IsOrleansShallowCopyable() && typeof(V).IsOrleansShallowCopyable())
            {
                return new SortedList<K, V>(list, list.Comparer);
            }

            var result = new SortedList<K, V>(list.Count, list.Comparer);
            context.RecordCopy(original, result);
            foreach (var pair in list)
            {
                result[(K)SerializationManager.DeepCopyInner(pair.Key, context)] = (V)SerializationManager.DeepCopyInner(pair.Value, context);
            }

            return result;
        }

        internal static void SerializeGenericImmutableDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutableDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableDictionary), nameof(DeserializeImmutableDictionary), nameof(CopyImmutableDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static object CopyImmutableDictionary<K, V>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableDictionary<K, V>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableDictionary<K, V>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(EqualityComparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IEqualityComparer<K>));
            SerializationManager.SerializeInner(dict.ValueComparer.Equals(EqualityComparer<V>.Default) ? null : dict.ValueComparer, context, typeof(IEqualityComparer<V>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeImmutableDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IEqualityComparer<K>>(context);
            var valueComparer = SerializationManager.DeserializeInner<IEqualityComparer<V>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableDictionary.CreateBuilder(keyComparer, valueComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                var value = SerializationManager.DeserializeInner<V>(context);
                dictBuilder.Add(key, value);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static void SerializeGenericImmutableList(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableList(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutableList(object original, ICopyContext context)
        {
            var t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableList), nameof(DeserializeImmutableList), nameof(CopyImmutableList));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeImmutableList<T>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var list = (ImmutableList<T>)untypedInput;
            context.StreamWriter.Write(list.Count);
            foreach (var element in list)
            {
                SerializationManager.SerializeInner(element, context, typeof(T));
            }
        }

        internal static object DeserializeImmutableList<T>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var listBuilder = ImmutableList.CreateBuilder<T>();

            for (var i = 0; i < count; i++)
            {
                listBuilder.Add(SerializationManager.DeserializeInner<T>(context));
            }
            var list = listBuilder.ToImmutable();
            context.RecordObject(list);
            return list;
        }

        internal static object CopyImmutableList<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static object CopyGenericImmutableHashSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeGenericImmutableHashSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutableHashSet(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableHashSet), nameof(DeserializeImmutableHashSet), nameof(CopyImmutableHashSet));
            return concreteMethods.Item2(expected, context);
        }
        
        internal static object CopyImmutableHashSet<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableHashSet<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableHashSet<K>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(EqualityComparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IEqualityComparer<K>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableHashSet<K>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IEqualityComparer<K>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableHashSet.CreateBuilder(keyComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                dictBuilder.Add(key);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableSortedSet(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableSortedSet(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableSortedSet(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedSet), nameof(DeserializeImmutableSortedSet), nameof(CopyImmutableSortedSet));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableSortedSet<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableSortedSet<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableSortedSet<K>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(Comparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IComparer<K>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableSortedSet<K>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IComparer<K>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableSortedSet.CreateBuilder(keyComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                dictBuilder.Add(key);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableSortedDictionary(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableSortedDictionary(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableSortedDictionary(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableSortedDictionary), nameof(DeserializeImmutableSortedDictionary), nameof(CopyImmutableSortedDictionary));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableSortedDictionary<K, V>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableSortedDictionary<K, V>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var dict = (ImmutableSortedDictionary<K, V>)untypedInput;
            SerializationManager.SerializeInner(dict.KeyComparer.Equals(Comparer<K>.Default) ? null : dict.KeyComparer, context, typeof(IComparer<K>));
            SerializationManager.SerializeInner(dict.ValueComparer.Equals(EqualityComparer<V>.Default) ? null : dict.ValueComparer, context, typeof(IEqualityComparer<V>));

            context.StreamWriter.Write(dict.Count);
            foreach (var pair in dict)
            {
                SerializationManager.SerializeInner(pair.Key, context, typeof(K));
                SerializationManager.SerializeInner(pair.Value, context, typeof(V));
            }
        }

        internal static object DeserializeImmutableSortedDictionary<K, V>(Type expected, IDeserializationContext context)
        {
            var keyComparer = SerializationManager.DeserializeInner<IComparer<K>>(context);
            var valueComparer = SerializationManager.DeserializeInner<IEqualityComparer<V>>(context);
            var count = context.StreamReader.ReadInt();
            var dictBuilder = ImmutableSortedDictionary.CreateBuilder(keyComparer, valueComparer);
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                var value = SerializationManager.DeserializeInner<V>(context);
                dictBuilder.Add(key, value);
            }
            var dict = dictBuilder.ToImmutable();
            context.RecordObject(dict);

            return dict;
        }

        internal static object CopyGenericImmutableArray(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableArray(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableArray(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableArray), nameof(DeserializeImmutableArray), nameof(CopyImmutableArray));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableArray<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableArray<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var array = (ImmutableArray<K>)untypedInput;

            if (array == default)
            {
                context.StreamWriter.Write(-1);
                return;
            }

            context.StreamWriter.Write(array.Length);
            foreach (var element in array)
            {
                SerializationManager.SerializeInner(element, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableArray<K>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();

            if (count == -1)
            {
                context.RecordObject(default(ImmutableArray<K>));
                return default(ImmutableArray<K>);
            }

            var builder = ImmutableArray.CreateBuilder<K>();
            for (var i = 0; i < count; i++)
            {
                var element = SerializationManager.DeserializeInner<K>(context);
                builder.Add(element);
            }
            var array = builder.ToImmutable();
            context.RecordObject(array);

            return array;
        }
        internal static object CopyGenericImmutableQueue(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            return concreteMethods.Item3(original, context);
        }

        internal static object DeserializeGenericImmutableQueue(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            return concreteMethods.Item2(expected, context);
        }

        internal static void SerializeGenericImmutableQueue(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutableQueue), nameof(DeserializeImmutableQueue), nameof(CopyImmutableQueue));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object CopyImmutableQueue<K>(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeImmutableQueue<K>(object untypedInput, ISerializationContext context, Type typeExpected)
        {
            var queue = (ImmutableQueue<K>)untypedInput;

            context.StreamWriter.Write(queue.Count);
            foreach (var item in queue)
            {
                SerializationManager.SerializeInner(item, context, typeof(K));
            }
        }

        internal static object DeserializeImmutableQueue<K>(Type expected, IDeserializationContext context)
        {
            var count = context.StreamReader.ReadInt();
            var items = new K[count];
            for (var i = 0; i < count; i++)
            {
                var key = SerializationManager.DeserializeInner<K>(context);
                items[i] = key;
            }
            var queues = ImmutableQueue.CreateRange(items);

            context.RecordObject(queues);

            return queues;
        }

        internal static void SerializeTuple(object raw, ISerializationContext context, Type expected)
        {
            Type t = raw.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            concretes.Item1(raw, context, expected);
        }

        internal static object DeserializeTuple(Type t, IDeserializationContext context)
        {
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            return concretes.Item2(t, context);
        }

        internal static object DeepCopyTuple(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeTuple) + generics.Length, nameof(DeserializeTuple) + generics.Length, nameof(DeepCopyTuple) + generics.Length, generics);

            return concretes.Item3(original, context);
        }

        internal static object DeepCopyTuple1<T1>(object original, ICopyContext context)
        {
            var input = (Tuple<T1>)original;
            var result = new Tuple<T1>((T1)SerializationManager.DeepCopyInner(input.Item1, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple1<T1>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
        }

        internal static object DeserializeTuple1<T1>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            return new Tuple<T1>(item1);
        }

        internal static object DeepCopyTuple2<T1, T2>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2>)original;
            var result = new Tuple<T1, T2>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple2<T1, T2>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
        }

        internal static object DeserializeTuple2<T1, T2>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            return new Tuple<T1, T2>(item1, item2);
        }

        internal static object DeepCopyTuple3<T1, T2, T3>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3>)original;
            var result = new Tuple<T1, T2, T3>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple3<T1, T2, T3>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
        }

        internal static object DeserializeTuple3<T1, T2, T3>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            return new Tuple<T1, T2, T3>(item1, item2, item3);
        }

        internal static object DeepCopyTuple4<T1, T2, T3, T4>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4>)original;
            var result = new Tuple<T1, T2, T3, T4>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple4<T1, T2, T3, T4>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
        }

        internal static object DeserializeTuple4<T1, T2, T3, T4>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            return new Tuple<T1, T2, T3, T4>(item1, item2, item3, item4);
        }

        internal static object DeepCopyTuple5<T1, T2, T3, T4, T5>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5>)original;
            var result = new Tuple<T1, T2, T3, T4, T5>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple5<T1, T2, T3, T4, T5>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
        }

        internal static object DeserializeTuple5<T1, T2, T3, T4, T5>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            return new Tuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
        }

        internal static object DeepCopyTuple6<T1, T2, T3, T4, T5, T6>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6>)original;
            var result = new Tuple<T1, T2, T3, T4, T5, T6>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple6<T1, T2, T3, T4, T5, T6>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
        }

        internal static object DeserializeTuple6<T1, T2, T3, T4, T5, T6>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            return new Tuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
        }

        internal static object DeepCopyTuple7<T1, T2, T3, T4, T5, T6, T7>(object original, ICopyContext context)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6, T7>)original;
            var result = new Tuple<T1, T2, T3, T4, T5, T6, T7>((T1)SerializationManager.DeepCopyInner(input.Item1, context), (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeTuple7<T1, T2, T3, T4, T5, T6, T7>(object obj, ISerializationContext context, Type expected)
        {
            var input = (Tuple<T1, T2, T3, T4, T5, T6, T7>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
        }

        internal static object DeserializeTuple7<T1, T2, T3, T4, T5, T6, T7>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            return new Tuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
        }

        internal static void SerializeValueTuple(object raw, ISerializationContext context, Type expected)
        {
            Type t = raw.GetType();
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            concretes.Item1(raw, context, expected);
        }

        internal static object DeserializeValueTuple(Type t, IDeserializationContext context)
        {
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            return concretes.Item2(t, context);
        }

        internal static object DeepCopyValueTuple(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var generics = t.GetGenericArguments();
            var concretes = RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeValueTuple) + generics.Length, nameof(DeserializeValueTuple) + generics.Length, nameof(DeepCopyValueTuple) + generics.Length, generics);

            return concretes.Item3(original, context);
        }

        internal static object DeepCopyValueTuple1<T1>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1>)original;
            var result = new ValueTuple<T1>((T1)SerializationManager.DeepCopyInner(input.Item1, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple1<T1>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
        }

        internal static object DeserializeValueTuple1<T1>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            return new ValueTuple<T1>(item1);
        }

        internal static object DeepCopyValueTuple2<T1, T2>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2>)original;
            var result = new ValueTuple<T1, T2>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple2<T1, T2>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
        }

        internal static object DeserializeValueTuple2<T1, T2>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            return new ValueTuple<T1, T2>(item1, item2);
        }

        internal static object DeepCopyValueTuple3<T1, T2, T3>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3>)original;
            var result = new ValueTuple<T1, T2, T3>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple3<T1, T2, T3>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
        }

        internal static object DeserializeValueTuple3<T1, T2, T3>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            return new ValueTuple<T1, T2, T3>(item1, item2, item3);
        }

        internal static object DeepCopyValueTuple4<T1, T2, T3, T4>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4>)original;
            var result = new ValueTuple<T1, T2, T3, T4>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple4<T1, T2, T3, T4>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
        }

        internal static object DeserializeValueTuple4<T1, T2, T3, T4>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            return new ValueTuple<T1, T2, T3, T4>(item1, item2, item3, item4);
        }

        internal static object DeepCopyValueTuple5<T1, T2, T3, T4, T5>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple5<T1, T2, T3, T4, T5>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
        }

        internal static object DeserializeValueTuple5<T1, T2, T3, T4, T5>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            return new ValueTuple<T1, T2, T3, T4, T5>(item1, item2, item3, item4, item5);
        }

        internal static object DeepCopyValueTuple6<T1, T2, T3, T4, T5, T6>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple6<T1, T2, T3, T4, T5, T6>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
        }

        internal static object DeserializeValueTuple6<T1, T2, T3, T4, T5, T6>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6>(item1, item2, item3, item4, item5, item6);
        }

        internal static object DeepCopyValueTuple7<T1, T2, T3, T4, T5, T6, T7>(object original, ICopyContext context)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple7<T1, T2, T3, T4, T5, T6, T7>(object obj, ISerializationContext context, Type expected)
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
        }

        internal static object DeserializeValueTuple7<T1, T2, T3, T4, T5, T6, T7>(Type expected, IDeserializationContext context)
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6, T7>(item1, item2, item3, item4, item5, item6, item7);
        }

        internal static object DeepCopyValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(object original, ICopyContext context) where T8 : struct
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>)original;
            var result = new ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(
                (T1)SerializationManager.DeepCopyInner(input.Item1, context), 
                (T2)SerializationManager.DeepCopyInner(input.Item2, context),
                (T3)SerializationManager.DeepCopyInner(input.Item3, context),
                (T4)SerializationManager.DeepCopyInner(input.Item4, context),
                (T5)SerializationManager.DeepCopyInner(input.Item5, context),
                (T6)SerializationManager.DeepCopyInner(input.Item6, context),
                (T7)SerializationManager.DeepCopyInner(input.Item7, context),
                (T8)SerializationManager.DeepCopyInner(input.Rest, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(object obj, ISerializationContext context, Type expected) where T8 : struct
        {
            var input = (ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>)obj;
            SerializationManager.SerializeInner(input.Item1, context, typeof(T1));
            SerializationManager.SerializeInner(input.Item2, context, typeof(T2));
            SerializationManager.SerializeInner(input.Item3, context, typeof(T3));
            SerializationManager.SerializeInner(input.Item4, context, typeof(T4));
            SerializationManager.SerializeInner(input.Item5, context, typeof(T5));
            SerializationManager.SerializeInner(input.Item6, context, typeof(T6));
            SerializationManager.SerializeInner(input.Item7, context, typeof(T7));
            SerializationManager.SerializeInner(input.Rest, context, typeof(T8));
        }

        internal static object DeserializeValueTuple8<T1, T2, T3, T4, T5, T6, T7, T8>(Type expected, IDeserializationContext context) where T8 : struct
        {
            var item1 = (T1)SerializationManager.DeserializeInner(typeof(T1), context);
            var item2 = (T2)SerializationManager.DeserializeInner(typeof(T2), context);
            var item3 = (T3)SerializationManager.DeserializeInner(typeof(T3), context);
            var item4 = (T4)SerializationManager.DeserializeInner(typeof(T4), context);
            var item5 = (T5)SerializationManager.DeserializeInner(typeof(T5), context);
            var item6 = (T6)SerializationManager.DeserializeInner(typeof(T6), context);
            var item7 = (T7)SerializationManager.DeserializeInner(typeof(T7), context);
            var rest = (T8)SerializationManager.DeserializeInner(typeof(T8), context);
            return new ValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(item1, item2, item3, item4, item5, item6, item7, rest);
        }

        internal static void SerializeGenericKeyValuePair(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericKeyValuePair(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericKeyValuePair(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeKeyValuePair), nameof(DeserializeKeyValuePair), nameof(CopyKeyValuePair));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeKeyValuePair<TK, TV>(object original, ISerializationContext context, Type expected)
        {
            var pair = (KeyValuePair<TK, TV>)original;
            SerializationManager.SerializeInner(pair.Key, context, typeof(TK));
            SerializationManager.SerializeInner(pair.Value, context, typeof(TV));
        }

        internal static object DeserializeKeyValuePair<K, V>(Type expected, IDeserializationContext context)
        {
            var key = (K)SerializationManager.DeserializeInner(typeof(K), context);
            var value = (V)SerializationManager.DeserializeInner(typeof(V), context);
            return new KeyValuePair<K, V>(key, value);
        }

        internal static object CopyKeyValuePair<TK, TV>(object original, ICopyContext context)
        {
            var pair = (KeyValuePair<TK, TV>)original;
            if (typeof(TK).IsOrleansShallowCopyable() && typeof(TV).IsOrleansShallowCopyable())
            {
                return pair;    // KeyValuePair is a struct, so there's already been a copy at this point
            }

            var result = new KeyValuePair<TK, TV>((TK)SerializationManager.DeepCopyInner(pair.Key, context), (TV)SerializationManager.DeepCopyInner(pair.Value, context));
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeGenericNullable(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericNullable(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericNullable(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeNullable), nameof(DeserializeNullable), nameof(CopyNullable));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeNullable<T>(object original, ISerializationContext context, Type expected) where T : struct
        {
            var obj = (T?)original;
            if (obj.HasValue)
            {
                SerializationManager.SerializeInner(obj.Value, context, typeof(T));
            }
            else
            {
                context.StreamWriter.WriteNull();
            }
        }

        internal static object DeserializeNullable<T>(Type expected, IDeserializationContext context) where T : struct
        {
            if (context.StreamReader.PeekToken() == SerializationTokenType.Null)
            {
                context.StreamReader.ReadToken();
                return new T?();
            }

            var val = (T)SerializationManager.DeserializeInner(typeof(T), context);
            return new Nullable<T>(val);
        }

        internal static object CopyNullable<T>(object original, ICopyContext context) where T : struct
        {
            return original;    // Everything is a struct, so a direct copy is fine
        }

        internal static void SerializeGenericImmutable(object original, ISerializationContext context, Type expected)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            concreteMethods.Item1(original, context, expected);
        }

        internal static object DeserializeGenericImmutable(Type expected, IDeserializationContext context)
        {
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), expected, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            return concreteMethods.Item2(expected, context);
        }

        internal static object CopyGenericImmutable(object original, ICopyContext context)
        {
            Type t = original.GetType();
            var concreteMethods= RegisterConcreteMethods(context.GetSerializationManager(), t, nameof(SerializeImmutable), nameof(DeserializeImmutable), nameof(CopyImmutable));
            return concreteMethods.Item3(original, context);
        }

        internal static void SerializeImmutable<T>(object original, ISerializationContext context, Type expected)
        {
            var obj = (Immutable<T>)original;
            SerializationManager.SerializeInner(obj.Value, context, typeof(T));
        }

        internal static object DeserializeImmutable<T>(Type expected, IDeserializationContext context)
        {
            var val = (T)SerializationManager.DeserializeInner(typeof(T), context);
            return new Immutable<T>(val);
        }

        internal static object CopyImmutable<T>(object original, ICopyContext context)
        {
            return original;    // Immutable means never having to make a copy...
        }

        internal static void SerializeTimeSpan(object obj, ISerializationContext context, Type expected)
        {
            var ts = (TimeSpan)obj;
            context.StreamWriter.Write(ts.Ticks);
        }

        internal static object DeserializeTimeSpan(Type expected, IDeserializationContext context)
        {
            return new TimeSpan(context.StreamReader.ReadLong());
        }

        internal static object CopyTimeSpan(object obj, ICopyContext context)
        {
            return obj; // TimeSpan is a value type 
        }

        internal static void SerializeDateTimeOffset(object obj, ISerializationContext context, Type expected)
        {
            var dts = (DateTimeOffset)obj;
            context.StreamWriter.Write(dts.DateTime.Ticks);
            context.StreamWriter.Write(dts.Offset.Ticks);
        }

        internal static object DeserializeDateTimeOffset(Type expected, IDeserializationContext context)
        {
            return new DateTimeOffset(context.StreamReader.ReadLong(), new TimeSpan(context.StreamReader.ReadLong()));
        }

        internal static object CopyDateTimeOffset(object obj, ICopyContext context)
        {
            return obj; // DateTimeOffset is a value type 
        }

        internal class DefaultTypeSerializer
        {
            private readonly ITypeResolver typeResolver;

            public DefaultTypeSerializer(ITypeResolver typeResolver)
            {
                this.typeResolver = typeResolver;
            }

            internal void SerializeType(object obj, ISerializationContext context, Type expected)
            {
                var typeSpecification = RuntimeTypeNameFormatter.Format((Type) obj);
                context.StreamWriter.Write(typeSpecification);
            }

            internal object DeserializeType(Type expected, IDeserializationContext context)
            {
                var typeSpecification = context.StreamReader.ReadString();
                return this.typeResolver.ResolveType(typeSpecification);
            }

            internal object CopyType(object obj, ICopyContext context)
            {
                return obj; // Type objects are effectively immutable
            }
        }

        internal static void SerializeGuid(object obj, ISerializationContext context, Type expected)
        {
            var guid = (Guid)obj;
            context.StreamWriter.Write(guid.ToByteArray());
        }

        internal static object DeserializeGuid(Type expected, IDeserializationContext context)
        {
            var bytes = context.StreamReader.ReadBytes(16);
            return new Guid(bytes);
        }

        internal static object CopyGuid(object obj, ICopyContext context)
        {
            return obj; // Guids are value types
        }

        [ThreadStatic]
        static private System.ComponentModel.TypeConverter uriConverter;

        internal static void SerializeUri(object obj, ISerializationContext context, Type expected)
        {
            if (uriConverter == null) uriConverter = TypeDescriptor.GetConverter(typeof(Uri));
            context.StreamWriter.Write(uriConverter.ConvertToInvariantString(obj));
        }

        internal static object DeserializeUri(Type expected, IDeserializationContext context)
        {
            if (uriConverter == null) uriConverter = TypeDescriptor.GetConverter(typeof(Uri));
            return uriConverter.ConvertFromInvariantString(context.StreamReader.ReadString());
        }

        internal static object CopyUri(object obj, ICopyContext context)
        {
            return obj; // URIs are immutable
        }

        internal static void SerializeCultureInfo(object obj, ISerializationContext context, Type expected)
        {
            var cultureInfo = (CultureInfo)obj;
            context.StreamWriter.Write(cultureInfo.Name);
        }

        internal static object DeserializeCultureInfo(Type expected, IDeserializationContext context)
        {           
            return new CultureInfo(context.StreamReader.ReadString());
        }

        internal static object CopyCultureInfo(object obj, ICopyContext context)
        {
            return obj;
        }

        internal static void SerializeGrainId(object obj, ISerializationContext context, Type expected)
        {
            var id = (GrainId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeGrainId(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadGrainId();
        }

        internal static object CopyGrainId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeActivationId(object obj, ISerializationContext context, Type expected)
        {
            var id = (ActivationId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeActivationId(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadActivationId();
        }

        internal static object CopyActivationId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeActivationAddress(object obj, ISerializationContext context, Type expected)
        {
            var addr = (ActivationAddress)obj;
            context.StreamWriter.Write(addr);
        }

        internal static object DeserializeActivationAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadActivationAddress();
        }

        internal static object CopyActivationAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeIPAddress(object obj, ISerializationContext context, Type expected)
        {
            var ip = (IPAddress)obj;
            context.StreamWriter.Write(ip);
        }

        internal static object DeserializeIPAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadIPAddress();
        }

        internal static object CopyIPAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeIPEndPoint(object obj, ISerializationContext context, Type expected)
        {
            var ep = (IPEndPoint)obj;
            context.StreamWriter.Write(ep);
        }

        internal static object DeserializeIPEndPoint(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadIPEndPoint();
        }

        internal static object CopyIPEndPoint(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeCorrelationId(object obj, ISerializationContext context, Type expected)
        {
            var id = (CorrelationId)obj;
            context.StreamWriter.Write(id);
        }

        internal static object DeserializeCorrelationId(Type expected, IDeserializationContext context)
        {
            var id = context.StreamReader.ReadLong();
            return new CorrelationId(id);
        }

        internal static object CopyCorrelationId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeSiloAddress(object obj, ISerializationContext context, Type expected)
        {
            var addr = (SiloAddress)obj;
            context.StreamWriter.Write(addr);
        }

        internal static object DeserializeSiloAddress(Type expected, IDeserializationContext context)
        {
            return context.StreamReader.ReadSiloAddress();
        }

        internal static object CopySiloAddress(object original, ICopyContext context)
        {
            return original;
        }

        internal static object CopyTaskId(object original, ICopyContext context)
        {
            return original;
        }

        internal static void SerializeInvokeMethodRequest(object obj, ISerializationContext context, Type expected)
        {
            var request = (InvokeMethodRequest)obj;

            context.StreamWriter.Write(request.InterfaceTypeCode);
            context.StreamWriter.Write(request.MethodId);
            context.StreamWriter.Write(request.Arguments != null ? request.Arguments.Length : 0);

            if (request.Arguments != null)
            {
                foreach (var arg in request.Arguments)
                {
                    SerializationManager.SerializeInner(arg, context, null);
                }
            }
        }

        internal static object DeserializeInvokeMethodRequest(Type expected, IDeserializationContext context)
        {
            int iid = context.StreamReader.ReadInt();
            int mid = context.StreamReader.ReadInt();

            int argCount = context.StreamReader.ReadInt();
            object[] args = null;

            if (argCount > 0)
            {
                args = new object[argCount];
                for (var i = 0; i < argCount; i++)
                {
                    args[i] = SerializationManager.DeserializeInner(null, context);
                }
            }

            return new InvokeMethodRequest(iid, mid, args);
        }

        internal static object CopyInvokeMethodRequest(object original, ICopyContext context)
        {
            var request = (InvokeMethodRequest)original;

            object[] args = null;
            if (request.Arguments != null)
            {
                args = new object[request.Arguments.Length];
                for (var i = 0; i < request.Arguments.Length; i++)
                {
                    args[i] = SerializationManager.DeepCopyInner(request.Arguments[i], context);
                }
            }

            var result = new InvokeMethodRequest(request.InterfaceTypeCode, request.MethodId, args);
            context.RecordCopy(original, result);
            return result;
        }

        internal static void SerializeOrleansResponse(object obj, ISerializationContext context, Type expected)
        {
            var resp = (Response)obj;

            SerializationManager.SerializeInner(resp.ExceptionFlag ? resp.Exception : resp.Data, context, null);
        }

        internal static object DeserializeOrleansResponse(Type expected, IDeserializationContext context)
        {
            var obj = SerializationManager.DeserializeInner(null, context);
            return new Response(obj);
        }

        internal static object CopyOrleansResponse(object original, ICopyContext context)
        {
            var resp = (Response)original;

            if (resp.ExceptionFlag)
            {
                return original;
            }

            var result = new Response(SerializationManager.DeepCopyInner(resp.Data, context));
            context.RecordCopy(original, result);
            return result;
        }

        private static Tuple<Serializer, Deserializer, DeepCopier>
            RegisterConcreteMethods(SerializationManager serializationManager, Type t, string serializerName, string deserializerName, string copierName, Type[] genericArgs = null)
        {
            if (genericArgs == null)
            {
                genericArgs = t.GetGenericArguments();
            }

            var genericCopier = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == copierName);
            var concreteCopier = genericCopier.MakeGenericMethod(genericArgs);
            var copier = (DeepCopier)concreteCopier.CreateDelegate(typeof(DeepCopier));

            var genericSerializer = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == serializerName);
            var concreteSerializer = genericSerializer.MakeGenericMethod(genericArgs);
            var serializer = (Serializer)concreteSerializer.CreateDelegate(typeof(Serializer));

            var genericDeserializer = typeof(BuiltInTypes).GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == deserializerName);
            var concreteDeserializer = genericDeserializer.MakeGenericMethod(genericArgs);
            var deserializer =
                (Deserializer)concreteDeserializer.CreateDelegate(typeof(Deserializer));

            serializationManager.Register(t, copier, serializer, deserializer);

            return new Tuple<Serializer, Deserializer, DeepCopier>(serializer, deserializer, copier);
        }

        public static Tuple<Serializer, Deserializer, DeepCopier>
            RegisterConcreteMethods(SerializationManager serializationManager, Type concreteType, Type definingType, string copierName, string serializerName, string deserializerName, Type[] genericArgs = null)
        {
            if (genericArgs == null)
            {
                genericArgs = concreteType.GetGenericArguments();
            }

            var genericCopier = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == copierName);
            var concreteCopier = genericCopier.MakeGenericMethod(genericArgs);
            var copier = (DeepCopier)concreteCopier.CreateDelegate(typeof(DeepCopier));

            var genericSerializer = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == serializerName);
            var concreteSerializer = genericSerializer.MakeGenericMethod(genericArgs);
            var serializer = (Serializer)concreteSerializer.CreateDelegate(typeof(Serializer));

            var genericDeserializer = definingType.GetMethods(BindingFlags.Static | BindingFlags.NonPublic).First(m => m.Name == deserializerName);
            var concreteDeserializer = genericDeserializer.MakeGenericMethod(genericArgs);
            var deserializer =
                (Deserializer)concreteDeserializer.CreateDelegate(typeof(Deserializer));

            serializationManager.Register(concreteType, copier, serializer, deserializer);

            return new Tuple<Serializer, Deserializer, DeepCopier>(serializer, deserializer, copier);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Orleans.Core\Serialization\BuiltInTypes.cs(1180,40): error CS1503: Argument 1: cannot convert from 'method group' to 'int'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Orleans.CodeGenerator\Compatibility\OrleansLegacyCompat.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Orleans.CodeGenerator.Utilities;

namespace Orleans.CodeGenerator.Compatibility
{
    internal static class OrleansLegacyCompat
    {
        public static int GetMethodId(this WellKnownTypes wellKnownTypes, IMethodSymbol methodInfo)
        {
            if (GetAttribute(methodInfo, wellKnownTypes.MethodIdAttribute) is AttributeData attr)
            {
                return (int)attr.ConstructorArguments.First().Value;
            }

            var result = FormatMethodForMethodIdComputation(methodInfo);
            return CalculateIdHash(result);
        }

        internal static string FormatMethodForMethodIdComputation(IMethodSymbol methodInfo)
        {
            var result = new StringBuilder(methodInfo.Name);

            if (methodInfo.IsGenericMethod)
            {
                result.Append('<');
                var first = true;
                foreach (var arg in methodInfo.TypeArguments)
                {
                    if (!first) result.Append(',');
                    else first = false;
                    result.Append(RoslynTypeNameFormatter.Format(arg, RoslynTypeNameFormatter.Style.RuntimeTypeNameFormatter));
                }

                result.Append('>');
            }

            {
                result.Append('(');
                var parameters = methodInfo.Parameters;
                var first = true;
                foreach (var parameter in parameters)
                {
                    if (!first)
                        result.Append(',');
                    var parameterType = parameter.Type;
                    switch (parameterType)
                    {
                        case ITypeParameterSymbol _:
                            result.Append(parameterType.Name);
                            break;
                        default:
                            result.Append(RoslynTypeNameFormatter.Format(parameterType, RoslynTypeNameFormatter.Style.RuntimeTypeNameFormatter));
                            break;
                    }

                    first = false;
                }
            }

            result.Append(')');
            return result.ToString();
        }

        public static int GetTypeId(this WellKnownTypes wellKnownTypes, INamedTypeSymbol type)
        {
            if (GetAttribute(type, wellKnownTypes.TypeCodeOverrideAttribute) is AttributeData attr)
            {
                return (int)attr.ConstructorArguments.First().Value;
            }

            var fullName = FormatTypeForIdComputation(type);
            return CalculateIdHash(fullName);
        }

        private static AttributeData GetAttribute(ISymbol type, ITypeSymbol attributeType)
        {
            var attrs = type.GetAttributes();
            foreach (var attr in attrs)
            {
                if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeType))
                {
                    return attr;
                }
            }

            return null;
        }

        private static int CalculateIdHash(string text)
        {
            var sha = SHA256.Create();
            var hash = 0;
            try
            {
                var data = Encoding.Unicode.GetBytes(text);
                var result = sha.ComputeHash(data);
                for (var i = 0; i < result.Length; i += 4)
                {
                    var tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | result[i + 3];
                    hash = hash ^ tmp;
                }
            }
            finally
            {
                sha.Dispose();
            }

            return hash;
        }

        internal static string FormatTypeForIdComputation(INamedTypeSymbol symbol) =>
            GetTemplatedName(
                GetFullName(symbol),
                symbol,
                symbol.TypeArguments,
                t => false);

        public static ushort GetVersion(this WellKnownTypes wellKnownTypes, ISymbol symbol)
        {
            if (GetAttribute(symbol, wellKnownTypes.VersionAttribute) is AttributeData attr)
            {
                return (ushort)attr.ConstructorArguments.First().Value;
            }

            // Return the default version
            return 0;
        }

        /// <summary>
        /// Returns true if the provided type is a grain interface.
        /// </summary>
        public static bool IsGrainInterface(this WellKnownTypes types, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Interface) return false;

            var orig = type.OriginalDefinition;
            return orig.AllInterfaces.Contains(types.IAddressable) && !IsGrainMarkerInterface(types, orig);

            bool IsGrainMarkerInterface(WellKnownTypes l, INamedTypeSymbol t)
            {
                return Eq(t, l.IGrainObserver) ||
                       Eq(t, l.IAddressable) ||
                       Eq(t, l.IGrainExtension) ||
                       Eq(t, l.IGrain) ||
                       Eq(t, l.IGrainWithGuidKey) ||
                       Eq(t, l.IGrainWithIntegerKey) ||
                       Eq(t, l.IGrainWithStringKey) ||
                       Eq(t, l.IGrainWithGuidCompoundKey) ||
                       Eq(t, l.IGrainWithIntegerCompoundKey) ||
                       Eq(t, l.ISystemTarget);

                static bool Eq(ISymbol left, ISymbol right) => SymbolEqualityComparer.Default.Equals(left, right);
            }
        }

        /// <summary>
        /// Returns true if the provided type is a grain implementation.
        /// </summary>
        public static bool IsGrainClass(this WellKnownTypes types, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Class) return false;

            var orig = type.OriginalDefinition;
            return HasBase(orig, types.Grain) && !IsMarkerType(types, orig);

            bool IsMarkerType(WellKnownTypes l, INamedTypeSymbol t)
            {
                return SymbolEqualityComparer.Default.Equals(t, l.Grain) || SymbolEqualityComparer.Default.Equals(t, l.GrainOfT);
            }

            bool HasBase(INamedTypeSymbol t, INamedTypeSymbol baseType)
            {
                if (SymbolEqualityComparer.Default.Equals(t.BaseType, baseType)) return true;
                if (t.BaseType != null) return HasBase(t.BaseType, baseType);
                return false;
            }
        }
        public static string OrleansTypeKeyString(this ITypeSymbol t)
        {
            var sb = new StringBuilder();
            OrleansTypeKeyString(t, sb);

            return sb.ToString();
        }

        private static void OrleansTypeKeyString(ITypeSymbol t, StringBuilder sb)
        {
            var namedType = t as INamedTypeSymbol;

            // Check if the type is a non-constructed generic type.
            if (namedType != null && IsGenericTypeDefinition(namedType, out var typeParamsLength))
            {
                GetBaseTypeKey(t, sb);
                sb.Append('\'');
                sb.Append(typeParamsLength);
            }
            else if (namedType != null && namedType.IsGenericType)
            {
                GetBaseTypeKey(t, sb);
                sb.Append('<');
                var first = true;
                foreach (var genericArgument in namedType.GetHierarchyTypeArguments())
                {
                    if (!first)
                    {
                        sb.Append(',');
                    }
                    first = false;
                    OrleansTypeKeyString(genericArgument, sb);
                }

                sb.Append('>');
            }
            else if (t is IArrayTypeSymbol arrayType)
            {
                OrleansTypeKeyString(arrayType.ElementType, sb);

                sb.Append('[');
                if (arrayType.Rank > 1)
                {
                    sb.Append(',', arrayType.Rank - 1);
                }
                sb.Append(']');
            }
            else if (t is IPointerTypeSymbol pointerType)
            {
                OrleansTypeKeyString(pointerType.PointedAtType, sb);

                sb.Append("*");
            }
            else
            {
                GetBaseTypeKey(t, sb);
            }
        }

        private static void GetBaseTypeKey(ITypeSymbol type, StringBuilder sb)
        {
            var namespacePrefix = "";
            if (!RoslynTypeHelper.IsSystemNamespace(type.ContainingNamespace))
            {
                namespacePrefix = type.ContainingNamespace.ToString() + '.';
            }

            if (type.DeclaredAccessibility == Accessibility.Public && type.ContainingType != null)
            {
                sb.Append(namespacePrefix);
                OrleansTypeKeyString(type.OriginalDefinition?.ContainingType ?? type.ContainingType, sb);
                sb.Append('.').Append(type.Name);
            }
            else
            {
                sb.Append(namespacePrefix).Append(type.Name);
            }

            if (type is INamedTypeSymbol namedType && namedType.IsGenericType && namedType.TypeArguments.Length > 0)
            {
                sb.Append('`').Append(namedType.TypeArguments.Length);
            }
        }

        public static string GetTemplatedName(ITypeSymbol type, Func<ITypeSymbol, bool> fullName = null)
        {
            if (fullName == null) fullName = _ => true;

            switch (type)
            {
                case IArrayTypeSymbol array:
                    return GetTemplatedName(array.ElementType, fullName)
                           + "["
                           + new string(',', array.Rank - 1)
                           + "]";
                case INamedTypeSymbol named when named.IsGenericType:
                    return GetTemplatedName(GetSimpleTypeName(named, fullName), named, named.TypeArguments, fullName);
                case INamedTypeSymbol named:
                    return GetSimpleTypeName(named, fullName);
                case ITypeParameterSymbol parameter:
                    return parameter.Name;
                default:
                    throw new NotSupportedException($"Symbol {type} of type {type.GetType()} is not supported.");
            }
        }

        public static string GetTemplatedName(string baseName, INamedTypeSymbol type, ImmutableArray<ITypeSymbol> genericArguments, Func<ITypeSymbol, bool> fullName)
        {
            if (!type.IsGenericType || type.ContainingType != null && type.ContainingType.IsGenericType) return baseName;
            var s = baseName;
            s += "<";
            s += GetGenericTypeArgs(genericArguments, fullName);
            s += ">";
            return s;
        }

        public static string GetGenericTypeArgs(IEnumerable<ITypeSymbol> args, Func<ITypeSymbol, bool> fullName)
        {
            var result = string.Empty;

            var first = true;
            foreach (var genericParameter in args)
            {
                if (!first)
                {
                    result += ",";
                }

                if (genericParameter is INamedTypeSymbol named && !named.IsGenericType)
                {
                    result += GetSimpleTypeName(named, fullName);
                }
                else
                {
                    result += GetTemplatedName(genericParameter, fullName);
                }

                first = false;
            }

            return result;
        }

        public static string GetSimpleTypeName(ITypeSymbol type, Func<ITypeSymbol, bool> fullName = null)
        {
            var named = type as INamedTypeSymbol;
            if (type.ContainingType != null)
            {
                if (type.ContainingType.IsGenericType)
                {
                    return GetTemplatedName(
                               GetUntemplatedTypeName(type.ContainingType.Name),
                               type.ContainingType,
                               named?.TypeArguments ?? default(ImmutableArray<ITypeSymbol>),
                               _ => true) + "." + GetUntemplatedTypeName(type.Name);
                }

                return GetTemplatedName(type.ContainingType) + "." + GetUntemplatedTypeName(type.Name);
            }

            if (named == null || named.IsGenericType) return GetSimpleTypeName(fullName != null && fullName(type) ? GetFullName(type) : type.Name);

            return fullName != null && fullName(type) ? GetFullName(type) : type.Name;
        }

        public static string GetUntemplatedTypeName(string typeName)
        {
            var i = typeName.IndexOf('`');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('<');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            return typeName;
        }

        public static string GetSimpleTypeName(string typeName)
        {
            var i = typeName.IndexOf('`');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('[');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('<');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            return typeName;
        }

        public static string GetFullName(ITypeSymbol t)
        {
            if (t == null) throw new ArgumentNullException(nameof(t));
            if (t.ContainingType != null && !(t is ITypeParameterSymbol))
            {
                return $"{t.GetNamespaceName()}.{t.ContainingType.Name}.{t.Name}{GetArity(t)}";
            }

            if (t is IArrayTypeSymbol array)
            {
                return GetFullName(array.ElementType)
                       + "["
                       + new string(',', array.Rank - 1)
                       + "]";
            }

            return RoslynTypeNameFormatter.Format(t, RoslynTypeNameFormatter.Style.FullName); // ?? (t is ITypeParameterSymbol) ? t.Name : t.GetNamespaceName() + "." + t.Name;

            string GetArity(ITypeSymbol type)
            {
                if (!(type is INamedTypeSymbol named)) return string.Empty;
                if (named.TypeArguments.Length > 0) return $"`{named.TypeArguments.Length}";
                return string.Empty;
            }
        }

        static bool IsGenericTypeDefinition(INamedTypeSymbol type, out int typeParamsLength)
        {
            if (type.IsUnboundGenericType)
            {
                typeParamsLength = type.GetHierarchyTypeArguments().Count();
                return true;
            }

            if (type.IsGenericType && type.GetNestedHierarchy().All(t => SymbolEqualityComparer.Default.Equals(t.ConstructedFrom, t)))
            {
                typeParamsLength = type.GetHierarchyTypeArguments().Count();
                return true;
            }

            typeParamsLength = 0;
            return false;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Orleans.CodeGenerator.Utilities;

namespace Orleans.CodeGenerator.Compatibility
{
    internal static class OrleansLegacyCompat
    {
        public static int GetMethodId(this WellKnownTypes wellKnownTypes, IMethodSymbol methodInfo)
        {
            if (GetAttribute(methodInfo, wellKnownTypes.MethodIdAttribute) is AttributeData attr)
            {
                return (int)attr.ConstructorArguments.First().Value;
            }

            var result = FormatMethodForMethodIdComputation(methodInfo);
            return CalculateIdHash(result);
        }

        internal static string FormatMethodForMethodIdComputation(IMethodSymbol methodInfo)
        {
            var result = new StringBuilder(methodInfo.Name);

            if (methodInfo.IsGenericMethod)
            {
                result.Append('<');
                var first = true;
                foreach (var arg in methodInfo.TypeArguments)
                {
                    if (!first) result.Append(',');
                    else first = false;
                    result.Append(RoslynTypeNameFormatter.Format(arg, RoslynTypeNameFormatter.Style.RuntimeTypeNameFormatter));
                }

                result.Append('>');
            }

            {
                result.Append('(');
                var parameters = methodInfo.Parameters;
                var first = true;
                foreach (var parameter in parameters)
                {
                    if (!first)
                        result.Append(',');
                    var parameterType = parameter.Type;
                    switch (parameterType)
                    {
                        case ITypeParameterSymbol _:
                            result.Append(parameterType.Name);
                            break;
                        default:
                            result.Append(RoslynTypeNameFormatter.Format(parameterType, RoslynTypeNameFormatter.Style.RuntimeTypeNameFormatter));
                            break;
                    }

                    first = false;
                }
            }

            result.Append(')');
            return result.ToString();
        }

        public static int GetTypeId(this WellKnownTypes wellKnownTypes, INamedTypeSymbol type)
        {
            if (GetAttribute(type, wellKnownTypes.TypeCodeOverrideAttribute) is AttributeData attr)
            {
                return (int)attr.ConstructorArguments.First().Value;
            }

            var fullName = FormatTypeForIdComputation(type);
            return CalculateIdHash(fullName);
        }

        private static AttributeData GetAttribute(ISymbol type, ITypeSymbol attributeType)
        {
            var attrs = type.GetAttributes();
            foreach (var attr in attrs)
            {
                if (SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeType))
                {
                    return attr;
                }
            }

            return null;
        }

        private static int CalculateIdHash(string text)
        {
            var sha = SHA256.Create();
            var hash = 0;
            try
            {
                var data = Encoding.Unicode.GetBytes(text);
                var result = sha.ComputeHash(data);
                for (var i = 0; i < result.Length; i += 4)
                {
                    var tmp = (result[i] << 24) | (result[i + 1] << 16) | (result[i + 2] << 8) | result[i + 3];
                    hash = hash ^ tmp;
                }
            }
            finally
            {
                sha.Dispose();
            }

            return hash;
        }

        internal static string FormatTypeForIdComputation(INamedTypeSymbol symbol) =>
            GetTemplatedName(
                GetFullName(symbol),
                symbol,
                symbol.TypeArguments,
                t => false);

        public static ushort GetVersion(this WellKnownTypes wellKnownTypes, ISymbol symbol)
        {
            if (GetAttribute(symbol, wellKnownTypes.VersionAttribute) is AttributeData attr)
            {
                return (ushort)attr.ConstructorArguments.First().Value;
            }

            // Return the default version
            return 0;
        }

        /// <summary>
        /// Returns true if the provided type is a grain interface.
        /// </summary>
        public static bool IsGrainInterface(this WellKnownTypes types, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Interface) return false;

            var orig = type.OriginalDefinition;
            return orig.AllInterfaces.Contains(types.IAddressable) && !IsGrainMarkerInterface(types, orig);

            bool IsGrainMarkerInterface(WellKnownTypes l, INamedTypeSymbol t)
            {
                return Eq(t, l.IGrainObserver) ||
                       Eq(t, l.IAddressable) ||
                       Eq(t, l.IGrainExtension) ||
                       Eq(t, l.IGrain) ||
                       Eq(t, l.IGrainWithGuidKey) ||
                       Eq(t, l.IGrainWithIntegerKey) ||
                       Eq(t, l.IGrainWithStringKey) ||
                       Eq(t, l.IGrainWithGuidCompoundKey) ||
                       Eq(t, l.IGrainWithIntegerCompoundKey) ||
                       Eq(t, l.ISystemTarget);

                static bool Eq(ISymbol left, ISymbol right) => SymbolEqualityComparer.Default.Equals(left, right);
            }
        }

        /// <summary>
        /// Returns true if the provided type is a grain implementation.
        /// </summary>
        public static bool IsGrainClass(this WellKnownTypes types, INamedTypeSymbol type)
        {
            if (type.TypeKind != TypeKind.Class) return false;

            var orig = type.OriginalDefinition;
            return HasBase(orig, types.Grain) && !IsMarkerType(types, orig);

            bool IsMarkerType(WellKnownTypes l, INamedTypeSymbol t)
            {
                return SymbolEqualityComparer.Default.Equals(t, l.Grain) || SymbolEqualityComparer.Default.Equals(t, l.GrainOfT);
            }

            bool HasBase(INamedTypeSymbol t, INamedTypeSymbol baseType)
            {
                if (SymbolEqualityComparer.Default.Equals(t.BaseType, baseType)) return true;
                if (t.BaseType != null) return HasBase(t.BaseType, baseType);
                return false;
            }
        }
        public static string OrleansTypeKeyString(this ITypeSymbol t)
        {
            var sb = new StringBuilder();
            OrleansTypeKeyString(t, sb);

            return sb.ToString();
        }

        private static void OrleansTypeKeyString(ITypeSymbol t, StringBuilder sb)
        {
            // Check if the type is a non-constructed generic type.
            if (t is INamedTypeSymbol namedType && IsGenericTypeDefinition(namedType, out var typeParamsLength))
            {
                GetBaseTypeKey(t, sb);
                sb.Append('\'');
                sb.Append(typeParamsLength);
            }
            else if (t is INamedTypeSymbol namedType && namedType.IsGenericType)
            {
                GetBaseTypeKey(t, sb);
                sb.Append('<');
                var first = true;
                foreach (var genericArgument in namedType.GetHierarchyTypeArguments())
                {
                    if (!first)
                    {
                        sb.Append(',');
                    }
                    first = false;
                    OrleansTypeKeyString(genericArgument, sb);
                }

                sb.Append('>');
            }
            else if (t is IArrayTypeSymbol arrayType)
            {
                OrleansTypeKeyString(arrayType.ElementType, sb);

                sb.Append('[');
                if (arrayType.Rank > 1)
                {
                    sb.Append(',', arrayType.Rank - 1);
                }
                sb.Append(']');
            }
            else if (t is IPointerTypeSymbol pointerType)
            {
                OrleansTypeKeyString(pointerType.PointedAtType, sb);

                sb.Append("*");
            }
            else
            {
                GetBaseTypeKey(t, sb);
            }
        }

        private static void GetBaseTypeKey(ITypeSymbol type, StringBuilder sb)
        {
            var namespacePrefix = "";
            if (!RoslynTypeHelper.IsSystemNamespace(type.ContainingNamespace))
            {
                namespacePrefix = type.ContainingNamespace.ToString() + '.';
            }

            if (type.DeclaredAccessibility == Accessibility.Public && type.ContainingType != null)
            {
                sb.Append(namespacePrefix);
                OrleansTypeKeyString(type.OriginalDefinition?.ContainingType ?? type.ContainingType, sb);
                sb.Append('.').Append(type.Name);
            }
            else
            {
                sb.Append(namespacePrefix).Append(type.Name);
            }

            if (type is INamedTypeSymbol namedType && namedType.IsGenericType && namedType.TypeArguments.Length > 0)
            {
                sb.Append('`').Append(namedType.TypeArguments.Length);
            }
        }

        public static string GetTemplatedName(ITypeSymbol type, Func<ITypeSymbol, bool> fullName = null)
        {
            if (fullName == null) fullName = _ => true;

            switch (type)
            {
                case IArrayTypeSymbol array:
                    return GetTemplatedName(array.ElementType, fullName)
                           + "["
                           + new string(',', array.Rank - 1)
                           + "]";
                case INamedTypeSymbol named when named.IsGenericType:
                    return GetTemplatedName(GetSimpleTypeName(named, fullName), named, named.TypeArguments, fullName);
                case INamedTypeSymbol named:
                    return GetSimpleTypeName(named, fullName);
                case ITypeParameterSymbol parameter:
                    return parameter.Name;
                default:
                    throw new NotSupportedException($"Symbol {type} of type {type.GetType()} is not supported.");
            }
        }

        public static string GetTemplatedName(string baseName, INamedTypeSymbol type, ImmutableArray<ITypeSymbol> genericArguments, Func<ITypeSymbol, bool> fullName)
        {
            if (!type.IsGenericType || type.ContainingType != null && type.ContainingType.IsGenericType) return baseName;
            var s = baseName;
            s += "<";
            s += GetGenericTypeArgs(genericArguments, fullName);
            s += ">";
            return s;
        }

        public static string GetGenericTypeArgs(IEnumerable<ITypeSymbol> args, Func<ITypeSymbol, bool> fullName)
        {
            var result = string.Empty;

            var first = true;
            foreach (var genericParameter in args)
            {
                if (!first)
                {
                    result += ",";
                }

                if (genericParameter is INamedTypeSymbol named && !named.IsGenericType)
                {
                    result += GetSimpleTypeName(named, fullName);
                }
                else
                {
                    result += GetTemplatedName(genericParameter, fullName);
                }

                first = false;
            }

            return result;
        }

        public static string GetSimpleTypeName(ITypeSymbol type, Func<ITypeSymbol, bool> fullName = null)
        {
            var named = type as INamedTypeSymbol;
            if (type.ContainingType != null)
            {
                if (type.ContainingType.IsGenericType)
                {
                    return GetTemplatedName(
                               GetUntemplatedTypeName(type.ContainingType.Name),
                               type.ContainingType,
                               named?.TypeArguments ?? default(ImmutableArray<ITypeSymbol>),
                               _ => true) + "." + GetUntemplatedTypeName(type.Name);
                }

                return GetTemplatedName(type.ContainingType) + "." + GetUntemplatedTypeName(type.Name);
            }

            if (named == null || named.IsGenericType) return GetSimpleTypeName(fullName != null && fullName(type) ? GetFullName(type) : type.Name);

            return fullName != null && fullName(type) ? GetFullName(type) : type.Name;
        }

        public static string GetUntemplatedTypeName(string typeName)
        {
            var i = typeName.IndexOf('`');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('<');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            return typeName;
        }

        public static string GetSimpleTypeName(string typeName)
        {
            var i = typeName.IndexOf('`');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('[');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            i = typeName.IndexOf('<');
            if (i > 0)
            {
                typeName = typeName.Substring(0, i);
            }
            return typeName;
        }

        public static string GetFullName(ITypeSymbol t)
        {
            if (t == null) throw new ArgumentNullException(nameof(t));
            if (t.ContainingType != null && !(t is ITypeParameterSymbol))
            {
                return $"{t.GetNamespaceName()}.{t.ContainingType.Name}.{t.Name}{GetArity(t)}";
            }

            if (t is IArrayTypeSymbol array)
            {
                return GetFullName(array.ElementType)
                       + "["
                       + new string(',', array.Rank - 1)
                       + "]";
            }

            return RoslynTypeNameFormatter.Format(t, RoslynTypeNameFormatter.Style.FullName); // ?? (t is ITypeParameterSymbol) ? t.Name : t.GetNamespaceName() + "." + t.Name;

            string GetArity(ITypeSymbol type)
            {
                if (!(type is INamedTypeSymbol named)) return string.Empty;
                if (named.TypeArguments.Length > 0) return $"`{named.TypeArguments.Length}";
                return string.Empty;
            }
        }

        static bool IsGenericTypeDefinition(INamedTypeSymbol type, out int typeParamsLength)
        {
            if (type.IsUnboundGenericType)
            {
                typeParamsLength = type.GetHierarchyTypeArguments().Count();
                return true;
            }

            if (type.IsGenericType && type.GetNestedHierarchy().All(t => SymbolEqualityComparer.Default.Equals(t.ConstructedFrom, t)))
            {
                typeParamsLength = type.GetHierarchyTypeArguments().Count();
                return true;
            }

            typeParamsLength = 0;
            return false;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Orleans.CodeGenerator\Compatibility\OrleansLegacyCompat.cs(201,44): error CS0136: A local or parameter named 'namedType' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


