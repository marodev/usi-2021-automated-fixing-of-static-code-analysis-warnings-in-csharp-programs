Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Microsoft.OData.Edm(net45)
    #1 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\CsdlReader.cs, Line: 685, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\CsdlReader.cs, Line: 711, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Parsing\Common\XmlElementParser.cs, Line: 23, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Parsing\CsdlDocumentParser.cs, Line: 1124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Parsing\CsdlDocumentParser.cs, Line: 1129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsDirectValueAnnotationsManager.cs, Line: 21, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 398, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 401, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 454, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 469, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 472, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 478, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 490, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsModel.cs, Line: 655, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsNavigationProperty.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsNavigationSource.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsOperation.cs, Line: 253, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsOperation.cs, Line: 260, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSchemaXmlWriter.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSchemaXmlWriter.cs, Line: 400, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSchemaXmlWriter.cs, Line: 780, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSchemaXmlWriter.cs, Line: 822, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 282, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 619, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 705, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 726, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 778, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Serialization\EdmModelCsdlSerializationVisitor.cs, Line: 790, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 332, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 342, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 418, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 421, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 433, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 440, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 443, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 457, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\src\Microsoft.OData.Edm\EdmUtil.cs, Line: 88, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1022, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1054, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1084, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1372, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1378, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1384, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1390, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 1396, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 723, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 732, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 849, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 878, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 910, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 937, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 963, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EdmTypeSemantics.cs, Line: 993, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\EnumHelper.cs, Line: 141, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs, Line: 1442, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #63 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs, Line: 3396, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #64 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs, Line: 809, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #65 Path: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ToTraceStringExtensionMethods.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\src\Microsoft.OData.Edm\Microsoft.OData.Edm.cs, Line: 375, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 133, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 145, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 157, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\src\Microsoft.OData.Edm\RegistrationHelper.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\Date.cs, Line: 253, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #74 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\Date.cs, Line: 298, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #75 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\EdmCollectionTypeReference.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\EdmEntityContainer.cs, Line: 284, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #77 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\EdmModel.cs, Line: 90, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #78 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\EdmModelBase.cs, Line: 213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\TimeOfDay.cs, Line: 276, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #80 Path: D:\a\1\s\src\Microsoft.OData.Edm\Schema\TimeOfDay.cs, Line: 317, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #81 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ExpressionTypeChecker.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ExpressionTypeChecker.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 1221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 1230, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 1239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 1248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 1257, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 225, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #89 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 231, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #90 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 308, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 320, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\InterfaceValidator.cs, Line: 710, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ValidationHelper.cs, Line: 203, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ValidationHelper.cs, Line: 44, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #95 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ValidationHelper.cs, Line: 49, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #96 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ValidationRules.cs, Line: 2774, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\src\Microsoft.OData.Edm\Validation\ValidationRules.cs, Line: 2798, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\EdmExpressionEvaluator.cs, Line: 356, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #99 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\EdmExpressionEvaluator.cs, Line: 467, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\EdmExpressionEvaluator.cs, Line: 728, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\EdmToClrConverter.cs, Line: 625, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\EdmToClrConverter.cs, Line: 628, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\VocabularyAnnotationExtensions.cs, Line: 34, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #104 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 572, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #105 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 711, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Microsoft.Spatial(net45)
    #106 Path: D:\a\1\s\src\Microsoft.Spatial\Geography\GeoJsonObjectReader.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\src\Microsoft.Spatial\Geography\GeoJsonObjectReader.cs, Line: 201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #108 Path: D:\a\1\s\src\Microsoft.Spatial\Geography\GeoJsonObjectReader.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\src\Microsoft.Spatial\Microsoft.Spatial.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 572, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #111 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 711, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Microsoft.OData.Client
    #112 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 274, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 280, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #114 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 286, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #115 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 292, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #116 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 298, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #117 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 304, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #118 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 60, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #119 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 66, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #120 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #121 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 85, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #122 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 91, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #123 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 147, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #126 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 152, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #127 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 158, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #128 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 173, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #129 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 178, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #130 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 226, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #132 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 236, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #133 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 242, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 254, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 323, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #137 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 467, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 543, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\EdmLibraryExtensions.cs, Line: 1573, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #141 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SyntacticAst\ComputeExpressionToken.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SyntacticAst\ComputeToken.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Microsoft.OData.Edm.Tests(net452)
    #143 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 197, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #144 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 201, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #145 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 308, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #146 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 312, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #147 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 495, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #148 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 498, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #149 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 501, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #150 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 798, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #151 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Csdl\CsdlReaderTests.cs, Line: 833, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ExtensionMethods\ExtensionMethodTests.cs, Line: 1106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #153 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ExtensionMethods\ExtensionMethodTests.cs, Line: 1112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #154 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ExtensionMethods\ExtensionMethodTests.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #155 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ScenarioTests\OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs, Line: 213, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #156 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ScenarioTests\OasisActionsFunctionsRelationshipChangesAcceptanceTests.cs, Line: 273, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #157 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\ScenarioTests\OasisRelationshipChangesAcceptanceTests.cs, Line: 474, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #158 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Edm.Tests\Vocabularies\CapabilitiesVocabularyTests.cs, Line: 802, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Microsoft.OData.Core(net45)
    #159 Path: D:\a\1\s\src\Microsoft.OData.Core\Buffers\BufferUtils.cs, Line: 74, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #160 Path: D:\a\1\s\src\Microsoft.OData.Core\EdmExtensionMethods.cs, Line: 111, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 274, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 242, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 254, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 467, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #170 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs, Line: 543, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #171 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalEntityMetadataBuilder.cs, Line: 238, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalIdMetadataBuilder.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalIdMetadataBuilder.cs, Line: 288, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalResourceMetadataBuilder.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalResourceMetadataBuilder.cs, Line: 178, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataConventionalResourceMetadataBuilder.cs, Line: 222, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\ODataResourceMetadataBuilder.cs, Line: 141, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #178 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\BufferingJsonReader.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\BufferingJsonReader.cs, Line: 201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\BufferingJsonReader.cs, Line: 218, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonLightInstanceAnnotationWriter.cs, Line: 173, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonLightInstanceAnnotationWriter.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonLightInstanceAnnotationWriter.cs, Line: 200, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonLightInstanceAnnotationWriter.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\ODataJsonWriterUtils.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\ODataJsonWriterUtils.cs, Line: 111, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\ODataJsonWriterUtils.cs, Line: 309, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\src\Microsoft.OData.Core\Json\ODataJsonWriterUtils.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\JsonFullMetadataLevel.cs, Line: 139, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #190 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\JsonFullMetadataLevel.cs, Line: 150, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #191 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightCollectionWriter.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightContextUriParser.cs, Line: 424, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #193 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightContextUriParser.cs, Line: 432, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightDeserializer.cs, Line: 543, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #195 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightOutputContext.cs, Line: 759, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #196 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightOutputContext.cs, Line: 812, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #197 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightParameterWriter.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertyAndValueDeserializer.cs, Line: 1502, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #199 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertyAndValueDeserializer.cs, Line: 776, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertyAndValueDeserializer.cs, Line: 837, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertyAndValueDeserializer.cs, Line: 888, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #202 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #204 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 181, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #207 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 200, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #208 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 215, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #209 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 268, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #210 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightPropertySerializer.cs, Line: 314, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #211 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs, Line: 1109, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #212 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs, Line: 1155, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #213 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs, Line: 2474, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #214 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReaderNestedResourceInfo.cs, Line: 82, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #215 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReaderUtils.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #216 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReaderUtils.cs, Line: 225, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #217 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceSerializer.cs, Line: 399, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #218 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightValueSerializer.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightValueSerializer.cs, Line: 262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightValueSerializer.cs, Line: 269, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #221 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs, Line: 314, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #222 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs, Line: 936, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #223 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ReorderingJsonReader.cs, Line: 347, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #224 Path: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ReorderingJsonReader.cs, Line: 384, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #225 Path: D:\a\1\s\src\Microsoft.OData.Core\MessageStreamWrapper.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #226 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\EdmLibraryExtensions.cs, Line: 1100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #227 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\EdmLibraryExtensions.cs, Line: 1112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #228 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\EdmLibraryExtensions.cs, Line: 1573, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #229 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\EdmTypeReaderResolver.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #230 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\MetadataUtils.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #231 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\MetadataUtilsCommon.cs, Line: 556, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\src\Microsoft.OData.Core\Metadata\MetadataUtilsCommon.cs, Line: 559, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #233 Path: D:\a\1\s\src\Microsoft.OData.Core\Microsoft.OData.Core.cs, Line: 889, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: D:\a\1\s\src\Microsoft.OData.Core\MultipartMixed\ODataMultipartMixedBatchReaderStream.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #235 Path: D:\a\1\s\src\Microsoft.OData.Core\MultipartMixed\ODataMultipartMixedBatchReaderStream.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #236 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 271, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #237 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 298, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #238 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 331, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #239 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 337, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 343, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #241 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataContextUrlInfo.cs, Line: 349, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #242 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataMessageReader.cs, Line: 1214, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #243 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPayloadValueConverter.cs, Line: 23, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #244 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPayloadValueConverter.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #245 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPayloadValueConverter.cs, Line: 66, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #246 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPreferenceHeader.cs, Line: 155, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #247 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPreferenceHeader.cs, Line: 223, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #248 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPreferenceHeader.cs, Line: 287, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #249 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataPreferenceHeader.cs, Line: 358, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #250 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataRawOutputContext.cs, Line: 358, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #253 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataResource.cs, Line: 417, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #254 Path: D:\a\1\s\src\Microsoft.OData.Core\ODataWriterCore.cs, Line: 2288, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #255 Path: D:\a\1\s\src\Microsoft.OData.Core\RawValueWriter.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #256 Path: D:\a\1\s\src\Microsoft.OData.Core\TaskUtils.cs, Line: 554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #257 Path: D:\a\1\s\src\Microsoft.OData.Core\TaskUtils.cs, Line: 725, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: D:\a\1\s\src\Microsoft.OData.Core\TaskUtils.cs, Line: 734, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #259 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 234, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #260 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 247, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 253, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #263 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 265, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #264 Path: D:\a\1\s\src\Microsoft.OData.Core\TypeNameOracle.cs, Line: 271, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs, Line: 519, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs, Line: 539, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #268 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #270 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #271 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #272 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #273 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #274 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #275 Path: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriUtils.cs, Line: 198, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #276 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Aggregation\ApplyBinder.cs, Line: 167, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #277 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Aggregation\ApplyBinder.cs, Line: 236, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #278 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Aggregation\ApplyBinder.cs, Line: 240, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #279 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Aggregation\ApplyBinder.cs, Line: 247, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #280 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\DottedIdentifierBinder.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #281 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\DottedIdentifierBinder.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #282 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\EndPathBinder.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #283 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\EndPathBinder.cs, Line: 179, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #284 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\EndPathBinder.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #285 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\InBinder.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #286 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\InnerPathTokenBinder.cs, Line: 145, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #287 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\LiteralBinder.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #288 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\LiteralBinder.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #289 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs, Line: 61, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #290 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\ParameterAliasBinder.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectExpandBinder.cs, Line: 207, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #292 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectPathSegmentTokenBinder.cs, Line: 156, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #293 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ExpandDepthAndCountValidator.cs, Line: 80, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #294 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\KeyFinder.cs, Line: 140, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #295 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\KeyFinder.cs, Line: 160, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #296 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\KeyFinder.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ODataPathParser.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #298 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\SegmentArgumentParser.cs, Line: 297, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\SegmentArgumentParser.cs, Line: 311, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #300 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\SegmentKeyHandler.cs, Line: 161, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #301 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\UriQueryExpressionParser.cs, Line: 486, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #302 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Resolver\ODataUriResolver.cs, Line: 502, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #303 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\AnnotationSegment.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #304 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\BatchReferenceSegment.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #305 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\DynamicPathSegment.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #306 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\EachSegment.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #307 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\EntitySetSegment.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #308 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\FilterSegment.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\KeySegment.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #310 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\NavigationPropertyLinkSegment.cs, Line: 102, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #311 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\NavigationPropertySegment.cs, Line: 103, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #312 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\ODataPathExtensions.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #313 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\ODataPathExtensions.cs, Line: 198, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #314 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\ODataPathExtensions.cs, Line: 212, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #315 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\OperationImportSegment.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #316 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\OperationImportSegment.cs, Line: 265, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #317 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\OperationSegment.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\OperationSegment.cs, Line: 261, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #319 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\PropertySegment.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #320 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\ReferenceSegment.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClause.cs, Line: 133, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #322 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClause.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClause.cs, Line: 99, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #324 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClauseExtensions.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #325 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClauseExtensions.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #326 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClauseExtensions.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #327 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SelectExpandClauseExtensions.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #328 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\SingletonSegment.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #329 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\TypeSegment.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #330 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SemanticAst\ValueSegment.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #331 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SyntacticAst\ComputeExpressionToken.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #332 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\SyntacticAst\ComputeToken.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #333 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\TypePromotionUtils.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #334 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\TypePromotionUtils.cs, Line: 227, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #335 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\UriEdmHelpers.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #336 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\UriEdmHelpers.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #337 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\UriEdmHelpers.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #338 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Visitors\PathSegmentToContextUrlPathTranslator.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #339 Path: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Visitors\PathSegmentToResourcePathTranslator.cs, Line: 50, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #341 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #342 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 153, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #343 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 161, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #344 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #345 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #346 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 195, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #347 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\Rules\DeprecationRules.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #348 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\ValidationEngine\ODataUrlValidator.cs, Line: 416, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #349 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\ValidationEngine\ODataUrlValidator.cs, Line: 447, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #350 Path: D:\a\1\s\src\Microsoft.OData.Core\UrlValidation\ValidationEngine\PathSegmentValidator.cs, Line: 272, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #351 Path: D:\a\1\s\src\Microsoft.OData.Core\Utils.cs, Line: 31, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #352 Path: D:\a\1\s\src\Microsoft.OData.Core\Value\ODataValueUtils.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\src\Microsoft.OData.Core\Value\ODataValueUtils.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #354 Path: D:\a\1\s\src\Microsoft.OData.Core\WriterValidationUtils.cs, Line: 316, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #355 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 572, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #356 Path: D:\a\1\s\src\PlatformHelper.cs, Line: 711, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Microsoft.OData.Core.Tests(net452)
    #357 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\ODataJsonLightWriterEnumIntegrationTests.cs, Line: 991, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #358 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\ODataJsonLightWriterEnumIntegrationTests.cs, Line: 998, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #359 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\UriParameterWriterIntegrationTests.cs, Line: 491, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #360 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #361 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 114, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #363 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #364 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 126, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 128, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #366 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #367 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #368 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #369 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 165, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #370 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 189, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #371 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 191, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #372 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 29, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #373 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsAsyncTests.cs, Line: 42, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #374 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #375 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 105, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #376 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #377 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 117, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #378 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 127, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #379 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 129, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #380 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 139, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #381 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 141, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #382 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 164, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #383 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 166, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #384 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 190, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #385 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #386 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 28, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #387 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\JsonValueUtilsTests.cs, Line: 41, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #388 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterAsyncTests.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #389 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterAsyncTests.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #390 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterAsyncTests.cs, Line: 66, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #391 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterAsyncTests.cs, Line: 68, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #392 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterTests.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterTests.cs, Line: 31, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #394 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterTests.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #395 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Json\NonIndentedTextWriterTests.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #396 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs, Line: 1146, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #397 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs, Line: 707, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #398 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightEntryAndFeedDeserializerUndeclaredTests.cs, Line: 765, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #399 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightParameterReaderTests.cs, Line: 135, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #400 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightParameterReaderTests.cs, Line: 187, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #401 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightParameterReaderTests.cs, Line: 203, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #402 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\ODataJsonLightPropertySerializerTests.cs, Line: 344, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #403 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\JsonLight\PayloadValueConverters.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #404 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\MediaTypeUtilsTests.cs, Line: 446, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #405 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\EdmLibraryExtensionsTests.cs, Line: 563, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #406 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\EdmLibraryExtensionsTests.cs, Line: 571, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #407 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\EdmLibraryExtensionsTests.cs, Line: 586, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #408 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\MetadataUtilsTests.cs, Line: 36, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #409 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\MetadataUtilsTests.cs, Line: 46, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #410 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\MetadataUtilsTests.cs, Line: 88, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #411 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\Metadata\MetadataUtilsTests.cs, Line: 98, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #412 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\NavigationPropertyOnComplexTests.cs, Line: 182, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #413 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\NavigationPropertyOnComplexTests.cs, Line: 191, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #414 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\NavigationPropertyOnComplexTests.cs, Line: 44, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #415 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\NavigationPropertyOnComplexTests.cs, Line: 52, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #416 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ODataPreferenceHeaderTests.cs, Line: 297, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #417 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ODataPreferenceHeaderTests.cs, Line: 311, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #418 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ODataReaderDerivedTypeConstraintTests.cs, Line: 156, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #419 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ODataReaderDerivedTypeConstraintTests.cs, Line: 182, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #420 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ODataReaderDerivedTypeConstraintTests.cs, Line: 211, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #421 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\CustomInstanceAnnotationAcceptanceTests.cs, Line: 175, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #422 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\CustomInstanceAnnotationAcceptanceTests.cs, Line: 192, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #423 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\CustomInstanceAnnotationAcceptanceTests.cs, Line: 211, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #424 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\CustomInstanceAnnotationAcceptanceTests.cs, Line: 220, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #425 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\DisablePrimitiveTypeConversionTests.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #426 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Reader\JsonLight\DateTimeReaderJsonLightTests.cs, Line: 92, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #427 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1007, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #428 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1034, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #429 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1060, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #430 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1090, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #431 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1135, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #432 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #433 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1203, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #434 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #435 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1261, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #436 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1278, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #437 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1299, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #438 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1315, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #439 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1352, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #440 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1379, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #441 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1395, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #442 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1419, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #443 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #444 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1443, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #445 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1465, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #446 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1477, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #447 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1505, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #448 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1513, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #449 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #450 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1537, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #451 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1561, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #452 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1586, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #453 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1602, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #454 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1611, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #455 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1636, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #456 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 1658, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #457 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #458 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 304, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #459 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 339, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #460 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 376, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #461 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 436, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #462 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 463, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #463 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 491, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #464 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #465 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 567, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #466 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 603, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #467 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 645, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #468 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 687, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #469 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 724, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #470 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 809, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #471 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 854, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #472 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 912, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #473 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\ContextUrlWriterReaderTests.cs, Line: 987, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #474 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\CustomInstanceAnnotationRoundtripJsonLightTests.cs, Line: 142, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #475 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\MultipartMixedBatchDependsOnIdsTests.cs, Line: 318, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #476 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\PrimitiveValuesRoundtripJsonLightTests.cs, Line: 714, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #477 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\PrimitiveValuesRoundtripJsonLightTests.cs, Line: 716, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #478 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Streaming\ODataJsonLightStreamReadingTests.cs, Line: 1236, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #479 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Streaming\ODataJsonLightStreamReadingTests.cs, Line: 363, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #480 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Streaming\ODataJsonLightStreamReadingTests.cs, Line: 54, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #481 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\UriParser\SelectExpandFunctionalTests.cs, Line: 899, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #482 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\UriParser\SemanticTreeFunctionalTests.cs, Line: 432, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #483 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\UriParser\SemanticTreeFunctionalTests.cs, Line: 467, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #484 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\SelectedPropertiesNodeTests.cs, Line: 634, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #485 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Binders\SelectBinderTests.cs, Line: 166, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #486 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Extensions\PathSegmentTokenExtensions.cs, Line: 32, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #487 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Extensions\SelectExpandTokenSyntacticTreeVisitor.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #488 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\HardCodedTestModel.cs, Line: 2455, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #489 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Metadata\ODataUriResolverTests.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #490 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\ODataUriParserTests.cs, Line: 1050, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #491 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\ODataUriParserTests.cs, Line: 954, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #492 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 683, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #493 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 704, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #494 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 725, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #495 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 749, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #496 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 777, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #497 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 812, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #498 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 840, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #499 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 865, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #500 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 889, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #501 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralParserTests.cs, Line: 916, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #502 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralPrefixesTests.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #503 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\Parsers\CustomUriLiteralPrefixesTests.cs, Line: 336, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #504 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\SemanticAst\ODataPathExtensionsTests.cs, Line: 316, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #505 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\SemanticAst\ODataPathExtensionsTests.cs, Line: 323, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #506 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ValidationHelper.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #507 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ValidationHelper.cs, Line: 63, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #508 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ValidationHelper.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #509 Path: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ValidationHelper.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #510 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\EdmToStockModelConverter.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #511 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\EdmToStockModelConverter.cs, Line: 420, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #512 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\EdmToStockModelConverter.cs, Line: 453, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #513 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\MetadataExtensionMethods.cs, Line: 277, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #514 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\MetadataExtensionMethods.cs, Line: 283, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #515 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\MetadataExtensionMethods.cs, Line: 286, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #516 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\MetadataUtils.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #517 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\Metadata\MetadataUtils.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #518 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\ODataLibTest\ModelBuilder.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #519 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\ODataLibTest\ModelBuilder.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #520 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\ODataLibTest\ModelBuilder.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #521 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\ODataLibTest\ModelBuilder.cs, Line: 178, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #522 Path: D:\a\1\s\test\FunctionalTests\Tests\TestUtils\Common\Microsoft.Test.OData.Utils\ODataLibTest\ModelBuilder.cs, Line: 406, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Microsoft.OData.PublicApi.Tests
    #523 Path: D:\a\1\s\test\PublicApiTests\PublicApiTests.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #524 Path: D:\a\1\s\test\PublicApiTests\PublicApiTests.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R8: 285
R9: 117
R4: 48
R2: 30
R5: 26
R7: 9
R3: 4
R10: 3
R6: 2

--- Summary ---
Fixed ReSharper issues: 494
Fixed SonarQube issues: 83
Total fixed issues: 524

Finished in: 1 min 1 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsComplexTypeDefinition.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlComplexType.
    /// </summary>
    internal class CsdlSemanticsComplexTypeDefinition : CsdlSemanticsStructuredTypeDefinition, IEdmComplexType, IEdmFullNamedElement
    {
        private readonly string fullName;
        private readonly CsdlComplexType complex;

        private readonly Cache<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> baseTypeCache = new Cache<CsdlSemanticsComplexTypeDefinition, IEdmComplexType>();
        private static readonly Func<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> ComputeBaseTypeFunc = (me) => me.ComputeBaseType();
        private static readonly Func<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> OnCycleBaseTypeFunc = (me) => new CyclicComplexType(me.GetCyclicBaseTypeName(me.complex.BaseTypeName), me.Location);

        public CsdlSemanticsComplexTypeDefinition(CsdlSemanticsSchema context, CsdlComplexType complex)
            : base(context, complex)
        {
            this.complex = complex;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(context?.Namespace, this.complex?.Name);
        }

        public override IEdmStructuredType BaseType
        {
            get { return this.baseTypeCache.GetValue(this, ComputeBaseTypeFunc, OnCycleBaseTypeFunc); }
        }

        public override EdmTypeKind TypeKind
        {
            get { return EdmTypeKind.Complex; }
        }

        public override bool IsAbstract
        {
            get { return this.complex.IsAbstract; }
        }

        public override bool IsOpen
        {
            get { return this.complex.IsOpen; }
        }

        public string Name
        {
            get { return this.complex.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        protected override CsdlStructuredType MyStructured
        {
            get { return this.complex; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "baseType2",
            Justification = "Value assignment is required by compiler.")]
        private IEdmComplexType ComputeBaseType()
        {
            if (this.complex.BaseTypeName != null)
            {
                IEdmComplexType baseType = this.Context.FindType(this.complex.BaseTypeName) as IEdmComplexType;
                if (baseType != null)
                {
                    // Evaluate the inductive step to detect cycles.
                    // Overriding BaseType getter from concrete type implementing IEdmComplexType will be invoked to
                    // detect cycles. The object assignment is required by compiler only.
                    IEdmStructuredType baseType2 = baseType.BaseType;
                }

                return baseType ?? new UnresolvedComplexType(this.Context.UnresolvedName(this.complex.BaseTypeName), this.Location);
            }

            return null;
        }
    }
}

---- Transformed Tree ----
using System;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlComplexType.
    /// </summary>
    internal class CsdlSemanticsComplexTypeDefinition : CsdlSemanticsStructuredTypeDefinition, IEdmComplexType, IEdmFullNamedElement
    {
        private readonly string fullName;
        private readonly CsdlComplexType complex;

        private readonly Cache<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> baseTypeCache = new Cache<CsdlSemanticsComplexTypeDefinition, IEdmComplexType>();
        private static readonly Func<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> ComputeBaseTypeFunc = (me) => me.ComputeBaseType();
        private static readonly Func<CsdlSemanticsComplexTypeDefinition, IEdmComplexType> OnCycleBaseTypeFunc = (me) => new CyclicComplexType(me.GetCyclicBaseTypeName(me.complex.BaseTypeName), me.Location);

        public CsdlSemanticsComplexTypeDefinition(CsdlSemanticsSchema context, CsdlComplexType complex)
            : base(context, complex)
        {
            this.complex = complex;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(context?.Namespace, this.complex?.Name);
        }

        public override IEdmStructuredType BaseType
        {
            get { return this.baseTypeCache.GetValue(this, ComputeBaseTypeFunc, OnCycleBaseTypeFunc); }
        }

        public override EdmTypeKind TypeKind
        {
            get { return EdmTypeKind.Complex; }
        }

        public override bool IsAbstract
        {
            get { return this.complex.IsAbstract; }
        }

        public override bool IsOpen
        {
            get { return this.complex.IsOpen; }
        }

        public string Name
        {
            get { return this.complex.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        protected override CsdlStructuredType MyStructured
        {
            get { return this.complex; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "baseType2",
            Justification = "Value assignment is required by compiler.")]
        private IEdmComplexType ComputeBaseType()
        {
            if (this.complex.BaseTypeName != null)
            {
                if (this.Context.FindType(this.complex.BaseTypeName) is IEdmComplexType baseType)
                {
                    // Evaluate the inductive step to detect cycles.
                    // Overriding BaseType getter from concrete type implementing IEdmComplexType will be invoked to
                    // detect cycles. The object assignment is required by compiler only.
                    IEdmStructuredType baseType2 = baseType.BaseType;
                }

                return baseType ?? new UnresolvedComplexType(this.Context.UnresolvedName(this.complex.BaseTypeName), this.Location);
            }

            return null;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsComplexTypeDefinition.cs(83,24): error CS0165: Use of unassigned local variable 'baseType'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityContainer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlEntityContainer.
    /// </summary>
    internal class CsdlSemanticsEntityContainer : CsdlSemanticsElement, IEdmEntityContainer, IEdmCheckable, IEdmFullNamedElement
    {
        private readonly string fullName;
        private readonly CsdlEntityContainer entityContainer;
        private readonly CsdlSemanticsSchema context;

        private readonly Cache<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>> elementsCache = new Cache<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>> ComputeElementsFunc = (me) => me.ComputeElements();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>> entitySetDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>> ComputeEntitySetDictionaryFunc = (me) => me.ComputeEntitySetDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>> singletonDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>> ComputeSingletonDictionaryFunc = (me) => me.ComputeSingletonDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, object>> operationImportsDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, object>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, object>> ComputeOperationImportsDictionaryFunc = (me) => me.ComputeOperationImportsDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, IEnumerable<EdmError>> errorsCache = new Cache<CsdlSemanticsEntityContainer, IEnumerable<EdmError>>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEnumerable<EdmError>> ComputeErrorsFunc = (me) => me.ComputeErrors();

        private readonly Cache<CsdlSemanticsEntityContainer, IEdmEntityContainer> extendsCache = new Cache<CsdlSemanticsEntityContainer, IEdmEntityContainer>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEdmEntityContainer> ComputeExtendsFunc = (me) => me.ComputeExtends();
        private static readonly Func<CsdlSemanticsEntityContainer, IEdmEntityContainer> OnCycleExtendsFunc = (me) => new CyclicEntityContainer(me.entityContainer.Extends, me.Location);

        public CsdlSemanticsEntityContainer(CsdlSemanticsSchema context, CsdlEntityContainer entityContainer)
            : base(entityContainer)
        {
            this.context = context;
            this.entityContainer = entityContainer;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(this.context?.Namespace, this.entityContainer?.Name);
        }

        public EdmSchemaElementKind SchemaElementKind
        {
            get { return EdmSchemaElementKind.EntityContainer; }
        }

        public override CsdlSemanticsModel Model
        {
            get { return this.context.Model; }
        }

        public IEnumerable<IEdmEntityContainerElement> Elements
        {
            get { return this.elementsCache.GetValue(this, ComputeElementsFunc, null); }
        }

        public string Namespace
        {
            get { return this.context.Namespace; }
        }

        public string Name
        {
            get { return this.entityContainer.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        public IEnumerable<EdmError> Errors
        {
            get { return this.errorsCache.GetValue(this, ComputeErrorsFunc, null); }
        }

        public override CsdlElement Element
        {
            get { return this.entityContainer; }
        }

        internal CsdlSemanticsSchema Context
        {
            get { return this.context; }
        }

        internal IEdmEntityContainer Extends
        {
            get { return this.extendsCache.GetValue(this, ComputeExtendsFunc, OnCycleExtendsFunc); }
        }

        private Dictionary<string, IEdmEntitySet> EntitySetDictionary
        {
            get { return this.entitySetDictionaryCache.GetValue(this, ComputeEntitySetDictionaryFunc, null); }
        }

        private Dictionary<string, IEdmSingleton> SingletonDictionary
        {
            get { return this.singletonDictionaryCache.GetValue(this, ComputeSingletonDictionaryFunc, null); }
        }

        private Dictionary<string, object> OperationImportsDictionary
        {
            get { return this.operationImportsDictionaryCache.GetValue(this, ComputeOperationImportsDictionaryFunc, null); }
        }

        public IEdmEntitySet FindEntitySet(string name)
        {
            IEdmEntitySet element;
            return this.EntitySetDictionary.TryGetValue(name, out element) ? element : null;
        }

        public IEdmSingleton FindSingleton(string name)
        {
            IEdmSingleton element;
            return this.SingletonDictionary.TryGetValue(name, out element) ? element : null;
        }

        public IEnumerable<IEdmOperationImport> FindOperationImports(string operationName)
        {
            object element;
            if (this.OperationImportsDictionary.TryGetValue(operationName, out element))
            {
                List<IEdmOperationImport> listElement = element as List<IEdmOperationImport>;
                if (listElement != null)
                {
                    return listElement;
                }

                return new IEdmOperationImport[] { (IEdmOperationImport)element };
            }

            return Enumerable.Empty<IEdmOperationImport>();
        }

        protected override IEnumerable<IEdmVocabularyAnnotation> ComputeInlineVocabularyAnnotations()
        {
            return this.Model.WrapInlineVocabularyAnnotations(this, this.Context);
        }

        private IEnumerable<IEdmEntityContainerElement> ComputeElements()
        {
            List<IEdmEntityContainerElement> elements = new List<IEdmEntityContainerElement>();

            // don't import this.Extends' elements.
            // (all IEdmxxx like IEdmEntityContainer should let extension methods handle cross model searches).
            foreach (CsdlEntitySet entitySet in this.entityContainer.EntitySets)
            {
                CsdlSemanticsEntitySet semanticsSet = new CsdlSemanticsEntitySet(this, entitySet);
                elements.Add(semanticsSet);
            }

            foreach (CsdlSingleton singleton in entityContainer.Singletons)
            {
                CsdlSemanticsSingleton semanticsSingleton = new CsdlSemanticsSingleton(this, singleton);
                elements.Add(semanticsSingleton);
            }

            foreach (CsdlOperationImport operationImport in this.entityContainer.OperationImports)
            {
                this.AddOperationImport(operationImport, elements);
            }

            return elements;
        }

        private void AddOperationImport(CsdlOperationImport operationImport, List<IEdmEntityContainerElement> elements)
        {
            var functionImport = operationImport as CsdlFunctionImport;
            var actionImport = operationImport as CsdlActionImport;
            CsdlSemanticsOperationImport semanticsOperation = null;
            EdmSchemaElementKind filterKind = EdmSchemaElementKind.Action;
            if (functionImport != null)
            {
                filterKind = EdmSchemaElementKind.Function;
            }

            // OperationImports only work with non-bound operations hence this extra logic in the where clause
            var operations = this.context.FindOperations(operationImport.SchemaOperationQualifiedTypeName).Where(o => o.SchemaElementKind == filterKind && !o.IsBound);

            int operationsCount = 0;
            foreach (IEdmOperation operation in operations)
            {
                if (functionImport != null)
                {
                    semanticsOperation = new CsdlSemanticsFunctionImport(this, functionImport, (IEdmFunction)operation);
                }
                else
                {
                    Debug.Assert(actionImport != null, "actionImport should not be null");
                    semanticsOperation = new CsdlSemanticsActionImport(this, actionImport, (IEdmAction)operation);
                }

                operationsCount++;
                elements.Add(semanticsOperation);
            }

            // If none have been created then its an unresolved operation.
            if (operationsCount == 0)
            {
                if (filterKind == EdmSchemaElementKind.Action)
                {
                    var action = new UnresolvedAction(operationImport.SchemaOperationQualifiedTypeName, Edm.Strings.Bad_UnresolvedOperation(operationImport.SchemaOperationQualifiedTypeName), operationImport.Location);
                    semanticsOperation = new CsdlSemanticsActionImport(this, actionImport, action);
                }
                else
                {
                    Debug.Assert(filterKind == EdmSchemaElementKind.Function, "Should be a function");
                    var function = new UnresolvedFunction(operationImport.SchemaOperationQualifiedTypeName, Edm.Strings.Bad_UnresolvedOperation(operationImport.SchemaOperationQualifiedTypeName), operationImport.Location);
                    semanticsOperation = new CsdlSemanticsFunctionImport(this, functionImport, function);
                }

                elements.Add(semanticsOperation);
            }
        }

        private IEnumerable<EdmError> ComputeErrors()
        {
            List<EdmError> errors = new List<EdmError>();
            if (this.Extends != null && this.Extends.IsBad())
            {
                errors.AddRange(((IEdmCheckable)this.Extends).Errors);
            }

            return errors;
        }

        private Dictionary<string, IEdmEntitySet> ComputeEntitySetDictionary()
        {
            Dictionary<string, IEdmEntitySet> sets = new Dictionary<string, IEdmEntitySet>();
            foreach (IEdmEntitySet entitySet in this.Elements.OfType<IEdmEntitySet>())
            {
                RegistrationHelper.AddElement(entitySet, entitySet.Name, sets, RegistrationHelper.CreateAmbiguousEntitySetBinding);
            }

            return sets;
        }

        private Dictionary<string, IEdmSingleton> ComputeSingletonDictionary()
        {
            Dictionary<string, IEdmSingleton> sets = new Dictionary<string, IEdmSingleton>();
            foreach (IEdmSingleton singleton in this.Elements.OfType<IEdmSingleton>())
            {
                RegistrationHelper.AddElement(singleton, singleton.Name, sets, RegistrationHelper.CreateAmbiguousSingletonBinding);
            }

            return sets;
        }

        private Dictionary<string, object> ComputeOperationImportsDictionary()
        {
            Dictionary<string, object> operationImports = new Dictionary<string, object>();
            foreach (IEdmOperationImport operationImport in this.Elements.OfType<IEdmOperationImport>())
            {
                RegistrationHelper.AddOperationImport(operationImport, operationImport.Name, operationImports);
            }

            return operationImports;
        }

        private IEdmEntityContainer ComputeExtends()
        {
            string containerFullNameExtended = this.entityContainer.Extends;
            if (containerFullNameExtended != null)
            {
                IEdmEntityContainer ret = this.Context.FindEntityContainer(containerFullNameExtended);
                return ret ?? new UnresolvedEntityContainer(this.entityContainer.Extends, this.Location);
            }

            return null;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlEntityContainer.
    /// </summary>
    internal class CsdlSemanticsEntityContainer : CsdlSemanticsElement, IEdmEntityContainer, IEdmCheckable, IEdmFullNamedElement
    {
        private readonly string fullName;
        private readonly CsdlEntityContainer entityContainer;
        private readonly CsdlSemanticsSchema context;

        private readonly Cache<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>> elementsCache = new Cache<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEnumerable<IEdmEntityContainerElement>> ComputeElementsFunc = (me) => me.ComputeElements();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>> entitySetDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, IEdmEntitySet>> ComputeEntitySetDictionaryFunc = (me) => me.ComputeEntitySetDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>> singletonDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, IEdmSingleton>> ComputeSingletonDictionaryFunc = (me) => me.ComputeSingletonDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, Dictionary<string, object>> operationImportsDictionaryCache = new Cache<CsdlSemanticsEntityContainer, Dictionary<string, object>>();
        private static readonly Func<CsdlSemanticsEntityContainer, Dictionary<string, object>> ComputeOperationImportsDictionaryFunc = (me) => me.ComputeOperationImportsDictionary();

        private readonly Cache<CsdlSemanticsEntityContainer, IEnumerable<EdmError>> errorsCache = new Cache<CsdlSemanticsEntityContainer, IEnumerable<EdmError>>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEnumerable<EdmError>> ComputeErrorsFunc = (me) => me.ComputeErrors();

        private readonly Cache<CsdlSemanticsEntityContainer, IEdmEntityContainer> extendsCache = new Cache<CsdlSemanticsEntityContainer, IEdmEntityContainer>();
        private static readonly Func<CsdlSemanticsEntityContainer, IEdmEntityContainer> ComputeExtendsFunc = (me) => me.ComputeExtends();
        private static readonly Func<CsdlSemanticsEntityContainer, IEdmEntityContainer> OnCycleExtendsFunc = (me) => new CyclicEntityContainer(me.entityContainer.Extends, me.Location);

        public CsdlSemanticsEntityContainer(CsdlSemanticsSchema context, CsdlEntityContainer entityContainer)
            : base(entityContainer)
        {
            this.context = context;
            this.entityContainer = entityContainer;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(this.context?.Namespace, this.entityContainer?.Name);
        }

        public EdmSchemaElementKind SchemaElementKind
        {
            get { return EdmSchemaElementKind.EntityContainer; }
        }

        public override CsdlSemanticsModel Model
        {
            get { return this.context.Model; }
        }

        public IEnumerable<IEdmEntityContainerElement> Elements
        {
            get { return this.elementsCache.GetValue(this, ComputeElementsFunc, null); }
        }

        public string Namespace
        {
            get { return this.context.Namespace; }
        }

        public string Name
        {
            get { return this.entityContainer.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        public IEnumerable<EdmError> Errors
        {
            get { return this.errorsCache.GetValue(this, ComputeErrorsFunc, null); }
        }

        public override CsdlElement Element
        {
            get { return this.entityContainer; }
        }

        internal CsdlSemanticsSchema Context
        {
            get { return this.context; }
        }

        internal IEdmEntityContainer Extends
        {
            get { return this.extendsCache.GetValue(this, ComputeExtendsFunc, OnCycleExtendsFunc); }
        }

        private Dictionary<string, IEdmEntitySet> EntitySetDictionary
        {
            get { return this.entitySetDictionaryCache.GetValue(this, ComputeEntitySetDictionaryFunc, null); }
        }

        private Dictionary<string, IEdmSingleton> SingletonDictionary
        {
            get { return this.singletonDictionaryCache.GetValue(this, ComputeSingletonDictionaryFunc, null); }
        }

        private Dictionary<string, object> OperationImportsDictionary
        {
            get { return this.operationImportsDictionaryCache.GetValue(this, ComputeOperationImportsDictionaryFunc, null); }
        }

        public IEdmEntitySet FindEntitySet(string name)
        {
            IEdmEntitySet element;
            return this.EntitySetDictionary.TryGetValue(name, out element) ? element : null;
        }

        public IEdmSingleton FindSingleton(string name)
        {
            IEdmSingleton element;
            return this.SingletonDictionary.TryGetValue(name, out element) ? element : null;
        }

        public IEnumerable<IEdmOperationImport> FindOperationImports(string operationName)
        {
            object element;
            if (this.OperationImportsDictionary.TryGetValue(operationName, out element))
            {
                if (element is List<IEdmOperationImport> listElement)
                {
                    return listElement;
                }

                return new IEdmOperationImport[] { (IEdmOperationImport)element };
            }

            return Enumerable.Empty<IEdmOperationImport>();
        }

        protected override IEnumerable<IEdmVocabularyAnnotation> ComputeInlineVocabularyAnnotations()
        {
            return this.Model.WrapInlineVocabularyAnnotations(this, this.Context);
        }

        private IEnumerable<IEdmEntityContainerElement> ComputeElements()
        {
            List<IEdmEntityContainerElement> elements = new List<IEdmEntityContainerElement>();

            // don't import this.Extends' elements.
            // (all IEdmxxx like IEdmEntityContainer should let extension methods handle cross model searches).
            foreach (CsdlEntitySet entitySet in this.entityContainer.EntitySets)
            {
                CsdlSemanticsEntitySet semanticsSet = new CsdlSemanticsEntitySet(this, entitySet);
                elements.Add(semanticsSet);
            }

            foreach (CsdlSingleton singleton in entityContainer.Singletons)
            {
                CsdlSemanticsSingleton semanticsSingleton = new CsdlSemanticsSingleton(this, singleton);
                elements.Add(semanticsSingleton);
            }

            foreach (CsdlOperationImport operationImport in this.entityContainer.OperationImports)
            {
                this.AddOperationImport(operationImport, elements);
            }

            return elements;
        }

        private void AddOperationImport(CsdlOperationImport operationImport, List<IEdmEntityContainerElement> elements)
        {
            CsdlSemanticsOperationImport semanticsOperation = null;
            EdmSchemaElementKind filterKind = EdmSchemaElementKind.Action;

            if (operationImport is CsdlFunctionImport functionImport)
            {
                filterKind = EdmSchemaElementKind.Function;
            }

            // OperationImports only work with non-bound operations hence this extra logic in the where clause
            var operations = this.context.FindOperations(operationImport.SchemaOperationQualifiedTypeName).Where(o => o.SchemaElementKind == filterKind && !o.IsBound);

            int operationsCount = 0;
            foreach (IEdmOperation operation in operations)
            {
                if (operationImport is CsdlFunctionImport functionImport)
                {
                    semanticsOperation = new CsdlSemanticsFunctionImport(this, functionImport, (IEdmFunction)operation);
                }
                else
                {
                    Debug.Assert(operationImport is CsdlActionImport actionImport, "actionImport should not be null");
                    semanticsOperation = new CsdlSemanticsActionImport(this, actionImport, (IEdmAction)operation);
                }

                operationsCount++;
                elements.Add(semanticsOperation);
            }

            // If none have been created then its an unresolved operation.
            if (operationsCount == 0)
            {
                if (filterKind == EdmSchemaElementKind.Action)
                {
                    var action = new UnresolvedAction(operationImport.SchemaOperationQualifiedTypeName, Edm.Strings.Bad_UnresolvedOperation(operationImport.SchemaOperationQualifiedTypeName), operationImport.Location);
                    semanticsOperation = new CsdlSemanticsActionImport(this, actionImport, action);
                }
                else
                {
                    Debug.Assert(filterKind == EdmSchemaElementKind.Function, "Should be a function");
                    var function = new UnresolvedFunction(operationImport.SchemaOperationQualifiedTypeName, Edm.Strings.Bad_UnresolvedOperation(operationImport.SchemaOperationQualifiedTypeName), operationImport.Location);
                    semanticsOperation = new CsdlSemanticsFunctionImport(this, functionImport, function);
                }

                elements.Add(semanticsOperation);
            }
        }

        private IEnumerable<EdmError> ComputeErrors()
        {
            List<EdmError> errors = new List<EdmError>();
            if (this.Extends != null && this.Extends.IsBad())
            {
                errors.AddRange(((IEdmCheckable)this.Extends).Errors);
            }

            return errors;
        }

        private Dictionary<string, IEdmEntitySet> ComputeEntitySetDictionary()
        {
            Dictionary<string, IEdmEntitySet> sets = new Dictionary<string, IEdmEntitySet>();
            foreach (IEdmEntitySet entitySet in this.Elements.OfType<IEdmEntitySet>())
            {
                RegistrationHelper.AddElement(entitySet, entitySet.Name, sets, RegistrationHelper.CreateAmbiguousEntitySetBinding);
            }

            return sets;
        }

        private Dictionary<string, IEdmSingleton> ComputeSingletonDictionary()
        {
            Dictionary<string, IEdmSingleton> sets = new Dictionary<string, IEdmSingleton>();
            foreach (IEdmSingleton singleton in this.Elements.OfType<IEdmSingleton>())
            {
                RegistrationHelper.AddElement(singleton, singleton.Name, sets, RegistrationHelper.CreateAmbiguousSingletonBinding);
            }

            return sets;
        }

        private Dictionary<string, object> ComputeOperationImportsDictionary()
        {
            Dictionary<string, object> operationImports = new Dictionary<string, object>();
            foreach (IEdmOperationImport operationImport in this.Elements.OfType<IEdmOperationImport>())
            {
                RegistrationHelper.AddOperationImport(operationImport, operationImport.Name, operationImports);
            }

            return operationImports;
        }

        private IEdmEntityContainer ComputeExtends()
        {
            string containerFullNameExtended = this.entityContainer.Extends;
            if (containerFullNameExtended != null)
            {
                IEdmEntityContainer ret = this.Context.FindEntityContainer(containerFullNameExtended);
                return ret ?? new UnresolvedEntityContainer(this.entityContainer.Extends, this.Location);
            }

            return null;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityContainer.cs(196,59): error CS0136: A local or parameter named 'functionImport' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityContainer.cs(216,78): error CS0103: The name 'actionImport' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityContainer.cs(203,78): error CS0165: Use of unassigned local variable 'actionImport',D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityContainer.cs(222,80): error CS0165: Use of unassigned local variable 'functionImport'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityTypeDefinition.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlEntityType.
    /// </summary>
    internal class CsdlSemanticsEntityTypeDefinition : CsdlSemanticsStructuredTypeDefinition, IEdmEntityType, IEdmFullNamedElement
    {
        private readonly CsdlEntityType entity;
        private readonly string fullName;

        private readonly Cache<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> baseTypeCache = new Cache<CsdlSemanticsEntityTypeDefinition, IEdmEntityType>();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> ComputeBaseTypeFunc = (me) => me.ComputeBaseType();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> OnCycleBaseTypeFunc = (me) => new CyclicEntityType(me.GetCyclicBaseTypeName(me.entity.BaseTypeName), me.Location);

        private readonly Cache<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>> declaredKeyCache = new Cache<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>>();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>> ComputeDeclaredKeyFunc = (me) => me.ComputeDeclaredKey();

        public CsdlSemanticsEntityTypeDefinition(CsdlSemanticsSchema context, CsdlEntityType entity)
            : base(context, entity)
        {
            this.entity = entity;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(context?.Namespace, this.entity?.Name);
        }

        public override IEdmStructuredType BaseType
        {
            get { return this.baseTypeCache.GetValue(this, ComputeBaseTypeFunc, OnCycleBaseTypeFunc); }
        }

        public override EdmTypeKind TypeKind
        {
            get { return EdmTypeKind.Entity; }
        }

        public string Name
        {
            get { return this.entity.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        public override bool IsAbstract
        {
            get { return this.entity.IsAbstract; }
        }

        public override bool IsOpen
        {
            get { return this.entity.IsOpen; }
        }

        public bool HasStream
        {
            get { return this.entity.HasStream; }
        }

        public IEnumerable<IEdmStructuralProperty> DeclaredKey
        {
            get
            {
                return this.declaredKeyCache.GetValue(this, ComputeDeclaredKeyFunc, null);
            }
        }

        protected override CsdlStructuredType MyStructured
        {
            get { return this.entity; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "baseType2",
            Justification = "Value assignment is required by compiler.")]
        private IEdmEntityType ComputeBaseType()
        {
            if (this.entity.BaseTypeName != null)
            {
                IEdmEntityType baseType = this.Context.FindType(this.entity.BaseTypeName) as IEdmEntityType;
                if (baseType != null)
                {
                    // Evaluate the inductive step to detect cycles.
                    // Overriding BaseType getter from concrete type implementing IEdmComplexType will be invoked to
                    // detect cycles. The object assignment is required by compiler only.
                    IEdmStructuredType baseType2 = baseType.BaseType;
                }

                return baseType ?? new UnresolvedEntityType(this.Context.UnresolvedName(this.entity.BaseTypeName), this.Location);
            }

            return null;
        }

        private IEnumerable<IEdmStructuralProperty> ComputeDeclaredKey()
        {
            if (this.entity.Key != null)
            {
                List<IEdmStructuralProperty> key = new List<IEdmStructuralProperty>();
                foreach (CsdlPropertyReference keyProperty in this.entity.Key.Properties)
                {
                    IEdmStructuralProperty structuralProperty = this.FindProperty(keyProperty.PropertyName) as IEdmStructuralProperty;
                    if (structuralProperty != null)
                    {
                        key.Add(structuralProperty);
                    }
                    else
                    {
                        // If keyProperty is a duplicate, it will come back as non-structural from FindProperty, but it still might be structural
                        // inside the DeclaredProperties, so try it. If it is not in the DeclaredProperties or it is not structural there,
                        // then fall back to unresolved.
                        structuralProperty = this.DeclaredProperties.FirstOrDefault(p => p.Name == keyProperty.PropertyName) as IEdmStructuralProperty;
                        if (structuralProperty != null)
                        {
                            key.Add(structuralProperty);
                        }
                        else
                        {
                            key.Add(new UnresolvedProperty(this, keyProperty.PropertyName, this.Location));
                        }
                    }
                }

                return key;
            }

            return null;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlEntityType.
    /// </summary>
    internal class CsdlSemanticsEntityTypeDefinition : CsdlSemanticsStructuredTypeDefinition, IEdmEntityType, IEdmFullNamedElement
    {
        private readonly CsdlEntityType entity;
        private readonly string fullName;

        private readonly Cache<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> baseTypeCache = new Cache<CsdlSemanticsEntityTypeDefinition, IEdmEntityType>();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> ComputeBaseTypeFunc = (me) => me.ComputeBaseType();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEdmEntityType> OnCycleBaseTypeFunc = (me) => new CyclicEntityType(me.GetCyclicBaseTypeName(me.entity.BaseTypeName), me.Location);

        private readonly Cache<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>> declaredKeyCache = new Cache<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>>();
        private static readonly Func<CsdlSemanticsEntityTypeDefinition, IEnumerable<IEdmStructuralProperty>> ComputeDeclaredKeyFunc = (me) => me.ComputeDeclaredKey();

        public CsdlSemanticsEntityTypeDefinition(CsdlSemanticsSchema context, CsdlEntityType entity)
            : base(context, entity)
        {
            this.entity = entity;
            this.fullName = EdmUtil.GetFullNameForSchemaElement(context?.Namespace, this.entity?.Name);
        }

        public override IEdmStructuredType BaseType
        {
            get { return this.baseTypeCache.GetValue(this, ComputeBaseTypeFunc, OnCycleBaseTypeFunc); }
        }

        public override EdmTypeKind TypeKind
        {
            get { return EdmTypeKind.Entity; }
        }

        public string Name
        {
            get { return this.entity.Name; }
        }

        /// <summary>
        /// Gets the full name of this schema element.
        /// </summary>
        public string FullName
        {
            get { return this.fullName; }
        }

        public override bool IsAbstract
        {
            get { return this.entity.IsAbstract; }
        }

        public override bool IsOpen
        {
            get { return this.entity.IsOpen; }
        }

        public bool HasStream
        {
            get { return this.entity.HasStream; }
        }

        public IEnumerable<IEdmStructuralProperty> DeclaredKey
        {
            get
            {
                return this.declaredKeyCache.GetValue(this, ComputeDeclaredKeyFunc, null);
            }
        }

        protected override CsdlStructuredType MyStructured
        {
            get { return this.entity; }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "baseType2",
            Justification = "Value assignment is required by compiler.")]
        private IEdmEntityType ComputeBaseType()
        {
            if (this.entity.BaseTypeName != null)
            {
                if (this.Context.FindType(this.entity.BaseTypeName) is IEdmEntityType baseType)
                {
                    // Evaluate the inductive step to detect cycles.
                    // Overriding BaseType getter from concrete type implementing IEdmComplexType will be invoked to
                    // detect cycles. The object assignment is required by compiler only.
                    IEdmStructuredType baseType2 = baseType.BaseType;
                }

                return baseType ?? new UnresolvedEntityType(this.Context.UnresolvedName(this.entity.BaseTypeName), this.Location);
            }

            return null;
        }

        private IEnumerable<IEdmStructuralProperty> ComputeDeclaredKey()
        {
            if (this.entity.Key != null)
            {
                List<IEdmStructuralProperty> key = new List<IEdmStructuralProperty>();
                foreach (CsdlPropertyReference keyProperty in this.entity.Key.Properties)
                {
                    if (this.FindProperty(keyProperty.PropertyName) is IEdmStructuralProperty structuralProperty)
                    {
                        key.Add(structuralProperty);
                    }
                    else
                    {
                        // If keyProperty is a duplicate, it will come back as non-structural from FindProperty, but it still might be structural
                        // inside the DeclaredProperties, so try it. If it is not in the DeclaredProperties or it is not structural there,
                        // then fall back to unresolved.
                        structuralProperty = this.DeclaredProperties.FirstOrDefault(p => p.Name == keyProperty.PropertyName) as IEdmStructuralProperty;

                        if (this.FindProperty(keyProperty.PropertyName) is IEdmStructuralProperty structuralProperty)
                        {
                            key.Add(structuralProperty);
                        }
                        else
                        {
                            key.Add(new UnresolvedProperty(this, keyProperty.PropertyName, this.Location));
                        }
                    }
                }

                return key;
            }

            return null;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityTypeDefinition.cs(101,24): error CS0165: Use of unassigned local variable 'baseType',D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityTypeDefinition.cs(123,25): error CS0841: Cannot use local variable 'structuralProperty' before it is declared,D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsEntityTypeDefinition.cs(125,99): error CS0136: A local or parameter named 'structuralProperty' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsSchema.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlSchema.
    /// </summary>
    internal class CsdlSemanticsSchema : CsdlSemanticsElement, IEdmCheckable
    {
        private readonly CsdlSemanticsModel model;
        private readonly CsdlSchema schema;

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>> typesCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>> ComputeTypesFunc = (me) => me.ComputeTypes();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmOperation>> operationsCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmOperation>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmOperation>> ComputeFunctionsFunc = (me) => me.ComputeOperations();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>> entityContainersCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>> ComputeEntityContainersFunc = (me) => me.ComputeEntityContainers();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmTerm>> termsCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmTerm>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmTerm>> ComputeTermsFunc = (me) => me.ComputeTerms();

        private readonly Cache<CsdlSemanticsSchema, Dictionary<string, object>> labeledExpressionsCache = new Cache<CsdlSemanticsSchema, Dictionary<string, object>>();
        private static readonly Func<CsdlSemanticsSchema, Dictionary<string, object>> ComputeLabeledExpressionsFunc = (me) => me.ComputeLabeledExpressions();

        private readonly Dictionary<CsdlLabeledExpression, IEdmLabeledExpression> semanticsLabeledElements = new Dictionary<CsdlLabeledExpression, IEdmLabeledExpression>();
        private readonly Dictionary<List<CsdlLabeledExpression>, IEdmLabeledExpression> ambiguousLabeledExpressions = new Dictionary<List<CsdlLabeledExpression>, IEdmLabeledExpression>();

        public CsdlSemanticsSchema(CsdlSemanticsModel model, CsdlSchema schema)
            : base(schema)
        {
            this.model = model;
            this.schema = schema;
        }

        public override CsdlSemanticsModel Model
        {
            get { return this.model; }
        }

        public override CsdlElement Element
        {
            get { return this.schema; }
        }

        public IEnumerable<IEdmSchemaType> Types
        {
            get { return this.typesCache.GetValue(this, ComputeTypesFunc, null); }
        }

        public IEnumerable<IEdmOperation> Operations
        {
            get { return this.operationsCache.GetValue(this, ComputeFunctionsFunc, null); }
        }

        public IEnumerable<IEdmTerm> Terms
        {
            get { return this.termsCache.GetValue(this, ComputeTermsFunc, null); }
        }

        public IEnumerable<IEdmEntityContainer> EntityContainers
        {
            get { return this.entityContainersCache.GetValue(this, ComputeEntityContainersFunc, null); }
        }

        public string Namespace
        {
            get { return this.schema.Namespace; }
        }

        public IEnumerable<EdmError> Errors
        {
            get
            {
                return Enumerable.Empty<EdmError>();
            }
        }

        /// <summary>
        /// Gets the labeled element expressions dictionary.
        /// Each value in the dictionary is either a <see cref="CsdlLabeledExpression"/> or a list of same.
        /// </summary>
        private Dictionary<string, object> LabeledExpressions
        {
            get { return this.labeledExpressionsCache.GetValue(this, ComputeLabeledExpressionsFunc, null); }
        }

        public IEnumerable<IEdmOperation> FindOperations(string name)
        {
            return FindSchemaElement<IEnumerable<IEdmOperation>>(name, ExtensionMethods.FindOperationsInModelTree);
        }

        public IEdmSchemaType FindType(string name)
        {
            return FindSchemaElement<IEdmSchemaType>(name, ExtensionMethods.FindTypeInModelTree);
        }

        public IEdmTerm FindTerm(string name)
        {
            return FindSchemaElement<IEdmTerm>(name, FindTerm);
        }

        public IEdmEntityContainer FindEntityContainer(string name)
        {
            return FindSchemaElement<IEdmEntityContainer>(name, FindEntityContainer);
        }

        public T FindSchemaElement<T>(string name, Func<CsdlSemanticsModel, string, T> modelFinder)
        {
            string namespaceQualifiedName = this.ReplaceAlias(name);
            return modelFinder(this.model, namespaceQualifiedName);
        }

        public string UnresolvedName(string qualifiedName)
        {
            if (qualifiedName == null)
            {
                return null;
            }

            return this.ReplaceAlias(qualifiedName);
        }

        public IEdmLabeledExpression FindLabeledElement(string label, IEdmEntityType bindingContext)
        {
            object labeledElement;
            if (this.LabeledExpressions.TryGetValue(label, out labeledElement))
            {
                CsdlLabeledExpression labeledElementExpression = labeledElement as CsdlLabeledExpression;
                if (labeledElementExpression != null)
                {
                    return this.WrapLabeledElement(labeledElementExpression, bindingContext);
                }

                return this.WrapLabeledElementList((List<CsdlLabeledExpression>)labeledElement, bindingContext);
            }

            return null;
        }

        public IEdmLabeledExpression WrapLabeledElement(CsdlLabeledExpression labeledElement, IEdmEntityType bindingContext)
        {
            IEdmLabeledExpression result;

            // Guarantee that multiple requests to wrap a given labeled element all return the same object.
            if (!this.semanticsLabeledElements.TryGetValue(labeledElement, out result))
            {
                result = new CsdlSemanticsLabeledExpression(labeledElement.Label, labeledElement.Element, bindingContext, this);
                this.semanticsLabeledElements[labeledElement] = result;
            }

            return result;
        }

        internal string ReplaceAlias(string name)
        {
            return this.model.ReplaceAlias(name);
        }

        private static IEdmTerm FindTerm(IEdmModel model, string name)
        {
            return model.FindTerm(name);
        }

        private static IEdmEntityContainer FindEntityContainer(IEdmModel model, string name)
        {
            return model.FindEntityContainer(name);
        }

        private static void AddLabeledExpressions(CsdlExpressionBase expression, Dictionary<string, object> result)
        {
            if (expression == null)
            {
                return;
            }

            switch (expression.ExpressionKind)
            {
                case EdmExpressionKind.Labeled:
                    {
                        CsdlLabeledExpression labeledElement = (CsdlLabeledExpression)expression;
                        string label = labeledElement.Label;
                        object duplicateLabeledElement;
                        if (result.TryGetValue(label, out duplicateLabeledElement))
                        {
                            // If the label has multiple definitions, store the duplicates as a list of labeled elements.
                            List<CsdlLabeledExpression> duplicates = duplicateLabeledElement as List<CsdlLabeledExpression>;
                            if (duplicates == null)
                            {
                                duplicates = new List<CsdlLabeledExpression>();
                                duplicates.Add((CsdlLabeledExpression)duplicateLabeledElement);
                                result[label] = duplicates;
                            }

                            duplicates.Add(labeledElement);
                        }
                        else
                        {
                            result[label] = labeledElement;
                        }

                        AddLabeledExpressions(labeledElement.Element, result);
                        break;
                    }

                case EdmExpressionKind.Collection:
                    foreach (CsdlExpressionBase element in ((CsdlCollectionExpression)expression).ElementValues)
                    {
                        AddLabeledExpressions(element, result);
                    }

                    break;
                case EdmExpressionKind.FunctionApplication:
                    foreach (CsdlExpressionBase argument in ((CsdlApplyExpression)expression).Arguments)
                    {
                        AddLabeledExpressions(argument, result);
                    }

                    break;
                case EdmExpressionKind.Record:
                    foreach (CsdlPropertyValue property in ((CsdlRecordExpression)expression).PropertyValues)
                    {
                        AddLabeledExpressions(property.Expression, result);
                    }

                    break;
                case EdmExpressionKind.If:
                    {
                        CsdlIfExpression ifExpression = (CsdlIfExpression)expression;
                        AddLabeledExpressions(ifExpression.Test, result);
                        AddLabeledExpressions(ifExpression.IfTrue, result);
                        AddLabeledExpressions(ifExpression.IfFalse, result);

                        break;
                    }

                case EdmExpressionKind.IsType:
                    AddLabeledExpressions(((CsdlIsTypeExpression)expression).Operand, result);
                    break;
                case EdmExpressionKind.Cast:
                    AddLabeledExpressions(((CsdlCastExpression)expression).Operand, result);
                    break;
                default:
                    break;
            }
        }

        private static void AddLabeledExpressions(IEnumerable<CsdlAnnotation> annotations, Dictionary<string, object> result)
        {
            foreach (CsdlAnnotation annotation in annotations)
            {
                if (annotation != null)
                {
                    AddLabeledExpressions(annotation.Expression, result);
                }
            }
        }

        private IEdmLabeledExpression WrapLabeledElementList(List<CsdlLabeledExpression> labeledExpressions, IEdmEntityType bindingContext)
        {
            IEdmLabeledExpression result;

            // Guarantee that multiple requests to wrap a given labeled element all return the same object.
            if (!this.ambiguousLabeledExpressions.TryGetValue(labeledExpressions, out result))
            {
                foreach (CsdlLabeledExpression labeledExpression in labeledExpressions)
                {
                    IEdmLabeledExpression wrappedExpression = this.WrapLabeledElement(labeledExpression, bindingContext);
                    result =
                        result == null
                            ? wrappedExpression
                            : new AmbiguousLabeledExpressionBinding(result, wrappedExpression);
                }

                this.ambiguousLabeledExpressions[labeledExpressions] = result;
            }

            return result;
        }

        private IEnumerable<IEdmTerm> ComputeTerms()
        {
            List<IEdmTerm> terms = new List<IEdmTerm>();
            foreach (CsdlTerm valueTerm in this.schema.Terms)
            {
                terms.Add(new CsdlSemanticsTerm(this, valueTerm));
            }

            return terms;
        }

        private IEnumerable<IEdmEntityContainer> ComputeEntityContainers()
        {
            List<IEdmEntityContainer> entityContainers = new List<IEdmEntityContainer>();
            foreach (CsdlEntityContainer entityContainer in this.schema.EntityContainers)
            {
                entityContainers.Add(new CsdlSemanticsEntityContainer(this, entityContainer));
            }

            return entityContainers;
        }

        private IEnumerable<IEdmOperation> ComputeOperations()
        {
            List<IEdmOperation> operations = new List<IEdmOperation>();
            foreach (CsdlOperation operation in this.schema.Operations)
            {
                CsdlAction action = operation as CsdlAction;
                if (action != null)
                {
                    operations.Add(new CsdlSemanticsAction(this, action));
                }
                else
                {
                    CsdlFunction function = operation as CsdlFunction;
                    Debug.Assert(function != null, "function != null");
                    operations.Add(new CsdlSemanticsFunction(this, function));
                }
            }

            return operations;
        }

        private IEnumerable<IEdmSchemaType> ComputeTypes()
        {
            List<IEdmSchemaType> types = new List<IEdmSchemaType>();

            foreach (var typeDefinition in schema.TypeDefinitions)
            {
                CsdlSemanticsTypeDefinitionDefinition edmTypeDefinition =
                    new CsdlSemanticsTypeDefinitionDefinition(this, typeDefinition);
                this.AttachDefaultPrimitiveValueConverter(typeDefinition, edmTypeDefinition);
                types.Add(edmTypeDefinition);
            }

            foreach (var structuredType in this.schema.StructuredTypes)
            {
                CsdlEntityType entity = structuredType as CsdlEntityType;
                if (entity != null)
                {
                    types.Add(new CsdlSemanticsEntityTypeDefinition(this, entity));
                }
                else
                {
                    CsdlComplexType complex = structuredType as CsdlComplexType;
                    if (complex != null)
                    {
                        types.Add(new CsdlSemanticsComplexTypeDefinition(this, complex));
                    }
                }
            }

            foreach (var enumType in this.schema.EnumTypes)
            {
                types.Add(new CsdlSemanticsEnumTypeDefinition(this, enumType));
            }

            return types;
        }

        /// <summary>
        /// Attach DefaultPrimitiveValueConverter to the model if the name and the underlying type of the given type definition
        /// matches the default unsigned int type definitions defined in <see cref="PrimitiveValueConverterConstants"/>.
        /// </summary>
        /// <param name="typeDefinition">The type definition to be added to the schema.</param>
        /// <param name="edmTypeDefinition">The EDM type definition to be added to the model.</param>
        private void AttachDefaultPrimitiveValueConverter(CsdlTypeDefinition typeDefinition, IEdmTypeDefinition edmTypeDefinition)
        {
            Debug.Assert(typeDefinition != null, "typeDefinition != null");

            string defaultUnderlyingType;
            switch (typeDefinition.Name)
            {
                case PrimitiveValueConverterConstants.UInt16TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType;
                    break;
                case PrimitiveValueConverterConstants.UInt32TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType;
                    break;
                case PrimitiveValueConverterConstants.UInt64TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType;
                    break;
                default:
                    // Not unsigned int type definition.
                    return;
            }

            if (String.CompareOrdinal(defaultUnderlyingType, typeDefinition.UnderlyingTypeName) != 0)
            {
                // Not default underlying type for unsigned int.
                return;
            }

            this.Model.SetPrimitiveValueConverter(edmTypeDefinition, DefaultPrimitiveValueConverter.Instance);
        }

        /// <summary>
        /// All of the labeled expressions in a schema are collected into a dictionary so that references to them can be bound.
        /// The elements of the dictionary are Csdl objects and not CsdlSemantics objects because the semantics objects are not created
        /// until and unless necessary.
        /// </summary>
        /// <returns>A dictionary containing entries for all labeled expressions in the schema.</returns>
        private Dictionary<string, object> ComputeLabeledExpressions()
        {
            Dictionary<string, object> result = new Dictionary<string, object>();

            foreach (CsdlAnnotations sourceAnnotations in this.schema.OutOfLineAnnotations)
            {
                AddLabeledExpressions(sourceAnnotations.Annotations, result);
            }

            foreach (CsdlStructuredType schemaType in this.schema.StructuredTypes)
            {
                AddLabeledExpressions(schemaType.VocabularyAnnotations, result);
                foreach (CsdlProperty property in schemaType.StructuralProperties)
                {
                    AddLabeledExpressions(property.VocabularyAnnotations, result);
                }
            }

            foreach (CsdlOperation operation in this.schema.Operations)
            {
                AddLabeledExpressions(operation.VocabularyAnnotations, result);
                foreach (CsdlOperationParameter parameter in operation.Parameters)
                {
                    AddLabeledExpressions(parameter.VocabularyAnnotations, result);
                }
            }

            foreach (CsdlTerm terms in this.schema.Terms)
            {
                AddLabeledExpressions(terms.VocabularyAnnotations, result);
            }

            foreach (CsdlEntityContainer container in this.schema.EntityContainers)
            {
                AddLabeledExpressions(container.VocabularyAnnotations, result);
                foreach (CsdlEntitySet set in container.EntitySets)
                {
                    AddLabeledExpressions(set.VocabularyAnnotations, result);
                }

                foreach (CsdlOperationImport import in container.OperationImports)
                {
                    AddLabeledExpressions(import.VocabularyAnnotations, result);
                    foreach (CsdlOperationParameter parameter in import.Parameters)
                    {
                        AddLabeledExpressions(parameter.VocabularyAnnotations, result);
                    }
                }
            }

            return result;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;

namespace Microsoft.OData.Edm.Csdl.CsdlSemantics
{
    /// <summary>
    /// Provides semantics for CsdlSchema.
    /// </summary>
    internal class CsdlSemanticsSchema : CsdlSemanticsElement, IEdmCheckable
    {
        private readonly CsdlSemanticsModel model;
        private readonly CsdlSchema schema;

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>> typesCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmSchemaType>> ComputeTypesFunc = (me) => me.ComputeTypes();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmOperation>> operationsCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmOperation>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmOperation>> ComputeFunctionsFunc = (me) => me.ComputeOperations();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>> entityContainersCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmEntityContainer>> ComputeEntityContainersFunc = (me) => me.ComputeEntityContainers();

        private readonly Cache<CsdlSemanticsSchema, IEnumerable<IEdmTerm>> termsCache = new Cache<CsdlSemanticsSchema, IEnumerable<IEdmTerm>>();
        private static readonly Func<CsdlSemanticsSchema, IEnumerable<IEdmTerm>> ComputeTermsFunc = (me) => me.ComputeTerms();

        private readonly Cache<CsdlSemanticsSchema, Dictionary<string, object>> labeledExpressionsCache = new Cache<CsdlSemanticsSchema, Dictionary<string, object>>();
        private static readonly Func<CsdlSemanticsSchema, Dictionary<string, object>> ComputeLabeledExpressionsFunc = (me) => me.ComputeLabeledExpressions();

        private readonly Dictionary<CsdlLabeledExpression, IEdmLabeledExpression> semanticsLabeledElements = new Dictionary<CsdlLabeledExpression, IEdmLabeledExpression>();
        private readonly Dictionary<List<CsdlLabeledExpression>, IEdmLabeledExpression> ambiguousLabeledExpressions = new Dictionary<List<CsdlLabeledExpression>, IEdmLabeledExpression>();

        public CsdlSemanticsSchema(CsdlSemanticsModel model, CsdlSchema schema)
            : base(schema)
        {
            this.model = model;
            this.schema = schema;
        }

        public override CsdlSemanticsModel Model
        {
            get { return this.model; }
        }

        public override CsdlElement Element
        {
            get { return this.schema; }
        }

        public IEnumerable<IEdmSchemaType> Types
        {
            get { return this.typesCache.GetValue(this, ComputeTypesFunc, null); }
        }

        public IEnumerable<IEdmOperation> Operations
        {
            get { return this.operationsCache.GetValue(this, ComputeFunctionsFunc, null); }
        }

        public IEnumerable<IEdmTerm> Terms
        {
            get { return this.termsCache.GetValue(this, ComputeTermsFunc, null); }
        }

        public IEnumerable<IEdmEntityContainer> EntityContainers
        {
            get { return this.entityContainersCache.GetValue(this, ComputeEntityContainersFunc, null); }
        }

        public string Namespace
        {
            get { return this.schema.Namespace; }
        }

        public IEnumerable<EdmError> Errors
        {
            get
            {
                return Enumerable.Empty<EdmError>();
            }
        }

        /// <summary>
        /// Gets the labeled element expressions dictionary.
        /// Each value in the dictionary is either a <see cref="CsdlLabeledExpression"/> or a list of same.
        /// </summary>
        private Dictionary<string, object> LabeledExpressions
        {
            get { return this.labeledExpressionsCache.GetValue(this, ComputeLabeledExpressionsFunc, null); }
        }

        public IEnumerable<IEdmOperation> FindOperations(string name)
        {
            return FindSchemaElement<IEnumerable<IEdmOperation>>(name, ExtensionMethods.FindOperationsInModelTree);
        }

        public IEdmSchemaType FindType(string name)
        {
            return FindSchemaElement<IEdmSchemaType>(name, ExtensionMethods.FindTypeInModelTree);
        }

        public IEdmTerm FindTerm(string name)
        {
            return FindSchemaElement<IEdmTerm>(name, FindTerm);
        }

        public IEdmEntityContainer FindEntityContainer(string name)
        {
            return FindSchemaElement<IEdmEntityContainer>(name, FindEntityContainer);
        }

        public T FindSchemaElement<T>(string name, Func<CsdlSemanticsModel, string, T> modelFinder)
        {
            string namespaceQualifiedName = this.ReplaceAlias(name);
            return modelFinder(this.model, namespaceQualifiedName);
        }

        public string UnresolvedName(string qualifiedName)
        {
            if (qualifiedName == null)
            {
                return null;
            }

            return this.ReplaceAlias(qualifiedName);
        }

        public IEdmLabeledExpression FindLabeledElement(string label, IEdmEntityType bindingContext)
        {
            object labeledElement;
            if (this.LabeledExpressions.TryGetValue(label, out labeledElement))
            {
                if (labeledElement is CsdlLabeledExpression labeledElementExpression)
                {
                    return this.WrapLabeledElement(labeledElementExpression, bindingContext);
                }

                return this.WrapLabeledElementList((List<CsdlLabeledExpression>)labeledElement, bindingContext);
            }

            return null;
        }

        public IEdmLabeledExpression WrapLabeledElement(CsdlLabeledExpression labeledElement, IEdmEntityType bindingContext)
        {
            IEdmLabeledExpression result;

            // Guarantee that multiple requests to wrap a given labeled element all return the same object.
            if (!this.semanticsLabeledElements.TryGetValue(labeledElement, out result))
            {
                result = new CsdlSemanticsLabeledExpression(labeledElement.Label, labeledElement.Element, bindingContext, this);
                this.semanticsLabeledElements[labeledElement] = result;
            }

            return result;
        }

        internal string ReplaceAlias(string name)
        {
            return this.model.ReplaceAlias(name);
        }

        private static IEdmTerm FindTerm(IEdmModel model, string name)
        {
            return model.FindTerm(name);
        }

        private static IEdmEntityContainer FindEntityContainer(IEdmModel model, string name)
        {
            return model.FindEntityContainer(name);
        }

        private static void AddLabeledExpressions(CsdlExpressionBase expression, Dictionary<string, object> result)
        {
            if (expression == null)
            {
                return;
            }

            switch (expression.ExpressionKind)
            {
                case EdmExpressionKind.Labeled:
                    {
                        CsdlLabeledExpression labeledElement = (CsdlLabeledExpression)expression;
                        string label = labeledElement.Label;
                        object duplicateLabeledElement;
                        if (result.TryGetValue(label, out duplicateLabeledElement))
                        {
                            // If the label has multiple definitions, store the duplicates as a list of labeled elements.
                            List<CsdlLabeledExpression> duplicates = duplicateLabeledElement as List<CsdlLabeledExpression>;
                            if (duplicates == null)
                            {
                                duplicates = new List<CsdlLabeledExpression>();
                                duplicates.Add((CsdlLabeledExpression)duplicateLabeledElement);
                                result[label] = duplicates;
                            }

                            duplicates.Add(labeledElement);
                        }
                        else
                        {
                            result[label] = labeledElement;
                        }

                        AddLabeledExpressions(labeledElement.Element, result);
                        break;
                    }

                case EdmExpressionKind.Collection:
                    foreach (CsdlExpressionBase element in ((CsdlCollectionExpression)expression).ElementValues)
                    {
                        AddLabeledExpressions(element, result);
                    }

                    break;
                case EdmExpressionKind.FunctionApplication:
                    foreach (CsdlExpressionBase argument in ((CsdlApplyExpression)expression).Arguments)
                    {
                        AddLabeledExpressions(argument, result);
                    }

                    break;
                case EdmExpressionKind.Record:
                    foreach (CsdlPropertyValue property in ((CsdlRecordExpression)expression).PropertyValues)
                    {
                        AddLabeledExpressions(property.Expression, result);
                    }

                    break;
                case EdmExpressionKind.If:
                    {
                        CsdlIfExpression ifExpression = (CsdlIfExpression)expression;
                        AddLabeledExpressions(ifExpression.Test, result);
                        AddLabeledExpressions(ifExpression.IfTrue, result);
                        AddLabeledExpressions(ifExpression.IfFalse, result);

                        break;
                    }

                case EdmExpressionKind.IsType:
                    AddLabeledExpressions(((CsdlIsTypeExpression)expression).Operand, result);
                    break;
                case EdmExpressionKind.Cast:
                    AddLabeledExpressions(((CsdlCastExpression)expression).Operand, result);
                    break;
                default:
                    break;
            }
        }

        private static void AddLabeledExpressions(IEnumerable<CsdlAnnotation> annotations, Dictionary<string, object> result)
        {
            foreach (CsdlAnnotation annotation in annotations)
            {
                if (annotation != null)
                {
                    AddLabeledExpressions(annotation.Expression, result);
                }
            }
        }

        private IEdmLabeledExpression WrapLabeledElementList(List<CsdlLabeledExpression> labeledExpressions, IEdmEntityType bindingContext)
        {
            IEdmLabeledExpression result;

            // Guarantee that multiple requests to wrap a given labeled element all return the same object.
            if (!this.ambiguousLabeledExpressions.TryGetValue(labeledExpressions, out result))
            {
                foreach (CsdlLabeledExpression labeledExpression in labeledExpressions)
                {
                    IEdmLabeledExpression wrappedExpression = this.WrapLabeledElement(labeledExpression, bindingContext);
                    result =
                        result == null
                            ? wrappedExpression
                            : new AmbiguousLabeledExpressionBinding(result, wrappedExpression);
                }

                this.ambiguousLabeledExpressions[labeledExpressions] = result;
            }

            return result;
        }

        private IEnumerable<IEdmTerm> ComputeTerms()
        {
            List<IEdmTerm> terms = new List<IEdmTerm>();
            foreach (CsdlTerm valueTerm in this.schema.Terms)
            {
                terms.Add(new CsdlSemanticsTerm(this, valueTerm));
            }

            return terms;
        }

        private IEnumerable<IEdmEntityContainer> ComputeEntityContainers()
        {
            List<IEdmEntityContainer> entityContainers = new List<IEdmEntityContainer>();
            foreach (CsdlEntityContainer entityContainer in this.schema.EntityContainers)
            {
                entityContainers.Add(new CsdlSemanticsEntityContainer(this, entityContainer));
            }

            return entityContainers;
        }

        private IEnumerable<IEdmOperation> ComputeOperations()
        {
            List<IEdmOperation> operations = new List<IEdmOperation>();
            foreach (CsdlOperation operation in this.schema.Operations)
            {
                if (operation is CsdlAction action)
                {
                    operations.Add(new CsdlSemanticsAction(this, action));
                }
                else
                {
                    Debug.Assert(operation is CsdlFunction function, "function != null");
                    operations.Add(new CsdlSemanticsFunction(this, function));
                }
            }

            return operations;
        }

        private IEnumerable<IEdmSchemaType> ComputeTypes()
        {
            List<IEdmSchemaType> types = new List<IEdmSchemaType>();

            foreach (var typeDefinition in schema.TypeDefinitions)
            {
                CsdlSemanticsTypeDefinitionDefinition edmTypeDefinition =
                    new CsdlSemanticsTypeDefinitionDefinition(this, typeDefinition);
                this.AttachDefaultPrimitiveValueConverter(typeDefinition, edmTypeDefinition);
                types.Add(edmTypeDefinition);
            }

            foreach (var structuredType in this.schema.StructuredTypes)
            {
                if (structuredType is CsdlEntityType entity)
                {
                    types.Add(new CsdlSemanticsEntityTypeDefinition(this, entity));
                }
                else
                {
                    if (structuredType is CsdlComplexType complex)
                    {
                        types.Add(new CsdlSemanticsComplexTypeDefinition(this, complex));
                    }
                }
            }

            foreach (var enumType in this.schema.EnumTypes)
            {
                types.Add(new CsdlSemanticsEnumTypeDefinition(this, enumType));
            }

            return types;
        }

        /// <summary>
        /// Attach DefaultPrimitiveValueConverter to the model if the name and the underlying type of the given type definition
        /// matches the default unsigned int type definitions defined in <see cref="PrimitiveValueConverterConstants"/>.
        /// </summary>
        /// <param name="typeDefinition">The type definition to be added to the schema.</param>
        /// <param name="edmTypeDefinition">The EDM type definition to be added to the model.</param>
        private void AttachDefaultPrimitiveValueConverter(CsdlTypeDefinition typeDefinition, IEdmTypeDefinition edmTypeDefinition)
        {
            Debug.Assert(typeDefinition != null, "typeDefinition != null");

            string defaultUnderlyingType;
            switch (typeDefinition.Name)
            {
                case PrimitiveValueConverterConstants.UInt16TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType;
                    break;
                case PrimitiveValueConverterConstants.UInt32TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType;
                    break;
                case PrimitiveValueConverterConstants.UInt64TypeName:
                    defaultUnderlyingType = PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType;
                    break;
                default:
                    // Not unsigned int type definition.
                    return;
            }

            if (String.CompareOrdinal(defaultUnderlyingType, typeDefinition.UnderlyingTypeName) != 0)
            {
                // Not default underlying type for unsigned int.
                return;
            }

            this.Model.SetPrimitiveValueConverter(edmTypeDefinition, DefaultPrimitiveValueConverter.Instance);
        }

        /// <summary>
        /// All of the labeled expressions in a schema are collected into a dictionary so that references to them can be bound.
        /// The elements of the dictionary are Csdl objects and not CsdlSemantics objects because the semantics objects are not created
        /// until and unless necessary.
        /// </summary>
        /// <returns>A dictionary containing entries for all labeled expressions in the schema.</returns>
        private Dictionary<string, object> ComputeLabeledExpressions()
        {
            Dictionary<string, object> result = new Dictionary<string, object>();

            foreach (CsdlAnnotations sourceAnnotations in this.schema.OutOfLineAnnotations)
            {
                AddLabeledExpressions(sourceAnnotations.Annotations, result);
            }

            foreach (CsdlStructuredType schemaType in this.schema.StructuredTypes)
            {
                AddLabeledExpressions(schemaType.VocabularyAnnotations, result);
                foreach (CsdlProperty property in schemaType.StructuralProperties)
                {
                    AddLabeledExpressions(property.VocabularyAnnotations, result);
                }
            }

            foreach (CsdlOperation operation in this.schema.Operations)
            {
                AddLabeledExpressions(operation.VocabularyAnnotations, result);
                foreach (CsdlOperationParameter parameter in operation.Parameters)
                {
                    AddLabeledExpressions(parameter.VocabularyAnnotations, result);
                }
            }

            foreach (CsdlTerm terms in this.schema.Terms)
            {
                AddLabeledExpressions(terms.VocabularyAnnotations, result);
            }

            foreach (CsdlEntityContainer container in this.schema.EntityContainers)
            {
                AddLabeledExpressions(container.VocabularyAnnotations, result);
                foreach (CsdlEntitySet set in container.EntitySets)
                {
                    AddLabeledExpressions(set.VocabularyAnnotations, result);
                }

                foreach (CsdlOperationImport import in container.OperationImports)
                {
                    AddLabeledExpressions(import.VocabularyAnnotations, result);
                    foreach (CsdlOperationParameter parameter in import.Parameters)
                    {
                        AddLabeledExpressions(parameter.VocabularyAnnotations, result);
                    }
                }
            }

            return result;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsSchema.cs(11,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsSchema.cs(329,68): error CS0165: Use of unassigned local variable 'function',D:\a\1\s\src\Microsoft.OData.Edm\Csdl\Semantics\CsdlSemanticsSchema.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;

using Microsoft.OData.Edm.Csdl;
using Microsoft.OData.Edm.Csdl.CsdlSemantics;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Csdl.Serialization;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.Edm.Vocabularies.Community.V1;
using Microsoft.OData.Edm.Vocabularies.V1;

namespace Microsoft.OData.Edm
{
    /// <summary>
    /// Contains extension methods for <see cref="IEdmModel"/> interfaces.
    /// </summary>
    public static class ExtensionMethods
    {
        private const int ContainerExtendsMaxDepth = 100;
        private const string CollectionTypeFormat = EdmConstants.Type_Collection + "({0})";

        private static readonly IEnumerable<IEdmStructuralProperty> EmptyStructuralProperties = Enumerable.Empty<IEdmStructuralProperty>();
        private static readonly IEnumerable<IEdmNavigationProperty> EmptyNavigationProperties = Enumerable.Empty<IEdmNavigationProperty>();

        #region IEdmModel

        private static readonly Func<IEdmModel, string, IEdmSchemaType> findType = (model, qualifiedName) => model.FindDeclaredType(qualifiedName);
        private static readonly Func<IEdmModel, IEdmType, IEnumerable<IEdmOperation>> findBoundOperations = (model, bindingType) => model.FindDeclaredBoundOperations(bindingType);
        private static readonly Func<IEdmModel, string, IEdmTerm> findTerm = (model, qualifiedName) => model.FindDeclaredTerm(qualifiedName);
        private static readonly Func<IEdmModel, string, IEnumerable<IEdmOperation>> findOperations = (model, qualifiedName) => model.FindDeclaredOperations(qualifiedName);
        private static readonly Func<IEdmModel, string, IEdmEntityContainer> findEntityContainer = (model, qualifiedName) => { return model.ExistsContainer(qualifiedName) ? model.EntityContainer : null; };
        private static readonly Func<IEnumerable<IEdmOperation>, IEnumerable<IEdmOperation>, IEnumerable<IEdmOperation>> mergeFunctions = (f1, f2) => Enumerable.Concat(f1, f2);

        /// <summary>
        /// Gets the value for the EDM version of the <paramref name="model"/>.
        /// </summary>
        /// <param name="model">Model the version has been set for.</param>
        /// <returns>The version.</returns>
        public static Version GetEdmVersion(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            return model.GetAnnotationValue<Version>(model, EdmConstants.InternalUri, EdmConstants.EdmVersionAnnotation);
        }

        /// <summary>
        /// Sets a value of EDM version attribute of the <paramref name="model"/>.
        /// </summary>
        /// <param name="model">The model the version should be set for.</param>
        /// <param name="version">The version.</param>
        public static void SetEdmVersion(this IEdmModel model, Version version)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            model.SetAnnotationValue(model, EdmConstants.InternalUri, EdmConstants.EdmVersionAnnotation, version);
        }

        #region IEdmModel interface's FindDeclaredXxx() methods, here their counterpart methods become FindXxx().
        /// <summary>
        /// Searches for a type with the given name in this model and all referenced models and returns null if no such type exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The namespace or alias qualified name of the type being found.</param>
        /// <returns>The requested type, or null if no such type exists.</returns>
        public static IEdmSchemaType FindType(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            string fullyQualifiedName = model.ReplaceAlias(qualifiedName);

            return FindAcrossModels(model, fullyQualifiedName, findType, RegistrationHelper.CreateAmbiguousTypeBinding);  // search built-in EdmCoreModel and CoreVocabularyModel.
        }

        /// <summary>
        /// Searches for bound operations based on the binding type, returns an empty enumerable if no operation exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>A set of operations that share the binding type or empty enumerable if no such operation exists.</returns>
        public static IEnumerable<IEdmOperation> FindBoundOperations(this IEdmModel model, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");
            return FindAcrossModels(model, bindingType, findBoundOperations, mergeFunctions);  // search built-in EdmCoreModel and CoreVocabularyModel.
        }

        /// <summary>
        /// Searches for bound operations based on the qualified name and binding type, returns an empty enumerable if no operation exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>A set of operations that share the qualified name and binding type or empty enumerable if no such operation exists.</returns>
        public static IEnumerable<IEdmOperation> FindBoundOperations(this IEdmModel model, string qualifiedName, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");

            string fullyQualifiedName = model.ReplaceAlias(qualifiedName);

            // the below is a copy of FindAcrossModels method but Func<IEdmModel, TInput, T> finder is replaced by FindDeclaredBoundOperations.
            IEnumerable<IEdmOperation> candidate = model.FindDeclaredBoundOperations(fullyQualifiedName, bindingType);

            foreach (IEdmModel reference in model.ReferencedModels)
            {
                IEnumerable<IEdmOperation> fromReference = reference.FindDeclaredBoundOperations(fullyQualifiedName, bindingType);
                if (fromReference != null)
                {
                    candidate = candidate == null ? fromReference : mergeFunctions(candidate, fromReference);
                }
            }

            return candidate;
        }

        /// <summary>
        /// Searches for a term with the given name in this model and all referenced models and returns null if no such term exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the term being found.</param>
        /// <returns>The requested term, or null if no such term exists.</returns>
        public static IEdmTerm FindTerm(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findTerm, RegistrationHelper.CreateAmbiguousTermBinding);
        }

        /// <summary>
        /// Searches for operations with the given name in this model and all referenced models and returns an empty enumerable if no such operations exist.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operations being found.</param>
        /// <returns>The requested operations.</returns>
        public static IEnumerable<IEdmOperation> FindOperations(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findOperations, mergeFunctions);
        }
        #endregion

        /// <summary>
        /// If the container name in the model is the same as the input name. The input name maybe full qualified name.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="containerName">Input container name to be searched. The container name may be full qualified with namespace prefix.</param>
        /// <returns>True if the model has a container called input name, otherwise false.</returns>
        public static bool ExistsContainer(this IEdmModel model, string containerName)
        {
            if (model.EntityContainer == null)
            {
                return false;
            }

            string fullQualifiedName = (model.EntityContainer.Namespace ?? String.Empty) + "." + (containerName ?? String.Empty);

            if (string.Equals(model.EntityContainer.FullName(), fullQualifiedName, StringComparison.Ordinal)
                || string.Equals(model.EntityContainer.FullName(), containerName, StringComparison.Ordinal))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Searches for an entity container with the given name in this model and all referenced models and returns null if no such entity container exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the entity container being found.</param>
        /// <returns>The requested entity container, or null if no such entity container exists.</returns>
        public static IEdmEntityContainer FindEntityContainer(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findEntityContainer, RegistrationHelper.CreateAmbiguousEntityContainerBinding);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations defined in a specific model and models referenced by that model.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <returns>Annotations attached to the element (or, if the element is a type, to its base types) by this model or by models referenced by this model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> FindVocabularyAnnotationsIncludingInheritedAnnotations(this IEdmModel model, IEdmVocabularyAnnotatable element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            IEnumerable<IEdmVocabularyAnnotation> result = model.FindDeclaredVocabularyAnnotations(element);

            IEdmStructuredType typeElement = element as IEdmStructuredType;
            if (typeElement != null)
            {
                typeElement = typeElement.BaseType;
                while (typeElement != null)
                {
                    IEdmVocabularyAnnotatable annotatableElement = typeElement as IEdmVocabularyAnnotatable;
                    if (annotatableElement != null)
                    {
                        result = result.Concat(model.FindDeclaredVocabularyAnnotations(annotatableElement));
                    }

                    typeElement = typeElement.BaseType;
                }
            }

            return result;
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations defined in a specific model and models referenced by that model.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> FindVocabularyAnnotations(this IEdmModel model, IEdmVocabularyAnnotatable element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            IEnumerable<IEdmVocabularyAnnotation> result = model.FindVocabularyAnnotationsIncludingInheritedAnnotations(element);
            foreach (IEdmModel referencedModel in model.ReferencedModels)
            {
                result = result.Concat(referencedModel.FindVocabularyAnnotationsIncludingInheritedAnnotations(element));
            }

            return result;
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="term">Term to search for.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");

            return FindVocabularyAnnotations<T>(model, element, term, null);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="term">Term to search for.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term with the given qualifier.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");

            List<T> result = null;

            foreach (T annotation in model.FindVocabularyAnnotations(element).OfType<T>())
            {
                if (annotation.Term == term && (qualifier == null || qualifier == annotation.Qualifier))
                {
                    if (result == null)
                    {
                        result = new List<T>();
                    }

                    result.Add(annotation);
                }
            }

            return result ?? Enumerable.Empty<T>();
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="termName">Name of the term to search for.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");

            return FindVocabularyAnnotations<T>(model, element, termName, null);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="termName">Name of the term to search for.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term with the given qualifier.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");

            // Look up annotations on the element by name. There's no particular advantage in searching for a term first.
            string name;
            string namespaceName;

            if (EdmUtil.TryGetNamespaceNameFromQualifiedName(termName, out namespaceName, out name))
            {
                foreach (T annotation in model.FindVocabularyAnnotations(element).OfType<T>())
                {
                    IEdmTerm annotationTerm = annotation.Term;
                    if (annotationTerm.Namespace == namespaceName && annotationTerm.Name == name && (qualifier == null || qualifier == annotation.Qualifier))
                    {
                        yield return annotation;
                    }
                }
            }
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, string termName, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), termName, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, string termName, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), termName, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), term, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), term, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, string termName, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), termName, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, string termName, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), termName, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), term, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), term, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, termName, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, termName, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, term, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, term, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, termName, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, termName, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, term, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, term, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets an annotation value corresponding to the given namespace and name provided.
        /// </summary>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace of the annotation.</param>
        /// <param name="localName">Name of the annotation inside the namespace.</param>
        /// <returns>The requested annotation value, if it exists. Otherwise, null.</returns>
        public static object GetAnnotationValue(this IEdmModel model, IEdmElement element, string namespaceName, string localName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.DirectValueAnnotationsManager.GetAnnotationValue(element, namespaceName, localName);
        }

        /// <summary>
        /// Gets an annotation value corresponding to the given namespace and name provided.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace of the annotation.</param>
        /// <param name="localName">Name of the annotation inside the namespace.</param>
        /// <returns>The requested annotation value, if it exists. Otherwise, null.</returns>
        public static T GetAnnotationValue<T>(this IEdmModel model, IEdmElement element, string namespaceName, string localName) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return AnnotationValue<T>(model.GetAnnotationValue(element, namespaceName, localName));
        }

        /// <summary>
        /// Gets an annotation value from an annotatable element.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <returns>The requested annotation, if it exists. Otherwise, null.</returns>
        /// <remarks>
        /// Strongly-typed wrappers for unnamed annotations keyed by CLR type.
        /// </remarks>
        public static T GetAnnotationValue<T>(this IEdmModel model, IEdmElement element) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.GetAnnotationValue<T>(element, EdmConstants.InternalUri, TypeName<T>.LocalName);
        }

        /// <summary>
        /// Sets an annotation value for an EDM element. If the value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Name of the annotation within the namespace.</param>
        /// <param name="value">Value of the new annotation.</param>
        public static void SetAnnotationValue(this IEdmModel model, IEdmElement element, string namespaceName, string localName, object value)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            model.DirectValueAnnotationsManager.SetAnnotationValue(element, namespaceName, localName, value);
        }

        /// <summary>
        /// Gets description for term Org.OData.Core.V1.Description from a target annotatable
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to find annotation</param>
        /// <returns>Description for term Org.OData.Core.V1.Description</returns>
        public static string GetDescriptionAnnotation(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, CoreVocabularyModel.DescriptionTerm).FirstOrDefault();
            if (annotation != null)
            {
                IEdmStringConstantExpression stringConstant = annotation.Value as IEdmStringConstantExpression;
                if (stringConstant != null)
                {
                    return stringConstant.Value;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets description for term Org.OData.Core.V1.LongDescription from a target annotatable
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to find annotation</param>
        /// <returns>Description for term Org.OData.Core.V1.LongDescription</returns>
        public static string GetLongDescriptionAnnotation(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, CoreVocabularyModel.LongDescriptionTerm).FirstOrDefault();
            if (annotation != null)
            {
                IEdmStringConstantExpression stringConstant = annotation.Value as IEdmStringConstantExpression;
                if (stringConstant != null)
                {
                    return stringConstant.Value;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets the collection of qualified type name for term Org.OData.Validation.V1.DerivedTypeConstraint from a navigation source.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>Null or a collection string of qualified type name.</returns>
        public static IEnumerable<string> GetDerivedTypeConstraints(this IEdmModel model, IEdmNavigationSource navigationSource)
        {
            if (model == null || navigationSource == null)
            {
                return null;
            }

            IEnumerable<string> derivedTypeConstraints = null;
            switch (navigationSource.NavigationSourceKind())
            {
                case EdmNavigationSourceKind.EntitySet:
                    derivedTypeConstraints = model.GetDerivedTypeConstraints((IEdmVocabularyAnnotatable)(IEdmEntitySet)navigationSource);
                    break;
                case EdmNavigationSourceKind.Singleton:
                    derivedTypeConstraints = model.GetDerivedTypeConstraints((IEdmVocabularyAnnotatable)(IEdmSingleton)navigationSource);
                    break;
            }

            return derivedTypeConstraints;
        }

        /// <summary>
        /// Gets the collection of qualified type name for term Org.OData.Validation.V1.DerivedTypeConstraint from a target annotatable.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target annotatable to find annotation.</param>
        /// <returns>Null or a collection string of qualified type name.</returns>
        public static IEnumerable<string> GetDerivedTypeConstraints(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            if (model == null || target == null)
            {
                return null;
            }

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, ValidationVocabularyModel.DerivedTypeConstraintTerm).FirstOrDefault();
            if (annotation != null)
            {
                IEdmCollectionExpression collectionExpression = annotation.Value as IEdmCollectionExpression;
                if (collectionExpression?.Elements != null)
                {
                    return collectionExpression.Elements.OfType<IEdmStringConstantExpression>().Select(e => e.Value);
                }
            }

            return null;
        }

        /// <summary>
        /// Gets all schema elements from the model, and models referenced by it.
        /// </summary>
        /// <param name="model">Model to search for elements</param>
        /// <returns>Schema elements from the model, and models referenced by it.</returns>
        public static IEnumerable<IEdmSchemaElement> SchemaElementsAcrossModels(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");

            IEnumerable<IEdmSchemaElement> result = Enumerable.Empty<IEdmSchemaElement>();
            foreach (IEdmModel referencedModel in model.ReferencedModels)
            {
                result = result.Concat(referencedModel.SchemaElements);
            }

            result = result.Concat(model.SchemaElements);
            return result;
        }

        /// <summary>
        /// Finds a list of types that derive from the supplied type directly or indirectly, and across models.
        /// </summary>
        /// <param name="model">The model types are being found on.</param>
        /// <param name="baseType">The base type that derived types are being searched for.</param>
        /// <returns>A list of types that derive from the type.</returns>
        public static IEnumerable<IEdmStructuredType> FindAllDerivedTypes(this IEdmModel model, IEdmStructuredType baseType)
        {
            List<IEdmStructuredType> result = new List<IEdmStructuredType>();
            if (baseType is IEdmSchemaElement)
            {
                model.DerivedFrom(baseType, new HashSetInternal<IEdmStructuredType>(), result);
            }

            return result;
        }

        /// <summary>
        /// Sets an annotation value on an annotatable element.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being set.</typeparam>
        ///  <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="value">Value of the new annotation.</param>
        public static void SetAnnotationValue<T>(this IEdmModel model, IEdmElement element, T value) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            model.SetAnnotationValue(element, EdmConstants.InternalUri, TypeName<T>.LocalName, value);
        }

        /// <summary>
        /// Retrieves a set of annotation values. For each requested value, returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="model">The model in which to find the annotations.</param>
        /// <param name="annotations">The set of requested annotations.</param>
        /// <returns>Returns values that correspond to the provided annotations. A value is null if no annotation with the given name exists for the given element.</returns>
        public static object[] GetAnnotationValues(this IEdmModel model, IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(annotations, "annotations");

            return model.DirectValueAnnotationsManager.GetAnnotationValues(annotations);
        }

        /// <summary>
        /// Sets a set of annotation values. If a supplied value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="model">The model in which to set the annotations.</param>
        /// <param name="annotations">The annotations to set.</param>
        public static void SetAnnotationValues(this IEdmModel model, IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(annotations, "annotations");

            model.DirectValueAnnotationsManager.SetAnnotationValues(annotations);
        }

        /// <summary>
        /// Gets the direct annotations for an element.
        /// </summary>
        /// <param name="model">The model containing the annotations.</param>
        /// <param name="element">The annotated element.</param>
        /// <returns>The immediate annotations of the element.</returns>
        public static IEnumerable<IEdmDirectValueAnnotation> DirectValueAnnotations(this IEdmModel model, IEdmElement element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.DirectValueAnnotationsManager.GetDirectValueAnnotations(element);
        }

        /// <summary>
        /// Finds the entity set with qualified entity set name (not simple entity set name).
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedEntitySetName">Name of the container qualified element, can be an OperationImport or an EntitySet.</param>
        /// <param name="entitySet">The Entity Set that was found.</param>
        /// <returns>True if an entityset was found from the qualified container name, false if none were found.</returns>
        public static bool TryFindContainerQualifiedEntitySet(this IEdmModel model, string containerQualifiedEntitySetName, out IEdmEntitySet entitySet)
        {
            entitySet = null;
            string containerName = null;
            string simpleEntitySetName = null;

            if (containerQualifiedEntitySetName != null &&
                containerQualifiedEntitySetName.IndexOf(".", StringComparison.Ordinal) > -1 &&
                EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedEntitySetName, out containerName, out simpleEntitySetName))
            {
                if (model.ExistsContainer(containerName))
                {
                    IEdmEntityContainer container = model.EntityContainer;
                    if (container != null)
                    {
                        entitySet = container.FindEntitySetExtended(simpleEntitySetName);
                    }
                }
            }

            return (entitySet != null);
        }

        /// <summary>
        /// Finds the singleton.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedSingletonName">Name of the container qualified singleton element.</param>
        /// <param name="singleton">The singleton that was found.</param>
        /// <returns>True if an singleton was found from the qualified container name, false if none were found.</returns>
        public static bool TryFindContainerQualifiedSingleton(this IEdmModel model, string containerQualifiedSingletonName, out IEdmSingleton singleton)
        {
            singleton = null;
            string containerName = null;
            string simpleSingletonName = null;

            if (containerQualifiedSingletonName != null &&
                containerQualifiedSingletonName.IndexOf(".", StringComparison.Ordinal) > -1 &&
                EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedSingletonName, out containerName, out simpleSingletonName))
            {
                if (model.ExistsContainer(containerName))
                {
                    singleton = model.EntityContainer.FindSingletonExtended(simpleSingletonName);

                    if (singleton != null)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Tries the find container qualified operation imports.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedOperationImportName">Name of the container qualified operation import.</param>
        /// <param name="operationImports">The operation imports.</param>
        /// <returns>True if OperationImports are found, false if none were found.</returns>
        public static bool TryFindContainerQualifiedOperationImports(this IEdmModel model, string containerQualifiedOperationImportName, out IEnumerable<IEdmOperationImport> operationImports)
        {
            operationImports = null;
            string containerName = null;
            string simpleOperationName = null;

            if (containerQualifiedOperationImportName.IndexOf(".", StringComparison.Ordinal) > -1 && EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedOperationImportName, out containerName, out simpleOperationName))
            {
                if (model.ExistsContainer(containerName))
                {
                    operationImports = model.EntityContainer.FindOperationImportsExtended(simpleOperationName);

                    if (operationImports != null && operationImports.Any())
                    {
                        return true;
                    }
                }
            }

            return false;
        }


        /// <summary>
        /// Searches for entity set by the given name that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        public static IEdmEntitySet FindDeclaredEntitySet(this IEdmModel model, string qualifiedName)
        {
            IEdmEntitySet foundEntitySet;
            if (!model.TryFindContainerQualifiedEntitySet(qualifiedName, out foundEntitySet))
            {
                // try searching by entity set name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindEntitySetExtended(qualifiedName);
                }
            }

            return foundEntitySet;
        }

        /// <summary>
        /// Searches for singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The singleton found or empty if none found.</returns>
        public static IEdmSingleton FindDeclaredSingleton(this IEdmModel model, string qualifiedName)
        {
            IEdmSingleton foundSingleton;
            if (!model.TryFindContainerQualifiedSingleton(qualifiedName, out foundSingleton))
            {
                // try searching by singleton name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindSingletonExtended(qualifiedName);
                }
            }

            return foundSingleton;
        }

        /// <summary>
        /// Searches for entity set or singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set or singleton found or empty if none found.</returns>
        public static IEdmNavigationSource FindDeclaredNavigationSource(this IEdmModel model, string qualifiedName)
        {
            IEdmEntitySet entitySet = model.FindDeclaredEntitySet(qualifiedName);
            if (entitySet != null)
            {
                return entitySet;
            }

            return model.FindDeclaredSingleton(qualifiedName);
        }


        /// <summary>
        /// Searches for the operation imports by the specified name in default container and .Extends containers, returns an empty enumerable if no operation import exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation import which may or may not include the container name.</param>
        /// <returns>All operation imports that can be found by the specified name, returns an empty enumerable if no operation import exists.</returns>
        public static IEnumerable<IEdmOperationImport> FindDeclaredOperationImports(this IEdmModel model, string qualifiedName)
        {
            IEnumerable<IEdmOperationImport> foundOperationImports;
            if (!model.TryFindContainerQualifiedOperationImports(qualifiedName, out foundOperationImports))
            {
                // try searching by operation import name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindOperationImportsExtended(qualifiedName);
                }
            }

            return foundOperationImports ?? Enumerable.Empty<IEdmOperationImport>();
        }

        /// <summary>
        /// Get the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="type">The reference to a type definition.</param>
        /// <returns>The primitive value converter for the type definition.</returns>
        public static IPrimitiveValueConverter GetPrimitiveValueConverter(this IEdmModel model, IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(model, "mode");

            // If type definition is not provided, we pass through the primitive value directly.
            if (type == null || !type.IsTypeDefinition())
            {
                return PassThroughPrimitiveValueConverter.Instance;
            }

            return model.GetPrimitiveValueConverter(type.Definition);
        }

        /// <summary>
        /// Set the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The reference to a type definition.</param>
        /// <param name="converter">The primitive value converter for the type definition.</param>
        public static void SetPrimitiveValueConverter(this IEdmModel model, IEdmTypeDefinitionReference typeDefinition, IPrimitiveValueConverter converter)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(typeDefinition, "typeDefinition");
            EdmUtil.CheckArgumentNull(converter, "converter");

            model.SetPrimitiveValueConverter(typeDefinition.Definition, converter);
        }

        #endregion

        #region EdmModel

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name)
        {
            return model.AddComplexType(namespaceName, name, null, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType)
        {
            return model.AddComplexType(namespaceName, name, baseType, false, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <param name="isAbstract">Denotes whether this complex type is abstract.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType, bool isAbstract)
        {
            return model.AddComplexType(namespaceName, name, baseType, isAbstract, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <param name="isAbstract">Denotes whether this complex type is abstract.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType, bool isAbstract, bool isOpen)
        {
            var type = new EdmComplexType(namespaceName, name, baseType, isAbstract, isOpen);
            model.AddElement(type);
            return type;
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name)
        {
            return model.AddEntityType(namespaceName, name, null, false, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType)
        {
            return model.AddEntityType(namespaceName, name, baseType, false, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <param name="isAbstract">Denotes an entity that cannot be instantiated.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType, bool isAbstract, bool isOpen)
        {
            return model.AddEntityType(namespaceName, name, baseType, isAbstract, isOpen, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <param name="isAbstract">Denotes an entity that cannot be instantiated.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <param name="hasStream">Denotes if the type is a media type.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType, bool isAbstract, bool isOpen, bool hasStream)
        {
            var type = new EdmEntityType(namespaceName, name, baseType, isAbstract, isOpen, hasStream);
            model.AddElement(type);
            return type;
        }

        /// <summary>
        /// Creates and adds an entity container to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace of the entity container.</param>
        /// <param name="name">Name of the entity container.</param>
        /// <returns>The entity container created.</returns>
        public static EdmEntityContainer AddEntityContainer(this EdmModel model, string namespaceName, string name)
        {
            var container = new EdmEntityContainer(namespaceName, name);
            model.AddElement(container);
            return container;
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a primitive type kind.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="kind">The primitive type kind of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, EdmPrimitiveTypeKind kind)
        {
            var term = new EdmTerm(namespaceName, name, kind);
            model.AddElement(term);
            return term;
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a type reference.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="type">The type of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, IEdmTypeReference type)
        {
            return model.AddTerm(namespaceName, name, type, null, null);
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a type reference.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="type">The type of the term.</param>
        /// <param name="appliesTo">The AppliesTo of the term.</param>
        /// <param name="defaultValue">The DefaultValue of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, IEdmTypeReference type, string appliesTo, string defaultValue)
        {
            var term = new EdmTerm(namespaceName, name, type, appliesTo, defaultValue);
            model.AddElement(term);
            return term;
        }

        /// <summary>
        /// Set annotation Org.OData.Core.V1.OptimisticConcurrency to EntitySet
        /// </summary>
        /// <param name="model">The model to add annotation</param>
        /// <param name="target">The target entitySet to set the inline annotation</param>
        /// <param name="properties">The PropertyPath for annotation</param>
        public static void SetOptimisticConcurrencyAnnotation(this EdmModel model, IEdmEntitySet target, IEnumerable<IEdmStructuralProperty> properties)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(properties, "properties");

            IEdmCollectionExpression collectionExpression = new EdmCollectionExpression(properties.Select(p => new EdmPropertyPathExpression(p.Name)).ToArray());
            IEdmTerm term = CoreVocabularyModel.ConcurrencyTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, term, collectionExpression);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Core.V1.Description to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to add annotation.</param>
        /// <param name="description">Description to be added.</param>
        public static void SetDescriptionAnnotation(this EdmModel model, IEdmVocabularyAnnotatable target, string description)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(description, "description");

            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, CoreVocabularyModel.DescriptionTerm, new EdmStringConstant(description));
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Core.V1.LongDescription to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to add annotation.</param>
        /// <param name="description">Description to be added.</param>
        public static void SetLongDescriptionAnnotation(this EdmModel model, IEdmVocabularyAnnotatable target, string description)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(description, "description");

            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, CoreVocabularyModel.LongDescriptionTerm, new EdmStringConstant(description));
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Capabilities.V1.ChangeTracking to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target entity container to set the inline annotation.</param>
        /// <param name="isSupported">This entity set supports the odata.track-changes preference.</param>
        public static void SetChangeTrackingAnnotation(this EdmModel model, IEdmEntityContainer target, bool isSupported)
        {
            model.SetChangeTrackingAnnotationImplementation(target, isSupported, null, null);
        }

        /// <summary>
        /// Set Org.OData.Capabilities.V1.ChangeTracking to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target entity set to set the inline annotation.</param>
        /// <param name="isSupported">This entity set supports the odata.track-changes preference.</param>
        /// <param name="filterableProperties">Change tracking supports filters on these properties.</param>
        /// <param name="expandableProperties">Change tracking supports these properties expanded.</param>
        public static void SetChangeTrackingAnnotation(this EdmModel model, IEdmEntitySet target, bool isSupported, IEnumerable<IEdmStructuralProperty> filterableProperties, IEnumerable<IEdmNavigationProperty> expandableProperties)
        {
            model.SetChangeTrackingAnnotationImplementation(target, isSupported, filterableProperties, expandableProperties);
        }

        /// <summary>
        /// Get type reference to the default UInt16 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType"/>.
        /// If the user has already defined his own UInt16, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt16 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt16(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt16TypeName,
                PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType,
                isNullable);
        }

        /// <summary>
        /// Get type reference to the default UInt32 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType"/>.
        /// If the user has already defined his own UInt32, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt32 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt32(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt32TypeName,
                PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType,
                isNullable);
        }

        /// <summary>
        /// Get type reference to the default UInt64 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType"/>.
        /// If the user has already defined his own UInt64, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt64 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt64(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt64TypeName,
                PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType,
                isNullable);
        }

        #endregion

        #region IEdmElement

        /// <summary>
        /// Gets the location of this element.
        /// </summary>
        /// <param name="item">Reference to the calling object.</param>
        /// <returns>The location of the element.</returns>
        public static EdmLocation Location(this IEdmElement item)
        {
            EdmUtil.CheckArgumentNull(item, "item");
            IEdmLocatable locatable = item as IEdmLocatable;
            return locatable?.Location != null ? locatable.Location : new ObjectLocation(item);
        }

        #endregion

        #region IEdmVocabularyAnnotatable

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations as seen from a particular model.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <param name="model">Model to check for annotations.</param>
        /// <returns>Annotations attached to the element by the model or by models referenced by the model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> VocabularyAnnotations(this IEdmVocabularyAnnotatable element, IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(model, "model");
            return model.FindVocabularyAnnotations(element);
        }

        #endregion

        #region IEdmSchemaElement

        /// <summary>
        /// Gets the full name of the element.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <returns>The full name of the element.</returns>
        public static string FullName(this IEdmSchemaElement element)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            if (element.Name == null)
            {
                return string.Empty;
            }

            if (element.Namespace == null)
            {
                return element.Name;
            }

            IEdmFullNamedElement fullNamedElement = element as IEdmFullNamedElement;
            if (fullNamedElement != null)
            {
                return fullNamedElement.FullName;
            }

            return element.Namespace + "." + element.Name;
        }

        /// <summary>
        /// Gets the Short Qualified name of the element.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <returns>The short qualified name of the element.</returns>
        public static string ShortQualifiedName(this IEdmSchemaElement element)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            if (element.Namespace != null && element.Namespace.Equals("Edm", StringComparison.Ordinal))
            {
                return (element.Name ?? String.Empty);
            }

            return FullName(element);
        }

        #endregion

        #region IEdmEntityContainer

        /// <summary>
        /// Returns entity sets belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Entity sets belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmEntitySet> EntitySets(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmEntitySet>();
        }

        /// <summary>
        /// Returns singletons belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Singletons belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmSingleton> Singletons(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmSingleton>();
        }

        /// <summary>
        /// Returns operation imports belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Operation imports belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmOperationImport> OperationImports(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmOperationImport>();
        }

        #endregion

        #region IEdmTypeReference
        /// <summary>
        /// Gets the type kind of the type references definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The type kind of the reference.</returns>
        public static EdmTypeKind TypeKind(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmType typeDefinition = type.Definition;
            return typeDefinition != null ? typeDefinition.TypeKind : EdmTypeKind.None;
        }

        /// <summary>
        /// Gets the full name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The full name of this references definition.</returns>
        public static string FullName(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.Definition.FullTypeName();
        }

        /// <summary>
        /// Gets the short qualified name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The short qualified name of this references definition.</returns>
        public static string ShortQualifiedName(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            var namedDefinition = type.Definition as IEdmSchemaElement;
            return namedDefinition != null ? namedDefinition.ShortQualifiedName() : null;
        }
        #endregion

        #region IEdmType

        /// <summary>
        /// Gets the full name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The full name of this references definition.</returns>
        public static string FullTypeName(this IEdmType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");

            if (type.TypeKind == EdmTypeKind.Primitive)
            {
                EdmCoreModelPrimitiveType primitiveType = type as EdmCoreModelPrimitiveType;
                if (primitiveType != null)
                {
                    return primitiveType.FullName;
                }
            }

            IEdmSchemaElement namedDefinition;
            if (type.TypeKind != EdmTypeKind.Collection)
            {
                namedDefinition = type as IEdmSchemaElement;
                return namedDefinition != null ? namedDefinition.FullName() : null;
            }
            else
            {
                // Handle collection case.
                namedDefinition = (type as IEdmCollectionType).ElementType.Definition as IEdmSchemaElement;
                return namedDefinition != null ? string.Format(CultureInfo.InvariantCulture, CollectionTypeFormat, namedDefinition.FullName()) : null;
            }
        }

        /// <summary>
        /// Gets the element type of a collection definition or itself of a non-collection definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The element type of this references definition.</returns>
        public static IEdmType AsElementType(this IEdmType type)
        {   
            if(type == null)
            {
                return type;
            }

            return (type.TypeKind == EdmTypeKind.Collection) ? (type as IEdmCollectionType).ElementType.Definition : type;
        }

        #endregion

        #region IEdmPrimitiveTypeReference
        /// <summary>
        /// Gets the definition of this primitive type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Definition of this primitive type reference.</returns>
        public static IEdmPrimitiveType PrimitiveDefinition(this IEdmPrimitiveTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmPrimitiveType)type.Definition;
        }

        /// <summary>
        /// Gets the primitive kind of the definition referred to by this type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Primitive kind of the definition of this reference.</returns>
        public static EdmPrimitiveTypeKind PrimitiveKind(this IEdmPrimitiveTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmPrimitiveType primitive = type.PrimitiveDefinition();
            return primitive != null ? primitive.PrimitiveKind : EdmPrimitiveTypeKind.None;
        }
        #endregion

        #region IEdmStructuredTypeDefinition
        /// <summary>
        /// Gets all properties of the structured type definition and its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Properties of this type.</returns>
        public static IEnumerable<IEdmProperty> Properties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            if (type.BaseType != null)
            {
                foreach (IEdmProperty baseProperty in type.BaseType.Properties())
                {
                    yield return baseProperty;
                }
            }

            if (type.DeclaredProperties != null)
            {
                foreach (IEdmProperty declaredProperty in type.DeclaredProperties)
                {
                    yield return declaredProperty;
                }
            }
        }

        /// <summary>
        /// Gets all structural properties declared in the IEdmStructuredTypeDefinition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the IEdmStructuredTypeDefinition.</returns>
        public static IEnumerable<IEdmStructuralProperty> DeclaredStructuralProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            foreach (IEdmProperty property in type.DeclaredProperties)
            {
                if (property.PropertyKind == EdmPropertyKind.Structural)
                {
                    yield return property as IEdmStructuralProperty;
                }
            }
        }

        /// <summary>
        /// Gets the structural properties declared in this type definition and all base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The structural properties declared in this type definition and all base types.</returns>
        public static IEnumerable<IEdmStructuralProperty> StructuralProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            foreach(IEdmProperty property in type.Properties())
            {
                if(property.PropertyKind == EdmPropertyKind.Structural)
                {
                    yield return property as IEdmStructuralProperty;
                }
            }
        }
        #endregion

        #region IEdmStructuredTypeReference
        /// <summary>
        /// Gets the definition of this structured type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this structured type reference.</returns>
        public static IEdmStructuredType StructuredDefinition(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmStructuredType)type.Definition;
        }

        /// <summary>
        /// Returns true if the definition of this reference is abstract.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is abstract.</returns>
        public static bool IsAbstract(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().IsAbstract;
        }

        /// <summary>
        /// Returns true if the definition of this reference is open.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is open.</returns>
        public static bool IsOpen(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().IsOpen;
        }

        /// <summary>
        /// Returns true if the definition of this reference is open.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is open.</returns>
        public static bool IsOpen(this IEdmType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");

            IEdmStructuredType structuredType = type as IEdmStructuredType;
            if (structuredType != null)
            {
                return structuredType.IsOpen;
            }

            // If its a collection, return whether its element type is open.
            // This is because when processing a navigation property, the target type
            // may be a collection type even though a key expression has been applied.
            var collectionType = type as IEdmCollectionType;
            if (collectionType == null)
            {
                return false;
            }

            return collectionType.ElementType.Definition.IsOpen();
        }

        /// <summary>
        /// Returns the base type of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of the definition of this reference. </returns>
        public static IEdmStructuredType BaseType(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().BaseType;
        }

        /// <summary>
        /// Gets all structural properties declared in the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the definition of this reference.</returns>
        public static IEnumerable<IEdmStructuralProperty> DeclaredStructuralProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().DeclaredStructuralProperties();
        }

        /// <summary>
        /// Gets all structural properties declared in the definition of this reference and all its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the definition of this reference and all its base types.</returns>
        public static IEnumerable<IEdmStructuralProperty> StructuralProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().StructuralProperties();
        }

        /// <summary>
        /// Finds a property from the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="name">Name of the property to find.</param>
        /// <returns>The requested property if it exists. Otherwise, null.</returns>
        public static IEdmProperty FindProperty(this IEdmStructuredTypeReference type, string name)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(name, "name");
            return type.StructuredDefinition().FindProperty(name);
        }

        /// <summary>
        /// Gets the navigation properties declared in the definition of this reference and its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in the definition of this reference and its base types.</returns>
        public static IEnumerable<IEdmNavigationProperty> NavigationProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().NavigationProperties();
        }

        /// <summary>
        /// Gets the navigation properties declared in the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in the definition of this reference.</returns>
        public static IEnumerable<IEdmNavigationProperty> DeclaredNavigationProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().DeclaredNavigationProperties();
        }

        /// <summary>
        /// Finds a navigation property declared in the definition of this reference by name.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="name">Name of the navigation property to find.</param>
        /// <returns>The requested navigation property if it exists. Otherwise, null.</returns>
        public static IEdmNavigationProperty FindNavigationProperty(this IEdmStructuredTypeReference type, string name)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(name, "name");
            return type.StructuredDefinition().FindProperty(name) as IEdmNavigationProperty;
        }

        #endregion

        #region IEdmEntityTypeDefinition
        /// <summary>
        /// Gets the base type of this entity type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this entity type definition.</returns>
        public static IEdmEntityType BaseEntityType(this IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmEntityType;
        }

        /// <summary>
        /// Gets the base type of this structured type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this structured type definition.</returns>
        public static IEdmStructuredType BaseType(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmStructuredType;
        }

        /// <summary>
        /// Gets the navigation properties declared in this structured type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in this structured type definition.</returns>
        public static IEnumerable<IEdmNavigationProperty> DeclaredNavigationProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.DeclaredProperties.OfType<IEdmNavigationProperty>();
        }

        /// <summary>
        /// Get the navigation properties declared in this structured type and all base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in this structured type and all base types.</returns>
        public static IEnumerable<IEdmNavigationProperty> NavigationProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.Properties().OfType<IEdmNavigationProperty>();
        }

        /// <summary>
        /// Gets the declared key of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Key of this type.</returns>
        public static IEnumerable<IEdmStructuralProperty> Key(this IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmEntityType checkingType = type;
            while (checkingType != null)
            {
                if (checkingType.DeclaredKey != null)
                {
                    return checkingType.DeclaredKey;
                }

                checkingType = checkingType.BaseEntityType();
            }

            return Enumerable.Empty<IEdmStructuralProperty>();
        }

        /// <summary>
        /// Determines whether the specified property is a key for its contained type.
        /// </summary>
        /// <param name="property">The property that may be a key.</param>
        /// <returns>True, if the property is a key, False if the property is not a key.</returns>
        public static bool IsKey(this IEdmProperty property)
        {
            EdmUtil.CheckArgumentNull(property, "property");
            IEdmEntityType entityType = property.DeclaringType as IEdmEntityType;

            if (entityType != null)
            {
                foreach (IEdmProperty key in entityType.Key())
                {
                    if (key == property)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the declared alternate keys of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="model">The model to be used.</param>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Alternate Keys of this type.</returns>
        public static IEnumerable<IDictionary<string, IEdmProperty>> GetAlternateKeysAnnotation(this IEdmModel model, IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(type, "type");

            IEdmEntityType checkingType = type;
            while (checkingType != null)
            {
                IEnumerable<IDictionary<string, IEdmProperty>> declaredAlternateKeys = GetDeclaredAlternateKeysForType(checkingType, model);
                if (declaredAlternateKeys != null)
                {
                    return declaredAlternateKeys;
                }

                checkingType = checkingType.BaseEntityType();
            }

            return Enumerable.Empty<IDictionary<string, IEdmProperty>>();
        }

        /// <summary>
        /// Adds the alternate keys to this entity type.
        /// </summary>
        /// <param name="model">The model to be used.</param>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="alternateKey">Dictionary of alias and structural properties for the alternate key.</param>
        public static void AddAlternateKeyAnnotation(this EdmModel model, IEdmEntityType type, IDictionary<string, IEdmProperty> alternateKey)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(alternateKey, "alternateKey");

            EdmCollectionExpression annotationValue = null;
            var ann = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(type, AlternateKeysVocabularyModel.AlternateKeysTerm).FirstOrDefault();
            if (ann != null)
            {
                annotationValue = ann.Value as EdmCollectionExpression;
            }

            var alternateKeysCollection = annotationValue != null ? new List<IEdmExpression>(annotationValue.Elements) : new List<IEdmExpression>();

            List<IEdmExpression> propertyRefs = new List<IEdmExpression>();

            foreach (KeyValuePair<string, IEdmProperty> kvp in alternateKey)
            {
                IEdmRecordExpression propertyRef = new EdmRecordExpression(
                    new EdmComplexTypeReference(AlternateKeysVocabularyModel.PropertyRefType, false),
                    new EdmPropertyConstructor(AlternateKeysVocabularyConstants.PropertyRefTypeAliasPropertyName, new EdmStringConstant(kvp.Key)),
                    new EdmPropertyConstructor(AlternateKeysVocabularyConstants.PropertyRefTypeNamePropertyName, new EdmPropertyPathExpression(kvp.Value.Name)));
                propertyRefs.Add(propertyRef);
            }

            EdmRecordExpression alternateKeyRecord = new EdmRecordExpression(
                new EdmComplexTypeReference(AlternateKeysVocabularyModel.AlternateKeyType, false),
                new EdmPropertyConstructor(AlternateKeysVocabularyConstants.AlternateKeyTypeKeyPropertyName, new EdmCollectionExpression(propertyRefs)));

            alternateKeysCollection.Add(alternateKeyRecord);

            var annotation = new EdmVocabularyAnnotation(
                type,
                AlternateKeysVocabularyModel.AlternateKeysTerm,
                new EdmCollectionExpression(alternateKeysCollection));

            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Checks whether the given entity type has the <paramref name="property"/> as one of the key properties.
        /// </summary>
        /// <param name="entityType">Given entity type.</param>
        /// <param name="property">Property to be searched for.</param>
        /// <returns><c>true</c> if the type or base types has given property declared as key. <c>false</c> otherwise.</returns>
        public static bool HasDeclaredKeyProperty(this IEdmEntityType entityType, IEdmProperty property)
        {
            EdmUtil.CheckArgumentNull(entityType, "entityType");
            EdmUtil.CheckArgumentNull(property, "property");

            while (entityType != null)
            {
                if (entityType.DeclaredKey != null && entityType.DeclaredKey.Any(k => k == property))
                {
                    return true;
                }

                entityType = entityType.BaseEntityType();
            }

            return false;
        }

        #endregion

        #region IEdmEntityTypeReference
        /// <summary>
        /// Gets the definition of this entity reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this entity reference.</returns>
        public static IEdmEntityType EntityDefinition(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEntityType)type.Definition;
        }

        /// <summary>
        /// Gets the base type of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of the definition of this reference.</returns>
        public static IEdmEntityType BaseEntityType(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityDefinition().BaseEntityType();
        }

        /// <summary>
        /// Gets the entity key of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The entity key of the definition of this reference.</returns>
        public static IEnumerable<IEdmStructuralProperty> Key(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityDefinition().Key();
        }
        #endregion

        #region IEdmComplexTypeDefinition
        /// <summary>
        /// Gets the base type of this references definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this references definition.</returns>
        public static IEdmComplexType BaseComplexType(this IEdmComplexType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmComplexType;
        }
        #endregion

        #region IEdmComplexTypeReference
        /// <summary>
        /// Gets the definition of this reference typed as an IEdmComplexTypeDefinition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this reference typed as an IEdmComplexTypeDefinition.</returns>
        public static IEdmComplexType ComplexDefinition(this IEdmComplexTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmComplexType)type.Definition;
        }

        /// <summary>
        /// Gets the base type of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this reference.</returns>
        public static IEdmComplexType BaseComplexType(this IEdmComplexTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.ComplexDefinition().BaseComplexType();
        }
        #endregion

        #region IEdmEntityReferenceTypeReference
        /// <summary>
        /// Gets the definition of this entity reference type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this entity reference type reference.</returns>
        public static IEdmEntityReferenceType EntityReferenceDefinition(this IEdmEntityReferenceTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEntityReferenceType)type.Definition;
        }

        /// <summary>
        /// Gets the entity type referred to by the definition of this entity reference type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The entity type referred to by the definition of this entity reference type reference.</returns>
        public static IEdmEntityType EntityType(this IEdmEntityReferenceTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityReferenceDefinition().EntityType;
        }
        #endregion

        #region IEdmCollectionTypeReference
        /// <summary>
        /// Gets the definition of this collection reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this collection reference.</returns>
        public static IEdmCollectionType CollectionDefinition(this IEdmCollectionTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmCollectionType)type.Definition;
        }

        /// <summary>
        /// Gets the element type of the definition of this collection reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The element type of the definition of this collection reference.</returns>
        public static IEdmTypeReference ElementType(this IEdmCollectionTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.CollectionDefinition().ElementType;
        }

        #endregion

        #region IEdmEnumTypeReference

        /// <summary>
        /// Gets the definition of this enumeration reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this enumeration reference.</returns>
        public static IEdmEnumType EnumDefinition(this IEdmEnumTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEnumType)type.Definition;
        }

        #endregion

        #region IEdmTypeDefinitionReference

        /// <summary>
        /// Gets the definition of this type definition reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this type definition reference.</returns>
        public static IEdmTypeDefinition TypeDefinition(this IEdmTypeDefinitionReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmTypeDefinition)type.Definition;
        }

        #endregion

        #region IEdmNavigationProperty

        /// <summary>
        /// Gets the multiplicity of the target of this navigation.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The multiplicity of the target end of the relationship.</returns>
        public static EdmMultiplicity TargetMultiplicity(this IEdmNavigationProperty property)
        {
            EdmUtil.CheckArgumentNull(property, "property");

            IEdmTypeReference type = property.Type;
            if (type.IsCollection())
            {
                return EdmMultiplicity.Many;
            }

            return type.IsNullable ? EdmMultiplicity.ZeroOrOne : EdmMultiplicity.One;
        }

        /// <summary>
        /// Gets the entity type targeted by this navigation property.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The entity type targeted by this navigation property.</returns>
        public static IEdmEntityType ToEntityType(this IEdmNavigationProperty property)
        {
            return property.Type.Definition.AsElementType() as IEdmEntityType;
        }

        /// <summary>
        /// Gets the structured type targeted by this structural property type reference.
        /// </summary>
        /// <param name="propertyTypeReference">Reference to the calling object.</param>
        /// <returns>The structured type targeted by this structural property.</returns>
        public static IEdmStructuredType ToStructuredType(this IEdmTypeReference propertyTypeReference)
        {
            IEdmType target = propertyTypeReference.Definition;
            if (target.TypeKind == EdmTypeKind.Collection)
            {
                target = ((IEdmCollectionType)target).ElementType.Definition;
            }

            return target as IEdmStructuredType;
        }

        /// <summary>
        /// Gets the entity type declaring this navigation property.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The entity type that declares this navigation property.</returns>
        public static IEdmEntityType DeclaringEntityType(this IEdmNavigationProperty property)
        {
            return (IEdmEntityType)property.DeclaringType;
        }

        /// <summary>
        /// Gets whether this navigation property originates at the principal end of an association.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>Whether this navigation property originates at the principal end of an association.</returns>
        public static bool IsPrincipal(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null && navigationProperty.Partner != null && navigationProperty.Partner.ReferentialConstraint != null;
        }

        /// <summary>
        /// Gets the dependent properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>The dependent properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.</returns>
        public static IEnumerable<IEdmStructuralProperty> DependentProperties(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null ? null : navigationProperty.ReferentialConstraint.PropertyPairs.Select(p => p.DependentProperty);
        }

        /// <summary>
        /// Gets the principal properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>The principal properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.</returns>
        public static IEnumerable<IEdmStructuralProperty> PrincipalProperties(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null ? null : navigationProperty.ReferentialConstraint.PropertyPairs.Select(p => p.PrincipalProperty);
        }

        #endregion

        #region IEdmVocabularyAnnotation
        /// <summary>
        /// Gets the term of this annotation.
        /// </summary>
        /// <param name="annotation">Reference to the calling object.</param>
        /// <returns>The term of this annotation.</returns>
        public static IEdmTerm Term(this IEdmVocabularyAnnotation annotation)
        {
            EdmUtil.CheckArgumentNull(annotation, "annotation");
            return annotation.Term;
        }
        #endregion

        #region IEdmOperationImport
        /// <summary>
        /// Tries to get the relative entity set path.
        /// </summary>
        /// <param name="operation">The operation to resolve the entitySet path.</param>
        /// <param name="model">The model.</param>
        /// <param name="parameter">The parameter.</param>
        /// <param name="relativeNavigations">The relative navigations and its path.</param>
        /// <param name="lastEntityType">Last type of the entity.</param>
        /// <param name="errors">The errors.</param>
        /// <returns>True if a Entity set path is found, false otherwise.</returns>
        public static bool TryGetRelativeEntitySetPath(this IEdmOperation operation, IEdmModel model, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEdmEntityType lastEntityType, out IEnumerable<EdmError> errors)
        {
            errors = Enumerable.Empty<EdmError>();
            parameter = null;
            relativeNavigations = null;
            lastEntityType = null;

            Debug.Assert(operation != null, "expected non null operation");

            // If a value does not exist just return as there is nothing to validate.
            if (operation.EntitySetPath == null)
            {
                return false;
            }

            Collection<EdmError> foundErrors = new Collection<EdmError>();
            errors = foundErrors;
            if (!operation.IsBound)
            {
                foundErrors.Add(
                    new EdmError(
                        operation.Location(),
                        EdmErrorCode.OperationCannotHaveEntitySetPathWithUnBoundOperation,
                        Strings.EdmModel_Validator_Semantic_OperationCannotHaveEntitySetPathWithUnBoundOperation(operation.Name)));
            }

            return TryGetRelativeEntitySetPath(operation, foundErrors, operation.EntitySetPath, model, operation.Parameters, out parameter, out relativeNavigations, out lastEntityType);
        }


        /// <summary>
        /// Determines whether [is action import] [the specified operation import].
        /// </summary>
        /// <param name="operationImport">The operation import.</param>
        /// <returns>
        ///   <c>true</c> if [is action import] [the specified operation import]; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsActionImport(this IEdmOperationImport operationImport)
        {
            return operationImport.ContainerElementKind == EdmContainerElementKind.ActionImport;
        }

        /// <summary>
        /// Determines whether [is function import] [the specified operation import].
        /// </summary>
        /// <param name="operationImport">The operation import.</param>
        /// <returns>
        ///   <c>true</c> if [is function import] [the specified operation import]; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsFunctionImport(this IEdmOperationImport operationImport)
        {
            return operationImport.ContainerElementKind == EdmContainerElementKind.FunctionImport;
        }

        /// <summary>
        /// Analyzes <see cref="IEdmOperationImport"/>.EntitySet expression and returns a static <see cref="IEdmEntitySet"/> reference if available.
        /// </summary>
        /// <param name="operationImport">The operation import containing the entity set expression.</param>
        /// <param name="model">The model containing the operation import.</param>
        /// <param name="entitySet">The static entity set of the operation import.</param>
        /// <returns>True if the entity set expression of the <paramref name="operationImport"/> contains a static reference to an <see cref="IEdmEntitySet"/>, otherwise false.</returns>
        /// <remarks>TODO: Support resolving target path to a contained entity set.</remarks>
        public static bool TryGetStaticEntitySet(this IEdmOperationImport operationImport, IEdmModel model, out IEdmEntitySetBase entitySet)
        {
            var pathExpression = operationImport.EntitySet as IEdmPathExpression;
            if (pathExpression != null)
            {
                return pathExpression.TryGetStaticEntitySet(model, out entitySet);
            }

            entitySet = null;
            return false;
        }

        /// <summary>
        /// Analyzes <see cref="IEdmOperationImport"/>.EntitySet expression and returns a relative path to an <see cref="IEdmEntitySet"/> if available.
        /// The path starts with the <paramref name="parameter"/> and may have optional sequence of <see cref="IEdmNavigationProperty"/> and type casts segments.
        /// </summary>
        /// <param name="operationImport">The operation import containing the entity set expression.</param>
        /// <param name="model">The model containing the operation import.</param>
        /// <param name="parameter">The operation import parameter from which the relative entity set path starts.</param>
        /// <param name="relativeNavigations">The optional sequence of navigation properties and their path</param>
        /// <param name="edmErrors">The errors that were found when attempting to get the relative path.</param>
        /// <returns>True if the entity set expression of the <paramref name="operationImport"/> contains a relative path an <see cref="IEdmEntitySet"/>, otherwise false.</returns>
        public static bool TryGetRelativeEntitySetPath(this IEdmOperationImport operationImport, IEdmModel model, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEnumerable<EdmError> edmErrors)
        {
            EdmUtil.CheckArgumentNull(operationImport, "operationImport");
            EdmUtil.CheckArgumentNull(model, "model");

            parameter = null;
            relativeNavigations = null;
            edmErrors = new ReadOnlyCollection<EdmError>(new List<EdmError>());

            IEdmPathExpression pathExpression = operationImport.EntitySet as IEdmPathExpression;
            if (pathExpression != null)
            {
                IEdmEntityType entityType = null;
                Collection<EdmError> foundErrors = new Collection<EdmError>();
                bool result = TryGetRelativeEntitySetPath(operationImport, foundErrors, pathExpression, model, operationImport.Operation.Parameters, out parameter, out relativeNavigations, out entityType);
                edmErrors = new ReadOnlyCollection<EdmError>(foundErrors);

                return result;
            }

            return false;
        }

        #endregion

        #region IEdmOperation

        /// <summary>
        /// Determines whether the specified operation is action.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>
        ///   <c>true</c> if the specified operation is action; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsAction(this IEdmOperation operation)
        {
            return operation.SchemaElementKind == EdmSchemaElementKind.Action;
        }

        /// <summary>
        /// Determines whether the specified operation is function.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>
        ///   <c>true</c> if the specified operation is function; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsFunction(this IEdmOperation operation)
        {
            return operation.SchemaElementKind == EdmSchemaElementKind.Function;
        }

        /// <summary>
        /// Gets the <see cref="IEdmOperationReturn"/> from the specified operation.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>The instance of <see cref="IEdmOperationReturn"/> or null if the operation has no return type.</returns>
        public static IEdmOperationReturn GetReturn(this IEdmOperation operation)
        {
            EdmOperation edmOperation = operation as EdmOperation;
            if (edmOperation != null)
            {
                return edmOperation.Return;
            }

            CsdlSemanticsOperation csdlOperation = operation as CsdlSemanticsOperation;
            if (csdlOperation != null)
            {
                return csdlOperation.Return;
            }

            if (operation == null || operation.ReturnType == null)
            {
                return null;
            }

            return new EdmOperationReturn(operation, operation.ReturnType);
        }

        /// <summary>
        /// Checks whether all operations have the same return type
        /// </summary>
        /// <param name="operations">the list to check</param>
        /// <param name="forceFullyQualifiedNameFilter">Ensures that the Where filter clause applies the Full name,</param>
        /// <param name="operationName">The operation name to filter by.</param>
        /// <returns>true if the list of operation imports all have the same return type</returns>
        public static IEnumerable<IEdmOperation> FilterByName(this IEnumerable<IEdmOperation> operations, bool forceFullyQualifiedNameFilter, string operationName)
        {
            EdmUtil.CheckArgumentNull(operations, "operations");
            EdmUtil.CheckArgumentNull(operationName, "operationName");

            if (forceFullyQualifiedNameFilter || operationName.IndexOf(".", StringComparison.Ordinal) > -1)
            {
                return operations.Where(o => o.FullName() == operationName);
            }
            else
            {
                return operations.Where(o => o.Name == operationName);
            }
        }

        /// <summary>
        /// Determines whether the bound operation's  binding type is equivalent to the specified binding type.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>
        ///   <c>true</c> if [is operation binding type equivalent to] [the specified operation]; otherwise, <c>false</c>.
        /// </returns>
        public static bool HasEquivalentBindingType(this IEdmOperation operation, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(operation, "operation");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");

            if (!operation.IsBound)
            {
                return false;
            }

            IEdmOperationParameter parameter = operation.Parameters.FirstOrDefault();
            if (parameter == null)
            {
                return false;
            }

            IEdmType parameterType = parameter.Type.Definition;
            if (parameterType.TypeKind != bindingType.TypeKind)
            {
                return false;
            }

            if (parameterType.TypeKind == EdmTypeKind.Collection)
            {
                // covariance applies here, so IEnumerable<A> is applicable to IEnumerable<B> where B:A
                IEdmCollectionType parameterCollectionType = (IEdmCollectionType)parameterType;
                IEdmCollectionType bindingCollectionType = (IEdmCollectionType)bindingType;

                return bindingCollectionType.ElementType.Definition.IsOrInheritsFrom(parameterCollectionType.ElementType.Definition);
            }
            else
            {
                return bindingType.IsOrInheritsFrom(parameterType);
            }
        }

        #endregion

        #region IEdmRecordExpression

        /// <summary>
        /// Finds a property of a record expression.
        /// </summary>
        /// <param name="expression">The record expression.</param>
        /// <param name="name">Name of the property to find.</param>
        /// <returns>The property, if found, otherwise null.</returns>
        public static IEdmPropertyConstructor FindProperty(this IEdmRecordExpression expression, string name)
        {
            foreach (IEdmPropertyConstructor propertyConstructor in expression.Properties)
            {
                if (propertyConstructor.Name == name)
                {
                    return propertyConstructor;
                }
            }

            return null;
        }

        #endregion

        #region IEdmNavigationSource

        /// <summary>
        /// Return the navigation kind of the navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>The kind of the navigation source.</returns>
        public static EdmNavigationSourceKind NavigationSourceKind(this IEdmNavigationSource navigationSource)
        {
            if (navigationSource is IEdmEntitySet)
            {
                return EdmNavigationSourceKind.EntitySet;
            }

            if (navigationSource is IEdmSingleton)
            {
                return EdmNavigationSourceKind.Singleton;
            }

            if (navigationSource is IEdmContainedEntitySet)
            {
                return EdmNavigationSourceKind.ContainedEntitySet;
            }

            if (navigationSource is IEdmUnknownEntitySet)
            {
                return EdmNavigationSourceKind.UnknownEntitySet;
            }

            return EdmNavigationSourceKind.None;
        }

        /// <summary>
        /// Returns the fully qualified name of a navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source to get the full name for.</param>
        /// <returns>The full qualified name of the navigation source.</returns>
        public static string FullNavigationSourceName(this IEdmNavigationSource navigationSource)
        {
            EdmUtil.CheckArgumentNull(navigationSource, "navigationSource");

            return string.Join(".", navigationSource.Path.PathSegments.ToArray());
        }

        /// <summary>
        /// Return the entity type of the navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>The entity type of the navigation source.</returns>
        public static IEdmEntityType EntityType(this IEdmNavigationSource navigationSource)
        {
            var entitySetBase = navigationSource as IEdmEntitySetBase;
            if (entitySetBase != null)
            {
                IEdmCollectionType collectionType = entitySetBase.Type as IEdmCollectionType;

                if (collectionType != null)
                {
                    return collectionType.ElementType.Definition as IEdmEntityType;
                }

                var unknownEntitySet = entitySetBase as IEdmUnknownEntitySet;
                if (unknownEntitySet != null)
                {
                    // Handle missing navigation target for nullable
                    // singleton navigation property.
                    return unknownEntitySet.Type as IEdmEntityType;
                }

                return null;
            }

            var singleton = navigationSource as IEdmSingleton;
            if (singleton != null)
            {
                return singleton.Type as IEdmEntityType;
            }

            return null;
        }

        #endregion

        #region IEdmReferences

        /// <summary>
        /// Sets edmx:Reference information (IEdmReference) to the model.
        /// </summary>
        /// <param name="model">The IEdmModel to set edmx:Reference information.</param>
        /// <param name="edmReferences">The edmx:Reference information to be set.</param>
        public static void SetEdmReferences(this IEdmModel model, IEnumerable<IEdmReference> edmReferences)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            model.SetAnnotationValue(model, EdmConstants.InternalUri, CsdlConstants.ReferencesAnnotation, edmReferences);
        }

        /// <summary>
        /// Gets edmx:Reference information (IEdmReference) from the model.
        /// </summary>
        /// <param name="model">The IEdmModel to get edmx:Reference information.</param>
        /// <returns>The edmx:Reference information.</returns>
        public static IEnumerable<IEdmReference> GetEdmReferences(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            return (IEnumerable<IEdmReference>)model.GetAnnotationValue(model, EdmConstants.InternalUri, CsdlConstants.ReferencesAnnotation);
        }

        #endregion

        /// <summary>
        /// Gets the partner path of a navigation property.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>Path to the partner navigation property from the related entity type.</returns>
        public static IEdmPathExpression GetPartnerPath(this IEdmNavigationProperty navigationProperty)
        {
            var edmNavigationProperty = navigationProperty as EdmNavigationProperty;
            if (edmNavigationProperty != null)
            {
                return edmNavigationProperty.PartnerPath;
            }

            var csdlSemanticsNavigationProperty = navigationProperty as CsdlSemanticsNavigationProperty;
            if (csdlSemanticsNavigationProperty != null)
            {
                return (csdlSemanticsNavigationProperty.Element as CsdlNavigationProperty)?.PartnerPath;
            }

            // Default behavior where partner path corresponds to the name of the partner nav. property. In other words,
            // the partner must be on an entity type. Will remove this limitation once we are OK to make breaking changes
            // on IEdmNavigationProperty.
            return navigationProperty.Partner == null ? null : new EdmPathExpression(navigationProperty.Partner.Name);
        }

        /// <summary>
        /// Replace a possibly alias-qualified name with the full namespace qualified name.
        /// </summary>
        /// <param name="model">The model containing the element.</param>
        /// <param name="name">The alias- or namespace- qualified name of the element.</param>
        /// <returns>The namespace qualified name of the element.</returns>
        internal static string ReplaceAlias(this IEdmModel model, string name)
        {
            VersioningDictionary<string, string> mappings = model.GetNamespaceAliases();
            VersioningList<string> list = model.GetUsedNamespacesHavingAlias();
            int idx = name.IndexOf('.');

            if (list != null && mappings != null && idx > 0)
            {
                var typeAlias = name.Substring(0, idx);
                var ns = list.FirstOrDefault(n =>
                {
                    string alias;
                    return mappings.TryGetValue(n, out alias) && alias == typeAlias;
                });

                return (ns != null) ? string.Format(CultureInfo.InvariantCulture, "{0}{1}", ns, name.Substring(idx)) : name;
            }

            return name;
        }

        #region methods for finding elements in CsdlSemanticsModel

        internal static IEnumerable<IEdmOperation> FindOperationsInModelTree(this CsdlSemanticsModel model, string name)
        {
            return model.FindInModelTree(findOperations, name, mergeFunctions);
        }

        /// <summary>
        /// Find types in CsdlSemanticsModel tree.
        /// </summary>
        /// <param name="model">The CsdlSemanticsModel.</param>
        /// <param name="name">The name by which to search.</param>
        /// <returns>The found emd type or null.</returns>
        internal static IEdmSchemaType FindTypeInModelTree(this CsdlSemanticsModel model, string name)
        {
            return model.FindInModelTree(findType, name, RegistrationHelper.CreateAmbiguousTypeBinding);
        }

        /// <summary>
        /// Searches for a type with the given name in the model and its main/sibling/referenced models, returns null if no such type exists.
        /// </summary>
        /// <typeparam name="T">the type of value to find.</typeparam>
        /// <param name="model">The model to search for type.</param>
        /// <param name="finderFunc">The func for each IEdmModel node to find element by name.</param>
        /// <param name="qualifiedName">The qualified name of the type being found.</param>
        /// <param name="ambiguousCreator">The func to combine results when more than one is found.</param>
        /// <remarks>when searching, will ignore built-in types in EdmCoreModel and CoreVocabularyModel.</remarks>
        /// <returns>The requested type, or null if no such type exists.</returns>
        internal static T FindInModelTree<T>(this CsdlSemanticsModel model, Func<IEdmModel, string, T> finderFunc, string qualifiedName, Func<T, T, T> ambiguousCreator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(finderFunc, "finderFunc");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");
            EdmUtil.CheckArgumentNull(ambiguousCreator, "ambiguousCreator");

            // find type in current model only
            T result = finderFunc(model, qualifiedName);
            T candidate;

            // now find type in main model and current model's sibling models.
            if (model.MainModel != null)
            {
                // main model:
                if ((candidate = finderFunc(model.MainModel, qualifiedName)) != null)
                {
                    result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                }

                // current model's sibling models :
                foreach (var tmp in model.MainModel.ReferencedModels)
                {
                    // doesn't search the current model again
                    if ((tmp != EdmCoreModel.Instance) && (tmp != CoreVocabularyModel.Instance)
                        && tmp != model)
                    {
                        if ((candidate = finderFunc(tmp, qualifiedName)) != null)
                        {
                            result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                        }
                    }
                }
            }

            // then find type in referenced models
            foreach (var tmp in model.ReferencedModels)
            {
                candidate = finderFunc(tmp, qualifiedName);
                if (candidate != null)
                {
                    result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                }
            }

            return result;
        }
        #endregion

        #region UrlEscape
        /// <summary>
        /// Determines whether the specified function is UrlEscape function or not.
        /// </summary>
        /// <param name="model">The Edm model.</param>
        /// <param name="function">The specified function</param>
        /// <returns><c>true</c> if the specified operation is UrlEscape function; otherwise, <c>false</c>.</returns>
        internal static bool IsUrlEscapeFunction(this IEdmModel model, IEdmFunction function)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(function, "function");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(function, CommunityVocabularyModel.UrlEscapeFunctionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value == null)
                {
                    // If the annotation is applied but a value is not specified then the value is assumed to be true.
                    return true;
                }

                IEdmBooleanConstantExpression tagConstant = annotation.Value as IEdmBooleanConstantExpression;
                if (tagConstant != null)
                {
                    return tagConstant.Value;
                }
            }

            return false;
        }

        /// <summary>
        /// Set annotation Org.OData.Community.V1.UrlEscapeFunction to <see cref="IEdmFunction"/>.
        /// </summary>
        /// <param name="model">The model to add annotation</param>
        /// <param name="function">The target function to set the inline annotation</param>
        internal static void SetUrlEscapeFunction(this EdmModel model, IEdmFunction function)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(function, "function");

            IEdmBooleanConstantExpression booleanConstant = new EdmBooleanConstant(true);
            IEdmTerm term = CommunityVocabularyModel.UrlEscapeFunctionTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(function, term, booleanConstant);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }
        #endregion

        internal static bool TryGetRelativeEntitySetPath(IEdmElement element, Collection<EdmError> foundErrors, IEdmPathExpression pathExpression, IEdmModel model, IEnumerable<IEdmOperationParameter> parameters, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEdmEntityType lastEntityType)
        {
            parameter = null;
            relativeNavigations = null;
            lastEntityType = null;

            var pathItems = pathExpression.PathSegments.ToList();
            if (pathItems.Count < 1)
            {
                foundErrors.Add(new EdmError(element.Location(), EdmErrorCode.OperationWithInvalidEntitySetPathMissingCompletePath, Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathMissingBindingParameterName(CsdlConstants.Attribute_EntitySetPath)));
                return false;
            }

            // If there is no parameter then this will fail in BoundOperationMustHaveParameters rule so skip validating this here.
            parameter = parameters.FirstOrDefault();
            if (parameter == null)
            {
                return false;
            }

            bool foundRelativePath = true;

            string bindingParameterName = pathItems.First();
            if (parameter.Name != bindingParameterName)
            {
                foundErrors.Add(
                    new EdmError(
                        element.Location(),
                        EdmErrorCode.InvalidPathFirstPathParameterNotMatchingFirstParameterName,
                        Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathWithFirstPathParameterNotMatchingFirstParameterName(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), bindingParameterName, parameter.Name)));

                foundRelativePath = false;
            }

            lastEntityType = parameter.Type.Definition as IEdmEntityType;
            if (lastEntityType == null)
            {
                var collectionReference = parameter.Type as IEdmCollectionTypeReference;
                if (collectionReference != null && collectionReference.ElementType().IsEntity())
                {
                    lastEntityType = collectionReference.ElementType().Definition as IEdmEntityType;
                }
                else
                {
                    foundErrors.Add(
                        new EdmError(
                            element.Location(),
                            EdmErrorCode.InvalidPathWithNonEntityBindingParameter,
                            Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathWithNonEntityBindingParameter(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), bindingParameterName)));

                    return false;
                }
            }

            Dictionary<IEdmNavigationProperty, IEdmPathExpression> navigationProperties = new Dictionary<IEdmNavigationProperty, IEdmPathExpression>();
            List<string> paths = new List<string>();

            // Now check that the next paths are valid parameters.
            foreach (string pathSegment in pathItems.Skip(1))
            {
                paths.Add(pathSegment);

                if (EdmUtil.IsQualifiedName(pathSegment))
                {
                    IEdmSchemaType foundType = model.FindDeclaredType(pathSegment);
                    if (foundType == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathUnknownTypeCastSegment,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathUnknownTypeCastSegment(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), pathSegment)));

                        foundRelativePath = false;
                        break;
                    }

                    IEdmEntityType foundEntityTypeCast = foundType as IEdmEntityType;

                    if (foundEntityTypeCast == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathTypeCastSegmentMustBeEntityType,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathTypeCastSegmentMustBeEntityType(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), foundType.FullName())));

                        foundRelativePath = false;
                        break;
                    }

                    if (!foundEntityTypeCast.IsOrInheritsFrom(lastEntityType))
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathInvalidTypeCastSegment,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathInvalidTypeCastSegment(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), lastEntityType.FullName(), foundEntityTypeCast.FullName())));

                        foundRelativePath = false;
                        break;
                    }

                    lastEntityType = foundEntityTypeCast;
                }
                else
                {
                    IEdmNavigationProperty navigationProperty = lastEntityType.FindProperty(pathSegment) as IEdmNavigationProperty;
                    if (navigationProperty == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathUnknownNavigationProperty,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathUnknownNavigationProperty(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), pathSegment)));

                        foundRelativePath = false;
                        break;
                    }

                    navigationProperties[navigationProperty] = new EdmPathExpression(paths);

                    // In 7.4.1, FindNavigationTarget expected a binding path that included the path
                    // to the contained entity set. In 7.4.2 FindNavigationTarget was fixed to work off
                    // of the path from the contained entity set, but retained the old behavior as well
                    // for backward compatibility. In the next breaking change we should remove that
                    // behavior in FindNavigationTarget and remove this special handling of containsTarget
                    // by always clearing the path.
                    if (!navigationProperty.ContainsTarget)
                    {
                        paths.Clear();
                    }

                    lastEntityType = navigationProperty.ToEntityType();
                }
            }

            relativeNavigations = navigationProperties;
            return foundRelativePath;
        }

        /// <summary>
        /// This method is only used for the operation import entity set path parsing.
        /// </summary>
        /// <param name="segmentType">The type of the segment.</param>
        /// <returns>Non-null entity type that may be bad.</returns>
        internal static IEdmEntityType GetPathSegmentEntityType(IEdmTypeReference segmentType)
        {
            return (segmentType.IsCollection() ? segmentType.AsCollection().ElementType() : segmentType).AsEntity().EntityDefinition();
        }

        internal static IEnumerable<IEdmEntityContainerElement> AllElements(this IEdmEntityContainer container, int depth = ContainerExtendsMaxDepth)
        {
            if (depth <= 0)
            {
                throw new InvalidOperationException(Edm.Strings.Bad_CyclicEntityContainer(container.FullName()));
            }

            CsdlSemanticsEntityContainer semanticsEntityContainer = container as CsdlSemanticsEntityContainer;
            if (semanticsEntityContainer == null || semanticsEntityContainer.Extends == null)
            {
                return container.Elements;
            }

            return container.Elements.Concat(semanticsEntityContainer.Extends.AllElements(depth - 1));
        }

        /// <summary>
        /// Searches for entity set by the given name that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        internal static IEdmEntitySet FindEntitySetExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindEntitySet(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for an entity set or contained navigation property according to the specified path that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="path">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        internal static IEdmNavigationSource FindNavigationSourceExtended(this IEdmEntityContainer container, string path)
        {
            return FindInContainerAndExtendsRecursively(container, path, (c, n) => c.FindNavigationSource(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for an entity set or contained navigation property according to the specified path that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="path">The path which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The navigation source found or empty if none found.</returns>
        internal static IEdmNavigationSource FindNavigationSource(this IEdmEntityContainer container, string path)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            EdmUtil.CheckArgumentNull(path, "path");

            // the path could be:
            // "NS.Default.Customers/ContainedOrders"(for backward-compatibility) or
            // "NS.Default/Customers/ContainedOrders" (for top-level entity set in the Default entity container) or
            // "Customers" (unqualified)
            // "Customers/ContainedOrders" (unqualified)
            string[] pathSegments = path.Split('/');

            string firstElementName = pathSegments[0];
            int nextIndex = 1;
            if (firstElementName.Contains("."))
            {
                if (string.Equals(firstElementName, container.FullName(), StringComparison.OrdinalIgnoreCase))
                {
                    if (pathSegments.Length > 1)
                    {
                        // NS.Default/Customers/ContainedOrders
                        firstElementName = pathSegments[1];
                        nextIndex = 2;
                    }
                    else
                    {
                        // if path only includes the namespace, for example "NS.Default", just return null;
                        return null;
                    }
                }
                else
                {
                    // NS.Default.Customers/ContainedOrders
                    // Split the first item using "." and fetch the last segment.
                    firstElementName = pathSegments[0].Split('.').Last();
                }
            }

            // Starting segment must be a singleton or entity set
            IEdmNavigationSource navigationSource = container.FindEntitySet(firstElementName);

            if (navigationSource == null)
            {
                navigationSource = container.FindSingleton(firstElementName);
            }

            // Subsequent segments may be single-valued complex or containment nav props
            List<string> subPathSegments = new List<string>();
            for (int i = nextIndex; i < pathSegments.Length && navigationSource != null; i++)
            {
                subPathSegments.Add(pathSegments[i]);
                IEdmNavigationProperty navProp = navigationSource.EntityType().FindProperty(pathSegments[i]) as IEdmNavigationProperty;
                if (navProp != null)
                {
                    navigationSource = navigationSource.FindNavigationTarget(navProp, new EdmPathExpression(subPathSegments));
                    subPathSegments.Clear();
                }
            }

            return navigationSource;
        }

        /// <summary>
        /// Searches for singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The singleton found or empty if none found.</returns>
        internal static IEdmSingleton FindSingletonExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindSingleton(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for the operation imports by the specified name in default container and .Extends containers, returns an empty enumerable if no operation import exists.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation import which may or may not include the container name.</param>
        /// <returns>All operation imports that can be found by the specified name, returns an empty enumerable if no operation import exists.</returns>
        internal static IEnumerable<IEdmOperationImport> FindOperationImportsExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindOperationImports(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Get the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The type definition.</param>
        /// <returns>The primitive value converter for the type definition.</returns>
        internal static IPrimitiveValueConverter GetPrimitiveValueConverter(this IEdmModel model, IEdmType typeDefinition)
        {
            Debug.Assert(model != null, "model != null");
            Debug.Assert(typeDefinition != null, "typeDefinition must be provided");

            // If the model does not have primitive value converter map yet, use the pass-through implementation.
            var converter = model.GetAnnotationValue<IPrimitiveValueConverter>(typeDefinition, EdmConstants.InternalUri, CsdlConstants.PrimitiveValueConverterMapAnnotation);
            if (converter == null)
            {
                return PassThroughPrimitiveValueConverter.Instance;
            }

            return converter;
        }

        /// <summary>
        /// Set the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The type definition.</param>
        /// <param name="converter">The primitive value converter for the type definition.</param>
        internal static void SetPrimitiveValueConverter(this IEdmModel model, IEdmType typeDefinition, IPrimitiveValueConverter converter)
        {
            Debug.Assert(model != null, "model != null");
            Debug.Assert(typeDefinition != null, "typeDefinition must be provided");
            Debug.Assert(converter != null, "converter != null");

            model.SetAnnotationValue(typeDefinition, EdmConstants.InternalUri, CsdlConstants.PrimitiveValueConverterMapAnnotation, converter);
        }

        internal static bool TryGetStaticEntitySet(this IEdmPathExpression pathExpression, IEdmModel model, out IEdmEntitySetBase entitySet)
        {
            var segmentIterator = pathExpression.PathSegments.GetEnumerator();
            if (!segmentIterator.MoveNext())
            {
                entitySet = null;
                return false;
            }

            IEdmEntityContainer container;
            var segment = segmentIterator.Current;
            if (segment.Contains("."))
            {
                // The first segment is the qualified name of an entity container.
                container = model.FindEntityContainer(segment);

                if (segmentIterator.MoveNext())
                {
                    segment = segmentIterator.Current;
                }
                else
                {
                    // Path that only contains an entity container is invalid.
                    entitySet = null;
                    return false;
                }
            }
            else
            {
                // No entity container specified. Use the default one from model.
                container = model.EntityContainer;
            }

            if (container == null)
            {
                entitySet = null;
                return false;
            }

            // The next segment must be entity set.
            var resolvedEntitySet = container.FindEntitySet(segment);

            // If there is any segment left, the path must represent a contained entity set.
            entitySet = segmentIterator.MoveNext() ? null : resolvedEntitySet;
            return entitySet != null;
        }

        /// <summary>
        /// Returns true if there is any element in the list or collections.
        /// It tries to cast to list first and then an array, this method will be performant if the callers of this extension method implement IEnumerable through lists.
        /// </summary>
        /// <typeparam name="T">The testing value type.</typeparam>
        /// <param name="enumerable">the testing enumerable.</param>
        /// <returns>ture/false.</returns>
        internal static bool HasAny<T>(this IEnumerable<T> enumerable) where T : class
        {
            IList<T> list = enumerable as IList<T>;
            if (list != null)
            {
                return list.Count > 0;
            }

            T[] array = enumerable as T[];
            if (array != null)
            {
                return array.Length > 0;
            }

            if (enumerable != null)
            {
                return enumerable.GetEnumerator().MoveNext();
            }

            return false;
        }

        /// <summary>
        /// Gets the declared alternate keys of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="model">The model to be used.</param>
        /// <returns>Alternate Keys of this type.</returns>
        private static IEnumerable<IDictionary<string, IEdmProperty>> GetDeclaredAlternateKeysForType(IEdmEntityType type, IEdmModel model)
        {
            IEdmVocabularyAnnotation annotationValue = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(type, AlternateKeysVocabularyModel.AlternateKeysTerm).FirstOrDefault();

            if (annotationValue != null)
            {
                List<IDictionary<string, IEdmProperty>> declaredAlternateKeys = new List<IDictionary<string, IEdmProperty>>();

                IEdmCollectionExpression keys = annotationValue.Value as IEdmCollectionExpression;
                Debug.Assert(keys != null, "expected IEdmCollectionExpression for alternate key annotation value");

                foreach (IEdmRecordExpression key in keys.Elements.OfType<IEdmRecordExpression>())
                {
                    var edmPropertyConstructor = key.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.AlternateKeyTypeKeyPropertyName);
                    if (edmPropertyConstructor != null)
                    {
                        IEdmCollectionExpression collectionExpression = edmPropertyConstructor.Value as IEdmCollectionExpression;
                        Debug.Assert(collectionExpression != null, "expected IEdmCollectionExpression type for Key Property");

                        IDictionary<string, IEdmProperty> alternateKey = new Dictionary<string, IEdmProperty>();
                        foreach (IEdmRecordExpression propertyRef in collectionExpression.Elements.OfType<IEdmRecordExpression>())
                        {
                            var aliasProp = propertyRef.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.PropertyRefTypeAliasPropertyName);
                            Debug.Assert(aliasProp != null, "expected non null Alias Property");
                            string alias = ((IEdmStringConstantExpression)aliasProp.Value).Value;

                            var nameProp = propertyRef.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.PropertyRefTypeNamePropertyName);
                            Debug.Assert(nameProp != null, "expected non null Name Property");
                            string propertyName = ((IEdmPathExpression)nameProp.Value).PathSegments.FirstOrDefault();

                            alternateKey[alias] = type.FindProperty(propertyName);
                        }

                        if (alternateKey.Any())
                        {
                            declaredAlternateKeys.Add(alternateKey);
                        }
                    }
                }

                return declaredAlternateKeys;
            }

            return null;
        }

        private static T FindAcrossModels<T, TInput>(this IEdmModel model, TInput qualifiedName, Func<IEdmModel, TInput, T> finder, Func<T, T, T> ambiguousCreator)
        {
            T candidate = finder(model, qualifiedName);

            foreach (IEdmModel reference in model.ReferencedModels)
            {
                T fromReference = finder(reference, qualifiedName);
                if (fromReference != null)
                {
                    candidate = candidate == null ? fromReference : ambiguousCreator(candidate, fromReference);
                }
            }

            return candidate;
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmEntityType contextType, IEdmTerm term, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(contextType, term, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnType(contextType.ToTraceString(), term.ToTraceString()));
            }

            return evaluator(annotations.Single().Value, context, term.Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmEntityType contextType, string termName, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(contextType, termName, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnType(contextType.ToTraceString(), termName));
            }

            IEdmVocabularyAnnotation valueAnnotation = annotations.Single();
            return evaluator(valueAnnotation.Value, context, valueAnnotation.Term().Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(element, term, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnElement(term.ToTraceString()));
            }

            return evaluator(annotations.Single().Value, null, term.Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(element, termName, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnElement(termName));
            }

            IEdmVocabularyAnnotation valueAnnotation = annotations.Single();
            return evaluator(valueAnnotation.Value, null, valueAnnotation.Term().Type);
        }

        /// <summary>
        /// Search entity set or singleton or operation import in container and its extended containers.
        /// </summary>
        /// <typeparam name="T">The IEdmEntityContainerElement derived type.</typeparam>
        /// <param name="container">The IEdmEntityContainer object, can be CsdlSemanticsEntityContainer.</param>
        /// <param name="simpleName">A simple (not fully qualified) entity set name, singleton name, operation import name or path.</param>
        /// <param name="finderFunc">The func to do the search within container.</param>
        /// <param name="depth">The recursive depth of .Extends containers to search.</param>
        /// <returns>The found entity set or singleton or operation import.</returns>
        private static T FindInContainerAndExtendsRecursively<T>(IEdmEntityContainer container, string simpleName, Func<IEdmEntityContainer, string, T> finderFunc, int depth)
        {
            Debug.Assert(finderFunc != null, "finderFunc!=null");
            EdmUtil.CheckArgumentNull(container, "container");
            if (depth <= 0)
            {
                // TODO: p2 add a new string resource for the error message
                throw new InvalidOperationException(Edm.Strings.Bad_CyclicEntityContainer(container.FullName()));
            }

            T ret = finderFunc(container, simpleName);
            IEnumerable<IEdmOperationImport> operations = ret as IEnumerable<IEdmOperationImport>;
            if (ret == null || operations != null && !operations.HasAny())
            {
                // for CsdlSemanticsEntityContainer, try searching .Extends container :
                // (after IEdmModel has public Extends property, don't need to check CsdlSemanticsEntityContainer)
                CsdlSemanticsEntityContainer tmp = container as CsdlSemanticsEntityContainer;
                if (tmp?.Extends != null)
                {
                    return FindInContainerAndExtendsRecursively(tmp.Extends, simpleName, finderFunc, --depth);
                }
            }

            return ret;
        }

        private static T AnnotationValue<T>(object annotation) where T : class
        {
            if (annotation != null)
            {
                T specificAnnotation = annotation as T;
                if (specificAnnotation != null)
                {
                    return specificAnnotation;
                }

                IEdmValue valueAnnotation = annotation as IEdmValue;
                if (valueAnnotation != null)
                {
                    // [EdmLib] AnnotationValue extension method should use the Clr converter to map annotation value to T.
                }

                throw new InvalidOperationException(Edm.Strings.Annotations_TypeMismatch(annotation.GetType().Name, typeof(T).Name));
            }

            return null;
        }

        private static void DerivedFrom(this IEdmModel model, IEdmStructuredType baseType, HashSetInternal<IEdmStructuredType> visited, List<IEdmStructuredType> derivedTypes)
        {
            if (visited.Add(baseType))
            {
                IEnumerable<IEdmStructuredType> candidates = model.FindDirectlyDerivedTypes(baseType);
                if (candidates != null && candidates.HasAny())
                {
                    foreach (IEdmStructuredType derivedType in candidates)
                    {
                        derivedTypes.Add(derivedType);
                        model.DerivedFrom(derivedType, visited, derivedTypes);
                    }
                }

                foreach (IEdmModel referenced in model.ReferencedModels)
                {
                    candidates = referenced.FindDirectlyDerivedTypes(baseType);
                    if (candidates != null && candidates.HasAny())
                    {
                        foreach (IEdmStructuredType derivedType in candidates)
                        {
                            derivedTypes.Add(derivedType);
                            model.DerivedFrom(derivedType, visited, derivedTypes);
                        }
                    }
                }
            }
        }

        private static void SetChangeTrackingAnnotationImplementation(this EdmModel model, IEdmVocabularyAnnotatable target, bool isSupported, IEnumerable<IEdmStructuralProperty> filterableProperties, IEnumerable<IEdmNavigationProperty> expandableProperties)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            if (filterableProperties == null)
            {
                filterableProperties = EmptyStructuralProperties;
            }

            if (expandableProperties == null)
            {
                expandableProperties = EmptyNavigationProperties;
            }

            IList<IEdmPropertyConstructor> properties = new List<IEdmPropertyConstructor>
            {
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingSupported, new EdmBooleanConstant(isSupported)),
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingFilterableProperties, new EdmCollectionExpression(filterableProperties.Select(p => new EdmPropertyPathExpression(p.Name)).ToArray())),
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingExpandableProperties, new EdmCollectionExpression(expandableProperties.Select(p => new EdmNavigationPropertyPathExpression(p.Name)).ToArray()))
            };

            IEdmRecordExpression record = new EdmRecordExpression(properties);
            IEdmTerm term = CapabilitiesVocabularyModel.ChangeTrackingTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, term, record);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        private static IEdmTypeDefinitionReference GetUIntImplementation(this EdmModel model, string namespaceName, string name, string underlyingType, bool isNullable)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(namespaceName, "namespaceName");

            Debug.Assert(!string.IsNullOrEmpty(name), "name must be provided");

            string qualifiedName = String.Format(CultureInfo.InvariantCulture, "{0}.{1}", namespaceName, name);

            // If the user has already defined his own UInt TypeDefinition, we don't define ours anymore.
            var type = model.FindDeclaredType(qualifiedName) as IEdmTypeDefinition;
            if (type == null)
            {
                type = new EdmTypeDefinition(namespaceName, name, EdmCoreModel.Instance.GetPrimitiveTypeKind(underlyingType));

                model.AddElement(type);

                model.SetPrimitiveValueConverter(type, DefaultPrimitiveValueConverter.Instance);
            }

            var typeReference = new EdmTypeDefinitionReference(type, isNullable);

            return typeReference;
        }

        internal static class TypeName<T>
        {
            // Use the name of the type as its local name for annotations.
            // Filter out special characters to produce a valid name:
            // '.'                      Appears in qualified names.
            // '`', '[', ']', ','       Appear in generic instantiations.
            // '+'                      Appears in names of local classes.
            public static readonly string LocalName = typeof(T).ToString().Replace("_", "_____").Replace('.', '_').Replace("[", "").Replace("]", "").Replace(",", "__").Replace("`", "___").Replace("+", "____");
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;

using Microsoft.OData.Edm.Csdl;
using Microsoft.OData.Edm.Csdl.CsdlSemantics;
using Microsoft.OData.Edm.Csdl.Parsing.Ast;
using Microsoft.OData.Edm.Csdl.Serialization;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.Edm.Vocabularies.Community.V1;
using Microsoft.OData.Edm.Vocabularies.V1;

namespace Microsoft.OData.Edm
{
    /// <summary>
    /// Contains extension methods for <see cref="IEdmModel"/> interfaces.
    /// </summary>
    public static class ExtensionMethods
    {
        private const int ContainerExtendsMaxDepth = 100;
        private const string CollectionTypeFormat = EdmConstants.Type_Collection + "({0})";

        private static readonly IEnumerable<IEdmStructuralProperty> EmptyStructuralProperties = Enumerable.Empty<IEdmStructuralProperty>();
        private static readonly IEnumerable<IEdmNavigationProperty> EmptyNavigationProperties = Enumerable.Empty<IEdmNavigationProperty>();

        #region IEdmModel

        private static readonly Func<IEdmModel, string, IEdmSchemaType> findType = (model, qualifiedName) => model.FindDeclaredType(qualifiedName);
        private static readonly Func<IEdmModel, IEdmType, IEnumerable<IEdmOperation>> findBoundOperations = (model, bindingType) => model.FindDeclaredBoundOperations(bindingType);
        private static readonly Func<IEdmModel, string, IEdmTerm> findTerm = (model, qualifiedName) => model.FindDeclaredTerm(qualifiedName);
        private static readonly Func<IEdmModel, string, IEnumerable<IEdmOperation>> findOperations = (model, qualifiedName) => model.FindDeclaredOperations(qualifiedName);
        private static readonly Func<IEdmModel, string, IEdmEntityContainer> findEntityContainer = (model, qualifiedName) => { return model.ExistsContainer(qualifiedName) ? model.EntityContainer : null; };
        private static readonly Func<IEnumerable<IEdmOperation>, IEnumerable<IEdmOperation>, IEnumerable<IEdmOperation>> mergeFunctions = (f1, f2) => Enumerable.Concat(f1, f2);

        /// <summary>
        /// Gets the value for the EDM version of the <paramref name="model"/>.
        /// </summary>
        /// <param name="model">Model the version has been set for.</param>
        /// <returns>The version.</returns>
        public static Version GetEdmVersion(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            return model.GetAnnotationValue<Version>(model, EdmConstants.InternalUri, EdmConstants.EdmVersionAnnotation);
        }

        /// <summary>
        /// Sets a value of EDM version attribute of the <paramref name="model"/>.
        /// </summary>
        /// <param name="model">The model the version should be set for.</param>
        /// <param name="version">The version.</param>
        public static void SetEdmVersion(this IEdmModel model, Version version)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            model.SetAnnotationValue(model, EdmConstants.InternalUri, EdmConstants.EdmVersionAnnotation, version);
        }

        #region IEdmModel interface's FindDeclaredXxx() methods, here their counterpart methods become FindXxx().
        /// <summary>
        /// Searches for a type with the given name in this model and all referenced models and returns null if no such type exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The namespace or alias qualified name of the type being found.</param>
        /// <returns>The requested type, or null if no such type exists.</returns>
        public static IEdmSchemaType FindType(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            string fullyQualifiedName = model.ReplaceAlias(qualifiedName);

            return FindAcrossModels(model, fullyQualifiedName, findType, RegistrationHelper.CreateAmbiguousTypeBinding);  // search built-in EdmCoreModel and CoreVocabularyModel.
        }

        /// <summary>
        /// Searches for bound operations based on the binding type, returns an empty enumerable if no operation exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>A set of operations that share the binding type or empty enumerable if no such operation exists.</returns>
        public static IEnumerable<IEdmOperation> FindBoundOperations(this IEdmModel model, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");
            return FindAcrossModels(model, bindingType, findBoundOperations, mergeFunctions);  // search built-in EdmCoreModel and CoreVocabularyModel.
        }

        /// <summary>
        /// Searches for bound operations based on the qualified name and binding type, returns an empty enumerable if no operation exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>A set of operations that share the qualified name and binding type or empty enumerable if no such operation exists.</returns>
        public static IEnumerable<IEdmOperation> FindBoundOperations(this IEdmModel model, string qualifiedName, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");

            string fullyQualifiedName = model.ReplaceAlias(qualifiedName);

            // the below is a copy of FindAcrossModels method but Func<IEdmModel, TInput, T> finder is replaced by FindDeclaredBoundOperations.
            IEnumerable<IEdmOperation> candidate = model.FindDeclaredBoundOperations(fullyQualifiedName, bindingType);

            foreach (IEdmModel reference in model.ReferencedModels)
            {
                IEnumerable<IEdmOperation> fromReference = reference.FindDeclaredBoundOperations(fullyQualifiedName, bindingType);
                if (fromReference != null)
                {
                    candidate = candidate == null ? fromReference : mergeFunctions(candidate, fromReference);
                }
            }

            return candidate;
        }

        /// <summary>
        /// Searches for a term with the given name in this model and all referenced models and returns null if no such term exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the term being found.</param>
        /// <returns>The requested term, or null if no such term exists.</returns>
        public static IEdmTerm FindTerm(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findTerm, RegistrationHelper.CreateAmbiguousTermBinding);
        }

        /// <summary>
        /// Searches for operations with the given name in this model and all referenced models and returns an empty enumerable if no such operations exist.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operations being found.</param>
        /// <returns>The requested operations.</returns>
        public static IEnumerable<IEdmOperation> FindOperations(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findOperations, mergeFunctions);
        }
        #endregion

        /// <summary>
        /// If the container name in the model is the same as the input name. The input name maybe full qualified name.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="containerName">Input container name to be searched. The container name may be full qualified with namespace prefix.</param>
        /// <returns>True if the model has a container called input name, otherwise false.</returns>
        public static bool ExistsContainer(this IEdmModel model, string containerName)
        {
            if (model.EntityContainer == null)
            {
                return false;
            }

            string fullQualifiedName = (model.EntityContainer.Namespace ?? String.Empty) + "." + (containerName ?? String.Empty);

            if (string.Equals(model.EntityContainer.FullName(), fullQualifiedName, StringComparison.Ordinal)
                || string.Equals(model.EntityContainer.FullName(), containerName, StringComparison.Ordinal))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Searches for an entity container with the given name in this model and all referenced models and returns null if no such entity container exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the entity container being found.</param>
        /// <returns>The requested entity container, or null if no such entity container exists.</returns>
        public static IEdmEntityContainer FindEntityContainer(this IEdmModel model, string qualifiedName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");

            return FindAcrossModels(model, qualifiedName, findEntityContainer, RegistrationHelper.CreateAmbiguousEntityContainerBinding);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations defined in a specific model and models referenced by that model.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <returns>Annotations attached to the element (or, if the element is a type, to its base types) by this model or by models referenced by this model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> FindVocabularyAnnotationsIncludingInheritedAnnotations(this IEdmModel model, IEdmVocabularyAnnotatable element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            IEnumerable<IEdmVocabularyAnnotation> result = model.FindDeclaredVocabularyAnnotations(element);

            if (element is IEdmStructuredType typeElement)
            {
                typeElement = typeElement.BaseType;
                while (element is IEdmStructuredType typeElement)
                {
                    if (typeElement is IEdmVocabularyAnnotatable annotatableElement)
                    {
                        result = result.Concat(model.FindDeclaredVocabularyAnnotations(annotatableElement));
                    }

                    typeElement = typeElement.BaseType;
                }
            }

            return result;
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations defined in a specific model and models referenced by that model.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> FindVocabularyAnnotations(this IEdmModel model, IEdmVocabularyAnnotatable element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            IEnumerable<IEdmVocabularyAnnotation> result = model.FindVocabularyAnnotationsIncludingInheritedAnnotations(element);
            foreach (IEdmModel referencedModel in model.ReferencedModels)
            {
                result = result.Concat(referencedModel.FindVocabularyAnnotationsIncludingInheritedAnnotations(element));
            }

            return result;
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="term">Term to search for.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");

            return FindVocabularyAnnotations<T>(model, element, term, null);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="term">Term to search for.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term with the given qualifier.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");

            List<T> result = null;

            foreach (T annotation in model.FindVocabularyAnnotations(element).OfType<T>())
            {
                if (annotation.Term == term && (qualifier == null || qualifier == annotation.Qualifier))
                {
                    if (result == null)
                    {
                        result = new List<T>();
                    }

                    result.Add(annotation);
                }
            }

            return result ?? Enumerable.Empty<T>();
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="termName">Name of the term to search for.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");

            return FindVocabularyAnnotations<T>(model, element, termName, null);
        }

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations that bind a particular term.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">Model to search.</param>
        /// <param name="element">Element to check for annotations.</param>
        /// <param name="termName">Name of the term to search for.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <returns>Annotations attached to the element by this model or by models referenced by this model that bind the term with the given qualifier.</returns>
        public static IEnumerable<T> FindVocabularyAnnotations<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier) where T : IEdmVocabularyAnnotation
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");

            // Look up annotations on the element by name. There's no particular advantage in searching for a term first.
            string name;
            string namespaceName;

            if (EdmUtil.TryGetNamespaceNameFromQualifiedName(termName, out namespaceName, out name))
            {
                foreach (T annotation in model.FindVocabularyAnnotations(element).OfType<T>())
                {
                    IEdmTerm annotationTerm = annotation.Term;
                    if (annotationTerm.Namespace == namespaceName && annotationTerm.Name == name && (qualifier == null || qualifier == annotation.Qualifier))
                    {
                        yield return annotation;
                    }
                }
            }
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, string termName, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), termName, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, string termName, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), termName, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), term, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "expressionEvaluator");

            return GetTermValue<IEdmValue>(model, context, context.Type.AsEntity().EntityDefinition(), term, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, string termName, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), termName, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, string termName, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), termName, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), term, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to the type of a value.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="context">Value to use as context in evaluation.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmTerm term, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(context, "context");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, context, context.Type.AsEntity().EntityDefinition(), term, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, termName, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, termName, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, term, null, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the <see cref="IEdmValue "/> of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="expressionEvaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static IEdmValue GetTermValue(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, EdmExpressionEvaluator expressionEvaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(expressionEvaluator, "evaluator");

            return GetTermValue<IEdmValue>(model, element, term, qualifier, expressionEvaluator.Evaluate);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, termName, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="termName">Name of the term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(termName, "termName");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, termName, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, term, null, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets the CLR value of a vocabulary term that has been applied to an element.
        /// </summary>
        /// <typeparam name="T">The CLR type of the value to be returned.</typeparam>
        /// <param name="model">Model to search for term annotations.</param>
        /// <param name="element">Annotated element.</param>
        /// <param name="term">Term to evaluate.</param>
        /// <param name="qualifier">Qualifier to apply.</param>
        /// <param name="evaluator">Evaluator to use to perform expression evaluation.</param>
        /// <returns>Value of the term evaluated against the supplied value.</returns>
        public static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, EdmToClrEvaluator evaluator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(term, "term");
            EdmUtil.CheckArgumentNull(evaluator, "evaluator");

            return GetTermValue<T>(model, element, term, qualifier, evaluator.EvaluateToClrValue<T>);
        }

        /// <summary>
        /// Gets an annotation value corresponding to the given namespace and name provided.
        /// </summary>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace of the annotation.</param>
        /// <param name="localName">Name of the annotation inside the namespace.</param>
        /// <returns>The requested annotation value, if it exists. Otherwise, null.</returns>
        public static object GetAnnotationValue(this IEdmModel model, IEdmElement element, string namespaceName, string localName)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.DirectValueAnnotationsManager.GetAnnotationValue(element, namespaceName, localName);
        }

        /// <summary>
        /// Gets an annotation value corresponding to the given namespace and name provided.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace of the annotation.</param>
        /// <param name="localName">Name of the annotation inside the namespace.</param>
        /// <returns>The requested annotation value, if it exists. Otherwise, null.</returns>
        public static T GetAnnotationValue<T>(this IEdmModel model, IEdmElement element, string namespaceName, string localName) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return AnnotationValue<T>(model.GetAnnotationValue(element, namespaceName, localName));
        }

        /// <summary>
        /// Gets an annotation value from an annotatable element.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being returned.</typeparam>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <returns>The requested annotation, if it exists. Otherwise, null.</returns>
        /// <remarks>
        /// Strongly-typed wrappers for unnamed annotations keyed by CLR type.
        /// </remarks>
        public static T GetAnnotationValue<T>(this IEdmModel model, IEdmElement element) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.GetAnnotationValue<T>(element, EdmConstants.InternalUri, TypeName<T>.LocalName);
        }

        /// <summary>
        /// Sets an annotation value for an EDM element. If the value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Name of the annotation within the namespace.</param>
        /// <param name="value">Value of the new annotation.</param>
        public static void SetAnnotationValue(this IEdmModel model, IEdmElement element, string namespaceName, string localName, object value)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            model.DirectValueAnnotationsManager.SetAnnotationValue(element, namespaceName, localName, value);
        }

        /// <summary>
        /// Gets description for term Org.OData.Core.V1.Description from a target annotatable
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to find annotation</param>
        /// <returns>Description for term Org.OData.Core.V1.Description</returns>
        public static string GetDescriptionAnnotation(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, CoreVocabularyModel.DescriptionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value is IEdmStringConstantExpression stringConstant)
                {
                    return stringConstant.Value;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets description for term Org.OData.Core.V1.LongDescription from a target annotatable
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to find annotation</param>
        /// <returns>Description for term Org.OData.Core.V1.LongDescription</returns>
        public static string GetLongDescriptionAnnotation(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, CoreVocabularyModel.LongDescriptionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value is IEdmStringConstantExpression stringConstant)
                {
                    return stringConstant.Value;
                }
            }

            return null;
        }

        /// <summary>
        /// Gets the collection of qualified type name for term Org.OData.Validation.V1.DerivedTypeConstraint from a navigation source.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>Null or a collection string of qualified type name.</returns>
        public static IEnumerable<string> GetDerivedTypeConstraints(this IEdmModel model, IEdmNavigationSource navigationSource)
        {
            if (model == null || navigationSource == null)
            {
                return null;
            }

            IEnumerable<string> derivedTypeConstraints = null;
            switch (navigationSource.NavigationSourceKind())
            {
                case EdmNavigationSourceKind.EntitySet:
                    derivedTypeConstraints = model.GetDerivedTypeConstraints((IEdmVocabularyAnnotatable)(IEdmEntitySet)navigationSource);
                    break;
                case EdmNavigationSourceKind.Singleton:
                    derivedTypeConstraints = model.GetDerivedTypeConstraints((IEdmVocabularyAnnotatable)(IEdmSingleton)navigationSource);
                    break;
            }

            return derivedTypeConstraints;
        }

        /// <summary>
        /// Gets the collection of qualified type name for term Org.OData.Validation.V1.DerivedTypeConstraint from a target annotatable.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target annotatable to find annotation.</param>
        /// <returns>Null or a collection string of qualified type name.</returns>
        public static IEnumerable<string> GetDerivedTypeConstraints(this IEdmModel model, IEdmVocabularyAnnotatable target)
        {
            if (model == null || target == null)
            {
                return null;
            }

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(target, ValidationVocabularyModel.DerivedTypeConstraintTerm).FirstOrDefault();
            if (annotation != null)
            {
                IEdmCollectionExpression collectionExpression = annotation.Value as IEdmCollectionExpression;
                if (collectionExpression?.Elements != null)
                {
                    return collectionExpression.Elements.OfType<IEdmStringConstantExpression>().Select(e => e.Value);
                }
            }

            return null;
        }

        /// <summary>
        /// Gets all schema elements from the model, and models referenced by it.
        /// </summary>
        /// <param name="model">Model to search for elements</param>
        /// <returns>Schema elements from the model, and models referenced by it.</returns>
        public static IEnumerable<IEdmSchemaElement> SchemaElementsAcrossModels(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");

            IEnumerable<IEdmSchemaElement> result = Enumerable.Empty<IEdmSchemaElement>();
            foreach (IEdmModel referencedModel in model.ReferencedModels)
            {
                result = result.Concat(referencedModel.SchemaElements);
            }

            result = result.Concat(model.SchemaElements);
            return result;
        }

        /// <summary>
        /// Finds a list of types that derive from the supplied type directly or indirectly, and across models.
        /// </summary>
        /// <param name="model">The model types are being found on.</param>
        /// <param name="baseType">The base type that derived types are being searched for.</param>
        /// <returns>A list of types that derive from the type.</returns>
        public static IEnumerable<IEdmStructuredType> FindAllDerivedTypes(this IEdmModel model, IEdmStructuredType baseType)
        {
            List<IEdmStructuredType> result = new List<IEdmStructuredType>();
            if (baseType is IEdmSchemaElement)
            {
                model.DerivedFrom(baseType, new HashSetInternal<IEdmStructuredType>(), result);
            }

            return result;
        }

        /// <summary>
        /// Sets an annotation value on an annotatable element.
        /// </summary>
        /// <typeparam name="T">Type of the annotation being set.</typeparam>
        ///  <param name="model">The model containing the annotation.</param>
        /// <param name="element">The annotated element.</param>
        /// <param name="value">Value of the new annotation.</param>
        public static void SetAnnotationValue<T>(this IEdmModel model, IEdmElement element, T value) where T : class
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            model.SetAnnotationValue(element, EdmConstants.InternalUri, TypeName<T>.LocalName, value);
        }

        /// <summary>
        /// Retrieves a set of annotation values. For each requested value, returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="model">The model in which to find the annotations.</param>
        /// <param name="annotations">The set of requested annotations.</param>
        /// <returns>Returns values that correspond to the provided annotations. A value is null if no annotation with the given name exists for the given element.</returns>
        public static object[] GetAnnotationValues(this IEdmModel model, IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(annotations, "annotations");

            return model.DirectValueAnnotationsManager.GetAnnotationValues(annotations);
        }

        /// <summary>
        /// Sets a set of annotation values. If a supplied value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="model">The model in which to set the annotations.</param>
        /// <param name="annotations">The annotations to set.</param>
        public static void SetAnnotationValues(this IEdmModel model, IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(annotations, "annotations");

            model.DirectValueAnnotationsManager.SetAnnotationValues(annotations);
        }

        /// <summary>
        /// Gets the direct annotations for an element.
        /// </summary>
        /// <param name="model">The model containing the annotations.</param>
        /// <param name="element">The annotated element.</param>
        /// <returns>The immediate annotations of the element.</returns>
        public static IEnumerable<IEdmDirectValueAnnotation> DirectValueAnnotations(this IEdmModel model, IEdmElement element)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(element, "element");

            return model.DirectValueAnnotationsManager.GetDirectValueAnnotations(element);
        }

        /// <summary>
        /// Finds the entity set with qualified entity set name (not simple entity set name).
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedEntitySetName">Name of the container qualified element, can be an OperationImport or an EntitySet.</param>
        /// <param name="entitySet">The Entity Set that was found.</param>
        /// <returns>True if an entityset was found from the qualified container name, false if none were found.</returns>
        public static bool TryFindContainerQualifiedEntitySet(this IEdmModel model, string containerQualifiedEntitySetName, out IEdmEntitySet entitySet)
        {
            entitySet = null;
            string containerName = null;
            string simpleEntitySetName = null;

            if (containerQualifiedEntitySetName != null &&
                containerQualifiedEntitySetName.IndexOf(".", StringComparison.Ordinal) > -1 &&
                EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedEntitySetName, out containerName, out simpleEntitySetName))
            {
                if (model.ExistsContainer(containerName))
                {
                    IEdmEntityContainer container = model.EntityContainer;
                    if (container != null)
                    {
                        entitySet = container.FindEntitySetExtended(simpleEntitySetName);
                    }
                }
            }

            return (entitySet != null);
        }

        /// <summary>
        /// Finds the singleton.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedSingletonName">Name of the container qualified singleton element.</param>
        /// <param name="singleton">The singleton that was found.</param>
        /// <returns>True if an singleton was found from the qualified container name, false if none were found.</returns>
        public static bool TryFindContainerQualifiedSingleton(this IEdmModel model, string containerQualifiedSingletonName, out IEdmSingleton singleton)
        {
            singleton = null;
            string containerName = null;
            string simpleSingletonName = null;

            if (containerQualifiedSingletonName != null &&
                containerQualifiedSingletonName.IndexOf(".", StringComparison.Ordinal) > -1 &&
                EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedSingletonName, out containerName, out simpleSingletonName))
            {
                if (model.ExistsContainer(containerName))
                {
                    singleton = model.EntityContainer.FindSingletonExtended(simpleSingletonName);

                    if (singleton != null)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Tries the find container qualified operation imports.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="containerQualifiedOperationImportName">Name of the container qualified operation import.</param>
        /// <param name="operationImports">The operation imports.</param>
        /// <returns>True if OperationImports are found, false if none were found.</returns>
        public static bool TryFindContainerQualifiedOperationImports(this IEdmModel model, string containerQualifiedOperationImportName, out IEnumerable<IEdmOperationImport> operationImports)
        {
            operationImports = null;
            string containerName = null;
            string simpleOperationName = null;

            if (containerQualifiedOperationImportName.IndexOf(".", StringComparison.Ordinal) > -1 && EdmUtil.TryParseContainerQualifiedElementName(containerQualifiedOperationImportName, out containerName, out simpleOperationName))
            {
                if (model.ExistsContainer(containerName))
                {
                    operationImports = model.EntityContainer.FindOperationImportsExtended(simpleOperationName);

                    if (operationImports != null && operationImports.Any())
                    {
                        return true;
                    }
                }
            }

            return false;
        }


        /// <summary>
        /// Searches for entity set by the given name that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        public static IEdmEntitySet FindDeclaredEntitySet(this IEdmModel model, string qualifiedName)
        {
            IEdmEntitySet foundEntitySet;
            if (!model.TryFindContainerQualifiedEntitySet(qualifiedName, out foundEntitySet))
            {
                // try searching by entity set name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindEntitySetExtended(qualifiedName);
                }
            }

            return foundEntitySet;
        }

        /// <summary>
        /// Searches for singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The singleton found or empty if none found.</returns>
        public static IEdmSingleton FindDeclaredSingleton(this IEdmModel model, string qualifiedName)
        {
            IEdmSingleton foundSingleton;
            if (!model.TryFindContainerQualifiedSingleton(qualifiedName, out foundSingleton))
            {
                // try searching by singleton name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindSingletonExtended(qualifiedName);
                }
            }

            return foundSingleton;
        }

        /// <summary>
        /// Searches for entity set or singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set or singleton found or empty if none found.</returns>
        public static IEdmNavigationSource FindDeclaredNavigationSource(this IEdmModel model, string qualifiedName)
        {
            IEdmEntitySet entitySet = model.FindDeclaredEntitySet(qualifiedName);
            if (entitySet != null)
            {
                return entitySet;
            }

            return model.FindDeclaredSingleton(qualifiedName);
        }


        /// <summary>
        /// Searches for the operation imports by the specified name in default container and .Extends containers, returns an empty enumerable if no operation import exists.
        /// </summary>
        /// <param name="model">The model to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation import which may or may not include the container name.</param>
        /// <returns>All operation imports that can be found by the specified name, returns an empty enumerable if no operation import exists.</returns>
        public static IEnumerable<IEdmOperationImport> FindDeclaredOperationImports(this IEdmModel model, string qualifiedName)
        {
            IEnumerable<IEdmOperationImport> foundOperationImports;
            if (!model.TryFindContainerQualifiedOperationImports(qualifiedName, out foundOperationImports))
            {
                // try searching by operation import name in container and extended containers:
                IEdmEntityContainer container = model.EntityContainer;
                if (container != null)
                {
                    return container.FindOperationImportsExtended(qualifiedName);
                }
            }

            return foundOperationImports ?? Enumerable.Empty<IEdmOperationImport>();
        }

        /// <summary>
        /// Get the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="type">The reference to a type definition.</param>
        /// <returns>The primitive value converter for the type definition.</returns>
        public static IPrimitiveValueConverter GetPrimitiveValueConverter(this IEdmModel model, IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(model, "mode");

            // If type definition is not provided, we pass through the primitive value directly.
            if (type == null || !type.IsTypeDefinition())
            {
                return PassThroughPrimitiveValueConverter.Instance;
            }

            return model.GetPrimitiveValueConverter(type.Definition);
        }

        /// <summary>
        /// Set the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The reference to a type definition.</param>
        /// <param name="converter">The primitive value converter for the type definition.</param>
        public static void SetPrimitiveValueConverter(this IEdmModel model, IEdmTypeDefinitionReference typeDefinition, IPrimitiveValueConverter converter)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(typeDefinition, "typeDefinition");
            EdmUtil.CheckArgumentNull(converter, "converter");

            model.SetPrimitiveValueConverter(typeDefinition.Definition, converter);
        }

        #endregion

        #region EdmModel

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name)
        {
            return model.AddComplexType(namespaceName, name, null, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType)
        {
            return model.AddComplexType(namespaceName, name, baseType, false, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <param name="isAbstract">Denotes whether this complex type is abstract.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType, bool isAbstract)
        {
            return model.AddComplexType(namespaceName, name, baseType, isAbstract, false);
        }

        /// <summary>
        /// Creates and adds a complex type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The namespace this type belongs to.</param>
        /// <param name="name">The name of this type within its namespace.</param>
        /// <param name="baseType">The base type of this complex type.</param>
        /// <param name="isAbstract">Denotes whether this complex type is abstract.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <returns>The complex type created.</returns>
        public static EdmComplexType AddComplexType(this EdmModel model, string namespaceName, string name, IEdmComplexType baseType, bool isAbstract, bool isOpen)
        {
            var type = new EdmComplexType(namespaceName, name, baseType, isAbstract, isOpen);
            model.AddElement(type);
            return type;
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name)
        {
            return model.AddEntityType(namespaceName, name, null, false, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType)
        {
            return model.AddEntityType(namespaceName, name, baseType, false, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <param name="isAbstract">Denotes an entity that cannot be instantiated.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType, bool isAbstract, bool isOpen)
        {
            return model.AddEntityType(namespaceName, name, baseType, isAbstract, isOpen, false);
        }

        /// <summary>
        /// Creates and adds an entity type to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace the entity belongs to.</param>
        /// <param name="name">Name of the entity.</param>
        /// <param name="baseType">The base type of this entity type.</param>
        /// <param name="isAbstract">Denotes an entity that cannot be instantiated.</param>
        /// <param name="isOpen">Denotes if the type is open.</param>
        /// <param name="hasStream">Denotes if the type is a media type.</param>
        /// <returns>The entity type created.</returns>
        public static EdmEntityType AddEntityType(this EdmModel model, string namespaceName, string name, IEdmEntityType baseType, bool isAbstract, bool isOpen, bool hasStream)
        {
            var type = new EdmEntityType(namespaceName, name, baseType, isAbstract, isOpen, hasStream);
            model.AddElement(type);
            return type;
        }

        /// <summary>
        /// Creates and adds an entity container to the model.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">Namespace of the entity container.</param>
        /// <param name="name">Name of the entity container.</param>
        /// <returns>The entity container created.</returns>
        public static EdmEntityContainer AddEntityContainer(this EdmModel model, string namespaceName, string name)
        {
            var container = new EdmEntityContainer(namespaceName, name);
            model.AddElement(container);
            return container;
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a primitive type kind.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="kind">The primitive type kind of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, EdmPrimitiveTypeKind kind)
        {
            var term = new EdmTerm(namespaceName, name, kind);
            model.AddElement(term);
            return term;
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a type reference.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="type">The type of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, IEdmTypeReference type)
        {
            return model.AddTerm(namespaceName, name, type, null, null);
        }

        /// <summary>
        /// Creates and adds a new instance of the <see cref="EdmTerm"/> class from a type reference.
        /// </summary>
        /// <param name="model">The EdmModel.</param>
        /// <param name="namespaceName">The Namespace of the term.</param>
        /// <param name="name">The name of the newly created term</param>
        /// <param name="type">The type of the term.</param>
        /// <param name="appliesTo">The AppliesTo of the term.</param>
        /// <param name="defaultValue">The DefaultValue of the term.</param>
        /// <returns>The created term.</returns>
        public static EdmTerm AddTerm(this EdmModel model, string namespaceName, string name, IEdmTypeReference type, string appliesTo, string defaultValue)
        {
            var term = new EdmTerm(namespaceName, name, type, appliesTo, defaultValue);
            model.AddElement(term);
            return term;
        }

        /// <summary>
        /// Set annotation Org.OData.Core.V1.OptimisticConcurrency to EntitySet
        /// </summary>
        /// <param name="model">The model to add annotation</param>
        /// <param name="target">The target entitySet to set the inline annotation</param>
        /// <param name="properties">The PropertyPath for annotation</param>
        public static void SetOptimisticConcurrencyAnnotation(this EdmModel model, IEdmEntitySet target, IEnumerable<IEdmStructuralProperty> properties)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(properties, "properties");

            IEdmCollectionExpression collectionExpression = new EdmCollectionExpression(properties.Select(p => new EdmPropertyPathExpression(p.Name)).ToArray());
            IEdmTerm term = CoreVocabularyModel.ConcurrencyTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, term, collectionExpression);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Core.V1.Description to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to add annotation.</param>
        /// <param name="description">Description to be added.</param>
        public static void SetDescriptionAnnotation(this EdmModel model, IEdmVocabularyAnnotatable target, string description)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(description, "description");

            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, CoreVocabularyModel.DescriptionTerm, new EdmStringConstant(description));
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Core.V1.LongDescription to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target Annotatable to add annotation.</param>
        /// <param name="description">Description to be added.</param>
        public static void SetLongDescriptionAnnotation(this EdmModel model, IEdmVocabularyAnnotatable target, string description)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");
            EdmUtil.CheckArgumentNull(description, "description");

            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, CoreVocabularyModel.LongDescriptionTerm, new EdmStringConstant(description));
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Set Org.OData.Capabilities.V1.ChangeTracking to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target entity container to set the inline annotation.</param>
        /// <param name="isSupported">This entity set supports the odata.track-changes preference.</param>
        public static void SetChangeTrackingAnnotation(this EdmModel model, IEdmEntityContainer target, bool isSupported)
        {
            model.SetChangeTrackingAnnotationImplementation(target, isSupported, null, null);
        }

        /// <summary>
        /// Set Org.OData.Capabilities.V1.ChangeTracking to target.
        /// </summary>
        /// <param name="model">The model referenced to.</param>
        /// <param name="target">The target entity set to set the inline annotation.</param>
        /// <param name="isSupported">This entity set supports the odata.track-changes preference.</param>
        /// <param name="filterableProperties">Change tracking supports filters on these properties.</param>
        /// <param name="expandableProperties">Change tracking supports these properties expanded.</param>
        public static void SetChangeTrackingAnnotation(this EdmModel model, IEdmEntitySet target, bool isSupported, IEnumerable<IEdmStructuralProperty> filterableProperties, IEnumerable<IEdmNavigationProperty> expandableProperties)
        {
            model.SetChangeTrackingAnnotationImplementation(target, isSupported, filterableProperties, expandableProperties);
        }

        /// <summary>
        /// Get type reference to the default UInt16 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType"/>.
        /// If the user has already defined his own UInt16, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt16 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt16(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt16TypeName,
                PrimitiveValueConverterConstants.DefaultUInt16UnderlyingType,
                isNullable);
        }

        /// <summary>
        /// Get type reference to the default UInt32 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType"/>.
        /// If the user has already defined his own UInt32, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt32 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt32(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt32TypeName,
                PrimitiveValueConverterConstants.DefaultUInt32UnderlyingType,
                isNullable);
        }

        /// <summary>
        /// Get type reference to the default UInt64 type definition.
        /// The default underlying type is <see cref="PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType"/>.
        /// If the user has already defined his own UInt64, this method will not define anything and simply returns the type reference.
        /// </summary>
        /// <param name="model">The model involved</param>
        /// <param name="namespaceName">The name of the namespace where the type definition resides.</param>
        /// <param name="isNullable">Indicate if the type definition reference is nullable.</param>
        /// <returns>The nullable type reference to UInt64 type definition.</returns>
        public static IEdmTypeDefinitionReference GetUInt64(this EdmModel model, string namespaceName, bool isNullable)
        {
            return model.GetUIntImplementation(
                namespaceName,
                PrimitiveValueConverterConstants.UInt64TypeName,
                PrimitiveValueConverterConstants.DefaultUInt64UnderlyingType,
                isNullable);
        }

        #endregion

        #region IEdmElement

        /// <summary>
        /// Gets the location of this element.
        /// </summary>
        /// <param name="item">Reference to the calling object.</param>
        /// <returns>The location of the element.</returns>
        public static EdmLocation Location(this IEdmElement item)
        {
            EdmUtil.CheckArgumentNull(item, "item");
            IEdmLocatable locatable = item as IEdmLocatable;
            return locatable?.Location != null ? locatable.Location : new ObjectLocation(item);
        }

        #endregion

        #region IEdmVocabularyAnnotatable

        /// <summary>
        /// Gets an annotatable element's vocabulary annotations as seen from a particular model.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <param name="model">Model to check for annotations.</param>
        /// <returns>Annotations attached to the element by the model or by models referenced by the model.</returns>
        public static IEnumerable<IEdmVocabularyAnnotation> VocabularyAnnotations(this IEdmVocabularyAnnotatable element, IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            EdmUtil.CheckArgumentNull(model, "model");
            return model.FindVocabularyAnnotations(element);
        }

        #endregion

        #region IEdmSchemaElement

        /// <summary>
        /// Gets the full name of the element.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <returns>The full name of the element.</returns>
        public static string FullName(this IEdmSchemaElement element)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            if (element.Name == null)
            {
                return string.Empty;
            }

            if (element.Namespace == null)
            {
                return element.Name;
            }

            if (element is IEdmFullNamedElement fullNamedElement)
            {
                return fullNamedElement.FullName;
            }

            return element.Namespace + "." + element.Name;
        }

        /// <summary>
        /// Gets the Short Qualified name of the element.
        /// </summary>
        /// <param name="element">Reference to the calling object.</param>
        /// <returns>The short qualified name of the element.</returns>
        public static string ShortQualifiedName(this IEdmSchemaElement element)
        {
            EdmUtil.CheckArgumentNull(element, "element");
            if (element.Namespace != null && element.Namespace.Equals("Edm", StringComparison.Ordinal))
            {
                return (element.Name ?? String.Empty);
            }

            return FullName(element);
        }

        #endregion

        #region IEdmEntityContainer

        /// <summary>
        /// Returns entity sets belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Entity sets belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmEntitySet> EntitySets(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmEntitySet>();
        }

        /// <summary>
        /// Returns singletons belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Singletons belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmSingleton> Singletons(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmSingleton>();
        }

        /// <summary>
        /// Returns operation imports belonging to an IEdmEntityContainer.
        /// </summary>
        /// <param name="container">Reference to the calling object.</param>
        /// <returns>Operation imports belonging to an IEdmEntityContainer.</returns>
        public static IEnumerable<IEdmOperationImport> OperationImports(this IEdmEntityContainer container)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            return container.AllElements().OfType<IEdmOperationImport>();
        }

        #endregion

        #region IEdmTypeReference
        /// <summary>
        /// Gets the type kind of the type references definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The type kind of the reference.</returns>
        public static EdmTypeKind TypeKind(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmType typeDefinition = type.Definition;
            return typeDefinition != null ? typeDefinition.TypeKind : EdmTypeKind.None;
        }

        /// <summary>
        /// Gets the full name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The full name of this references definition.</returns>
        public static string FullName(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.Definition.FullTypeName();
        }

        /// <summary>
        /// Gets the short qualified name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The short qualified name of this references definition.</returns>
        public static string ShortQualifiedName(this IEdmTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.Definition is IEdmSchemaElement namedDefinition ? namedDefinition.ShortQualifiedName() : null;
        }
        #endregion

        #region IEdmType

        /// <summary>
        /// Gets the full name of the definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The full name of this references definition.</returns>
        public static string FullTypeName(this IEdmType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");

            if (type.TypeKind == EdmTypeKind.Primitive)
            {
                if (type is EdmCoreModelPrimitiveType primitiveType)
                {
                    return primitiveType.FullName;
                }
            }

            IEdmSchemaElement namedDefinition;
            if (type.TypeKind != EdmTypeKind.Collection)
            {
                namedDefinition = type as IEdmSchemaElement;
                return namedDefinition != null ? namedDefinition.FullName() : null;
            }
            else
            {
                // Handle collection case.
                namedDefinition = (type as IEdmCollectionType).ElementType.Definition as IEdmSchemaElement;
                return namedDefinition != null ? string.Format(CultureInfo.InvariantCulture, CollectionTypeFormat, namedDefinition.FullName()) : null;
            }
        }

        /// <summary>
        /// Gets the element type of a collection definition or itself of a non-collection definition referred to by the type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The element type of this references definition.</returns>
        public static IEdmType AsElementType(this IEdmType type)
        {   
            if(type == null)
            {
                return type;
            }

            return (type.TypeKind == EdmTypeKind.Collection) ? (type as IEdmCollectionType).ElementType.Definition : type;
        }

        #endregion

        #region IEdmPrimitiveTypeReference
        /// <summary>
        /// Gets the definition of this primitive type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Definition of this primitive type reference.</returns>
        public static IEdmPrimitiveType PrimitiveDefinition(this IEdmPrimitiveTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmPrimitiveType)type.Definition;
        }

        /// <summary>
        /// Gets the primitive kind of the definition referred to by this type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Primitive kind of the definition of this reference.</returns>
        public static EdmPrimitiveTypeKind PrimitiveKind(this IEdmPrimitiveTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmPrimitiveType primitive = type.PrimitiveDefinition();
            return primitive != null ? primitive.PrimitiveKind : EdmPrimitiveTypeKind.None;
        }
        #endregion

        #region IEdmStructuredTypeDefinition
        /// <summary>
        /// Gets all properties of the structured type definition and its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Properties of this type.</returns>
        public static IEnumerable<IEdmProperty> Properties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            if (type.BaseType != null)
            {
                foreach (IEdmProperty baseProperty in type.BaseType.Properties())
                {
                    yield return baseProperty;
                }
            }

            if (type.DeclaredProperties != null)
            {
                foreach (IEdmProperty declaredProperty in type.DeclaredProperties)
                {
                    yield return declaredProperty;
                }
            }
        }

        /// <summary>
        /// Gets all structural properties declared in the IEdmStructuredTypeDefinition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the IEdmStructuredTypeDefinition.</returns>
        public static IEnumerable<IEdmStructuralProperty> DeclaredStructuralProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            foreach (IEdmProperty property in type.DeclaredProperties)
            {
                if (property.PropertyKind == EdmPropertyKind.Structural)
                {
                    yield return property as IEdmStructuralProperty;
                }
            }
        }

        /// <summary>
        /// Gets the structural properties declared in this type definition and all base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The structural properties declared in this type definition and all base types.</returns>
        public static IEnumerable<IEdmStructuralProperty> StructuralProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            foreach(IEdmProperty property in type.Properties())
            {
                if(property.PropertyKind == EdmPropertyKind.Structural)
                {
                    yield return property as IEdmStructuralProperty;
                }
            }
        }
        #endregion

        #region IEdmStructuredTypeReference
        /// <summary>
        /// Gets the definition of this structured type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this structured type reference.</returns>
        public static IEdmStructuredType StructuredDefinition(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmStructuredType)type.Definition;
        }

        /// <summary>
        /// Returns true if the definition of this reference is abstract.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is abstract.</returns>
        public static bool IsAbstract(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().IsAbstract;
        }

        /// <summary>
        /// Returns true if the definition of this reference is open.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is open.</returns>
        public static bool IsOpen(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().IsOpen;
        }

        /// <summary>
        /// Returns true if the definition of this reference is open.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>If the definition of this reference is open.</returns>
        public static bool IsOpen(this IEdmType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");

            if (type is IEdmStructuredType structuredType)
            {
                return structuredType.IsOpen;
            }

            // If its a collection, return whether its element type is open.
            // This is because when processing a navigation property, the target type
            // may be a collection type even though a key expression has been applied.
            var collectionType = type as IEdmCollectionType;
            if (collectionType == null)
            {
                return false;
            }

            return collectionType.ElementType.Definition.IsOpen();
        }

        /// <summary>
        /// Returns the base type of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of the definition of this reference. </returns>
        public static IEdmStructuredType BaseType(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().BaseType;
        }

        /// <summary>
        /// Gets all structural properties declared in the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the definition of this reference.</returns>
        public static IEnumerable<IEdmStructuralProperty> DeclaredStructuralProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().DeclaredStructuralProperties();
        }

        /// <summary>
        /// Gets all structural properties declared in the definition of this reference and all its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>All structural properties declared in the definition of this reference and all its base types.</returns>
        public static IEnumerable<IEdmStructuralProperty> StructuralProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().StructuralProperties();
        }

        /// <summary>
        /// Finds a property from the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="name">Name of the property to find.</param>
        /// <returns>The requested property if it exists. Otherwise, null.</returns>
        public static IEdmProperty FindProperty(this IEdmStructuredTypeReference type, string name)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(name, "name");
            return type.StructuredDefinition().FindProperty(name);
        }

        /// <summary>
        /// Gets the navigation properties declared in the definition of this reference and its base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in the definition of this reference and its base types.</returns>
        public static IEnumerable<IEdmNavigationProperty> NavigationProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().NavigationProperties();
        }

        /// <summary>
        /// Gets the navigation properties declared in the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in the definition of this reference.</returns>
        public static IEnumerable<IEdmNavigationProperty> DeclaredNavigationProperties(this IEdmStructuredTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.StructuredDefinition().DeclaredNavigationProperties();
        }

        /// <summary>
        /// Finds a navigation property declared in the definition of this reference by name.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="name">Name of the navigation property to find.</param>
        /// <returns>The requested navigation property if it exists. Otherwise, null.</returns>
        public static IEdmNavigationProperty FindNavigationProperty(this IEdmStructuredTypeReference type, string name)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(name, "name");
            return type.StructuredDefinition().FindProperty(name) as IEdmNavigationProperty;
        }

        #endregion

        #region IEdmEntityTypeDefinition
        /// <summary>
        /// Gets the base type of this entity type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this entity type definition.</returns>
        public static IEdmEntityType BaseEntityType(this IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmEntityType;
        }

        /// <summary>
        /// Gets the base type of this structured type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this structured type definition.</returns>
        public static IEdmStructuredType BaseType(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmStructuredType;
        }

        /// <summary>
        /// Gets the navigation properties declared in this structured type definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in this structured type definition.</returns>
        public static IEnumerable<IEdmNavigationProperty> DeclaredNavigationProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.DeclaredProperties.OfType<IEdmNavigationProperty>();
        }

        /// <summary>
        /// Get the navigation properties declared in this structured type and all base types.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The navigation properties declared in this structured type and all base types.</returns>
        public static IEnumerable<IEdmNavigationProperty> NavigationProperties(this IEdmStructuredType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.Properties().OfType<IEdmNavigationProperty>();
        }

        /// <summary>
        /// Gets the declared key of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Key of this type.</returns>
        public static IEnumerable<IEdmStructuralProperty> Key(this IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            IEdmEntityType checkingType = type;
            while (checkingType != null)
            {
                if (checkingType.DeclaredKey != null)
                {
                    return checkingType.DeclaredKey;
                }

                checkingType = checkingType.BaseEntityType();
            }

            return Enumerable.Empty<IEdmStructuralProperty>();
        }

        /// <summary>
        /// Determines whether the specified property is a key for its contained type.
        /// </summary>
        /// <param name="property">The property that may be a key.</param>
        /// <returns>True, if the property is a key, False if the property is not a key.</returns>
        public static bool IsKey(this IEdmProperty property)
        {
            EdmUtil.CheckArgumentNull(property, "property");

            if (property.DeclaringType is IEdmEntityType entityType)
            {
                foreach (IEdmProperty key in entityType.Key())
                {
                    if (key == property)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Gets the declared alternate keys of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="model">The model to be used.</param>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>Alternate Keys of this type.</returns>
        public static IEnumerable<IDictionary<string, IEdmProperty>> GetAlternateKeysAnnotation(this IEdmModel model, IEdmEntityType type)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(type, "type");

            IEdmEntityType checkingType = type;
            while (checkingType != null)
            {
                IEnumerable<IDictionary<string, IEdmProperty>> declaredAlternateKeys = GetDeclaredAlternateKeysForType(checkingType, model);
                if (declaredAlternateKeys != null)
                {
                    return declaredAlternateKeys;
                }

                checkingType = checkingType.BaseEntityType();
            }

            return Enumerable.Empty<IDictionary<string, IEdmProperty>>();
        }

        /// <summary>
        /// Adds the alternate keys to this entity type.
        /// </summary>
        /// <param name="model">The model to be used.</param>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="alternateKey">Dictionary of alias and structural properties for the alternate key.</param>
        public static void AddAlternateKeyAnnotation(this EdmModel model, IEdmEntityType type, IDictionary<string, IEdmProperty> alternateKey)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(type, "type");
            EdmUtil.CheckArgumentNull(alternateKey, "alternateKey");

            EdmCollectionExpression annotationValue = null;
            var ann = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(type, AlternateKeysVocabularyModel.AlternateKeysTerm).FirstOrDefault();
            if (ann != null)
            {
                annotationValue = ann.Value as EdmCollectionExpression;
            }

            var alternateKeysCollection = annotationValue != null ? new List<IEdmExpression>(annotationValue.Elements) : new List<IEdmExpression>();

            List<IEdmExpression> propertyRefs = new List<IEdmExpression>();

            foreach (KeyValuePair<string, IEdmProperty> kvp in alternateKey)
            {
                IEdmRecordExpression propertyRef = new EdmRecordExpression(
                    new EdmComplexTypeReference(AlternateKeysVocabularyModel.PropertyRefType, false),
                    new EdmPropertyConstructor(AlternateKeysVocabularyConstants.PropertyRefTypeAliasPropertyName, new EdmStringConstant(kvp.Key)),
                    new EdmPropertyConstructor(AlternateKeysVocabularyConstants.PropertyRefTypeNamePropertyName, new EdmPropertyPathExpression(kvp.Value.Name)));
                propertyRefs.Add(propertyRef);
            }

            EdmRecordExpression alternateKeyRecord = new EdmRecordExpression(
                new EdmComplexTypeReference(AlternateKeysVocabularyModel.AlternateKeyType, false),
                new EdmPropertyConstructor(AlternateKeysVocabularyConstants.AlternateKeyTypeKeyPropertyName, new EdmCollectionExpression(propertyRefs)));

            alternateKeysCollection.Add(alternateKeyRecord);

            var annotation = new EdmVocabularyAnnotation(
                type,
                AlternateKeysVocabularyModel.AlternateKeysTerm,
                new EdmCollectionExpression(alternateKeysCollection));

            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        /// <summary>
        /// Checks whether the given entity type has the <paramref name="property"/> as one of the key properties.
        /// </summary>
        /// <param name="entityType">Given entity type.</param>
        /// <param name="property">Property to be searched for.</param>
        /// <returns><c>true</c> if the type or base types has given property declared as key. <c>false</c> otherwise.</returns>
        public static bool HasDeclaredKeyProperty(this IEdmEntityType entityType, IEdmProperty property)
        {
            EdmUtil.CheckArgumentNull(entityType, "entityType");
            EdmUtil.CheckArgumentNull(property, "property");

            while (entityType != null)
            {
                if (entityType.DeclaredKey != null && entityType.DeclaredKey.Any(k => k == property))
                {
                    return true;
                }

                entityType = entityType.BaseEntityType();
            }

            return false;
        }

        #endregion

        #region IEdmEntityTypeReference
        /// <summary>
        /// Gets the definition of this entity reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this entity reference.</returns>
        public static IEdmEntityType EntityDefinition(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEntityType)type.Definition;
        }

        /// <summary>
        /// Gets the base type of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of the definition of this reference.</returns>
        public static IEdmEntityType BaseEntityType(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityDefinition().BaseEntityType();
        }

        /// <summary>
        /// Gets the entity key of the definition of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The entity key of the definition of this reference.</returns>
        public static IEnumerable<IEdmStructuralProperty> Key(this IEdmEntityTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityDefinition().Key();
        }
        #endregion

        #region IEdmComplexTypeDefinition
        /// <summary>
        /// Gets the base type of this references definition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this references definition.</returns>
        public static IEdmComplexType BaseComplexType(this IEdmComplexType type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.BaseType as IEdmComplexType;
        }
        #endregion

        #region IEdmComplexTypeReference
        /// <summary>
        /// Gets the definition of this reference typed as an IEdmComplexTypeDefinition.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this reference typed as an IEdmComplexTypeDefinition.</returns>
        public static IEdmComplexType ComplexDefinition(this IEdmComplexTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmComplexType)type.Definition;
        }

        /// <summary>
        /// Gets the base type of this reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The base type of this reference.</returns>
        public static IEdmComplexType BaseComplexType(this IEdmComplexTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.ComplexDefinition().BaseComplexType();
        }
        #endregion

        #region IEdmEntityReferenceTypeReference
        /// <summary>
        /// Gets the definition of this entity reference type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this entity reference type reference.</returns>
        public static IEdmEntityReferenceType EntityReferenceDefinition(this IEdmEntityReferenceTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEntityReferenceType)type.Definition;
        }

        /// <summary>
        /// Gets the entity type referred to by the definition of this entity reference type reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The entity type referred to by the definition of this entity reference type reference.</returns>
        public static IEdmEntityType EntityType(this IEdmEntityReferenceTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.EntityReferenceDefinition().EntityType;
        }
        #endregion

        #region IEdmCollectionTypeReference
        /// <summary>
        /// Gets the definition of this collection reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this collection reference.</returns>
        public static IEdmCollectionType CollectionDefinition(this IEdmCollectionTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmCollectionType)type.Definition;
        }

        /// <summary>
        /// Gets the element type of the definition of this collection reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The element type of the definition of this collection reference.</returns>
        public static IEdmTypeReference ElementType(this IEdmCollectionTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return type.CollectionDefinition().ElementType;
        }

        #endregion

        #region IEdmEnumTypeReference

        /// <summary>
        /// Gets the definition of this enumeration reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this enumeration reference.</returns>
        public static IEdmEnumType EnumDefinition(this IEdmEnumTypeReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmEnumType)type.Definition;
        }

        #endregion

        #region IEdmTypeDefinitionReference

        /// <summary>
        /// Gets the definition of this type definition reference.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <returns>The definition of this type definition reference.</returns>
        public static IEdmTypeDefinition TypeDefinition(this IEdmTypeDefinitionReference type)
        {
            EdmUtil.CheckArgumentNull(type, "type");
            return (IEdmTypeDefinition)type.Definition;
        }

        #endregion

        #region IEdmNavigationProperty

        /// <summary>
        /// Gets the multiplicity of the target of this navigation.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The multiplicity of the target end of the relationship.</returns>
        public static EdmMultiplicity TargetMultiplicity(this IEdmNavigationProperty property)
        {
            EdmUtil.CheckArgumentNull(property, "property");

            IEdmTypeReference type = property.Type;
            if (type.IsCollection())
            {
                return EdmMultiplicity.Many;
            }

            return type.IsNullable ? EdmMultiplicity.ZeroOrOne : EdmMultiplicity.One;
        }

        /// <summary>
        /// Gets the entity type targeted by this navigation property.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The entity type targeted by this navigation property.</returns>
        public static IEdmEntityType ToEntityType(this IEdmNavigationProperty property)
        {
            return property.Type.Definition.AsElementType() as IEdmEntityType;
        }

        /// <summary>
        /// Gets the structured type targeted by this structural property type reference.
        /// </summary>
        /// <param name="propertyTypeReference">Reference to the calling object.</param>
        /// <returns>The structured type targeted by this structural property.</returns>
        public static IEdmStructuredType ToStructuredType(this IEdmTypeReference propertyTypeReference)
        {
            IEdmType target = propertyTypeReference.Definition;
            if (target.TypeKind == EdmTypeKind.Collection)
            {
                target = ((IEdmCollectionType)target).ElementType.Definition;
            }

            return target as IEdmStructuredType;
        }

        /// <summary>
        /// Gets the entity type declaring this navigation property.
        /// </summary>
        /// <param name="property">Reference to the calling object.</param>
        /// <returns>The entity type that declares this navigation property.</returns>
        public static IEdmEntityType DeclaringEntityType(this IEdmNavigationProperty property)
        {
            return (IEdmEntityType)property.DeclaringType;
        }

        /// <summary>
        /// Gets whether this navigation property originates at the principal end of an association.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>Whether this navigation property originates at the principal end of an association.</returns>
        public static bool IsPrincipal(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null && navigationProperty.Partner != null && navigationProperty.Partner.ReferentialConstraint != null;
        }

        /// <summary>
        /// Gets the dependent properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>The dependent properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.</returns>
        public static IEnumerable<IEdmStructuralProperty> DependentProperties(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null ? null : navigationProperty.ReferentialConstraint.PropertyPairs.Select(p => p.DependentProperty);
        }

        /// <summary>
        /// Gets the principal properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>The principal properties of this navigation property, returning null if this is the principal entity or if there is no referential constraint.</returns>
        public static IEnumerable<IEdmStructuralProperty> PrincipalProperties(this IEdmNavigationProperty navigationProperty)
        {
            return navigationProperty.ReferentialConstraint == null ? null : navigationProperty.ReferentialConstraint.PropertyPairs.Select(p => p.PrincipalProperty);
        }

        #endregion

        #region IEdmVocabularyAnnotation
        /// <summary>
        /// Gets the term of this annotation.
        /// </summary>
        /// <param name="annotation">Reference to the calling object.</param>
        /// <returns>The term of this annotation.</returns>
        public static IEdmTerm Term(this IEdmVocabularyAnnotation annotation)
        {
            EdmUtil.CheckArgumentNull(annotation, "annotation");
            return annotation.Term;
        }
        #endregion

        #region IEdmOperationImport
        /// <summary>
        /// Tries to get the relative entity set path.
        /// </summary>
        /// <param name="operation">The operation to resolve the entitySet path.</param>
        /// <param name="model">The model.</param>
        /// <param name="parameter">The parameter.</param>
        /// <param name="relativeNavigations">The relative navigations and its path.</param>
        /// <param name="lastEntityType">Last type of the entity.</param>
        /// <param name="errors">The errors.</param>
        /// <returns>True if a Entity set path is found, false otherwise.</returns>
        public static bool TryGetRelativeEntitySetPath(this IEdmOperation operation, IEdmModel model, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEdmEntityType lastEntityType, out IEnumerable<EdmError> errors)
        {
            errors = Enumerable.Empty<EdmError>();
            parameter = null;
            relativeNavigations = null;
            lastEntityType = null;

            Debug.Assert(operation != null, "expected non null operation");

            // If a value does not exist just return as there is nothing to validate.
            if (operation.EntitySetPath == null)
            {
                return false;
            }

            Collection<EdmError> foundErrors = new Collection<EdmError>();
            errors = foundErrors;
            if (!operation.IsBound)
            {
                foundErrors.Add(
                    new EdmError(
                        operation.Location(),
                        EdmErrorCode.OperationCannotHaveEntitySetPathWithUnBoundOperation,
                        Strings.EdmModel_Validator_Semantic_OperationCannotHaveEntitySetPathWithUnBoundOperation(operation.Name)));
            }

            return TryGetRelativeEntitySetPath(operation, foundErrors, operation.EntitySetPath, model, operation.Parameters, out parameter, out relativeNavigations, out lastEntityType);
        }


        /// <summary>
        /// Determines whether [is action import] [the specified operation import].
        /// </summary>
        /// <param name="operationImport">The operation import.</param>
        /// <returns>
        ///   <c>true</c> if [is action import] [the specified operation import]; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsActionImport(this IEdmOperationImport operationImport)
        {
            return operationImport.ContainerElementKind == EdmContainerElementKind.ActionImport;
        }

        /// <summary>
        /// Determines whether [is function import] [the specified operation import].
        /// </summary>
        /// <param name="operationImport">The operation import.</param>
        /// <returns>
        ///   <c>true</c> if [is function import] [the specified operation import]; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsFunctionImport(this IEdmOperationImport operationImport)
        {
            return operationImport.ContainerElementKind == EdmContainerElementKind.FunctionImport;
        }

        /// <summary>
        /// Analyzes <see cref="IEdmOperationImport"/>.EntitySet expression and returns a static <see cref="IEdmEntitySet"/> reference if available.
        /// </summary>
        /// <param name="operationImport">The operation import containing the entity set expression.</param>
        /// <param name="model">The model containing the operation import.</param>
        /// <param name="entitySet">The static entity set of the operation import.</param>
        /// <returns>True if the entity set expression of the <paramref name="operationImport"/> contains a static reference to an <see cref="IEdmEntitySet"/>, otherwise false.</returns>
        /// <remarks>TODO: Support resolving target path to a contained entity set.</remarks>
        public static bool TryGetStaticEntitySet(this IEdmOperationImport operationImport, IEdmModel model, out IEdmEntitySetBase entitySet)
        {
            if (operationImport.EntitySet is IEdmPathExpression pathExpression)
            {
                return pathExpression.TryGetStaticEntitySet(model, out entitySet);
            }

            entitySet = null;
            return false;
        }

        /// <summary>
        /// Analyzes <see cref="IEdmOperationImport"/>.EntitySet expression and returns a relative path to an <see cref="IEdmEntitySet"/> if available.
        /// The path starts with the <paramref name="parameter"/> and may have optional sequence of <see cref="IEdmNavigationProperty"/> and type casts segments.
        /// </summary>
        /// <param name="operationImport">The operation import containing the entity set expression.</param>
        /// <param name="model">The model containing the operation import.</param>
        /// <param name="parameter">The operation import parameter from which the relative entity set path starts.</param>
        /// <param name="relativeNavigations">The optional sequence of navigation properties and their path</param>
        /// <param name="edmErrors">The errors that were found when attempting to get the relative path.</param>
        /// <returns>True if the entity set expression of the <paramref name="operationImport"/> contains a relative path an <see cref="IEdmEntitySet"/>, otherwise false.</returns>
        public static bool TryGetRelativeEntitySetPath(this IEdmOperationImport operationImport, IEdmModel model, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEnumerable<EdmError> edmErrors)
        {
            EdmUtil.CheckArgumentNull(operationImport, "operationImport");
            EdmUtil.CheckArgumentNull(model, "model");

            parameter = null;
            relativeNavigations = null;
            edmErrors = new ReadOnlyCollection<EdmError>(new List<EdmError>());

            if (operationImport.EntitySet is IEdmPathExpression pathExpression)
            {
                IEdmEntityType entityType = null;
                Collection<EdmError> foundErrors = new Collection<EdmError>();
                bool result = TryGetRelativeEntitySetPath(operationImport, foundErrors, pathExpression, model, operationImport.Operation.Parameters, out parameter, out relativeNavigations, out entityType);
                edmErrors = new ReadOnlyCollection<EdmError>(foundErrors);

                return result;
            }

            return false;
        }

        #endregion

        #region IEdmOperation

        /// <summary>
        /// Determines whether the specified operation is action.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>
        ///   <c>true</c> if the specified operation is action; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsAction(this IEdmOperation operation)
        {
            return operation.SchemaElementKind == EdmSchemaElementKind.Action;
        }

        /// <summary>
        /// Determines whether the specified operation is function.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>
        ///   <c>true</c> if the specified operation is function; otherwise, <c>false</c>.
        /// </returns>
        public static bool IsFunction(this IEdmOperation operation)
        {
            return operation.SchemaElementKind == EdmSchemaElementKind.Function;
        }

        /// <summary>
        /// Gets the <see cref="IEdmOperationReturn"/> from the specified operation.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <returns>The instance of <see cref="IEdmOperationReturn"/> or null if the operation has no return type.</returns>
        public static IEdmOperationReturn GetReturn(this IEdmOperation operation)
        {
            if (operation is EdmOperation edmOperation)
            {
                return edmOperation.Return;
            }

            if (operation is CsdlSemanticsOperation csdlOperation)
            {
                return csdlOperation.Return;
            }

            if (operation == null || operation.ReturnType == null)
            {
                return null;
            }

            return new EdmOperationReturn(operation, operation.ReturnType);
        }

        /// <summary>
        /// Checks whether all operations have the same return type
        /// </summary>
        /// <param name="operations">the list to check</param>
        /// <param name="forceFullyQualifiedNameFilter">Ensures that the Where filter clause applies the Full name,</param>
        /// <param name="operationName">The operation name to filter by.</param>
        /// <returns>true if the list of operation imports all have the same return type</returns>
        public static IEnumerable<IEdmOperation> FilterByName(this IEnumerable<IEdmOperation> operations, bool forceFullyQualifiedNameFilter, string operationName)
        {
            EdmUtil.CheckArgumentNull(operations, "operations");
            EdmUtil.CheckArgumentNull(operationName, "operationName");

            if (forceFullyQualifiedNameFilter || operationName.IndexOf(".", StringComparison.Ordinal) > -1)
            {
                return operations.Where(o => o.FullName() == operationName);
            }
            else
            {
                return operations.Where(o => o.Name == operationName);
            }
        }

        /// <summary>
        /// Determines whether the bound operation's  binding type is equivalent to the specified binding type.
        /// </summary>
        /// <param name="operation">The operation.</param>
        /// <param name="bindingType">Type of the binding.</param>
        /// <returns>
        ///   <c>true</c> if [is operation binding type equivalent to] [the specified operation]; otherwise, <c>false</c>.
        /// </returns>
        public static bool HasEquivalentBindingType(this IEdmOperation operation, IEdmType bindingType)
        {
            EdmUtil.CheckArgumentNull(operation, "operation");
            EdmUtil.CheckArgumentNull(bindingType, "bindingType");

            if (!operation.IsBound)
            {
                return false;
            }

            IEdmOperationParameter parameter = operation.Parameters.FirstOrDefault();
            if (parameter == null)
            {
                return false;
            }

            IEdmType parameterType = parameter.Type.Definition;
            if (parameterType.TypeKind != bindingType.TypeKind)
            {
                return false;
            }

            if (parameterType.TypeKind == EdmTypeKind.Collection)
            {
                // covariance applies here, so IEnumerable<A> is applicable to IEnumerable<B> where B:A
                IEdmCollectionType parameterCollectionType = (IEdmCollectionType)parameterType;
                IEdmCollectionType bindingCollectionType = (IEdmCollectionType)bindingType;

                return bindingCollectionType.ElementType.Definition.IsOrInheritsFrom(parameterCollectionType.ElementType.Definition);
            }
            else
            {
                return bindingType.IsOrInheritsFrom(parameterType);
            }
        }

        #endregion

        #region IEdmRecordExpression

        /// <summary>
        /// Finds a property of a record expression.
        /// </summary>
        /// <param name="expression">The record expression.</param>
        /// <param name="name">Name of the property to find.</param>
        /// <returns>The property, if found, otherwise null.</returns>
        public static IEdmPropertyConstructor FindProperty(this IEdmRecordExpression expression, string name)
        {
            foreach (IEdmPropertyConstructor propertyConstructor in expression.Properties)
            {
                if (propertyConstructor.Name == name)
                {
                    return propertyConstructor;
                }
            }

            return null;
        }

        #endregion

        #region IEdmNavigationSource

        /// <summary>
        /// Return the navigation kind of the navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>The kind of the navigation source.</returns>
        public static EdmNavigationSourceKind NavigationSourceKind(this IEdmNavigationSource navigationSource)
        {
            if (navigationSource is IEdmEntitySet)
            {
                return EdmNavigationSourceKind.EntitySet;
            }

            if (navigationSource is IEdmSingleton)
            {
                return EdmNavigationSourceKind.Singleton;
            }

            if (navigationSource is IEdmContainedEntitySet)
            {
                return EdmNavigationSourceKind.ContainedEntitySet;
            }

            if (navigationSource is IEdmUnknownEntitySet)
            {
                return EdmNavigationSourceKind.UnknownEntitySet;
            }

            return EdmNavigationSourceKind.None;
        }

        /// <summary>
        /// Returns the fully qualified name of a navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source to get the full name for.</param>
        /// <returns>The full qualified name of the navigation source.</returns>
        public static string FullNavigationSourceName(this IEdmNavigationSource navigationSource)
        {
            EdmUtil.CheckArgumentNull(navigationSource, "navigationSource");

            return string.Join(".", navigationSource.Path.PathSegments.ToArray());
        }

        /// <summary>
        /// Return the entity type of the navigation source.
        /// </summary>
        /// <param name="navigationSource">The navigation source.</param>
        /// <returns>The entity type of the navigation source.</returns>
        public static IEdmEntityType EntityType(this IEdmNavigationSource navigationSource)
        {
            if (navigationSource is IEdmEntitySetBase entitySetBase)
            {
                if (entitySetBase.Type is IEdmCollectionType collectionType)
                {
                    return collectionType.ElementType.Definition as IEdmEntityType;
                }

                if (entitySetBase is IEdmUnknownEntitySet unknownEntitySet)
                {
                    // Handle missing navigation target for nullable
                    // singleton navigation property.
                    return unknownEntitySet.Type as IEdmEntityType;
                }

                return null;
            }

            if (navigationSource is IEdmSingleton singleton)
            {
                return singleton.Type as IEdmEntityType;
            }

            return null;
        }

        #endregion

        #region IEdmReferences

        /// <summary>
        /// Sets edmx:Reference information (IEdmReference) to the model.
        /// </summary>
        /// <param name="model">The IEdmModel to set edmx:Reference information.</param>
        /// <param name="edmReferences">The edmx:Reference information to be set.</param>
        public static void SetEdmReferences(this IEdmModel model, IEnumerable<IEdmReference> edmReferences)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            model.SetAnnotationValue(model, EdmConstants.InternalUri, CsdlConstants.ReferencesAnnotation, edmReferences);
        }

        /// <summary>
        /// Gets edmx:Reference information (IEdmReference) from the model.
        /// </summary>
        /// <param name="model">The IEdmModel to get edmx:Reference information.</param>
        /// <returns>The edmx:Reference information.</returns>
        public static IEnumerable<IEdmReference> GetEdmReferences(this IEdmModel model)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            return (IEnumerable<IEdmReference>)model.GetAnnotationValue(model, EdmConstants.InternalUri, CsdlConstants.ReferencesAnnotation);
        }

        #endregion

        /// <summary>
        /// Gets the partner path of a navigation property.
        /// </summary>
        /// <param name="navigationProperty">The navigation property.</param>
        /// <returns>Path to the partner navigation property from the related entity type.</returns>
        public static IEdmPathExpression GetPartnerPath(this IEdmNavigationProperty navigationProperty)
        {
            if (navigationProperty is EdmNavigationProperty edmNavigationProperty)
            {
                return edmNavigationProperty.PartnerPath;
            }

            if (navigationProperty is CsdlSemanticsNavigationProperty csdlSemanticsNavigationProperty)
            {
                return (csdlSemanticsNavigationProperty.Element as CsdlNavigationProperty)?.PartnerPath;
            }

            // Default behavior where partner path corresponds to the name of the partner nav. property. In other words,
            // the partner must be on an entity type. Will remove this limitation once we are OK to make breaking changes
            // on IEdmNavigationProperty.
            return navigationProperty.Partner == null ? null : new EdmPathExpression(navigationProperty.Partner.Name);
        }

        /// <summary>
        /// Replace a possibly alias-qualified name with the full namespace qualified name.
        /// </summary>
        /// <param name="model">The model containing the element.</param>
        /// <param name="name">The alias- or namespace- qualified name of the element.</param>
        /// <returns>The namespace qualified name of the element.</returns>
        internal static string ReplaceAlias(this IEdmModel model, string name)
        {
            VersioningDictionary<string, string> mappings = model.GetNamespaceAliases();
            VersioningList<string> list = model.GetUsedNamespacesHavingAlias();
            int idx = name.IndexOf('.');

            if (list != null && mappings != null && idx > 0)
            {
                var typeAlias = name.Substring(0, idx);
                var ns = list.FirstOrDefault(n =>
                {
                    string alias;
                    return mappings.TryGetValue(n, out alias) && alias == typeAlias;
                });

                return (ns != null) ? string.Format(CultureInfo.InvariantCulture, "{0}{1}", ns, name.Substring(idx)) : name;
            }

            return name;
        }

        #region methods for finding elements in CsdlSemanticsModel

        internal static IEnumerable<IEdmOperation> FindOperationsInModelTree(this CsdlSemanticsModel model, string name)
        {
            return model.FindInModelTree(findOperations, name, mergeFunctions);
        }

        /// <summary>
        /// Find types in CsdlSemanticsModel tree.
        /// </summary>
        /// <param name="model">The CsdlSemanticsModel.</param>
        /// <param name="name">The name by which to search.</param>
        /// <returns>The found emd type or null.</returns>
        internal static IEdmSchemaType FindTypeInModelTree(this CsdlSemanticsModel model, string name)
        {
            return model.FindInModelTree(findType, name, RegistrationHelper.CreateAmbiguousTypeBinding);
        }

        /// <summary>
        /// Searches for a type with the given name in the model and its main/sibling/referenced models, returns null if no such type exists.
        /// </summary>
        /// <typeparam name="T">the type of value to find.</typeparam>
        /// <param name="model">The model to search for type.</param>
        /// <param name="finderFunc">The func for each IEdmModel node to find element by name.</param>
        /// <param name="qualifiedName">The qualified name of the type being found.</param>
        /// <param name="ambiguousCreator">The func to combine results when more than one is found.</param>
        /// <remarks>when searching, will ignore built-in types in EdmCoreModel and CoreVocabularyModel.</remarks>
        /// <returns>The requested type, or null if no such type exists.</returns>
        internal static T FindInModelTree<T>(this CsdlSemanticsModel model, Func<IEdmModel, string, T> finderFunc, string qualifiedName, Func<T, T, T> ambiguousCreator)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(finderFunc, "finderFunc");
            EdmUtil.CheckArgumentNull(qualifiedName, "qualifiedName");
            EdmUtil.CheckArgumentNull(ambiguousCreator, "ambiguousCreator");

            // find type in current model only
            T result = finderFunc(model, qualifiedName);
            T candidate;

            // now find type in main model and current model's sibling models.
            if (model.MainModel != null)
            {
                // main model:
                if ((candidate = finderFunc(model.MainModel, qualifiedName)) != null)
                {
                    result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                }

                // current model's sibling models :
                foreach (var tmp in model.MainModel.ReferencedModels)
                {
                    // doesn't search the current model again
                    if ((tmp != EdmCoreModel.Instance) && (tmp != CoreVocabularyModel.Instance)
                        && tmp != model)
                    {
                        if ((candidate = finderFunc(tmp, qualifiedName)) != null)
                        {
                            result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                        }
                    }
                }
            }

            // then find type in referenced models
            foreach (var tmp in model.ReferencedModels)
            {
                candidate = finderFunc(tmp, qualifiedName);
                if (candidate != null)
                {
                    result = (result == null) ? candidate : ambiguousCreator(result, candidate);
                }
            }

            return result;
        }
        #endregion

        #region UrlEscape
        /// <summary>
        /// Determines whether the specified function is UrlEscape function or not.
        /// </summary>
        /// <param name="model">The Edm model.</param>
        /// <param name="function">The specified function</param>
        /// <returns><c>true</c> if the specified operation is UrlEscape function; otherwise, <c>false</c>.</returns>
        internal static bool IsUrlEscapeFunction(this IEdmModel model, IEdmFunction function)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(function, "function");

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(function, CommunityVocabularyModel.UrlEscapeFunctionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value == null)
                {
                    // If the annotation is applied but a value is not specified then the value is assumed to be true.
                    return true;
                }

                if (annotation.Value is IEdmBooleanConstantExpression tagConstant)
                {
                    return tagConstant.Value;
                }
            }

            return false;
        }

        /// <summary>
        /// Set annotation Org.OData.Community.V1.UrlEscapeFunction to <see cref="IEdmFunction"/>.
        /// </summary>
        /// <param name="model">The model to add annotation</param>
        /// <param name="function">The target function to set the inline annotation</param>
        internal static void SetUrlEscapeFunction(this EdmModel model, IEdmFunction function)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(function, "function");

            IEdmBooleanConstantExpression booleanConstant = new EdmBooleanConstant(true);
            IEdmTerm term = CommunityVocabularyModel.UrlEscapeFunctionTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(function, term, booleanConstant);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }
        #endregion

        internal static bool TryGetRelativeEntitySetPath(IEdmElement element, Collection<EdmError> foundErrors, IEdmPathExpression pathExpression, IEdmModel model, IEnumerable<IEdmOperationParameter> parameters, out IEdmOperationParameter parameter, out Dictionary<IEdmNavigationProperty, IEdmPathExpression> relativeNavigations, out IEdmEntityType lastEntityType)
        {
            parameter = null;
            relativeNavigations = null;
            lastEntityType = null;

            var pathItems = pathExpression.PathSegments.ToList();
            if (pathItems.Count < 1)
            {
                foundErrors.Add(new EdmError(element.Location(), EdmErrorCode.OperationWithInvalidEntitySetPathMissingCompletePath, Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathMissingBindingParameterName(CsdlConstants.Attribute_EntitySetPath)));
                return false;
            }

            // If there is no parameter then this will fail in BoundOperationMustHaveParameters rule so skip validating this here.
            parameter = parameters.FirstOrDefault();
            if (parameter == null)
            {
                return false;
            }

            bool foundRelativePath = true;

            string bindingParameterName = pathItems.First();
            if (parameter.Name != bindingParameterName)
            {
                foundErrors.Add(
                    new EdmError(
                        element.Location(),
                        EdmErrorCode.InvalidPathFirstPathParameterNotMatchingFirstParameterName,
                        Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathWithFirstPathParameterNotMatchingFirstParameterName(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), bindingParameterName, parameter.Name)));

                foundRelativePath = false;
            }

            lastEntityType = parameter.Type.Definition as IEdmEntityType;
            if (lastEntityType == null)
            {
                if (parameter.Type is IEdmCollectionTypeReference collectionReference && collectionReference.ElementType().IsEntity())
                {
                    lastEntityType = collectionReference.ElementType().Definition as IEdmEntityType;
                }
                else
                {
                    foundErrors.Add(
                        new EdmError(
                            element.Location(),
                            EdmErrorCode.InvalidPathWithNonEntityBindingParameter,
                            Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathWithNonEntityBindingParameter(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), bindingParameterName)));

                    return false;
                }
            }

            Dictionary<IEdmNavigationProperty, IEdmPathExpression> navigationProperties = new Dictionary<IEdmNavigationProperty, IEdmPathExpression>();
            List<string> paths = new List<string>();

            // Now check that the next paths are valid parameters.
            foreach (string pathSegment in pathItems.Skip(1))
            {
                paths.Add(pathSegment);

                if (EdmUtil.IsQualifiedName(pathSegment))
                {
                    IEdmSchemaType foundType = model.FindDeclaredType(pathSegment);
                    if (foundType == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathUnknownTypeCastSegment,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathUnknownTypeCastSegment(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), pathSegment)));

                        foundRelativePath = false;
                        break;
                    }

                    IEdmEntityType foundEntityTypeCast = foundType as IEdmEntityType;

                    if (foundEntityTypeCast == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathTypeCastSegmentMustBeEntityType,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathTypeCastSegmentMustBeEntityType(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), foundType.FullName())));

                        foundRelativePath = false;
                        break;
                    }

                    if (!foundEntityTypeCast.IsOrInheritsFrom(lastEntityType))
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathInvalidTypeCastSegment,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathInvalidTypeCastSegment(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), lastEntityType.FullName(), foundEntityTypeCast.FullName())));

                        foundRelativePath = false;
                        break;
                    }

                    lastEntityType = foundEntityTypeCast;
                }
                else
                {
                    IEdmNavigationProperty navigationProperty = lastEntityType.FindProperty(pathSegment) as IEdmNavigationProperty;
                    if (navigationProperty == null)
                    {
                        foundErrors.Add(
                            new EdmError(
                                element.Location(),
                                EdmErrorCode.InvalidPathUnknownNavigationProperty,
                                Strings.EdmModel_Validator_Semantic_InvalidEntitySetPathUnknownNavigationProperty(CsdlConstants.Attribute_EntitySetPath, EdmModelCsdlSchemaWriter.PathAsXml(pathExpression.PathSegments), pathSegment)));

                        foundRelativePath = false;
                        break;
                    }

                    navigationProperties[navigationProperty] = new EdmPathExpression(paths);

                    // In 7.4.1, FindNavigationTarget expected a binding path that included the path
                    // to the contained entity set. In 7.4.2 FindNavigationTarget was fixed to work off
                    // of the path from the contained entity set, but retained the old behavior as well
                    // for backward compatibility. In the next breaking change we should remove that
                    // behavior in FindNavigationTarget and remove this special handling of containsTarget
                    // by always clearing the path.
                    if (!navigationProperty.ContainsTarget)
                    {
                        paths.Clear();
                    }

                    lastEntityType = navigationProperty.ToEntityType();
                }
            }

            relativeNavigations = navigationProperties;
            return foundRelativePath;
        }

        /// <summary>
        /// This method is only used for the operation import entity set path parsing.
        /// </summary>
        /// <param name="segmentType">The type of the segment.</param>
        /// <returns>Non-null entity type that may be bad.</returns>
        internal static IEdmEntityType GetPathSegmentEntityType(IEdmTypeReference segmentType)
        {
            return (segmentType.IsCollection() ? segmentType.AsCollection().ElementType() : segmentType).AsEntity().EntityDefinition();
        }

        internal static IEnumerable<IEdmEntityContainerElement> AllElements(this IEdmEntityContainer container, int depth = ContainerExtendsMaxDepth)
        {
            if (depth <= 0)
            {
                throw new InvalidOperationException(Edm.Strings.Bad_CyclicEntityContainer(container.FullName()));
            }

            CsdlSemanticsEntityContainer semanticsEntityContainer = container as CsdlSemanticsEntityContainer;
            if (semanticsEntityContainer == null || semanticsEntityContainer.Extends == null)
            {
                return container.Elements;
            }

            return container.Elements.Concat(semanticsEntityContainer.Extends.AllElements(depth - 1));
        }

        /// <summary>
        /// Searches for entity set by the given name that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        internal static IEdmEntitySet FindEntitySetExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindEntitySet(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for an entity set or contained navigation property according to the specified path that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="path">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The entity set found or empty if none found.</returns>
        internal static IEdmNavigationSource FindNavigationSourceExtended(this IEdmEntityContainer container, string path)
        {
            return FindInContainerAndExtendsRecursively(container, path, (c, n) => c.FindNavigationSource(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for an entity set or contained navigation property according to the specified path that may be container qualified in default container and .Extends containers.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="path">The path which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The navigation source found or empty if none found.</returns>
        internal static IEdmNavigationSource FindNavigationSource(this IEdmEntityContainer container, string path)
        {
            EdmUtil.CheckArgumentNull(container, "container");
            EdmUtil.CheckArgumentNull(path, "path");

            // the path could be:
            // "NS.Default.Customers/ContainedOrders"(for backward-compatibility) or
            // "NS.Default/Customers/ContainedOrders" (for top-level entity set in the Default entity container) or
            // "Customers" (unqualified)
            // "Customers/ContainedOrders" (unqualified)
            string[] pathSegments = path.Split('/');

            string firstElementName = pathSegments[0];
            int nextIndex = 1;
            if (firstElementName.Contains("."))
            {
                if (string.Equals(firstElementName, container.FullName(), StringComparison.OrdinalIgnoreCase))
                {
                    if (pathSegments.Length > 1)
                    {
                        // NS.Default/Customers/ContainedOrders
                        firstElementName = pathSegments[1];
                        nextIndex = 2;
                    }
                    else
                    {
                        // if path only includes the namespace, for example "NS.Default", just return null;
                        return null;
                    }
                }
                else
                {
                    // NS.Default.Customers/ContainedOrders
                    // Split the first item using "." and fetch the last segment.
                    firstElementName = pathSegments[0].Split('.').Last();
                }
            }

            // Starting segment must be a singleton or entity set
            IEdmNavigationSource navigationSource = container.FindEntitySet(firstElementName);

            if (navigationSource == null)
            {
                navigationSource = container.FindSingleton(firstElementName);
            }

            // Subsequent segments may be single-valued complex or containment nav props
            List<string> subPathSegments = new List<string>();
            for (int i = nextIndex; i < pathSegments.Length && navigationSource != null; i++)
            {
                subPathSegments.Add(pathSegments[i]);

                if (navigationSource.EntityType().FindProperty(pathSegments[i]) is IEdmNavigationProperty navProp)
                {
                    navigationSource = navigationSource.FindNavigationTarget(navProp, new EdmPathExpression(subPathSegments));
                    subPathSegments.Clear();
                }
            }

            return navigationSource;
        }

        /// <summary>
        /// Searches for singleton by the given name that may be container qualified in default container and .Extends containers. If no container name is provided, then default container will be searched.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The name which might be container qualified. If no container name is provided, then default container will be searched.</param>
        /// <returns>The singleton found or empty if none found.</returns>
        internal static IEdmSingleton FindSingletonExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindSingleton(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Searches for the operation imports by the specified name in default container and .Extends containers, returns an empty enumerable if no operation import exists.
        /// </summary>
        /// <param name="container">The container to search.</param>
        /// <param name="qualifiedName">The qualified name of the operation import which may or may not include the container name.</param>
        /// <returns>All operation imports that can be found by the specified name, returns an empty enumerable if no operation import exists.</returns>
        internal static IEnumerable<IEdmOperationImport> FindOperationImportsExtended(this IEdmEntityContainer container, string qualifiedName)
        {
            return FindInContainerAndExtendsRecursively(container, qualifiedName, (c, n) => c.FindOperationImports(n), ContainerExtendsMaxDepth);
        }

        /// <summary>
        /// Get the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The type definition.</param>
        /// <returns>The primitive value converter for the type definition.</returns>
        internal static IPrimitiveValueConverter GetPrimitiveValueConverter(this IEdmModel model, IEdmType typeDefinition)
        {
            Debug.Assert(model != null, "model != null");
            Debug.Assert(typeDefinition != null, "typeDefinition must be provided");

            // If the model does not have primitive value converter map yet, use the pass-through implementation.
            var converter = model.GetAnnotationValue<IPrimitiveValueConverter>(typeDefinition, EdmConstants.InternalUri, CsdlConstants.PrimitiveValueConverterMapAnnotation);
            if (converter == null)
            {
                return PassThroughPrimitiveValueConverter.Instance;
            }

            return converter;
        }

        /// <summary>
        /// Set the primitive value converter for the given type definition in the model.
        /// </summary>
        /// <param name="model">The model involved.</param>
        /// <param name="typeDefinition">The type definition.</param>
        /// <param name="converter">The primitive value converter for the type definition.</param>
        internal static void SetPrimitiveValueConverter(this IEdmModel model, IEdmType typeDefinition, IPrimitiveValueConverter converter)
        {
            Debug.Assert(model != null, "model != null");
            Debug.Assert(typeDefinition != null, "typeDefinition must be provided");
            Debug.Assert(converter != null, "converter != null");

            model.SetAnnotationValue(typeDefinition, EdmConstants.InternalUri, CsdlConstants.PrimitiveValueConverterMapAnnotation, converter);
        }

        internal static bool TryGetStaticEntitySet(this IEdmPathExpression pathExpression, IEdmModel model, out IEdmEntitySetBase entitySet)
        {
            var segmentIterator = pathExpression.PathSegments.GetEnumerator();
            if (!segmentIterator.MoveNext())
            {
                entitySet = null;
                return false;
            }

            IEdmEntityContainer container;
            var segment = segmentIterator.Current;
            if (segment.Contains("."))
            {
                // The first segment is the qualified name of an entity container.
                container = model.FindEntityContainer(segment);

                if (segmentIterator.MoveNext())
                {
                    segment = segmentIterator.Current;
                }
                else
                {
                    // Path that only contains an entity container is invalid.
                    entitySet = null;
                    return false;
                }
            }
            else
            {
                // No entity container specified. Use the default one from model.
                container = model.EntityContainer;
            }

            if (container == null)
            {
                entitySet = null;
                return false;
            }

            // The next segment must be entity set.
            var resolvedEntitySet = container.FindEntitySet(segment);

            // If there is any segment left, the path must represent a contained entity set.
            entitySet = segmentIterator.MoveNext() ? null : resolvedEntitySet;
            return entitySet != null;
        }

        /// <summary>
        /// Returns true if there is any element in the list or collections.
        /// It tries to cast to list first and then an array, this method will be performant if the callers of this extension method implement IEnumerable through lists.
        /// </summary>
        /// <typeparam name="T">The testing value type.</typeparam>
        /// <param name="enumerable">the testing enumerable.</param>
        /// <returns>ture/false.</returns>
        internal static bool HasAny<T>(this IEnumerable<T> enumerable) where T : class
        {
            if (enumerable is IList<T> list)
            {
                return list.Count > 0;
            }

            if (enumerable is T[] array)
            {
                return array.Length > 0;
            }

            if (enumerable != null)
            {
                return enumerable.GetEnumerator().MoveNext();
            }

            return false;
        }

        /// <summary>
        /// Gets the declared alternate keys of the most defined entity with a declared key present.
        /// </summary>
        /// <param name="type">Reference to the calling object.</param>
        /// <param name="model">The model to be used.</param>
        /// <returns>Alternate Keys of this type.</returns>
        private static IEnumerable<IDictionary<string, IEdmProperty>> GetDeclaredAlternateKeysForType(IEdmEntityType type, IEdmModel model)
        {
            IEdmVocabularyAnnotation annotationValue = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(type, AlternateKeysVocabularyModel.AlternateKeysTerm).FirstOrDefault();

            if (annotationValue != null)
            {
                List<IDictionary<string, IEdmProperty>> declaredAlternateKeys = new List<IDictionary<string, IEdmProperty>>();
                Debug.Assert(annotationValue.Value is IEdmCollectionExpression keys, "expected IEdmCollectionExpression for alternate key annotation value");

                foreach (IEdmRecordExpression key in keys.Elements.OfType<IEdmRecordExpression>())
                {
                    var edmPropertyConstructor = key.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.AlternateKeyTypeKeyPropertyName);
                    if (edmPropertyConstructor != null)
                    {
                        Debug.Assert(edmPropertyConstructor.Value is IEdmCollectionExpression collectionExpression, "expected IEdmCollectionExpression type for Key Property");

                        IDictionary<string, IEdmProperty> alternateKey = new Dictionary<string, IEdmProperty>();
                        foreach (IEdmRecordExpression propertyRef in collectionExpression.Elements.OfType<IEdmRecordExpression>())
                        {
                            var aliasProp = propertyRef.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.PropertyRefTypeAliasPropertyName);
                            Debug.Assert(aliasProp != null, "expected non null Alias Property");
                            string alias = ((IEdmStringConstantExpression)aliasProp.Value).Value;

                            var nameProp = propertyRef.Properties.FirstOrDefault(e => e.Name == AlternateKeysVocabularyConstants.PropertyRefTypeNamePropertyName);
                            Debug.Assert(nameProp != null, "expected non null Name Property");
                            string propertyName = ((IEdmPathExpression)nameProp.Value).PathSegments.FirstOrDefault();

                            alternateKey[alias] = type.FindProperty(propertyName);
                        }

                        if (alternateKey.Any())
                        {
                            declaredAlternateKeys.Add(alternateKey);
                        }
                    }
                }

                return declaredAlternateKeys;
            }

            return null;
        }

        private static T FindAcrossModels<T, TInput>(this IEdmModel model, TInput qualifiedName, Func<IEdmModel, TInput, T> finder, Func<T, T, T> ambiguousCreator)
        {
            T candidate = finder(model, qualifiedName);

            foreach (IEdmModel reference in model.ReferencedModels)
            {
                T fromReference = finder(reference, qualifiedName);
                if (fromReference != null)
                {
                    candidate = candidate == null ? fromReference : ambiguousCreator(candidate, fromReference);
                }
            }

            return candidate;
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmEntityType contextType, IEdmTerm term, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(contextType, term, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnType(contextType.ToTraceString(), term.ToTraceString()));
            }

            return evaluator(annotations.Single().Value, context, term.Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmStructuredValue context, IEdmEntityType contextType, string termName, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(contextType, termName, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnType(contextType.ToTraceString(), termName));
            }

            IEdmVocabularyAnnotation valueAnnotation = annotations.Single();
            return evaluator(valueAnnotation.Value, context, valueAnnotation.Term().Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, IEdmTerm term, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(element, term, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnElement(term.ToTraceString()));
            }

            return evaluator(annotations.Single().Value, null, term.Type);
        }

        private static T GetTermValue<T>(this IEdmModel model, IEdmVocabularyAnnotatable element, string termName, string qualifier, Func<IEdmExpression, IEdmStructuredValue, IEdmTypeReference, T> evaluator)
        {
            IEnumerable<IEdmVocabularyAnnotation> annotations = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(element, termName, qualifier);

            if (annotations.Count() != 1)
            {
                throw new InvalidOperationException(Edm.Strings.Edm_Evaluator_NoValueAnnotationOnElement(termName));
            }

            IEdmVocabularyAnnotation valueAnnotation = annotations.Single();
            return evaluator(valueAnnotation.Value, null, valueAnnotation.Term().Type);
        }

        /// <summary>
        /// Search entity set or singleton or operation import in container and its extended containers.
        /// </summary>
        /// <typeparam name="T">The IEdmEntityContainerElement derived type.</typeparam>
        /// <param name="container">The IEdmEntityContainer object, can be CsdlSemanticsEntityContainer.</param>
        /// <param name="simpleName">A simple (not fully qualified) entity set name, singleton name, operation import name or path.</param>
        /// <param name="finderFunc">The func to do the search within container.</param>
        /// <param name="depth">The recursive depth of .Extends containers to search.</param>
        /// <returns>The found entity set or singleton or operation import.</returns>
        private static T FindInContainerAndExtendsRecursively<T>(IEdmEntityContainer container, string simpleName, Func<IEdmEntityContainer, string, T> finderFunc, int depth)
        {
            Debug.Assert(finderFunc != null, "finderFunc!=null");
            EdmUtil.CheckArgumentNull(container, "container");
            if (depth <= 0)
            {
                // TODO: p2 add a new string resource for the error message
                throw new InvalidOperationException(Edm.Strings.Bad_CyclicEntityContainer(container.FullName()));
            }

            T ret = finderFunc(container, simpleName);
            if (ret == null || ret is IEnumerable<IEdmOperationImport> operations && !operations.HasAny())
            {
                // for CsdlSemanticsEntityContainer, try searching .Extends container :
                // (after IEdmModel has public Extends property, don't need to check CsdlSemanticsEntityContainer)
                CsdlSemanticsEntityContainer tmp = container as CsdlSemanticsEntityContainer;
                if (tmp?.Extends != null)
                {
                    return FindInContainerAndExtendsRecursively(tmp.Extends, simpleName, finderFunc, --depth);
                }
            }

            return ret;
        }

        private static T AnnotationValue<T>(object annotation) where T : class
        {
            if (annotation != null)
            {
                if (annotation is T specificAnnotation)
                {
                    return specificAnnotation;
                }

                if (annotation is IEdmValue valueAnnotation)
                {
                    // [EdmLib] AnnotationValue extension method should use the Clr converter to map annotation value to T.
                }

                throw new InvalidOperationException(Edm.Strings.Annotations_TypeMismatch(annotation.GetType().Name, typeof(T).Name));
            }

            return null;
        }

        private static void DerivedFrom(this IEdmModel model, IEdmStructuredType baseType, HashSetInternal<IEdmStructuredType> visited, List<IEdmStructuredType> derivedTypes)
        {
            if (visited.Add(baseType))
            {
                IEnumerable<IEdmStructuredType> candidates = model.FindDirectlyDerivedTypes(baseType);
                if (candidates != null && candidates.HasAny())
                {
                    foreach (IEdmStructuredType derivedType in candidates)
                    {
                        derivedTypes.Add(derivedType);
                        model.DerivedFrom(derivedType, visited, derivedTypes);
                    }
                }

                foreach (IEdmModel referenced in model.ReferencedModels)
                {
                    candidates = referenced.FindDirectlyDerivedTypes(baseType);
                    if (candidates != null && candidates.HasAny())
                    {
                        foreach (IEdmStructuredType derivedType in candidates)
                        {
                            derivedTypes.Add(derivedType);
                            model.DerivedFrom(derivedType, visited, derivedTypes);
                        }
                    }
                }
            }
        }

        private static void SetChangeTrackingAnnotationImplementation(this EdmModel model, IEdmVocabularyAnnotatable target, bool isSupported, IEnumerable<IEdmStructuralProperty> filterableProperties, IEnumerable<IEdmNavigationProperty> expandableProperties)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(target, "target");

            if (filterableProperties == null)
            {
                filterableProperties = EmptyStructuralProperties;
            }

            if (expandableProperties == null)
            {
                expandableProperties = EmptyNavigationProperties;
            }

            IList<IEdmPropertyConstructor> properties = new List<IEdmPropertyConstructor>
            {
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingSupported, new EdmBooleanConstant(isSupported)),
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingFilterableProperties, new EdmCollectionExpression(filterableProperties.Select(p => new EdmPropertyPathExpression(p.Name)).ToArray())),
                new EdmPropertyConstructor(CapabilitiesVocabularyConstants.ChangeTrackingExpandableProperties, new EdmCollectionExpression(expandableProperties.Select(p => new EdmNavigationPropertyPathExpression(p.Name)).ToArray()))
            };

            IEdmRecordExpression record = new EdmRecordExpression(properties);
            IEdmTerm term = CapabilitiesVocabularyModel.ChangeTrackingTerm;

            Debug.Assert(term != null, "term!=null");
            EdmVocabularyAnnotation annotation = new EdmVocabularyAnnotation(target, term, record);
            annotation.SetSerializationLocation(model, EdmVocabularyAnnotationSerializationLocation.Inline);
            model.SetVocabularyAnnotation(annotation);
        }

        private static IEdmTypeDefinitionReference GetUIntImplementation(this EdmModel model, string namespaceName, string name, string underlyingType, bool isNullable)
        {
            EdmUtil.CheckArgumentNull(model, "model");
            EdmUtil.CheckArgumentNull(namespaceName, "namespaceName");

            Debug.Assert(!string.IsNullOrEmpty(name), "name must be provided");

            string qualifiedName = String.Format(CultureInfo.InvariantCulture, "{0}.{1}", namespaceName, name);

            // If the user has already defined his own UInt TypeDefinition, we don't define ours anymore.
            var type = model.FindDeclaredType(qualifiedName) as IEdmTypeDefinition;
            if (type == null)
            {
                type = new EdmTypeDefinition(namespaceName, name, EdmCoreModel.Instance.GetPrimitiveTypeKind(underlyingType));

                model.AddElement(type);

                model.SetPrimitiveValueConverter(type, DefaultPrimitiveValueConverter.Instance);
            }

            var typeReference = new EdmTypeDefinitionReference(type, isNullable);

            return typeReference;
        }

        internal static class TypeName<T>
        {
            // Use the name of the type as its local name for annotations.
            // Filter out special characters to produce a valid name:
            // '.'                      Appears in qualified names.
            // '`', '[', ']', ','       Appear in generic instantiations.
            // '+'                      Appears in names of local classes.
            public static readonly string LocalName = typeof(T).ToString().Replace("_", "_____").Replace('.', '_').Replace("[", "").Replace("]", "").Replace(",", "__").Replace("`", "___").Replace("+", "____");
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs(11,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs(211,54): error CS0136: A local or parameter named 'typeElement' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs(3243,54): error CS0165: Use of unassigned local variable 'keys',D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs(3251,70): error CS0165: Use of unassigned local variable 'collectionExpression',D:\a\1\s\src\Microsoft.OData.Edm\ExtensionMethods\ExtensionMethods.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Validation\DuplicateOperationValidator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.Edm.Validation
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;

    internal class DuplicateOperationValidator
    {
        private readonly HashSetInternal<string> functionsParameterNameHash = new HashSetInternal<string>();
        private readonly HashSetInternal<string> functionsParameterTypeHash = new HashSetInternal<string>();
        private readonly HashSetInternal<string> actionsNameHash = new HashSetInternal<string>();

        private readonly ValidationContext context;

        internal DuplicateOperationValidator(ValidationContext context)
        {
            this.context = context;
        }

        public static bool IsDuplicateOperation(IEdmOperation operation, IEnumerable<IEdmOperation> candidateDuplicateOperations)
        {
            var validator = new DuplicateOperationValidator(null);
            foreach (var candidateOperation in candidateDuplicateOperations)
            {
                validator.ValidateNotDuplicate(candidateOperation, true /*skipError*/);
            }

            return validator.ValidateNotDuplicate(operation, true /*skipError*/);
        }

        public bool ValidateNotDuplicate(IEdmOperation operation, bool skipError)
        {
            bool duplicate = false;
            string fullName = operation.FullName();
            var function = operation as IEdmFunction;
            if (function != null)
            {
                var uniqueFunctionParameterName = BuildInternalUniqueParameterNameFunctionString(function);
                if (functionsParameterNameHash.Contains(uniqueFunctionParameterName))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            function.Location(),
                            EdmErrorCode.DuplicateFunctions,
                            function.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundFunctionParameterNames(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundFunctionsParameterNames(fullName));
                    }
                }
                else
                {
                    functionsParameterNameHash.Add(uniqueFunctionParameterName);
                }

                var uniqueFunctionParameterType = BuildInternalUniqueParameterTypeFunctionString(function);
                if (functionsParameterTypeHash.Contains(uniqueFunctionParameterType))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            function.Location(),
                            EdmErrorCode.DuplicateFunctions,
                            function.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundFunctionParameterTypes(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundFunctionsParameterTypes(fullName));
                    }
                }
                else
                {
                    functionsParameterTypeHash.Add(uniqueFunctionParameterType);
                }
            }
            else
            {
                var action = operation as IEdmAction;
                Debug.Assert(action != null, "action should not be null");
                var uniqueActionName = BuildInternalUniqueActionString(action);
                if (actionsNameHash.Contains(uniqueActionName))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            action.Location(),
                            EdmErrorCode.DuplicateActions,
                            action.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundActions(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundActions(fullName));
                    }
                }
                else
                {
                    actionsNameHash.Add(uniqueActionName);
                }
            }

            return duplicate;
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to find duplicates of functions.
        /// - The combination of function name, binding parameter type, and unordered set of non-binding parameter names MUST be unique within a namespace.
        /// - An unbound function MAY have the same name as a bound function. (Note this is why IsBound is added into the string)
        /// </summary>
        /// <param name="function">function to create the hash for.</param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueParameterNameFunctionString(IEdmFunction function)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(function.IsBound);
            builder.Append("-");
            builder.Append(function.Namespace);
            builder.Append("-");
            builder.Append(function.Name);
            builder.Append("-");
            if (!function.Parameters.Any())
            {
                return builder.ToString();
            }

            if (function.IsBound)
            {
                IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
                builder.Append(bindingParameter.Type.FullName());
                builder.Append("-");
                foreach (IEdmOperationParameter parameter in function.Parameters.Skip(1).OrderBy(p => p.Name))
                {
                    builder.Append(parameter.Name);
                    builder.Append("-");
                }
            }
            else
            {
                foreach (IEdmOperationParameter parameter in function.Parameters.OrderBy(p => p.Name))
                {
                    builder.Append(parameter.Name);
                    builder.Append("-");
                }
            }

            return builder.ToString();
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to validate duplicates of functions. Rules this is validating
        /// - The combination of function name, binding parameter type, and ordered set of parameter types MUST be unique within a namespace.
        /// - An unbound function MAY have the same name as a bound function. (Note this is why IsBound is added into the string)
        /// </summary>
        /// <param name="function">function to use to create the hash. </param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueParameterTypeFunctionString(IEdmFunction function)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(function.IsBound);
            builder.Append("-");
            builder.Append(function.Namespace);
            builder.Append("-");
            builder.Append(function.Name);
            builder.Append("-");

            foreach (IEdmOperationParameter parameter in function.Parameters)
            {
                builder.Append(parameter.Type.FullName());
                builder.Append("-");
            }

            return builder.ToString();
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to find duplicates of functions.
        /// - Bound actions support overloading (multiple actions having the same name within the same namespace) by binding parameter type. The combination of action name and the binding parameter type MUST be unique within a namespace.
        /// - Unbound actions do not support overloads. The names of all unbound actions MUST be unique within a namespace. An unbound action MAY have the same name as a bound action.
        /// </summary>
        /// <param name="action">action to build the hash from.</param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueActionString(IEdmAction action)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(action.IsBound);
            builder.Append("-");
            builder.Append(action.Namespace);
            builder.Append("-");
            builder.Append(action.Name);
            builder.Append("-");
            if (!action.Parameters.Any())
            {
                return builder.ToString();
            }

            if (action.IsBound)
            {
                IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
                builder.Append(bindingParameter.Type.FullName());
            }

            return builder.ToString();
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.Edm.Validation
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Text;

    internal class DuplicateOperationValidator
    {
        private readonly HashSetInternal<string> functionsParameterNameHash = new HashSetInternal<string>();
        private readonly HashSetInternal<string> functionsParameterTypeHash = new HashSetInternal<string>();
        private readonly HashSetInternal<string> actionsNameHash = new HashSetInternal<string>();

        private readonly ValidationContext context;

        internal DuplicateOperationValidator(ValidationContext context)
        {
            this.context = context;
        }

        public static bool IsDuplicateOperation(IEdmOperation operation, IEnumerable<IEdmOperation> candidateDuplicateOperations)
        {
            var validator = new DuplicateOperationValidator(null);
            foreach (var candidateOperation in candidateDuplicateOperations)
            {
                validator.ValidateNotDuplicate(candidateOperation, true /*skipError*/);
            }

            return validator.ValidateNotDuplicate(operation, true /*skipError*/);
        }

        public bool ValidateNotDuplicate(IEdmOperation operation, bool skipError)
        {
            bool duplicate = false;
            string fullName = operation.FullName();

            if (operation is IEdmFunction function)
            {
                var uniqueFunctionParameterName = BuildInternalUniqueParameterNameFunctionString(function);
                if (functionsParameterNameHash.Contains(uniqueFunctionParameterName))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            function.Location(),
                            EdmErrorCode.DuplicateFunctions,
                            function.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundFunctionParameterNames(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundFunctionsParameterNames(fullName));
                    }
                }
                else
                {
                    functionsParameterNameHash.Add(uniqueFunctionParameterName);
                }

                var uniqueFunctionParameterType = BuildInternalUniqueParameterTypeFunctionString(function);
                if (functionsParameterTypeHash.Contains(uniqueFunctionParameterType))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            function.Location(),
                            EdmErrorCode.DuplicateFunctions,
                            function.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundFunctionParameterTypes(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundFunctionsParameterTypes(fullName));
                    }
                }
                else
                {
                    functionsParameterTypeHash.Add(uniqueFunctionParameterType);
                }
            }
            else
            {
                Debug.Assert(operation is IEdmAction action, "action should not be null");
                var uniqueActionName = BuildInternalUniqueActionString(action);
                if (actionsNameHash.Contains(uniqueActionName))
                {
                    duplicate = true;
                    if (!skipError)
                    {
                        this.context.AddError(
                            action.Location(),
                            EdmErrorCode.DuplicateActions,
                            action.IsBound ? Strings.EdmModel_Validator_Semantic_ModelDuplicateBoundActions(fullName) : Strings.EdmModel_Validator_Semantic_ModelDuplicateUnBoundActions(fullName));
                    }
                }
                else
                {
                    actionsNameHash.Add(uniqueActionName);
                }
            }

            return duplicate;
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to find duplicates of functions.
        /// - The combination of function name, binding parameter type, and unordered set of non-binding parameter names MUST be unique within a namespace.
        /// - An unbound function MAY have the same name as a bound function. (Note this is why IsBound is added into the string)
        /// </summary>
        /// <param name="function">function to create the hash for.</param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueParameterNameFunctionString(IEdmFunction function)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(function.IsBound);
            builder.Append("-");
            builder.Append(function.Namespace);
            builder.Append("-");
            builder.Append(function.Name);
            builder.Append("-");
            if (!function.Parameters.Any())
            {
                return builder.ToString();
            }

            if (function.IsBound)
            {
                IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
                builder.Append(bindingParameter.Type.FullName());
                builder.Append("-");
                foreach (IEdmOperationParameter parameter in function.Parameters.Skip(1).OrderBy(p => p.Name))
                {
                    builder.Append(parameter.Name);
                    builder.Append("-");
                }
            }
            else
            {
                foreach (IEdmOperationParameter parameter in function.Parameters.OrderBy(p => p.Name))
                {
                    builder.Append(parameter.Name);
                    builder.Append("-");
                }
            }

            return builder.ToString();
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to validate duplicates of functions. Rules this is validating
        /// - The combination of function name, binding parameter type, and ordered set of parameter types MUST be unique within a namespace.
        /// - An unbound function MAY have the same name as a bound function. (Note this is why IsBound is added into the string)
        /// </summary>
        /// <param name="function">function to use to create the hash. </param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueParameterTypeFunctionString(IEdmFunction function)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(function.IsBound);
            builder.Append("-");
            builder.Append(function.Namespace);
            builder.Append("-");
            builder.Append(function.Name);
            builder.Append("-");

            foreach (IEdmOperationParameter parameter in function.Parameters)
            {
                builder.Append(parameter.Type.FullName());
                builder.Append("-");
            }

            return builder.ToString();
        }

        /// <summary>
        /// Creates a unique function name based on the type. Used to find duplicates of functions.
        /// - Bound actions support overloading (multiple actions having the same name within the same namespace) by binding parameter type. The combination of action name and the binding parameter type MUST be unique within a namespace.
        /// - Unbound actions do not support overloads. The names of all unbound actions MUST be unique within a namespace. An unbound action MAY have the same name as a bound action.
        /// </summary>
        /// <param name="action">action to build the hash from.</param>
        /// <returns>A unique string that identifies a function.</returns>
        private static string BuildInternalUniqueActionString(IEdmAction action)
        {
            StringBuilder builder = new StringBuilder();
            builder.Append(action.IsBound);
            builder.Append("-");
            builder.Append(action.Namespace);
            builder.Append("-");
            builder.Append(action.Name);
            builder.Append("-");
            if (!action.Parameters.Any())
            {
                return builder.ToString();
            }

            if (action.IsBound)
            {
                IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
                builder.Append(bindingParameter.Type.FullName());
            }

            return builder.ToString();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Validation\DuplicateOperationValidator.cs(82,72): error CS0165: Use of unassigned local variable 'action'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\Annotations\EdmDirectValueAnnotationsManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

namespace Microsoft.OData.Edm.Vocabularies
{
    /// <summary>
    /// Direct-value annotations manager provides services for setting and getting transient annotations on elements.
    /// </summary>
    /// <remarks>
    /// An object representing transient annotations is in one of these states:
    ///    1) Null, if the element has no transient annotations.
    ///    2) An EdmVocabularyAnnotation, if the element has exactly one annotation.
    ///    3) A list of EdmVocabularyAnnotation, if the element has more than one annotation.
    /// If the speed of annotation lookup for elements with many annotations becomes a concern, another option
    /// including a dictionary is possible.
    /// </remarks>
    public class EdmDirectValueAnnotationsManager : IEdmDirectValueAnnotationsManager
    {
        /// <summary>
        /// Keeps track of transient annotations on elements.
        /// </summary>
        private VersioningDictionary<IEdmElement, object> annotationsDictionary;

        /// <summary>
        /// Used for locking during updates to the annotations dictionary;
        /// </summary>
        private object annotationsDictionaryLock = new object();

        /// <summary>
        /// Elements for which normal comparison failed to produce a valid result, arbitrarily ordered to enable stable comparisons.
        /// </summary>
        private VersioningList<IEdmElement> unsortedElements = VersioningList<IEdmElement>.Create();

        /// <summary>
        /// Used for locking during updates to the unsorted elements list.
        /// </summary>
        private object unsortedElementsLock = new object();

        /// <summary>
        /// Initializes a new instance of the <see cref="EdmDirectValueAnnotationsManager"/> class.
        /// </summary>
        public EdmDirectValueAnnotationsManager()
        {
            this.annotationsDictionary = VersioningDictionary<IEdmElement, object>.Create(this.CompareElements);
        }

        /// <summary>
        /// Gets annotations associated with an element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <returns>The immediate annotations for the element.</returns>
        public IEnumerable<IEdmDirectValueAnnotation> GetDirectValueAnnotations(IEdmElement element)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations = this.GetAttachedAnnotations(element);
            object transientAnnotations = GetTransientAnnotations(element, annotationsDictionary);

            if (immutableAnnotations != null)
            {
                foreach (IEdmDirectValueAnnotation existingAnnotation in immutableAnnotations)
                {
                    if (!IsDead(existingAnnotation.NamespaceUri, existingAnnotation.Name, transientAnnotations))
                    {
                        yield return existingAnnotation;
                    }
                }
            }

            foreach (IEdmDirectValueAnnotation existingAnnotation in TransientAnnotations(transientAnnotations))
            {
                yield return existingAnnotation;
            }
        }

        /// <summary>
        /// Sets an annotation value for an EDM element. If the value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Name of the annotation within the namespace.</param>
        /// <param name="value">New annotation to set.</param>
        public void SetAnnotationValue(IEdmElement element, string namespaceName, string localName, object value)
        {
            lock (this.annotationsDictionaryLock)
            {
                // Use a local variable to store any interim changes to the annotations dictionary, and perform one atomic update
                // to the field. Otherwise, other threads could see a dictionary in an interim state.
                VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;
                this.SetAnnotationValue(element, namespaceName, localName, value, ref annotationsDictionary);

                this.annotationsDictionary = annotationsDictionary;
            }
        }

        /// <summary>
        /// Sets a set of annotation values. If a supplied value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="annotations">The annotations to set</param>
        public void SetAnnotationValues(IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            lock (this.annotationsDictionaryLock)
            {
                // Use a local variable to store any interim changes to the annotations dictionary, and perform one atomic update
                // to the field. Otherwise, other threads could see a dictionary in an interim state.
                VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

                foreach (IEdmDirectValueAnnotationBinding annotation in annotations)
                {
                    this.SetAnnotationValue(annotation.Element, annotation.NamespaceUri, annotation.Name, annotation.Value, ref annotationsDictionary);
                }

                this.annotationsDictionary = annotationsDictionary;
            }
        }

        /// <summary>
        /// Retrieves an annotation value for an EDM element. Returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Local name of the annotation.</param>
        /// <returns>Returns the annotation that corresponds to the provided name. Returns null if no annotation with the given name exists for the given element.</returns>
        public object GetAnnotationValue(IEdmElement element, string namespaceName, string localName)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            return this.GetAnnotationValue(element, namespaceName, localName, annotationsDictionary);
        }

        /// <summary>
        /// Retrieves a set of annotation values. For each requested value, returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="annotations">The set of requested annotations</param>
        /// <returns>Returns values that correspond to the provided annotations. A value is null if no annotation with the given name exists for the given element.</returns>
        public object[] GetAnnotationValues(IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            object[] values = new object[annotations.Count()];

            int index = 0;
            foreach (IEdmDirectValueAnnotationBinding annotation in annotations)
            {
                values[index++] = this.GetAnnotationValue(annotation.Element, annotation.NamespaceUri, annotation.Name, annotationsDictionary);
            }

            return values;
        }

        /// <summary>
        /// Retrieves the annotations that are directly attached to an element.
        /// </summary>
        /// <param name="element">The element in question.</param>
        /// <returns>The annotations that are directly attached to an element (outside the control of the manager).</returns>
        protected virtual IEnumerable<IEdmDirectValueAnnotation> GetAttachedAnnotations(IEdmElement element)
        {
            return null;
        }

        private static void SetAnnotation(IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations, ref object transientAnnotations, string namespaceName, string localName, object value)
        {
            bool needTombstone = false;
            if (immutableAnnotations != null)
            {
                if (immutableAnnotations.Any(existingAnnotation => existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName))
                {
                    needTombstone = true;
                }
            }

            if (value == null)
            {
                // "Removing" an immutable annotation leaves behind a transient annotation with a null value
                // as a tombstone to hide the immutable annotation. The normal logic below makes this happen.
                // Removing a transient annotation actually takes the annotation away.
                if (!needTombstone)
                {
                    RemoveTransientAnnotation(ref transientAnnotations, namespaceName, localName);
                    return;
                }
            }

            IEdmDirectValueAnnotation newAnnotation = value != null ?
                new EdmDirectValueAnnotation(namespaceName, localName, value) :
                new EdmDirectValueAnnotation(namespaceName, localName);

            if (transientAnnotations == null)
            {
                transientAnnotations = newAnnotation;
                return;
            }

            IEdmDirectValueAnnotation singleAnnotation = transientAnnotations as IEdmDirectValueAnnotation;
            if (singleAnnotation != null)
            {
                if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                {
                    transientAnnotations = newAnnotation;
                }
                else
                {
                    transientAnnotations = VersioningList<IEdmDirectValueAnnotation>.Create().Add(singleAnnotation).Add(newAnnotation);
                }

                return;
            }

            VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
            for (int index = 0; index < annotationsList.Count; index++)
            {
                IEdmDirectValueAnnotation existingAnnotation = annotationsList[index];
                if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                {
                    annotationsList = annotationsList.RemoveAt(index);
                    break;
                }
            }

            transientAnnotations = annotationsList.Add(newAnnotation);
        }

        private static IEdmDirectValueAnnotation FindTransientAnnotation(object transientAnnotations, string namespaceName, string localName)
        {
            if (transientAnnotations != null)
            {
                IEdmDirectValueAnnotation singleAnnotation = transientAnnotations as IEdmDirectValueAnnotation;
                if (singleAnnotation != null)
                {
                    if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                    {
                        return singleAnnotation;
                    }
                }
                else
                {
                    VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
                    return annotationsList.FirstOrDefault(
                        existingAnnotation => existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName);
                }
            }

            return null;
        }

        private static void RemoveTransientAnnotation(ref object transientAnnotations, string namespaceName, string localName)
        {
            if (transientAnnotations != null)
            {
                IEdmDirectValueAnnotation singleAnnotation = transientAnnotations as IEdmDirectValueAnnotation;
                if (singleAnnotation != null)
                {
                    if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                    {
                        transientAnnotations = null;
                        return;
                    }
                }
                else
                {
                    VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
                    for (int index = 0; index < annotationsList.Count; index++)
                    {
                        IEdmDirectValueAnnotation existingAnnotation = annotationsList[index];
                        if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                        {
                            annotationsList = annotationsList.RemoveAt(index);
                            if (annotationsList.Count == 1)
                            {
                                transientAnnotations = annotationsList.Single();
                            }
                            else
                            {
                                transientAnnotations = annotationsList;
                            }

                            return;
                        }
                    }
                }
            }
        }

        private static IEnumerable<IEdmDirectValueAnnotation> TransientAnnotations(object transientAnnotations)
        {
            if (transientAnnotations == null)
            {
                yield break;
            }

            IEdmDirectValueAnnotation singleAnnotation = transientAnnotations as IEdmDirectValueAnnotation;
            if (singleAnnotation != null)
            {
                if (singleAnnotation.Value != null)
                {
                    yield return singleAnnotation;
                }

                yield break;
            }

            VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
            foreach (IEdmDirectValueAnnotation existingAnnotation in annotationsList)
            {
                if (existingAnnotation.Value != null)
                {
                    yield return existingAnnotation;
                }
            }
        }

        private static bool IsDead(string namespaceName, string localName, object transientAnnotations)
        {
            return FindTransientAnnotation(transientAnnotations, namespaceName, localName) != null;
        }

        /// <summary>
        /// Retrieves the transient annotations for an EDM element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="annotationsDictionary">The dictionary for looking up the element's annotations.</param>
        /// <returns>The transient annotations for the element, in a form managed by the annotations manager.</returns>
        /// <remarks>This method is static to guarantee that the annotations dictionary is not fetched more than once per lookup operation.</remarks>
        private static object GetTransientAnnotations(IEdmElement element, VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            object transientAnnotations;
            annotationsDictionary.TryGetValue(element, out transientAnnotations);
            return transientAnnotations;
        }

        private void SetAnnotationValue(IEdmElement element, string namespaceName, string localName, object value, ref VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            object transientAnnotations = GetTransientAnnotations(element, annotationsDictionary);
            object transientAnnotationsBeforeSet = transientAnnotations;
            SetAnnotation(this.GetAttachedAnnotations(element), ref transientAnnotations, namespaceName, localName, value);

            // There is at least one case (removing an annotation that was not present to begin with) where the transient annotations are not changed,
            // so test to see if updating the dictionary is necessary.
            if (transientAnnotations != transientAnnotationsBeforeSet)
            {
                annotationsDictionary = annotationsDictionary.Set(element, transientAnnotations);
            }
        }

        private object GetAnnotationValue(IEdmElement element, string namespaceName, string localName, VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            IEdmDirectValueAnnotation annotation = FindTransientAnnotation(GetTransientAnnotations(element, annotationsDictionary), namespaceName, localName);
            if (annotation != null)
            {
                return annotation.Value;
            }

            IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations = this.GetAttachedAnnotations(element);
            if (immutableAnnotations != null)
            {
                foreach (IEdmDirectValueAnnotation existingAnnotation in immutableAnnotations)
                {
                    if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                    {
                        // No need to check that the immutable annotation isn't Dead, because if it were
                        // the tombstone would have been found in the transient annotations.
                        return existingAnnotation.Value;
                    }
                }
            }

            return null;
        }

        private int CompareElements(IEdmElement left, IEdmElement right)
        {
            if (left == right)
            {
                return 0;
            }

            /* Left and right are distinct. */

            int leftHash = left.GetHashCode();
            int rightHash = right.GetHashCode();

            if (leftHash < rightHash)
            {
                return -1;
            }

            if (leftHash > rightHash)
            {
                return 1;
            }

            /* Left and right are distinct and have identical hash codes. */

            IEdmNamedElement leftNamed = left as IEdmNamedElement;
            IEdmNamedElement rightNamed = right as IEdmNamedElement;

            if (leftNamed == null)
            {
                if (rightNamed != null)
                {
                    return -1;
                }
            }
            else if (rightNamed == null)
            {
                return 1;
            }
            else
            {
                /* Left and right are both named. */

                int nameComparison = string.Compare(leftNamed.Name, rightNamed.Name, StringComparison.Ordinal);

                if (nameComparison != 0)
                {
                    return nameComparison;
                }
            }

            /* Left and right are distinct, have identical hash codes, and have identical names. */

            /* The first element to occur in the unsorted list is the greatest. */

            while (true)
            {
                foreach (IEdmElement element in this.unsortedElements)
                {
                    if (element == left)
                    {
                        return 1;
                    }

                    if (element == right)
                    {
                        return -1;
                    }
                }

                lock (this.unsortedElementsLock)
                {
                    this.unsortedElements = this.unsortedElements.Add(left);
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

namespace Microsoft.OData.Edm.Vocabularies
{
    /// <summary>
    /// Direct-value annotations manager provides services for setting and getting transient annotations on elements.
    /// </summary>
    /// <remarks>
    /// An object representing transient annotations is in one of these states:
    ///    1) Null, if the element has no transient annotations.
    ///    2) An EdmVocabularyAnnotation, if the element has exactly one annotation.
    ///    3) A list of EdmVocabularyAnnotation, if the element has more than one annotation.
    /// If the speed of annotation lookup for elements with many annotations becomes a concern, another option
    /// including a dictionary is possible.
    /// </remarks>
    public class EdmDirectValueAnnotationsManager : IEdmDirectValueAnnotationsManager
    {
        /// <summary>
        /// Keeps track of transient annotations on elements.
        /// </summary>
        private VersioningDictionary<IEdmElement, object> annotationsDictionary;

        /// <summary>
        /// Used for locking during updates to the annotations dictionary;
        /// </summary>
        private object annotationsDictionaryLock = new object();

        /// <summary>
        /// Elements for which normal comparison failed to produce a valid result, arbitrarily ordered to enable stable comparisons.
        /// </summary>
        private VersioningList<IEdmElement> unsortedElements = VersioningList<IEdmElement>.Create();

        /// <summary>
        /// Used for locking during updates to the unsorted elements list.
        /// </summary>
        private object unsortedElementsLock = new object();

        /// <summary>
        /// Initializes a new instance of the <see cref="EdmDirectValueAnnotationsManager"/> class.
        /// </summary>
        public EdmDirectValueAnnotationsManager()
        {
            this.annotationsDictionary = VersioningDictionary<IEdmElement, object>.Create(this.CompareElements);
        }

        /// <summary>
        /// Gets annotations associated with an element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <returns>The immediate annotations for the element.</returns>
        public IEnumerable<IEdmDirectValueAnnotation> GetDirectValueAnnotations(IEdmElement element)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations = this.GetAttachedAnnotations(element);
            object transientAnnotations = GetTransientAnnotations(element, annotationsDictionary);

            if (immutableAnnotations != null)
            {
                foreach (IEdmDirectValueAnnotation existingAnnotation in immutableAnnotations)
                {
                    if (!IsDead(existingAnnotation.NamespaceUri, existingAnnotation.Name, transientAnnotations))
                    {
                        yield return existingAnnotation;
                    }
                }
            }

            foreach (IEdmDirectValueAnnotation existingAnnotation in TransientAnnotations(transientAnnotations))
            {
                yield return existingAnnotation;
            }
        }

        /// <summary>
        /// Sets an annotation value for an EDM element. If the value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Name of the annotation within the namespace.</param>
        /// <param name="value">New annotation to set.</param>
        public void SetAnnotationValue(IEdmElement element, string namespaceName, string localName, object value)
        {
            lock (this.annotationsDictionaryLock)
            {
                // Use a local variable to store any interim changes to the annotations dictionary, and perform one atomic update
                // to the field. Otherwise, other threads could see a dictionary in an interim state.
                VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;
                this.SetAnnotationValue(element, namespaceName, localName, value, ref annotationsDictionary);

                this.annotationsDictionary = annotationsDictionary;
            }
        }

        /// <summary>
        /// Sets a set of annotation values. If a supplied value is null, no annotation is added and an existing annotation with the same name is removed.
        /// </summary>
        /// <param name="annotations">The annotations to set</param>
        public void SetAnnotationValues(IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            lock (this.annotationsDictionaryLock)
            {
                // Use a local variable to store any interim changes to the annotations dictionary, and perform one atomic update
                // to the field. Otherwise, other threads could see a dictionary in an interim state.
                VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

                foreach (IEdmDirectValueAnnotationBinding annotation in annotations)
                {
                    this.SetAnnotationValue(annotation.Element, annotation.NamespaceUri, annotation.Name, annotation.Value, ref annotationsDictionary);
                }

                this.annotationsDictionary = annotationsDictionary;
            }
        }

        /// <summary>
        /// Retrieves an annotation value for an EDM element. Returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="namespaceName">Namespace that the annotation belongs to.</param>
        /// <param name="localName">Local name of the annotation.</param>
        /// <returns>Returns the annotation that corresponds to the provided name. Returns null if no annotation with the given name exists for the given element.</returns>
        public object GetAnnotationValue(IEdmElement element, string namespaceName, string localName)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            return this.GetAnnotationValue(element, namespaceName, localName, annotationsDictionary);
        }

        /// <summary>
        /// Retrieves a set of annotation values. For each requested value, returns null if no annotation with the given name exists for the given element.
        /// </summary>
        /// <param name="annotations">The set of requested annotations</param>
        /// <returns>Returns values that correspond to the provided annotations. A value is null if no annotation with the given name exists for the given element.</returns>
        public object[] GetAnnotationValues(IEnumerable<IEdmDirectValueAnnotationBinding> annotations)
        {
            // Fetch the annotations dictionary once and only once, because this.annotationsDictionary might get updated by another thread.
            VersioningDictionary<IEdmElement, object> annotationsDictionary = this.annotationsDictionary;

            object[] values = new object[annotations.Count()];

            int index = 0;
            foreach (IEdmDirectValueAnnotationBinding annotation in annotations)
            {
                values[index++] = this.GetAnnotationValue(annotation.Element, annotation.NamespaceUri, annotation.Name, annotationsDictionary);
            }

            return values;
        }

        /// <summary>
        /// Retrieves the annotations that are directly attached to an element.
        /// </summary>
        /// <param name="element">The element in question.</param>
        /// <returns>The annotations that are directly attached to an element (outside the control of the manager).</returns>
        protected virtual IEnumerable<IEdmDirectValueAnnotation> GetAttachedAnnotations(IEdmElement element)
        {
            return null;
        }

        private static void SetAnnotation(IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations, ref object transientAnnotations, string namespaceName, string localName, object value)
        {
            bool needTombstone = false;
            if (immutableAnnotations != null)
            {
                if (immutableAnnotations.Any(existingAnnotation => existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName))
                {
                    needTombstone = true;
                }
            }

            if (value == null)
            {
                // "Removing" an immutable annotation leaves behind a transient annotation with a null value
                // as a tombstone to hide the immutable annotation. The normal logic below makes this happen.
                // Removing a transient annotation actually takes the annotation away.
                if (!needTombstone)
                {
                    RemoveTransientAnnotation(ref transientAnnotations, namespaceName, localName);
                    return;
                }
            }

            IEdmDirectValueAnnotation newAnnotation = value != null ?
                new EdmDirectValueAnnotation(namespaceName, localName, value) :
                new EdmDirectValueAnnotation(namespaceName, localName);

            if (transientAnnotations == null)
            {
                transientAnnotations = newAnnotation;
                return;
            }

            if (transientAnnotations is IEdmDirectValueAnnotation singleAnnotation)
            {
                if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                {
                    transientAnnotations = newAnnotation;
                }
                else
                {
                    transientAnnotations = VersioningList<IEdmDirectValueAnnotation>.Create().Add(singleAnnotation).Add(newAnnotation);
                }

                return;
            }

            VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
            for (int index = 0; index < annotationsList.Count; index++)
            {
                IEdmDirectValueAnnotation existingAnnotation = annotationsList[index];
                if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                {
                    annotationsList = annotationsList.RemoveAt(index);
                    break;
                }
            }

            transientAnnotations = annotationsList.Add(newAnnotation);
        }

        private static IEdmDirectValueAnnotation FindTransientAnnotation(object transientAnnotations, string namespaceName, string localName)
        {
            if (transientAnnotations != null)
            {
                if (transientAnnotations is IEdmDirectValueAnnotation singleAnnotation)
                {
                    if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                    {
                        return singleAnnotation;
                    }
                }
                else
                {
                    VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
                    return annotationsList.FirstOrDefault(
                        existingAnnotation => existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName);
                }
            }

            return null;
        }

        private static void RemoveTransientAnnotation(ref object transientAnnotations, string namespaceName, string localName)
        {
            if (transientAnnotations != null)
            {
                if (transientAnnotations is IEdmDirectValueAnnotation singleAnnotation)
                {
                    if (singleAnnotation.NamespaceUri == namespaceName && singleAnnotation.Name == localName)
                    {
                        transientAnnotations = null;
                        return;
                    }
                }
                else
                {
                    VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
                    for (int index = 0; index < annotationsList.Count; index++)
                    {
                        IEdmDirectValueAnnotation existingAnnotation = annotationsList[index];
                        if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                        {
                            annotationsList = annotationsList.RemoveAt(index);
                            if (annotationsList.Count == 1)
                            {
                                transientAnnotations = annotationsList.Single();
                            }
                            else
                            {
                                transientAnnotations = annotationsList;
                            }

                            return;
                        }
                    }
                }
            }
        }

        private static IEnumerable<IEdmDirectValueAnnotation> TransientAnnotations(object transientAnnotations)
        {
            if (transientAnnotations == null)
            {
                yield break;
            }

            if (transientAnnotations is IEdmDirectValueAnnotation singleAnnotation)
            {
                if (singleAnnotation.Value != null)
                {
                    yield return singleAnnotation;
                }

                yield break;
            }

            VersioningList<IEdmDirectValueAnnotation> annotationsList = (VersioningList<IEdmDirectValueAnnotation>)transientAnnotations;
            foreach (IEdmDirectValueAnnotation existingAnnotation in annotationsList)
            {
                if (existingAnnotation.Value != null)
                {
                    yield return existingAnnotation;
                }
            }
        }

        private static bool IsDead(string namespaceName, string localName, object transientAnnotations)
        {
            return FindTransientAnnotation(transientAnnotations, namespaceName, localName) != null;
        }

        /// <summary>
        /// Retrieves the transient annotations for an EDM element.
        /// </summary>
        /// <param name="element">The annotated element.</param>
        /// <param name="annotationsDictionary">The dictionary for looking up the element's annotations.</param>
        /// <returns>The transient annotations for the element, in a form managed by the annotations manager.</returns>
        /// <remarks>This method is static to guarantee that the annotations dictionary is not fetched more than once per lookup operation.</remarks>
        private static object GetTransientAnnotations(IEdmElement element, VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            object transientAnnotations;
            annotationsDictionary.TryGetValue(element, out transientAnnotations);
            return transientAnnotations;
        }

        private void SetAnnotationValue(IEdmElement element, string namespaceName, string localName, object value, ref VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            object transientAnnotations = GetTransientAnnotations(element, annotationsDictionary);
            object transientAnnotationsBeforeSet = transientAnnotations;
            SetAnnotation(this.GetAttachedAnnotations(element), ref transientAnnotations, namespaceName, localName, value);

            // There is at least one case (removing an annotation that was not present to begin with) where the transient annotations are not changed,
            // so test to see if updating the dictionary is necessary.
            if (transientAnnotations != transientAnnotationsBeforeSet)
            {
                annotationsDictionary = annotationsDictionary.Set(element, transientAnnotations);
            }
        }

        private object GetAnnotationValue(IEdmElement element, string namespaceName, string localName, VersioningDictionary<IEdmElement, object> annotationsDictionary)
        {
            IEdmDirectValueAnnotation annotation = FindTransientAnnotation(GetTransientAnnotations(element, annotationsDictionary), namespaceName, localName);
            if (annotation != null)
            {
                return annotation.Value;
            }

            IEnumerable<IEdmDirectValueAnnotation> immutableAnnotations = this.GetAttachedAnnotations(element);
            if (immutableAnnotations != null)
            {
                foreach (IEdmDirectValueAnnotation existingAnnotation in immutableAnnotations)
                {
                    if (existingAnnotation.NamespaceUri == namespaceName && existingAnnotation.Name == localName)
                    {
                        // No need to check that the immutable annotation isn't Dead, because if it were
                        // the tombstone would have been found in the transient annotations.
                        return existingAnnotation.Value;
                    }
                }
            }

            return null;
        }

        private int CompareElements(IEdmElement left, IEdmElement right)
        {
            if (left == right)
            {
                return 0;
            }

            /* Left and right are distinct. */

            int leftHash = left.GetHashCode();
            int rightHash = right.GetHashCode();

            if (leftHash < rightHash)
            {
                return -1;
            }

            if (leftHash > rightHash)
            {
                return 1;
            }

            /* Left and right are distinct and have identical hash codes. */

            IEdmNamedElement leftNamed = left as IEdmNamedElement;

            if (leftNamed == null)
            {
                if (right is IEdmNamedElement rightNamed)
                {
                    return -1;
                }
            }
            else if (rightNamed == null)
            {
                return 1;
            }
            else
            {
                /* Left and right are both named. */

                int nameComparison = string.Compare(leftNamed.Name, rightNamed.Name, StringComparison.Ordinal);

                if (nameComparison != 0)
                {
                    return nameComparison;
                }
            }

            /* Left and right are distinct, have identical hash codes, and have identical names. */

            /* The first element to occur in the unsorted list is the greatest. */

            while (true)
            {
                foreach (IEdmElement element in this.unsortedElements)
                {
                    if (element == left)
                    {
                        return 1;
                    }

                    if (element == right)
                    {
                        return -1;
                    }
                }

                lock (this.unsortedElementsLock)
                {
                    this.unsortedElements = this.unsortedElements.Add(left);
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\Annotations\EdmDirectValueAnnotationsManager.cs(409,22): error CS0103: The name 'rightNamed' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Edm\Vocabularies\Annotations\EdmDirectValueAnnotationsManager.cs(417,69): error CS0103: The name 'rightNamed' does not exist in the current context
######################################################################


######################################################################
Nr: 8 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Diagnostics;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.Spatial;
#if ODATA_CLIENT
    using Microsoft.OData;
    using ErrorStrings = Microsoft.OData.Client.Strings;
    using PlatformHelpers = Microsoft.OData.Client.PlatformHelper;
#else
using ErrorStrings = Microsoft.OData.Strings;
using PlatformHelpers = Microsoft.OData.PlatformHelper;
#endif

#if ODATA_CLIENT
namespace Microsoft.OData.Client
#else
namespace Microsoft.OData.Evaluation
#endif
{
    /// <summary>
    /// Class with utility methods to deal with EDM values
    /// </summary>
    internal static class EdmValueUtils
    {
        /// <summary>
        /// Converts a primitive OData value to the corresponding <see cref="IEdmDelayedValue"/>.
        /// </summary>
        /// <param name="primitiveValue">The primitive OData value to convert.</param>
        /// <param name="type">The <see cref="IEdmTypeReference"/> for the primitive value (if available).</param>
        /// <returns>An <see cref="IEdmDelayedValue"/> for the <paramref name="primitiveValue"/>.</returns>
        internal static IEdmDelayedValue ConvertPrimitiveValue(object primitiveValue, IEdmPrimitiveTypeReference type)
        {
            Debug.Assert(primitiveValue != null, "primitiveValue != null");

            if (primitiveValue is Boolean)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Boolean);
                return new EdmBooleanConstant(type, (bool)primitiveValue);
            }

            if (primitiveValue is Byte)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Byte);
                return new EdmIntegerConstant(type, (byte)primitiveValue);
            }

            if (primitiveValue is SByte)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.SByte);
                return new EdmIntegerConstant(type, (sbyte)primitiveValue);
            }

            if (primitiveValue is Int16)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int16);
                return new EdmIntegerConstant(type, (Int16)primitiveValue);
            }

            if (primitiveValue is Int32)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int32);
                return new EdmIntegerConstant(type, (Int32)primitiveValue);
            }

            if (primitiveValue is Int64)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int64);
                return new EdmIntegerConstant(type, (Int64)primitiveValue);
            }

            if (primitiveValue is Decimal)
            {
                var decimalType =
                    (IEdmDecimalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Decimal);
                return new EdmDecimalConstant(decimalType, (decimal)primitiveValue);
            }

            if (primitiveValue is Single)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Single);
                return new EdmFloatingConstant(type, (Single)primitiveValue);
            }

            if (primitiveValue is Double)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Double);
                return new EdmFloatingConstant(type, (Double)primitiveValue);
            }

            var str = primitiveValue as string;
            if (str != null)
            {
                var stringType =
                    (IEdmStringTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.String);
                return new EdmStringConstant(stringType, str);
            }

            return ConvertPrimitiveValueWithoutTypeCode(primitiveValue, type);
        }

        /// <summary>
        /// Gets the clr value of the edm value based on its type.
        /// </summary>
        /// <param name="edmValue">The edm value.</param>
        /// <returns>The clr value</returns>
        internal static object ToClrValue(this IEdmPrimitiveValue edmValue)
        {
            Debug.Assert(edmValue != null, "edmValue != null");
            EdmPrimitiveTypeKind primitiveKind = edmValue.Type.PrimitiveKind();
            switch (edmValue.ValueKind)
            {
                case EdmValueKind.Binary:
                    return ((IEdmBinaryValue)edmValue).Value;

                case EdmValueKind.Boolean:
                    return ((IEdmBooleanValue)edmValue).Value;

                case EdmValueKind.DateTimeOffset:
                    return ((IEdmDateTimeOffsetValue)edmValue).Value;

                case EdmValueKind.Decimal:
                    return ((IEdmDecimalValue)edmValue).Value;

                case EdmValueKind.Guid:
                    return ((IEdmGuidValue)edmValue).Value;

                case EdmValueKind.String:
                    return ((IEdmStringValue)edmValue).Value;

                case EdmValueKind.Duration:
                    return ((IEdmDurationValue)edmValue).Value;

                case EdmValueKind.Floating:
                    return ConvertFloatingValue((IEdmFloatingValue)edmValue, primitiveKind);

                case EdmValueKind.Integer:
                    return ConvertIntegerValue((IEdmIntegerValue)edmValue, primitiveKind);

                case EdmValueKind.Date:
                    return ((IEdmDateValue)edmValue).Value;

                case EdmValueKind.TimeOfDay:
                    return ((IEdmTimeOfDayValue)edmValue).Value;
            }

            throw new ODataException(ErrorStrings.EdmValueUtils_CannotConvertTypeToClrValue(edmValue.ValueKind));
        }

#if !ODATA_CLIENT
        /// <summary>
        /// Tries to get a stream property of the specified name.
        /// </summary>
        /// <param name="entityInstance">The instance of the entity to get the stream property for.</param>
        /// <param name="streamPropertyName">The stream property name to find.</param>
        /// <param name="streamProperty">The stream property found.</param>
        /// <returns>true if the stream property was found or if the stream property name was null (default stream).
        /// false if the stream property doesn't exist.</returns>
        internal static bool TryGetStreamProperty(IEdmStructuredValue entityInstance, string streamPropertyName, out IEdmProperty streamProperty)
        {
            Debug.Assert(entityInstance != null, "entityInstance != null");

            streamProperty = null;
            if (streamPropertyName != null)
            {
                streamProperty = entityInstance.Type.AsEntity().FindProperty(streamPropertyName);
                if (streamProperty == null)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Gets the the CLR value for a primitive property.
        /// </summary>
        /// <param name="structuredValue">The structured value.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <returns>The clr value of the property.</returns>
        internal static object GetPrimitivePropertyClrValue(this IEdmStructuredValue structuredValue, string propertyName)
        {
            Debug.Assert(structuredValue != null, "entityInstance != null");
            IEdmStructuredTypeReference valueType = structuredValue.Type.AsStructured();

            IEdmPropertyValue propertyValue = structuredValue.FindPropertyValue(propertyName);
            if (propertyValue == null)
            {
                throw new ODataException(ErrorStrings.EdmValueUtils_PropertyDoesntExist(valueType.FullName(), propertyName));
            }

            if (propertyValue.Value.ValueKind == EdmValueKind.Null)
            {
                return null;
            }

            IEdmPrimitiveValue primitiveValue = propertyValue.Value as IEdmPrimitiveValue;
            if (primitiveValue == null)
            {
                throw new ODataException(ErrorStrings.EdmValueUtils_NonPrimitiveValue(propertyValue.Name, valueType.FullName()));
            }

            return primitiveValue.ToClrValue();
        }
#endif

        /// <summary>
        /// Converts a floating-point edm value to a clr value
        /// </summary>
        /// <param name="floatingValue">The edm floating-point value.</param>
        /// <param name="primitiveKind">Kind of the primitive.</param>
        /// <returns>The converted value</returns>
        private static object ConvertFloatingValue(IEdmFloatingValue floatingValue, EdmPrimitiveTypeKind primitiveKind)
        {
            Debug.Assert(floatingValue != null, "floatingValue != null");
            double doubleValue = floatingValue.Value;

            if (primitiveKind == EdmPrimitiveTypeKind.Single)
            {
                return Convert.ToSingle(doubleValue);
            }

            Debug.Assert(primitiveKind == EdmPrimitiveTypeKind.Double, "primitiveKind == EdmPrimitiveTypeKind.Double");
            return doubleValue;
        }

        /// <summary>
        /// Converts an integer edm value to a clr value.
        /// </summary>
        /// <param name="integerValue">The integer value.</param>
        /// <param name="primitiveKind">Kind of the primitive.</param>
        /// <returns>The converted value</returns>
        private static object ConvertIntegerValue(IEdmIntegerValue integerValue, EdmPrimitiveTypeKind primitiveKind)
        {
            Debug.Assert(integerValue != null, "integerValue != null");
            long longValue = integerValue.Value;

            switch (primitiveKind)
            {
                case EdmPrimitiveTypeKind.Int16:
                    return Convert.ToInt16(longValue);

                case EdmPrimitiveTypeKind.Int32:
                    return Convert.ToInt32(longValue);

                case EdmPrimitiveTypeKind.Byte:
                    return Convert.ToByte(longValue);

                case EdmPrimitiveTypeKind.SByte:
                    return Convert.ToSByte(longValue);

                default:
                    Debug.Assert(primitiveKind == EdmPrimitiveTypeKind.Int64, "primitiveKind == EdmPrimitiveTypeKind.Int64");
                    return longValue;
            }
        }

        /// <summary>
        /// Convert a primitive value which didn't match any of the known values of the TypeCode enumeration.
        /// </summary>
        /// <param name="primitiveValue">The value to convert.</param>
        /// <param name="type">The expected primitive type or null.</param>
        /// <returns>The converted value.</returns>
        private static IEdmDelayedValue ConvertPrimitiveValueWithoutTypeCode(object primitiveValue, IEdmPrimitiveTypeReference type)
        {
            byte[] bytes = primitiveValue as byte[];
            if (bytes != null)
            {
                IEdmBinaryTypeReference binaryType = (IEdmBinaryTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Binary);
                return new EdmBinaryConstant(binaryType, bytes);
            }

            if (primitiveValue is Date)
            {
                IEdmPrimitiveTypeReference dateType = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Date);
                return new EdmDateConstant(dateType, (Date)primitiveValue);
            }

            if (primitiveValue is DateTimeOffset)
            {
                IEdmTemporalTypeReference dateTimeOffsetType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.DateTimeOffset);
                return new EdmDateTimeOffsetConstant(dateTimeOffsetType, (DateTimeOffset)primitiveValue);
            }

            if (primitiveValue is Guid)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Guid);
                return new EdmGuidConstant(type, (Guid)primitiveValue);
            }

            if (primitiveValue is TimeOfDay)
            {
                IEdmTemporalTypeReference timeOfDayType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.TimeOfDay);
                return new EdmTimeOfDayConstant(timeOfDayType, (TimeOfDay)primitiveValue);
            }

            if (primitiveValue is TimeSpan)
            {
                IEdmTemporalTypeReference timeType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Duration);
                return new EdmDurationConstant(timeType, (TimeSpan)primitiveValue);
            }

            if (primitiveValue is ISpatial)
            {
                // TODO: [JsonLight] Add support for spatial values in ODataEdmStructuredValue
                throw new NotImplementedException();
            }

#if ODATA_CLIENT
            IEdmDelayedValue convertPrimitiveValueWithoutTypeCode;
            if (TryConvertClientSpecificPrimitiveValue(primitiveValue, type, out convertPrimitiveValueWithoutTypeCode))
            {
                return convertPrimitiveValueWithoutTypeCode;
            }
#endif

            throw new ODataException(ErrorStrings.EdmValueUtils_UnsupportedPrimitiveType(primitiveValue.GetType().FullName));
        }

#if ODATA_CLIENT
        /// <summary>
        /// Tries to convert the given value if it is of a type specific to the client library but still able to be mapped to EDM.
        /// </summary>
        /// <param name="primitiveValue">The value to convert.</param>
        /// <param name="type">The expected type of the value or null.</param>
        /// <param name="convertedValue">The converted value, if conversion was possible.</param>
        /// <returns>Whether or not conversion was possible.</returns>
        private static bool TryConvertClientSpecificPrimitiveValue(object primitiveValue, IEdmPrimitiveTypeReference type, out IEdmDelayedValue convertedValue)
        {
            byte[] byteArray;
            if (ClientConvert.TryConvertBinaryToByteArray(primitiveValue, out byteArray))
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Binary);
                convertedValue = new EdmBinaryConstant((IEdmBinaryTypeReference)type, byteArray);
                return true;
            }

            PrimitiveType clientPrimitiveType;
            if (PrimitiveType.TryGetPrimitiveType(primitiveValue.GetType(), out clientPrimitiveType))
            {
                type = EnsurePrimitiveType(type, clientPrimitiveType.PrimitiveKind);
                if (clientPrimitiveType.PrimitiveKind == EdmPrimitiveTypeKind.String)
                {
                    {
                        convertedValue = new EdmStringConstant((IEdmStringTypeReference)type, clientPrimitiveType.TypeConverter.ToString(primitiveValue));
                        return true;
                    }
                }
            }

            convertedValue = null;
            return false;
        }
#endif

        /// <summary>
        /// Ensures a primitive type reference for a given primitive type kind.
        /// </summary>
        /// <param name="type">The possibly null type reference.</param>
        /// <param name="primitiveKindFromValue">The primitive type kind to ensure.</param>
        /// <returns>An <see cref="IEdmPrimitiveTypeReference"/> instance created for the <paramref name="primitiveKindFromValue"/>
        /// if <paramref name="type"/> is null; if <paramref name="type"/> is not null, validates it and then returns it.</returns>
        private static IEdmPrimitiveTypeReference EnsurePrimitiveType(IEdmPrimitiveTypeReference type, EdmPrimitiveTypeKind primitiveKindFromValue)
        {
            if (type == null)
            {
                type = EdmCoreModel.Instance.GetPrimitive(primitiveKindFromValue, /*isNullable*/ true);
            }
            else
            {
                EdmPrimitiveTypeKind primitiveKindFromType = type.PrimitiveDefinition().PrimitiveKind;

                if (primitiveKindFromType != primitiveKindFromValue)
                {
                    string typeName = type.FullName();
                    if (typeName == null)
                    {
                        throw new ODataException(ErrorStrings.EdmValueUtils_IncorrectPrimitiveTypeKindNoTypeName(primitiveKindFromType.ToString(), primitiveKindFromValue.ToString()));
                    }

                    throw new ODataException(ErrorStrings.EdmValueUtils_IncorrectPrimitiveTypeKind(typeName, primitiveKindFromValue.ToString(), primitiveKindFromType.ToString()));
                }
            }

            return type;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Diagnostics;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.Spatial;
#if ODATA_CLIENT
    using Microsoft.OData;
    using ErrorStrings = Microsoft.OData.Client.Strings;
    using PlatformHelpers = Microsoft.OData.Client.PlatformHelper;
#else
using ErrorStrings = Microsoft.OData.Strings;
using PlatformHelpers = Microsoft.OData.PlatformHelper;
#endif

#if ODATA_CLIENT
namespace Microsoft.OData.Client
#else
namespace Microsoft.OData.Evaluation
#endif
{
    /// <summary>
    /// Class with utility methods to deal with EDM values
    /// </summary>
    internal static class EdmValueUtils
    {
        /// <summary>
        /// Converts a primitive OData value to the corresponding <see cref="IEdmDelayedValue"/>.
        /// </summary>
        /// <param name="primitiveValue">The primitive OData value to convert.</param>
        /// <param name="type">The <see cref="IEdmTypeReference"/> for the primitive value (if available).</param>
        /// <returns>An <see cref="IEdmDelayedValue"/> for the <paramref name="primitiveValue"/>.</returns>
        internal static IEdmDelayedValue ConvertPrimitiveValue(object primitiveValue, IEdmPrimitiveTypeReference type)
        {
            Debug.Assert(primitiveValue != null, "primitiveValue != null");

            if (primitiveValue is Boolean)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Boolean);
                return new EdmBooleanConstant(type, (bool)primitiveValue);
            }

            if (primitiveValue is Byte)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Byte);
                return new EdmIntegerConstant(type, (byte)primitiveValue);
            }

            if (primitiveValue is SByte)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.SByte);
                return new EdmIntegerConstant(type, (sbyte)primitiveValue);
            }

            if (primitiveValue is Int16 i)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int16);
                return new EdmIntegerConstant(type, i);
            }

            if (primitiveValue is Int32 i)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int32);
                return new EdmIntegerConstant(type, i);
            }

            if (primitiveValue is Int64 i)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Int64);
                return new EdmIntegerConstant(type, i);
            }

            if (primitiveValue is Decimal)
            {
                var decimalType =
                    (IEdmDecimalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Decimal);
                return new EdmDecimalConstant(decimalType, (decimal)primitiveValue);
            }

            if (primitiveValue is Single single)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Single);
                return new EdmFloatingConstant(type, single);
            }

            if (primitiveValue is Double d)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Double);
                return new EdmFloatingConstant(type, d);
            }

            var str = primitiveValue as string;
            if (str != null)
            {
                var stringType =
                    (IEdmStringTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.String);
                return new EdmStringConstant(stringType, str);
            }

            return ConvertPrimitiveValueWithoutTypeCode(primitiveValue, type);
        }

        /// <summary>
        /// Gets the clr value of the edm value based on its type.
        /// </summary>
        /// <param name="edmValue">The edm value.</param>
        /// <returns>The clr value</returns>
        internal static object ToClrValue(this IEdmPrimitiveValue edmValue)
        {
            Debug.Assert(edmValue != null, "edmValue != null");
            EdmPrimitiveTypeKind primitiveKind = edmValue.Type.PrimitiveKind();
            switch (edmValue.ValueKind)
            {
                case EdmValueKind.Binary:
                    return ((IEdmBinaryValue)edmValue).Value;

                case EdmValueKind.Boolean:
                    return ((IEdmBooleanValue)edmValue).Value;

                case EdmValueKind.DateTimeOffset:
                    return ((IEdmDateTimeOffsetValue)edmValue).Value;

                case EdmValueKind.Decimal:
                    return ((IEdmDecimalValue)edmValue).Value;

                case EdmValueKind.Guid:
                    return ((IEdmGuidValue)edmValue).Value;

                case EdmValueKind.String:
                    return ((IEdmStringValue)edmValue).Value;

                case EdmValueKind.Duration:
                    return ((IEdmDurationValue)edmValue).Value;

                case EdmValueKind.Floating:
                    return ConvertFloatingValue((IEdmFloatingValue)edmValue, primitiveKind);

                case EdmValueKind.Integer:
                    return ConvertIntegerValue((IEdmIntegerValue)edmValue, primitiveKind);

                case EdmValueKind.Date:
                    return ((IEdmDateValue)edmValue).Value;

                case EdmValueKind.TimeOfDay:
                    return ((IEdmTimeOfDayValue)edmValue).Value;
            }

            throw new ODataException(ErrorStrings.EdmValueUtils_CannotConvertTypeToClrValue(edmValue.ValueKind));
        }

#if !ODATA_CLIENT
        /// <summary>
        /// Tries to get a stream property of the specified name.
        /// </summary>
        /// <param name="entityInstance">The instance of the entity to get the stream property for.</param>
        /// <param name="streamPropertyName">The stream property name to find.</param>
        /// <param name="streamProperty">The stream property found.</param>
        /// <returns>true if the stream property was found or if the stream property name was null (default stream).
        /// false if the stream property doesn't exist.</returns>
        internal static bool TryGetStreamProperty(IEdmStructuredValue entityInstance, string streamPropertyName, out IEdmProperty streamProperty)
        {
            Debug.Assert(entityInstance != null, "entityInstance != null");

            streamProperty = null;
            if (streamPropertyName != null)
            {
                streamProperty = entityInstance.Type.AsEntity().FindProperty(streamPropertyName);
                if (streamProperty == null)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Gets the the CLR value for a primitive property.
        /// </summary>
        /// <param name="structuredValue">The structured value.</param>
        /// <param name="propertyName">Name of the property.</param>
        /// <returns>The clr value of the property.</returns>
        internal static object GetPrimitivePropertyClrValue(this IEdmStructuredValue structuredValue, string propertyName)
        {
            Debug.Assert(structuredValue != null, "entityInstance != null");
            IEdmStructuredTypeReference valueType = structuredValue.Type.AsStructured();

            IEdmPropertyValue propertyValue = structuredValue.FindPropertyValue(propertyName);
            if (propertyValue == null)
            {
                throw new ODataException(ErrorStrings.EdmValueUtils_PropertyDoesntExist(valueType.FullName(), propertyName));
            }

            if (propertyValue.Value.ValueKind == EdmValueKind.Null)
            {
                return null;
            }

            IEdmPrimitiveValue primitiveValue = propertyValue.Value as IEdmPrimitiveValue;
            if (primitiveValue == null)
            {
                throw new ODataException(ErrorStrings.EdmValueUtils_NonPrimitiveValue(propertyValue.Name, valueType.FullName()));
            }

            return primitiveValue.ToClrValue();
        }
#endif

        /// <summary>
        /// Converts a floating-point edm value to a clr value
        /// </summary>
        /// <param name="floatingValue">The edm floating-point value.</param>
        /// <param name="primitiveKind">Kind of the primitive.</param>
        /// <returns>The converted value</returns>
        private static object ConvertFloatingValue(IEdmFloatingValue floatingValue, EdmPrimitiveTypeKind primitiveKind)
        {
            Debug.Assert(floatingValue != null, "floatingValue != null");
            double doubleValue = floatingValue.Value;

            if (primitiveKind == EdmPrimitiveTypeKind.Single)
            {
                return Convert.ToSingle(doubleValue);
            }

            Debug.Assert(primitiveKind == EdmPrimitiveTypeKind.Double, "primitiveKind == EdmPrimitiveTypeKind.Double");
            return doubleValue;
        }

        /// <summary>
        /// Converts an integer edm value to a clr value.
        /// </summary>
        /// <param name="integerValue">The integer value.</param>
        /// <param name="primitiveKind">Kind of the primitive.</param>
        /// <returns>The converted value</returns>
        private static object ConvertIntegerValue(IEdmIntegerValue integerValue, EdmPrimitiveTypeKind primitiveKind)
        {
            Debug.Assert(integerValue != null, "integerValue != null");
            long longValue = integerValue.Value;

            switch (primitiveKind)
            {
                case EdmPrimitiveTypeKind.Int16:
                    return Convert.ToInt16(longValue);

                case EdmPrimitiveTypeKind.Int32:
                    return Convert.ToInt32(longValue);

                case EdmPrimitiveTypeKind.Byte:
                    return Convert.ToByte(longValue);

                case EdmPrimitiveTypeKind.SByte:
                    return Convert.ToSByte(longValue);

                default:
                    Debug.Assert(primitiveKind == EdmPrimitiveTypeKind.Int64, "primitiveKind == EdmPrimitiveTypeKind.Int64");
                    return longValue;
            }
        }

        /// <summary>
        /// Convert a primitive value which didn't match any of the known values of the TypeCode enumeration.
        /// </summary>
        /// <param name="primitiveValue">The value to convert.</param>
        /// <param name="type">The expected primitive type or null.</param>
        /// <returns>The converted value.</returns>
        private static IEdmDelayedValue ConvertPrimitiveValueWithoutTypeCode(object primitiveValue, IEdmPrimitiveTypeReference type)
        {
            byte[] bytes = primitiveValue as byte[];
            if (bytes != null)
            {
                IEdmBinaryTypeReference binaryType = (IEdmBinaryTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Binary);
                return new EdmBinaryConstant(binaryType, bytes);
            }

            if (primitiveValue is Date date)
            {
                IEdmPrimitiveTypeReference dateType = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Date);
                return new EdmDateConstant(dateType, date);
            }

            if (primitiveValue is DateTimeOffset dateTimeOffset)
            {
                IEdmTemporalTypeReference dateTimeOffsetType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.DateTimeOffset);
                return new EdmDateTimeOffsetConstant(dateTimeOffsetType, dateTimeOffset);
            }

            if (primitiveValue is Guid guid)
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Guid);
                return new EdmGuidConstant(type, guid);
            }

            if (primitiveValue is TimeOfDay timeOfDay)
            {
                IEdmTemporalTypeReference timeOfDayType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.TimeOfDay);
                return new EdmTimeOfDayConstant(timeOfDayType, timeOfDay);
            }

            if (primitiveValue is TimeSpan timeSpan)
            {
                IEdmTemporalTypeReference timeType = (IEdmTemporalTypeReference)EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Duration);
                return new EdmDurationConstant(timeType, timeSpan);
            }

            if (primitiveValue is ISpatial)
            {
                // TODO: [JsonLight] Add support for spatial values in ODataEdmStructuredValue
                throw new NotImplementedException();
            }

#if ODATA_CLIENT
            IEdmDelayedValue convertPrimitiveValueWithoutTypeCode;
            if (TryConvertClientSpecificPrimitiveValue(primitiveValue, type, out convertPrimitiveValueWithoutTypeCode))
            {
                return convertPrimitiveValueWithoutTypeCode;
            }
#endif

            throw new ODataException(ErrorStrings.EdmValueUtils_UnsupportedPrimitiveType(primitiveValue.GetType().FullName));
        }

#if ODATA_CLIENT
        /// <summary>
        /// Tries to convert the given value if it is of a type specific to the client library but still able to be mapped to EDM.
        /// </summary>
        /// <param name="primitiveValue">The value to convert.</param>
        /// <param name="type">The expected type of the value or null.</param>
        /// <param name="convertedValue">The converted value, if conversion was possible.</param>
        /// <returns>Whether or not conversion was possible.</returns>
        private static bool TryConvertClientSpecificPrimitiveValue(object primitiveValue, IEdmPrimitiveTypeReference type, out IEdmDelayedValue convertedValue)
        {
            byte[] byteArray;
            if (ClientConvert.TryConvertBinaryToByteArray(primitiveValue, out byteArray))
            {
                type = EnsurePrimitiveType(type, EdmPrimitiveTypeKind.Binary);
                convertedValue = new EdmBinaryConstant((IEdmBinaryTypeReference)type, byteArray);
                return true;
            }

            PrimitiveType clientPrimitiveType;
            if (PrimitiveType.TryGetPrimitiveType(primitiveValue.GetType(), out clientPrimitiveType))
            {
                type = EnsurePrimitiveType(type, clientPrimitiveType.PrimitiveKind);
                if (clientPrimitiveType.PrimitiveKind == EdmPrimitiveTypeKind.String)
                {
                    {
                        convertedValue = new EdmStringConstant((IEdmStringTypeReference)type, clientPrimitiveType.TypeConverter.ToString(primitiveValue));
                        return true;
                    }
                }
            }

            convertedValue = null;
            return false;
        }
#endif

        /// <summary>
        /// Ensures a primitive type reference for a given primitive type kind.
        /// </summary>
        /// <param name="type">The possibly null type reference.</param>
        /// <param name="primitiveKindFromValue">The primitive type kind to ensure.</param>
        /// <returns>An <see cref="IEdmPrimitiveTypeReference"/> instance created for the <paramref name="primitiveKindFromValue"/>
        /// if <paramref name="type"/> is null; if <paramref name="type"/> is not null, validates it and then returns it.</returns>
        private static IEdmPrimitiveTypeReference EnsurePrimitiveType(IEdmPrimitiveTypeReference type, EdmPrimitiveTypeKind primitiveKindFromValue)
        {
            if (type == null)
            {
                type = EdmCoreModel.Instance.GetPrimitive(primitiveKindFromValue, /*isNullable*/ true);
            }
            else
            {
                EdmPrimitiveTypeKind primitiveKindFromType = type.PrimitiveDefinition().PrimitiveKind;

                if (primitiveKindFromType != primitiveKindFromValue)
                {
                    string typeName = type.FullName();
                    if (typeName == null)
                    {
                        throw new ODataException(ErrorStrings.EdmValueUtils_IncorrectPrimitiveTypeKindNoTypeName(primitiveKindFromType.ToString(), primitiveKindFromValue.ToString()));
                    }

                    throw new ODataException(ErrorStrings.EdmValueUtils_IncorrectPrimitiveTypeKind(typeName, primitiveKindFromValue.ToString(), primitiveKindFromType.ToString()));
                }
            }

            return type;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs(66,41): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs(72,41): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs(69,53): error CS0165: Use of unassigned local variable 'i',D:\a\1\s\src\Microsoft.OData.Core\Evaluation\EdmValueUtils.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.Evaluation
#endif
#endif
{
#if ODATA_SERVICE
    using System.Data.Linq;
#endif
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Text;
    using System.Linq;
    using System.Xml;
#if ODATA_CORE
    using Microsoft.OData.Edm;
    using Microsoft.Spatial;
#else
    using System.Xml.Linq;
    using Microsoft.OData;
    using Microsoft.OData.Edm;
    using Microsoft.Spatial;
    using ExpressionConstants = XmlConstants;
#endif

    /// <summary>
    /// Component for formatting literals for use in URIs, ETags, and skip-tokens.
    /// </summary>
    internal abstract class LiteralFormatter
    {
        /// <summary>Default singleton instance for parenthetical keys, etags, or skiptokens.</summary>
        private static readonly LiteralFormatter DefaultInstance = new DefaultLiteralFormatter();

#if ODATA_CORE
        /// <summary>Default singleton instance which does not URL-encode the resulting string.</summary>
        private static readonly LiteralFormatter DefaultInstanceWithoutEncoding = new DefaultLiteralFormatter(/*disableUrlEncoding*/ true);
#endif

        /// <summary>Default singleton instance for keys formatted as segments.</summary>
        private static readonly LiteralFormatter KeyAsSegmentInstance = new KeysAsSegmentsLiteralFormatter();

#if ODATA_SERVICE
        /// <summary>
        /// Gets the literal formatter for ETags.
        /// </summary>
        internal static LiteralFormatter ForETag
        {
            get { return DefaultInstance; }
        }

        /// <summary>
        /// Gets the literal formatter for skip-tokens.
        /// </summary>
        internal static LiteralFormatter ForSkipToken
        {
            get { return DefaultInstance; }
        }
#else
        /// <summary>
        /// Gets the literal formatter for URL constants.
        /// </summary>
        internal static LiteralFormatter ForConstants
        {
            get
            {
                return DefaultInstance;
            }
        }
#endif

#if ODATA_CORE
        /// <summary>
        /// Gets the literal formatter for URL constants which does not URL-encode the string.
        /// </summary>
        internal static LiteralFormatter ForConstantsWithoutEncoding
        {
            get
            {
                return DefaultInstanceWithoutEncoding;
            }
        }
#endif

        /// <summary>
        /// Gets the literal formatter for keys.
        /// </summary>
        /// <param name="keysAsSegment">if set to <c>true</c> then the key is going to be written as a segment, rather than in parentheses.</param>
        /// <returns>The literal formatter for keys.</returns>
        internal static LiteralFormatter ForKeys(bool keysAsSegment)
        {
            return keysAsSegment ? KeyAsSegmentInstance : DefaultInstance;
        }

        /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
        /// <param name="value">Non-null value to convert.</param>
        /// <returns>value converted to a serializable string for URI key.</returns>
        internal abstract string Format(object value);

        /// <summary>
        /// Escapes the result according to URI escaping rules.
        /// </summary>
        /// <param name="result">The result to escape.</param>
        /// <returns>The escaped string.</returns>
        protected virtual string EscapeResultForUri(string result)
        {
            // required for strings as data, DateTime for ':', numbers for '+'
            // we specifically do not want to encode leading and trailing "'" wrapping strings/datetime/guid
            return Uri.EscapeDataString(result);
        }

        /// <summary>Converts the given byte[] into string.</summary>
        /// <param name="byteArray">byte[] that needs to be converted.</param>
        /// <returns>String containing hex values representing the byte[].</returns>
        private static string ConvertByteArrayToKeyString(byte[] byteArray)
        {
            Debug.Assert(byteArray != null, "byteArray != null");
            return Convert.ToBase64String(byteArray, 0, byteArray.Length);
        }

        /// <summary>
        /// Formats the literal without a type prefix, quotes, or escaping.
        /// </summary>
        /// <param name="value">The non-null value to format.</param>
        /// <returns>The formatted literal, without type marker or quotes.</returns>
        private static string FormatRawLiteral(object value)
        {
            Debug.Assert(value != null, "value != null");

            string stringValue = value as string;
            if (stringValue != null)
            {
                return stringValue;
            }

            if (value is bool)
            {
                return XmlConvert.ToString((bool)value);
            }

            if (value is byte)
            {
                return XmlConvert.ToString((byte)value);
            }

#if ODATA_SERVICE || ODATA_CLIENT
            if (value is DateTime)
            {
                // Since the server/client supports DateTime values, convert the DateTime value
                // to DateTimeOffset and use XmlConvert to convert to String.
                // If datetime kind is unspecified, then treat it as UTC.
#if ODATA_SERVICE
                DateTimeOffset dto = WebUtil.ConvertDateTimeToDateTimeOffset((DateTime)value);
#elif ODATA_CLIENT
                DateTimeOffset dto = PlatformHelper.ConvertDateTimeToDateTimeOffset((DateTime)value);
#endif

                return XmlConvert.ToString(dto);
            }
#endif

            if (value is decimal)
            {
                return XmlConvert.ToString((decimal)value);
            }

            if (value is double)
            {
                string formattedDouble = XmlConvert.ToString((double)value);
                formattedDouble = SharedUtils.AppendDecimalMarkerToDouble(formattedDouble);
                return formattedDouble;
            }

            if (value is Guid)
            {
                return value.ToString();
            }

            if (value is short)
            {
                return XmlConvert.ToString((Int16)value);
            }

            if (value is int)
            {
                return XmlConvert.ToString((Int32)value);
            }

            if (value is long)
            {
                return XmlConvert.ToString((Int64)value);
            }

            if (value is sbyte)
            {
                return XmlConvert.ToString((SByte)value);
            }

            if (value is float)
            {
                return XmlConvert.ToString((Single)value);
            }

            byte[] array = value as byte[];
            if (array != null)
            {
                return ConvertByteArrayToKeyString(array);
            }

            if (value is Date)
            {
                return value.ToString();
            }

            if (value is DateTimeOffset)
            {
                return XmlConvert.ToString((DateTimeOffset)value);
            }

            if (value is TimeOfDay)
            {
                return value.ToString();
            }

            if (value is TimeSpan)
            {
                return EdmValueWriter.DurationAsXml((TimeSpan)value);
            }

            Geography geography = value as Geography;
            if (geography != null)
            {
                return WellKnownTextSqlFormatter.Create(true).Write(geography);
            }

            Geometry geometry = value as Geometry;
            if (geometry != null)
            {
                return WellKnownTextSqlFormatter.Create(true).Write(geometry);
            }

            ODataEnumValue enumValue = value as ODataEnumValue;
            if (enumValue != null)
            {
                return enumValue.Value;
            }

            throw SharedUtils.CreateExceptionForUnconvertableType(value);
        }

        /// <summary>
        /// Formats the literal without a type prefix or quotes, but does escape it.
        /// </summary>
        /// <param name="value">The non-null value to format.</param>
        /// <returns>The formatted literal, without type marker or quotes.</returns>
        private string FormatAndEscapeLiteral(object value)
        {
            Debug.Assert(value != null, "value != null");

            string result = FormatRawLiteral(value);
            Debug.Assert(result != null, "result != null");

            if (value is string)
            {
                result = result.Replace("'", "''");
            }

            return this.EscapeResultForUri(result);
        }

        /// <summary>
        /// Helper utilities that capture any deltas between ODL, the WCF DS Client, and the WCF DS Server.
        /// </summary>
        private static class SharedUtils
        {
            /// <summary>
            /// Creates a new exception instance to be thrown if the value is not a type that can be formatted as a literal.
            /// DEVNOTE: Will return a different exception depending on whether this is ODataLib, the WCF DS Server, or the WCF DS client.
            /// </summary>
            /// <param name="value">The literal value that could not be converted.</param>
            /// <returns>The exception that should be thrown.</returns>
            internal static InvalidOperationException CreateExceptionForUnconvertableType(object value)
            {
#if ODATA_SERVICE
                return new InvalidOperationException(Microsoft.OData.Service.Strings.Serializer_CannotConvertValue(value));
#endif
#if ODATA_CLIENT
                return Error.InvalidOperation(Client.Strings.Context_CannotConvertKey(value));
#endif
#if ODATA_CORE
                return new ODataException(Strings.ODataUriUtils_ConvertToUriLiteralUnsupportedType(value.GetType().ToString()));
#endif
            }

            /// <summary>
            /// Tries to convert the given value to one of the standard recognized types. Used specifically for handling XML and binary types.
            /// </summary>
            /// <param name="value">The original value.</param>
            /// <param name="converted">The value converted to one of the standard types.</param>
            /// <returns>Whether or not the value was converted.</returns>
            internal static bool TryConvertToStandardType(object value, out object converted)
            {
                byte[] array;
                if (TryGetByteArrayFromBinary(value, out array))
                {
                    converted = array;
                    return true;
                }

#if !ODATA_CORE
                XElement xml = value as XElement;
                if (xml != null)
                {
                    converted = xml.ToString();
                    return true;
                }
#endif
                converted = null;
                return false;
            }

            /// <summary>
            /// Appends the decimal marker to string form of double value if necessary.
            /// DEVNOTE: Only used by the client and ODL, for legacy/back-compat reasons.
            /// </summary>
            /// <param name="input">Input string.</param>
            /// <returns>String with decimal marker optionally added.</returns>
            internal static string AppendDecimalMarkerToDouble(string input)
            {
                // DEVNOTE: for some reason, the client adds .0 to doubles where the server does not.
                // Unfortunately, it would be a breaking change to alter this behavior now.
#if ODATA_CLIENT || ODATA_CORE
                IEnumerable<char> characters = input.ToCharArray();

#if ODATA_CORE
                // negative numbers can also be 'whole', but the client did not take that into account.
                if (input[0] == '-')
                {
                    characters = characters.Skip(1);
                }
#endif
                // a whole number should be all digits.
                if (characters.All(char.IsDigit))
                {
                    return string.Concat(input, ".0");
                }

#endif
                // the server never appended anything, so it will fall through to here.
                return input;
            }

            /// <summary>
            /// Tries to convert an instance of System.Data.Linq.Binary to a byte array.
            /// </summary>
            /// <param name="value">The original value which might be an instance of System.Data.Linq.Binary.</param>
            /// <param name="array">The converted byte array, if it was converted.</param>
            /// <returns>Whether or not the value was converted.</returns>
            [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "value", Justification = "Method is compiled into 3 assemblies, and the parameter is used in 2 of them.")]
            private static bool TryGetByteArrayFromBinary(object value, out byte[] array)
            {
                // DEVNOTE: the client does not have a reference to System.Data.Linq, but the server does.
                // So we need to interact with Binary differently.
#if ODATA_SERVICE
                Binary binary = value as Binary;
                if (binary != null)
                {
                    array = binary.ToArray();
                    return true;
                }
#endif
#if ODATA_CLIENT
                return ClientConvert.TryConvertBinaryToByteArray(value, out array);
#else
                array = null;
                return false;
#endif
            }
        }

        /// <summary>
        /// Default literal formatter implementation.
        /// </summary>
        private sealed class DefaultLiteralFormatter : LiteralFormatter
        {
            /// <summary>If true, literals will not be URL encoded.</summary>
            private readonly bool disableUrlEncoding;

            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            internal DefaultLiteralFormatter()
                : this(false /*disableUrlEncoding*/)
            {
            }

#if ODATA_CORE
            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            /// <param name="disableUrlEncoding">If true, literals will not be URL encoded.</param>
            internal DefaultLiteralFormatter(bool disableUrlEncoding)
#else
            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            /// <param name="disableUrlEncoding">If true, literals will not be URL encoded.</param>
            private DefaultLiteralFormatter(bool disableUrlEncoding)
#endif
            {
                this.disableUrlEncoding = disableUrlEncoding;
            }

            /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
            /// <param name="value">Non-null value to convert.</param>
            /// <returns>value converted to a serializable string for URI key.</returns>
            internal override string Format(object value)
            {
                object converted;
                if (SharedUtils.TryConvertToStandardType(value, out converted))
                {
                    value = converted;
                }

                return this.FormatLiteralWithTypePrefix(value);
            }

            /// <summary>
            /// Escapes the result according to URI escaping rules.
            /// </summary>
            /// <param name="result">The result to escape.</param>
            /// <returns>The escaped string.</returns>
            protected override string EscapeResultForUri(string result)
            {
#if !ODATA_CORE
                Debug.Assert(!this.disableUrlEncoding, "Only supported for ODataLib for backwards compatibility reasons.");
#endif
                if (!this.disableUrlEncoding)
                {
                    result = base.EscapeResultForUri(result);
                }

                return result;
            }

            /// <summary>
            /// Formats the literal with a type prefix and quotes (if the type requires it).
            /// </summary>
            /// <param name="value">The value to format.</param>
            /// <returns>The formatted literal, with type marker if needed.</returns>
            private string FormatLiteralWithTypePrefix(object value)
            {
                Debug.Assert(value != null, "value != null. Null values need to be handled differently in some cases.");

                var enumValue = value as ODataEnumValue;
                if (enumValue != null)
                {
                    if (string.IsNullOrEmpty(enumValue.TypeName))
                    {
                        // TODO: [Sizhong Du] Replace with error string #647.
                        throw new ODataException("Type name should not be null or empty when serializing an Enum value for URI key.");
                    }

                    return string.Concat(enumValue.TypeName, "'", this.FormatAndEscapeLiteral(enumValue.Value), "'");
                }

                string result = this.FormatAndEscapeLiteral(value);

                if (value is byte[])
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixBinary, "'", result, "'");
                }

                if (value is Geography)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixGeography, "'", result, "'");
                }

                if (value is Geometry)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixGeometry, "'", result, "'");
                }

                if (value is TimeSpan)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixDuration, "'", result, "'");
                }

                if (value is string)
                {
                    return string.Concat("'", result, "'");
                }

                // for int32,int64,float,double, decimal, Infinity/NaN, just output them without prefix or suffix such as L/M/D/F.
                return result;
            }
        }

        /// <summary>
        /// Literal formatter for keys which are written as URI segments.
        /// Very similar to the default, but it never puts the type markers or single quotes around the value.
        /// </summary>
        private sealed class KeysAsSegmentsLiteralFormatter : LiteralFormatter
        {
            /// <summary>
            /// Creates a new instance of <see cref="KeysAsSegmentsLiteralFormatter"/>.
            /// </summary>
            internal KeysAsSegmentsLiteralFormatter()
            {
            }

            /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
            /// <param name="value">Non-null value to convert.</param>
            /// <returns>value converted to a serializable string for URI key.</returns>
            internal override string Format(object value)
            {
                Debug.Assert(value != null, "value != null");

                ODataEnumValue enumValue = value as ODataEnumValue;
                if (enumValue != null)
                {
                    value = enumValue.Value;
                }

                object converted;
                if (SharedUtils.TryConvertToStandardType(value, out converted))
                {
                    value = converted;
                }

                string stringValue = value as string;
                if (stringValue != null)
                {
                    value = EscapeLeadingDollarSign(stringValue);
                }

                return FormatAndEscapeLiteral(value);
            }

            /// <summary>
            /// If the string starts with a '$', prepends another '$' to escape it.
            /// </summary>
            /// <param name="stringValue">The string value.</param>
            /// <returns>The string value with a leading '$' escaped, if one was present.</returns>
            private static string EscapeLeadingDollarSign(string stringValue)
            {
                if (stringValue.Length > 0 && stringValue[0] == '$')
                {
                    stringValue = '$' + stringValue;
                }

                return stringValue;
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.Evaluation
#endif
#endif
{
#if ODATA_SERVICE
    using System.Data.Linq;
#endif
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Text;
    using System.Linq;
    using System.Xml;
#if ODATA_CORE
    using Microsoft.OData.Edm;
    using Microsoft.Spatial;
#else
    using System.Xml.Linq;
    using Microsoft.OData;
    using Microsoft.OData.Edm;
    using Microsoft.Spatial;
    using ExpressionConstants = XmlConstants;
#endif

    /// <summary>
    /// Component for formatting literals for use in URIs, ETags, and skip-tokens.
    /// </summary>
    internal abstract class LiteralFormatter
    {
        /// <summary>Default singleton instance for parenthetical keys, etags, or skiptokens.</summary>
        private static readonly LiteralFormatter DefaultInstance = new DefaultLiteralFormatter();

#if ODATA_CORE
        /// <summary>Default singleton instance which does not URL-encode the resulting string.</summary>
        private static readonly LiteralFormatter DefaultInstanceWithoutEncoding = new DefaultLiteralFormatter(/*disableUrlEncoding*/ true);
#endif

        /// <summary>Default singleton instance for keys formatted as segments.</summary>
        private static readonly LiteralFormatter KeyAsSegmentInstance = new KeysAsSegmentsLiteralFormatter();

#if ODATA_SERVICE
        /// <summary>
        /// Gets the literal formatter for ETags.
        /// </summary>
        internal static LiteralFormatter ForETag
        {
            get { return DefaultInstance; }
        }

        /// <summary>
        /// Gets the literal formatter for skip-tokens.
        /// </summary>
        internal static LiteralFormatter ForSkipToken
        {
            get { return DefaultInstance; }
        }
#else
        /// <summary>
        /// Gets the literal formatter for URL constants.
        /// </summary>
        internal static LiteralFormatter ForConstants
        {
            get
            {
                return DefaultInstance;
            }
        }
#endif

#if ODATA_CORE
        /// <summary>
        /// Gets the literal formatter for URL constants which does not URL-encode the string.
        /// </summary>
        internal static LiteralFormatter ForConstantsWithoutEncoding
        {
            get
            {
                return DefaultInstanceWithoutEncoding;
            }
        }
#endif

        /// <summary>
        /// Gets the literal formatter for keys.
        /// </summary>
        /// <param name="keysAsSegment">if set to <c>true</c> then the key is going to be written as a segment, rather than in parentheses.</param>
        /// <returns>The literal formatter for keys.</returns>
        internal static LiteralFormatter ForKeys(bool keysAsSegment)
        {
            return keysAsSegment ? KeyAsSegmentInstance : DefaultInstance;
        }

        /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
        /// <param name="value">Non-null value to convert.</param>
        /// <returns>value converted to a serializable string for URI key.</returns>
        internal abstract string Format(object value);

        /// <summary>
        /// Escapes the result according to URI escaping rules.
        /// </summary>
        /// <param name="result">The result to escape.</param>
        /// <returns>The escaped string.</returns>
        protected virtual string EscapeResultForUri(string result)
        {
            // required for strings as data, DateTime for ':', numbers for '+'
            // we specifically do not want to encode leading and trailing "'" wrapping strings/datetime/guid
            return Uri.EscapeDataString(result);
        }

        /// <summary>Converts the given byte[] into string.</summary>
        /// <param name="byteArray">byte[] that needs to be converted.</param>
        /// <returns>String containing hex values representing the byte[].</returns>
        private static string ConvertByteArrayToKeyString(byte[] byteArray)
        {
            Debug.Assert(byteArray != null, "byteArray != null");
            return Convert.ToBase64String(byteArray, 0, byteArray.Length);
        }

        /// <summary>
        /// Formats the literal without a type prefix, quotes, or escaping.
        /// </summary>
        /// <param name="value">The non-null value to format.</param>
        /// <returns>The formatted literal, without type marker or quotes.</returns>
        private static string FormatRawLiteral(object value)
        {
            Debug.Assert(value != null, "value != null");

            string stringValue = value as string;
            if (stringValue != null)
            {
                return stringValue;
            }

            if (value is bool b)
            {
                return XmlConvert.ToString(b);
            }

            if (value is byte b)
            {
                return XmlConvert.ToString(b);
            }

#if ODATA_SERVICE || ODATA_CLIENT
            if (value is DateTime)
            {
                // Since the server/client supports DateTime values, convert the DateTime value
                // to DateTimeOffset and use XmlConvert to convert to String.
                // If datetime kind is unspecified, then treat it as UTC.
#if ODATA_SERVICE
                DateTimeOffset dto = WebUtil.ConvertDateTimeToDateTimeOffset((DateTime)value);
#elif ODATA_CLIENT
                DateTimeOffset dto = PlatformHelper.ConvertDateTimeToDateTimeOffset((DateTime)value);
#endif

                return XmlConvert.ToString(dto);
            }
#endif

            if (value is decimal d)
            {
                return XmlConvert.ToString(d);
            }

            if (value is double d)
            {
                string formattedDouble = XmlConvert.ToString(d);
                formattedDouble = SharedUtils.AppendDecimalMarkerToDouble(formattedDouble);
                return formattedDouble;
            }

            if (value is Guid)
            {
                return value.ToString();
            }

            if (value is short)
            {
                return XmlConvert.ToString((Int16)value);
            }

            if (value is int)
            {
                return XmlConvert.ToString((Int32)value);
            }

            if (value is long)
            {
                return XmlConvert.ToString((Int64)value);
            }

            if (value is sbyte)
            {
                return XmlConvert.ToString((SByte)value);
            }

            if (value is float)
            {
                return XmlConvert.ToString((Single)value);
            }

            byte[] array = value as byte[];
            if (array != null)
            {
                return ConvertByteArrayToKeyString(array);
            }

            if (value is Date)
            {
                return value.ToString();
            }

            if (value is DateTimeOffset dateTimeOffset)
            {
                return XmlConvert.ToString(dateTimeOffset);
            }

            if (value is TimeOfDay)
            {
                return value.ToString();
            }

            if (value is TimeSpan timeSpan)
            {
                return EdmValueWriter.DurationAsXml(timeSpan);
            }

            Geography geography = value as Geography;
            if (geography != null)
            {
                return WellKnownTextSqlFormatter.Create(true).Write(geography);
            }

            Geometry geometry = value as Geometry;
            if (geometry != null)
            {
                return WellKnownTextSqlFormatter.Create(true).Write(geometry);
            }

            ODataEnumValue enumValue = value as ODataEnumValue;
            if (enumValue != null)
            {
                return enumValue.Value;
            }

            throw SharedUtils.CreateExceptionForUnconvertableType(value);
        }

        /// <summary>
        /// Formats the literal without a type prefix or quotes, but does escape it.
        /// </summary>
        /// <param name="value">The non-null value to format.</param>
        /// <returns>The formatted literal, without type marker or quotes.</returns>
        private string FormatAndEscapeLiteral(object value)
        {
            Debug.Assert(value != null, "value != null");

            string result = FormatRawLiteral(value);
            Debug.Assert(result != null, "result != null");

            if (value is string)
            {
                result = result.Replace("'", "''");
            }

            return this.EscapeResultForUri(result);
        }

        /// <summary>
        /// Helper utilities that capture any deltas between ODL, the WCF DS Client, and the WCF DS Server.
        /// </summary>
        private static class SharedUtils
        {
            /// <summary>
            /// Creates a new exception instance to be thrown if the value is not a type that can be formatted as a literal.
            /// DEVNOTE: Will return a different exception depending on whether this is ODataLib, the WCF DS Server, or the WCF DS client.
            /// </summary>
            /// <param name="value">The literal value that could not be converted.</param>
            /// <returns>The exception that should be thrown.</returns>
            internal static InvalidOperationException CreateExceptionForUnconvertableType(object value)
            {
#if ODATA_SERVICE
                return new InvalidOperationException(Microsoft.OData.Service.Strings.Serializer_CannotConvertValue(value));
#endif
#if ODATA_CLIENT
                return Error.InvalidOperation(Client.Strings.Context_CannotConvertKey(value));
#endif
#if ODATA_CORE
                return new ODataException(Strings.ODataUriUtils_ConvertToUriLiteralUnsupportedType(value.GetType().ToString()));
#endif
            }

            /// <summary>
            /// Tries to convert the given value to one of the standard recognized types. Used specifically for handling XML and binary types.
            /// </summary>
            /// <param name="value">The original value.</param>
            /// <param name="converted">The value converted to one of the standard types.</param>
            /// <returns>Whether or not the value was converted.</returns>
            internal static bool TryConvertToStandardType(object value, out object converted)
            {
                byte[] array;
                if (TryGetByteArrayFromBinary(value, out array))
                {
                    converted = array;
                    return true;
                }

#if !ODATA_CORE
                XElement xml = value as XElement;
                if (xml != null)
                {
                    converted = xml.ToString();
                    return true;
                }
#endif
                converted = null;
                return false;
            }

            /// <summary>
            /// Appends the decimal marker to string form of double value if necessary.
            /// DEVNOTE: Only used by the client and ODL, for legacy/back-compat reasons.
            /// </summary>
            /// <param name="input">Input string.</param>
            /// <returns>String with decimal marker optionally added.</returns>
            internal static string AppendDecimalMarkerToDouble(string input)
            {
                // DEVNOTE: for some reason, the client adds .0 to doubles where the server does not.
                // Unfortunately, it would be a breaking change to alter this behavior now.
#if ODATA_CLIENT || ODATA_CORE
                IEnumerable<char> characters = input.ToCharArray();

#if ODATA_CORE
                // negative numbers can also be 'whole', but the client did not take that into account.
                if (input[0] == '-')
                {
                    characters = characters.Skip(1);
                }
#endif
                // a whole number should be all digits.
                if (characters.All(char.IsDigit))
                {
                    return string.Concat(input, ".0");
                }

#endif
                // the server never appended anything, so it will fall through to here.
                return input;
            }

            /// <summary>
            /// Tries to convert an instance of System.Data.Linq.Binary to a byte array.
            /// </summary>
            /// <param name="value">The original value which might be an instance of System.Data.Linq.Binary.</param>
            /// <param name="array">The converted byte array, if it was converted.</param>
            /// <returns>Whether or not the value was converted.</returns>
            [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "value", Justification = "Method is compiled into 3 assemblies, and the parameter is used in 2 of them.")]
            private static bool TryGetByteArrayFromBinary(object value, out byte[] array)
            {
                // DEVNOTE: the client does not have a reference to System.Data.Linq, but the server does.
                // So we need to interact with Binary differently.
#if ODATA_SERVICE
                Binary binary = value as Binary;
                if (binary != null)
                {
                    array = binary.ToArray();
                    return true;
                }
#endif
#if ODATA_CLIENT
                return ClientConvert.TryConvertBinaryToByteArray(value, out array);
#else
                array = null;
                return false;
#endif
            }
        }

        /// <summary>
        /// Default literal formatter implementation.
        /// </summary>
        private sealed class DefaultLiteralFormatter : LiteralFormatter
        {
            /// <summary>If true, literals will not be URL encoded.</summary>
            private readonly bool disableUrlEncoding;

            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            internal DefaultLiteralFormatter()
                : this(false /*disableUrlEncoding*/)
            {
            }

#if ODATA_CORE
            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            /// <param name="disableUrlEncoding">If true, literals will not be URL encoded.</param>
            internal DefaultLiteralFormatter(bool disableUrlEncoding)
#else
            /// <summary>
            /// Creates a new instance of <see cref="DefaultLiteralFormatter"/>.
            /// </summary>
            /// <param name="disableUrlEncoding">If true, literals will not be URL encoded.</param>
            private DefaultLiteralFormatter(bool disableUrlEncoding)
#endif
            {
                this.disableUrlEncoding = disableUrlEncoding;
            }

            /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
            /// <param name="value">Non-null value to convert.</param>
            /// <returns>value converted to a serializable string for URI key.</returns>
            internal override string Format(object value)
            {
                object converted;
                if (SharedUtils.TryConvertToStandardType(value, out converted))
                {
                    value = converted;
                }

                return this.FormatLiteralWithTypePrefix(value);
            }

            /// <summary>
            /// Escapes the result according to URI escaping rules.
            /// </summary>
            /// <param name="result">The result to escape.</param>
            /// <returns>The escaped string.</returns>
            protected override string EscapeResultForUri(string result)
            {
#if !ODATA_CORE
                Debug.Assert(!this.disableUrlEncoding, "Only supported for ODataLib for backwards compatibility reasons.");
#endif
                if (!this.disableUrlEncoding)
                {
                    result = base.EscapeResultForUri(result);
                }

                return result;
            }

            /// <summary>
            /// Formats the literal with a type prefix and quotes (if the type requires it).
            /// </summary>
            /// <param name="value">The value to format.</param>
            /// <returns>The formatted literal, with type marker if needed.</returns>
            private string FormatLiteralWithTypePrefix(object value)
            {
                Debug.Assert(value != null, "value != null. Null values need to be handled differently in some cases.");

                var enumValue = value as ODataEnumValue;
                if (enumValue != null)
                {
                    if (string.IsNullOrEmpty(enumValue.TypeName))
                    {
                        // TODO: [Sizhong Du] Replace with error string #647.
                        throw new ODataException("Type name should not be null or empty when serializing an Enum value for URI key.");
                    }

                    return string.Concat(enumValue.TypeName, "'", this.FormatAndEscapeLiteral(enumValue.Value), "'");
                }

                string result = this.FormatAndEscapeLiteral(value);

                if (value is byte[])
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixBinary, "'", result, "'");
                }

                if (value is Geography)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixGeography, "'", result, "'");
                }

                if (value is Geometry)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixGeometry, "'", result, "'");
                }

                if (value is TimeSpan)
                {
                    return string.Concat(ExpressionConstants.LiteralPrefixDuration, "'", result, "'");
                }

                if (value is string)
                {
                    return string.Concat("'", result, "'");
                }

                // for int32,int64,float,double, decimal, Infinity/NaN, just output them without prefix or suffix such as L/M/D/F.
                return result;
            }
        }

        /// <summary>
        /// Literal formatter for keys which are written as URI segments.
        /// Very similar to the default, but it never puts the type markers or single quotes around the value.
        /// </summary>
        private sealed class KeysAsSegmentsLiteralFormatter : LiteralFormatter
        {
            /// <summary>
            /// Creates a new instance of <see cref="KeysAsSegmentsLiteralFormatter"/>.
            /// </summary>
            internal KeysAsSegmentsLiteralFormatter()
            {
            }

            /// <summary>Converts the specified value to an encoded, serializable string for URI key.</summary>
            /// <param name="value">Non-null value to convert.</param>
            /// <returns>value converted to a serializable string for URI key.</returns>
            internal override string Format(object value)
            {
                Debug.Assert(value != null, "value != null");

                ODataEnumValue enumValue = value as ODataEnumValue;
                if (enumValue != null)
                {
                    value = enumValue.Value;
                }

                object converted;
                if (SharedUtils.TryConvertToStandardType(value, out converted))
                {
                    value = converted;
                }

                string stringValue = value as string;
                if (stringValue != null)
                {
                    value = EscapeLeadingDollarSign(stringValue);
                }

                return FormatAndEscapeLiteral(value);
            }

            /// <summary>
            /// If the string starts with a '$', prepends another '$' to escape it.
            /// </summary>
            /// <param name="stringValue">The string value.</param>
            /// <returns>The string value with a leading '$' escaped, if one was present.</returns>
            private static string EscapeLeadingDollarSign(string stringValue)
            {
                if (stringValue.Length > 0 && stringValue[0] == '$')
                {
                    stringValue = '$' + stringValue;
                }

                return stringValue;
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(24,5): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(152,31): error CS0128: A local variable or function named 'b' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(178,33): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(154,44): error CS0165: Use of unassigned local variable 'b',D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(180,62): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\src\Microsoft.OData.Core\Evaluation\LiteralFormatter.cs(24,5): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Threading.Tasks;
using Microsoft.OData.Evaluation;
using Microsoft.OData.Json;
using Microsoft.OData.Metadata;
using Microsoft.OData.UriParser;
using Microsoft.OData.Edm;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.JsonLight
{
    /// <summary>
    /// OData reader for the JsonLight format.
    /// </summary>
    internal sealed class ODataJsonLightReader : ODataReaderCoreAsync
    {
        #region private fields
        /// <summary>The input to read the payload from.</summary>
        private readonly ODataJsonLightInputContext jsonLightInputContext;

        /// <summary>The resource and resource set deserializer to read input with.</summary>
        private readonly ODataJsonLightResourceDeserializer jsonLightResourceDeserializer;

        /// <summary>The scope associated with the top level of this payload.</summary>
        private readonly JsonLightTopLevelScope topLevelScope;

        /// <summary>true if the reader is created for reading parameter; false otherwise.</summary>
        private readonly bool readingParameter;
        #endregion private fields

        #region Constructors
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightInputContext">The input to read the payload from.</param>
        /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
        /// <param name="expectedResourceType">The expected structured type for the resource to be read (in case of resource reader) or entries in the resource set to be read (in case of resource set reader).</param>
        /// <param name="readingResourceSet">true if the reader is created for reading a resource set; false when it is created for reading a resource.</param>
        /// <param name="readingParameter">true if the reader is created for reading a parameter; false otherwise.</param>
        /// <param name="readingDelta">true if the reader is created for reading expanded navigation property in delta response; false otherwise.</param>
        /// <param name="listener">If not null, the Json reader will notify the implementer of the interface of relevant state changes in the Json reader.</param>
        internal ODataJsonLightReader(
            ODataJsonLightInputContext jsonLightInputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType expectedResourceType,
            bool readingResourceSet,
            bool readingParameter = false,
            bool readingDelta = false,
            IODataReaderWriterListener listener = null)
            : base(jsonLightInputContext, readingResourceSet, readingDelta, listener)
        {
            Debug.Assert(jsonLightInputContext != null, "jsonLightInputContext != null");
            Debug.Assert(
                expectedResourceType == null || jsonLightInputContext.Model.IsUserModel(),
                "If the expected type is specified we need model as well. We should have verified that by now.");

            this.jsonLightInputContext = jsonLightInputContext;
            this.jsonLightResourceDeserializer = new ODataJsonLightResourceDeserializer(jsonLightInputContext);
            this.readingParameter = readingParameter;
            this.topLevelScope = new JsonLightTopLevelScope(navigationSource, expectedResourceType, new ODataUri());
            this.EnterScope(this.topLevelScope);
        }

        #endregion

        #region private properties

        /// <summary>
        /// Returns the current resource state.
        /// </summary>
        private IODataJsonLightReaderResourceState CurrentResourceState
        {
            get
            {
                Debug.Assert(
                    this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd ||
                    this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                    "This property can only be accessed in the EntryStart or EntryEnd scope.");
                return (IODataJsonLightReaderResourceState)this.CurrentScope;
            }
        }

        /// <summary>
        /// Returns current scope cast to JsonLightResourceSetScope
        /// </summary>
        private JsonLightResourceSetScope CurrentJsonLightResourceSetScope
        {
            get
            {
                return ((JsonLightResourceSetScope)this.CurrentScope);
            }
        }

        /// <summary>
        /// Returns current scope cast to JsonLightNestedResourceInfoScope
        /// </summary>
        private JsonLightNestedResourceInfoScope CurrentJsonLightNestedResourceInfoScope
        {
            get
            {
                return ((JsonLightNestedResourceInfoScope)this.CurrentScope);
            }
        }

        /// <summary>
        /// Returns nest info of current resource.
        /// </summary>
        private ODataNestedResourceInfo ParentNestedInfo
        {
            get
            {
                // NestInfo/Resource or NestInfo/ResourceSet/Resource
                Scope scope = SeekScope<JsonLightNestedResourceInfoScope>(maxDepth: 3);

                return scope != null ? (ODataNestedResourceInfo)scope.Item : null;
            }
        }
        #endregion private properties

        #region ReadAt<>Implementation Methods
        #region ReadAtStartImplementation
        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        protected override bool ReadAtStartImplementation()
        {
            Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
            Debug.Assert(
                this.IsReadingNestedPayload ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.None,
                "Pre-Condition: expected JsonNodeType.None when not reading a nested payload.");

            PropertyAndAnnotationCollector propertyAndAnnotationCollector =
                this.jsonLightInputContext.CreatePropertyAndAnnotationCollector();

            // Position the reader on the first node depending on whether we are reading a nested payload or a Uri Operation Parameter or not.
            ODataPayloadKind payloadKind = this.ReadingResourceSet ?
                this.ReadingDelta ? ODataPayloadKind.Delta : ODataPayloadKind.ResourceSet : ODataPayloadKind.Resource;

            // Following parameter "this.IsReadingNestedPayload || this.readingParameter" indicates whether to read
            // { "value" :
            // or
            // { "parameterName" :
            this.jsonLightResourceDeserializer.ReadPayloadStart(
                payloadKind,
                propertyAndAnnotationCollector,
                this.IsReadingNestedPayload || this.readingParameter,
                /*allowEmptyPayload*/false);

            ResolveScopeInfoFromContextUrl();

            Scope currentScope = this.CurrentScope;
            if (this.jsonLightInputContext.Model.IsUserModel())
            {
                var derivedTypeConstraints = this.jsonLightInputContext.Model.GetDerivedTypeConstraints(currentScope.NavigationSource);
                if (derivedTypeConstraints != null)
                {
                    currentScope.DerivedTypeValidator = new DerivedTypeValidator(currentScope.ResourceType, derivedTypeConstraints, "navigation source", currentScope.NavigationSource.Name);
                }
            }

            return this.ReadAtStartImplementationSynchronously(propertyAndAnnotationCollector);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        protected override Task<bool> ReadAtStartImplementationAsync()
        {
            Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
            Debug.Assert(
                this.IsReadingNestedPayload ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.None,
                "Pre-Condition: expected JsonNodeType.None when not reading a nested payload.");

            PropertyAndAnnotationCollector propertyAndAnnotationCollector =
                this.jsonLightInputContext.CreatePropertyAndAnnotationCollector();

            // Position the reader on the first node depending on whether we are reading a nested payload or not.
            ODataPayloadKind payloadKind = this.ReadingDelta
                ? ODataPayloadKind.Delta
                : this.ReadingResourceSet ?
                    ODataPayloadKind.ResourceSet
                    : ODataPayloadKind.Resource;

            return this.jsonLightResourceDeserializer.ReadPayloadStartAsync(
                payloadKind,
                propertyAndAnnotationCollector,
                this.IsReadingNestedPayload,
                /*allowEmptyPayload*/false)
                .FollowOnSuccessWith(t => ResolveScopeInfoFromContextUrl())
                .FollowOnSuccessWith(t =>
                    this.ReadAtStartImplementationSynchronously(propertyAndAnnotationCollector));
        }

        #endregion ReadAtStartImplementation

        #region ResourceSet
        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override bool ReadAtResourceSetStartImplementation()
        {
            return this.ReadAtResourceSetStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override Task<bool> ReadAtResourceSetStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override bool ReadAtResourceSetEndImplementation()
        {
            return this.ReadAtResourceSetEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override Task<bool> ReadAtResourceSetEndImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetEndImplementationSynchronously);
        }

        #endregion ResourceSet

        #region Resource
        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtResourceStartImplementation()
        {
            return this.ReadAtResourceStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtResourceStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        protected override bool ReadAtResourceEndImplementation()
        {
            return this.ReadAtResourceEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        protected override Task<bool> ReadAtResourceEndImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceEndImplementationSynchronously);
        }

        #endregion Resource

        #region Primitive
        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        protected override bool ReadAtPrimitiveImplementation()
        {
            return this.ReadAtPrimitiveSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        protected override Task<bool> ReadAtPrimitiveImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtPrimitiveSynchronously);
        }

        #endregion Primitive

        #region Property

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected override bool ReadAtNestedPropertyInfoImplementation()
        {
            return this.ReadAtNestedPropertyInfoSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        protected override Task<bool> ReadAtNestedPropertyInfoImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtNestedPropertyInfoSynchronously);
        }

        #endregion

        #region Stream

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected override bool ReadAtStreamImplementation()
        {
            return this.ReadAtStreamSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        protected override Task<bool> ReadAtStreamImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtStreamSynchronously);
        }

        /// <summary>
        /// Creates a stream for reading an inline stream property.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        protected override Stream CreateReadStreamImplementation()
        {
            Stream stream;
            IJsonStreamReader streamReader = this.jsonLightInputContext.JsonReader as IJsonStreamReader;
            if (streamReader != null)
            {
                stream = streamReader.CreateReadStream();
            }
            else
            {
                // JSONReader doesn't support streaming; read as a string and convert
                // Skip over property or start array
                this.jsonLightInputContext.JsonReader.Read();
                string valueAsString = this.jsonLightInputContext.JsonReader.ReadStringValue();
                stream = new MemoryStream(Convert.FromBase64String(valueAsString.Replace('_', '/').Replace('-', '+')));
            }

            return stream;
        }

        protected override TextReader CreateTextReaderImplementation()
        {
            TextReader reader;
            IJsonStreamReader jsonStreamReader = this.jsonLightInputContext.JsonReader as IJsonStreamReader;
            if (jsonStreamReader != null)
            {
                reader = jsonStreamReader.CreateTextReader();
            }
            else
            {
                // JSONReader doesn't support streaming; read as a string and convert
                // Skip over property or start array
                this.jsonLightInputContext.JsonReader.Read();
                string valueAsString = this.jsonLightInputContext.JsonReader.ReadStringValue();
                reader = new StringReader(valueAsString);
            }

            return reader;
        }

        #endregion

        #region NestedResourceInfo
        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// </remarks>
        protected override bool ReadAtNestedResourceInfoStartImplementation()
        {
            return this.ReadAtNestedResourceInfoStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// </remarks>
        protected override Task<bool> ReadAtNestedResourceInfoStartImplementationAsync()
        {
            return
                TaskUtils.GetTaskForSynchronousOperation<bool>(
                    this.ReadAtNestedResourceInfoStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        protected override bool ReadAtNestedResourceInfoEndImplementation()
        {
            return this.ReadAtNestedResourceInfoEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        protected override Task<bool> ReadAtNestedResourceInfoEndImplementationAsync()
        {
            return
                TaskUtils.GetTaskForSynchronousOperation<bool>(
                    this.ReadAtNestedResourceInfoEndImplementationSynchronously);
        }

        #endregion NestedResourceInfo

        #region EntityReferenceLink
        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        protected override bool ReadAtEntityReferenceLink()
        {
            return this.ReadAtEntityReferenceLinkSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        protected override Task<bool> ReadAtEntityReferenceLinkAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtEntityReferenceLinkSynchronously);
        }

        #endregion EntityReferenceLink

        #region DeltaResourceSet

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override bool ReadAtDeltaResourceSetStartImplementation()
        {
            return this.ReadAtResourceSetStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override Task<bool> ReadAtDeltaResourceSetStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override bool ReadAtDeltaResourceSetEndImplementation()
        {
            // Logic is same as for ResourceSet
            return this.ReadAtResourceSetEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override Task<bool> ReadAtDeltaResourceSetEndImplementationAsync()
        {
            // Logic is same as for ResourceSet
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetEndImplementationSynchronously);
        }

        #endregion DeltaResourceSet

        #region DeltaDeletedEntry

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedEntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeletedResourceStartImplementation()
        {
            return this.ReadAtDeletedResourceStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedResourceStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeletedResourceStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeletedResourceStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the deleted resource's end-object node
        /// </remarks>
        protected override bool ReadAtDeletedResourceEndImplementation()
        {
            // Same logic as ReadAtResourceEndImplementation
            return this.ReadAtResourceEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the deleted resource's end-object node
        /// </remarks>
        protected override Task<bool> ReadAtDeletedResourceEndImplementationAsync()
        {
            // Same logic as ReadAtResourceEndImplementationAsync
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceEndImplementationSynchronously);
        }

        #endregion DeltaDeletedEntry

        #region DeltaLink

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndArray               If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeltaLinkImplementation()
        {
            return this.ReadAtDeltaLinkImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeltaLinkImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeltaLinkImplementationSynchronously);
        }

        #endregion DeltaLink

        #region DeltaDeletedLink

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndArray               If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeltaDeletedLinkImplementation()
        {
            return this.ReadAtDeltaDeletedLinkImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLinkImplementation'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeltaDeletedLinkImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeltaDeletedLinkImplementationSynchronously);
        }

        #endregion DeltaDeletedLink

        #endregion ReadAt<>Implementation methods

        #region ReadAt<>ImplementationSynchronously methods

        #region Start

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the top-level scope.</param>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        private bool ReadAtStartImplementationSynchronously(
            PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");

            // For nested payload (e.g., expanded resource set or resource in delta $entity payload),
            // we usually don't have a context URL for the resource set or resource:
            // {
            //   "@odata.context":"...", <--- this context URL is for delta entity only
            //   "value": [
            //     {
            //       ...
            //       "NavigationProperty": <--- usually we don't have a context URL for this
            //       [ <--- nested payload start
            //         {...}
            //       ] <--- nested payload end
            //     }
            //    ]
            // }
            //
            // The consequence is that the resource we read out from a nested payload doesn't
            // have an entity metadata builder thus you cannot compute read link, edit link,
            // etc. from the resource object.
            if (this.jsonLightInputContext.ReadingResponse && !this.IsReadingNestedPayload)
            {
                Debug.Assert(this.jsonLightResourceDeserializer.ContextUriParseResult != null,
                    "We should have failed by now if we don't have parse results for context URI.");

                // Validate the context URI parsed from the payload against the entity set and entity type passed in through the API.
                ReaderValidationUtils.ValidateResourceSetOrResourceContextUri(
                    this.jsonLightResourceDeserializer.ContextUriParseResult, this.CurrentScope, true);
            }

            // Get the $select query option from the metadata link, if we have one.
            string selectQueryOption = this.jsonLightResourceDeserializer.ContextUriParseResult == null
                ? null
                : this.jsonLightResourceDeserializer.ContextUriParseResult.SelectQueryOption;

            SelectedPropertiesNode selectedProperties = SelectedPropertiesNode.Create(selectQueryOption, (this.CurrentResourceTypeReference != null) ? this.CurrentResourceTypeReference.AsStructured().StructuredDefinition() : null, this.jsonLightInputContext.Model);

            if (this.ReadingResourceSet)
            {
                // Store the duplicate property names checker to use it later when reading the resource set end
                // (since we allow resourceSet-related annotations to appear after the resource set's data).
                this.topLevelScope.PropertyAndAnnotationCollector = propertyAndAnnotationCollector;

                bool isReordering = this.jsonLightInputContext.JsonReader is ReorderingJsonReader;

                if (this.ReadingDelta)
                {
                    ODataDeltaResourceSet resourceSet = new ODataDeltaResourceSet();

                    // Read top-level resource set annotations for delta resource sets.
                    this.jsonLightResourceDeserializer.ReadTopLevelResourceSetAnnotations(
                        resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/true,
                        /*readAllFeedProperties*/isReordering);
                    this.ReadDeltaResourceSetStart(resourceSet, selectedProperties);

                    this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndArray, JsonNodeType.StartObject);
                }
                else
                {
                    ODataResourceSet resourceSet = new ODataResourceSet();
                    if (!this.IsReadingNestedPayload)
                    {
                        if (!this.readingParameter)
                        {
                            // Skip top-level resource set annotations for nested resource sets.
                            this.jsonLightResourceDeserializer.ReadTopLevelResourceSetAnnotations(
                                resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/true,
                                /*readAllFeedProperties*/isReordering);
                        }
                        else
                        {
                            // This line will be used to read the first node of a resource set in Uri operation parameter, The first node is : '['
                            // Node is in following format:
                            // [
                            //      {...}, <------------ complex object.
                            //      {...}, <------------ complex object.
                            // ]
                            this.jsonLightResourceDeserializer.JsonReader.Read();
                        }
                    }

                    this.ReadResourceSetStart(resourceSet, selectedProperties);
                }

                return true;
            }

            this.ReadResourceSetItemStart(propertyAndAnnotationCollector, selectedProperties);
            return true;
        }

        #endregion Start

        #region ResourceSet

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        private bool ReadAtResourceSetStartImplementationSynchronously()
        {
            this.ReadNextResourceSetItem();
            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        ///                JsonNodeType.EndOfInput      if the resource set is in a Uri operation parameter.
        ///                JsonNodeType.StartArray      if the resource set is a member of an untyped collection followed by a collection
        ///                JsonNodeType.PrimitiveValue  if the resource set is a member of an untyped collection followed by a primitive value
        ///                JsonNodeType.StartObject     if the resource set is a member of an untyped collection followed by a resource
        ///                JsonNodeType.EndArray        if the resource set is the last member of an untyped collection
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        private bool ReadAtResourceSetEndImplementationSynchronously()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetEnd || this.State == ODataReaderState.DeltaResourceSetEnd, "Not in (delta) resource set end state.");
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput ||
                (this.ParentScope != null && (this.ParentScope.ResourceType == null || this.ParentScope.ResourceType.TypeKind == EdmTypeKind.Untyped) &&
                    (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndArray)) ||
                !this.IsTopLevel && !this.jsonLightInputContext.ReadingResponse,
                "Pre-Condition: expected JsonNodeType.EndObject or JsonNodeType.Property, or JsonNodeType.StartArray, JsonNodeTypeStart.Object, or JsonNodeType.EndArray with an untyped collection");

            bool isTopLevelResourceSet = this.IsTopLevel;
            bool isExpandedLinkContent = this.IsExpandedLinkContent;

            this.PopScope(this.State == ODataReaderState.ResourceSetEnd ? ODataReaderState.ResourceSetEnd : ODataReaderState.DeltaResourceSetEnd);

            // When we finish a top-level resource set in a nested payload (inside parameter or delta payload),
            // we can directly turn the reader into Completed state because we don't have any JSON token
            // (e.g., EndObject in a normal resource set payload) left in the stream.
            //
            // Nested resource set payload:
            // [
            //   {...},
            //   ...
            // ]
            // EOF <--- current reader position
            //
            // Normal resource set payload:
            // {
            //   "@odata.context":"...",
            //   ...,
            //   "value": [
            //     {...},
            //     ...
            //   ],
            //   "@odata.nextLink":"..."
            // } <--- current reader position
            // EOF
            //
            // Normal resource set payload as uri operation parameter
            // [
            //   {...},
            //   ...
            // ]
            // EOF <--- current reader position
            if ((this.IsReadingNestedPayload || this.readingParameter) && isTopLevelResourceSet)
            {
                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                return false;
            }

            if (isTopLevelResourceSet)
            {
                Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");

                // Read the end-object node of the resource set object and position the reader on the next input node
                // This can hit the end of the input.
                this.jsonLightResourceDeserializer.JsonReader.Read();

                // read the end-of-payload
                this.jsonLightResourceDeserializer.ReadPayloadEnd(this.IsReadingNestedPayload);

                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                return false;
            }
            else if (isExpandedLinkContent)
            {
                // finish reading the expanded link
                this.ReadExpandedNestedResourceInfoEnd(true);
                return true;
            }

            // read the next item in an untyped collection
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion ResourceSet

        #region Resource
        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private bool ReadAtResourceStartImplementationSynchronously()
        {
            ODataResourceBase currentResource = this.Item as ODataResourceBase;
            if (currentResource != null && !this.IsReadingNestedPayload)
            {
                this.CurrentResourceState.ResourceTypeFromMetadata = this.ParentScope.ResourceType as IEdmStructuredType;
                ODataResourceMetadataBuilder builder =
                    this.jsonLightResourceDeserializer.MetadataContext.GetResourceMetadataBuilderForReader(
                        this.CurrentResourceState,
                        this.jsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                        this.ReadingDelta);
                if (builder != currentResource.MetadataBuilder)
                {
                    ODataNestedResourceInfo parentNestInfo = this.ParentNestedInfo;
                    ODataConventionalResourceMetadataBuilder conventionalResourceMetadataBuilder =
                        builder as ODataConventionalResourceMetadataBuilder;

                    // If it's ODataConventionalResourceMetadataBuilder, then it means we need to build nested relationship for it in containment case
                    if (conventionalResourceMetadataBuilder != null)
                    {
                        if (parentNestInfo != null)
                        {
                            conventionalResourceMetadataBuilder.NameAsProperty = parentNestInfo.Name;
                            conventionalResourceMetadataBuilder.IsFromCollection = parentNestInfo.IsCollection == true;
                            conventionalResourceMetadataBuilder.ODataUri = ResolveODataUriFromContextUrl(parentNestInfo) ?? CurrentScope.ODataUri;
                        }

                        conventionalResourceMetadataBuilder.StartResource();
                    }

                    // Set the metadata builder and parent metadata builder for the resource itself
                    currentResource.MetadataBuilder = builder;
                    if (parentNestInfo?.MetadataBuilder != null)
                    {
                        currentResource.MetadataBuilder.ParentMetadataBuilder = parentNestInfo.MetadataBuilder;
                    }
                }
            }

            if (currentResource == null)
            {
                // Debug.Assert(this.IsExpandedLinkContent || this.CurrentResourceType.IsODataComplexTypeKind() || this.CurrentResourceType.TypeKind == EdmTypeKind.Untyped,
                //    "null or untyped resource can only be reported in an expanded link or in collection of complex instance.");
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.PrimitiveValue);

                // There's nothing to read, so move to the end resource state
                this.EndEntry();
            }
            else if (this.CurrentResourceState.FirstNestedInfo != null)
            {
                this.ReadNestedInfo(this.CurrentResourceState.FirstNestedInfo);
            }
            else
            {
                // End of resource
                // All the properties have already been read before we actually entered the EntryStart state (since we read as far as we can in any given state).
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject);
                this.EndEntry();
            }

            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.PrimitiveValue or JsonNodeType.Property or JsonNodeType.EndObject");

            return true;
        }

        /// <summary>
        /// If the nested info has context url, resolve it to ODataUri.
        /// </summary>
        /// <param name="nestedInfo">The nestedInfo to be evaluated.</param>
        /// <returns>The odata uri resolved from context url.</returns>
        private ODataUri ResolveODataUriFromContextUrl(ODataNestedResourceInfo nestedInfo)
        {
            if (nestedInfo?.ContextUrl != null)
            {
                var payloadKind = nestedInfo.IsCollection.GetValueOrDefault()
                    ? ODataPayloadKind.ResourceSet
                    : ODataPayloadKind.Resource;
                var odataPath = ODataJsonLightContextUriParser.Parse(
                    this.jsonLightResourceDeserializer.Model,
                    UriUtils.UriToString(nestedInfo.ContextUrl),
                    payloadKind,
                    this.jsonLightResourceDeserializer.MessageReaderSettings.ClientCustomTypeResolver,
                    this.jsonLightResourceDeserializer.JsonLightInputContext.ReadingResponse).Path;

                return new ODataUri() { Path = odataPath };
            }

            return null;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        private bool ReadAtResourceEndImplementationSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null),
                "Pre-Condition: JsonNodeType.EndObject or JsonNodeType.PrimitiveValue (null)");

            // We have to cache these values here, since the PopScope below will destroy them.
            bool isTopLevel = this.IsTopLevel;
            bool isExpandedLinkContent = this.IsExpandedLinkContent;

            this.PopScope(this.State == ODataReaderState.ResourceEnd ? ODataReaderState.ResourceEnd : ODataReaderState.DeletedResourceEnd);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This can hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();

            // Analyze the next Json token to determine whether it is start object (next resource), end array (resource set end) or eof (top-level resource end)
            bool result = true;
            if (isTopLevel)
            {
                // NOTE: we rely on the underlying JSON reader to fail if there is more than one value at the root level.
                Debug.Assert(
                    this.IsReadingNestedPayload ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput,
                    "Expected JSON reader to have reached the end of input when not reading a nested payload.");

                // read the end-of-payload
                Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
                this.jsonLightResourceDeserializer.ReadPayloadEnd(this.IsReadingNestedPayload);
                Debug.Assert(
                    this.IsReadingNestedPayload ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput,
                    "Expected JSON reader to have reached the end of input when not reading a nested payload.");

                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                result = false;
            }
            else if (isExpandedLinkContent)
            {
                Debug.Assert(
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject || // expanded link resource as last property of the owning resource
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property, // expanded link resource with more properties on the resource
                    "Invalid JSON reader state for reading end of resource in expanded link.");

                // finish reading the expanded link
                this.ReadExpandedNestedResourceInfoEnd(false);
            }
            else
            {
                this.ReadNextResourceSetItem();
            }

            return result;
        }

        #endregion Resource

        #region Primitive

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         primitive value
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        private bool ReadAtPrimitiveSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue,
                "Pre-Condition: JsonNodeType.PrimitiveValue (null or untyped)");

            this.PopScope(ODataReaderState.Primitive);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This should never hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion Primitive

        #region DeletedEntry

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedEntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private bool ReadAtDeletedResourceStartImplementationSynchronously()
        {
            Debug.Assert(this.CurrentScope is JsonLightDeletedResourceScope);

            if (((JsonLightDeletedResourceScope)(this.CurrentScope)).Is40DeletedResource)
            {
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject);
                this.EndEntry();
                return true;
            }

            return this.ReadAtResourceStartImplementationSynchronously();
        }

        #endregion DeletedEntry

        #region (Deleted)Link

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool ReadAtDeltaLinkImplementationSynchronously()
        {
            return this.EndDeltaLink(ODataReaderState.DeltaLink);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool ReadAtDeltaDeletedLinkImplementationSynchronously()
        {
            return this.EndDeltaLink(ODataReaderState.DeltaDeletedLink);
        }

        /// <summary>
        /// Reads the end of the delta(deleted)link.
        /// </summary>
        /// <param name="readerState">The state of the link or deleted link being completed.</param>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool EndDeltaLink(ODataReaderState readerState)
        {
            Debug.Assert(readerState == ODataReaderState.DeltaLink || readerState == ODataReaderState.DeltaDeletedLink, "ReadAtDeltaLinkImplementation called when not on delta(deleted)link");
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject,
                "Not positioned at end of object after reading delta link");

            this.PopScope(readerState);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This should never hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion (Deleted)Link

        #region NestedResourceInfo

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource or
        ///                                                     reporting projected navigation links missing in the payload
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource or
        ///                                                     reporting projected navigation links missing in the payload
        /// </remarks>
        private bool ReadAtNestedResourceInfoStartImplementationSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null,
                "Pre-Condition: expected JsonNodeType.Property, JsonNodeType.EndObject, JsonNodeType.StartObject, JsonNodeType.StartArray or JsonNodeType.Primitive (null)");

            ODataNestedResourceInfo currentLink = this.CurrentNestedResourceInfo;

            IODataJsonLightReaderResourceState parentResourceState = (IODataJsonLightReaderResourceState)this.ParentScope;

            if (this.jsonLightInputContext.ReadingResponse)
            {
                // If we are reporting a nested resource info that was projected but not included in the payload,
                // simply change state to NestedResourceInfoEnd.
                if (parentResourceState.ProcessingMissingProjectedNestedResourceInfos)
                {
                    this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
                }
                else if (!this.jsonLightResourceDeserializer.JsonReader.IsOnValueNode())
                {
                    // Deferred link (nested resource info which doesn't have a value and is in the response)
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);
                    this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject, JsonNodeType.Property);

                    // Record that we read the link on the parent resource's scope.
                    parentResourceState.NavigationPropertiesRead.Add(currentLink.Name);

                    this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
                }
                else if (!currentLink.IsCollection.Value)
                {
                    // We should get here only for declared or undeclared navigation properties.
                    Debug.Assert(this.CurrentResourceType != null || this.CurrentNestedResourceInfo.Name != null,
                        "We must have a declared navigation property to read expanded links.");

                    // Expanded resource
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);
                    this.ReadExpandedNestedResourceInfoStart(currentLink);
                }
                else
                {
                    // Expanded resource set
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);

                    // We store the precreated expanded resource set in the nested resource info since it carries the annotations for it.
                    ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                        this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo;
                    Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
                    Debug.Assert(nestedResourceInfo.NestedResourceSet != null,
                        "We must have a precreated expanded resource set already.");
                    JsonLightResourceBaseScope parentScope = (JsonLightResourceBaseScope)this.ParentScope;
                    SelectedPropertiesNode parentSelectedProperties = parentScope.SelectedProperties;
                    Debug.Assert(parentSelectedProperties != null, "parentProjectedProperties != null");

                    ODataResourceSet resourceSet = nestedResourceInfo.NestedResourceSet as ODataResourceSet;
                    if (resourceSet != null)
                    {
                        this.ReadResourceSetStart(resourceSet, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, currentLink.Name));
                    }
                    else
                    {
                        ODataDeltaResourceSet deltaResourceSet = nestedResourceInfo.NestedResourceSet as ODataDeltaResourceSet;
                        Debug.Assert(deltaResourceSet != null, "Nested resource collection is not a resource set or a delta resource set");
                        this.ReadDeltaResourceSetStart(deltaResourceSet, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, currentLink.Name));
                    }
                }
            }
            else
            {
                // Navigation link in request - report entity reference links and then possible expanded value.
                ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                    parentResourceState.PropertyAndAnnotationCollector,
                    currentLink);

                this.ReadNextNestedResourceInfoContentItemInRequest();
            }

            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource or
        ///                                                 reporting projected navigation links missing in the payload
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtNestedResourceInfoEndImplementationSynchronously()
        {
            this.PopScope(ODataReaderState.NestedResourceInfoEnd);
            return this.ReadNextNestedInfo();
        }


        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtNestedPropertyInfoSynchronously()
        {
            ODataPropertyInfo propertyInfo = this.CurrentScope.Item as ODataPropertyInfo;
            Debug.Assert(propertyInfo != null, "Reading Nested Property Without an ODataPropertyInfo");

            ODataStreamPropertyInfo streamPropertyInfo = propertyInfo as ODataStreamPropertyInfo;
            if (streamPropertyInfo != null && !String.IsNullOrEmpty(streamPropertyInfo.ContentType))
            {
                this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(streamPropertyInfo.PrimitiveTypeKind, streamPropertyInfo.ContentType));
            }
            else
            {
                this.StartNestedStreamInfo(
                    new ODataJsonLightReaderStreamInfo(propertyInfo.PrimitiveTypeKind));
            }

            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource or
        ///                                                 reporting projected navigation links missing in the payload
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtStreamSynchronously()
        {
            this.PopScope(ODataReaderState.Stream);
            if (this.State == ODataReaderState.ResourceSetStart ||
                this.State == ODataReaderState.DeltaResourceSetStart)
            {
                // We are reading a stream within a collection
                this.ReadNextResourceSetItem();
                return true;
            }

            if (this.State == ODataReaderState.NestedProperty)
            {
                this.PopScope(ODataReaderState.NestedProperty);
            }

            // We are reading a stream value
            return this.ReadNextNestedInfo();
        }

        private bool ReadNextNestedInfo()
        {
            this.jsonLightResourceDeserializer.AssertJsonCondition(
                JsonNodeType.EndObject,
                JsonNodeType.Property);
            Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "Should be in (deleted) resource start state after reading stream.");

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IODataJsonLightReaderResourceState resourceState = this.CurrentResourceState;

            if (this.jsonLightInputContext.ReadingResponse &&
                resourceState.ProcessingMissingProjectedNestedResourceInfos)
            {
                // We are reporting navigation links that were projected but missing from the payload
                readerNestedInfo = resourceState.Resource.MetadataBuilder.GetNextUnprocessedNavigationLink();
            }
            else
            {
                readerNestedInfo = this.jsonLightResourceDeserializer.ReadResourceContent(resourceState);
            }

            if (readerNestedInfo == null)
            {
                // End of the resource
                this.EndEntry();
            }
            else
            {
                this.ReadNestedInfo(readerNestedInfo);
            }

            return true;
        }

        private void ReadNestedInfo(ODataJsonLightReaderNestedInfo nestedInfo)
        {
            ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo = nestedInfo as ODataJsonLightReaderNestedResourceInfo;
            if (readerNestedResourceInfo != null)
            {
                // Next nested resource info on the resource
                this.StartNestedResourceInfo(readerNestedResourceInfo);
            }
            else
            {
                ODataJsonLightReaderNestedPropertyInfo readerNestedStreamInfo = nestedInfo as ODataJsonLightReaderNestedPropertyInfo;
                Debug.Assert(readerNestedStreamInfo != null, "NestedInfo is not a resource, stream, string");
                if (readerNestedStreamInfo != null)
                {
                    this.StartNestedPropertyInfo(readerNestedStreamInfo);
                }
            }
        }

        #endregion NestedResourceInfo

        #region EntityReferenceLink

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        private bool ReadAtEntityReferenceLinkSynchronously()
        {
            this.PopScope(ODataReaderState.EntityReferenceLink);
            Debug.Assert(this.State == ODataReaderState.NestedResourceInfoStart,
                "this.State == ODataReaderState.NestedResourceInfoStart");

            this.ReadNextNestedResourceInfoContentItemInRequest();
            return true;
        }

        #endregion EntityReferenceLink

        #endregion ReadAt<>Synchronously methods

        #region Read<> methods

        #region ResourceSet

        /// <summary>
        /// Reads the start of the JSON array for the content of the resource set and sets up the reader state correctly.
        /// </summary>
        /// <param name="resourceSet">The resource set to read the contents for.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  The first node of the resource set property value; this method will throw if the node is not
        ///                 JsonNodeType.StartArray
        /// Post-Condition: The reader is positioned on the first item in the resource set, or on the end array of the resource set.
        /// </remarks>
        private void ReadResourceSetStart(ODataResourceSet resourceSet, SelectedPropertiesNode selectedProperties)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            this.jsonLightResourceDeserializer.ReadResourceSetContentStart();
            IJsonReader jsonReader = this.jsonLightResourceDeserializer.JsonReader;
            if (jsonReader.NodeType != JsonNodeType.EndArray
                && jsonReader.NodeType != JsonNodeType.StartObject
                && jsonReader.NodeType != JsonNodeType.PrimitiveValue
                && jsonReader.NodeType != JsonNodeType.StartArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidNodeTypeForItemsInResourceSet(jsonReader.NodeType));
            }

            this.EnterScope(new JsonLightResourceSetScope(resourceSet, this.CurrentNavigationSource,
                this.CurrentScope.ResourceTypeReference, selectedProperties, this.CurrentScope.ODataUri, /*isDelta*/ false));
        }

        /// <summary>
        /// Reads the end of the current resource set.
        /// </summary>
        private void ReadResourceSetEnd()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetStart || this.State == ODataReaderState.DeltaResourceSetStart,
                "Not in ResourceSetStart or DeltaResourceSetStart state when reading end of (delta) resource set.");
            Debug.Assert(this.Item is ODataResourceSetBase, "Current Item is not ResourceSetBase");

            this.jsonLightResourceDeserializer.ReadResourceSetContentEnd();

            ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo = null;
            JsonLightNestedResourceInfoScope parentNestedResourceInfoScope = (JsonLightNestedResourceInfoScope)this.ExpandedLinkContentParentScope;
            if (parentNestedResourceInfoScope != null)
            {
                expandedNestedResourceInfo = parentNestedResourceInfoScope.ReaderNestedResourceInfo;
            }

            if (!this.IsReadingNestedPayload && (this.IsExpandedLinkContent || this.IsTopLevel))
            {
                // Temp ban reading the instance annotation after the resource set in parameter payload. (!this.IsReadingNestedPayload => !this.readingParameter)
                // Nested resource set payload won't have a NextLink annotation after the resource set itself since the payload is NOT pageable.
                this.jsonLightResourceDeserializer.ReadNextLinkAnnotationAtResourceSetEnd(this.Item as ODataResourceSetBase,
                    expandedNestedResourceInfo, this.topLevelScope.PropertyAndAnnotationCollector);
            }

            this.ReplaceScope(this.State == ODataReaderState.ResourceSetStart ? ODataReaderState.ResourceSetEnd : ODataReaderState.DeltaResourceSetEnd);
        }

        #endregion ResourceSet

        #region NestedResourceInfo

        /// <summary>
        /// Reads the start of an expanded resource (null or non-null).
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info that is being expanded.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            The start of the resource object
        ///                 JsonNodeType.PrimitiveValue (null)  The null resource value
        /// Post-Condition: JsonNodeType.StartObject            Start of expanded resource of the nested resource info to read next
        ///                 JsonNodeType.StartArray             Start of expanded resource set of the nested resource info to read next
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next, or the null value of the current null resource
        ///                 JsonNodeType.Property               Property after deferred link or expanded entity reference
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private void ReadExpandedNestedResourceInfoStart(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.Value == null,
                    "If a primitive value is representing an expanded resource its value must be null.");

                var structuralProperty =
                    this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo.StructuralProperty;
                if (structuralProperty != null && !structuralProperty.Type.IsNullable)
                {
                    ODataNullValueBehaviorKind nullValueReadBehaviorKind =
                        this.jsonLightResourceDeserializer.ReadingResponse
                            ? ODataNullValueBehaviorKind.Default
                            : this.jsonLightResourceDeserializer.Model.NullValueReadBehaviorKind(structuralProperty);

                    if (nullValueReadBehaviorKind == ODataNullValueBehaviorKind.Default)
                    {
                        throw new ODataException(
                            Strings.ReaderValidationUtils_NullNamedValueForNonNullableType(nestedResourceInfo.Name,
                                structuralProperty.Type.FullName()));
                    }
                }

                // Expanded null resource
                // The expected type and expected navigation source for an expanded resource are the same as for the nested resource info around it.
                this.EnterScope(new JsonLightResourceScope(ODataReaderState.ResourceStart, /*resource*/ null,
                    this.CurrentNavigationSource, this.CurrentResourceTypeReference, /*propertyAndAnnotationCollector*/null,
                    /*projectedProperties*/null, this.CurrentScope.ODataUri));
            }
            else
            {
                // Expanded resource
                // The expected type for an expanded resource is the same as for the nested resource info around it.
                JsonLightResourceBaseScope parentScope = (JsonLightResourceBaseScope)this.ParentScope;
                SelectedPropertiesNode parentSelectedProperties = parentScope.SelectedProperties;
                Debug.Assert(parentSelectedProperties != null, "parentProjectedProperties != null");
                this.ReadResourceSetItemStart(/*propertyAndAnnotationCollector*/ null, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, nestedResourceInfo.Name));
            }
        }

        /// <summary>
        /// Verifies that the current item is an <see cref="ODataNestedResourceInfo"/> instance,
        /// sets the cardinality of the link (IsCollection property) and moves the reader
        /// into state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <param name="isCollection">A flag indicating whether the link represents a collection or not.</param>
        private void ReadExpandedNestedResourceInfoEnd(bool isCollection)
        {
            Debug.Assert(this.State == ODataReaderState.NestedResourceInfoStart,
                "this.State == ODataReaderState.NestedResourceInfoStart");
            this.CurrentNestedResourceInfo.IsCollection = isCollection;

            // Record that we read the link on the parent resource's scope.
            IODataJsonLightReaderResourceState parentResourceState = (IODataJsonLightReaderResourceState)this.ParentScope;
            parentResourceState.NavigationPropertiesRead.Add(this.CurrentNestedResourceInfo.Name);

            // replace the 'NestedResourceInfoStart' scope with the 'NestedResourceInfoEnd' scope
            this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
        }

        #endregion NestedResourceInfo

        #region Resource

        /// <summary>
        /// Reads the start of a (standard, delta, primitive, or null) resource and sets up the reader state correctly
        /// </summary>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            If the resource is in a resource set - the start of the resource object
        ///                 JsonNodeType.Property               If the resource is a top-level resource and has at least one property
        ///                 JsonNodeType.EndObject              If the resource is a top-level resource and has no properties
        /// Post-Condition: JsonNodeType.StartObject            Start of expanded resource of the nested resource info to read next
        ///                 JsonNodeType.StartArray             Start of expanded resource set of the nested resource info to read next
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next
        ///                 JsonNodeType.Property               Property after deferred link or expanded entity reference
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private void ReadResourceSetItemStart(PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties)
        {
            IEdmNavigationSource source = this.CurrentNavigationSource;
            IEdmTypeReference resourceTypeReference = this.CurrentResourceTypeReference;

            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.StartObject, JsonNodeType.Property,
                JsonNodeType.EndObject, JsonNodeType.PrimitiveValue);

            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                object primitiveValue = this.jsonLightResourceDeserializer.JsonReader.Value;
                if (primitiveValue != null)
                {
                    // primitive value in an untyped collection
                    if (this.CurrentResourceType.TypeKind == EdmTypeKind.Untyped)
                    {
                        this.EnterScope(new JsonLightPrimitiveScope(new ODataPrimitiveValue(primitiveValue),
                            this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                    }
                    else
                    {
                        throw new ODataException(Strings.ODataJsonLightReader_UnexpectedPrimitiveValueForODataResource);
                    }
                }
                else
                {
                    // null resource
                    if (resourceTypeReference.IsComplex() || resourceTypeReference.IsUntyped())
                    {
                        this.jsonLightResourceDeserializer.MessageReaderSettings.Validator.ValidateNullValue(this.CurrentResourceTypeReference, true, "", null);
                    }

                    this.EnterScope(new JsonLightResourceScope(ODataReaderState.ResourceStart, /*resource*/ null,
                        this.CurrentNavigationSource, this.CurrentResourceTypeReference, /*propertyAndAnnotationCollector*/null,
                        /*projectedProperties*/null, this.CurrentScope.ODataUri));
                }

                return;
            }

            // If the reader is on StartObject then read over it. This happens for entries in resource set.
            // For top-level entries the reader will be positioned on the first resource property (after odata.context if it was present).
            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject)
            {
                this.jsonLightResourceDeserializer.JsonReader.Read();
            }

            ODataDeltaKind resourceKind = ODataDeltaKind.Resource;

            // if this is a resourceSet, expanded link, or non-top level resource in a delta result, read the contextUrl
            if (this.ReadingResourceSet || this.IsExpandedLinkContent || (this.ReadingDelta && !this.IsTopLevel))
            {
                string contextUriStr =
                    this.jsonLightResourceDeserializer.ReadContextUriAnnotation(ODataPayloadKind.Resource,
                        propertyAndAnnotationCollector, false);
                if (contextUriStr != null)
                {
                    contextUriStr =
                        UriUtils.UriToString(this.jsonLightResourceDeserializer.ProcessUriFromPayload(contextUriStr));
                    var parseResult = ODataJsonLightContextUriParser.Parse(
                        this.jsonLightResourceDeserializer.Model,
                        contextUriStr,
                        this.ReadingDelta ? ODataPayloadKind.Delta : ODataPayloadKind.Resource,
                        this.jsonLightResourceDeserializer.MessageReaderSettings.ClientCustomTypeResolver,
                        this.jsonLightInputContext.ReadingResponse || this.ReadingDelta);
                    if (parseResult != null)
                    {
                        // a top-level (deleted) resource in a delta response can come from any entity set
                        resourceKind = parseResult.DeltaKind;
                        if (this.ReadingDelta && this.IsTopLevel && (resourceKind == ODataDeltaKind.Resource || resourceKind == ODataDeltaKind.DeletedEntry))
                        {
                            IEdmStructuredType parsedType = parseResult.EdmType as IEdmStructuredType;
                            if (parsedType != null)
                            {
                                resourceTypeReference = parsedType.ToTypeReference(true);
                                source = parseResult.NavigationSource;
                            }
                        }
                        else
                        {
                            ReaderValidationUtils.ValidateResourceSetOrResourceContextUri(parseResult, this.CurrentScope,
                                false);
                        }
                    }
                }
            }

            // If this is a resource in a delta resource set, check to see if it's a 4.01 deleted resource
            ODataDeletedResource deletedResource = null;
            if (this.ReadingDelta && (resourceKind == ODataDeltaKind.Resource || resourceKind == ODataDeltaKind.DeletedEntry))
            {
                deletedResource = this.jsonLightResourceDeserializer.IsDeletedResource();
                if (deletedResource != null)
                {
                    resourceKind = ODataDeltaKind.DeletedEntry;
                }
            }

            switch (resourceKind)
            {
                case ODataDeltaKind.None:
                case ODataDeltaKind.Resource:
                    // Setup the new resource state
                    this.StartResource(source, resourceTypeReference, propertyAndAnnotationCollector, selectedProperties);

                    // Start reading the resource up to the first nested resource info
                    this.StartReadingResource();

                    break;

                case ODataDeltaKind.ResourceSet:
                    this.ReadAtResourceSetStartImplementation();
                    break;

                case ODataDeltaKind.DeletedEntry:
                    // OData 4.0 deleted entry
                    if (deletedResource == null)
                    {
                        deletedResource = this.jsonLightResourceDeserializer.ReadDeletedEntry();
                        this.StartDeletedResource(
                            deletedResource,
                            source,
                            resourceTypeReference,
                            propertyAndAnnotationCollector,
                            selectedProperties,
                            true /*is 4.0 Deleted Resource*/);
                    }
                    else // OData 4.01 deleted entry
                    {
                        this.StartDeletedResource(
                            deletedResource,
                            source,
                            resourceTypeReference,
                            propertyAndAnnotationCollector,
                            selectedProperties);

                        // Start reading the resource up to the first nested resource info
                        this.StartReadingResource();
                    }

                    break;

                case ODataDeltaKind.DeletedLink:
                    this.StartDeltaLink(ODataReaderState.DeltaDeletedLink);
                    break;

                case ODataDeltaKind.Link:
                    this.StartDeltaLink(ODataReaderState.DeltaLink);
                    break;

                default:
                    Debug.Assert(true, "Unknown ODataDeltaKind " + resourceKind.ToString());
                    break;
            }
        }

        #endregion Resource

        #region DeltaResourceSet
        /// <summary>
        /// Reads the start of the JSON array for the content of the delta resource set and sets up the reader state correctly.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to read the contents for.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  The first node of the resource set property value; this method will throw if the node is not
        ///                 JsonNodeType.StartArray
        /// Post-Condition: The reader is positioned on the first item in the resource set, or on the end array of the resource set.
        /// </remarks>
        private void ReadDeltaResourceSetStart(ODataDeltaResourceSet deltaResourceSet, SelectedPropertiesNode selectedProperties)
        {
            Debug.Assert(deltaResourceSet != null, "resourceSet != null");

            this.jsonLightResourceDeserializer.ReadResourceSetContentStart();
            IJsonReader jsonReader = this.jsonLightResourceDeserializer.JsonReader;
            if (jsonReader.NodeType != JsonNodeType.EndArray && jsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidNodeTypeForItemsInResourceSet(jsonReader.NodeType));
            }

            Debug.Assert(this.CurrentResourceType is IEdmEntityType, "Delta resource type is not an entity");

            this.EnterScope(new JsonLightResourceSetScope(
                deltaResourceSet,
                this.CurrentNavigationSource,
                this.CurrentResourceTypeReference as IEdmEntityTypeReference,
                selectedProperties,
                this.CurrentScope.ODataUri,
                /*isDelta*/ true));
        }

        #endregion DeltaResourceSet

        #endregion Read<> methods

        #region private methods

        /// <summary>
        /// Read the resource up to the first nested resource info.
        /// </summary>
        private void StartReadingResource()
        {
            ODataResourceBase currentResource = this.Item as ODataResourceBase;

            // Read the odata.type annotation.
            this.jsonLightResourceDeserializer.ReadResourceTypeName(this.CurrentResourceState);

            // Resolve the type name
            this.ApplyResourceTypeNameFromPayload(currentResource.TypeName);

            // Validate type with derived type validator if available
            if (this.CurrentDerivedTypeValidator != null)
            {
                this.CurrentDerivedTypeValidator.ValidateResourceType(this.CurrentResourceType);
            }

            // Validate type with resource set validator if available and not reading top-level delta resource set
            if (this.CurrentResourceSetValidator != null && !(this.ReadingDelta && this.CurrentResourceDepth == 0))
            {
                this.CurrentResourceSetValidator.ValidateResource(this.CurrentResourceType);
            }

            this.CurrentResourceState.FirstNestedInfo =
                this.jsonLightResourceDeserializer.ReadResourceContent(this.CurrentResourceState);

            this.jsonLightResourceDeserializer.AssertJsonCondition(
                JsonNodeType.Property,
                JsonNodeType.StartObject,
                JsonNodeType.StartArray,
                JsonNodeType.EndObject,
                JsonNodeType.PrimitiveValue);
        }

        /// <summary>
        /// Reads the next entity or complex value (or primitive or collection value for an untyped collection) in a resource set.
        /// </summary>
        private void ReadNextResourceSetItem()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetStart ||
                this.State == ODataReaderState.DeltaResourceSetStart,
                "Reading a resource set item while not in a ResourceSetStart or DeltaResourceSetStart state.");
            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndArray, JsonNodeType.PrimitiveValue,
                JsonNodeType.StartObject, JsonNodeType.StartArray);
            IEdmType resourceType = this.CurrentScope.ResourceType;

            // End of item in a resource set
            switch (this.jsonLightResourceDeserializer.JsonReader.NodeType)
            {
                case JsonNodeType.StartObject:
                    // another resource in a resource set
                    this.ReadResourceSetItemStart( /*propertyAndAnnotationCollector*/
                        null, this.CurrentJsonLightResourceSetScope.SelectedProperties);
                    break;
                case JsonNodeType.StartArray:
                    // we are at the start of a nested resource set
                    this.ReadResourceSetStart(new ODataResourceSet(), new SelectedPropertiesNode(SelectedPropertiesNode.SelectionType.EntireSubtree));
                    break;
                case JsonNodeType.EndArray:
                    // we are at the end of a resource set
                    this.ReadResourceSetEnd();
                    break;
                case JsonNodeType.PrimitiveValue:
                    // Is this a stream, or a binary or string value with a collection that the client wants to read as a stream
                    if (!TryReadPrimitiveAsStream(resourceType))
                    {
                        // we are at a null value, or a non-null primitive value within an untyped collection
                        object primitiveValue = this.jsonLightResourceDeserializer.JsonReader.Value;
                        if (primitiveValue != null)
                        {
                            this.EnterScope(new JsonLightPrimitiveScope(new ODataPrimitiveValue(primitiveValue),
                                this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                        }
                        else
                        {
                            if (resourceType.TypeKind == EdmTypeKind.Primitive || resourceType.TypeKind == EdmTypeKind.Enum)
                            {
                                // null primitive
                                this.EnterScope(new JsonLightPrimitiveScope(new ODataNullValue(),
                                    this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                            }
                            else
                            {
                                // null resource (ReadResourceStart will raise the appropriate error for a non-null primitive value)
                                this.ReadResourceSetItemStart( /*propertyAndAnnotationCollector*/
                                    null, this.CurrentJsonLightResourceSetScope.SelectedProperties);
                            }
                        }
                    }

                    break;
                default:
                    throw new ODataException(
                        ODataErrorStrings.ODataJsonReader_CannotReadResourcesOfResourceSet(
                            this.jsonLightResourceDeserializer.JsonReader.NodeType));
            }
        }

        private bool TryReadPrimitiveAsStream(IEdmType resourceType)
        {
            Func<IEdmPrimitiveType, bool, string, IEdmProperty, bool> readAsStream = this.jsonLightInputContext.MessageReaderSettings.ReadAsStreamFunc;

            // Should stream primitive if
            // 1. Primitive is a stream value
            // 2. Primitive is a string or binary value (within an untyped or streamed collection) that the reader wants to read as a stream
            if (
                (resourceType != null && resourceType.IsStream()) ||
                (resourceType != null
                   && readAsStream != null
                   && (resourceType.IsBinary() || resourceType.IsString())
                   && readAsStream(resourceType as IEdmPrimitiveType, false, null, null)))
            {
                if (resourceType == null || resourceType.IsUntyped())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(
                        EdmPrimitiveTypeKind.None));
                }
                else if (resourceType.IsString())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(
                        EdmPrimitiveTypeKind.String));
                }
                else if (resourceType.IsStream() || resourceType.IsBinary())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(EdmPrimitiveTypeKind.Binary));
                }
                else
                {
                    Debug.Assert(false, "We thought we could read as stream, but ran out of options");
                    return false;
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads the next item in a nested resource info content in a request payload.
        /// </summary>
        private void ReadNextNestedResourceInfoContentItemInRequest()
        {
            Debug.Assert(this.CurrentScope.State == ODataReaderState.NestedResourceInfoStart,
                "Must be on 'NestedResourceInfoStart' scope.");

            ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo;
            if (nestedResourceInfo.HasEntityReferenceLink)
            {
                this.EnterScope(new Scope(ODataReaderState.EntityReferenceLink, nestedResourceInfo.ReportEntityReferenceLink(), this.CurrentScope.ODataUri));
            }
            else if (nestedResourceInfo.HasValue)
            {
                if (nestedResourceInfo.NestedResourceInfo.IsCollection == true)
                {
                    // because this is a request, there is no $select query option.
                    SelectedPropertiesNode selectedProperties = new SelectedPropertiesNode(SelectedPropertiesNode.SelectionType.EntireSubtree);
                    ODataDeltaResourceSet deltaResourceSet = nestedResourceInfo.NestedResourceSet as ODataDeltaResourceSet;
                    if (deltaResourceSet != null)
                    {
                        this.ReadDeltaResourceSetStart(deltaResourceSet, selectedProperties);
                    }
                    else
                    {
                        ODataResourceSet resourceSet = nestedResourceInfo.NestedResourceSet as ODataResourceSet;
                        this.ReadResourceSetStart(resourceSet ?? new ODataResourceSet(), selectedProperties);
                    }
                }
                else
                {
                    this.ReadExpandedNestedResourceInfoStart(nestedResourceInfo.NestedResourceInfo);
                }
            }
            else
            {
                // replace the 'NestedResourceInfoStart' scope with the 'NestedResourceInfoEnd' scope
                this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
            }
        }

        /// <summary>
        /// Starts the resource, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="source">The source for the resource</param>
        /// <param name="resourceType">The entity type of the resource</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        private void StartResource(IEdmNavigationSource source, IEdmTypeReference resourceType, PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties)
        {
            this.EnterScope(new JsonLightResourceScope(
                ODataReaderState.ResourceStart,
                ReaderUtils.CreateNewResource(),
                source,
                resourceType,
                propertyAndAnnotationCollector ?? this.jsonLightInputContext.CreatePropertyAndAnnotationCollector(),
                selectedProperties,
                this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Starts the deleted resource, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="deletedResource">The deletedResource to be created.</param>
        /// <param name="source">The navigation source of the deleted resource.</param>
        /// <param name="resourceType">The entity type of the deleted resource.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <param name="is40DeletedResource">Whether the current resource being read is a 4.0-style deleted resource.</param>
        private void StartDeletedResource(ODataDeletedResource deletedResource, IEdmNavigationSource source, IEdmTypeReference resourceType, PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties, bool is40DeletedResource = false)
        {
            this.EnterScope(new JsonLightDeletedResourceScope(
                ODataReaderState.DeletedResourceStart,
                deletedResource,
                source,
                resourceType,
                propertyAndAnnotationCollector ?? this.jsonLightInputContext.CreatePropertyAndAnnotationCollector(),
                selectedProperties,
                this.CurrentScope.ODataUri,
                is40DeletedResource));
        }

        /// <summary>
        /// Starts the (deleted) link, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="state">The reader state to switch to.</param>
        private void StartDeltaLink(ODataReaderState state)
        {
            Debug.Assert(
                state == ODataReaderState.DeltaLink || state == ODataReaderState.DeltaDeletedLink,
                "state must be either DeltaResource or DeltaDeletedEntry or DeltaLink or DeltaDeletedLink.");
            Debug.Assert(this.CurrentResourceType is IEdmEntityType, "DeltaLink is not from an entity type");

            ODataDeltaLinkBase link;
            if (state == ODataReaderState.DeltaLink)
            {
                link = new ODataDeltaLink(null, null, null);
            }
            else
            {
                link = new ODataDeltaDeletedLink(null, null, null);
            }

            this.EnterScope(new JsonLightDeltaLinkScope(
                state,
                link,
                this.CurrentNavigationSource,
                this.CurrentResourceType as IEdmEntityType,
                this.CurrentScope.ODataUri));

            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject, JsonNodeType.Property);

            // Read source property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkSource(link);

            // Read relationship property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkRelationship(link);

            // Read target property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkTarget(link);

            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject, "Unexpected content in a delta (deleted) link");
        }

        /// <summary>
        /// Starts the nested resource info.
        /// Does metadata validation of the nested resource info and sets up the reader to report it.
        /// </summary>
        /// <param name="readerNestedResourceInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedResourceInfo(ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo)
        {
            Debug.Assert(readerNestedResourceInfo != null, "readerNestedResourceInfo != null");
            ODataNestedResourceInfo nestedResourceInfo = readerNestedResourceInfo.NestedResourceInfo;
            IEdmProperty nestedProperty = readerNestedResourceInfo.NestedProperty;
            IEdmTypeReference targetResourceTypeReference = readerNestedResourceInfo.NestedResourceTypeReference;

            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.Primitive (null), or JsonNodeType.Property, JsonNodeType.EndObject");
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(!string.IsNullOrEmpty(nestedResourceInfo.Name), "Navigation links must have a name.");
            Debug.Assert(nestedProperty == null || nestedResourceInfo.Name == nestedProperty.Name,
                "The navigation property must match the nested resource info.");

            // we are at the beginning of a link
            if (targetResourceTypeReference == null && nestedProperty != null)
            {
                IEdmTypeReference nestedPropertyType = nestedProperty.Type;
                targetResourceTypeReference = nestedPropertyType.IsCollection()
                    ? nestedPropertyType.AsCollection().ElementType().AsStructured()
                    : nestedPropertyType.AsStructured();
            }

            // Since we don't have the entity metadata builder for the resource read out from a nested payload
            // as stated in ReadAtResourceSetEndImplementationSynchronously(), we cannot access it here which otherwise
            // would lead to an exception.
            if (this.jsonLightInputContext.ReadingResponse && !this.IsReadingNestedPayload
                && (targetResourceTypeReference == null || targetResourceTypeReference.Definition.IsStructuredOrStructuredCollectionType()))
            {
                // Hookup the metadata builder to the nested resource info.
                // Note that we set the metadata builder even when navigationProperty is null, which is the case when the link is undeclared.
                // For undeclared links, we will apply conventional metadata evaluation just as declared links.
                this.CurrentResourceState.ResourceTypeFromMetadata = this.ParentScope.ResourceType as IEdmStructuredType;
                ODataResourceMetadataBuilder resourceMetadataBuilder =
                    this.jsonLightResourceDeserializer.MetadataContext.GetResourceMetadataBuilderForReader(
                        this.CurrentResourceState,
                        this.jsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                        this.ReadingDelta);
                nestedResourceInfo.MetadataBuilder = resourceMetadataBuilder;
            }

            Debug.Assert(
                this.CurrentNavigationSource != null || this.readingParameter ||
                this.CurrentNavigationSource == null && this.CurrentScope.ResourceType.IsODataComplexTypeKind(),
                "Json requires an navigation source when not reading parameter.");

            IEdmNavigationProperty navigationProperty = readerNestedResourceInfo.NavigationProperty;

            IEdmNavigationSource navigationSource;

            // Since we are entering a nested info scope, check whether the current resource is derived type in order to correctly further property or navigation property.
            JsonLightResourceBaseScope currentScope = this.CurrentScope as JsonLightResourceBaseScope;
            ODataUri odataUri = this.CurrentScope.ODataUri.Clone();
            ODataPath odataPath = odataUri.Path ?? new ODataPath();

            if (currentScope != null && currentScope.ResourceTypeFromMetadata != currentScope.ResourceType)
            {
                odataPath.Add(new TypeSegment(currentScope.ResourceType, null));
            }

            if (navigationProperty == null)
            {
                navigationSource = this.CurrentNavigationSource;
            }
            else
            {
                IEdmPathExpression bindingPath;
                navigationSource = this.CurrentNavigationSource == null
                    ? null
                    : this.CurrentNavigationSource.FindNavigationTarget(navigationProperty,
                        BindingPathHelper.MatchBindingPath, odataPath.ToList(), out bindingPath);
            }

            if (navigationProperty != null)
            {
                if (navigationSource is IEdmContainedEntitySet)
                {
                    if (TryAppendEntitySetKeySegment(ref odataPath))
                    {
                        odataPath = odataPath.AddNavigationPropertySegment(navigationProperty, navigationSource);
                    }
                }
                else if (navigationSource != null && !(navigationSource is IEdmUnknownEntitySet))
                {
                    var entitySet = navigationSource as IEdmEntitySet;
                    odataPath = entitySet != null
                        ? new ODataPath(new EntitySetSegment(entitySet))
                        : new ODataPath(new SingletonSegment(navigationSource as IEdmSingleton));
                }
                else
                {
                    odataPath = new ODataPath();
                }
            }
            else if (nestedProperty != null)
            {
                odataPath = odataPath.AddPropertySegment(nestedProperty as IEdmStructuralProperty);
            }

            odataUri.Path = odataPath;

            JsonLightNestedResourceInfoScope newScope = new JsonLightNestedResourceInfoScope(readerNestedResourceInfo, navigationSource,
                targetResourceTypeReference, odataUri);

            var derivedTypeConstraints = this.jsonLightInputContext.Model.GetDerivedTypeConstraints(nestedProperty);
            if (derivedTypeConstraints != null)
            {
                newScope.DerivedTypeValidator = new DerivedTypeValidator(nestedProperty.Type.ToStructuredType(), derivedTypeConstraints, "nested resource", nestedProperty.Name);
            }

            this.EnterScope(newScope);
        }

        /// <summary>
        /// Starts the nested property info.
        /// </summary>
        /// <param name="readerNestedPropertyInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedPropertyInfo(ODataJsonLightReaderNestedPropertyInfo readerNestedPropertyInfo)
        {
            Debug.Assert(readerNestedPropertyInfo != null, "readerNestedResourceInfo != null");
            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.CanStream() || this.CurrentScope is JsonLightResourceSetScope,
                "Starting stream while not positioned on a primitive value or within an array");

            this.EnterScope(new JsonLightNestedPropertyInfoScope(readerNestedPropertyInfo, this.CurrentNavigationSource, this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Starts the nested stream info.
        /// </summary>
        /// <param name="readerStreamInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedStreamInfo(ODataJsonLightReaderStreamInfo readerStreamInfo)
        {
            Debug.Assert(readerStreamInfo != null, "readerNestedResourceInfo != null");
            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.CanStream() || this.CurrentScope is JsonLightResourceSetScope,
                "Starting stream while not positioned on a primitive value or within an array");

            this.EnterScope(new JsonLightStreamScope(readerStreamInfo, this.CurrentNavigationSource, this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Try to append key segment.
        /// </summary>
        /// <param name="odataPath">The ODataPath to be evaluated.</param>
        /// <returns>True if successfully append key segment.</returns>
        private bool TryAppendEntitySetKeySegment(ref ODataPath odataPath)
        {
            try
            {
                if (EdmExtensionMethods.HasKey(this.CurrentScope.NavigationSource, this.CurrentScope.ResourceType as IEdmStructuredType))
                {
                    IEdmEntityType currentEntityType = this.CurrentScope.ResourceType as IEdmEntityType;
                    ODataResourceBase resource = this.CurrentScope.Item as ODataResourceBase;
                    KeyValuePair<string, object>[] keys = ODataResourceMetadataContext.GetKeyProperties(resource, null, currentEntityType);
                    odataPath = odataPath.AddKeySegment(keys, currentEntityType, this.CurrentScope.NavigationSource);
                }
            }
            catch (ODataException)
            {
                odataPath = null;
                return false;
            }

            return true;
        }

        /// <summary>
        /// Replaces the current scope with a new scope with the specified <paramref name="state"/> and
        /// the item of the current scope.
        /// </summary>
        /// <param name="state">The <see cref="ODataReaderState"/> to use for the new scope.</param>
        private void ReplaceScope(ODataReaderState state)
        {
            this.ReplaceScope(new Scope(state, this.Item, this.CurrentNavigationSource, this.CurrentResourceTypeReference,
                this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Called to transition into the EntryEnd state.
        /// </summary>
        private void EndEntry()
        {
            IODataJsonLightReaderResourceState resourceState = this.CurrentResourceState;
            ODataResourceBase currentResource = this.Item as ODataResourceBase;

            if (currentResource != null && !this.IsReadingNestedPayload)
            {
                // Builder should not be used outside the odataresource, lazy builder logic does not work here
                // We should refactor this
                foreach (string navigationPropertyName in this.CurrentResourceState.NavigationPropertiesRead)
                {
                    currentResource.MetadataBuilder.MarkNestedResourceInfoProcessed(navigationPropertyName);
                }

                ODataConventionalEntityMetadataBuilder builder =
                    currentResource.MetadataBuilder as ODataConventionalEntityMetadataBuilder;
                builder?.EndResource();
            }

            if (!this.ReadingDelta)
            {
                this.jsonLightResourceDeserializer.ValidateMediaEntity(resourceState);
            }

            // In non-delta responses, ensure that all projected properties get created.
            // Also ignore cases where the resource is 'null' which happens for expanded null entries.
            if (this.jsonLightInputContext.ReadingResponse && !this.ReadingDelta && currentResource != null)
            {
                // If we have a projected nested resource info that was missing from the payload, report it now.
                ODataJsonLightReaderNestedResourceInfo unprocessedNestedResourceInfo =
                    currentResource.MetadataBuilder.GetNextUnprocessedNavigationLink();
                if (unprocessedNestedResourceInfo != null)
                {
                    this.CurrentResourceState.ProcessingMissingProjectedNestedResourceInfos = true;
                    this.StartNestedResourceInfo(unprocessedNestedResourceInfo);
                    return;
                }
            }

            if (this.State == ODataReaderState.ResourceStart)
            {
                this.EndEntry(
                    new JsonLightResourceScope(
                        ODataReaderState.ResourceEnd,
                        (ODataResource)this.Item,
                        this.CurrentNavigationSource,
                        this.CurrentResourceTypeReference,
                        this.CurrentResourceState.PropertyAndAnnotationCollector,
                        this.CurrentResourceState.SelectedProperties,
                        this.CurrentScope.ODataUri));
            }
            else
            {
                this.EndEntry(
                    new JsonLightDeletedResourceScope(
                        ODataReaderState.DeletedResourceEnd,
                        (ODataDeletedResource)this.Item,
                        this.CurrentNavigationSource,
                        this.CurrentResourceTypeReference,
                        this.CurrentResourceState.PropertyAndAnnotationCollector,
                        this.CurrentResourceState.SelectedProperties,
                        this.CurrentScope.ODataUri));
            }
        }

        /// <summary>
        /// Add info resolved from context url to current scope.
        /// </summary>
        private void ResolveScopeInfoFromContextUrl()
        {
            if (this.jsonLightResourceDeserializer.ContextUriParseResult != null)
            {
                this.CurrentScope.ODataUri.Path = this.jsonLightResourceDeserializer.ContextUriParseResult.Path;

                if (this.CurrentScope.NavigationSource == null)
                {
                    this.CurrentScope.NavigationSource =
                        this.jsonLightResourceDeserializer.ContextUriParseResult.NavigationSource;
                }

                if (this.CurrentScope.ResourceType == null)
                {
                    IEdmType typeFromContext = this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType;
                    if (typeFromContext != null)
                    {
                        if (typeFromContext.TypeKind == EdmTypeKind.Collection)
                        {
                            typeFromContext = ((IEdmCollectionType)typeFromContext).ElementType.Definition;
                            if (!(typeFromContext is IEdmStructuredType))
                            {
                                typeFromContext = new EdmUntypedStructuredType();
                                this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType = new EdmCollectionType(typeFromContext.ToTypeReference());
                            }
                        }

                        IEdmStructuredType resourceType = typeFromContext as IEdmStructuredType;
                        if (resourceType == null)
                        {
                            resourceType = new EdmUntypedStructuredType();
                            this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType = resourceType;
                        }

                        this.CurrentScope.ResourceTypeReference = resourceType.ToTypeReference(true).AsStructured();
                    }
                }
            }
        }

#endregion private methods

        #region scopes

        /// <summary>
        /// A reader top-level scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightTopLevelScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceType">The expected type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri attached to this scope.</param>
            /// <remarks>The <paramref name="expectedResourceType"/> has the following meaning
            ///   it's the expected base type of the top-level resource or resource set in the top-level resource set.
            /// In all cases the specified type must be a structured type.</remarks>
            internal JsonLightTopLevelScope(IEdmNavigationSource navigationSource, IEdmStructuredType expectedResourceType, ODataUri odataUri)
                : base(ODataReaderState.Start, /*item*/ null, navigationSource, expectedResourceType.ToTypeReference(true), odataUri)
            {
            }

            /// <summary>
            /// The duplicate property names checker for the top level scope represented by the current state.
            /// </summary>
            public PropertyAndAnnotationCollector PropertyAndAnnotationCollector { get; set; }
        }

        /// <summary>
        /// A reader primitive scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightPrimitiveScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="primitiveValue">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedTypeReference">The expected type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightPrimitiveScope(
                ODataValue primitiveValue,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedTypeReference,
                ODataUri odataUri)
                : base(ODataReaderState.Primitive, primitiveValue, navigationSource, expectedTypeReference, odataUri)
            {
                Debug.Assert(primitiveValue is ODataPrimitiveValue || primitiveValue is ODataNullValue, "Primitive value scope created with non-primitive value");
            }
        }

        /// <summary>
        /// A reader resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private abstract class JsonLightResourceBaseScope : Scope, IODataJsonLightReaderResourceState
        {
            /// <summary>The set of names of the navigation properties we have read so far while reading the resource.</summary>
            private List<string> navigationPropertiesRead;

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceTypeReference">The expected type reference for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            protected JsonLightResourceBaseScope(
                ODataReaderState readerState,
                ODataResourceBase resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceTypeReference,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri)
                : base(readerState, resource, navigationSource, expectedResourceTypeReference, odataUri)
            {
                Debug.Assert(
                    readerState == ODataReaderState.ResourceStart || readerState == ODataReaderState.ResourceEnd ||
                    readerState == ODataReaderState.DeletedResourceStart || readerState == ODataReaderState.DeletedResourceEnd,
                    "Resource scope created for invalid reader state: " + readerState);

                this.PropertyAndAnnotationCollector = propertyAndAnnotationCollector;
                this.SelectedProperties = selectedProperties;
            }

            /// <summary>
            /// The metadata builder instance for the resource.
            /// </summary>
            public ODataResourceMetadataBuilder MetadataBuilder { get; set; }

            /// <summary>
            /// Flag which indicates that during parsing of the resource represented by this state,
            /// any property which is not an instance annotation was found. This includes property annotations
            /// for property which is not present in the payload.
            /// </summary>
            /// <remarks>
            /// This is used to detect incorrect ordering of the payload (for example odata.id must not come after the first property).
            /// </remarks>
            public bool AnyPropertyFound { get; set; }

            /// <summary>
            /// If the reader finds a nested resource info to report, but it must first report the parent resource
            /// it will store the nested resource info in this property. So this will only ever store the first nested resource info of a resource.
            /// </summary>
            public ODataJsonLightReaderNestedInfo FirstNestedInfo { get; set; }

            /// <summary>
            /// The duplicate property names checker for the resource represented by the current state.
            /// </summary>
            public PropertyAndAnnotationCollector PropertyAndAnnotationCollector { get; private set; }

            /// <summary>
            /// The selected properties that should be expanded during template evaluation.
            /// </summary>
            public SelectedPropertiesNode SelectedProperties { get; private set; }

            /// <summary>
            /// The set of names of the navigation properties we have read so far while reading the resource.
            /// true if we have started processing missing projected navigation links, false otherwise.
            /// </summary>
            public List<string> NavigationPropertiesRead
            {
                get { return this.navigationPropertiesRead ?? (this.navigationPropertiesRead = new List<string>()); }
            }

            /// <summary>
            /// true if we have started processing missing projected navigation links, false otherwise.
            /// </summary>
            public bool ProcessingMissingProjectedNestedResourceInfos { get; set; }

            /// <summary>
            /// The expected type defined in the model for the resource.
            /// </summary>
            public IEdmStructuredType ResourceTypeFromMetadata { get; set; }

            /// <summary>
            /// The resource type for this resource.
            /// </summary>
            public new IEdmStructuredType ResourceType
            {
                get
                {
                    return base.ResourceType as IEdmStructuredType;
                }
            }

            /// <summary>
            /// The resource being read.
            /// </summary>
            ODataResourceBase IODataJsonLightReaderResourceState.Resource
            {
                get
                {
                    Debug.Assert(
                        this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd ||
                        this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                        "The IODataJsonLightReaderResourceState is only supported on ResourceStart or ResourceEnd scope.");
                    return (ODataResourceBase)this.Item;
                }
            }

            /// <summary>
            /// The structured type for the resource (if available).
            /// </summary>
            IEdmStructuredType IODataJsonLightReaderResourceState.ResourceType
            {
                get
                {
                    Debug.Assert(
                        this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd | this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                        "The IODataJsonLightReaderResourceState is only supported on (Deleted)ResourceStart or (Deleted)ResourceEnd scope.");
                    return this.ResourceType;
                }
            }

            /// <summary>
            /// The navigation source for the resource (if available)
            /// </summary>
            IEdmNavigationSource IODataJsonLightReaderResourceState.NavigationSource
            {
                get { return this.NavigationSource; }
            }
        }

        /// <summary>
        /// Base class for a reader resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightResourceScope : JsonLightResourceBaseScope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceTypeReference">The expected type for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightResourceScope(
                ODataReaderState readerState,
                ODataResourceBase resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceTypeReference,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri)
                : base(readerState, resource, navigationSource, expectedResourceTypeReference, propertyAndAnnotationCollector, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A reader deleted resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightDeletedResourceScope : JsonLightResourceBaseScope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceType">The expected type for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <param name="is40DeletedResource">Whether the deleted resource being read is an OData 4.0 Deleted Resource</param>
            /// <remarks>The <paramref name="expectedResourceType"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightDeletedResourceScope(
                ODataReaderState readerState,
                ODataDeletedResource resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceType,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool is40DeletedResource = false)
                : base(readerState, resource, navigationSource, expectedResourceType, propertyAndAnnotationCollector, selectedProperties, odataUri)
            {
                this.Is40DeletedResource = is40DeletedResource;
            }

            /// <summary>Whether the payload is an OData 4.0 deleted resource.</summary>
            internal bool Is40DeletedResource { get; }
        }

        /// <summary>
        /// A reader resource set scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightResourceSetScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="resourceSet">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceTypeReference">The expected type reference for the scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <param name="isDelta">True of the ResourceSetScope is for a delta resource set</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the entries in the resource set.
            ///   note that it might be a more derived type than the base type of the entity set for the resource set.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightResourceSetScope(ODataResourceSetBase resourceSet, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceTypeReference, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isDelta)
                : base(isDelta ? ODataReaderState.DeltaResourceSetStart : ODataReaderState.ResourceSetStart, resourceSet, navigationSource, expectedResourceTypeReference, odataUri)
            {
                this.SelectedProperties = selectedProperties;
            }

            /// <summary>
            /// The selected properties that should be expanded during template evaluation.
            /// </summary>
            public SelectedPropertiesNode SelectedProperties { get; private set; }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightNestedResourceInfoScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="nestedResourceInfo">The nested resource info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedTypeReference">The expected type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedTypeReference"/> is the expected base type reference the items in the nested resource info.</remarks>
            internal JsonLightNestedResourceInfoScope(ODataJsonLightReaderNestedResourceInfo nestedResourceInfo, IEdmNavigationSource navigationSource, IEdmTypeReference expectedTypeReference, ODataUri odataUri)
                : base(ODataReaderState.NestedResourceInfoStart, nestedResourceInfo.NestedResourceInfo, navigationSource, expectedTypeReference, odataUri)
            {
                this.ReaderNestedResourceInfo = nestedResourceInfo;
            }

            /// <summary>
            /// The nested resource info for the nested resource info to report.
            /// This is only used on a StartNestedResourceInfo scope in responses.
            /// </summary>
            public ODataJsonLightReaderNestedResourceInfo ReaderNestedResourceInfo { get; private set; }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightNestedPropertyInfoScope : Scope
        {
            /// <summary>
            /// Constructor creating a new nested property info scope.
            /// </summary>
            /// <param name="nestedPropertyInfo">The nested property info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightNestedPropertyInfoScope(ODataJsonLightReaderNestedPropertyInfo nestedPropertyInfo, IEdmNavigationSource navigationSource, ODataUri odataUri)
                : base(ODataReaderState.NestedProperty, nestedPropertyInfo.NestedPropertyInfo,
                      navigationSource, EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Stream, true), odataUri)
            {
                Debug.Assert(nestedPropertyInfo != null, "JsonLightNestedInfoScope created with a null nestedPropertyInfo");
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightStreamScope : StreamScope
        {
            /// <summary>
            /// Constructor creating a new nested property info scope.
            /// </summary>
            /// <param name="streamInfo">The stream info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightStreamScope(ODataJsonLightReaderStreamInfo streamInfo, IEdmNavigationSource navigationSource, ODataUri odataUri)
                : base(ODataReaderState.Stream, new ODataStreamItem(streamInfo.PrimitiveTypeKind, streamInfo.ContentType),
                      navigationSource, EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Stream, true), odataUri)
            {
                Debug.Assert(streamInfo != null, "JsonLightNestedStreamScope created with a null streamInfo");
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightDeltaLinkScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of the new scope that is being created.</param>
            /// <param name="link">The link info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedEntityType">The expected type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedEntityType"/> has the following meaning
            ///   it's the expected base type the entries in the expanded link (either the single resource
            ///   or entries in the expanded resource set).
            /// In all cases the specified type must be an entity type.</remarks>
            public JsonLightDeltaLinkScope(ODataReaderState state, ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType expectedEntityType, ODataUri odataUri)
                : base(state, link, navigationSource, expectedEntityType.ToTypeReference(true), odataUri)
            {
                Debug.Assert(
                    state == ODataReaderState.DeltaLink && link is ODataDeltaLink ||
                    state == ODataReaderState.DeltaDeletedLink && link is ODataDeltaDeletedLink,
                    "link must be either DeltaLink or DeltaDeletedLink.");
            }
        }

        #endregion Scopes
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Threading.Tasks;
using Microsoft.OData.Evaluation;
using Microsoft.OData.Json;
using Microsoft.OData.Metadata;
using Microsoft.OData.UriParser;
using Microsoft.OData.Edm;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.JsonLight
{
    /// <summary>
    /// OData reader for the JsonLight format.
    /// </summary>
    internal sealed class ODataJsonLightReader : ODataReaderCoreAsync
    {
        #region private fields
        /// <summary>The input to read the payload from.</summary>
        private readonly ODataJsonLightInputContext jsonLightInputContext;

        /// <summary>The resource and resource set deserializer to read input with.</summary>
        private readonly ODataJsonLightResourceDeserializer jsonLightResourceDeserializer;

        /// <summary>The scope associated with the top level of this payload.</summary>
        private readonly JsonLightTopLevelScope topLevelScope;

        /// <summary>true if the reader is created for reading parameter; false otherwise.</summary>
        private readonly bool readingParameter;
        #endregion private fields

        #region Constructors
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightInputContext">The input to read the payload from.</param>
        /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
        /// <param name="expectedResourceType">The expected structured type for the resource to be read (in case of resource reader) or entries in the resource set to be read (in case of resource set reader).</param>
        /// <param name="readingResourceSet">true if the reader is created for reading a resource set; false when it is created for reading a resource.</param>
        /// <param name="readingParameter">true if the reader is created for reading a parameter; false otherwise.</param>
        /// <param name="readingDelta">true if the reader is created for reading expanded navigation property in delta response; false otherwise.</param>
        /// <param name="listener">If not null, the Json reader will notify the implementer of the interface of relevant state changes in the Json reader.</param>
        internal ODataJsonLightReader(
            ODataJsonLightInputContext jsonLightInputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType expectedResourceType,
            bool readingResourceSet,
            bool readingParameter = false,
            bool readingDelta = false,
            IODataReaderWriterListener listener = null)
            : base(jsonLightInputContext, readingResourceSet, readingDelta, listener)
        {
            Debug.Assert(jsonLightInputContext != null, "jsonLightInputContext != null");
            Debug.Assert(
                expectedResourceType == null || jsonLightInputContext.Model.IsUserModel(),
                "If the expected type is specified we need model as well. We should have verified that by now.");

            this.jsonLightInputContext = jsonLightInputContext;
            this.jsonLightResourceDeserializer = new ODataJsonLightResourceDeserializer(jsonLightInputContext);
            this.readingParameter = readingParameter;
            this.topLevelScope = new JsonLightTopLevelScope(navigationSource, expectedResourceType, new ODataUri());
            this.EnterScope(this.topLevelScope);
        }

        #endregion

        #region private properties

        /// <summary>
        /// Returns the current resource state.
        /// </summary>
        private IODataJsonLightReaderResourceState CurrentResourceState
        {
            get
            {
                Debug.Assert(
                    this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd ||
                    this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                    "This property can only be accessed in the EntryStart or EntryEnd scope.");
                return (IODataJsonLightReaderResourceState)this.CurrentScope;
            }
        }

        /// <summary>
        /// Returns current scope cast to JsonLightResourceSetScope
        /// </summary>
        private JsonLightResourceSetScope CurrentJsonLightResourceSetScope
        {
            get
            {
                return ((JsonLightResourceSetScope)this.CurrentScope);
            }
        }

        /// <summary>
        /// Returns current scope cast to JsonLightNestedResourceInfoScope
        /// </summary>
        private JsonLightNestedResourceInfoScope CurrentJsonLightNestedResourceInfoScope
        {
            get
            {
                return ((JsonLightNestedResourceInfoScope)this.CurrentScope);
            }
        }

        /// <summary>
        /// Returns nest info of current resource.
        /// </summary>
        private ODataNestedResourceInfo ParentNestedInfo
        {
            get
            {
                // NestInfo/Resource or NestInfo/ResourceSet/Resource
                Scope scope = SeekScope<JsonLightNestedResourceInfoScope>(maxDepth: 3);

                return scope != null ? (ODataNestedResourceInfo)scope.Item : null;
            }
        }
        #endregion private properties

        #region ReadAt<>Implementation Methods
        #region ReadAtStartImplementation
        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        protected override bool ReadAtStartImplementation()
        {
            Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
            Debug.Assert(
                this.IsReadingNestedPayload ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.None,
                "Pre-Condition: expected JsonNodeType.None when not reading a nested payload.");

            PropertyAndAnnotationCollector propertyAndAnnotationCollector =
                this.jsonLightInputContext.CreatePropertyAndAnnotationCollector();

            // Position the reader on the first node depending on whether we are reading a nested payload or a Uri Operation Parameter or not.
            ODataPayloadKind payloadKind = this.ReadingResourceSet ?
                this.ReadingDelta ? ODataPayloadKind.Delta : ODataPayloadKind.ResourceSet : ODataPayloadKind.Resource;

            // Following parameter "this.IsReadingNestedPayload || this.readingParameter" indicates whether to read
            // { "value" :
            // or
            // { "parameterName" :
            this.jsonLightResourceDeserializer.ReadPayloadStart(
                payloadKind,
                propertyAndAnnotationCollector,
                this.IsReadingNestedPayload || this.readingParameter,
                /*allowEmptyPayload*/false);

            ResolveScopeInfoFromContextUrl();

            Scope currentScope = this.CurrentScope;
            if (this.jsonLightInputContext.Model.IsUserModel())
            {
                var derivedTypeConstraints = this.jsonLightInputContext.Model.GetDerivedTypeConstraints(currentScope.NavigationSource);
                if (derivedTypeConstraints != null)
                {
                    currentScope.DerivedTypeValidator = new DerivedTypeValidator(currentScope.ResourceType, derivedTypeConstraints, "navigation source", currentScope.NavigationSource.Name);
                }
            }

            return this.ReadAtStartImplementationSynchronously(propertyAndAnnotationCollector);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        protected override Task<bool> ReadAtStartImplementationAsync()
        {
            Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
            Debug.Assert(
                this.IsReadingNestedPayload ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.None,
                "Pre-Condition: expected JsonNodeType.None when not reading a nested payload.");

            PropertyAndAnnotationCollector propertyAndAnnotationCollector =
                this.jsonLightInputContext.CreatePropertyAndAnnotationCollector();

            // Position the reader on the first node depending on whether we are reading a nested payload or not.
            ODataPayloadKind payloadKind = this.ReadingDelta
                ? ODataPayloadKind.Delta
                : this.ReadingResourceSet ?
                    ODataPayloadKind.ResourceSet
                    : ODataPayloadKind.Resource;

            return this.jsonLightResourceDeserializer.ReadPayloadStartAsync(
                payloadKind,
                propertyAndAnnotationCollector,
                this.IsReadingNestedPayload,
                /*allowEmptyPayload*/false)
                .FollowOnSuccessWith(t => ResolveScopeInfoFromContextUrl())
                .FollowOnSuccessWith(t =>
                    this.ReadAtStartImplementationSynchronously(propertyAndAnnotationCollector));
        }

        #endregion ReadAtStartImplementation

        #region ResourceSet
        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override bool ReadAtResourceSetStartImplementation()
        {
            return this.ReadAtResourceSetStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override Task<bool> ReadAtResourceSetStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override bool ReadAtResourceSetEndImplementation()
        {
            return this.ReadAtResourceSetEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override Task<bool> ReadAtResourceSetEndImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetEndImplementationSynchronously);
        }

        #endregion ResourceSet

        #region Resource
        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtResourceStartImplementation()
        {
            return this.ReadAtResourceStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtResourceStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        protected override bool ReadAtResourceEndImplementation()
        {
            return this.ReadAtResourceEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        protected override Task<bool> ReadAtResourceEndImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceEndImplementationSynchronously);
        }

        #endregion Resource

        #region Primitive
        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        protected override bool ReadAtPrimitiveImplementation()
        {
            return this.ReadAtPrimitiveSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        protected override Task<bool> ReadAtPrimitiveImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtPrimitiveSynchronously);
        }

        #endregion Primitive

        #region Property

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected override bool ReadAtNestedPropertyInfoImplementation()
        {
            return this.ReadAtNestedPropertyInfoSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        protected override Task<bool> ReadAtNestedPropertyInfoImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtNestedPropertyInfoSynchronously);
        }

        #endregion

        #region Stream

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected override bool ReadAtStreamImplementation()
        {
            return this.ReadAtStreamSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        protected override Task<bool> ReadAtStreamImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtStreamSynchronously);
        }

        /// <summary>
        /// Creates a stream for reading an inline stream property.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        protected override Stream CreateReadStreamImplementation()
        {
            Stream stream;

            if (this.jsonLightInputContext.JsonReader is IJsonStreamReader streamReader)
            {
                stream = streamReader.CreateReadStream();
            }
            else
            {
                // JSONReader doesn't support streaming; read as a string and convert
                // Skip over property or start array
                this.jsonLightInputContext.JsonReader.Read();
                string valueAsString = this.jsonLightInputContext.JsonReader.ReadStringValue();
                stream = new MemoryStream(Convert.FromBase64String(valueAsString.Replace('_', '/').Replace('-', '+')));
            }

            return stream;
        }

        protected override TextReader CreateTextReaderImplementation()
        {
            TextReader reader;

            if (this.jsonLightInputContext.JsonReader is IJsonStreamReader jsonStreamReader)
            {
                reader = jsonStreamReader.CreateTextReader();
            }
            else
            {
                // JSONReader doesn't support streaming; read as a string and convert
                // Skip over property or start array
                this.jsonLightInputContext.JsonReader.Read();
                string valueAsString = this.jsonLightInputContext.JsonReader.ReadStringValue();
                reader = new StringReader(valueAsString);
            }

            return reader;
        }

        #endregion

        #region NestedResourceInfo
        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// </remarks>
        protected override bool ReadAtNestedResourceInfoStartImplementation()
        {
            return this.ReadAtNestedResourceInfoStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource
        /// </remarks>
        protected override Task<bool> ReadAtNestedResourceInfoStartImplementationAsync()
        {
            return
                TaskUtils.GetTaskForSynchronousOperation<bool>(
                    this.ReadAtNestedResourceInfoStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        protected override bool ReadAtNestedResourceInfoEndImplementation()
        {
            return this.ReadAtNestedResourceInfoEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        protected override Task<bool> ReadAtNestedResourceInfoEndImplementationAsync()
        {
            return
                TaskUtils.GetTaskForSynchronousOperation<bool>(
                    this.ReadAtNestedResourceInfoEndImplementationSynchronously);
        }

        #endregion NestedResourceInfo

        #region EntityReferenceLink
        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        protected override bool ReadAtEntityReferenceLink()
        {
            return this.ReadAtEntityReferenceLinkSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        protected override Task<bool> ReadAtEntityReferenceLinkAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtEntityReferenceLinkSynchronously);
        }

        #endregion EntityReferenceLink

        #region DeltaResourceSet

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override bool ReadAtDeltaResourceSetStartImplementation()
        {
            return this.ReadAtResourceSetStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        protected override Task<bool> ReadAtDeltaResourceSetStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override bool ReadAtDeltaResourceSetEndImplementation()
        {
            // Logic is same as for ResourceSet
            return this.ReadAtResourceSetEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        protected override Task<bool> ReadAtDeltaResourceSetEndImplementationAsync()
        {
            // Logic is same as for ResourceSet
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceSetEndImplementationSynchronously);
        }

        #endregion DeltaResourceSet

        #region DeltaDeletedEntry

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedEntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeletedResourceStartImplementation()
        {
            return this.ReadAtDeletedResourceStartImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedResourceStart'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeletedResourceStartImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeletedResourceStartImplementationSynchronously);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue         end of primitive value in a collection
        /// Post-Condition: The reader is positioned on the first node after the deleted resource's end-object node
        /// </remarks>
        protected override bool ReadAtDeletedResourceEndImplementation()
        {
            // Same logic as ReadAtResourceEndImplementation
            return this.ReadAtResourceEndImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the deleted resource's end-object node
        /// </remarks>
        protected override Task<bool> ReadAtDeletedResourceEndImplementationAsync()
        {
            // Same logic as ReadAtResourceEndImplementationAsync
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtResourceEndImplementationSynchronously);
        }

        #endregion DeltaDeletedEntry

        #region DeltaLink

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndArray               If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeltaLinkImplementation()
        {
            return this.ReadAtDeltaLinkImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeltaLinkImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeltaLinkImplementationSynchronously);
        }

        #endregion DeltaLink

        #region DeltaDeletedLink

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLinkImplementation'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndArray               If no (more) properties exist in the resource's content
        /// </remarks>
        protected override bool ReadAtDeltaDeletedLinkImplementation()
        {
            return this.ReadAtDeltaDeletedLinkImplementationSynchronously();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLinkImplementation'.
        /// </summary>
        /// <returns>A task which returns true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        protected override Task<bool> ReadAtDeltaDeletedLinkImplementationAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadAtDeltaDeletedLinkImplementationSynchronously);
        }

        #endregion DeltaDeletedLink

        #endregion ReadAt<>Implementation methods

        #region ReadAt<>ImplementationSynchronously methods

        #region Start

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the top-level scope.</param>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.None:      assumes that the JSON reader has not been used yet when not reading a nested payload.
        /// Post-Condition: when reading a resource set:    the reader is positioned on the first item in the resource set or the end array node of an empty resource set
        ///                 when reading a resource:  the first node of the first nested resource info value, null for a null expanded link or an end object
        ///                                         node if there are no navigation links.
        /// </remarks>
        private bool ReadAtStartImplementationSynchronously(
            PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");

            // For nested payload (e.g., expanded resource set or resource in delta $entity payload),
            // we usually don't have a context URL for the resource set or resource:
            // {
            //   "@odata.context":"...", <--- this context URL is for delta entity only
            //   "value": [
            //     {
            //       ...
            //       "NavigationProperty": <--- usually we don't have a context URL for this
            //       [ <--- nested payload start
            //         {...}
            //       ] <--- nested payload end
            //     }
            //    ]
            // }
            //
            // The consequence is that the resource we read out from a nested payload doesn't
            // have an entity metadata builder thus you cannot compute read link, edit link,
            // etc. from the resource object.
            if (this.jsonLightInputContext.ReadingResponse && !this.IsReadingNestedPayload)
            {
                Debug.Assert(this.jsonLightResourceDeserializer.ContextUriParseResult != null,
                    "We should have failed by now if we don't have parse results for context URI.");

                // Validate the context URI parsed from the payload against the entity set and entity type passed in through the API.
                ReaderValidationUtils.ValidateResourceSetOrResourceContextUri(
                    this.jsonLightResourceDeserializer.ContextUriParseResult, this.CurrentScope, true);
            }

            // Get the $select query option from the metadata link, if we have one.
            string selectQueryOption = this.jsonLightResourceDeserializer.ContextUriParseResult == null
                ? null
                : this.jsonLightResourceDeserializer.ContextUriParseResult.SelectQueryOption;

            SelectedPropertiesNode selectedProperties = SelectedPropertiesNode.Create(selectQueryOption, (this.CurrentResourceTypeReference != null) ? this.CurrentResourceTypeReference.AsStructured().StructuredDefinition() : null, this.jsonLightInputContext.Model);

            if (this.ReadingResourceSet)
            {
                // Store the duplicate property names checker to use it later when reading the resource set end
                // (since we allow resourceSet-related annotations to appear after the resource set's data).
                this.topLevelScope.PropertyAndAnnotationCollector = propertyAndAnnotationCollector;

                bool isReordering = this.jsonLightInputContext.JsonReader is ReorderingJsonReader;

                if (this.ReadingDelta)
                {
                    ODataDeltaResourceSet resourceSet = new ODataDeltaResourceSet();

                    // Read top-level resource set annotations for delta resource sets.
                    this.jsonLightResourceDeserializer.ReadTopLevelResourceSetAnnotations(
                        resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/true,
                        /*readAllFeedProperties*/isReordering);
                    this.ReadDeltaResourceSetStart(resourceSet, selectedProperties);

                    this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndArray, JsonNodeType.StartObject);
                }
                else
                {
                    ODataResourceSet resourceSet = new ODataResourceSet();
                    if (!this.IsReadingNestedPayload)
                    {
                        if (!this.readingParameter)
                        {
                            // Skip top-level resource set annotations for nested resource sets.
                            this.jsonLightResourceDeserializer.ReadTopLevelResourceSetAnnotations(
                                resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/true,
                                /*readAllFeedProperties*/isReordering);
                        }
                        else
                        {
                            // This line will be used to read the first node of a resource set in Uri operation parameter, The first node is : '['
                            // Node is in following format:
                            // [
                            //      {...}, <------------ complex object.
                            //      {...}, <------------ complex object.
                            // ]
                            this.jsonLightResourceDeserializer.JsonReader.Read();
                        }
                    }

                    this.ReadResourceSetStart(resourceSet, selectedProperties);
                }

                return true;
            }

            this.ReadResourceSetItemStart(propertyAndAnnotationCollector, selectedProperties);
            return true;
        }

        #endregion Start

        #region ResourceSet

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  Any start node            - The first resource in the resource set
        ///                 JsonNodeType.EndArray     - The end of the resource set
        /// Post-Condition: The reader is positioned over the StartObject node of the first resource in the resource set or
        ///                 on the node following the resource set end in case of an empty resource set
        /// </remarks>
        private bool ReadAtResourceSetStartImplementationSynchronously()
        {
            this.ReadNextResourceSetItem();
            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.Property        if the resource set has further instance or property annotations after the resource set property
        ///                JsonNodeType.EndObject       if the resource set has no further instance or property annotations after the resource set property
        ///                JsonNodeType.EndOfInput      if the resource set is in a Uri operation parameter.
        ///                JsonNodeType.StartArray      if the resource set is a member of an untyped collection followed by a collection
        ///                JsonNodeType.PrimitiveValue  if the resource set is a member of an untyped collection followed by a primitive value
        ///                JsonNodeType.StartObject     if the resource set is a member of an untyped collection followed by a resource
        ///                JsonNodeType.EndArray        if the resource set is the last member of an untyped collection
        /// Post-Condition: JsonNodeType.EndOfInput     for a top-level resource set when not reading a nested payload
        ///                 JsonNodeType.Property       more properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndObject      no further properties exist on the owning resource after the expanded link containing the resource set
        ///                 JsonNodeType.EndArray       end of expanded link in request, in this case the resource set doesn't actually own the array object and it won't read it.
        ///                 Any                         in case of expanded resource set in request, this might be the next item in the expanded array, which is not a resource
        /// </remarks>
        private bool ReadAtResourceSetEndImplementationSynchronously()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetEnd || this.State == ODataReaderState.DeltaResourceSetEnd, "Not in (delta) resource set end state.");
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput ||
                (this.ParentScope != null && (this.ParentScope.ResourceType == null || this.ParentScope.ResourceType.TypeKind == EdmTypeKind.Untyped) &&
                    (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndArray)) ||
                !this.IsTopLevel && !this.jsonLightInputContext.ReadingResponse,
                "Pre-Condition: expected JsonNodeType.EndObject or JsonNodeType.Property, or JsonNodeType.StartArray, JsonNodeTypeStart.Object, or JsonNodeType.EndArray with an untyped collection");

            bool isTopLevelResourceSet = this.IsTopLevel;
            bool isExpandedLinkContent = this.IsExpandedLinkContent;

            this.PopScope(this.State == ODataReaderState.ResourceSetEnd ? ODataReaderState.ResourceSetEnd : ODataReaderState.DeltaResourceSetEnd);

            // When we finish a top-level resource set in a nested payload (inside parameter or delta payload),
            // we can directly turn the reader into Completed state because we don't have any JSON token
            // (e.g., EndObject in a normal resource set payload) left in the stream.
            //
            // Nested resource set payload:
            // [
            //   {...},
            //   ...
            // ]
            // EOF <--- current reader position
            //
            // Normal resource set payload:
            // {
            //   "@odata.context":"...",
            //   ...,
            //   "value": [
            //     {...},
            //     ...
            //   ],
            //   "@odata.nextLink":"..."
            // } <--- current reader position
            // EOF
            //
            // Normal resource set payload as uri operation parameter
            // [
            //   {...},
            //   ...
            // ]
            // EOF <--- current reader position
            if ((this.IsReadingNestedPayload || this.readingParameter) && isTopLevelResourceSet)
            {
                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                return false;
            }

            if (isTopLevelResourceSet)
            {
                Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");

                // Read the end-object node of the resource set object and position the reader on the next input node
                // This can hit the end of the input.
                this.jsonLightResourceDeserializer.JsonReader.Read();

                // read the end-of-payload
                this.jsonLightResourceDeserializer.ReadPayloadEnd(this.IsReadingNestedPayload);

                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                return false;
            }
            else if (isExpandedLinkContent)
            {
                // finish reading the expanded link
                this.ReadExpandedNestedResourceInfoEnd(true);
                return true;
            }

            // read the next item in an untyped collection
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion ResourceSet

        #region Resource
        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private bool ReadAtResourceStartImplementationSynchronously()
        {
            if (this.Item is ODataResourceBase currentResource && !this.IsReadingNestedPayload)
            {
                this.CurrentResourceState.ResourceTypeFromMetadata = this.ParentScope.ResourceType as IEdmStructuredType;
                ODataResourceMetadataBuilder builder =
                    this.jsonLightResourceDeserializer.MetadataContext.GetResourceMetadataBuilderForReader(
                        this.CurrentResourceState,
                        this.jsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                        this.ReadingDelta);
                if (builder != currentResource.MetadataBuilder)
                {
                    ODataNestedResourceInfo parentNestInfo = this.ParentNestedInfo;

                    // If it's ODataConventionalResourceMetadataBuilder, then it means we need to build nested relationship for it in containment case
                    if (builder is ODataConventionalResourceMetadataBuilder conventionalResourceMetadataBuilder)
                    {
                        if (parentNestInfo != null)
                        {
                            conventionalResourceMetadataBuilder.NameAsProperty = parentNestInfo.Name;
                            conventionalResourceMetadataBuilder.IsFromCollection = parentNestInfo.IsCollection == true;
                            conventionalResourceMetadataBuilder.ODataUri = ResolveODataUriFromContextUrl(parentNestInfo) ?? CurrentScope.ODataUri;
                        }

                        conventionalResourceMetadataBuilder.StartResource();
                    }

                    // Set the metadata builder and parent metadata builder for the resource itself
                    currentResource.MetadataBuilder = builder;
                    if (parentNestInfo?.MetadataBuilder != null)
                    {
                        currentResource.MetadataBuilder.ParentMetadataBuilder = parentNestInfo.MetadataBuilder;
                    }
                }
            }

            if (currentResource == null)
            {
                // Debug.Assert(this.IsExpandedLinkContent || this.CurrentResourceType.IsODataComplexTypeKind() || this.CurrentResourceType.TypeKind == EdmTypeKind.Untyped,
                //    "null or untyped resource can only be reported in an expanded link or in collection of complex instance.");
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.PrimitiveValue);

                // There's nothing to read, so move to the end resource state
                this.EndEntry();
            }
            else if (this.CurrentResourceState.FirstNestedInfo != null)
            {
                this.ReadNestedInfo(this.CurrentResourceState.FirstNestedInfo);
            }
            else
            {
                // End of resource
                // All the properties have already been read before we actually entered the EntryStart state (since we read as far as we can in any given state).
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject);
                this.EndEntry();
            }

            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.PrimitiveValue or JsonNodeType.Property or JsonNodeType.EndObject");

            return true;
        }

        /// <summary>
        /// If the nested info has context url, resolve it to ODataUri.
        /// </summary>
        /// <param name="nestedInfo">The nestedInfo to be evaluated.</param>
        /// <returns>The odata uri resolved from context url.</returns>
        private ODataUri ResolveODataUriFromContextUrl(ODataNestedResourceInfo nestedInfo)
        {
            if (nestedInfo?.ContextUrl != null)
            {
                var payloadKind = nestedInfo.IsCollection.GetValueOrDefault()
                    ? ODataPayloadKind.ResourceSet
                    : ODataPayloadKind.Resource;
                var odataPath = ODataJsonLightContextUriParser.Parse(
                    this.jsonLightResourceDeserializer.Model,
                    UriUtils.UriToString(nestedInfo.ContextUrl),
                    payloadKind,
                    this.jsonLightResourceDeserializer.MessageReaderSettings.ClientCustomTypeResolver,
                    this.jsonLightResourceDeserializer.JsonLightInputContext.ReadingResponse).Path;

                return new ODataUri() { Path = odataPath };
            }

            return null;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              end of object of the resource
        ///                 JsonNodeType.PrimitiveValue (null)  end of null expanded resource
        /// Post-Condition: The reader is positioned on the first node after the resource's end-object node
        /// </remarks>
        private bool ReadAtResourceEndImplementationSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null),
                "Pre-Condition: JsonNodeType.EndObject or JsonNodeType.PrimitiveValue (null)");

            // We have to cache these values here, since the PopScope below will destroy them.
            bool isTopLevel = this.IsTopLevel;
            bool isExpandedLinkContent = this.IsExpandedLinkContent;

            this.PopScope(this.State == ODataReaderState.ResourceEnd ? ODataReaderState.ResourceEnd : ODataReaderState.DeletedResourceEnd);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This can hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();

            // Analyze the next Json token to determine whether it is start object (next resource), end array (resource set end) or eof (top-level resource end)
            bool result = true;
            if (isTopLevel)
            {
                // NOTE: we rely on the underlying JSON reader to fail if there is more than one value at the root level.
                Debug.Assert(
                    this.IsReadingNestedPayload ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput,
                    "Expected JSON reader to have reached the end of input when not reading a nested payload.");

                // read the end-of-payload
                Debug.Assert(this.State == ODataReaderState.Start, "this.State == ODataReaderState.Start");
                this.jsonLightResourceDeserializer.ReadPayloadEnd(this.IsReadingNestedPayload);
                Debug.Assert(
                    this.IsReadingNestedPayload ||
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndOfInput,
                    "Expected JSON reader to have reached the end of input when not reading a nested payload.");

                // replace the 'Start' scope with the 'Completed' scope
                this.ReplaceScope(ODataReaderState.Completed);
                result = false;
            }
            else if (isExpandedLinkContent)
            {
                Debug.Assert(
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject || // expanded link resource as last property of the owning resource
                    this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property, // expanded link resource with more properties on the resource
                    "Invalid JSON reader state for reading end of resource in expanded link.");

                // finish reading the expanded link
                this.ReadExpandedNestedResourceInfoEnd(false);
            }
            else
            {
                this.ReadNextResourceSetItem();
            }

            return result;
        }

        #endregion Resource

        #region Primitive

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         primitive value
        /// Post-Condition: The reader is positioned on the first node after the primitive value
        /// </remarks>
        private bool ReadAtPrimitiveSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue,
                "Pre-Condition: JsonNodeType.PrimitiveValue (null or untyped)");

            this.PopScope(ODataReaderState.Primitive);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This should never hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion Primitive

        #region DeletedEntry

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedEntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.StartObject            Start of the expanded resource of the nested resource info to read next.
        ///                 JsonNodeType.StartArray             Start of the expanded resource set of the nested resource info to read next.
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next.
        ///                 JsonNodeType.Property               The next property after a deferred link or entity reference link
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private bool ReadAtDeletedResourceStartImplementationSynchronously()
        {
            Debug.Assert(this.CurrentScope is JsonLightDeletedResourceScope);

            if (((JsonLightDeletedResourceScope)(this.CurrentScope)).Is40DeletedResource)
            {
                this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject);
                this.EndEntry();
                return true;
            }

            return this.ReadAtResourceStartImplementationSynchronously();
        }

        #endregion DeletedEntry

        #region (Deleted)Link

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool ReadAtDeltaLinkImplementationSynchronously()
        {
            return this.EndDeltaLink(ODataReaderState.DeltaLink);
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool ReadAtDeltaDeletedLinkImplementationSynchronously()
        {
            return this.EndDeltaLink(ODataReaderState.DeltaDeletedLink);
        }

        /// <summary>
        /// Reads the end of the delta(deleted)link.
        /// </summary>
        /// <param name="readerState">The state of the link or deleted link being completed.</param>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The next annotation.
        ///                 JsonNodeType.EndObject              No more other annotation or property in the link.
        /// Post-Condition: The reader is positioned on the first node after the link's end-object node.
        /// </remarks>
        private bool EndDeltaLink(ODataReaderState readerState)
        {
            Debug.Assert(readerState == ODataReaderState.DeltaLink || readerState == ODataReaderState.DeltaDeletedLink, "ReadAtDeltaLinkImplementation called when not on delta(deleted)link");
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject,
                "Not positioned at end of object after reading delta link");

            this.PopScope(readerState);

            // Read over the end object node (or null value) and position the reader on the next node in the input.
            // This should never hit the end of the input.
            this.jsonLightResourceDeserializer.JsonReader.Read();
            this.ReadNextResourceSetItem();
            return true;
        }

        #endregion (Deleted)Link

        #region NestedResourceInfo

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            start of an expanded resource
        ///                 JsonNodeType.StartArray             start of an expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource or
        ///                                                     reporting projected navigation links missing in the payload
        /// Post-Condition: JsonNodeType.StartArray:            start of expanded resource
        ///                 JsonNodeType.StartObject            start of expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  expanded null resource
        ///                 JsonNodeType.Property               deferred link with more properties in owning resource
        ///                 JsonNodeType.EndObject              deferred link as last property of the owning resource or
        ///                                                     reporting projected navigation links missing in the payload
        /// </remarks>
        private bool ReadAtNestedResourceInfoStartImplementationSynchronously()
        {
            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null,
                "Pre-Condition: expected JsonNodeType.Property, JsonNodeType.EndObject, JsonNodeType.StartObject, JsonNodeType.StartArray or JsonNodeType.Primitive (null)");

            ODataNestedResourceInfo currentLink = this.CurrentNestedResourceInfo;

            IODataJsonLightReaderResourceState parentResourceState = (IODataJsonLightReaderResourceState)this.ParentScope;

            if (this.jsonLightInputContext.ReadingResponse)
            {
                // If we are reporting a nested resource info that was projected but not included in the payload,
                // simply change state to NestedResourceInfoEnd.
                if (parentResourceState.ProcessingMissingProjectedNestedResourceInfos)
                {
                    this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
                }
                else if (!this.jsonLightResourceDeserializer.JsonReader.IsOnValueNode())
                {
                    // Deferred link (nested resource info which doesn't have a value and is in the response)
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);
                    this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject, JsonNodeType.Property);

                    // Record that we read the link on the parent resource's scope.
                    parentResourceState.NavigationPropertiesRead.Add(currentLink.Name);

                    this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
                }
                else if (!currentLink.IsCollection.Value)
                {
                    // We should get here only for declared or undeclared navigation properties.
                    Debug.Assert(this.CurrentResourceType != null || this.CurrentNestedResourceInfo.Name != null,
                        "We must have a declared navigation property to read expanded links.");

                    // Expanded resource
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);
                    this.ReadExpandedNestedResourceInfoStart(currentLink);
                }
                else
                {
                    // Expanded resource set
                    ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                        parentResourceState.PropertyAndAnnotationCollector, currentLink);

                    // We store the precreated expanded resource set in the nested resource info since it carries the annotations for it.
                    ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                        this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo;
                    Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
                    Debug.Assert(nestedResourceInfo.NestedResourceSet != null,
                        "We must have a precreated expanded resource set already.");
                    JsonLightResourceBaseScope parentScope = (JsonLightResourceBaseScope)this.ParentScope;
                    SelectedPropertiesNode parentSelectedProperties = parentScope.SelectedProperties;
                    Debug.Assert(parentSelectedProperties != null, "parentProjectedProperties != null");

                    if (nestedResourceInfo.NestedResourceSet is ODataResourceSet resourceSet)
                    {
                        this.ReadResourceSetStart(resourceSet, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, currentLink.Name));
                    }
                    else
                    {
                        Debug.Assert(nestedResourceInfo.NestedResourceSet is ODataDeltaResourceSet deltaResourceSet, "Nested resource collection is not a resource set or a delta resource set");
                        this.ReadDeltaResourceSetStart(deltaResourceSet, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, currentLink.Name));
                    }
                }
            }
            else
            {
                // Navigation link in request - report entity reference links and then possible expanded value.
                ReaderUtils.CheckForDuplicateNestedResourceInfoNameAndSetAssociationLink(
                    parentResourceState.PropertyAndAnnotationCollector,
                    currentLink);

                this.ReadNextNestedResourceInfoContentItemInRequest();
            }

            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource or
        ///                                                 reporting projected navigation links missing in the payload
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtNestedResourceInfoEndImplementationSynchronously()
        {
            this.PopScope(ODataReaderState.NestedResourceInfoEnd);
            return this.ReadNextNestedInfo();
        }


        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtNestedPropertyInfoSynchronously()
        {
            ODataPropertyInfo propertyInfo = this.CurrentScope.Item as ODataPropertyInfo;
            Debug.Assert(propertyInfo != null, "Reading Nested Property Without an ODataPropertyInfo");

            if (propertyInfo is ODataStreamPropertyInfo streamPropertyInfo && !String.IsNullOrEmpty(streamPropertyInfo.ContentType))
            {
                this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(streamPropertyInfo.PrimitiveTypeKind, streamPropertyInfo.ContentType));
            }
            else
            {
                this.StartNestedStreamInfo(
                    new ODataJsonLightReaderStreamInfo(propertyInfo.PrimitiveTypeKind));
            }

            return true;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject:         nested resource info is last property in owning resource or
        ///                                                 reporting projected navigation links missing in the payload
        ///                 JsonNodeType.Property:          there are more properties after the nested resource info in the owning resource
        /// Post-Condition: JsonNodeType.StartObject        start of the expanded resource nested resource info to read next
        ///                 JsonNodeType.StartArray         start of the expanded resource set nested resource info to read next
        ///                 JsonNoteType.Primitive (null)   expanded null resource nested resource info to read next
        ///                 JsonNoteType.Property           property after deferred link or entity reference link
        ///                 JsonNodeType.EndObject          end of the parent resource
        /// </remarks>
        private bool ReadAtStreamSynchronously()
        {
            this.PopScope(ODataReaderState.Stream);
            if (this.State == ODataReaderState.ResourceSetStart ||
                this.State == ODataReaderState.DeltaResourceSetStart)
            {
                // We are reading a stream within a collection
                this.ReadNextResourceSetItem();
                return true;
            }

            if (this.State == ODataReaderState.NestedProperty)
            {
                this.PopScope(ODataReaderState.NestedProperty);
            }

            // We are reading a stream value
            return this.ReadNextNestedInfo();
        }

        private bool ReadNextNestedInfo()
        {
            this.jsonLightResourceDeserializer.AssertJsonCondition(
                JsonNodeType.EndObject,
                JsonNodeType.Property);
            Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "Should be in (deleted) resource start state after reading stream.");

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IODataJsonLightReaderResourceState resourceState = this.CurrentResourceState;

            if (this.jsonLightInputContext.ReadingResponse &&
                resourceState.ProcessingMissingProjectedNestedResourceInfos)
            {
                // We are reporting navigation links that were projected but missing from the payload
                readerNestedInfo = resourceState.Resource.MetadataBuilder.GetNextUnprocessedNavigationLink();
            }
            else
            {
                readerNestedInfo = this.jsonLightResourceDeserializer.ReadResourceContent(resourceState);
            }

            if (readerNestedInfo == null)
            {
                // End of the resource
                this.EndEntry();
            }
            else
            {
                this.ReadNestedInfo(readerNestedInfo);
            }

            return true;
        }

        private void ReadNestedInfo(ODataJsonLightReaderNestedInfo nestedInfo)
        {
            if (nestedInfo is ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo)
            {
                // Next nested resource info on the resource
                this.StartNestedResourceInfo(readerNestedResourceInfo);
            }
            else
            {
                Debug.Assert(nestedInfo is ODataJsonLightReaderNestedPropertyInfo readerNestedStreamInfo, "NestedInfo is not a resource, stream, string");

                if (nestedInfo is ODataJsonLightReaderNestedPropertyInfo readerNestedStreamInfo)
                {
                    this.StartNestedPropertyInfo(readerNestedStreamInfo);
                }
            }
        }

        #endregion NestedResourceInfo

        #region EntityReferenceLink

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        /// <remarks>
        /// This method doesn't move the reader
        /// Pre-Condition:  JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// Post-Condition: JsonNodeType.EndObject:         expanded link property is last property in owning resource
        ///                 JsonNodeType.Property:          there are more properties after the expanded link property in the owning resource
        ///                 Any:                            expanded collection link - the node after the entity reference link.
        /// </remarks>
        private bool ReadAtEntityReferenceLinkSynchronously()
        {
            this.PopScope(ODataReaderState.EntityReferenceLink);
            Debug.Assert(this.State == ODataReaderState.NestedResourceInfoStart,
                "this.State == ODataReaderState.NestedResourceInfoStart");

            this.ReadNextNestedResourceInfoContentItemInRequest();
            return true;
        }

        #endregion EntityReferenceLink

        #endregion ReadAt<>Synchronously methods

        #region Read<> methods

        #region ResourceSet

        /// <summary>
        /// Reads the start of the JSON array for the content of the resource set and sets up the reader state correctly.
        /// </summary>
        /// <param name="resourceSet">The resource set to read the contents for.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  The first node of the resource set property value; this method will throw if the node is not
        ///                 JsonNodeType.StartArray
        /// Post-Condition: The reader is positioned on the first item in the resource set, or on the end array of the resource set.
        /// </remarks>
        private void ReadResourceSetStart(ODataResourceSet resourceSet, SelectedPropertiesNode selectedProperties)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            this.jsonLightResourceDeserializer.ReadResourceSetContentStart();
            IJsonReader jsonReader = this.jsonLightResourceDeserializer.JsonReader;
            if (jsonReader.NodeType != JsonNodeType.EndArray
                && jsonReader.NodeType != JsonNodeType.StartObject
                && jsonReader.NodeType != JsonNodeType.PrimitiveValue
                && jsonReader.NodeType != JsonNodeType.StartArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidNodeTypeForItemsInResourceSet(jsonReader.NodeType));
            }

            this.EnterScope(new JsonLightResourceSetScope(resourceSet, this.CurrentNavigationSource,
                this.CurrentScope.ResourceTypeReference, selectedProperties, this.CurrentScope.ODataUri, /*isDelta*/ false));
        }

        /// <summary>
        /// Reads the end of the current resource set.
        /// </summary>
        private void ReadResourceSetEnd()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetStart || this.State == ODataReaderState.DeltaResourceSetStart,
                "Not in ResourceSetStart or DeltaResourceSetStart state when reading end of (delta) resource set.");
            Debug.Assert(this.Item is ODataResourceSetBase, "Current Item is not ResourceSetBase");

            this.jsonLightResourceDeserializer.ReadResourceSetContentEnd();

            ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo = null;
            JsonLightNestedResourceInfoScope parentNestedResourceInfoScope = (JsonLightNestedResourceInfoScope)this.ExpandedLinkContentParentScope;
            if (parentNestedResourceInfoScope != null)
            {
                expandedNestedResourceInfo = parentNestedResourceInfoScope.ReaderNestedResourceInfo;
            }

            if (!this.IsReadingNestedPayload && (this.IsExpandedLinkContent || this.IsTopLevel))
            {
                // Temp ban reading the instance annotation after the resource set in parameter payload. (!this.IsReadingNestedPayload => !this.readingParameter)
                // Nested resource set payload won't have a NextLink annotation after the resource set itself since the payload is NOT pageable.
                this.jsonLightResourceDeserializer.ReadNextLinkAnnotationAtResourceSetEnd(this.Item as ODataResourceSetBase,
                    expandedNestedResourceInfo, this.topLevelScope.PropertyAndAnnotationCollector);
            }

            this.ReplaceScope(this.State == ODataReaderState.ResourceSetStart ? ODataReaderState.ResourceSetEnd : ODataReaderState.DeltaResourceSetEnd);
        }

        #endregion ResourceSet

        #region NestedResourceInfo

        /// <summary>
        /// Reads the start of an expanded resource (null or non-null).
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info that is being expanded.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            The start of the resource object
        ///                 JsonNodeType.PrimitiveValue (null)  The null resource value
        /// Post-Condition: JsonNodeType.StartObject            Start of expanded resource of the nested resource info to read next
        ///                 JsonNodeType.StartArray             Start of expanded resource set of the nested resource info to read next
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next, or the null value of the current null resource
        ///                 JsonNodeType.Property               Property after deferred link or expanded entity reference
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private void ReadExpandedNestedResourceInfoStart(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.Value == null,
                    "If a primitive value is representing an expanded resource its value must be null.");

                var structuralProperty =
                    this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo.StructuralProperty;
                if (structuralProperty != null && !structuralProperty.Type.IsNullable)
                {
                    ODataNullValueBehaviorKind nullValueReadBehaviorKind =
                        this.jsonLightResourceDeserializer.ReadingResponse
                            ? ODataNullValueBehaviorKind.Default
                            : this.jsonLightResourceDeserializer.Model.NullValueReadBehaviorKind(structuralProperty);

                    if (nullValueReadBehaviorKind == ODataNullValueBehaviorKind.Default)
                    {
                        throw new ODataException(
                            Strings.ReaderValidationUtils_NullNamedValueForNonNullableType(nestedResourceInfo.Name,
                                structuralProperty.Type.FullName()));
                    }
                }

                // Expanded null resource
                // The expected type and expected navigation source for an expanded resource are the same as for the nested resource info around it.
                this.EnterScope(new JsonLightResourceScope(ODataReaderState.ResourceStart, /*resource*/ null,
                    this.CurrentNavigationSource, this.CurrentResourceTypeReference, /*propertyAndAnnotationCollector*/null,
                    /*projectedProperties*/null, this.CurrentScope.ODataUri));
            }
            else
            {
                // Expanded resource
                // The expected type for an expanded resource is the same as for the nested resource info around it.
                JsonLightResourceBaseScope parentScope = (JsonLightResourceBaseScope)this.ParentScope;
                SelectedPropertiesNode parentSelectedProperties = parentScope.SelectedProperties;
                Debug.Assert(parentSelectedProperties != null, "parentProjectedProperties != null");
                this.ReadResourceSetItemStart(/*propertyAndAnnotationCollector*/ null, parentSelectedProperties.GetSelectedPropertiesForNavigationProperty(parentScope.ResourceType, nestedResourceInfo.Name));
            }
        }

        /// <summary>
        /// Verifies that the current item is an <see cref="ODataNestedResourceInfo"/> instance,
        /// sets the cardinality of the link (IsCollection property) and moves the reader
        /// into state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <param name="isCollection">A flag indicating whether the link represents a collection or not.</param>
        private void ReadExpandedNestedResourceInfoEnd(bool isCollection)
        {
            Debug.Assert(this.State == ODataReaderState.NestedResourceInfoStart,
                "this.State == ODataReaderState.NestedResourceInfoStart");
            this.CurrentNestedResourceInfo.IsCollection = isCollection;

            // Record that we read the link on the parent resource's scope.
            IODataJsonLightReaderResourceState parentResourceState = (IODataJsonLightReaderResourceState)this.ParentScope;
            parentResourceState.NavigationPropertiesRead.Add(this.CurrentNestedResourceInfo.Name);

            // replace the 'NestedResourceInfoStart' scope with the 'NestedResourceInfoEnd' scope
            this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
        }

        #endregion NestedResourceInfo

        #region Resource

        /// <summary>
        /// Reads the start of a (standard, delta, primitive, or null) resource and sets up the reader state correctly
        /// </summary>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject            If the resource is in a resource set - the start of the resource object
        ///                 JsonNodeType.Property               If the resource is a top-level resource and has at least one property
        ///                 JsonNodeType.EndObject              If the resource is a top-level resource and has no properties
        /// Post-Condition: JsonNodeType.StartObject            Start of expanded resource of the nested resource info to read next
        ///                 JsonNodeType.StartArray             Start of expanded resource set of the nested resource info to read next
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource of the nested resource info to read next
        ///                 JsonNodeType.Property               Property after deferred link or expanded entity reference
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// </remarks>
        private void ReadResourceSetItemStart(PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties)
        {
            IEdmNavigationSource source = this.CurrentNavigationSource;
            IEdmTypeReference resourceTypeReference = this.CurrentResourceTypeReference;

            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.StartObject, JsonNodeType.Property,
                JsonNodeType.EndObject, JsonNodeType.PrimitiveValue);

            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                object primitiveValue = this.jsonLightResourceDeserializer.JsonReader.Value;
                if (primitiveValue != null)
                {
                    // primitive value in an untyped collection
                    if (this.CurrentResourceType.TypeKind == EdmTypeKind.Untyped)
                    {
                        this.EnterScope(new JsonLightPrimitiveScope(new ODataPrimitiveValue(primitiveValue),
                            this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                    }
                    else
                    {
                        throw new ODataException(Strings.ODataJsonLightReader_UnexpectedPrimitiveValueForODataResource);
                    }
                }
                else
                {
                    // null resource
                    if (resourceTypeReference.IsComplex() || resourceTypeReference.IsUntyped())
                    {
                        this.jsonLightResourceDeserializer.MessageReaderSettings.Validator.ValidateNullValue(this.CurrentResourceTypeReference, true, "", null);
                    }

                    this.EnterScope(new JsonLightResourceScope(ODataReaderState.ResourceStart, /*resource*/ null,
                        this.CurrentNavigationSource, this.CurrentResourceTypeReference, /*propertyAndAnnotationCollector*/null,
                        /*projectedProperties*/null, this.CurrentScope.ODataUri));
                }

                return;
            }

            // If the reader is on StartObject then read over it. This happens for entries in resource set.
            // For top-level entries the reader will be positioned on the first resource property (after odata.context if it was present).
            if (this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject)
            {
                this.jsonLightResourceDeserializer.JsonReader.Read();
            }

            ODataDeltaKind resourceKind = ODataDeltaKind.Resource;

            // if this is a resourceSet, expanded link, or non-top level resource in a delta result, read the contextUrl
            if (this.ReadingResourceSet || this.IsExpandedLinkContent || (this.ReadingDelta && !this.IsTopLevel))
            {
                string contextUriStr =
                    this.jsonLightResourceDeserializer.ReadContextUriAnnotation(ODataPayloadKind.Resource,
                        propertyAndAnnotationCollector, false);
                if (contextUriStr != null)
                {
                    contextUriStr =
                        UriUtils.UriToString(this.jsonLightResourceDeserializer.ProcessUriFromPayload(contextUriStr));
                    var parseResult = ODataJsonLightContextUriParser.Parse(
                        this.jsonLightResourceDeserializer.Model,
                        contextUriStr,
                        this.ReadingDelta ? ODataPayloadKind.Delta : ODataPayloadKind.Resource,
                        this.jsonLightResourceDeserializer.MessageReaderSettings.ClientCustomTypeResolver,
                        this.jsonLightInputContext.ReadingResponse || this.ReadingDelta);
                    if (parseResult != null)
                    {
                        // a top-level (deleted) resource in a delta response can come from any entity set
                        resourceKind = parseResult.DeltaKind;
                        if (this.ReadingDelta && this.IsTopLevel && (resourceKind == ODataDeltaKind.Resource || resourceKind == ODataDeltaKind.DeletedEntry))
                        {
                            if (parseResult.EdmType is IEdmStructuredType parsedType)
                            {
                                resourceTypeReference = parsedType.ToTypeReference(true);
                                source = parseResult.NavigationSource;
                            }
                        }
                        else
                        {
                            ReaderValidationUtils.ValidateResourceSetOrResourceContextUri(parseResult, this.CurrentScope,
                                false);
                        }
                    }
                }
            }

            // If this is a resource in a delta resource set, check to see if it's a 4.01 deleted resource
            ODataDeletedResource deletedResource = null;
            if (this.ReadingDelta && (resourceKind == ODataDeltaKind.Resource || resourceKind == ODataDeltaKind.DeletedEntry))
            {
                deletedResource = this.jsonLightResourceDeserializer.IsDeletedResource();
                if (deletedResource != null)
                {
                    resourceKind = ODataDeltaKind.DeletedEntry;
                }
            }

            switch (resourceKind)
            {
                case ODataDeltaKind.None:
                case ODataDeltaKind.Resource:
                    // Setup the new resource state
                    this.StartResource(source, resourceTypeReference, propertyAndAnnotationCollector, selectedProperties);

                    // Start reading the resource up to the first nested resource info
                    this.StartReadingResource();

                    break;

                case ODataDeltaKind.ResourceSet:
                    this.ReadAtResourceSetStartImplementation();
                    break;

                case ODataDeltaKind.DeletedEntry:
                    // OData 4.0 deleted entry
                    if (deletedResource == null)
                    {
                        deletedResource = this.jsonLightResourceDeserializer.ReadDeletedEntry();
                        this.StartDeletedResource(
                            deletedResource,
                            source,
                            resourceTypeReference,
                            propertyAndAnnotationCollector,
                            selectedProperties,
                            true /*is 4.0 Deleted Resource*/);
                    }
                    else // OData 4.01 deleted entry
                    {
                        this.StartDeletedResource(
                            deletedResource,
                            source,
                            resourceTypeReference,
                            propertyAndAnnotationCollector,
                            selectedProperties);

                        // Start reading the resource up to the first nested resource info
                        this.StartReadingResource();
                    }

                    break;

                case ODataDeltaKind.DeletedLink:
                    this.StartDeltaLink(ODataReaderState.DeltaDeletedLink);
                    break;

                case ODataDeltaKind.Link:
                    this.StartDeltaLink(ODataReaderState.DeltaLink);
                    break;

                default:
                    Debug.Assert(true, "Unknown ODataDeltaKind " + resourceKind.ToString());
                    break;
            }
        }

        #endregion Resource

        #region DeltaResourceSet
        /// <summary>
        /// Reads the start of the JSON array for the content of the delta resource set and sets up the reader state correctly.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to read the contents for.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <remarks>
        /// Pre-Condition:  The first node of the resource set property value; this method will throw if the node is not
        ///                 JsonNodeType.StartArray
        /// Post-Condition: The reader is positioned on the first item in the resource set, or on the end array of the resource set.
        /// </remarks>
        private void ReadDeltaResourceSetStart(ODataDeltaResourceSet deltaResourceSet, SelectedPropertiesNode selectedProperties)
        {
            Debug.Assert(deltaResourceSet != null, "resourceSet != null");

            this.jsonLightResourceDeserializer.ReadResourceSetContentStart();
            IJsonReader jsonReader = this.jsonLightResourceDeserializer.JsonReader;
            if (jsonReader.NodeType != JsonNodeType.EndArray && jsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidNodeTypeForItemsInResourceSet(jsonReader.NodeType));
            }

            Debug.Assert(this.CurrentResourceType is IEdmEntityType, "Delta resource type is not an entity");

            this.EnterScope(new JsonLightResourceSetScope(
                deltaResourceSet,
                this.CurrentNavigationSource,
                this.CurrentResourceTypeReference as IEdmEntityTypeReference,
                selectedProperties,
                this.CurrentScope.ODataUri,
                /*isDelta*/ true));
        }

        #endregion DeltaResourceSet

        #endregion Read<> methods

        #region private methods

        /// <summary>
        /// Read the resource up to the first nested resource info.
        /// </summary>
        private void StartReadingResource()
        {
            ODataResourceBase currentResource = this.Item as ODataResourceBase;

            // Read the odata.type annotation.
            this.jsonLightResourceDeserializer.ReadResourceTypeName(this.CurrentResourceState);

            // Resolve the type name
            this.ApplyResourceTypeNameFromPayload(currentResource.TypeName);

            // Validate type with derived type validator if available
            if (this.CurrentDerivedTypeValidator != null)
            {
                this.CurrentDerivedTypeValidator.ValidateResourceType(this.CurrentResourceType);
            }

            // Validate type with resource set validator if available and not reading top-level delta resource set
            if (this.CurrentResourceSetValidator != null && !(this.ReadingDelta && this.CurrentResourceDepth == 0))
            {
                this.CurrentResourceSetValidator.ValidateResource(this.CurrentResourceType);
            }

            this.CurrentResourceState.FirstNestedInfo =
                this.jsonLightResourceDeserializer.ReadResourceContent(this.CurrentResourceState);

            this.jsonLightResourceDeserializer.AssertJsonCondition(
                JsonNodeType.Property,
                JsonNodeType.StartObject,
                JsonNodeType.StartArray,
                JsonNodeType.EndObject,
                JsonNodeType.PrimitiveValue);
        }

        /// <summary>
        /// Reads the next entity or complex value (or primitive or collection value for an untyped collection) in a resource set.
        /// </summary>
        private void ReadNextResourceSetItem()
        {
            Debug.Assert(this.State == ODataReaderState.ResourceSetStart ||
                this.State == ODataReaderState.DeltaResourceSetStart,
                "Reading a resource set item while not in a ResourceSetStart or DeltaResourceSetStart state.");
            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndArray, JsonNodeType.PrimitiveValue,
                JsonNodeType.StartObject, JsonNodeType.StartArray);
            IEdmType resourceType = this.CurrentScope.ResourceType;

            // End of item in a resource set
            switch (this.jsonLightResourceDeserializer.JsonReader.NodeType)
            {
                case JsonNodeType.StartObject:
                    // another resource in a resource set
                    this.ReadResourceSetItemStart( /*propertyAndAnnotationCollector*/
                        null, this.CurrentJsonLightResourceSetScope.SelectedProperties);
                    break;
                case JsonNodeType.StartArray:
                    // we are at the start of a nested resource set
                    this.ReadResourceSetStart(new ODataResourceSet(), new SelectedPropertiesNode(SelectedPropertiesNode.SelectionType.EntireSubtree));
                    break;
                case JsonNodeType.EndArray:
                    // we are at the end of a resource set
                    this.ReadResourceSetEnd();
                    break;
                case JsonNodeType.PrimitiveValue:
                    // Is this a stream, or a binary or string value with a collection that the client wants to read as a stream
                    if (!TryReadPrimitiveAsStream(resourceType))
                    {
                        // we are at a null value, or a non-null primitive value within an untyped collection
                        object primitiveValue = this.jsonLightResourceDeserializer.JsonReader.Value;
                        if (primitiveValue != null)
                        {
                            this.EnterScope(new JsonLightPrimitiveScope(new ODataPrimitiveValue(primitiveValue),
                                this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                        }
                        else
                        {
                            if (resourceType.TypeKind == EdmTypeKind.Primitive || resourceType.TypeKind == EdmTypeKind.Enum)
                            {
                                // null primitive
                                this.EnterScope(new JsonLightPrimitiveScope(new ODataNullValue(),
                                    this.CurrentNavigationSource, this.CurrentResourceTypeReference, this.CurrentScope.ODataUri));
                            }
                            else
                            {
                                // null resource (ReadResourceStart will raise the appropriate error for a non-null primitive value)
                                this.ReadResourceSetItemStart( /*propertyAndAnnotationCollector*/
                                    null, this.CurrentJsonLightResourceSetScope.SelectedProperties);
                            }
                        }
                    }

                    break;
                default:
                    throw new ODataException(
                        ODataErrorStrings.ODataJsonReader_CannotReadResourcesOfResourceSet(
                            this.jsonLightResourceDeserializer.JsonReader.NodeType));
            }
        }

        private bool TryReadPrimitiveAsStream(IEdmType resourceType)
        {
            Func<IEdmPrimitiveType, bool, string, IEdmProperty, bool> readAsStream = this.jsonLightInputContext.MessageReaderSettings.ReadAsStreamFunc;

            // Should stream primitive if
            // 1. Primitive is a stream value
            // 2. Primitive is a string or binary value (within an untyped or streamed collection) that the reader wants to read as a stream
            if (
                (resourceType != null && resourceType.IsStream()) ||
                (resourceType != null
                   && readAsStream != null
                   && (resourceType.IsBinary() || resourceType.IsString())
                   && readAsStream(resourceType as IEdmPrimitiveType, false, null, null)))
            {
                if (resourceType == null || resourceType.IsUntyped())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(
                        EdmPrimitiveTypeKind.None));
                }
                else if (resourceType.IsString())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(
                        EdmPrimitiveTypeKind.String));
                }
                else if (resourceType.IsStream() || resourceType.IsBinary())
                {
                    this.StartNestedStreamInfo(new ODataJsonLightReaderStreamInfo(EdmPrimitiveTypeKind.Binary));
                }
                else
                {
                    Debug.Assert(false, "We thought we could read as stream, but ran out of options");
                    return false;
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Reads the next item in a nested resource info content in a request payload.
        /// </summary>
        private void ReadNextNestedResourceInfoContentItemInRequest()
        {
            Debug.Assert(this.CurrentScope.State == ODataReaderState.NestedResourceInfoStart,
                "Must be on 'NestedResourceInfoStart' scope.");

            ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                this.CurrentJsonLightNestedResourceInfoScope.ReaderNestedResourceInfo;
            if (nestedResourceInfo.HasEntityReferenceLink)
            {
                this.EnterScope(new Scope(ODataReaderState.EntityReferenceLink, nestedResourceInfo.ReportEntityReferenceLink(), this.CurrentScope.ODataUri));
            }
            else if (nestedResourceInfo.HasValue)
            {
                if (nestedResourceInfo.NestedResourceInfo.IsCollection == true)
                {
                    // because this is a request, there is no $select query option.
                    SelectedPropertiesNode selectedProperties = new SelectedPropertiesNode(SelectedPropertiesNode.SelectionType.EntireSubtree);

                    if (nestedResourceInfo.NestedResourceSet is ODataDeltaResourceSet deltaResourceSet)
                    {
                        this.ReadDeltaResourceSetStart(deltaResourceSet, selectedProperties);
                    }
                    else
                    {
                        ODataResourceSet resourceSet = nestedResourceInfo.NestedResourceSet as ODataResourceSet;
                        this.ReadResourceSetStart(resourceSet ?? new ODataResourceSet(), selectedProperties);
                    }
                }
                else
                {
                    this.ReadExpandedNestedResourceInfoStart(nestedResourceInfo.NestedResourceInfo);
                }
            }
            else
            {
                // replace the 'NestedResourceInfoStart' scope with the 'NestedResourceInfoEnd' scope
                this.ReplaceScope(ODataReaderState.NestedResourceInfoEnd);
            }
        }

        /// <summary>
        /// Starts the resource, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="source">The source for the resource</param>
        /// <param name="resourceType">The entity type of the resource</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        private void StartResource(IEdmNavigationSource source, IEdmTypeReference resourceType, PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties)
        {
            this.EnterScope(new JsonLightResourceScope(
                ODataReaderState.ResourceStart,
                ReaderUtils.CreateNewResource(),
                source,
                resourceType,
                propertyAndAnnotationCollector ?? this.jsonLightInputContext.CreatePropertyAndAnnotationCollector(),
                selectedProperties,
                this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Starts the deleted resource, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="deletedResource">The deletedResource to be created.</param>
        /// <param name="source">The navigation source of the deleted resource.</param>
        /// <param name="resourceType">The entity type of the deleted resource.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker to use for the resource;
        /// or null if a new one should be created.</param>
        /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
        /// <param name="is40DeletedResource">Whether the current resource being read is a 4.0-style deleted resource.</param>
        private void StartDeletedResource(ODataDeletedResource deletedResource, IEdmNavigationSource source, IEdmTypeReference resourceType, PropertyAndAnnotationCollector propertyAndAnnotationCollector,
            SelectedPropertiesNode selectedProperties, bool is40DeletedResource = false)
        {
            this.EnterScope(new JsonLightDeletedResourceScope(
                ODataReaderState.DeletedResourceStart,
                deletedResource,
                source,
                resourceType,
                propertyAndAnnotationCollector ?? this.jsonLightInputContext.CreatePropertyAndAnnotationCollector(),
                selectedProperties,
                this.CurrentScope.ODataUri,
                is40DeletedResource));
        }

        /// <summary>
        /// Starts the (deleted) link, initializing the scopes and such. This method starts a non-null resource only.
        /// </summary>
        /// <param name="state">The reader state to switch to.</param>
        private void StartDeltaLink(ODataReaderState state)
        {
            Debug.Assert(
                state == ODataReaderState.DeltaLink || state == ODataReaderState.DeltaDeletedLink,
                "state must be either DeltaResource or DeltaDeletedEntry or DeltaLink or DeltaDeletedLink.");
            Debug.Assert(this.CurrentResourceType is IEdmEntityType, "DeltaLink is not from an entity type");

            ODataDeltaLinkBase link;
            if (state == ODataReaderState.DeltaLink)
            {
                link = new ODataDeltaLink(null, null, null);
            }
            else
            {
                link = new ODataDeltaDeletedLink(null, null, null);
            }

            this.EnterScope(new JsonLightDeltaLinkScope(
                state,
                link,
                this.CurrentNavigationSource,
                this.CurrentResourceType as IEdmEntityType,
                this.CurrentScope.ODataUri));

            this.jsonLightResourceDeserializer.AssertJsonCondition(JsonNodeType.EndObject, JsonNodeType.Property);

            // Read source property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkSource(link);

            // Read relationship property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkRelationship(link);

            // Read target property.
            this.jsonLightResourceDeserializer.ReadDeltaLinkTarget(link);

            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject, "Unexpected content in a delta (deleted) link");
        }

        /// <summary>
        /// Starts the nested resource info.
        /// Does metadata validation of the nested resource info and sets up the reader to report it.
        /// </summary>
        /// <param name="readerNestedResourceInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedResourceInfo(ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo)
        {
            Debug.Assert(readerNestedResourceInfo != null, "readerNestedResourceInfo != null");
            ODataNestedResourceInfo nestedResourceInfo = readerNestedResourceInfo.NestedResourceInfo;
            IEdmProperty nestedProperty = readerNestedResourceInfo.NestedProperty;
            IEdmTypeReference targetResourceTypeReference = readerNestedResourceInfo.NestedResourceTypeReference;

            Debug.Assert(
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.Property ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.EndObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartObject ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.StartArray ||
                this.jsonLightResourceDeserializer.JsonReader.NodeType == JsonNodeType.PrimitiveValue &&
                this.jsonLightResourceDeserializer.JsonReader.Value == null,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.Primitive (null), or JsonNodeType.Property, JsonNodeType.EndObject");
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(!string.IsNullOrEmpty(nestedResourceInfo.Name), "Navigation links must have a name.");
            Debug.Assert(nestedProperty == null || nestedResourceInfo.Name == nestedProperty.Name,
                "The navigation property must match the nested resource info.");

            // we are at the beginning of a link
            if (targetResourceTypeReference == null && nestedProperty != null)
            {
                IEdmTypeReference nestedPropertyType = nestedProperty.Type;
                targetResourceTypeReference = nestedPropertyType.IsCollection()
                    ? nestedPropertyType.AsCollection().ElementType().AsStructured()
                    : nestedPropertyType.AsStructured();
            }

            // Since we don't have the entity metadata builder for the resource read out from a nested payload
            // as stated in ReadAtResourceSetEndImplementationSynchronously(), we cannot access it here which otherwise
            // would lead to an exception.
            if (this.jsonLightInputContext.ReadingResponse && !this.IsReadingNestedPayload
                && (targetResourceTypeReference == null || targetResourceTypeReference.Definition.IsStructuredOrStructuredCollectionType()))
            {
                // Hookup the metadata builder to the nested resource info.
                // Note that we set the metadata builder even when navigationProperty is null, which is the case when the link is undeclared.
                // For undeclared links, we will apply conventional metadata evaluation just as declared links.
                this.CurrentResourceState.ResourceTypeFromMetadata = this.ParentScope.ResourceType as IEdmStructuredType;
                ODataResourceMetadataBuilder resourceMetadataBuilder =
                    this.jsonLightResourceDeserializer.MetadataContext.GetResourceMetadataBuilderForReader(
                        this.CurrentResourceState,
                        this.jsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                        this.ReadingDelta);
                nestedResourceInfo.MetadataBuilder = resourceMetadataBuilder;
            }

            Debug.Assert(
                this.CurrentNavigationSource != null || this.readingParameter ||
                this.CurrentNavigationSource == null && this.CurrentScope.ResourceType.IsODataComplexTypeKind(),
                "Json requires an navigation source when not reading parameter.");

            IEdmNavigationProperty navigationProperty = readerNestedResourceInfo.NavigationProperty;

            IEdmNavigationSource navigationSource;
            // Since we are entering a nested info scope, check whether the current resource is derived type in order to correctly further property or navigation property.
            ODataUri odataUri = this.CurrentScope.ODataUri.Clone();
            ODataPath odataPath = odataUri.Path ?? new ODataPath();

            if (this.CurrentScope is JsonLightResourceBaseScope currentScope && currentScope.ResourceTypeFromMetadata != currentScope.ResourceType)
            {
                odataPath.Add(new TypeSegment(currentScope.ResourceType, null));
            }

            if (navigationProperty == null)
            {
                navigationSource = this.CurrentNavigationSource;
            }
            else
            {
                IEdmPathExpression bindingPath;
                navigationSource = this.CurrentNavigationSource == null
                    ? null
                    : this.CurrentNavigationSource.FindNavigationTarget(navigationProperty,
                        BindingPathHelper.MatchBindingPath, odataPath.ToList(), out bindingPath);
            }

            if (navigationProperty != null)
            {
                if (navigationSource is IEdmContainedEntitySet)
                {
                    if (TryAppendEntitySetKeySegment(ref odataPath))
                    {
                        odataPath = odataPath.AddNavigationPropertySegment(navigationProperty, navigationSource);
                    }
                }
                else if (navigationSource != null && !(navigationSource is IEdmUnknownEntitySet))
                {
                    odataPath = navigationSource is IEdmEntitySet entitySet
                        ? new ODataPath(new EntitySetSegment(entitySet))
                        : new ODataPath(new SingletonSegment(navigationSource as IEdmSingleton));
                }
                else
                {
                    odataPath = new ODataPath();
                }
            }
            else if (nestedProperty != null)
            {
                odataPath = odataPath.AddPropertySegment(nestedProperty as IEdmStructuralProperty);
            }

            odataUri.Path = odataPath;

            JsonLightNestedResourceInfoScope newScope = new JsonLightNestedResourceInfoScope(readerNestedResourceInfo, navigationSource,
                targetResourceTypeReference, odataUri);

            var derivedTypeConstraints = this.jsonLightInputContext.Model.GetDerivedTypeConstraints(nestedProperty);
            if (derivedTypeConstraints != null)
            {
                newScope.DerivedTypeValidator = new DerivedTypeValidator(nestedProperty.Type.ToStructuredType(), derivedTypeConstraints, "nested resource", nestedProperty.Name);
            }

            this.EnterScope(newScope);
        }

        /// <summary>
        /// Starts the nested property info.
        /// </summary>
        /// <param name="readerNestedPropertyInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedPropertyInfo(ODataJsonLightReaderNestedPropertyInfo readerNestedPropertyInfo)
        {
            Debug.Assert(readerNestedPropertyInfo != null, "readerNestedResourceInfo != null");
            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.CanStream() || this.CurrentScope is JsonLightResourceSetScope,
                "Starting stream while not positioned on a primitive value or within an array");

            this.EnterScope(new JsonLightNestedPropertyInfoScope(readerNestedPropertyInfo, this.CurrentNavigationSource, this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Starts the nested stream info.
        /// </summary>
        /// <param name="readerStreamInfo">The nested resource info for the nested resource info to start.</param>
        private void StartNestedStreamInfo(ODataJsonLightReaderStreamInfo readerStreamInfo)
        {
            Debug.Assert(readerStreamInfo != null, "readerNestedResourceInfo != null");
            Debug.Assert(this.jsonLightResourceDeserializer.JsonReader.CanStream() || this.CurrentScope is JsonLightResourceSetScope,
                "Starting stream while not positioned on a primitive value or within an array");

            this.EnterScope(new JsonLightStreamScope(readerStreamInfo, this.CurrentNavigationSource, this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Try to append key segment.
        /// </summary>
        /// <param name="odataPath">The ODataPath to be evaluated.</param>
        /// <returns>True if successfully append key segment.</returns>
        private bool TryAppendEntitySetKeySegment(ref ODataPath odataPath)
        {
            try
            {
                if (EdmExtensionMethods.HasKey(this.CurrentScope.NavigationSource, this.CurrentScope.ResourceType as IEdmStructuredType))
                {
                    IEdmEntityType currentEntityType = this.CurrentScope.ResourceType as IEdmEntityType;
                    ODataResourceBase resource = this.CurrentScope.Item as ODataResourceBase;
                    KeyValuePair<string, object>[] keys = ODataResourceMetadataContext.GetKeyProperties(resource, null, currentEntityType);
                    odataPath = odataPath.AddKeySegment(keys, currentEntityType, this.CurrentScope.NavigationSource);
                }
            }
            catch (ODataException)
            {
                odataPath = null;
                return false;
            }

            return true;
        }

        /// <summary>
        /// Replaces the current scope with a new scope with the specified <paramref name="state"/> and
        /// the item of the current scope.
        /// </summary>
        /// <param name="state">The <see cref="ODataReaderState"/> to use for the new scope.</param>
        private void ReplaceScope(ODataReaderState state)
        {
            this.ReplaceScope(new Scope(state, this.Item, this.CurrentNavigationSource, this.CurrentResourceTypeReference,
                this.CurrentScope.ODataUri));
        }

        /// <summary>
        /// Called to transition into the EntryEnd state.
        /// </summary>
        private void EndEntry()
        {
            IODataJsonLightReaderResourceState resourceState = this.CurrentResourceState;

            if (this.Item is ODataResourceBase currentResource && !this.IsReadingNestedPayload)
            {
                // Builder should not be used outside the odataresource, lazy builder logic does not work here
                // We should refactor this
                foreach (string navigationPropertyName in this.CurrentResourceState.NavigationPropertiesRead)
                {
                    currentResource.MetadataBuilder.MarkNestedResourceInfoProcessed(navigationPropertyName);
                }

                ODataConventionalEntityMetadataBuilder builder =
                    currentResource.MetadataBuilder as ODataConventionalEntityMetadataBuilder;
                builder?.EndResource();
            }

            if (!this.ReadingDelta)
            {
                this.jsonLightResourceDeserializer.ValidateMediaEntity(resourceState);
            }

            // In non-delta responses, ensure that all projected properties get created.
            // Also ignore cases where the resource is 'null' which happens for expanded null entries.
            if (this.jsonLightInputContext.ReadingResponse && !this.ReadingDelta && this.Item is ODataResourceBase currentResource)
            {
                // If we have a projected nested resource info that was missing from the payload, report it now.
                ODataJsonLightReaderNestedResourceInfo unprocessedNestedResourceInfo =
                    currentResource.MetadataBuilder.GetNextUnprocessedNavigationLink();
                if (unprocessedNestedResourceInfo != null)
                {
                    this.CurrentResourceState.ProcessingMissingProjectedNestedResourceInfos = true;
                    this.StartNestedResourceInfo(unprocessedNestedResourceInfo);
                    return;
                }
            }

            if (this.State == ODataReaderState.ResourceStart)
            {
                this.EndEntry(
                    new JsonLightResourceScope(
                        ODataReaderState.ResourceEnd,
                        (ODataResource)this.Item,
                        this.CurrentNavigationSource,
                        this.CurrentResourceTypeReference,
                        this.CurrentResourceState.PropertyAndAnnotationCollector,
                        this.CurrentResourceState.SelectedProperties,
                        this.CurrentScope.ODataUri));
            }
            else
            {
                this.EndEntry(
                    new JsonLightDeletedResourceScope(
                        ODataReaderState.DeletedResourceEnd,
                        (ODataDeletedResource)this.Item,
                        this.CurrentNavigationSource,
                        this.CurrentResourceTypeReference,
                        this.CurrentResourceState.PropertyAndAnnotationCollector,
                        this.CurrentResourceState.SelectedProperties,
                        this.CurrentScope.ODataUri));
            }
        }

        /// <summary>
        /// Add info resolved from context url to current scope.
        /// </summary>
        private void ResolveScopeInfoFromContextUrl()
        {
            if (this.jsonLightResourceDeserializer.ContextUriParseResult != null)
            {
                this.CurrentScope.ODataUri.Path = this.jsonLightResourceDeserializer.ContextUriParseResult.Path;

                if (this.CurrentScope.NavigationSource == null)
                {
                    this.CurrentScope.NavigationSource =
                        this.jsonLightResourceDeserializer.ContextUriParseResult.NavigationSource;
                }

                if (this.CurrentScope.ResourceType == null)
                {
                    IEdmType typeFromContext = this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType;
                    if (typeFromContext != null)
                    {
                        if (typeFromContext.TypeKind == EdmTypeKind.Collection)
                        {
                            typeFromContext = ((IEdmCollectionType)typeFromContext).ElementType.Definition;
                            if (!(typeFromContext is IEdmStructuredType))
                            {
                                typeFromContext = new EdmUntypedStructuredType();
                                this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType = new EdmCollectionType(typeFromContext.ToTypeReference());
                            }
                        }

                        IEdmStructuredType resourceType = typeFromContext as IEdmStructuredType;
                        if (resourceType == null)
                        {
                            resourceType = new EdmUntypedStructuredType();
                            this.jsonLightResourceDeserializer.ContextUriParseResult.EdmType = resourceType;
                        }

                        this.CurrentScope.ResourceTypeReference = resourceType.ToTypeReference(true).AsStructured();
                    }
                }
            }
        }

#endregion private methods

        #region scopes

        /// <summary>
        /// A reader top-level scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightTopLevelScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceType">The expected type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri attached to this scope.</param>
            /// <remarks>The <paramref name="expectedResourceType"/> has the following meaning
            ///   it's the expected base type of the top-level resource or resource set in the top-level resource set.
            /// In all cases the specified type must be a structured type.</remarks>
            internal JsonLightTopLevelScope(IEdmNavigationSource navigationSource, IEdmStructuredType expectedResourceType, ODataUri odataUri)
                : base(ODataReaderState.Start, /*item*/ null, navigationSource, expectedResourceType.ToTypeReference(true), odataUri)
            {
            }

            /// <summary>
            /// The duplicate property names checker for the top level scope represented by the current state.
            /// </summary>
            public PropertyAndAnnotationCollector PropertyAndAnnotationCollector { get; set; }
        }

        /// <summary>
        /// A reader primitive scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightPrimitiveScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="primitiveValue">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedTypeReference">The expected type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightPrimitiveScope(
                ODataValue primitiveValue,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedTypeReference,
                ODataUri odataUri)
                : base(ODataReaderState.Primitive, primitiveValue, navigationSource, expectedTypeReference, odataUri)
            {
                Debug.Assert(primitiveValue is ODataPrimitiveValue || primitiveValue is ODataNullValue, "Primitive value scope created with non-primitive value");
            }
        }

        /// <summary>
        /// A reader resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private abstract class JsonLightResourceBaseScope : Scope, IODataJsonLightReaderResourceState
        {
            /// <summary>The set of names of the navigation properties we have read so far while reading the resource.</summary>
            private List<string> navigationPropertiesRead;

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceTypeReference">The expected type reference for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            protected JsonLightResourceBaseScope(
                ODataReaderState readerState,
                ODataResourceBase resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceTypeReference,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri)
                : base(readerState, resource, navigationSource, expectedResourceTypeReference, odataUri)
            {
                Debug.Assert(
                    readerState == ODataReaderState.ResourceStart || readerState == ODataReaderState.ResourceEnd ||
                    readerState == ODataReaderState.DeletedResourceStart || readerState == ODataReaderState.DeletedResourceEnd,
                    "Resource scope created for invalid reader state: " + readerState);

                this.PropertyAndAnnotationCollector = propertyAndAnnotationCollector;
                this.SelectedProperties = selectedProperties;
            }

            /// <summary>
            /// The metadata builder instance for the resource.
            /// </summary>
            public ODataResourceMetadataBuilder MetadataBuilder { get; set; }

            /// <summary>
            /// Flag which indicates that during parsing of the resource represented by this state,
            /// any property which is not an instance annotation was found. This includes property annotations
            /// for property which is not present in the payload.
            /// </summary>
            /// <remarks>
            /// This is used to detect incorrect ordering of the payload (for example odata.id must not come after the first property).
            /// </remarks>
            public bool AnyPropertyFound { get; set; }

            /// <summary>
            /// If the reader finds a nested resource info to report, but it must first report the parent resource
            /// it will store the nested resource info in this property. So this will only ever store the first nested resource info of a resource.
            /// </summary>
            public ODataJsonLightReaderNestedInfo FirstNestedInfo { get; set; }

            /// <summary>
            /// The duplicate property names checker for the resource represented by the current state.
            /// </summary>
            public PropertyAndAnnotationCollector PropertyAndAnnotationCollector { get; private set; }

            /// <summary>
            /// The selected properties that should be expanded during template evaluation.
            /// </summary>
            public SelectedPropertiesNode SelectedProperties { get; private set; }

            /// <summary>
            /// The set of names of the navigation properties we have read so far while reading the resource.
            /// true if we have started processing missing projected navigation links, false otherwise.
            /// </summary>
            public List<string> NavigationPropertiesRead
            {
                get { return this.navigationPropertiesRead ?? (this.navigationPropertiesRead = new List<string>()); }
            }

            /// <summary>
            /// true if we have started processing missing projected navigation links, false otherwise.
            /// </summary>
            public bool ProcessingMissingProjectedNestedResourceInfos { get; set; }

            /// <summary>
            /// The expected type defined in the model for the resource.
            /// </summary>
            public IEdmStructuredType ResourceTypeFromMetadata { get; set; }

            /// <summary>
            /// The resource type for this resource.
            /// </summary>
            public new IEdmStructuredType ResourceType
            {
                get
                {
                    return base.ResourceType as IEdmStructuredType;
                }
            }

            /// <summary>
            /// The resource being read.
            /// </summary>
            ODataResourceBase IODataJsonLightReaderResourceState.Resource
            {
                get
                {
                    Debug.Assert(
                        this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd ||
                        this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                        "The IODataJsonLightReaderResourceState is only supported on ResourceStart or ResourceEnd scope.");
                    return (ODataResourceBase)this.Item;
                }
            }

            /// <summary>
            /// The structured type for the resource (if available).
            /// </summary>
            IEdmStructuredType IODataJsonLightReaderResourceState.ResourceType
            {
                get
                {
                    Debug.Assert(
                        this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.ResourceEnd | this.State == ODataReaderState.DeletedResourceStart || this.State == ODataReaderState.DeletedResourceEnd,
                        "The IODataJsonLightReaderResourceState is only supported on (Deleted)ResourceStart or (Deleted)ResourceEnd scope.");
                    return this.ResourceType;
                }
            }

            /// <summary>
            /// The navigation source for the resource (if available)
            /// </summary>
            IEdmNavigationSource IODataJsonLightReaderResourceState.NavigationSource
            {
                get { return this.NavigationSource; }
            }
        }

        /// <summary>
        /// Base class for a reader resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightResourceScope : JsonLightResourceBaseScope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceTypeReference">The expected type for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightResourceScope(
                ODataReaderState readerState,
                ODataResourceBase resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceTypeReference,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri)
                : base(readerState, resource, navigationSource, expectedResourceTypeReference, propertyAndAnnotationCollector, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A reader deleted resource scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightDeletedResourceScope : JsonLightResourceBaseScope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="readerState">The reader state of the new scope that is being created.</param>
            /// <param name="resource">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read resources for.</param>
            /// <param name="expectedResourceType">The expected type for the scope.</param>
            /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for this resource scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <param name="is40DeletedResource">Whether the deleted resource being read is an OData 4.0 Deleted Resource</param>
            /// <remarks>The <paramref name="expectedResourceType"/> has the following meaning
            ///   it's the expected base type of the resource. If the resource has no type name specified
            ///   this type will be assumed. Otherwise the specified type name must be
            ///   the expected type or a more derived type.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightDeletedResourceScope(
                ODataReaderState readerState,
                ODataDeletedResource resource,
                IEdmNavigationSource navigationSource,
                IEdmTypeReference expectedResourceType,
                PropertyAndAnnotationCollector propertyAndAnnotationCollector,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool is40DeletedResource = false)
                : base(readerState, resource, navigationSource, expectedResourceType, propertyAndAnnotationCollector, selectedProperties, odataUri)
            {
                this.Is40DeletedResource = is40DeletedResource;
            }

            /// <summary>Whether the payload is an OData 4.0 deleted resource.</summary>
            internal bool Is40DeletedResource { get; }
        }

        /// <summary>
        /// A reader resource set scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightResourceSetScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="resourceSet">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceTypeReference">The expected type reference for the scope.</param>
            /// <param name="selectedProperties">The selected properties node capturing what properties should be expanded during template evaluation.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <param name="isDelta">True of the ResourceSetScope is for a delta resource set</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meaning
            ///   it's the expected base type of the entries in the resource set.
            ///   note that it might be a more derived type than the base type of the entity set for the resource set.
            /// In all cases the specified type must be an entity type.</remarks>
            internal JsonLightResourceSetScope(ODataResourceSetBase resourceSet, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceTypeReference, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isDelta)
                : base(isDelta ? ODataReaderState.DeltaResourceSetStart : ODataReaderState.ResourceSetStart, resourceSet, navigationSource, expectedResourceTypeReference, odataUri)
            {
                this.SelectedProperties = selectedProperties;
            }

            /// <summary>
            /// The selected properties that should be expanded during template evaluation.
            /// </summary>
            public SelectedPropertiesNode SelectedProperties { get; private set; }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightNestedResourceInfoScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="nestedResourceInfo">The nested resource info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedTypeReference">The expected type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedTypeReference"/> is the expected base type reference the items in the nested resource info.</remarks>
            internal JsonLightNestedResourceInfoScope(ODataJsonLightReaderNestedResourceInfo nestedResourceInfo, IEdmNavigationSource navigationSource, IEdmTypeReference expectedTypeReference, ODataUri odataUri)
                : base(ODataReaderState.NestedResourceInfoStart, nestedResourceInfo.NestedResourceInfo, navigationSource, expectedTypeReference, odataUri)
            {
                this.ReaderNestedResourceInfo = nestedResourceInfo;
            }

            /// <summary>
            /// The nested resource info for the nested resource info to report.
            /// This is only used on a StartNestedResourceInfo scope in responses.
            /// </summary>
            public ODataJsonLightReaderNestedResourceInfo ReaderNestedResourceInfo { get; private set; }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightNestedPropertyInfoScope : Scope
        {
            /// <summary>
            /// Constructor creating a new nested property info scope.
            /// </summary>
            /// <param name="nestedPropertyInfo">The nested property info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightNestedPropertyInfoScope(ODataJsonLightReaderNestedPropertyInfo nestedPropertyInfo, IEdmNavigationSource navigationSource, ODataUri odataUri)
                : base(ODataReaderState.NestedProperty, nestedPropertyInfo.NestedPropertyInfo,
                      navigationSource, EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Stream, true), odataUri)
            {
                Debug.Assert(nestedPropertyInfo != null, "JsonLightNestedInfoScope created with a null nestedPropertyInfo");
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightStreamScope : StreamScope
        {
            /// <summary>
            /// Constructor creating a new nested property info scope.
            /// </summary>
            /// <param name="streamInfo">The stream info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal JsonLightStreamScope(ODataJsonLightReaderStreamInfo streamInfo, IEdmNavigationSource navigationSource, ODataUri odataUri)
                : base(ODataReaderState.Stream, new ODataStreamItem(streamInfo.PrimitiveTypeKind, streamInfo.ContentType),
                      navigationSource, EdmCoreModel.Instance.GetPrimitive(EdmPrimitiveTypeKind.Stream, true), odataUri)
            {
                Debug.Assert(streamInfo != null, "JsonLightNestedStreamScope created with a null streamInfo");
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        private sealed class JsonLightDeltaLinkScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of the new scope that is being created.</param>
            /// <param name="link">The link info attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedEntityType">The expected type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedEntityType"/> has the following meaning
            ///   it's the expected base type the entries in the expanded link (either the single resource
            ///   or entries in the expanded resource set).
            /// In all cases the specified type must be an entity type.</remarks>
            public JsonLightDeltaLinkScope(ODataReaderState state, ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType expectedEntityType, ODataUri odataUri)
                : base(state, link, navigationSource, expectedEntityType.ToTypeReference(true), odataUri)
            {
                Debug.Assert(
                    state == ODataReaderState.DeltaLink && link is ODataDeltaLink ||
                    state == ODataReaderState.DeltaDeletedLink && link is ODataDeltaDeletedLink,
                    "link must be either DeltaLink or DeltaDeletedLink.");
            }
        }

        #endregion Scopes
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(12,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(1113,17): error CS0165: Use of unassigned local variable 'currentResource',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(1447,56): error CS0165: Use of unassigned local variable 'deltaResourceSet',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(1594,74): error CS0128: A local variable or function named 'readerNestedStreamInfo' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(1596,50): error CS0165: Use of unassigned local variable 'readerNestedStreamInfo',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(2472,116): error CS0128: A local variable or function named 'currentResource' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(2476,21): error CS0165: Use of unassigned local variable 'currentResource',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightReader.cs(12,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.JsonLight
{
    #region Namespaces
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Microsoft.OData.Evaluation;
    using Microsoft.OData.Json;
    using Microsoft.OData.Metadata;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Edm.Vocabularies;
    using Microsoft.OData.Edm.Vocabularies.V1;
    using ODataErrorStrings = Microsoft.OData.Strings;

    #endregion Namespaces

    /// <summary>
    /// OData JsonLight deserializer for entries and resource sets.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Need to keep the logic together for better readability.")]
    internal sealed class ODataJsonLightResourceDeserializer : ODataJsonLightPropertyAndValueDeserializer
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightInputContext">The JsonLight input context to read from.</param>
        internal ODataJsonLightResourceDeserializer(ODataJsonLightInputContext jsonLightInputContext)
            : base(jsonLightInputContext)
        {
        }

        /// <summary>
        /// Reads the start of the JSON array for the content of the resource set.
        /// </summary>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartArray:     The start of the resource set property array; this method will fail if the node is anything else.
        /// Post-Condition: JsonNodeType.StartObject:    The first item in the resource set
        ///                 JsonNodeType.PrimitiveValue: A null resource, or a primitive value within an untyped collection
        ///                 JsonNodeType.StartArray:     A nested collection within an untyped collection
        ///                 JsonNodeType.EndArray:       The end of the resource set
        /// </remarks>
        internal void ReadResourceSetContentStart()
        {
            this.JsonReader.AssertNotBuffering();

            if (this.JsonReader.NodeType != JsonNodeType.StartArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_CannotReadResourceSetContentStart(this.JsonReader.NodeType));
            }

            this.JsonReader.ReadStartArray();
            this.JsonReader.AssertNotBuffering();
        }

        /// <summary>
        /// Reads the end of the array containing the resource set content.
        /// </summary>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndArray
        /// Post-Condition: JsonNodeType.Property   if the resource set is part of an expanded nested resource info and there are more properties in the object
        ///                 JsonNodeType.EndObject  if the resource set is a top-level resource set or the expanded nested resource info is the last property of the payload
        ///                 JsonNodeType.EndOfInput  if the resource set is in a Uri operation parameter
        ///                 JsonNodeType.StartArray      if the resource set is a member of an untyped collection followed by a collection
        ///                 JsonNodeType.PrimitiveValue  if the resource set is a member of an untyped collection followed by a primitive value
        ///                 JsonNodeType.StartObject     if the resource set is a member of an untyped collection followed by a resource
        ///                 JsonNodeType.EndArray        if the resource set is the last member of an untyped collection
        /// </remarks>
        internal void ReadResourceSetContentEnd()
        {
            this.AssertJsonCondition(JsonNodeType.EndArray);
            this.JsonReader.AssertNotBuffering();

            this.JsonReader.ReadEndArray();

            this.AssertJsonCondition(JsonNodeType.EndOfInput, JsonNodeType.EndObject, JsonNodeType.Property, JsonNodeType.StartArray, JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.EndArray);
        }

        /// <summary>
        /// Reads the resource type name annotation (odata.type)
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the resource object.
        ///                 JsonNodeType.EndObject         End of the resource object.
        /// Post-Condition: JsonNodeType.Property          The property after the odata.type (if there was any), or the property on which the method was called.
        ///                 JsonNodeType.EndObject         End of the resource object.
        ///
        /// This method fills the ODataResource.TypeName property if the type name is found in the payload.
        /// </remarks>
        internal void ReadResourceTypeName(IODataJsonLightReaderResourceState resourceState)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the odata.type property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string propertyName = this.JsonReader.GetPropertyName();
                if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataType, propertyName) == 0
                    || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataTypePropertyName, propertyName))
                {
                    Debug.Assert(resourceState.Resource.TypeName == null, "type name should not have already been set");

                    // Read over the property to move to its value.
                    this.JsonReader.Read();

                    // Read the annotation value.
                    resourceState.Resource.TypeName = this.ReadODataTypeAnnotationValue();
                }
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the OData 4.01 deleted resource annotation (odata.removed)
        /// </summary>
        /// <returns>Returns True if the resource is a deleted resource, otherwise returns false </returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the resource object.
        ///                 JsonNodeType.EndObject         End of the resource object.
        /// Post-Condition: JsonNodeType.Property          The property after the odata.type (if there was any), or the property on which the method was called.
        ///                 JsonNodeType.EndObject         End of the resource object.
        ///
        /// This method Creates an ODataDeltaDeletedEntry and fills in the Id and Reason properties, if specified in the payload.
        /// </remarks>
        internal ODataDeletedResource IsDeletedResource()
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            ODataDeletedResource deletedResource = null;

            // If the current node is the deleted property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string propertyName = this.JsonReader.GetPropertyName();
                if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataRemoved, propertyName) == 0
                    || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataRemovedPropertyName, propertyName))
                {
                    DeltaDeletedEntryReason reason = DeltaDeletedEntryReason.Changed;
                    Uri id = null;

                    // Read over the property to move to its value.
                    this.JsonReader.Read();

                    // Read the removed object and extract the reason, if present
                    this.AssertJsonCondition(JsonNodeType.StartObject, JsonNodeType.PrimitiveValue /*null*/);
                    if (this.JsonReader.NodeType != JsonNodeType.PrimitiveValue)
                    {
                        while (this.JsonReader.NodeType != JsonNodeType.EndObject && this.JsonReader.Read())
                        {
                            // If the current node is the reason property - read it.
                            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                            string.CompareOrdinal(JsonLightConstants.ODataReasonPropertyName, this.JsonReader.GetPropertyName()) == 0)
                            {
                                // Read over the property to move to its value.
                                this.JsonReader.Read();

                                // Read the reason value.
                                if (string.CompareOrdinal(JsonLightConstants.ODataReasonDeletedValue, this.JsonReader.ReadStringValue()) == 0)
                                {
                                    reason = DeltaDeletedEntryReason.Deleted;
                                }
                            }
                        }
                    }
                    else if (this.JsonReader.Value != null)
                    {
                        throw new ODataException(Strings.ODataJsonLightResourceDeserializer_DeltaRemovedAnnotationMustBeObject(this.JsonReader.Value));
                    }

                    // read over end object or null value
                    this.JsonReader.Read();

                    // A deleted object must have at least either the odata id annotation or the key values
                    if (this.JsonReader.NodeType != JsonNodeType.Property)
                    {
                        throw new ODataException(Strings.ODataWriterCore_DeltaResourceWithoutIdOrKeyProperties);
                    }

                    // If the next property is the id property - read it.
                    propertyName = this.JsonReader.GetPropertyName();
                    if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataId, propertyName) == 0
                        || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataIdPropertyName, propertyName))
                    {
                        // Read over the property to move to its value.
                        this.JsonReader.Read();

                        // Read the id value.
                        id = UriUtils.StringToUri(this.JsonReader.ReadStringValue());
                    }

                    deletedResource = ReaderUtils.CreateDeletedResource(id, reason);
                }
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            return deletedResource;
        }

        /// <summary>
        /// Reads an OData 4.0 delete entry
        /// </summary>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// <returns>The <see cref="ODataDeletedResource"/> read.</returns>
        /// <remarks>
        /// This method Creates an ODataDeltaDeletedEntry and fills in the Id and Reason properties, if specified in the payload.
        /// </remarks>
        internal ODataDeletedResource ReadDeletedEntry()
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            Uri id = null;
            DeltaDeletedEntryReason reason = DeltaDeletedEntryReason.Changed;

            // If the current node is the id property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataIdPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the Id value.
                id = this.JsonReader.ReadUriValue();
                Debug.Assert(id != null, "value for Id must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the reason property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataReasonPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the reason value.
                if (string.CompareOrdinal(JsonLightConstants.ODataReasonDeletedValue, this.JsonReader.ReadStringValue()) == 0)
                {
                    reason = DeltaDeletedEntryReason.Deleted;
                }
            }

            // Ignore unknown primitive properties in a 4.0 deleted entry
            while (this.JsonReader.NodeType != JsonNodeType.EndObject && this.JsonReader.Read())
            {
                if (this.JsonReader.NodeType == JsonNodeType.StartObject || this.JsonReader.NodeType == JsonNodeType.StartArray)
                {
                    throw new ODataException(Strings.ODataWriterCore_NestedContentNotAllowedIn40DeletedEntry);
                }
            }

            return ReaderUtils.CreateDeletedResource(id, reason);
        }

        /// <summary>
        /// Reads the delta (deleted) link source.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Source property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkSource(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the source property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataSourcePropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Source == null, "source should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the source value.
                link.Source = this.JsonReader.ReadUriValue();
                Debug.Assert(link.Source != null, "value for source must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the delta (deleted) link relationship.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Relationship property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkRelationship(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the relationship property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataRelationshipPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Relationship == null, "relationship should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the relationship value.
                link.Relationship = this.JsonReader.ReadStringValue();
                Debug.Assert(link.Relationship != null, "value for relationship must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the delta (deleted) link target.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Target property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkTarget(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the target property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataTargetPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Target == null, "target should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the source value.
                link.Target = this.JsonReader.ReadUriValue();
                Debug.Assert(link.Target != null, "value for target must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the content of a resource until a nested resource info is detected.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The property to read
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        ///                 JsonNodeType.Property               If we've read a deferred link (this is the property after the deferred link)
        ///                 JsonNodeType.StartObject            Expanded resource
        ///                 JsonNodeType.StartArray             Expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null
        /// </remarks>
        internal ODataJsonLightReaderNestedInfo ReadResourceContent(IODataJsonLightReaderResourceState resourceState)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(resourceState.ResourceType != null && this.Model.IsUserModel(), "A non-null resource type and non-null model are required.");
            Debug.Assert(
                this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Pre-Condition: JsonNodeType.Property or JsonNodeType.EndObject");
            this.JsonReader.AssertNotBuffering();

            ODataJsonLightReaderNestedInfo readerNestedResourceInfo = null;
            Debug.Assert(resourceState.ResourceType != null, "In JSON we must always have an structured type when reading resource.");

            // Figure out whether we have more properties for this resource
            // read all the properties until we hit a link
            while (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                this.ReadPropertyCustomAnnotationValue = this.ReadCustomInstanceAnnotationValue;
                this.ProcessProperty(
                    resourceState.PropertyAndAnnotationCollector,
                    this.ReadEntryPropertyAnnotationValue,
                    (propertyParsingResult, propertyName) =>
                    {
                        switch (propertyParsingResult)
                        {
                            case PropertyParsingResult.ODataInstanceAnnotation:
                            case PropertyParsingResult.CustomInstanceAnnotation:
                                this.ReadOverPropertyName();
                                object value = ReadODataOrCustomInstanceAnnotationValue(resourceState, propertyParsingResult, propertyName);
                                this.ApplyEntryInstanceAnnotation(resourceState, propertyName, value);
                                break;

                            case PropertyParsingResult.PropertyWithoutValue:
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithoutValue(resourceState, propertyName);
                                break;

                            case PropertyParsingResult.NestedDeltaResourceSet:
                                // Will read over property name in ReadPropertyWithValue
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithValue(resourceState, propertyName, /*isDeltaResourceSet*/ true);
                                break;

                            case PropertyParsingResult.PropertyWithValue:
                                // Will read over property name in ReadPropertyWithValue
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithValue(resourceState, propertyName, /*isDeltaResourceSet*/ false);
                                break;

                            case PropertyParsingResult.MetadataReferenceProperty:
                                this.ReadOverPropertyName();
                                this.ReadMetadataReferencePropertyValue(resourceState, propertyName);
                                break;

                            case PropertyParsingResult.EndOfObject:
                                this.ReadOverPropertyName();
                                break;
                        }
                    });

                if (readerNestedResourceInfo != null)
                {
                    // we found a nested resource info
                    // stop parsing the resource content and return to the caller
                    break;
                }

                Debug.Assert(
                    this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                    "After reading a property the reader should be positioned on another property or have hit the end of the object.");
            }

            this.JsonReader.AssertNotBuffering();

            // The reader can be either on
            //  - StartObject - if it's an expanded resource
            //  - StartArray - if it's an expanded resource set
            //  - Property - if it's a deferred link
            //  - PrimitiveValue- if it's a stream or an expanded null resource
            //  - EndObject - end of the resource
            Debug.Assert(
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.StartObject ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.StartArray ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.Property ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                readerNestedResourceInfo is ODataJsonLightReaderNestedInfo ||
                this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.Property or JsonNodeType.EndObject or JsonNodeType.Primitive (with null value)");

            return readerNestedResourceInfo;
        }

        /// <summary>
        /// Reads built-in "odata." or custom instance annotation's value.
        /// </summary>
        /// <param name="resourceState">The IODataJsonLightReaderResourceState.</param>
        /// <param name="propertyParsingResult">The PropertyParsingResult.</param>
        /// <param name="annotationName">The annotation name</param>
        /// <returns>The annotation value.</returns>
        internal object ReadODataOrCustomInstanceAnnotationValue(IODataJsonLightReaderResourceState resourceState, PropertyParsingResult propertyParsingResult, string annotationName)
        {
            object value = this.ReadEntryInstanceAnnotation(annotationName, resourceState.AnyPropertyFound, /*typeAnnotationFound*/ true, resourceState.PropertyAndAnnotationCollector);
            if (propertyParsingResult == PropertyParsingResult.ODataInstanceAnnotation)
            {
                resourceState.PropertyAndAnnotationCollector.AddODataScopeAnnotation(annotationName, value);
            }
            else
            {
                resourceState.PropertyAndAnnotationCollector.AddCustomScopeAnnotation(annotationName, value);
            }

            return value;
        }

        /// <summary>
        /// Validates resource metadata.
        /// </summary>
        /// <param name="resourceState">The resource state to use.</param>
        internal void ValidateMediaEntity(IODataJsonLightReaderResourceState resourceState)
        {
            ODataResourceBase resource = resourceState.Resource;
            if (resource != null)
            {
                IEdmEntityType entityType = resourceState.ResourceType as IEdmEntityType;
                if (entityType != null)
                {
                    // If the entity in the model has a default stream and if no MR related metadata exists in the resource payload, create an empty MediaResource.
                    // Note that for responses the metadata builder will compute the default stream.  For requests we really don't need to add the default stream since the service knows its metadata.
                    // We leave this here for now so we don't introduce a breaking change.
                    if (!this.ReadingResponse && entityType.HasStream && resource.MediaResource == null)
                    {
                        ODataStreamReferenceValue mediaResource = resource.MediaResource;
                        ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                        this.SetEntryMediaResource(resourceState, mediaResource);
                    }

                    this.ReaderValidator.ValidateMediaResource(resource, entityType);
                }
            }
        }

        /// <summary>
        /// Reads the resource set instance annotations for a top-level resource set.
        /// </summary>
        /// <param name="resourceSet">The <see cref="ODataResourceSet"/> to read the instance annotations for.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for the top-level scope.</param>
        /// <param name="forResourceSetStart">true when parsing the instance annotations before the resource set property;
        /// false when parsing the instance annotations after the resource set property.</param>
        /// <param name="readAllResourceSetProperties">true if we should scan ahead for the annotations and ignore the actual data properties (used with
        /// the reordering reader); otherwise false.</param>
        internal void ReadTopLevelResourceSetAnnotations(ODataResourceSetBase resourceSet, PropertyAndAnnotationCollector propertyAndAnnotationCollector, bool forResourceSetStart, bool readAllResourceSetProperties)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");
            this.JsonReader.AssertNotBuffering();

            bool buffering = false;
            try
            {
                while (this.JsonReader.NodeType == JsonNodeType.Property)
                {
                    bool foundValueProperty = false;

                    if (!forResourceSetStart && readAllResourceSetProperties)
                    {
                        // If this is not called for reading ResourceSetStart and we already scanned ahead and processed all resource set properties, we already checked for duplicate property names.
                        // Use an empty duplicate property name checker since this.ParseProperty() read through the same property annotation of instance annotations again.
                        propertyAndAnnotationCollector = new PropertyAndAnnotationCollector(false);
                    }

                    this.ProcessProperty(
                        propertyAndAnnotationCollector,
                        this.ReadTypePropertyAnnotationValue,
                        (propertyParseResult, propertyName) =>
                        {
                            this.ReadOverPropertyName();
                            switch (propertyParseResult)
                            {
                                case PropertyParsingResult.ODataInstanceAnnotation:
                                case PropertyParsingResult.CustomInstanceAnnotation:
                                    ReadODataOrCustomInstanceAnnotationValue(resourceSet, propertyAndAnnotationCollector,
                                        forResourceSetStart, readAllResourceSetProperties, propertyParseResult, propertyName);
                                    break;

                                case PropertyParsingResult.PropertyWithValue:
                                    if (string.CompareOrdinal(JsonLightConstants.ODataValuePropertyName, propertyName) == 0)
                                    {
                                        // We found the resource set property and are done parsing property annotations;
                                        // When we are in the mode where we scan ahead and read all resource set properties
                                        // (for the reordering scenario), we have to start buffering and continue
                                        // reading. Otherwise we found the resourceSet's data property and are done.
                                        if (readAllResourceSetProperties)
                                        {
                                            this.JsonReader.StartBuffering();
                                            buffering = true;

                                            this.JsonReader.SkipValue();
                                        }
                                        else
                                        {
                                            foundValueProperty = true;
                                        }
                                    }
                                    else
                                    {
                                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidPropertyInTopLevelResourceSet(propertyName, JsonLightConstants.ODataValuePropertyName));
                                    }

                                    break;
                                case PropertyParsingResult.PropertyWithoutValue:
                                    // If we find a property without a value it means that we did not find the resource set property (yet)
                                    // but an invalid property annotation
                                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidPropertyAnnotationInTopLevelResourceSet(propertyName));

                                case PropertyParsingResult.EndOfObject:
                                    break;

                                case PropertyParsingResult.MetadataReferenceProperty:
                                    if (!(resourceSet is ODataResourceSet))
                                    {
                                        throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedMetadataReferenceProperty(propertyName));
                                    }

                                    this.ReadMetadataReferencePropertyValue((ODataResourceSet)resourceSet, propertyName);
                                    break;

                                default:
                                    throw new ODataException(ODataErrorStrings.General_InternalError(InternalErrorCodes.ODataJsonLightResourceDeserializer_ReadTopLevelResourceSetAnnotations));
                            }
                        });

                    if (foundValueProperty)
                    {
                        return;
                    }
                }
            }
            finally
            {
                if (buffering)
                {
                    Debug.Assert(readAllResourceSetProperties, "Expect the reader to be in buffering mode only when scanning to the end.");
                    this.JsonReader.StopBuffering();
                }
            }

            if (forResourceSetStart && !readAllResourceSetProperties)
            {
                // We did not find any properties or only instance annotations.
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ExpectedResourceSetPropertyNotFound(JsonLightConstants.ODataValuePropertyName));
            }
        }

        /// <summary>
        /// Reads built-in "odata." or custom instance annotation's value.
        /// </summary>
        /// <param name="resourceSet">The ODataResourceSetBase.</param>
        /// <param name="propertyAndAnnotationCollector">The PropertyAndAnnotationCollector.</param>
        /// <param name="forResourceSetStart">true when parsing the instance annotations before the resource set property;
        /// false when parsing the instance annotations after the resource set property.</param>
        /// <param name="readAllResourceSetProperties">true if we should scan ahead for the annotations and ignore the actual data properties (used with
        /// the reordering reader); otherwise false.</param>
        /// <param name="propertyParseResult">The PropertyParsingResult.</param>
        /// <param name="annotationName">The annotation name.</param>
        internal void ReadODataOrCustomInstanceAnnotationValue(ODataResourceSetBase resourceSet,
            PropertyAndAnnotationCollector propertyAndAnnotationCollector, bool forResourceSetStart,
            bool readAllResourceSetProperties, PropertyParsingResult propertyParseResult, string annotationName)
        {
            if (propertyParseResult == PropertyParsingResult.ODataInstanceAnnotation)
            {
                // #### annotation 1 ####
                // built-in "odata." annotation value is added to propertyAndAnnotationCollector then later to resourceSet.InstanceAnnotations.
                propertyAndAnnotationCollector.AddODataScopeAnnotation(annotationName, this.JsonReader.Value);
            }

            // When we are reading the start of a resource set (in scan-ahead mode or not) or when
            // we read the end of a resource set and not in scan-ahead mode, read the value;
            // otherwise skip it.
            if (forResourceSetStart || !readAllResourceSetProperties)
            {
                // #### annotation 2 ####
                // custom annotation value will be directly added to resourceSet.InstanceAnnotations.
                this.ReadAndApplyResourceSetInstanceAnnotationValue(annotationName, resourceSet, propertyAndAnnotationCollector);
            }
            else
            {
                this.JsonReader.SkipValue();
            }
        }

        /// <summary>
        /// Reads a value of property annotation on the resource level.
        /// </summary>
        /// <param name="propertyAnnotationName">The name of the property annotation to read.</param>
        /// <returns>The value of the property annotation.</returns>
        /// <remarks>
        /// This method should read the property annotation value and return a representation of the value which will be later
        /// consumed by the resource reading code.
        ///
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the property annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the property annotation
        /// </remarks>
        internal object ReadEntryPropertyAnnotationValue(string propertyAnnotationName)
        {
            Debug.Assert(!string.IsNullOrEmpty(propertyAnnotationName), "!string.IsNullOrEmpty(propertyAnnotationName)");
            Debug.Assert(
                propertyAnnotationName.StartsWith(JsonLightConstants.ODataAnnotationNamespacePrefix, StringComparison.Ordinal),
                "The method should only be called with OData. annotations");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.StartArray);

            string typeName;
            if (this.TryReadODataTypeAnnotationValue(propertyAnnotationName, out typeName))
            {
                return typeName;
            }

            switch (propertyAnnotationName)
            {
                case ODataAnnotationNames.ODataNavigationLinkUrl:  // odata.navigationLinkUrl
                case ODataAnnotationNames.ODataAssociationLinkUrl: // odata.associationLinkUrl
                case ODataAnnotationNames.ODataNextLink:           // odata.nextLink
                case ODataAnnotationNames.ODataMediaEditLink:      // odata.mediaEditLink
                case ODataAnnotationNames.ODataMediaReadLink:      // odata.mediaReadLink
                case ODataAnnotationNames.ODataContext:            // odata.context
                    return this.ReadAndValidateAnnotationStringValueAsUri(propertyAnnotationName);

                case ODataAnnotationNames.ODataCount:              // odata.count
                    return this.ReadAndValidateAnnotationAsLongForIeee754Compatible(propertyAnnotationName);

                case ODataAnnotationNames.ODataMediaETag:          // odata.mediaEtag
                case ODataAnnotationNames.ODataMediaContentType:   // odata.mediaContentType
                    return this.ReadAndValidateAnnotationStringValue(propertyAnnotationName);

                // odata.bind
                case ODataAnnotationNames.ODataBind:
                    // The value of the odata.bind annotation can be either an array of strings or a string (collection or singleton nested resource info).
                    // Note that we don't validate that the cardinality of the navigation property matches the payload here, since we don't want to lookup the property twice.
                    // We will validate that later when we consume the value of the property annotation.
                    if (this.JsonReader.NodeType != JsonNodeType.StartArray)
                    {
                        return new ODataEntityReferenceLink
                        {
                            Url = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataBind)
                        };
                    }

                    LinkedList<ODataEntityReferenceLink> entityReferenceLinks = new LinkedList<ODataEntityReferenceLink>();

                    // Read over the start array
                    this.JsonReader.Read();
                    while (this.JsonReader.NodeType != JsonNodeType.EndArray)
                    {
                        entityReferenceLinks.AddLast(
                            new ODataEntityReferenceLink
                            {
                                Url = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataBind)
                            });
                    }

                    // Read over the end array
                    this.JsonReader.Read();
                    if (entityReferenceLinks.Count == 0)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_EmptyBindArray(ODataAnnotationNames.ODataBind));
                    }

                    return entityReferenceLinks;

                case ODataAnnotationNames.ODataDeltaLink:   // Delta links are not supported on expanded resource sets.
                default:
                    throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedAnnotationProperties(propertyAnnotationName));
            }
        }

        /// <summary>
        /// Reads instance annotation in the resource object.
        /// </summary>
        /// <param name="annotationName">The name of the instance annotation found.</param>
        /// <param name="anyPropertyFound">true if a non-annotation property has already been encountered.</param>
        /// <param name="typeAnnotationFound">true if the 'odata.type' annotation has already been encountered, or should have been by now.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for the resource being read.</param>
        /// <returns>The value of the annotation.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the instance annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the instance annotation
        /// </remarks>
        internal object ReadEntryInstanceAnnotation(string annotationName, bool anyPropertyFound, bool typeAnnotationFound, PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.StartArray);

            switch (annotationName)
            {
                case ODataAnnotationNames.ODataType:   // 'odata.type'
                    if (!typeAnnotationFound)
                    {
                        return this.ReadODataTypeAnnotationValue();
                    }

                    // We already read the odata.type if it was the first property in ReadResourceStart, so any other occurrence means
                    // that it was not the first property.
                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceTypeAnnotationNotFirst);

                case ODataAnnotationNames.ODataId:   // 'odata.id'
                    if (anyPropertyFound)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceInstanceAnnotationPrecededByProperty(annotationName));
                    }

                    return this.ReadAnnotationStringValueAsUri(annotationName);

                case ODataAnnotationNames.ODataETag:   // 'odata.etag'
                    if (anyPropertyFound)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceInstanceAnnotationPrecededByProperty(annotationName));
                    }

                    return this.ReadAndValidateAnnotationStringValue(annotationName);

                case ODataAnnotationNames.ODataEditLink:    // 'odata.editLink'
                case ODataAnnotationNames.ODataReadLink:    // 'odata.readLink'
                case ODataAnnotationNames.ODataMediaEditLink:   // 'odata.mediaEditLink'
                case ODataAnnotationNames.ODataMediaReadLink:   // 'odata.mediaReadLink'
                    return this.ReadAndValidateAnnotationStringValueAsUri(annotationName);

                case ODataAnnotationNames.ODataMediaContentType:  // 'odata.mediaContentType'
                case ODataAnnotationNames.ODataMediaETag:  // 'odata.mediaEtag'
                    return this.ReadAndValidateAnnotationStringValue(annotationName);

                case ODataAnnotationNames.ODataRemoved: // 'odata.removed'
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedDeletedEntryInResponsePayload);
                    }

                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    return this.ReadCustomInstanceAnnotationValue(propertyAndAnnotationCollector, annotationName);
            }
        }

        /// <summary>
        /// Reads instance annotation in the resource object.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="annotationName">The name of the instance annotation found.</param>
        /// <param name="annotationValue">The value of the annotation.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the instance annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the instance annotation
        /// </remarks>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "The casts aren't actually being done multiple times, since they occur in different cases of the switch statement.")]
        internal void ApplyEntryInstanceAnnotation(IODataJsonLightReaderResourceState resourceState, string annotationName, object annotationValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");

            ODataResourceBase resource = resourceState.Resource;
            ODataStreamReferenceValue mediaResource = resource.MediaResource;
            switch (annotationName)
            {
                case ODataAnnotationNames.ODataType:   // 'odata.type'
                    resource.TypeName = ReaderUtils.AddEdmPrefixOfTypeName(ReaderUtils.RemovePrefixOfTypeName((string)annotationValue));
                    break;

                case ODataAnnotationNames.ODataId:   // 'odata.id'
                    if (annotationValue == null)
                    {
                        resource.IsTransient = true;
                    }
                    else
                    {
                        resource.Id = (Uri)annotationValue;
                    }

                    break;

                case ODataAnnotationNames.ODataETag:   // 'odata.etag'
                    resource.ETag = (string)annotationValue;
                    break;

                case ODataAnnotationNames.ODataEditLink:    // 'odata.editLink'
                    resource.EditLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataReadLink:    // 'odata.readLink'
                    resource.ReadLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaEditLink:   // 'odata.mediaEditLink'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.EditLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaReadLink:   // 'odata.mediaReadLink'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ReadLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaContentType:  // 'odata.mediaContentType'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ContentType = (string)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaETag:  // 'odata.mediaEtag'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ETag = (string)annotationValue;
                    break;

                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    resource.InstanceAnnotations.Add(new ODataInstanceAnnotation(annotationName, annotationValue.ToODataValue()));
                    break;
            }

            if (mediaResource != null && resource.MediaResource == null)
            {
                this.SetEntryMediaResource(resourceState, mediaResource);
            }
        }

        /// <summary>
        /// Reads the value of a resource set annotation (count or next link).
        /// </summary>
        /// <param name="annotationName">The name of the annotation found.</param>
        /// <param name="resourceSet">The resource set to read the annotation for; if non-null, the annotation value will be assigned to the resource set.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker instance.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the annotation
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource set object
        ///                 JsonNodeType.Property               The next annotation after the current annotation
        /// </remarks>
        internal void ReadAndApplyResourceSetInstanceAnnotationValue(string annotationName, ODataResourceSetBase resourceSet, PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");
            Debug.Assert(resourceSet != null, "resourceSet != null");

            switch (annotationName)
            {
                case ODataAnnotationNames.ODataCount:
                    resourceSet.Count = this.ReadAndValidateAnnotationAsLongForIeee754Compatible(ODataAnnotationNames.ODataCount);
                    break;

                case ODataAnnotationNames.ODataNextLink:
                    resourceSet.NextPageLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataNextLink);
                    break;

                case ODataAnnotationNames.ODataDeltaLink:
                    resourceSet.DeltaLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataDeltaLink);
                    break;
                case ODataAnnotationNames.ODataType:

                    // TODO: skip the odata.type;
                    this.ReadAndValidateAnnotationStringValue(ODataAnnotationNames.ODataType);
                    break;
                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    object instanceAnnotationValue = this.ReadCustomInstanceAnnotationValue(propertyAndAnnotationCollector, annotationName);
                    resourceSet.InstanceAnnotations.Add(new ODataInstanceAnnotation(annotationName, instanceAnnotationValue.ToODataValue()));
                    break;
            }
        }

        /// <summary>
        /// Reads resource property which doesn't have value, just annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the property read.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              The end of the resource object.
        ///                 JsonNodeType.Property               The property after the one we're to read.
        /// Post-Condition: JsonNodeType.EndObject              This method doesn't move the reader.
        ///                 JsonNodeType.Property
        /// </remarks>
        internal ODataJsonLightReaderNestedInfo ReadPropertyWithoutValue(IODataJsonLightReaderResourceState resourceState, string propertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IEdmStructuredType resourceType = resourceState.ResourceType;
            IEdmProperty edmProperty = this.ReaderValidator.ValidatePropertyDefined(propertyName, resourceType);
            if (edmProperty != null && !edmProperty.Type.IsUntyped())
            {
                // Declared property - read it.
                ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo;
                IEdmNavigationProperty navigationProperty = edmProperty as IEdmNavigationProperty;
                if (navigationProperty != null)
                {
                    if (this.ReadingResponse)
                    {
                        // Deferred link
                        readerNestedResourceInfo = ReadDeferredNestedResourceInfo(resourceState, propertyName, navigationProperty);
                    }
                    else
                    {
                        // Entity reference link or links
                        readerNestedResourceInfo = navigationProperty.Type.IsCollection()
                            ? ReadEntityReferenceLinksForCollectionNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ false)
                            : ReadEntityReferenceLinkForSingletonNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ false);

                        if (!readerNestedResourceInfo.HasEntityReferenceLink)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_NavigationPropertyWithoutValueAndEntityReferenceLink(propertyName, ODataAnnotationNames.ODataBind));
                        }
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else
                {
                    IEdmTypeReference propertyTypeReference = edmProperty.Type;
                    if (propertyTypeReference.IsStream())
                    {
                        Debug.Assert(propertyName == edmProperty.Name, "propertyName == edmProperty.Name");
                        ODataStreamReferenceValue streamPropertyValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                        AddResourceProperty(resourceState, edmProperty.Name, streamPropertyValue);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_PropertyWithoutValueWithWrongType(propertyName, propertyTypeReference.FullName()));
                    }
                }
            }
            else
            {
                // Undeclared property - we need to run detection algorithm here.
                readerNestedInfo = this.ReadUndeclaredProperty(resourceState, propertyName, /*propertyWithValue*/ false);
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            return readerNestedInfo;
        }

        /// <summary>
        /// Reads any next link annotation immediately after the end of a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set being read.</param>
        /// <param name="expandedNestedResourceInfo">The information about the expanded link. This must be non-null if we're reading an expanded resource set, and must be null if we're reading a top-level resource set.</param>
        /// <param name="propertyAndAnnotationCollector">The top-level duplicate property names checker, if we're reading a top-level resource set.</param>
        internal void ReadNextLinkAnnotationAtResourceSetEnd(
            ODataResourceSetBase resourceSet,
            ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo,
            PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            // Check for annotations on the resource set that occur after the resource set itself. (Note: the only allowed one is odata.nextLink, and we fail for anything else.)
            // We do this slightly differently depending on whether the resource set was an expanded navigation or a top-level resource set.
            if (expandedNestedResourceInfo != null)
            {
                this.ReadExpandedResourceSetAnnotationsAtResourceSetEnd(resourceSet, expandedNestedResourceInfo);
            }
            else
            {
                Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");

                // Check for resource set instance annotations that appear after the resource set.
                bool isReordering = this.JsonReader is ReorderingJsonReader;
                this.ReadTopLevelResourceSetAnnotations(resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/false, /*readAllResourceSetProperties*/isReordering);
            }
        }

        /// <summary>
        /// Reads the information of a deferred link.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="navigationPropertyName">The name of the navigation property for which to read the deferred link.</param>
        /// <param name="navigationProperty">The navigation property for which to read the deferred link. This can be null.</param>
        /// <returns>Returns the nested resource info for the deferred nested resource info read.</returns>
        /// <remarks>
        /// This method doesn't move the reader.
        /// </remarks>
        private static ODataJsonLightReaderNestedResourceInfo ReadDeferredNestedResourceInfo(IODataJsonLightReaderResourceState resourceState, string navigationPropertyName, IEdmNavigationProperty navigationProperty)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(navigationPropertyName), "!string.IsNullOrEmpty(navigationPropertyName)");
            Debug.Assert(navigationProperty == null || navigationPropertyName == navigationProperty.Name, "navigationProperty == null || navigationPropertyName == navigationProperty.Name");

            ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo()
            {
                Name = navigationPropertyName,
                IsCollection = navigationProperty == null ? null : (bool?)navigationProperty.Type.IsCollection()
            };

            foreach (var propertyAnnotation
                     in resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(nestedResourceInfo.Name))
            {
                switch (propertyAnnotation.Key)
                {
                    case ODataAnnotationNames.ODataNavigationLinkUrl:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.navigationLinkUrl annotation should have been parsed as a non-null Uri.");
                        nestedResourceInfo.Url = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataAssociationLinkUrl:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.associationLinkUrl annotation should have been parsed as a non-null Uri.");
                        nestedResourceInfo.AssociationLinkUrl = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataType:
                        Debug.Assert(propertyAnnotation.Value is String && propertyAnnotation.Value != null, "The odata.type annotation should have been parsed as a non-null string.");
                        nestedResourceInfo.TypeAnnotation = new ODataTypeAnnotation((string)propertyAnnotation.Value);
                        break;

                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedDeferredLinkPropertyAnnotation(nestedResourceInfo.Name, propertyAnnotation.Key));
                }
            }

            return ODataJsonLightReaderNestedResourceInfo.CreateDeferredLinkInfo(nestedResourceInfo, navigationProperty);
        }

        /// <summary>
        /// We fail here if we encounter any other property annotation for the expanded navigation (since these should come before the property itself).
        /// </summary>
        /// <param name="resourceSet">The resource set that was just read.</param>
        /// <param name="expandedNestedResourceInfo">The information for the current expanded nested resource info being read.</param>
        private void ReadExpandedResourceSetAnnotationsAtResourceSetEnd(ODataResourceSetBase resourceSet, ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo)
        {
            Debug.Assert(expandedNestedResourceInfo != null, "expandedNestedResourceInfo != null");
            Debug.Assert(expandedNestedResourceInfo.NestedResourceInfo.IsCollection == true, "Only collection navigation properties can have resourceSet content.");

            // Look at the next property in the owning resource, if it's a property annotation for the expanded nested resource info property, read it.
            string propertyName, annotationName;
            while (this.JsonReader.NodeType == JsonNodeType.Property &&
                   TryParsePropertyAnnotation(this.JsonReader.GetPropertyName(), out propertyName, out annotationName) &&
                   string.CompareOrdinal(propertyName, expandedNestedResourceInfo.NestedResourceInfo.Name) == 0)
            {
                if (!this.ReadingResponse)
                {
                    throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedPropertyAnnotation(propertyName, annotationName));
                }

                // Read over the property name.
                this.JsonReader.Read();

                switch (this.CompleteSimplifiedODataAnnotation(annotationName))
                {
                    case ODataAnnotationNames.ODataNextLink:
                        if (resourceSet.NextPageLink != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_DuplicateNestedResourceSetAnnotation(ODataAnnotationNames.ODataNextLink, expandedNestedResourceInfo.NestedResourceInfo.Name));
                        }

                        // Read the property value.
                        resourceSet.NextPageLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataNextLink);
                        break;

                    case ODataAnnotationNames.ODataCount:
                        if (resourceSet.Count != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_DuplicateNestedResourceSetAnnotation(ODataAnnotationNames.ODataCount, expandedNestedResourceInfo.NestedResourceInfo.Name));
                        }

                        // Read the property value.
                        resourceSet.Count = this.ReadAndValidateAnnotationAsLongForIeee754Compatible(ODataAnnotationNames.ODataCount);
                        break;

                    case ODataAnnotationNames.ODataDeltaLink:   // Delta links are not supported on expanded resource sets.
                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedPropertyAnnotationAfterExpandedResourceSet(annotationName, expandedNestedResourceInfo.NestedResourceInfo.Name));
                }
            }
        }

        /// <summary>
        /// Sets specified media resource on a resource and hooks up metadata builder.
        /// </summary>
        /// <param name="resourceState">The resource state to use.</param>
        /// <param name="mediaResource">The media resource to set.</param>
        private void SetEntryMediaResource(IODataJsonLightReaderResourceState resourceState, ODataStreamReferenceValue mediaResource)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(mediaResource != null, "mediaResource != null");
            ODataResourceBase resource = resourceState.Resource;
            Debug.Assert(resource != null, "resource != null");

            ODataResourceMetadataBuilder builder =
                this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                    this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                    /*isDelta*/ false);
            mediaResource.SetMetadataBuilder(builder, /*propertyName*/ null);
            resource.MediaResource = mediaResource;
        }

        /// <summary>
        /// Reads resource property (which is neither instance nor property annotation) which has a value.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the property read.</param>
        /// <param name="isDeltaResourceSet">The property being read represents a nested delta resource set.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the property
        ///                 JsonNodeType.StartObject            Expanded resource
        ///                 JsonNodeType.StartArray             Expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource
        /// </remarks>
        private ODataJsonLightReaderNestedInfo ReadPropertyWithValue(IODataJsonLightReaderResourceState resourceState, string propertyName, bool isDeltaResourceSet)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property, JsonNodeType.StartObject, JsonNodeType.StartArray);

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IEdmStructuredType resourceType = resourceState.ResourceType;
            IEdmProperty edmProperty = this.ReaderValidator.ValidatePropertyDefined(propertyName, resourceType);
            bool isCollection = edmProperty == null ? false : edmProperty.Type.IsCollection();
            IEdmStructuralProperty structuralProperty = edmProperty as IEdmStructuralProperty;

            if (structuralProperty != null)
            {
                ODataJsonLightReaderNestedInfo nestedInfo = TryReadAsStream(resourceState, structuralProperty, structuralProperty.Type, structuralProperty.Name);
                if (nestedInfo != null)
                {
                    return nestedInfo;
                }
            }

            if (edmProperty != null && !edmProperty.Type.IsUntyped())
            {
                this.ReadOverPropertyName();
                IEdmStructuredType structuredPropertyTypeOrItemType = structuralProperty == null ? null : structuralProperty.Type.ToStructuredType();
                IEdmNavigationProperty navigationProperty = edmProperty as IEdmNavigationProperty;
                if (structuredPropertyTypeOrItemType != null)
                {
                    ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo = null;

                    // Complex property or collection of complex property.
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, edmProperty.Type);

                    if (isCollection)
                    {
                        readerNestedResourceInfo = ReadNonExpandedResourceSetNestedResourceInfo(resourceState, structuralProperty, structuredPropertyTypeOrItemType, structuralProperty.Name);
                    }
                    else
                    {
                        readerNestedResourceInfo = ReadNonExpandedResourceNestedResourceInfo(resourceState, structuralProperty, structuredPropertyTypeOrItemType, structuralProperty.Name);
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else if (navigationProperty != null)
                {
                    ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo = null;

                    // Expanded link
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, edmProperty.Type);
                    if (isCollection)
                    {
                        readerNestedResourceInfo = this.ReadingResponse || isDeltaResourceSet
                            ? ReadExpandedResourceSetNestedResourceInfo(resourceState, navigationProperty, navigationProperty.Type.ToStructuredType(), propertyName, /*isDeltaResourceSet*/ isDeltaResourceSet)
                            : ReadEntityReferenceLinksForCollectionNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ true);
                    }
                    else
                    {
                        readerNestedResourceInfo = this.ReadingResponse
                            ? ReadExpandedResourceNestedResourceInfo(resourceState, navigationProperty, propertyName, navigationProperty.Type.ToStructuredType(), this.MessageReaderSettings)
                            : ReadEntityReferenceLinkForSingletonNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ true);
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else
                {
                    var derivedTypeConstraints = this.JsonLightInputContext.Model.GetDerivedTypeConstraints(edmProperty);
                    if (derivedTypeConstraints != null)
                    {
                        resourceState.PropertyAndAnnotationCollector.SetDerivedTypeValidator(propertyName, new DerivedTypeValidator(edmProperty.Type.Definition, derivedTypeConstraints, "property", propertyName));
                    }

                    // NOTE: we currently do not check whether the property should be skipped
                    //       here because this can only happen for navigation properties and open properties.
                    this.ReadEntryDataProperty(resourceState, edmProperty, ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName));
                }
            }
            else
            {
                // Undeclared property - we need to run detection algorithm here.
                readerNestedInfo = this.ReadUndeclaredProperty(resourceState, propertyName, /*propertyWithValue*/ true);

                // Note that if nested resource info is returned it's already validated, so we just report it here.
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject, JsonNodeType.StartObject, JsonNodeType.StartArray, JsonNodeType.PrimitiveValue);
            return readerNestedInfo;
        }

        /// <summary>
        /// Checks to see if the current property should be read as a stream and, if so reads it
        /// </summary>
        /// <param name="resourceState">current ResourceState</param>
        /// <param name="property">The property being serialized (null for a dynamic property)</param>
        /// <param name="propertyType">The type of the property being serialized</param>
        /// <param name="propertyName">The name of the property being serialized</param>
        /// <returns>The ODataJsonLightReaderNestedInfo for a nested stream property, or null if the property shouldn't be streamed</returns>
        private ODataJsonLightReaderNestedInfo TryReadAsStream(IODataJsonLightReaderResourceState resourceState, IEdmStructuralProperty property, IEdmTypeReference propertyType, string propertyName)
        {
            Debug.Assert(propertyName != null, "Property name must not be null");

            bool isCollection = false;
            IEdmPrimitiveType primitiveType = null;
            if (propertyType != null)
            {
                primitiveType = propertyType.Definition.AsElementType() as IEdmPrimitiveType;
                isCollection = propertyType.IsCollection();
            }
            else
            {
                isCollection = this.JsonReader.NodeType != JsonNodeType.PrimitiveValue;
            }

            Func<IEdmPrimitiveType, bool, string, IEdmProperty, bool> readAsStream = this.MessageReaderSettings.ReadAsStreamFunc;

            // is the property a stream or a stream collection,
            // untyped collection,
            // or a binary or binary collection the client wants to read as a stream...
            if (
                (primitiveType != null &&
                    (primitiveType.IsStream() ||
                        (readAsStream != null
                             && (property == null || !property.IsKey())  // don't stream key properties
                             && (primitiveType.IsBinary() || primitiveType.IsString() || isCollection))
                         && readAsStream(primitiveType, isCollection, propertyName, property))) ||
                (propertyType != null &&
                    isCollection &&
                    propertyType.Definition.AsElementType().IsUntyped()) ||
                (propertyType == null
                    && (isCollection || this.JsonReader.CanStream())
                    && readAsStream != null
                    && readAsStream(null, isCollection, propertyName, property)))
            {
                if (isCollection)
                {
                    this.ReadOverPropertyName();
                    IEdmType elementType = propertyType == null ? EdmCoreModel.Instance.GetUntypedType() : propertyType.Definition.AsElementType();

                    // Collection of streams, or binary/string values to read as streams
                    return ReadStreamCollectionNestedResourceInfo(resourceState, property, propertyName, elementType);
                }
                else
                {
                    ODataPropertyInfo propertyInfo;
                    if (primitiveType != null && primitiveType.PrimitiveKind == EdmPrimitiveTypeKind.Stream)
                    {
                        ODataStreamPropertyInfo streamPropertyInfo = this.ReadStreamPropertyInfo(resourceState, propertyName);

                        // If it has an instance annotation saying that the content type is JSON, don't read propertyName
                        // otherwise, if we are on start object, BufferingJsonReader will read ahead to try and determine
                        // if we are reading an instream error, which destroys our ability to stream json stream values.
                        if (this.JsonReader.NodeType == JsonNodeType.Property)
                        {
                            bool isJson = false;
                            if (streamPropertyInfo.ContentType != null)
                            {
                                if (streamPropertyInfo.ContentType.Contains(MimeConstants.MimeApplicationJson))
                                {
                                    isJson = true;
                                }
                            }
                            else if (property != null)
                            {
                                IEdmVocabularyAnnotation mediaTypeAnnotation = property.VocabularyAnnotations(this.Model).FirstOrDefault(a => a.Term == CoreVocabularyModel.MediaTypeTerm);
                                if (mediaTypeAnnotation != null)
                                {
                                    // If the property does not have a mediaType annotation specifying application/json, then read over the property name
                                    IEdmStringConstantExpression stringExpression = mediaTypeAnnotation.Value as IEdmStringConstantExpression;
                                    if (stringExpression != null && stringExpression.Value.Contains(MimeConstants.MimeApplicationJson))
                                    {
                                        isJson = true;
                                    }
                                }
                            }

                            if (!isJson)
                            {
                                // Not reading JSON stream, so read over property name
                                this.ReadOverPropertyName();
                            }
                        }

                        // Add the stream reference property
                        ODataStreamReferenceValue streamReferenceValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                        AddResourceProperty(resourceState, propertyName, streamReferenceValue);

                        propertyInfo = streamPropertyInfo;
                    }
                    else
                    {
                        this.ReadOverPropertyName();

                        propertyInfo = new ODataPropertyInfo
                        {
                            PrimitiveTypeKind = primitiveType == null ? EdmPrimitiveTypeKind.None : primitiveType.PrimitiveKind,
                            Name = propertyName,
                        };
                    }

                    // return without reading over the property node; we will create a stream over the value
                    this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property);
                    return new ODataJsonLightReaderNestedPropertyInfo(propertyInfo, property);
                }
            }

            return null;
        }

        /// <summary>
        /// Reads over the current property name if positioned on a property
        /// </summary>
        private void ReadOverPropertyName()
        {
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                this.JsonReader.Read();
            }
        }

        /// <summary>
        /// Returns whether or not a StreamPropertyInfo value specifies a content-type of application/json.
        /// </summary>
        /// <param name="streamPropertyInfo">The StreamPropertyInfo that may specify application/json.</param>
        /// <returns>True, if the StreamPropertyInfo specifies application/json, otherwise false.</returns>
        private static bool IsJsonStream(ODataStreamPropertyInfo streamPropertyInfo)
        {
            return streamPropertyInfo.ContentType != null && streamPropertyInfo.ContentType.Contains(MimeConstants.MimeApplicationJson);
        }

        /// <summary>
        /// Read a resource-level data property and check its version compliance.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="edmProperty">The EDM property of the property being read, or null if the property is an open property.</param>
        /// <param name="propertyTypeName">The type name specified for the property in property annotation, or null if no such type name is available.</param>
        /// <remarks>
        /// Pre-Condition:  The reader is positioned on the first node of the property value
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        private void ReadEntryDataProperty(IODataJsonLightReaderResourceState resourceState, IEdmProperty edmProperty, string propertyTypeName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(edmProperty != null, "edmProperty != null");
            this.JsonReader.AssertNotBuffering();

            // EdmLib bridge marks all key properties as non-nullable, but Astoria allows them to be nullable.
            // If the property has an annotation to ignore null values, we need to omit the property in requests.
            ODataNullValueBehaviorKind nullValueReadBehaviorKind = this.ReadingResponse
                ? ODataNullValueBehaviorKind.Default
                : this.Model.NullValueReadBehaviorKind(edmProperty);
            object propertyValue = this.ReadNonEntityValue(
                propertyTypeName,
                edmProperty.Type,
                /*propertyAndAnnotationCollector*/ null,
                /*collectionValidator*/ null,
                nullValueReadBehaviorKind == ODataNullValueBehaviorKind.Default,
                /*isTopLevelPropertyValue*/ false,
                /*insideResourceValue*/ false,
                edmProperty.Name);

            if (nullValueReadBehaviorKind != ODataNullValueBehaviorKind.IgnoreValue || propertyValue != null)
            {
                AddResourceProperty(resourceState, edmProperty.Name, propertyValue);
            }

            this.JsonReader.AssertNotBuffering();
            Debug.Assert(
                this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.Property or JsonNodeType.EndObject");
        }

        /// <summary>
        /// Read an open property.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="owningStructuredType">The owning type of the property with name <paramref name="propertyName"/>
        /// or null if no metadata is available.</param>
        /// <param name="propertyName">The name of the open property to read.</param>
        /// <param name="propertyWithValue">true if the property has a value, false if it doesn't.</param>
        /// <remarks>
        /// Pre-Condition:  The reader is positioned on the first node of the property value
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        /// <returns>The NestedResourceInfo or null.</returns>
        private ODataJsonLightReaderNestedInfo InnerReadUndeclaredProperty(IODataJsonLightReaderResourceState resourceState, IEdmStructuredType owningStructuredType, string propertyName, bool propertyWithValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.JsonReader.AssertNotBuffering();

            // Property without a value can't be ignored if we don't know what it is.
            if (!propertyWithValue)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OpenPropertyWithoutValue(propertyName));
            }

            object propertyValue = null;
            bool insideResourceValue = false;
            string outerPayloadTypeName = ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName);
            string payloadTypeName = TryReadOrPeekPayloadType(resourceState.PropertyAndAnnotationCollector, propertyName, insideResourceValue);
            EdmTypeKind payloadTypeKind;
            IEdmType payloadType = ReaderValidationUtils.ResolvePayloadTypeName(
                this.Model,
                null, // expectedTypeReference
                payloadTypeName,
                EdmTypeKind.Complex,
                this.MessageReaderSettings.ClientCustomTypeResolver,
                out payloadTypeKind);
            IEdmTypeReference payloadTypeReference = null;
            if (!string.IsNullOrEmpty(payloadTypeName) && payloadType != null)
            {
                // only try resolving for known type (the below will throw on unknown type name) :
                ODataTypeAnnotation typeAnnotation;
                EdmTypeKind targetTypeKind;
                payloadTypeReference = this.ReaderValidator.ResolvePayloadTypeNameAndComputeTargetType(
                    EdmTypeKind.None,
                    /*expectStructuredType*/ null,
                    /*defaultPrimitivePayloadType*/ null,
                    null, // expectedTypeReference
                    payloadTypeName,
                    this.Model,
                    this.GetNonEntityValueKind,
                    out targetTypeKind,
                    out typeAnnotation);
            }

            ODataJsonLightReaderNestedInfo nestedResourceInfo = TryReadAsStream(resourceState, null, payloadTypeReference, propertyName);
            if (nestedResourceInfo != null)
            {
                return nestedResourceInfo;
            }

            payloadTypeReference = ResolveUntypedType(
                this.JsonReader.NodeType,
                this.JsonReader.Value,
                payloadTypeName,
                payloadTypeReference,
                this.MessageReaderSettings.PrimitiveTypeResolver,
                this.MessageReaderSettings.ReadUntypedAsString,
                !this.MessageReaderSettings.ThrowIfTypeConflictsWithMetadata);

            bool isCollection = payloadTypeReference.IsCollection();
            IEdmStructuredType payloadTypeOrItemType = payloadTypeReference.ToStructuredType();
            if (payloadTypeOrItemType != null)
            {
                // Complex property or collection of complex property.
                ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, payloadTypeReference);
                if (isCollection)
                {
                    return ReadNonExpandedResourceSetNestedResourceInfo(resourceState, null, payloadTypeOrItemType, propertyName);
                }
                else
                {
                    return ReadNonExpandedResourceNestedResourceInfo(resourceState, null, payloadTypeOrItemType, propertyName);
                }
            }

            if (!(payloadTypeReference is IEdmUntypedTypeReference))
            {
                this.JsonReader.AssertNotBuffering();
                propertyValue = this.ReadNonEntityValue(
                    outerPayloadTypeName,
                    payloadTypeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevelPropertyValue*/ false,
                    /*insideResourceValue*/ false,
                    propertyName,
                    /*isDynamicProperty*/true);
            }
            else
            {
                propertyValue = this.JsonReader.ReadAsUntypedOrNullValue();
            }

            ValidationUtils.ValidateOpenPropertyValue(propertyName, propertyValue);
            AddResourceProperty(resourceState, propertyName, propertyValue);
            this.JsonReader.AssertNotBuffering();
            Debug.Assert(
                        this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                        "Post-Condition: expected JsonNodeType.Property or JsonNodeType.EndObject");

            return null;
        }

        /// <summary>
        /// Read an undeclared property. That is a property which is not declared by the model, but the owning type is not an open type.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the open property to read.</param>
        /// <param name="propertyWithValue">true if the property has a value, false if it doesn't.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue:  propertyWithValue is true and the reader is positioned on the first node of the property value.
        ///                 JsonNodeType.StartObject:
        ///                 JsonNodeType.StartArray:
        ///                 JsonNodeType.Property:        propertyWithValue is false and the reader is positioned on the node after the property.
        ///                 JsonNodeType.EndObject:
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        /// <returns>A nested resource info instance if the property read is a nested resource info which should be reported to the caller.
        /// Otherwise null if the property was either ignored or read and added to the list of properties on the resource.</returns>
        private ODataJsonLightReaderNestedInfo ReadUndeclaredProperty(IODataJsonLightReaderResourceState resourceState, string propertyName, bool propertyWithValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
#if DEBUG
            if (propertyWithValue)
            {
                this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property, JsonNodeType.StartObject, JsonNodeType.StartArray);
            }
            else
            {
                this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            }
#endif
            // Undeclared property
            // Detect whether it's a link property or value property.
            // Link properties are stream properties and deferred links.
            var odataPropertyAnnotations = resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(propertyName);
            object propertyAnnotationValue;

            // If the property has 'odata.mediaEditLink', 'odata.mediaReadLink', 'odata.mediaContentType' or 'odata.mediaEtag' annotation, read it as a stream property
            if (odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaEditLink, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaReadLink, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaContentType, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaETag, out propertyAnnotationValue))
            {
                // Add the stream reference property
                ODataStreamReferenceValue streamReferenceValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                AddResourceProperty(resourceState, propertyName, streamReferenceValue);

                if (propertyWithValue)
                {
                    ODataStreamPropertyInfo propertyInfo = this.ReadStreamPropertyInfo(resourceState, propertyName);
                    if (!IsJsonStream(propertyInfo))
                    {
                        // Not a JSON Stream, so skip over property name in JSON reader
                        this.JsonReader.Read();
                    }

                    return new ODataJsonLightReaderNestedPropertyInfo(propertyInfo, null);
                }

                return null;
            }

            // It's not a JSON stream, so skip the property name.
            // If the property does not have a value we will have already skipped the name
            if (propertyWithValue)
            {
                this.JsonReader.Read();
            }

            // If the property has 'odata.navigationLink' or 'odata.associationLink' annotation, read it as a navigation property
            if (odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataNavigationLinkUrl, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataAssociationLinkUrl, out propertyAnnotationValue))
            {
                // Read it as a deferred link - we never read the expanded content.
                ODataJsonLightReaderNestedResourceInfo navigationLinkInfo = ReadDeferredNestedResourceInfo(resourceState, propertyName, /*navigationProperty*/ null);
                resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(navigationLinkInfo.NestedResourceInfo);

                // If the property is expanded, ignore the content if we're asked to do so.
                if (propertyWithValue)
                {
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, null, propertyName, resourceState.ResourceType.ToTypeReference());

                    // Since we marked the nested resource info as deferred the reader will not try to read its content
                    // instead it will behave as if it was a real deferred link (without a property value).
                    // So skip the value here to move to the next property in the payload, which will look exactly the same
                    // as if the nested resource info was deferred.
                    this.JsonReader.SkipValue();
                }

                return navigationLinkInfo;
            }

            if (resourceState.ResourceType.IsOpen)
            {
                // Open property - read it as such.
                ODataJsonLightReaderNestedInfo nestedResourceInfo =
                    this.InnerReadUndeclaredProperty(resourceState, resourceState.ResourceType, propertyName, propertyWithValue);
                return nestedResourceInfo;
            }

            // Property without a value can't be ignored if we don't know what it is.
            if (!propertyWithValue)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_PropertyWithoutValueWithUnknownType(propertyName));
            }

            // Validate that the property doesn't have unrecognized annotations
            // We ignore the type name since we might not have the full model and thus might not be able to resolve it correctly.
            ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName);

            if (!this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType)
            {
                bool isTopLevelPropertyValue = false;
                ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                    this.InnerReadUndeclaredProperty(resourceState, propertyName, isTopLevelPropertyValue);
                return nestedResourceInfo;
            }
            else
            {
                Debug.Assert(
                    this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType,
                    "this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType");
            }

            return null;
        }

        /// <summary>
        /// Reads a stream property value from the property annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        /// <returns>The newly created stream reference value.</returns>
        private ODataStreamReferenceValue ReadStreamPropertyValue(IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            ODataStreamReferenceValue streamReferenceValue = new ODataStreamReferenceValue();
            ReadStreamInfo(streamReferenceValue, resourceState, streamPropertyName);
            ODataResourceMetadataBuilder builder =
            this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                /*isDelta*/ false);

            // Note that we set the metadata builder even when streamProperty is null, which is the case when the stream property is undeclared.
            // For undeclared stream properties, we will apply conventional metadata evaluation just as declared stream properties.
            streamReferenceValue.SetMetadataBuilder(builder, streamPropertyName);

            return streamReferenceValue;
        }

        /// <summary>
        /// Reads a stream property info from the property annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        /// <returns>The newly created stream reference value.</returns>
        private ODataStreamPropertyInfo ReadStreamPropertyInfo(IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            ODataStreamPropertyInfo streamInfo = new ODataStreamPropertyInfo
            {
                Name = streamPropertyName,
            };

            ReadStreamInfo(streamInfo, resourceState, streamPropertyName);
            ODataResourceMetadataBuilder builder =
            this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                /*isDelta*/ false);

            // Note that we set the metadata builder even when streamProperty is null, which is the case when the stream property is undeclared.
            // For undeclared stream properties, we will apply conventional metadata evaluation just as declared stream properties.
            streamInfo.SetMetadataBuilder(builder, streamPropertyName);

            return streamInfo;
        }

        /// <summary>
        /// Populates StreamInfo from the property annotations.
        /// </summary>
        /// <param name="streamInfo">The stream info to populate.</param>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        private void ReadStreamInfo(IODataStreamReferenceInfo streamInfo, IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(streamPropertyName), "!string.IsNullOrEmpty(streamPropertyName)");

            foreach (var propertyAnnotation
                     in resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(streamPropertyName))
            {
                switch (propertyAnnotation.Key)
                {
                    case ODataAnnotationNames.ODataMediaEditLink:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.mediaEditLink annotation should have been parsed as a non-null Uri.");
                        streamInfo.EditLink = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaReadLink:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.mediaReadLink annotation should have been parsed as a non-null Uri.");
                        streamInfo.ReadLink = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaETag:
                        Debug.Assert(propertyAnnotation.Value is string && propertyAnnotation.Value != null, "The odata.mediaEtag annotation should have been parsed as a non-null string.");
                        streamInfo.ETag = (string)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaContentType:
                        Debug.Assert(propertyAnnotation.Value is string && propertyAnnotation.Value != null, "The odata.mediaContentType annotation should have been parsed as a non-null string.");
                        streamInfo.ContentType = (string)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataType:
                        Debug.Assert(((string)propertyAnnotation.Value).Contains("Stream"), "Non-stream type annotation on stream property");
                        break;

                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedStreamPropertyAnnotation(streamPropertyName, propertyAnnotation.Key));
                }
            }

            // Streams in requests cannot contain links or etags
            if (!this.ReadingResponse)
            {
                if (streamInfo.ETag != null || streamInfo.EditLink != null || streamInfo.ReadLink != null)
                {
                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_StreamPropertyInRequest(streamPropertyName));
                }
            }
        }

        /// <summary>
        /// Reads one operation for the resource being read.
        /// </summary>
        /// <param name="readerContext">The Json operation deserializer context.</param>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <param name="insideArray">true if the operation value is inside an array, i.e. multiple targets for the operation; false otherwise.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject:   first node of the operation value.
        /// Post-Condition: JsonNodeType.Property:      the property after the current operation being read when there is one target for the operation.
        ///                 JsonNodeType.StartObject:   the first node of the next operation value when there are multiple targets for the operation.
        ///                 JsonNodeType.EndArray:      the end-array of the operation values when there are multiple target for the operation.
        /// </remarks>
        private void ReadSingleOperationValue(IODataJsonOperationsDeserializerContext readerContext, IODataJsonLightReaderResourceState resourceState, string metadataReferencePropertyName, bool insideArray)
        {
            Debug.Assert(readerContext != null, "readerContext != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(ODataJsonLightUtils.IsMetadataReferenceProperty(metadataReferencePropertyName), "ODataJsonLightReaderUtils.IsMetadataReferenceProperty(metadataReferencePropertyName)");

            if (readerContext.JsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonOperationsDeserializerUtils_OperationsPropertyMustHaveObjectValue(metadataReferencePropertyName, readerContext.JsonReader.NodeType));
            }

            // read over the start-object node of the metadata object for the operations
            readerContext.JsonReader.ReadStartObject();

            var operation = this.CreateODataOperationAndAddToEntry(readerContext, metadataReferencePropertyName);

            // Ignore the unrecognized operation.
            if (operation == null)
            {
                while (readerContext.JsonReader.NodeType == JsonNodeType.Property)
                {
                    readerContext.JsonReader.ReadPropertyName();
                    readerContext.JsonReader.SkipValue();
                }

                readerContext.JsonReader.ReadEndObject();
                return;
            }

            Debug.Assert(operation.Metadata != null, "operation.Metadata != null");

            while (readerContext.JsonReader.NodeType == JsonNodeType.Property)
            {
                string operationPropertyName = ODataAnnotationNames.RemoveAnnotationPrefix(readerContext.JsonReader.ReadPropertyName());
                switch (operationPropertyName)
                {
                    case JsonConstants.ODataOperationTitleName:
                        if (operation.Title != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string titleString = readerContext.JsonReader.ReadStringValue(JsonConstants.ODataOperationTitleName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(titleString, operationPropertyName, metadataReferencePropertyName);
                        operation.Title = titleString;
                        break;

                    case JsonConstants.ODataOperationTargetName:
                        if (operation.Target != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string targetString = readerContext.JsonReader.ReadStringValue(JsonConstants.ODataOperationTargetName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(targetString, operationPropertyName, metadataReferencePropertyName);
                        operation.Target = readerContext.ProcessUriFromPayload(targetString);
                        break;

                    default:
                        // skip over all unknown properties and read the next property or
                        // the end of the metadata for the current propertyName
                        readerContext.JsonReader.SkipValue();
                        break;
                }
            }

            if (operation.Target == null && insideArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OperationMissingTargetProperty(metadataReferencePropertyName));
            }

            // read the end-object node of the target / title pair
            readerContext.JsonReader.ReadEndObject();

            // Sets the metadata builder to evaluate by convention any operation property that's not on the wire.
            // Note we must only set this after the operation is read from the wire since we lose the ability to tell
            // what was on the wire and what is being dynamically computed.
            this.SetMetadataBuilder(resourceState, operation);
        }

        /// <summary>
        /// Reads one operation for the resource set being read.
        /// </summary>
        /// <param name="resourceSet">The resource set to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <param name="insideArray">true if the operation value is inside an array, i.e. multiple targets for the operation; false otherwise.</param>
        private void ReadSingleOperationValue(ODataResourceSet resourceSet, string metadataReferencePropertyName, bool insideArray)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(ODataJsonLightUtils.IsMetadataReferenceProperty(metadataReferencePropertyName), "ODataJsonLightReaderUtils.IsMetadataReferenceProperty(metadataReferencePropertyName)");

            if (this.JsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonOperationsDeserializerUtils_OperationsPropertyMustHaveObjectValue(metadataReferencePropertyName, this.JsonReader.NodeType));
            }

            // read over the start-object node of the metadata object for the operations
            this.JsonReader.ReadStartObject();

            var operation = this.CreateODataOperationAndAddToResourceSet(resourceSet, metadataReferencePropertyName);

            // Ignore the unrecognized operation.
            if (operation == null)
            {
                while (this.JsonReader.NodeType == JsonNodeType.Property)
                {
                    this.JsonReader.ReadPropertyName();
                    this.JsonReader.SkipValue();
                }

                this.JsonReader.ReadEndObject();
                return;
            }

            Debug.Assert(operation.Metadata != null, "operation.Metadata != null");

            while (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string operationPropertyName = ODataAnnotationNames.RemoveAnnotationPrefix(this.JsonReader.ReadPropertyName());
                switch (operationPropertyName)
                {
                    case JsonConstants.ODataOperationTitleName:
                        if (operation.Title != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string titleString = this.JsonReader.ReadStringValue(JsonConstants.ODataOperationTitleName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(titleString, operationPropertyName, metadataReferencePropertyName);
                        operation.Title = titleString;
                        break;

                    case JsonConstants.ODataOperationTargetName:
                        if (operation.Target != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string targetString = this.JsonReader.ReadStringValue(JsonConstants.ODataOperationTargetName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(targetString, operationPropertyName, metadataReferencePropertyName);
                        operation.Target = this.ProcessUriFromPayload(targetString);
                        break;

                    default:
                        // skip over all unknown properties and read the next property or
                        // the end of the metadata for the current propertyName
                        this.JsonReader.SkipValue();
                        break;
                }
            }

            if (operation.Target == null && insideArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OperationMissingTargetProperty(metadataReferencePropertyName));
            }

            // read the end-object node of the target / title pair
            this.JsonReader.ReadEndObject();
        }

        /// <summary>
        /// Sets the metadata builder for the operation.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="operation">The operation to set the metadata builder on.</param>
        private void SetMetadataBuilder(IODataJsonLightReaderResourceState resourceState, ODataOperation operation)
        {
            ODataResourceMetadataBuilder builder =
                this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                    this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                    /*isDelta*/ false);
            operation.SetMetadataBuilder(builder, this.ContextUriParseResult.MetadataDocumentUri);
        }

        /// <summary>
        /// Creates a new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.
        /// </summary>
        /// <param name="readerContext">The Json operation deserializer context.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <returns>A new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.</returns>
        private ODataOperation CreateODataOperationAndAddToEntry(IODataJsonOperationsDeserializerContext readerContext, string metadataReferencePropertyName)
        {
            string fullyQualifiedOperationName = ODataJsonLightUtils.GetUriFragmentFromMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);
            IEdmOperation firstActionOrFunction = this.JsonLightInputContext.Model.ResolveOperations(fullyQualifiedOperationName).FirstOrDefault();

            bool isAction;

            if (firstActionOrFunction == null)
            {
                // Ignore the unknown function/action.
                return null;
            }

            var operation = ODataJsonLightUtils.CreateODataOperation(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName, firstActionOrFunction, out isAction);

            if (isAction)
            {
                readerContext.AddActionToResource((ODataAction)operation);
            }
            else
            {
                readerContext.AddFunctionToResource((ODataFunction)operation);
            }

            return operation;
        }

        /// <summary>
        /// Creates a new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.
        /// </summary>
        /// <param name="resourceSet">The resource set to add the action or function .</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <returns>A new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.</returns>
        private ODataOperation CreateODataOperationAndAddToResourceSet(ODataResourceSet resourceSet, string metadataReferencePropertyName)
        {
            string fullyQualifiedOperationName = ODataJsonLightUtils.GetUriFragmentFromMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);
            IEdmOperation firstActionOrFunction = this.JsonLightInputContext.Model.ResolveOperations(fullyQualifiedOperationName).FirstOrDefault();

            bool isAction;

            if (firstActionOrFunction == null)
            {
                // Ignore the unknown function/action.
                return null;
            }

            var operation = ODataJsonLightUtils.CreateODataOperation(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName, firstActionOrFunction, out isAction);

            if (isAction)
            {
                resourceSet.AddAction((ODataAction)operation);
            }
            else
            {
                resourceSet.AddFunction((ODataFunction)operation);
            }

            return operation;
        }

        /// <summary>
        /// Read the metadata reference property value for the resource being read.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property:      first node of the metadata reference property's value. Currently
        ///                                             actions and functions are the only supported metadata reference property,
        ///                                             we will throw if this is not a start object or start array node.
        /// Post-Condition: JsonNodeType.Property:      the property after the annotation value
        ///                 JsonNodeType.EndObject:     the end-object of the resource
        /// </remarks>
        private void ReadMetadataReferencePropertyValue(IODataJsonLightReaderResourceState resourceState, string metadataReferencePropertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(resourceState.Resource != null, "resourceState.Resource != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(metadataReferencePropertyName.IndexOf(ODataConstants.ContextUriFragmentIndicator) > -1, "metadataReferencePropertyName.IndexOf(JsonLightConstants.ContextUriFragmentIndicator) > -1");
            this.JsonReader.AssertNotBuffering();

            this.ValidateCanReadMetadataReferenceProperty();

            // Validate that the property name is a valid absolute URI or a valid URI fragment.
            ODataJsonLightValidationUtils.ValidateMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);

            IODataJsonOperationsDeserializerContext readerContext = new OperationsDeserializerContext(resourceState.Resource, this);

            bool insideArray = false;
            if (readerContext.JsonReader.NodeType == JsonNodeType.StartArray)
            {
                readerContext.JsonReader.ReadStartArray();
                insideArray = true;
            }

            do
            {
                this.ReadSingleOperationValue(readerContext, resourceState, metadataReferencePropertyName, insideArray);
            }
            while (insideArray && readerContext.JsonReader.NodeType != JsonNodeType.EndArray);

            if (insideArray)
            {
                readerContext.JsonReader.ReadEndArray();
            }

            this.JsonReader.AssertNotBuffering();
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Read the metadata reference property value for the resource set being read.
        /// </summary>
        /// <param name="resourceSet">The resource set to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        private void ReadMetadataReferencePropertyValue(ODataResourceSet resourceSet, string metadataReferencePropertyName)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(metadataReferencePropertyName.IndexOf(ODataConstants.ContextUriFragmentIndicator) > -1, "metadataReferencePropertyName.IndexOf(JsonLightConstants.ContextUriFragmentIndicator) > -1");
            this.JsonReader.AssertNotBuffering();

            this.ValidateCanReadMetadataReferenceProperty();

            // Validate that the property name is a valid absolute URI or a valid URI fragment.
            ODataJsonLightValidationUtils.ValidateMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);

            bool insideArray = false;
            if (this.JsonReader.NodeType == JsonNodeType.StartArray)
            {
                this.JsonReader.ReadStartArray();
                insideArray = true;
            }

            do
            {
                this.ReadSingleOperationValue(resourceSet, metadataReferencePropertyName, insideArray);
            }
            while (insideArray && this.JsonReader.NodeType != JsonNodeType.EndArray);

            if (insideArray)
            {
                this.JsonReader.ReadEndArray();
            }

            this.JsonReader.AssertNotBuffering();
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Validates that we can read metadata reference property.
        /// </summary>
        private void ValidateCanReadMetadataReferenceProperty()
        {
            if (!this.ReadingResponse)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MetadataReferencePropertyInRequest);
            }
        }

        /// <summary>
        /// Operations deserializer context to pass to JSON operations reader.
        /// </summary>
        private sealed class OperationsDeserializerContext : IODataJsonOperationsDeserializerContext
        {
            /// <summary>
            /// The resource to add operations to.
            /// </summary>
            private ODataResourceBase resource;

            /// <summary>
            /// The deserializer to use.
            /// </summary>
            private ODataJsonLightResourceDeserializer jsonLightResourceDeserializer;

            /// <summary>
            /// Constructor.
            /// </summary>
            /// <param name="resource">The resource to add operations to.</param>
            /// <param name="jsonLightResourceDeserializer">The deserializer to use.</param>
            public OperationsDeserializerContext(ODataResourceBase resource, ODataJsonLightResourceDeserializer jsonLightResourceDeserializer)
            {
                Debug.Assert(resource != null, "resource != null");
                Debug.Assert(jsonLightResourceDeserializer != null, "jsonLightResourceDeserializer != null");

                this.resource = resource;
                this.jsonLightResourceDeserializer = jsonLightResourceDeserializer;
            }

            /// <summary>
            /// The JSON reader to read the operations value from.
            /// </summary>
            public IJsonReader JsonReader
            {
                get
                {
                    return this.jsonLightResourceDeserializer.JsonReader;
                }
            }

            /// <summary>
            /// Given a URI from the payload, this method will try to make it absolute, or fail otherwise.
            /// </summary>
            /// <param name="uriFromPayload">The URI string from the payload to process.</param>
            /// <returns>An absolute URI to report.</returns>
            public Uri ProcessUriFromPayload(string uriFromPayload)
            {
                return this.jsonLightResourceDeserializer.ProcessUriFromPayload(uriFromPayload);
            }

            /// <summary>
            /// Adds the specified action to the current resource.
            /// </summary>
            /// <param name="action">The action which is fully populated with the data from the payload.</param>
            public void AddActionToResource(ODataAction action)
            {
                Debug.Assert(action != null, "action != null");
                this.resource.AddAction(action);
            }

            /// <summary>
            /// Adds the specified function to the current resource.
            /// </summary>
            /// <param name="function">The function which is fully populated with the data from the payload.</param>
            public void AddFunctionToResource(ODataFunction function)
            {
                Debug.Assert(function != null, "function != null");
                this.resource.AddFunction(function);
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.JsonLight
{
    #region Namespaces
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Microsoft.OData.Evaluation;
    using Microsoft.OData.Json;
    using Microsoft.OData.Metadata;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Edm.Vocabularies;
    using Microsoft.OData.Edm.Vocabularies.V1;
    using ODataErrorStrings = Microsoft.OData.Strings;

    #endregion Namespaces

    /// <summary>
    /// OData JsonLight deserializer for entries and resource sets.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Need to keep the logic together for better readability.")]
    internal sealed class ODataJsonLightResourceDeserializer : ODataJsonLightPropertyAndValueDeserializer
    {
        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightInputContext">The JsonLight input context to read from.</param>
        internal ODataJsonLightResourceDeserializer(ODataJsonLightInputContext jsonLightInputContext)
            : base(jsonLightInputContext)
        {
        }

        /// <summary>
        /// Reads the start of the JSON array for the content of the resource set.
        /// </summary>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartArray:     The start of the resource set property array; this method will fail if the node is anything else.
        /// Post-Condition: JsonNodeType.StartObject:    The first item in the resource set
        ///                 JsonNodeType.PrimitiveValue: A null resource, or a primitive value within an untyped collection
        ///                 JsonNodeType.StartArray:     A nested collection within an untyped collection
        ///                 JsonNodeType.EndArray:       The end of the resource set
        /// </remarks>
        internal void ReadResourceSetContentStart()
        {
            this.JsonReader.AssertNotBuffering();

            if (this.JsonReader.NodeType != JsonNodeType.StartArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_CannotReadResourceSetContentStart(this.JsonReader.NodeType));
            }

            this.JsonReader.ReadStartArray();
            this.JsonReader.AssertNotBuffering();
        }

        /// <summary>
        /// Reads the end of the array containing the resource set content.
        /// </summary>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndArray
        /// Post-Condition: JsonNodeType.Property   if the resource set is part of an expanded nested resource info and there are more properties in the object
        ///                 JsonNodeType.EndObject  if the resource set is a top-level resource set or the expanded nested resource info is the last property of the payload
        ///                 JsonNodeType.EndOfInput  if the resource set is in a Uri operation parameter
        ///                 JsonNodeType.StartArray      if the resource set is a member of an untyped collection followed by a collection
        ///                 JsonNodeType.PrimitiveValue  if the resource set is a member of an untyped collection followed by a primitive value
        ///                 JsonNodeType.StartObject     if the resource set is a member of an untyped collection followed by a resource
        ///                 JsonNodeType.EndArray        if the resource set is the last member of an untyped collection
        /// </remarks>
        internal void ReadResourceSetContentEnd()
        {
            this.AssertJsonCondition(JsonNodeType.EndArray);
            this.JsonReader.AssertNotBuffering();

            this.JsonReader.ReadEndArray();

            this.AssertJsonCondition(JsonNodeType.EndOfInput, JsonNodeType.EndObject, JsonNodeType.Property, JsonNodeType.StartArray, JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.EndArray);
        }

        /// <summary>
        /// Reads the resource type name annotation (odata.type)
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the resource object.
        ///                 JsonNodeType.EndObject         End of the resource object.
        /// Post-Condition: JsonNodeType.Property          The property after the odata.type (if there was any), or the property on which the method was called.
        ///                 JsonNodeType.EndObject         End of the resource object.
        ///
        /// This method fills the ODataResource.TypeName property if the type name is found in the payload.
        /// </remarks>
        internal void ReadResourceTypeName(IODataJsonLightReaderResourceState resourceState)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the odata.type property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string propertyName = this.JsonReader.GetPropertyName();
                if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataType, propertyName) == 0
                    || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataTypePropertyName, propertyName))
                {
                    Debug.Assert(resourceState.Resource.TypeName == null, "type name should not have already been set");

                    // Read over the property to move to its value.
                    this.JsonReader.Read();

                    // Read the annotation value.
                    resourceState.Resource.TypeName = this.ReadODataTypeAnnotationValue();
                }
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the OData 4.01 deleted resource annotation (odata.removed)
        /// </summary>
        /// <returns>Returns True if the resource is a deleted resource, otherwise returns false </returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the resource object.
        ///                 JsonNodeType.EndObject         End of the resource object.
        /// Post-Condition: JsonNodeType.Property          The property after the odata.type (if there was any), or the property on which the method was called.
        ///                 JsonNodeType.EndObject         End of the resource object.
        ///
        /// This method Creates an ODataDeltaDeletedEntry and fills in the Id and Reason properties, if specified in the payload.
        /// </remarks>
        internal ODataDeletedResource IsDeletedResource()
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            ODataDeletedResource deletedResource = null;

            // If the current node is the deleted property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string propertyName = this.JsonReader.GetPropertyName();
                if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataRemoved, propertyName) == 0
                    || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataRemovedPropertyName, propertyName))
                {
                    DeltaDeletedEntryReason reason = DeltaDeletedEntryReason.Changed;
                    Uri id = null;

                    // Read over the property to move to its value.
                    this.JsonReader.Read();

                    // Read the removed object and extract the reason, if present
                    this.AssertJsonCondition(JsonNodeType.StartObject, JsonNodeType.PrimitiveValue /*null*/);
                    if (this.JsonReader.NodeType != JsonNodeType.PrimitiveValue)
                    {
                        while (this.JsonReader.NodeType != JsonNodeType.EndObject && this.JsonReader.Read())
                        {
                            // If the current node is the reason property - read it.
                            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                            string.CompareOrdinal(JsonLightConstants.ODataReasonPropertyName, this.JsonReader.GetPropertyName()) == 0)
                            {
                                // Read over the property to move to its value.
                                this.JsonReader.Read();

                                // Read the reason value.
                                if (string.CompareOrdinal(JsonLightConstants.ODataReasonDeletedValue, this.JsonReader.ReadStringValue()) == 0)
                                {
                                    reason = DeltaDeletedEntryReason.Deleted;
                                }
                            }
                        }
                    }
                    else if (this.JsonReader.Value != null)
                    {
                        throw new ODataException(Strings.ODataJsonLightResourceDeserializer_DeltaRemovedAnnotationMustBeObject(this.JsonReader.Value));
                    }

                    // read over end object or null value
                    this.JsonReader.Read();

                    // A deleted object must have at least either the odata id annotation or the key values
                    if (this.JsonReader.NodeType != JsonNodeType.Property)
                    {
                        throw new ODataException(Strings.ODataWriterCore_DeltaResourceWithoutIdOrKeyProperties);
                    }

                    // If the next property is the id property - read it.
                    propertyName = this.JsonReader.GetPropertyName();
                    if (string.CompareOrdinal(JsonLightConstants.ODataPropertyAnnotationSeparatorChar + ODataAnnotationNames.ODataId, propertyName) == 0
                        || this.CompareSimplifiedODataAnnotation(JsonLightConstants.SimplifiedODataIdPropertyName, propertyName))
                    {
                        // Read over the property to move to its value.
                        this.JsonReader.Read();

                        // Read the id value.
                        id = UriUtils.StringToUri(this.JsonReader.ReadStringValue());
                    }

                    deletedResource = ReaderUtils.CreateDeletedResource(id, reason);
                }
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            return deletedResource;
        }

        /// <summary>
        /// Reads an OData 4.0 delete entry
        /// </summary>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// <returns>The <see cref="ODataDeletedResource"/> read.</returns>
        /// <remarks>
        /// This method Creates an ODataDeltaDeletedEntry and fills in the Id and Reason properties, if specified in the payload.
        /// </remarks>
        internal ODataDeletedResource ReadDeletedEntry()
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            Uri id = null;
            DeltaDeletedEntryReason reason = DeltaDeletedEntryReason.Changed;

            // If the current node is the id property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataIdPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the Id value.
                id = this.JsonReader.ReadUriValue();
                Debug.Assert(id != null, "value for Id must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the reason property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataReasonPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the reason value.
                if (string.CompareOrdinal(JsonLightConstants.ODataReasonDeletedValue, this.JsonReader.ReadStringValue()) == 0)
                {
                    reason = DeltaDeletedEntryReason.Deleted;
                }
            }

            // Ignore unknown primitive properties in a 4.0 deleted entry
            while (this.JsonReader.NodeType != JsonNodeType.EndObject && this.JsonReader.Read())
            {
                if (this.JsonReader.NodeType == JsonNodeType.StartObject || this.JsonReader.NodeType == JsonNodeType.StartArray)
                {
                    throw new ODataException(Strings.ODataWriterCore_NestedContentNotAllowedIn40DeletedEntry);
                }
            }

            return ReaderUtils.CreateDeletedResource(id, reason);
        }

        /// <summary>
        /// Reads the delta (deleted) link source.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Source property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkSource(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the source property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataSourcePropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Source == null, "source should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the source value.
                link.Source = this.JsonReader.ReadUriValue();
                Debug.Assert(link.Source != null, "value for source must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the delta (deleted) link relationship.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Relationship property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkRelationship(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the relationship property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataRelationshipPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Relationship == null, "relationship should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the relationship value.
                link.Relationship = this.JsonReader.ReadStringValue();
                Debug.Assert(link.Relationship != null, "value for relationship must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the delta (deleted) link target.
        /// </summary>
        /// <param name="link">The delta (deleted) link being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property          The first property after the odata.context in the link object.
        ///                 JsonNodeType.EndObject         End of the link object.
        /// Post-Condition: JsonNodeType.Property          The properties.
        ///                 JsonNodeType.EndObject         End of the link object.
        ///
        /// This method fills the ODataDelta(Deleted)Link.Target property if the id is found in the payload.
        /// </remarks>
        internal void ReadDeltaLinkTarget(ODataDeltaLinkBase link)
        {
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            // If the current node is the target property - read it.
            if (this.JsonReader.NodeType == JsonNodeType.Property &&
                string.CompareOrdinal(JsonLightConstants.ODataTargetPropertyName, this.JsonReader.GetPropertyName()) == 0)
            {
                Debug.Assert(link.Target == null, "target should not have already been set");

                // Read over the property to move to its value.
                this.JsonReader.Read();

                // Read the source value.
                link.Target = this.JsonReader.ReadUriValue();
                Debug.Assert(link.Target != null, "value for target must be provided");
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the content of a resource until a nested resource info is detected.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property               The property to read
        ///                 JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        /// Post-Condition: JsonNodeType.EndObject              If no (more) properties exist in the resource's content
        ///                 JsonNodeType.Property               If we've read a deferred link (this is the property after the deferred link)
        ///                 JsonNodeType.StartObject            Expanded resource
        ///                 JsonNodeType.StartArray             Expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null
        /// </remarks>
        internal ODataJsonLightReaderNestedInfo ReadResourceContent(IODataJsonLightReaderResourceState resourceState)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(resourceState.ResourceType != null && this.Model.IsUserModel(), "A non-null resource type and non-null model are required.");
            Debug.Assert(
                this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Pre-Condition: JsonNodeType.Property or JsonNodeType.EndObject");
            this.JsonReader.AssertNotBuffering();

            ODataJsonLightReaderNestedInfo readerNestedResourceInfo = null;
            Debug.Assert(resourceState.ResourceType != null, "In JSON we must always have an structured type when reading resource.");

            // Figure out whether we have more properties for this resource
            // read all the properties until we hit a link
            while (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                this.ReadPropertyCustomAnnotationValue = this.ReadCustomInstanceAnnotationValue;
                this.ProcessProperty(
                    resourceState.PropertyAndAnnotationCollector,
                    this.ReadEntryPropertyAnnotationValue,
                    (propertyParsingResult, propertyName) =>
                    {
                        switch (propertyParsingResult)
                        {
                            case PropertyParsingResult.ODataInstanceAnnotation:
                            case PropertyParsingResult.CustomInstanceAnnotation:
                                this.ReadOverPropertyName();
                                object value = ReadODataOrCustomInstanceAnnotationValue(resourceState, propertyParsingResult, propertyName);
                                this.ApplyEntryInstanceAnnotation(resourceState, propertyName, value);
                                break;

                            case PropertyParsingResult.PropertyWithoutValue:
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithoutValue(resourceState, propertyName);
                                break;

                            case PropertyParsingResult.NestedDeltaResourceSet:
                                // Will read over property name in ReadPropertyWithValue
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithValue(resourceState, propertyName, /*isDeltaResourceSet*/ true);
                                break;

                            case PropertyParsingResult.PropertyWithValue:
                                // Will read over property name in ReadPropertyWithValue
                                resourceState.AnyPropertyFound = true;
                                readerNestedResourceInfo = this.ReadPropertyWithValue(resourceState, propertyName, /*isDeltaResourceSet*/ false);
                                break;

                            case PropertyParsingResult.MetadataReferenceProperty:
                                this.ReadOverPropertyName();
                                this.ReadMetadataReferencePropertyValue(resourceState, propertyName);
                                break;

                            case PropertyParsingResult.EndOfObject:
                                this.ReadOverPropertyName();
                                break;
                        }
                    });

                if (readerNestedResourceInfo != null)
                {
                    // we found a nested resource info
                    // stop parsing the resource content and return to the caller
                    break;
                }

                Debug.Assert(
                    this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                    "After reading a property the reader should be positioned on another property or have hit the end of the object.");
            }

            this.JsonReader.AssertNotBuffering();

            // The reader can be either on
            //  - StartObject - if it's an expanded resource
            //  - StartArray - if it's an expanded resource set
            //  - Property - if it's a deferred link
            //  - PrimitiveValue- if it's a stream or an expanded null resource
            //  - EndObject - end of the resource
            Debug.Assert(
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.StartObject ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.StartArray ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.Property ||
                readerNestedResourceInfo != null && this.JsonReader.NodeType == JsonNodeType.PrimitiveValue ||
                readerNestedResourceInfo is ODataJsonLightReaderNestedInfo ||
                this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.StartObject or JsonNodeType.StartArray or JsonNodeType.Property or JsonNodeType.EndObject or JsonNodeType.Primitive (with null value)");

            return readerNestedResourceInfo;
        }

        /// <summary>
        /// Reads built-in "odata." or custom instance annotation's value.
        /// </summary>
        /// <param name="resourceState">The IODataJsonLightReaderResourceState.</param>
        /// <param name="propertyParsingResult">The PropertyParsingResult.</param>
        /// <param name="annotationName">The annotation name</param>
        /// <returns>The annotation value.</returns>
        internal object ReadODataOrCustomInstanceAnnotationValue(IODataJsonLightReaderResourceState resourceState, PropertyParsingResult propertyParsingResult, string annotationName)
        {
            object value = this.ReadEntryInstanceAnnotation(annotationName, resourceState.AnyPropertyFound, /*typeAnnotationFound*/ true, resourceState.PropertyAndAnnotationCollector);
            if (propertyParsingResult == PropertyParsingResult.ODataInstanceAnnotation)
            {
                resourceState.PropertyAndAnnotationCollector.AddODataScopeAnnotation(annotationName, value);
            }
            else
            {
                resourceState.PropertyAndAnnotationCollector.AddCustomScopeAnnotation(annotationName, value);
            }

            return value;
        }

        /// <summary>
        /// Validates resource metadata.
        /// </summary>
        /// <param name="resourceState">The resource state to use.</param>
        internal void ValidateMediaEntity(IODataJsonLightReaderResourceState resourceState)
        {
            ODataResourceBase resource = resourceState.Resource;
            if (resource != null)
            {
                if (resourceState.ResourceType is IEdmEntityType entityType)
                {
                    // If the entity in the model has a default stream and if no MR related metadata exists in the resource payload, create an empty MediaResource.
                    // Note that for responses the metadata builder will compute the default stream.  For requests we really don't need to add the default stream since the service knows its metadata.
                    // We leave this here for now so we don't introduce a breaking change.
                    if (!this.ReadingResponse && entityType.HasStream && resource.MediaResource == null)
                    {
                        ODataStreamReferenceValue mediaResource = resource.MediaResource;
                        ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                        this.SetEntryMediaResource(resourceState, mediaResource);
                    }

                    this.ReaderValidator.ValidateMediaResource(resource, entityType);
                }
            }
        }

        /// <summary>
        /// Reads the resource set instance annotations for a top-level resource set.
        /// </summary>
        /// <param name="resourceSet">The <see cref="ODataResourceSet"/> to read the instance annotations for.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for the top-level scope.</param>
        /// <param name="forResourceSetStart">true when parsing the instance annotations before the resource set property;
        /// false when parsing the instance annotations after the resource set property.</param>
        /// <param name="readAllResourceSetProperties">true if we should scan ahead for the annotations and ignore the actual data properties (used with
        /// the reordering reader); otherwise false.</param>
        internal void ReadTopLevelResourceSetAnnotations(ODataResourceSetBase resourceSet, PropertyAndAnnotationCollector propertyAndAnnotationCollector, bool forResourceSetStart, bool readAllResourceSetProperties)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");
            this.JsonReader.AssertNotBuffering();

            bool buffering = false;
            try
            {
                while (this.JsonReader.NodeType == JsonNodeType.Property)
                {
                    bool foundValueProperty = false;

                    if (!forResourceSetStart && readAllResourceSetProperties)
                    {
                        // If this is not called for reading ResourceSetStart and we already scanned ahead and processed all resource set properties, we already checked for duplicate property names.
                        // Use an empty duplicate property name checker since this.ParseProperty() read through the same property annotation of instance annotations again.
                        propertyAndAnnotationCollector = new PropertyAndAnnotationCollector(false);
                    }

                    this.ProcessProperty(
                        propertyAndAnnotationCollector,
                        this.ReadTypePropertyAnnotationValue,
                        (propertyParseResult, propertyName) =>
                        {
                            this.ReadOverPropertyName();
                            switch (propertyParseResult)
                            {
                                case PropertyParsingResult.ODataInstanceAnnotation:
                                case PropertyParsingResult.CustomInstanceAnnotation:
                                    ReadODataOrCustomInstanceAnnotationValue(resourceSet, propertyAndAnnotationCollector,
                                        forResourceSetStart, readAllResourceSetProperties, propertyParseResult, propertyName);
                                    break;

                                case PropertyParsingResult.PropertyWithValue:
                                    if (string.CompareOrdinal(JsonLightConstants.ODataValuePropertyName, propertyName) == 0)
                                    {
                                        // We found the resource set property and are done parsing property annotations;
                                        // When we are in the mode where we scan ahead and read all resource set properties
                                        // (for the reordering scenario), we have to start buffering and continue
                                        // reading. Otherwise we found the resourceSet's data property and are done.
                                        if (readAllResourceSetProperties)
                                        {
                                            this.JsonReader.StartBuffering();
                                            buffering = true;

                                            this.JsonReader.SkipValue();
                                        }
                                        else
                                        {
                                            foundValueProperty = true;
                                        }
                                    }
                                    else
                                    {
                                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidPropertyInTopLevelResourceSet(propertyName, JsonLightConstants.ODataValuePropertyName));
                                    }

                                    break;
                                case PropertyParsingResult.PropertyWithoutValue:
                                    // If we find a property without a value it means that we did not find the resource set property (yet)
                                    // but an invalid property annotation
                                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_InvalidPropertyAnnotationInTopLevelResourceSet(propertyName));

                                case PropertyParsingResult.EndOfObject:
                                    break;

                                case PropertyParsingResult.MetadataReferenceProperty:
                                    if (!(resourceSet is ODataResourceSet))
                                    {
                                        throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedMetadataReferenceProperty(propertyName));
                                    }

                                    this.ReadMetadataReferencePropertyValue((ODataResourceSet)resourceSet, propertyName);
                                    break;

                                default:
                                    throw new ODataException(ODataErrorStrings.General_InternalError(InternalErrorCodes.ODataJsonLightResourceDeserializer_ReadTopLevelResourceSetAnnotations));
                            }
                        });

                    if (foundValueProperty)
                    {
                        return;
                    }
                }
            }
            finally
            {
                if (buffering)
                {
                    Debug.Assert(readAllResourceSetProperties, "Expect the reader to be in buffering mode only when scanning to the end.");
                    this.JsonReader.StopBuffering();
                }
            }

            if (forResourceSetStart && !readAllResourceSetProperties)
            {
                // We did not find any properties or only instance annotations.
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ExpectedResourceSetPropertyNotFound(JsonLightConstants.ODataValuePropertyName));
            }
        }

        /// <summary>
        /// Reads built-in "odata." or custom instance annotation's value.
        /// </summary>
        /// <param name="resourceSet">The ODataResourceSetBase.</param>
        /// <param name="propertyAndAnnotationCollector">The PropertyAndAnnotationCollector.</param>
        /// <param name="forResourceSetStart">true when parsing the instance annotations before the resource set property;
        /// false when parsing the instance annotations after the resource set property.</param>
        /// <param name="readAllResourceSetProperties">true if we should scan ahead for the annotations and ignore the actual data properties (used with
        /// the reordering reader); otherwise false.</param>
        /// <param name="propertyParseResult">The PropertyParsingResult.</param>
        /// <param name="annotationName">The annotation name.</param>
        internal void ReadODataOrCustomInstanceAnnotationValue(ODataResourceSetBase resourceSet,
            PropertyAndAnnotationCollector propertyAndAnnotationCollector, bool forResourceSetStart,
            bool readAllResourceSetProperties, PropertyParsingResult propertyParseResult, string annotationName)
        {
            if (propertyParseResult == PropertyParsingResult.ODataInstanceAnnotation)
            {
                // #### annotation 1 ####
                // built-in "odata." annotation value is added to propertyAndAnnotationCollector then later to resourceSet.InstanceAnnotations.
                propertyAndAnnotationCollector.AddODataScopeAnnotation(annotationName, this.JsonReader.Value);
            }

            // When we are reading the start of a resource set (in scan-ahead mode or not) or when
            // we read the end of a resource set and not in scan-ahead mode, read the value;
            // otherwise skip it.
            if (forResourceSetStart || !readAllResourceSetProperties)
            {
                // #### annotation 2 ####
                // custom annotation value will be directly added to resourceSet.InstanceAnnotations.
                this.ReadAndApplyResourceSetInstanceAnnotationValue(annotationName, resourceSet, propertyAndAnnotationCollector);
            }
            else
            {
                this.JsonReader.SkipValue();
            }
        }

        /// <summary>
        /// Reads a value of property annotation on the resource level.
        /// </summary>
        /// <param name="propertyAnnotationName">The name of the property annotation to read.</param>
        /// <returns>The value of the property annotation.</returns>
        /// <remarks>
        /// This method should read the property annotation value and return a representation of the value which will be later
        /// consumed by the resource reading code.
        ///
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the property annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the property annotation
        /// </remarks>
        internal object ReadEntryPropertyAnnotationValue(string propertyAnnotationName)
        {
            Debug.Assert(!string.IsNullOrEmpty(propertyAnnotationName), "!string.IsNullOrEmpty(propertyAnnotationName)");
            Debug.Assert(
                propertyAnnotationName.StartsWith(JsonLightConstants.ODataAnnotationNamespacePrefix, StringComparison.Ordinal),
                "The method should only be called with OData. annotations");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.StartArray);

            string typeName;
            if (this.TryReadODataTypeAnnotationValue(propertyAnnotationName, out typeName))
            {
                return typeName;
            }

            switch (propertyAnnotationName)
            {
                case ODataAnnotationNames.ODataNavigationLinkUrl:  // odata.navigationLinkUrl
                case ODataAnnotationNames.ODataAssociationLinkUrl: // odata.associationLinkUrl
                case ODataAnnotationNames.ODataNextLink:           // odata.nextLink
                case ODataAnnotationNames.ODataMediaEditLink:      // odata.mediaEditLink
                case ODataAnnotationNames.ODataMediaReadLink:      // odata.mediaReadLink
                case ODataAnnotationNames.ODataContext:            // odata.context
                    return this.ReadAndValidateAnnotationStringValueAsUri(propertyAnnotationName);

                case ODataAnnotationNames.ODataCount:              // odata.count
                    return this.ReadAndValidateAnnotationAsLongForIeee754Compatible(propertyAnnotationName);

                case ODataAnnotationNames.ODataMediaETag:          // odata.mediaEtag
                case ODataAnnotationNames.ODataMediaContentType:   // odata.mediaContentType
                    return this.ReadAndValidateAnnotationStringValue(propertyAnnotationName);

                // odata.bind
                case ODataAnnotationNames.ODataBind:
                    // The value of the odata.bind annotation can be either an array of strings or a string (collection or singleton nested resource info).
                    // Note that we don't validate that the cardinality of the navigation property matches the payload here, since we don't want to lookup the property twice.
                    // We will validate that later when we consume the value of the property annotation.
                    if (this.JsonReader.NodeType != JsonNodeType.StartArray)
                    {
                        return new ODataEntityReferenceLink
                        {
                            Url = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataBind)
                        };
                    }

                    LinkedList<ODataEntityReferenceLink> entityReferenceLinks = new LinkedList<ODataEntityReferenceLink>();

                    // Read over the start array
                    this.JsonReader.Read();
                    while (this.JsonReader.NodeType != JsonNodeType.EndArray)
                    {
                        entityReferenceLinks.AddLast(
                            new ODataEntityReferenceLink
                            {
                                Url = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataBind)
                            });
                    }

                    // Read over the end array
                    this.JsonReader.Read();
                    if (entityReferenceLinks.Count == 0)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_EmptyBindArray(ODataAnnotationNames.ODataBind));
                    }

                    return entityReferenceLinks;

                case ODataAnnotationNames.ODataDeltaLink:   // Delta links are not supported on expanded resource sets.
                default:
                    throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedAnnotationProperties(propertyAnnotationName));
            }
        }

        /// <summary>
        /// Reads instance annotation in the resource object.
        /// </summary>
        /// <param name="annotationName">The name of the instance annotation found.</param>
        /// <param name="anyPropertyFound">true if a non-annotation property has already been encountered.</param>
        /// <param name="typeAnnotationFound">true if the 'odata.type' annotation has already been encountered, or should have been by now.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker for the resource being read.</param>
        /// <returns>The value of the annotation.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the instance annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the instance annotation
        /// </remarks>
        internal object ReadEntryInstanceAnnotation(string annotationName, bool anyPropertyFound, bool typeAnnotationFound, PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.StartObject, JsonNodeType.StartArray);

            switch (annotationName)
            {
                case ODataAnnotationNames.ODataType:   // 'odata.type'
                    if (!typeAnnotationFound)
                    {
                        return this.ReadODataTypeAnnotationValue();
                    }

                    // We already read the odata.type if it was the first property in ReadResourceStart, so any other occurrence means
                    // that it was not the first property.
                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceTypeAnnotationNotFirst);

                case ODataAnnotationNames.ODataId:   // 'odata.id'
                    if (anyPropertyFound)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceInstanceAnnotationPrecededByProperty(annotationName));
                    }

                    return this.ReadAnnotationStringValueAsUri(annotationName);

                case ODataAnnotationNames.ODataETag:   // 'odata.etag'
                    if (anyPropertyFound)
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_ResourceInstanceAnnotationPrecededByProperty(annotationName));
                    }

                    return this.ReadAndValidateAnnotationStringValue(annotationName);

                case ODataAnnotationNames.ODataEditLink:    // 'odata.editLink'
                case ODataAnnotationNames.ODataReadLink:    // 'odata.readLink'
                case ODataAnnotationNames.ODataMediaEditLink:   // 'odata.mediaEditLink'
                case ODataAnnotationNames.ODataMediaReadLink:   // 'odata.mediaReadLink'
                    return this.ReadAndValidateAnnotationStringValueAsUri(annotationName);

                case ODataAnnotationNames.ODataMediaContentType:  // 'odata.mediaContentType'
                case ODataAnnotationNames.ODataMediaETag:  // 'odata.mediaEtag'
                    return this.ReadAndValidateAnnotationStringValue(annotationName);

                case ODataAnnotationNames.ODataRemoved: // 'odata.removed'
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedDeletedEntryInResponsePayload);
                    }

                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    return this.ReadCustomInstanceAnnotationValue(propertyAndAnnotationCollector, annotationName);
            }
        }

        /// <summary>
        /// Reads instance annotation in the resource object.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="annotationName">The name of the instance annotation found.</param>
        /// <param name="annotationValue">The value of the annotation.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the instance annotation property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the instance annotation
        /// </remarks>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "The casts aren't actually being done multiple times, since they occur in different cases of the switch statement.")]
        internal void ApplyEntryInstanceAnnotation(IODataJsonLightReaderResourceState resourceState, string annotationName, object annotationValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");

            ODataResourceBase resource = resourceState.Resource;
            ODataStreamReferenceValue mediaResource = resource.MediaResource;
            switch (annotationName)
            {
                case ODataAnnotationNames.ODataType:   // 'odata.type'
                    resource.TypeName = ReaderUtils.AddEdmPrefixOfTypeName(ReaderUtils.RemovePrefixOfTypeName((string)annotationValue));
                    break;

                case ODataAnnotationNames.ODataId:   // 'odata.id'
                    if (annotationValue == null)
                    {
                        resource.IsTransient = true;
                    }
                    else
                    {
                        resource.Id = (Uri)annotationValue;
                    }

                    break;

                case ODataAnnotationNames.ODataETag:   // 'odata.etag'
                    resource.ETag = (string)annotationValue;
                    break;

                case ODataAnnotationNames.ODataEditLink:    // 'odata.editLink'
                    resource.EditLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataReadLink:    // 'odata.readLink'
                    resource.ReadLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaEditLink:   // 'odata.mediaEditLink'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.EditLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaReadLink:   // 'odata.mediaReadLink'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ReadLink = (Uri)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaContentType:  // 'odata.mediaContentType'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ContentType = (string)annotationValue;
                    break;

                case ODataAnnotationNames.ODataMediaETag:  // 'odata.mediaEtag'
                    ODataJsonLightReaderUtils.EnsureInstance(ref mediaResource);
                    mediaResource.ETag = (string)annotationValue;
                    break;

                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    resource.InstanceAnnotations.Add(new ODataInstanceAnnotation(annotationName, annotationValue.ToODataValue()));
                    break;
            }

            if (mediaResource != null && resource.MediaResource == null)
            {
                this.SetEntryMediaResource(resourceState, mediaResource);
            }
        }

        /// <summary>
        /// Reads the value of a resource set annotation (count or next link).
        /// </summary>
        /// <param name="annotationName">The name of the annotation found.</param>
        /// <param name="resourceSet">The resource set to read the annotation for; if non-null, the annotation value will be assigned to the resource set.</param>
        /// <param name="propertyAndAnnotationCollector">The duplicate property names checker instance.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the annotation
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource set object
        ///                 JsonNodeType.Property               The next annotation after the current annotation
        /// </remarks>
        internal void ReadAndApplyResourceSetInstanceAnnotationValue(string annotationName, ODataResourceSetBase resourceSet, PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(!string.IsNullOrEmpty(annotationName), "!string.IsNullOrEmpty(annotationName)");
            Debug.Assert(resourceSet != null, "resourceSet != null");

            switch (annotationName)
            {
                case ODataAnnotationNames.ODataCount:
                    resourceSet.Count = this.ReadAndValidateAnnotationAsLongForIeee754Compatible(ODataAnnotationNames.ODataCount);
                    break;

                case ODataAnnotationNames.ODataNextLink:
                    resourceSet.NextPageLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataNextLink);
                    break;

                case ODataAnnotationNames.ODataDeltaLink:
                    resourceSet.DeltaLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataDeltaLink);
                    break;
                case ODataAnnotationNames.ODataType:

                    // TODO: skip the odata.type;
                    this.ReadAndValidateAnnotationStringValue(ODataAnnotationNames.ODataType);
                    break;
                default:
                    ODataAnnotationNames.ValidateIsCustomAnnotationName(annotationName);
                    Debug.Assert(
                        !this.MessageReaderSettings.ShouldSkipAnnotation(annotationName),
                        "!this.MessageReaderSettings.ShouldReadAndValidateAnnotation(annotationName) -- otherwise we should have already skipped the custom annotation and won't see it here.");
                    object instanceAnnotationValue = this.ReadCustomInstanceAnnotationValue(propertyAndAnnotationCollector, annotationName);
                    resourceSet.InstanceAnnotations.Add(new ODataInstanceAnnotation(annotationName, instanceAnnotationValue.ToODataValue()));
                    break;
            }
        }

        /// <summary>
        /// Reads resource property which doesn't have value, just annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the property read.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.EndObject              The end of the resource object.
        ///                 JsonNodeType.Property               The property after the one we're to read.
        /// Post-Condition: JsonNodeType.EndObject              This method doesn't move the reader.
        ///                 JsonNodeType.Property
        /// </remarks>
        internal ODataJsonLightReaderNestedInfo ReadPropertyWithoutValue(IODataJsonLightReaderResourceState resourceState, string propertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IEdmStructuredType resourceType = resourceState.ResourceType;
            IEdmProperty edmProperty = this.ReaderValidator.ValidatePropertyDefined(propertyName, resourceType);
            if (edmProperty != null && !edmProperty.Type.IsUntyped())
            {
                // Declared property - read it.
                ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo;

                if (edmProperty is IEdmNavigationProperty navigationProperty)
                {
                    if (this.ReadingResponse)
                    {
                        // Deferred link
                        readerNestedResourceInfo = ReadDeferredNestedResourceInfo(resourceState, propertyName, navigationProperty);
                    }
                    else
                    {
                        // Entity reference link or links
                        readerNestedResourceInfo = navigationProperty.Type.IsCollection()
                            ? ReadEntityReferenceLinksForCollectionNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ false)
                            : ReadEntityReferenceLinkForSingletonNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ false);

                        if (!readerNestedResourceInfo.HasEntityReferenceLink)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_NavigationPropertyWithoutValueAndEntityReferenceLink(propertyName, ODataAnnotationNames.ODataBind));
                        }
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else
                {
                    IEdmTypeReference propertyTypeReference = edmProperty.Type;
                    if (propertyTypeReference.IsStream())
                    {
                        Debug.Assert(propertyName == edmProperty.Name, "propertyName == edmProperty.Name");
                        ODataStreamReferenceValue streamPropertyValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                        AddResourceProperty(resourceState, edmProperty.Name, streamPropertyValue);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_PropertyWithoutValueWithWrongType(propertyName, propertyTypeReference.FullName()));
                    }
                }
            }
            else
            {
                // Undeclared property - we need to run detection algorithm here.
                readerNestedInfo = this.ReadUndeclaredProperty(resourceState, propertyName, /*propertyWithValue*/ false);
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            return readerNestedInfo;
        }

        /// <summary>
        /// Reads any next link annotation immediately after the end of a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set being read.</param>
        /// <param name="expandedNestedResourceInfo">The information about the expanded link. This must be non-null if we're reading an expanded resource set, and must be null if we're reading a top-level resource set.</param>
        /// <param name="propertyAndAnnotationCollector">The top-level duplicate property names checker, if we're reading a top-level resource set.</param>
        internal void ReadNextLinkAnnotationAtResourceSetEnd(
            ODataResourceSetBase resourceSet,
            ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo,
            PropertyAndAnnotationCollector propertyAndAnnotationCollector)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            // Check for annotations on the resource set that occur after the resource set itself. (Note: the only allowed one is odata.nextLink, and we fail for anything else.)
            // We do this slightly differently depending on whether the resource set was an expanded navigation or a top-level resource set.
            if (expandedNestedResourceInfo != null)
            {
                this.ReadExpandedResourceSetAnnotationsAtResourceSetEnd(resourceSet, expandedNestedResourceInfo);
            }
            else
            {
                Debug.Assert(propertyAndAnnotationCollector != null, "propertyAndAnnotationCollector != null");

                // Check for resource set instance annotations that appear after the resource set.
                bool isReordering = this.JsonReader is ReorderingJsonReader;
                this.ReadTopLevelResourceSetAnnotations(resourceSet, propertyAndAnnotationCollector, /*forResourceSetStart*/false, /*readAllResourceSetProperties*/isReordering);
            }
        }

        /// <summary>
        /// Reads the information of a deferred link.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="navigationPropertyName">The name of the navigation property for which to read the deferred link.</param>
        /// <param name="navigationProperty">The navigation property for which to read the deferred link. This can be null.</param>
        /// <returns>Returns the nested resource info for the deferred nested resource info read.</returns>
        /// <remarks>
        /// This method doesn't move the reader.
        /// </remarks>
        private static ODataJsonLightReaderNestedResourceInfo ReadDeferredNestedResourceInfo(IODataJsonLightReaderResourceState resourceState, string navigationPropertyName, IEdmNavigationProperty navigationProperty)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(navigationPropertyName), "!string.IsNullOrEmpty(navigationPropertyName)");
            Debug.Assert(navigationProperty == null || navigationPropertyName == navigationProperty.Name, "navigationProperty == null || navigationPropertyName == navigationProperty.Name");

            ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo()
            {
                Name = navigationPropertyName,
                IsCollection = navigationProperty == null ? null : (bool?)navigationProperty.Type.IsCollection()
            };

            foreach (var propertyAnnotation
                     in resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(nestedResourceInfo.Name))
            {
                switch (propertyAnnotation.Key)
                {
                    case ODataAnnotationNames.ODataNavigationLinkUrl:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.navigationLinkUrl annotation should have been parsed as a non-null Uri.");
                        nestedResourceInfo.Url = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataAssociationLinkUrl:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.associationLinkUrl annotation should have been parsed as a non-null Uri.");
                        nestedResourceInfo.AssociationLinkUrl = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataType:
                        Debug.Assert(propertyAnnotation.Value is String && propertyAnnotation.Value != null, "The odata.type annotation should have been parsed as a non-null string.");
                        nestedResourceInfo.TypeAnnotation = new ODataTypeAnnotation((string)propertyAnnotation.Value);
                        break;

                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedDeferredLinkPropertyAnnotation(nestedResourceInfo.Name, propertyAnnotation.Key));
                }
            }

            return ODataJsonLightReaderNestedResourceInfo.CreateDeferredLinkInfo(nestedResourceInfo, navigationProperty);
        }

        /// <summary>
        /// We fail here if we encounter any other property annotation for the expanded navigation (since these should come before the property itself).
        /// </summary>
        /// <param name="resourceSet">The resource set that was just read.</param>
        /// <param name="expandedNestedResourceInfo">The information for the current expanded nested resource info being read.</param>
        private void ReadExpandedResourceSetAnnotationsAtResourceSetEnd(ODataResourceSetBase resourceSet, ODataJsonLightReaderNestedResourceInfo expandedNestedResourceInfo)
        {
            Debug.Assert(expandedNestedResourceInfo != null, "expandedNestedResourceInfo != null");
            Debug.Assert(expandedNestedResourceInfo.NestedResourceInfo.IsCollection == true, "Only collection navigation properties can have resourceSet content.");

            // Look at the next property in the owning resource, if it's a property annotation for the expanded nested resource info property, read it.
            string propertyName, annotationName;
            while (this.JsonReader.NodeType == JsonNodeType.Property &&
                   TryParsePropertyAnnotation(this.JsonReader.GetPropertyName(), out propertyName, out annotationName) &&
                   string.CompareOrdinal(propertyName, expandedNestedResourceInfo.NestedResourceInfo.Name) == 0)
            {
                if (!this.ReadingResponse)
                {
                    throw new ODataException(ODataErrorStrings.ODataJsonLightPropertyAndValueDeserializer_UnexpectedPropertyAnnotation(propertyName, annotationName));
                }

                // Read over the property name.
                this.JsonReader.Read();

                switch (this.CompleteSimplifiedODataAnnotation(annotationName))
                {
                    case ODataAnnotationNames.ODataNextLink:
                        if (resourceSet.NextPageLink != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_DuplicateNestedResourceSetAnnotation(ODataAnnotationNames.ODataNextLink, expandedNestedResourceInfo.NestedResourceInfo.Name));
                        }

                        // Read the property value.
                        resourceSet.NextPageLink = this.ReadAndValidateAnnotationStringValueAsUri(ODataAnnotationNames.ODataNextLink);
                        break;

                    case ODataAnnotationNames.ODataCount:
                        if (resourceSet.Count != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_DuplicateNestedResourceSetAnnotation(ODataAnnotationNames.ODataCount, expandedNestedResourceInfo.NestedResourceInfo.Name));
                        }

                        // Read the property value.
                        resourceSet.Count = this.ReadAndValidateAnnotationAsLongForIeee754Compatible(ODataAnnotationNames.ODataCount);
                        break;

                    case ODataAnnotationNames.ODataDeltaLink:   // Delta links are not supported on expanded resource sets.
                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedPropertyAnnotationAfterExpandedResourceSet(annotationName, expandedNestedResourceInfo.NestedResourceInfo.Name));
                }
            }
        }

        /// <summary>
        /// Sets specified media resource on a resource and hooks up metadata builder.
        /// </summary>
        /// <param name="resourceState">The resource state to use.</param>
        /// <param name="mediaResource">The media resource to set.</param>
        private void SetEntryMediaResource(IODataJsonLightReaderResourceState resourceState, ODataStreamReferenceValue mediaResource)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(mediaResource != null, "mediaResource != null");
            ODataResourceBase resource = resourceState.Resource;
            Debug.Assert(resource != null, "resource != null");

            ODataResourceMetadataBuilder builder =
                this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                    this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                    /*isDelta*/ false);
            mediaResource.SetMetadataBuilder(builder, /*propertyName*/ null);
            resource.MediaResource = mediaResource;
        }

        /// <summary>
        /// Reads resource property (which is neither instance nor property annotation) which has a value.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the property read.</param>
        /// <param name="isDeltaResourceSet">The property being read represents a nested delta resource set.</param>
        /// <returns>A reader nested resource info representing the nested resource info detected while reading the resource contents; null if no nested resource info was detected.</returns>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue         The value of the property
        ///                 JsonNodeType.StartObject
        ///                 JsonNodeType.StartArray
        /// Post-Condition: JsonNodeType.EndObject              The end of the resource object
        ///                 JsonNodeType.Property               The next property after the property
        ///                 JsonNodeType.StartObject            Expanded resource
        ///                 JsonNodeType.StartArray             Expanded resource set
        ///                 JsonNodeType.PrimitiveValue (null)  Expanded null resource
        /// </remarks>
        private ODataJsonLightReaderNestedInfo ReadPropertyWithValue(IODataJsonLightReaderResourceState resourceState, string propertyName, bool isDeltaResourceSet)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property, JsonNodeType.StartObject, JsonNodeType.StartArray);

            ODataJsonLightReaderNestedInfo readerNestedInfo = null;
            IEdmStructuredType resourceType = resourceState.ResourceType;
            IEdmProperty edmProperty = this.ReaderValidator.ValidatePropertyDefined(propertyName, resourceType);
            bool isCollection = edmProperty == null ? false : edmProperty.Type.IsCollection();

            if (edmProperty is IEdmStructuralProperty structuralProperty)
            {
                ODataJsonLightReaderNestedInfo nestedInfo = TryReadAsStream(resourceState, structuralProperty, structuralProperty.Type, structuralProperty.Name);
                if (nestedInfo != null)
                {
                    return nestedInfo;
                }
            }

            if (edmProperty != null && !edmProperty.Type.IsUntyped())
            {
                this.ReadOverPropertyName();
                IEdmStructuredType structuredPropertyTypeOrItemType = structuralProperty == null ? null : structuralProperty.Type.ToStructuredType();
                if (structuredPropertyTypeOrItemType != null)
                {
                    ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo = null;

                    // Complex property or collection of complex property.
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, edmProperty.Type);

                    if (isCollection)
                    {
                        readerNestedResourceInfo = ReadNonExpandedResourceSetNestedResourceInfo(resourceState, structuralProperty, structuredPropertyTypeOrItemType, structuralProperty.Name);
                    }
                    else
                    {
                        readerNestedResourceInfo = ReadNonExpandedResourceNestedResourceInfo(resourceState, structuralProperty, structuredPropertyTypeOrItemType, structuralProperty.Name);
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else if (edmProperty is IEdmNavigationProperty navigationProperty)
                {
                    ODataJsonLightReaderNestedResourceInfo readerNestedResourceInfo = null;

                    // Expanded link
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, edmProperty.Type);
                    if (isCollection)
                    {
                        readerNestedResourceInfo = this.ReadingResponse || isDeltaResourceSet
                            ? ReadExpandedResourceSetNestedResourceInfo(resourceState, navigationProperty, navigationProperty.Type.ToStructuredType(), propertyName, /*isDeltaResourceSet*/ isDeltaResourceSet)
                            : ReadEntityReferenceLinksForCollectionNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ true);
                    }
                    else
                    {
                        readerNestedResourceInfo = this.ReadingResponse
                            ? ReadExpandedResourceNestedResourceInfo(resourceState, navigationProperty, propertyName, navigationProperty.Type.ToStructuredType(), this.MessageReaderSettings)
                            : ReadEntityReferenceLinkForSingletonNavigationLinkInRequest(resourceState, navigationProperty, propertyName, /*isExpanded*/ true);
                    }

                    resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(readerNestedResourceInfo.NestedResourceInfo);
                    readerNestedInfo = readerNestedResourceInfo;
                }
                else
                {
                    var derivedTypeConstraints = this.JsonLightInputContext.Model.GetDerivedTypeConstraints(edmProperty);
                    if (derivedTypeConstraints != null)
                    {
                        resourceState.PropertyAndAnnotationCollector.SetDerivedTypeValidator(propertyName, new DerivedTypeValidator(edmProperty.Type.Definition, derivedTypeConstraints, "property", propertyName));
                    }

                    // NOTE: we currently do not check whether the property should be skipped
                    //       here because this can only happen for navigation properties and open properties.
                    this.ReadEntryDataProperty(resourceState, edmProperty, ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName));
                }
            }
            else
            {
                // Undeclared property - we need to run detection algorithm here.
                readerNestedInfo = this.ReadUndeclaredProperty(resourceState, propertyName, /*propertyWithValue*/ true);

                // Note that if nested resource info is returned it's already validated, so we just report it here.
            }

            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject, JsonNodeType.StartObject, JsonNodeType.StartArray, JsonNodeType.PrimitiveValue);
            return readerNestedInfo;
        }

        /// <summary>
        /// Checks to see if the current property should be read as a stream and, if so reads it
        /// </summary>
        /// <param name="resourceState">current ResourceState</param>
        /// <param name="property">The property being serialized (null for a dynamic property)</param>
        /// <param name="propertyType">The type of the property being serialized</param>
        /// <param name="propertyName">The name of the property being serialized</param>
        /// <returns>The ODataJsonLightReaderNestedInfo for a nested stream property, or null if the property shouldn't be streamed</returns>
        private ODataJsonLightReaderNestedInfo TryReadAsStream(IODataJsonLightReaderResourceState resourceState, IEdmStructuralProperty property, IEdmTypeReference propertyType, string propertyName)
        {
            Debug.Assert(propertyName != null, "Property name must not be null");

            bool isCollection = false;
            IEdmPrimitiveType primitiveType = null;
            if (propertyType != null)
            {
                primitiveType = propertyType.Definition.AsElementType() as IEdmPrimitiveType;
                isCollection = propertyType.IsCollection();
            }
            else
            {
                isCollection = this.JsonReader.NodeType != JsonNodeType.PrimitiveValue;
            }

            Func<IEdmPrimitiveType, bool, string, IEdmProperty, bool> readAsStream = this.MessageReaderSettings.ReadAsStreamFunc;

            // is the property a stream or a stream collection,
            // untyped collection,
            // or a binary or binary collection the client wants to read as a stream...
            if (
                (primitiveType != null &&
                    (primitiveType.IsStream() ||
                        (readAsStream != null
                             && (property == null || !property.IsKey())  // don't stream key properties
                             && (primitiveType.IsBinary() || primitiveType.IsString() || isCollection))
                         && readAsStream(primitiveType, isCollection, propertyName, property))) ||
                (propertyType != null &&
                    isCollection &&
                    propertyType.Definition.AsElementType().IsUntyped()) ||
                (propertyType == null
                    && (isCollection || this.JsonReader.CanStream())
                    && readAsStream != null
                    && readAsStream(null, isCollection, propertyName, property)))
            {
                if (isCollection)
                {
                    this.ReadOverPropertyName();
                    IEdmType elementType = propertyType == null ? EdmCoreModel.Instance.GetUntypedType() : propertyType.Definition.AsElementType();

                    // Collection of streams, or binary/string values to read as streams
                    return ReadStreamCollectionNestedResourceInfo(resourceState, property, propertyName, elementType);
                }
                else
                {
                    ODataPropertyInfo propertyInfo;
                    if (primitiveType != null && primitiveType.PrimitiveKind == EdmPrimitiveTypeKind.Stream)
                    {
                        ODataStreamPropertyInfo streamPropertyInfo = this.ReadStreamPropertyInfo(resourceState, propertyName);

                        // If it has an instance annotation saying that the content type is JSON, don't read propertyName
                        // otherwise, if we are on start object, BufferingJsonReader will read ahead to try and determine
                        // if we are reading an instream error, which destroys our ability to stream json stream values.
                        if (this.JsonReader.NodeType == JsonNodeType.Property)
                        {
                            bool isJson = false;
                            if (streamPropertyInfo.ContentType != null)
                            {
                                if (streamPropertyInfo.ContentType.Contains(MimeConstants.MimeApplicationJson))
                                {
                                    isJson = true;
                                }
                            }
                            else if (property != null)
                            {
                                IEdmVocabularyAnnotation mediaTypeAnnotation = property.VocabularyAnnotations(this.Model).FirstOrDefault(a => a.Term == CoreVocabularyModel.MediaTypeTerm);
                                if (mediaTypeAnnotation != null)
                                {
                                    // If the property does not have a mediaType annotation specifying application/json, then read over the property name
                                    if (mediaTypeAnnotation.Value is IEdmStringConstantExpression stringExpression && stringExpression.Value.Contains(MimeConstants.MimeApplicationJson))
                                    {
                                        isJson = true;
                                    }
                                }
                            }

                            if (!isJson)
                            {
                                // Not reading JSON stream, so read over property name
                                this.ReadOverPropertyName();
                            }
                        }

                        // Add the stream reference property
                        ODataStreamReferenceValue streamReferenceValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                        AddResourceProperty(resourceState, propertyName, streamReferenceValue);

                        propertyInfo = streamPropertyInfo;
                    }
                    else
                    {
                        this.ReadOverPropertyName();

                        propertyInfo = new ODataPropertyInfo
                        {
                            PrimitiveTypeKind = primitiveType == null ? EdmPrimitiveTypeKind.None : primitiveType.PrimitiveKind,
                            Name = propertyName,
                        };
                    }

                    // return without reading over the property node; we will create a stream over the value
                    this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property);
                    return new ODataJsonLightReaderNestedPropertyInfo(propertyInfo, property);
                }
            }

            return null;
        }

        /// <summary>
        /// Reads over the current property name if positioned on a property
        /// </summary>
        private void ReadOverPropertyName()
        {
            if (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                this.JsonReader.Read();
            }
        }

        /// <summary>
        /// Returns whether or not a StreamPropertyInfo value specifies a content-type of application/json.
        /// </summary>
        /// <param name="streamPropertyInfo">The StreamPropertyInfo that may specify application/json.</param>
        /// <returns>True, if the StreamPropertyInfo specifies application/json, otherwise false.</returns>
        private static bool IsJsonStream(ODataStreamPropertyInfo streamPropertyInfo)
        {
            return streamPropertyInfo.ContentType != null && streamPropertyInfo.ContentType.Contains(MimeConstants.MimeApplicationJson);
        }

        /// <summary>
        /// Read a resource-level data property and check its version compliance.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="edmProperty">The EDM property of the property being read, or null if the property is an open property.</param>
        /// <param name="propertyTypeName">The type name specified for the property in property annotation, or null if no such type name is available.</param>
        /// <remarks>
        /// Pre-Condition:  The reader is positioned on the first node of the property value
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        private void ReadEntryDataProperty(IODataJsonLightReaderResourceState resourceState, IEdmProperty edmProperty, string propertyTypeName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(edmProperty != null, "edmProperty != null");
            this.JsonReader.AssertNotBuffering();

            // EdmLib bridge marks all key properties as non-nullable, but Astoria allows them to be nullable.
            // If the property has an annotation to ignore null values, we need to omit the property in requests.
            ODataNullValueBehaviorKind nullValueReadBehaviorKind = this.ReadingResponse
                ? ODataNullValueBehaviorKind.Default
                : this.Model.NullValueReadBehaviorKind(edmProperty);
            object propertyValue = this.ReadNonEntityValue(
                propertyTypeName,
                edmProperty.Type,
                /*propertyAndAnnotationCollector*/ null,
                /*collectionValidator*/ null,
                nullValueReadBehaviorKind == ODataNullValueBehaviorKind.Default,
                /*isTopLevelPropertyValue*/ false,
                /*insideResourceValue*/ false,
                edmProperty.Name);

            if (nullValueReadBehaviorKind != ODataNullValueBehaviorKind.IgnoreValue || propertyValue != null)
            {
                AddResourceProperty(resourceState, edmProperty.Name, propertyValue);
            }

            this.JsonReader.AssertNotBuffering();
            Debug.Assert(
                this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                "Post-Condition: expected JsonNodeType.Property or JsonNodeType.EndObject");
        }

        /// <summary>
        /// Read an open property.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="owningStructuredType">The owning type of the property with name <paramref name="propertyName"/>
        /// or null if no metadata is available.</param>
        /// <param name="propertyName">The name of the open property to read.</param>
        /// <param name="propertyWithValue">true if the property has a value, false if it doesn't.</param>
        /// <remarks>
        /// Pre-Condition:  The reader is positioned on the first node of the property value
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        /// <returns>The NestedResourceInfo or null.</returns>
        private ODataJsonLightReaderNestedInfo InnerReadUndeclaredProperty(IODataJsonLightReaderResourceState resourceState, IEdmStructuredType owningStructuredType, string propertyName, bool propertyWithValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
            this.JsonReader.AssertNotBuffering();

            // Property without a value can't be ignored if we don't know what it is.
            if (!propertyWithValue)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OpenPropertyWithoutValue(propertyName));
            }

            object propertyValue = null;
            bool insideResourceValue = false;
            string outerPayloadTypeName = ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName);
            string payloadTypeName = TryReadOrPeekPayloadType(resourceState.PropertyAndAnnotationCollector, propertyName, insideResourceValue);
            EdmTypeKind payloadTypeKind;
            IEdmType payloadType = ReaderValidationUtils.ResolvePayloadTypeName(
                this.Model,
                null, // expectedTypeReference
                payloadTypeName,
                EdmTypeKind.Complex,
                this.MessageReaderSettings.ClientCustomTypeResolver,
                out payloadTypeKind);
            IEdmTypeReference payloadTypeReference = null;
            if (!string.IsNullOrEmpty(payloadTypeName) && payloadType != null)
            {
                // only try resolving for known type (the below will throw on unknown type name) :
                ODataTypeAnnotation typeAnnotation;
                EdmTypeKind targetTypeKind;
                payloadTypeReference = this.ReaderValidator.ResolvePayloadTypeNameAndComputeTargetType(
                    EdmTypeKind.None,
                    /*expectStructuredType*/ null,
                    /*defaultPrimitivePayloadType*/ null,
                    null, // expectedTypeReference
                    payloadTypeName,
                    this.Model,
                    this.GetNonEntityValueKind,
                    out targetTypeKind,
                    out typeAnnotation);
            }

            ODataJsonLightReaderNestedInfo nestedResourceInfo = TryReadAsStream(resourceState, null, payloadTypeReference, propertyName);
            if (nestedResourceInfo != null)
            {
                return nestedResourceInfo;
            }

            payloadTypeReference = ResolveUntypedType(
                this.JsonReader.NodeType,
                this.JsonReader.Value,
                payloadTypeName,
                payloadTypeReference,
                this.MessageReaderSettings.PrimitiveTypeResolver,
                this.MessageReaderSettings.ReadUntypedAsString,
                !this.MessageReaderSettings.ThrowIfTypeConflictsWithMetadata);

            bool isCollection = payloadTypeReference.IsCollection();
            IEdmStructuredType payloadTypeOrItemType = payloadTypeReference.ToStructuredType();
            if (payloadTypeOrItemType != null)
            {
                // Complex property or collection of complex property.
                ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, isCollection, propertyName, payloadTypeReference);
                if (isCollection)
                {
                    return ReadNonExpandedResourceSetNestedResourceInfo(resourceState, null, payloadTypeOrItemType, propertyName);
                }
                else
                {
                    return ReadNonExpandedResourceNestedResourceInfo(resourceState, null, payloadTypeOrItemType, propertyName);
                }
            }

            if (!(payloadTypeReference is IEdmUntypedTypeReference))
            {
                this.JsonReader.AssertNotBuffering();
                propertyValue = this.ReadNonEntityValue(
                    outerPayloadTypeName,
                    payloadTypeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevelPropertyValue*/ false,
                    /*insideResourceValue*/ false,
                    propertyName,
                    /*isDynamicProperty*/true);
            }
            else
            {
                propertyValue = this.JsonReader.ReadAsUntypedOrNullValue();
            }

            ValidationUtils.ValidateOpenPropertyValue(propertyName, propertyValue);
            AddResourceProperty(resourceState, propertyName, propertyValue);
            this.JsonReader.AssertNotBuffering();
            Debug.Assert(
                        this.JsonReader.NodeType == JsonNodeType.Property || this.JsonReader.NodeType == JsonNodeType.EndObject,
                        "Post-Condition: expected JsonNodeType.Property or JsonNodeType.EndObject");

            return null;
        }

        /// <summary>
        /// Read an undeclared property. That is a property which is not declared by the model, but the owning type is not an open type.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="propertyName">The name of the open property to read.</param>
        /// <param name="propertyWithValue">true if the property has a value, false if it doesn't.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.PrimitiveValue:  propertyWithValue is true and the reader is positioned on the first node of the property value.
        ///                 JsonNodeType.StartObject:
        ///                 JsonNodeType.StartArray:
        ///                 JsonNodeType.Property:        propertyWithValue is false and the reader is positioned on the node after the property.
        ///                 JsonNodeType.EndObject:
        /// Post-Condition: JsonNodeType.Property:    the next property of the resource
        ///                 JsonNodeType.EndObject:   the end-object node of the resource
        /// </remarks>
        /// <returns>A nested resource info instance if the property read is a nested resource info which should be reported to the caller.
        /// Otherwise null if the property was either ignored or read and added to the list of properties on the resource.</returns>
        private ODataJsonLightReaderNestedInfo ReadUndeclaredProperty(IODataJsonLightReaderResourceState resourceState, string propertyName, bool propertyWithValue)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(propertyName), "!string.IsNullOrEmpty(propertyName)");
#if DEBUG
            if (propertyWithValue)
            {
                this.AssertJsonCondition(JsonNodeType.PrimitiveValue, JsonNodeType.Property, JsonNodeType.StartObject, JsonNodeType.StartArray);
            }
            else
            {
                this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
            }
#endif
            // Undeclared property
            // Detect whether it's a link property or value property.
            // Link properties are stream properties and deferred links.
            var odataPropertyAnnotations = resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(propertyName);
            object propertyAnnotationValue;

            // If the property has 'odata.mediaEditLink', 'odata.mediaReadLink', 'odata.mediaContentType' or 'odata.mediaEtag' annotation, read it as a stream property
            if (odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaEditLink, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaReadLink, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaContentType, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataMediaETag, out propertyAnnotationValue))
            {
                // Add the stream reference property
                ODataStreamReferenceValue streamReferenceValue = this.ReadStreamPropertyValue(resourceState, propertyName);
                AddResourceProperty(resourceState, propertyName, streamReferenceValue);

                if (propertyWithValue)
                {
                    ODataStreamPropertyInfo propertyInfo = this.ReadStreamPropertyInfo(resourceState, propertyName);
                    if (!IsJsonStream(propertyInfo))
                    {
                        // Not a JSON Stream, so skip over property name in JSON reader
                        this.JsonReader.Read();
                    }

                    return new ODataJsonLightReaderNestedPropertyInfo(propertyInfo, null);
                }

                return null;
            }

            // It's not a JSON stream, so skip the property name.
            // If the property does not have a value we will have already skipped the name
            if (propertyWithValue)
            {
                this.JsonReader.Read();
            }

            // If the property has 'odata.navigationLink' or 'odata.associationLink' annotation, read it as a navigation property
            if (odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataNavigationLinkUrl, out propertyAnnotationValue) ||
                odataPropertyAnnotations.TryGetValue(ODataAnnotationNames.ODataAssociationLinkUrl, out propertyAnnotationValue))
            {
                // Read it as a deferred link - we never read the expanded content.
                ODataJsonLightReaderNestedResourceInfo navigationLinkInfo = ReadDeferredNestedResourceInfo(resourceState, propertyName, /*navigationProperty*/ null);
                resourceState.PropertyAndAnnotationCollector.ValidatePropertyUniquenessOnNestedResourceInfoStart(navigationLinkInfo.NestedResourceInfo);

                // If the property is expanded, ignore the content if we're asked to do so.
                if (propertyWithValue)
                {
                    ValidateExpandedNestedResourceInfoPropertyValue(this.JsonReader, null, propertyName, resourceState.ResourceType.ToTypeReference());

                    // Since we marked the nested resource info as deferred the reader will not try to read its content
                    // instead it will behave as if it was a real deferred link (without a property value).
                    // So skip the value here to move to the next property in the payload, which will look exactly the same
                    // as if the nested resource info was deferred.
                    this.JsonReader.SkipValue();
                }

                return navigationLinkInfo;
            }

            if (resourceState.ResourceType.IsOpen)
            {
                // Open property - read it as such.
                ODataJsonLightReaderNestedInfo nestedResourceInfo =
                    this.InnerReadUndeclaredProperty(resourceState, resourceState.ResourceType, propertyName, propertyWithValue);
                return nestedResourceInfo;
            }

            // Property without a value can't be ignored if we don't know what it is.
            if (!propertyWithValue)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_PropertyWithoutValueWithUnknownType(propertyName));
            }

            // Validate that the property doesn't have unrecognized annotations
            // We ignore the type name since we might not have the full model and thus might not be able to resolve it correctly.
            ValidateDataPropertyTypeNameAnnotation(resourceState.PropertyAndAnnotationCollector, propertyName);

            if (!this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType)
            {
                bool isTopLevelPropertyValue = false;
                ODataJsonLightReaderNestedResourceInfo nestedResourceInfo =
                    this.InnerReadUndeclaredProperty(resourceState, propertyName, isTopLevelPropertyValue);
                return nestedResourceInfo;
            }
            else
            {
                Debug.Assert(
                    this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType,
                    "this.MessageReaderSettings.ThrowOnUndeclaredPropertyForNonOpenType");
            }

            return null;
        }

        /// <summary>
        /// Reads a stream property value from the property annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        /// <returns>The newly created stream reference value.</returns>
        private ODataStreamReferenceValue ReadStreamPropertyValue(IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            ODataStreamReferenceValue streamReferenceValue = new ODataStreamReferenceValue();
            ReadStreamInfo(streamReferenceValue, resourceState, streamPropertyName);
            ODataResourceMetadataBuilder builder =
            this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                /*isDelta*/ false);

            // Note that we set the metadata builder even when streamProperty is null, which is the case when the stream property is undeclared.
            // For undeclared stream properties, we will apply conventional metadata evaluation just as declared stream properties.
            streamReferenceValue.SetMetadataBuilder(builder, streamPropertyName);

            return streamReferenceValue;
        }

        /// <summary>
        /// Reads a stream property info from the property annotations.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        /// <returns>The newly created stream reference value.</returns>
        private ODataStreamPropertyInfo ReadStreamPropertyInfo(IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            ODataStreamPropertyInfo streamInfo = new ODataStreamPropertyInfo
            {
                Name = streamPropertyName,
            };

            ReadStreamInfo(streamInfo, resourceState, streamPropertyName);
            ODataResourceMetadataBuilder builder =
            this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                /*isDelta*/ false);

            // Note that we set the metadata builder even when streamProperty is null, which is the case when the stream property is undeclared.
            // For undeclared stream properties, we will apply conventional metadata evaluation just as declared stream properties.
            streamInfo.SetMetadataBuilder(builder, streamPropertyName);

            return streamInfo;
        }

        /// <summary>
        /// Populates StreamInfo from the property annotations.
        /// </summary>
        /// <param name="streamInfo">The stream info to populate.</param>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="streamPropertyName">The name of the stream property to read the value for.</param>
        private void ReadStreamInfo(IODataStreamReferenceInfo streamInfo, IODataJsonLightReaderResourceState resourceState, string streamPropertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(!string.IsNullOrEmpty(streamPropertyName), "!string.IsNullOrEmpty(streamPropertyName)");

            foreach (var propertyAnnotation
                     in resourceState.PropertyAndAnnotationCollector.GetODataPropertyAnnotations(streamPropertyName))
            {
                switch (propertyAnnotation.Key)
                {
                    case ODataAnnotationNames.ODataMediaEditLink:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.mediaEditLink annotation should have been parsed as a non-null Uri.");
                        streamInfo.EditLink = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaReadLink:
                        Debug.Assert(propertyAnnotation.Value is Uri && propertyAnnotation.Value != null, "The odata.mediaReadLink annotation should have been parsed as a non-null Uri.");
                        streamInfo.ReadLink = (Uri)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaETag:
                        Debug.Assert(propertyAnnotation.Value is string && propertyAnnotation.Value != null, "The odata.mediaEtag annotation should have been parsed as a non-null string.");
                        streamInfo.ETag = (string)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataMediaContentType:
                        Debug.Assert(propertyAnnotation.Value is string && propertyAnnotation.Value != null, "The odata.mediaContentType annotation should have been parsed as a non-null string.");
                        streamInfo.ContentType = (string)propertyAnnotation.Value;
                        break;

                    case ODataAnnotationNames.ODataType:
                        Debug.Assert(((string)propertyAnnotation.Value).Contains("Stream"), "Non-stream type annotation on stream property");
                        break;

                    default:
                        throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_UnexpectedStreamPropertyAnnotation(streamPropertyName, propertyAnnotation.Key));
                }
            }

            // Streams in requests cannot contain links or etags
            if (!this.ReadingResponse)
            {
                if (streamInfo.ETag != null || streamInfo.EditLink != null || streamInfo.ReadLink != null)
                {
                    throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_StreamPropertyInRequest(streamPropertyName));
                }
            }
        }

        /// <summary>
        /// Reads one operation for the resource being read.
        /// </summary>
        /// <param name="readerContext">The Json operation deserializer context.</param>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <param name="insideArray">true if the operation value is inside an array, i.e. multiple targets for the operation; false otherwise.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.StartObject:   first node of the operation value.
        /// Post-Condition: JsonNodeType.Property:      the property after the current operation being read when there is one target for the operation.
        ///                 JsonNodeType.StartObject:   the first node of the next operation value when there are multiple targets for the operation.
        ///                 JsonNodeType.EndArray:      the end-array of the operation values when there are multiple target for the operation.
        /// </remarks>
        private void ReadSingleOperationValue(IODataJsonOperationsDeserializerContext readerContext, IODataJsonLightReaderResourceState resourceState, string metadataReferencePropertyName, bool insideArray)
        {
            Debug.Assert(readerContext != null, "readerContext != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(ODataJsonLightUtils.IsMetadataReferenceProperty(metadataReferencePropertyName), "ODataJsonLightReaderUtils.IsMetadataReferenceProperty(metadataReferencePropertyName)");

            if (readerContext.JsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonOperationsDeserializerUtils_OperationsPropertyMustHaveObjectValue(metadataReferencePropertyName, readerContext.JsonReader.NodeType));
            }

            // read over the start-object node of the metadata object for the operations
            readerContext.JsonReader.ReadStartObject();

            var operation = this.CreateODataOperationAndAddToEntry(readerContext, metadataReferencePropertyName);

            // Ignore the unrecognized operation.
            if (operation == null)
            {
                while (readerContext.JsonReader.NodeType == JsonNodeType.Property)
                {
                    readerContext.JsonReader.ReadPropertyName();
                    readerContext.JsonReader.SkipValue();
                }

                readerContext.JsonReader.ReadEndObject();
                return;
            }

            Debug.Assert(operation.Metadata != null, "operation.Metadata != null");

            while (readerContext.JsonReader.NodeType == JsonNodeType.Property)
            {
                string operationPropertyName = ODataAnnotationNames.RemoveAnnotationPrefix(readerContext.JsonReader.ReadPropertyName());
                switch (operationPropertyName)
                {
                    case JsonConstants.ODataOperationTitleName:
                        if (operation.Title != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string titleString = readerContext.JsonReader.ReadStringValue(JsonConstants.ODataOperationTitleName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(titleString, operationPropertyName, metadataReferencePropertyName);
                        operation.Title = titleString;
                        break;

                    case JsonConstants.ODataOperationTargetName:
                        if (operation.Target != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string targetString = readerContext.JsonReader.ReadStringValue(JsonConstants.ODataOperationTargetName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(targetString, operationPropertyName, metadataReferencePropertyName);
                        operation.Target = readerContext.ProcessUriFromPayload(targetString);
                        break;

                    default:
                        // skip over all unknown properties and read the next property or
                        // the end of the metadata for the current propertyName
                        readerContext.JsonReader.SkipValue();
                        break;
                }
            }

            if (operation.Target == null && insideArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OperationMissingTargetProperty(metadataReferencePropertyName));
            }

            // read the end-object node of the target / title pair
            readerContext.JsonReader.ReadEndObject();

            // Sets the metadata builder to evaluate by convention any operation property that's not on the wire.
            // Note we must only set this after the operation is read from the wire since we lose the ability to tell
            // what was on the wire and what is being dynamically computed.
            this.SetMetadataBuilder(resourceState, operation);
        }

        /// <summary>
        /// Reads one operation for the resource set being read.
        /// </summary>
        /// <param name="resourceSet">The resource set to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <param name="insideArray">true if the operation value is inside an array, i.e. multiple targets for the operation; false otherwise.</param>
        private void ReadSingleOperationValue(ODataResourceSet resourceSet, string metadataReferencePropertyName, bool insideArray)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(ODataJsonLightUtils.IsMetadataReferenceProperty(metadataReferencePropertyName), "ODataJsonLightReaderUtils.IsMetadataReferenceProperty(metadataReferencePropertyName)");

            if (this.JsonReader.NodeType != JsonNodeType.StartObject)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonOperationsDeserializerUtils_OperationsPropertyMustHaveObjectValue(metadataReferencePropertyName, this.JsonReader.NodeType));
            }

            // read over the start-object node of the metadata object for the operations
            this.JsonReader.ReadStartObject();

            var operation = this.CreateODataOperationAndAddToResourceSet(resourceSet, metadataReferencePropertyName);

            // Ignore the unrecognized operation.
            if (operation == null)
            {
                while (this.JsonReader.NodeType == JsonNodeType.Property)
                {
                    this.JsonReader.ReadPropertyName();
                    this.JsonReader.SkipValue();
                }

                this.JsonReader.ReadEndObject();
                return;
            }

            Debug.Assert(operation.Metadata != null, "operation.Metadata != null");

            while (this.JsonReader.NodeType == JsonNodeType.Property)
            {
                string operationPropertyName = ODataAnnotationNames.RemoveAnnotationPrefix(this.JsonReader.ReadPropertyName());
                switch (operationPropertyName)
                {
                    case JsonConstants.ODataOperationTitleName:
                        if (operation.Title != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string titleString = this.JsonReader.ReadStringValue(JsonConstants.ODataOperationTitleName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(titleString, operationPropertyName, metadataReferencePropertyName);
                        operation.Title = titleString;
                        break;

                    case JsonConstants.ODataOperationTargetName:
                        if (operation.Target != null)
                        {
                            throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MultipleOptionalPropertiesInOperation(operationPropertyName, metadataReferencePropertyName));
                        }

                        string targetString = this.JsonReader.ReadStringValue(JsonConstants.ODataOperationTargetName);
                        ODataJsonLightValidationUtils.ValidateOperationPropertyValueIsNotNull(targetString, operationPropertyName, metadataReferencePropertyName);
                        operation.Target = this.ProcessUriFromPayload(targetString);
                        break;

                    default:
                        // skip over all unknown properties and read the next property or
                        // the end of the metadata for the current propertyName
                        this.JsonReader.SkipValue();
                        break;
                }
            }

            if (operation.Target == null && insideArray)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_OperationMissingTargetProperty(metadataReferencePropertyName));
            }

            // read the end-object node of the target / title pair
            this.JsonReader.ReadEndObject();
        }

        /// <summary>
        /// Sets the metadata builder for the operation.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="operation">The operation to set the metadata builder on.</param>
        private void SetMetadataBuilder(IODataJsonLightReaderResourceState resourceState, ODataOperation operation)
        {
            ODataResourceMetadataBuilder builder =
                this.MetadataContext.GetResourceMetadataBuilderForReader(resourceState,
                    this.JsonLightInputContext.ODataSimplifiedOptions.EnableReadingKeyAsSegment,
                    /*isDelta*/ false);
            operation.SetMetadataBuilder(builder, this.ContextUriParseResult.MetadataDocumentUri);
        }

        /// <summary>
        /// Creates a new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.
        /// </summary>
        /// <param name="readerContext">The Json operation deserializer context.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <returns>A new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.</returns>
        private ODataOperation CreateODataOperationAndAddToEntry(IODataJsonOperationsDeserializerContext readerContext, string metadataReferencePropertyName)
        {
            string fullyQualifiedOperationName = ODataJsonLightUtils.GetUriFragmentFromMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);
            IEdmOperation firstActionOrFunction = this.JsonLightInputContext.Model.ResolveOperations(fullyQualifiedOperationName).FirstOrDefault();

            bool isAction;

            if (firstActionOrFunction == null)
            {
                // Ignore the unknown function/action.
                return null;
            }

            var operation = ODataJsonLightUtils.CreateODataOperation(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName, firstActionOrFunction, out isAction);

            if (isAction)
            {
                readerContext.AddActionToResource((ODataAction)operation);
            }
            else
            {
                readerContext.AddFunctionToResource((ODataFunction)operation);
            }

            return operation;
        }

        /// <summary>
        /// Creates a new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.
        /// </summary>
        /// <param name="resourceSet">The resource set to add the action or function .</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <returns>A new instance of ODataAction or ODataFunction for the <paramref name="metadataReferencePropertyName"/>.</returns>
        private ODataOperation CreateODataOperationAndAddToResourceSet(ODataResourceSet resourceSet, string metadataReferencePropertyName)
        {
            string fullyQualifiedOperationName = ODataJsonLightUtils.GetUriFragmentFromMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);
            IEdmOperation firstActionOrFunction = this.JsonLightInputContext.Model.ResolveOperations(fullyQualifiedOperationName).FirstOrDefault();

            bool isAction;

            if (firstActionOrFunction == null)
            {
                // Ignore the unknown function/action.
                return null;
            }

            var operation = ODataJsonLightUtils.CreateODataOperation(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName, firstActionOrFunction, out isAction);

            if (isAction)
            {
                resourceSet.AddAction((ODataAction)operation);
            }
            else
            {
                resourceSet.AddFunction((ODataFunction)operation);
            }

            return operation;
        }

        /// <summary>
        /// Read the metadata reference property value for the resource being read.
        /// </summary>
        /// <param name="resourceState">The state of the reader for resource to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        /// <remarks>
        /// Pre-Condition:  JsonNodeType.Property:      first node of the metadata reference property's value. Currently
        ///                                             actions and functions are the only supported metadata reference property,
        ///                                             we will throw if this is not a start object or start array node.
        /// Post-Condition: JsonNodeType.Property:      the property after the annotation value
        ///                 JsonNodeType.EndObject:     the end-object of the resource
        /// </remarks>
        private void ReadMetadataReferencePropertyValue(IODataJsonLightReaderResourceState resourceState, string metadataReferencePropertyName)
        {
            Debug.Assert(resourceState != null, "resourceState != null");
            Debug.Assert(resourceState.Resource != null, "resourceState.Resource != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(metadataReferencePropertyName.IndexOf(ODataConstants.ContextUriFragmentIndicator) > -1, "metadataReferencePropertyName.IndexOf(JsonLightConstants.ContextUriFragmentIndicator) > -1");
            this.JsonReader.AssertNotBuffering();

            this.ValidateCanReadMetadataReferenceProperty();

            // Validate that the property name is a valid absolute URI or a valid URI fragment.
            ODataJsonLightValidationUtils.ValidateMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);

            IODataJsonOperationsDeserializerContext readerContext = new OperationsDeserializerContext(resourceState.Resource, this);

            bool insideArray = false;
            if (readerContext.JsonReader.NodeType == JsonNodeType.StartArray)
            {
                readerContext.JsonReader.ReadStartArray();
                insideArray = true;
            }

            do
            {
                this.ReadSingleOperationValue(readerContext, resourceState, metadataReferencePropertyName, insideArray);
            }
            while (insideArray && readerContext.JsonReader.NodeType != JsonNodeType.EndArray);

            if (insideArray)
            {
                readerContext.JsonReader.ReadEndArray();
            }

            this.JsonReader.AssertNotBuffering();
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Read the metadata reference property value for the resource set being read.
        /// </summary>
        /// <param name="resourceSet">The resource set to read.</param>
        /// <param name="metadataReferencePropertyName">The name of the metadata reference property being read.</param>
        private void ReadMetadataReferencePropertyValue(ODataResourceSet resourceSet, string metadataReferencePropertyName)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(!string.IsNullOrEmpty(metadataReferencePropertyName), "!string.IsNullOrEmpty(metadataReferencePropertyName)");
            Debug.Assert(metadataReferencePropertyName.IndexOf(ODataConstants.ContextUriFragmentIndicator) > -1, "metadataReferencePropertyName.IndexOf(JsonLightConstants.ContextUriFragmentIndicator) > -1");
            this.JsonReader.AssertNotBuffering();

            this.ValidateCanReadMetadataReferenceProperty();

            // Validate that the property name is a valid absolute URI or a valid URI fragment.
            ODataJsonLightValidationUtils.ValidateMetadataReferencePropertyName(this.ContextUriParseResult.MetadataDocumentUri, metadataReferencePropertyName);

            bool insideArray = false;
            if (this.JsonReader.NodeType == JsonNodeType.StartArray)
            {
                this.JsonReader.ReadStartArray();
                insideArray = true;
            }

            do
            {
                this.ReadSingleOperationValue(resourceSet, metadataReferencePropertyName, insideArray);
            }
            while (insideArray && this.JsonReader.NodeType != JsonNodeType.EndArray);

            if (insideArray)
            {
                this.JsonReader.ReadEndArray();
            }

            this.JsonReader.AssertNotBuffering();
            this.AssertJsonCondition(JsonNodeType.Property, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Validates that we can read metadata reference property.
        /// </summary>
        private void ValidateCanReadMetadataReferenceProperty()
        {
            if (!this.ReadingResponse)
            {
                throw new ODataException(ODataErrorStrings.ODataJsonLightResourceDeserializer_MetadataReferencePropertyInRequest);
            }
        }

        /// <summary>
        /// Operations deserializer context to pass to JSON operations reader.
        /// </summary>
        private sealed class OperationsDeserializerContext : IODataJsonOperationsDeserializerContext
        {
            /// <summary>
            /// The resource to add operations to.
            /// </summary>
            private ODataResourceBase resource;

            /// <summary>
            /// The deserializer to use.
            /// </summary>
            private ODataJsonLightResourceDeserializer jsonLightResourceDeserializer;

            /// <summary>
            /// Constructor.
            /// </summary>
            /// <param name="resource">The resource to add operations to.</param>
            /// <param name="jsonLightResourceDeserializer">The deserializer to use.</param>
            public OperationsDeserializerContext(ODataResourceBase resource, ODataJsonLightResourceDeserializer jsonLightResourceDeserializer)
            {
                Debug.Assert(resource != null, "resource != null");
                Debug.Assert(jsonLightResourceDeserializer != null, "jsonLightResourceDeserializer != null");

                this.resource = resource;
                this.jsonLightResourceDeserializer = jsonLightResourceDeserializer;
            }

            /// <summary>
            /// The JSON reader to read the operations value from.
            /// </summary>
            public IJsonReader JsonReader
            {
                get
                {
                    return this.jsonLightResourceDeserializer.JsonReader;
                }
            }

            /// <summary>
            /// Given a URI from the payload, this method will try to make it absolute, or fail otherwise.
            /// </summary>
            /// <param name="uriFromPayload">The URI string from the payload to process.</param>
            /// <returns>An absolute URI to report.</returns>
            public Uri ProcessUriFromPayload(string uriFromPayload)
            {
                return this.jsonLightResourceDeserializer.ProcessUriFromPayload(uriFromPayload);
            }

            /// <summary>
            /// Adds the specified action to the current resource.
            /// </summary>
            /// <param name="action">The action which is fully populated with the data from the payload.</param>
            public void AddActionToResource(ODataAction action)
            {
                Debug.Assert(action != null, "action != null");
                this.resource.AddAction(action);
            }

            /// <summary>
            /// Adds the specified function to the current resource.
            /// </summary>
            /// <param name="function">The function which is fully populated with the data from the payload.</param>
            public void AddFunctionToResource(ODataFunction function)
            {
                Debug.Assert(function != null, "function != null");
                this.resource.AddFunction(function);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs(14,5): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs(16,5): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs(1226,71): error CS0165: Use of unassigned local variable 'structuralProperty',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs(14,5): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightResourceDeserializer.cs(16,5): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.OData.Edm;
using Microsoft.OData.Evaluation;
using Microsoft.OData.Metadata;
using Microsoft.OData.Json;

namespace Microsoft.OData.JsonLight
{
    /// <summary>
    /// Implementation of the ODataWriter for the JsonLight format.
    /// </summary>
    internal sealed class ODataJsonLightWriter : ODataWriterCore
    {
        /// <summary>
        /// The output context to write to.
        /// </summary>
        private readonly ODataJsonLightOutputContext jsonLightOutputContext;

        /// <summary>
        /// The JsonLight resource and resource set serializer to use.
        /// </summary>
        private readonly ODataJsonLightResourceSerializer jsonLightResourceSerializer;

        /// <summary>
        /// The JsonLight value serializer to use for primitive values in an untyped collection.
        /// </summary>
        private readonly ODataJsonLightValueSerializer jsonLightValueSerializer;

        /// <summary>
        /// The JsonLight property serializer.
        /// </summary>
        private readonly ODataJsonLightPropertySerializer jsonLightPropertySerializer;

        /// <summary>
        /// True if the writer was created for writing a parameter; false otherwise.
        /// </summary>
        private readonly bool writingParameter;

        /// <summary>
        /// The underlying JSON writer.
        /// </summary>
        private readonly IJsonWriter jsonWriter;

        /// <summary>
        /// The underlying JSON writer.
        /// </summary>
        private readonly IJsonStreamWriter jsonStreamWriter;

        /// <summary>
        /// OData annotation writer.
        /// </summary>
        private readonly JsonLightODataAnnotationWriter odataAnnotationWriter;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightOutputContext">The output context to write to.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="writingResourceSet">true if the writer is created for writing a resource set; false when it is created for writing a resource.</param>
        /// <param name="writingParameter">true if the writer is created for writing a parameter; false otherwise.</param>
        /// <param name="writingDelta">True if the writer is created for writing delta payload; false otherwise.</param>
        /// <param name="listener">If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</param>
        internal ODataJsonLightWriter(
            ODataJsonLightOutputContext jsonLightOutputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool writingResourceSet,
            bool writingParameter = false,
            bool writingDelta = false,
            IODataReaderWriterListener listener = null)
            : base(jsonLightOutputContext, navigationSource, resourceType, writingResourceSet, writingDelta, listener)
        {
            Debug.Assert(jsonLightOutputContext != null, "jsonLightOutputContext != null");

            this.jsonLightOutputContext = jsonLightOutputContext;
            this.jsonLightResourceSerializer = new ODataJsonLightResourceSerializer(this.jsonLightOutputContext);
            this.jsonLightValueSerializer = new ODataJsonLightValueSerializer(this.jsonLightOutputContext);
            this.jsonLightPropertySerializer = new ODataJsonLightPropertySerializer(this.jsonLightOutputContext);

            this.writingParameter = writingParameter;
            this.jsonWriter = this.jsonLightOutputContext.JsonWriter;
            this.jsonStreamWriter = this.jsonWriter as IJsonStreamWriter;
            this.odataAnnotationWriter = new JsonLightODataAnnotationWriter(this.jsonWriter,
                this.jsonLightOutputContext.OmitODataPrefix, this.jsonLightOutputContext.MessageWriterSettings.Version);
        }

        /// <summary>
        /// Returns the current JsonLightResourceScope.
        /// </summary>
        private JsonLightResourceScope CurrentResourceScope
        {
            get
            {
                JsonLightResourceScope currentJsonLightResourceScope = this.CurrentScope as JsonLightResourceScope;
                Debug.Assert(currentJsonLightResourceScope != null, "Asking for JsonLightResourceScope when the current scope is not an JsonLightResourceScope.");
                return currentJsonLightResourceScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeletedResourceScope.
        /// </summary>
        private JsonLightDeletedResourceScope CurrentDeletedResourceScope
        {
            get
            {
                JsonLightDeletedResourceScope currentJsonLightDeletedResourceScope = this.CurrentScope as JsonLightDeletedResourceScope;
                Debug.Assert(currentJsonLightDeletedResourceScope != null, "Asking for JsonLightResourceScope when the current scope is not an JsonLightResourceScope.");
                return currentJsonLightDeletedResourceScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeltaLinkScope.
        /// </summary>
        private JsonLightDeltaLinkScope CurrentDeltaLinkScope
        {
            get
            {
                JsonLightDeltaLinkScope jsonLightDeltaLinkScope = this.CurrentScope as JsonLightDeltaLinkScope;
                Debug.Assert(jsonLightDeltaLinkScope != null, "Asking for JsonLightDeltaLinkScope when the current scope is not an JsonLightDeltaLinkScope.");
                return jsonLightDeltaLinkScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightResourceSetScope.
        /// </summary>
        private JsonLightResourceSetScope CurrentResourceSetScope
        {
            get
            {
                JsonLightResourceSetScope currentJsonLightResourceSetScope = this.CurrentScope as JsonLightResourceSetScope;
                Debug.Assert(currentJsonLightResourceSetScope != null, "Asking for JsonResourceSetScope when the current scope is not a JsonResourceSetScope.");
                return currentJsonLightResourceSetScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeltaResourceSetScope.
        /// </summary>
        private JsonLightDeltaResourceSetScope CurrentDeltaResourceSetScope
        {
            get
            {
                JsonLightDeltaResourceSetScope currentJsonLightDeltaResourceSetScope = this.CurrentScope as JsonLightDeltaResourceSetScope;
                Debug.Assert(currentJsonLightDeltaResourceSetScope != null, "Asking for JsonDeltaResourceSetScope when the current scope is not a JsonDeltaResourceSetScope.");
                return currentJsonLightDeltaResourceSetScope;
            }
        }

        /// <summary>
        /// Check if the object has been disposed; called from all public API methods. Throws an ObjectDisposedException if the object
        /// has already been disposed.
        /// </summary>
        protected override void VerifyNotDisposed()
        {
            this.jsonLightOutputContext.VerifyNotDisposed();
        }

        /// <summary>
        /// Flush the output.
        /// </summary>
        protected override void FlushSynchronously()
        {
            this.jsonLightOutputContext.Flush();
        }

        /// <summary>
        /// Flush the output.
        /// </summary>
        /// <returns>Task representing the pending flush operation.</returns>
        protected override Task FlushAsynchronously()
        {
            return this.jsonLightOutputContext.FlushAsync();
        }

        /// <summary>
        /// Starts writing a payload (called exactly once before anything else)
        /// </summary>
        protected override void StartPayload()
        {
            this.jsonLightResourceSerializer.WritePayloadStart();
        }

        /// <summary>
        /// Ends writing a payload (called exactly once after everything else in case of success)
        /// </summary>
        protected override void EndPayload()
        {
            this.jsonLightResourceSerializer.WritePayloadEnd();
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="resource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected override void PrepareResourceForWriteStart(ResourceScope resourceScope, ODataResource resource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            var typeContext = resourceScope.GetOrCreateTypeContext(writingResponse);
            if (this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel)
            {
                // 1. NoMetadata level: always enable its NullResourceMetadataBuilder
                InnerPrepareResourceForWriteStart(resource, typeContext, selectedProperties);
            }
            else
            {
                // 2. Minimal/Full Metadata level: Use ODataConventionalEntityMetadataBuilder for entity, ODataConventionalResourceMetadataBuilder for other cases.
                if (this.jsonLightOutputContext.Model.IsUserModel() || resourceScope.SerializationInfo != null)
                {
                    InnerPrepareResourceForWriteStart(resource, typeContext, selectedProperties);
                }

                // 3. Here fallback to the default NoOpResourceMetadataBuilder, when model and serializationInfo are both null.
            }
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the deleted resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="deletedResource">Deleted resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected override void PrepareDeletedResourceForWriteStart(DeletedResourceScope resourceScope, ODataDeletedResource deletedResource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            if (this.jsonLightOutputContext.MessageWriterSettings.Version > ODataVersion.V4)
            {
                // If:
                //      1. Minimal/Full Metadata level: Use ODataConventionalEntityMetadataBuilder for entity, ODataConventionalResourceMetadataBuilder for other cases.
                //      2. NoMetadata level: always enable its NullResourceMetadataBuilder
                // otherwise:
                //      3. Fallback to the default NoOpResourceMetadataBuilder, when model and serializationInfo are both null.
                if (this.jsonLightOutputContext.Model.IsUserModel() || resourceScope.SerializationInfo != null || this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel)
                {
                    var typeContext = resourceScope.GetOrCreateTypeContext(writingResponse);
                    InnerPrepareResourceForWriteStart(deletedResource, typeContext, selectedProperties);
                }
            }
            else if (deletedResource.Id == null && this.jsonLightOutputContext.Model.IsUserModel())
            {
                // Create an instance of the conventional UriBuilder and build id from key values
                IEdmEntityType entityType = resourceScope.ResourceType as IEdmEntityType;
                if (deletedResource.SerializationInfo != null)
                {
                    string entityTypeName = deletedResource.SerializationInfo.ExpectedTypeName;
                    if (!String.IsNullOrEmpty(entityTypeName))
                    {
                        entityType = this.jsonLightOutputContext.Model.FindType(entityTypeName) as IEdmEntityType ?? entityType;
                    }
                }

                Debug.Assert(entityType != null, "No entity type specified in resourceScope or serializationInfo.");

                ODataConventionalUriBuilder uriBuilder = new ODataConventionalUriBuilder(
                    new Uri(this.jsonLightOutputContext.MessageWriterSettings.MetadataDocumentUri, "./"),
                    this.jsonLightOutputContext.ODataSimplifiedOptions.EnableWritingKeyAsSegment ? ODataUrlKeyDelimiter.Slash : ODataUrlKeyDelimiter.Parentheses
                    );

                Uri uri = uriBuilder.BuildBaseUri();
                uri = uriBuilder.BuildEntitySetUri(uri, resourceScope.NavigationSource.Name);
                uri = uriBuilder.BuildEntityInstanceUri(uri, ComputeKeyProperties(deletedResource, entityType, this.jsonLightOutputContext.Model), entityType.FullTypeName());

                deletedResource.Id = uri;
            }
        }

        internal static ICollection<KeyValuePair<string, object>> ComputeKeyProperties(ODataDeletedResource resource, IEdmEntityType entityType, IEdmModel model)
        {
            Debug.Assert(entityType.Key().Any(), "actual entity type has no keys defined");

            ICollection<KeyValuePair<string, object>> computedKeyProperties = new List<KeyValuePair<string, object>>();
            foreach (IEdmStructuralProperty edmKeyProperty in entityType.Key())
            {
                foreach(ODataProperty property in resource.NonComputedProperties)
                {
                    if (property.Name == edmKeyProperty.Name)
                    {
                        object newValue = model.ConvertToUnderlyingTypeIfUIntValue(property.Value);
                        computedKeyProperties.Add(new KeyValuePair<string, object>(edmKeyProperty.Name, newValue));
                        break;
                    }
                }
            }

            return computedKeyProperties;
        }

        /// <summary>
        /// Start writing a property.
        /// </summary>
        /// <param name="property">The property info to write.</param>
        protected override void StartProperty(ODataPropertyInfo property)
        {
            ResourceBaseScope scope = this.ParentScope as ResourceBaseScope;
            Debug.Assert(scope != null, "Writing a property and the parent scope is not a resource");
            ODataResource resource = scope.Item as ODataResource;
            Debug.Assert(resource?.MetadataBuilder != null, "Writing a property with no parent resource MetadataBuilder");

            ODataProperty propertyWithValue = property as ODataProperty;
            if (propertyWithValue != null)
            {
                this.jsonLightPropertySerializer.WriteProperty(
                propertyWithValue,
                scope.ResourceType,
                false /*isTopLevel*/,
                this.DuplicatePropertyNameChecker,
                resource.MetadataBuilder);
            }
            else
            {
                this.jsonLightPropertySerializer.WritePropertyInfo(
                property,
                scope.ResourceType,
                false /*isTopLevel*/,
                this.DuplicatePropertyNameChecker,
                resource.MetadataBuilder);
            }
        }

        /// <summary>
        /// End writing a property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected override void EndProperty(ODataPropertyInfo property)
        {
            // nothing to do
        }

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void StartResource(ODataResource resource)
        {
            ODataNestedResourceInfo parentNavLink = this.ParentNestedResourceInfo;
            if (parentNavLink != null)
            {
                // For a null value, write the type as a property annotation
                if (resource == null)
                {
                    if (parentNavLink.TypeAnnotation != null && parentNavLink.TypeAnnotation.TypeName != null)
                    {
                        this.jsonLightResourceSerializer.ODataAnnotationWriter.WriteODataTypePropertyAnnotation(parentNavLink.Name, parentNavLink.TypeAnnotation.TypeName);
                    }

                    this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(parentNavLink.GetInstanceAnnotations(), parentNavLink.Name);
                }

                // Write the property name of an expanded navigation property to start the value.
                this.jsonWriter.WriteName(parentNavLink.Name);
            }

            if (resource == null)
            {
                this.jsonWriter.WriteValue((string)null);
                return;
            }

            // Write just the object start, nothing else, since we might not have complete information yet
            this.jsonWriter.StartObjectScope();

            JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            if (this.IsTopLevel && !(this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
            {
                var contextUriInfo = this.jsonLightResourceSerializer.WriteResourceContextUri(
                        resourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse));

                // Is writing an undeclared resource.
                if (contextUriInfo != null)
                {
                    resourceScope.IsUndeclared = contextUriInfo.IsUndeclared.HasValue && contextUriInfo.IsUndeclared.Value;
                }
            }
            else if (this.ParentScope.State == WriterState.DeltaResourceSet && this.ScopeLevel == 3)
            {
                DeltaResourceSetScope deltaResourceSetScope = this.ParentScope as DeltaResourceSetScope;
                Debug.Assert(deltaResourceSetScope != null, "Writing child of delta set and parent scope is not DeltaResourceSetScope");

                string expectedNavigationSource =
                    deltaResourceSetScope.NavigationSource == null ? null : deltaResourceSetScope.NavigationSource.Name;
                string currentNavigationSource =
                    resource.SerializationInfo != null ? resource.SerializationInfo.NavigationSourceName :
                    resourceScope.NavigationSource == null ? null : resourceScope.NavigationSource.Name;

                if (String.IsNullOrEmpty(currentNavigationSource) || currentNavigationSource != expectedNavigationSource)
                {
                    this.jsonLightResourceSerializer.WriteDeltaContextUri(
                        this.CurrentResourceScope.GetOrCreateTypeContext(true), ODataDeltaKind.Resource,
                        deltaResourceSetScope.ContextUriInfo);
                }
            }

            // Write the metadata
            this.jsonLightResourceSerializer.WriteResourceStartMetadataProperties(resourceScope);
            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            this.jsonLightOutputContext.PropertyCacheHandler.SetCurrentResourceScopeLevel(this.ScopeLevel);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            if (resource.NonComputedProperties != null)
            {
                this.jsonLightResourceSerializer.WriteProperties(
                    this.ResourceType,
                    resource.NonComputedProperties,
                    false /* isComplexValue */,
                    this.DuplicatePropertyNameChecker,
                    resource.MetadataBuilder);
                this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            }

            // COMPAT 48: Position of navigation properties/links in JSON differs.
        }

        /// <summary>
        /// Finish writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void EndResource(ODataResource resource)
        {
            if (resource == null)
            {
                return;
            }

            // Get the projected properties
            JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.WriteResourceEndMetadataProperties(resourceScope, resourceScope.DuplicatePropertyNameChecker);

            // Close the object scope
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Finish writing a deleted resource.
        /// </summary>
        /// <param name="deletedResource">The resource to write.</param>
        protected override void EndDeletedResource(ODataDeletedResource deletedResource)
        {
            if (deletedResource == null)
            {
                return;
            }

            // Get the projected properties
            // JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            // this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            // Write custom instance annotations
            // this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deletedResource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            // this.jsonLightResourceSerializer.WriteResourceEndMetadataProperties(resourceScope, resourceScope.DuplicatePropertyNameChecker);

            // Close the object scope
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Start writing a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        protected override void StartResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null && (this.writingParameter || this.ParentScope.State == WriterState.ResourceSet))
            {
                // Start array which will hold the entries in the resource set.
                this.jsonWriter.StartArrayScope();
            }
            else if (this.ParentNestedResourceInfo == null)
            {
                // Top-level resource set.
                // "{"
                this.jsonWriter.StartObjectScope();

                // @odata.context
                this.jsonLightResourceSerializer.WriteResourceSetContextUri(this.CurrentResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse));

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // write "odata.actions" metadata
                    IEnumerable<ODataAction> actions = resourceSet.Actions;
                    if (actions != null && actions.Any())
                    {
                        this.jsonLightResourceSerializer.WriteOperations(actions.Cast<ODataOperation>(), /*isAction*/ true);
                    }

                    // write "odata.functions" metadata
                    IEnumerable<ODataFunction> functions = resourceSet.Functions;
                    if (functions != null && functions.Any())
                    {
                        this.jsonLightResourceSerializer.WriteOperations(functions.Cast<ODataOperation>(), /*isAction*/ false);
                    }

                    // Write the inline count if it's available.
                    this.WriteResourceSetCount(resourceSet.Count, /*propertyName*/null);

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, /*propertyName*/null);

                    // Write the delta link if it's available.
                    this.WriteResourceSetDeltaLink(resourceSet.DeltaLink);
                }

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resourceSet.InstanceAnnotations, this.CurrentResourceSetScope.InstanceAnnotationWriteTracker);

                // "value":
                this.jsonWriter.WriteValuePropertyName();

                // Start array which will hold the entries in the resource set.
                this.jsonWriter.StartArrayScope();
            }
            else
            {
                // Expanded resource set.
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value),
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");

                this.ValidateNoDeltaLinkForExpandedResourceSet(resourceSet);
                this.ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(resourceSet);

                string propertyName = this.ParentNestedResourceInfo.Name;
                bool isUndeclared = (this.CurrentScope as JsonLightResourceSetScope).IsUndeclared;
                var expectedResourceTypeName =
                    this.CurrentResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse)
                    .ExpectedResourceTypeName;

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // Write the inline count if it's available.
                    this.WriteResourceSetCount(resourceSet.Count, propertyName);

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, propertyName);

                    // Write the odata type.
                    this.jsonLightResourceSerializer.WriteResourceSetStartMetadataProperties(resourceSet, propertyName, expectedResourceTypeName, isUndeclared);

                    // And then write the property name to start the value.
                    this.jsonWriter.WriteName(propertyName);

                    // Start array which will hold the entries in the resource set.
                    this.jsonWriter.StartArrayScope();
                }
                else
                {
                    JsonLightNestedResourceInfoScope navigationLinkScope = (JsonLightNestedResourceInfoScope)this.ParentNestedResourceInfoScope;
                    if (!navigationLinkScope.ResourceSetWritten)
                    {
                        // Close the entity reference link array (if written)
                        if (navigationLinkScope.EntityReferenceLinkWritten)
                        {
                            this.jsonWriter.EndArrayScope();
                        }

                        // Write the odata type.
                        this.jsonLightResourceSerializer.WriteResourceSetStartMetadataProperties(resourceSet, propertyName, expectedResourceTypeName, isUndeclared);

                        // And then write the property name to start the value.
                        this.jsonWriter.WriteName(propertyName);

                        // Start array which will hold the entries in the resource set.
                        this.jsonWriter.StartArrayScope();

                        navigationLinkScope.ResourceSetWritten = true;
                    }
                }
            }

            this.jsonLightOutputContext.PropertyCacheHandler.EnterResourceSetScope(this.CurrentResourceSetScope.ResourceType, this.ScopeLevel);
        }

        /// <summary>
        /// Finish writing a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        protected override void EndResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null && (this.writingParameter || this.ParentScope.State == WriterState.ResourceSet))
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();
            }
            else if (this.ParentNestedResourceInfo == null)
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resourceSet.InstanceAnnotations, this.CurrentResourceSetScope.InstanceAnnotationWriteTracker);

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, /*propertyName*/null);

                    // Write the delta link if it's available.
                    this.WriteResourceSetDeltaLink(resourceSet.DeltaLink);
                }

                // Close the object wrapper.
                this.jsonWriter.EndObjectScope();
            }
            else
            {
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value),
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");
                string propertyName = this.ParentNestedResourceInfo.Name;

                this.ValidateNoDeltaLinkForExpandedResourceSet(resourceSet);
                this.ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(resourceSet);

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // End the array which holds the entries in the resource set.
                    // NOTE: in requests we will only write the EndArray of a resource set
                    //       when we hit the nested resource info end since a nested resource info
                    //       can contain multiple resource sets that get collapsed into a single array value.
                    this.jsonWriter.EndArrayScope();

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, propertyName);
                }
            }

            this.jsonLightOutputContext.PropertyCacheHandler.LeaveResourceSetScope();
        }

        /// <summary>
        /// Start writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected override void StartDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            Debug.Assert(deltaResourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null)
            {
                this.jsonWriter.StartObjectScope();

                // Write ContextUrl
                this.CurrentDeltaResourceSetScope.ContextUriInfo = this.jsonLightResourceSerializer.WriteDeltaContextUri(
                    this.CurrentDeltaResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                    ODataDeltaKind.ResourceSet);

                // Write Count, if available
                this.WriteResourceSetCount(deltaResourceSet.Count, /*propertyname*/ null);

                // Write NextLink, if available
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, /*propertyname*/ null);

                // If we haven't written the delta link yet and it's available, write it.
                this.WriteResourceSetDeltaLink(deltaResourceSet.DeltaLink);

                // Write annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deltaResourceSet.InstanceAnnotations, this.CurrentDeltaResourceSetScope.InstanceAnnotationWriteTracker);

                // Write Value Start
                this.jsonWriter.WriteValuePropertyName();
                this.jsonWriter.StartArrayScope();
            }
            else
            {
                // Nested Delta
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && this.ParentNestedResourceInfo.IsCollection.HasValue && this.ParentNestedResourceInfo.IsCollection.Value,
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");

                string propertyName = this.ParentNestedResourceInfo.Name;

                // Write the inline count if it's available.
                this.WriteResourceSetCount(deltaResourceSet.Count, propertyName);

                // Write the next link if it's available.
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, propertyName);

                //// Write the name for the nested delta payload
                this.jsonWriter.WritePropertyAnnotationName(propertyName, JsonLightConstants.ODataDeltaPropertyName);

                // Start array which will hold the entries in the nested delta resource set.
                this.jsonWriter.StartArrayScope();
            }
        }

        /// <summary>
        /// Finish writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The resource set to write.</param>
        protected override void EndDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            Debug.Assert(deltaResourceSet != null, "deltaResourceSet != null");

            if (this.ParentNestedResourceInfo == null)
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deltaResourceSet.InstanceAnnotations, this.CurrentDeltaResourceSetScope.InstanceAnnotationWriteTracker);

                // Write the next link if it's available.
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, /*propertynamne*/ null);

                // Write the delta link if it's available.
                this.WriteResourceSetDeltaLink(deltaResourceSet.DeltaLink);

                // Close the object wrapper.
                this.jsonWriter.EndObjectScope();
            }
            else
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();
            }
        }

        /// <summary>
        /// Start writing a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void StartDeletedResource(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");
            Debug.Assert(!this.IsTopLevel, "Delta resource cannot be on top level.");
            DeletedResourceScope resourceScope = this.CurrentDeletedResourceScope;
            Debug.Assert(resourceScope != null, "Writing deleted entry and scope is not DeltaResourceScope");
            ODataNestedResourceInfo parentNavLink = this.ParentNestedResourceInfo;
            if (parentNavLink != null)
            {
                // Writing a nested deleted resource
                if (this.Version == null || this.Version < ODataVersion.V401)
                {
                    throw new ODataException(Strings.ODataWriterCore_NestedContentNotAllowedIn40DeletedEntry);
                }
                else
                {
                    // Write the property name of an expanded navigation property to start the value.
                    this.jsonWriter.WriteName(parentNavLink.Name);
                    this.jsonWriter.StartObjectScope();
                    this.WriteDeletedEntryContents(resource);
                }
            }
            else
            {
                // Writing a deleted resource within an entity set
                DeltaResourceSetScope deltaResourceSetScope = this.ParentScope as DeltaResourceSetScope;
                Debug.Assert(deltaResourceSetScope != null, "Writing child of delta set and parent scope is not DeltaResourceSetScope");

                this.jsonWriter.StartObjectScope();

                if (this.Version == null || this.Version < ODataVersion.V401)
                {
                    // Write ContextUrl
                    this.jsonLightResourceSerializer.WriteDeltaContextUri(
                            this.CurrentDeletedResourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                            ODataDeltaKind.DeletedEntry, deltaResourceSetScope.ContextUriInfo);
                    this.WriteV4DeletedEntryContents(resource);
                }
                else
                {
                    // Only write ContextUrl for V4.01 deleted resource if it is in a top level delta
                    // resource set and comes from a different entity set
                    string expectedNavigationSource =
                        deltaResourceSetScope.NavigationSource == null ? null : deltaResourceSetScope.NavigationSource.Name;
                    string currentNavigationSource =
                        resource.SerializationInfo != null ? resource.SerializationInfo.NavigationSourceName :
                        resourceScope.NavigationSource == null ? null : resourceScope.NavigationSource.Name;

                    if (String.IsNullOrEmpty(currentNavigationSource) || currentNavigationSource != expectedNavigationSource)
                    {
                        Debug.Assert(this.ScopeLevel == 3, "Writing a nested deleted resource of the wrong type should already have been caught.");

                        // We are writing a deleted resource in a top level delta resource set
                        // from a different entity set, so include the context Url
                        this.jsonLightResourceSerializer.WriteDeltaContextUri(
                                this.CurrentDeletedResourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                                ODataDeltaKind.DeletedEntry, deltaResourceSetScope.ContextUriInfo);
                    }

                    this.WriteDeletedEntryContents(resource);
                }
            }
        }

        /// <summary>
        /// Start writing a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write.</param>
        protected override void StartDeltaLink(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");

            this.jsonWriter.StartObjectScope();

            if (link is ODataDeltaLink)
            {
                this.WriteDeltaLinkContextUri(ODataDeltaKind.Link);
            }
            else
            {
                Debug.Assert(link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");
                this.WriteDeltaLinkContextUri(ODataDeltaKind.DeletedLink);
            }

            this.WriteDeltaLinkSource(link);
            this.WriteDeltaLinkRelationship(link);
            this.WriteDeltaLinkTarget(link);
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Write a primitive type inside an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">The primitive value to write.</param>
        protected override void WritePrimitiveValue(ODataPrimitiveValue primitiveValue)
        {
            ODataPropertyInfo property;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                this.jsonWriter.WriteName(property.Name);
            }

            if (primitiveValue == null)
            {
                this.jsonLightValueSerializer.WriteNullValue();
            }
            else
            {
                this.jsonLightValueSerializer.WritePrimitiveValue(primitiveValue.Value, /*expectedType*/ null);
            }
        }

        /// <summary>
        /// Create a stream for writing a binary value.
        /// </summary>
        /// <returns>Stream for writing a binary value.</returns>
        protected override Stream StartBinaryStream()
        {
            ODataPropertyInfo property;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                // writing a stream property - write the property name
                this.jsonWriter.WriteName(property.Name);
                this.jsonWriter.Flush();
            }

            Stream stream;
            if (this.jsonStreamWriter == null)
            {
                this.jsonLightOutputContext.BinaryValueStream = new MemoryStream();
                stream = this.jsonLightOutputContext.BinaryValueStream;
            }
            else
            {
                stream = this.jsonStreamWriter.StartStreamValueScope();
            }

            return stream;
        }

        /// <summary>
        /// Finish writing a stream value.
        /// </summary>
        protected sealed override void EndBinaryStream()
        {
            if (this.jsonStreamWriter == null)
            {
                this.jsonWriter.WriteValue(this.jsonLightOutputContext.BinaryValueStream.ToArray());
                this.jsonLightOutputContext.BinaryValueStream.Flush();
                this.jsonLightOutputContext.BinaryValueStream.Dispose();
                this.jsonLightOutputContext.BinaryValueStream = null;
            }
            else
            {
                this.jsonStreamWriter.EndStreamValueScope();
            }
        }

        /// <summary>
        /// Create a TextWriter for writing a string value.
        /// </summary>
        /// <returns>TextWriter for writing a string value.</returns>
        protected override TextWriter StartTextWriter()
        {
            ODataPropertyInfo property = null;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                // writing a text property - write the property name
                this.jsonWriter.WriteName(property.Name);
                this.jsonWriter.Flush();
            }

            TextWriter writer;
            if (this.jsonStreamWriter == null)
            {
                this.jsonLightOutputContext.StringWriter = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
                writer = this.jsonLightOutputContext.StringWriter;
            }
            else
            {
                string contentType = "text/plain";
                ODataStreamPropertyInfo streamInfo = property as ODataStreamPropertyInfo;
                if (streamInfo?.ContentType != null)
                {
                    contentType = streamInfo.ContentType;
                }

                writer = this.jsonStreamWriter.StartTextWriterValueScope(contentType);
            }

            return writer;
        }

        /// <summary>
        /// Finish writing a text value.
        /// </summary>
        protected sealed override void EndTextWriter()
        {
            if (this.jsonStreamWriter == null)
            {
                Debug.Assert(this.jsonLightOutputContext.StringWriter != null, "Calling EndTextWriter with a non-streaming JsonWriter and a null StringWriter");
                this.jsonLightOutputContext.StringWriter.Flush();
                this.jsonWriter.WriteValue(this.jsonLightOutputContext.StringWriter.GetStringBuilder().ToString());
                this.jsonLightOutputContext.StringWriter.Dispose();
                this.jsonLightOutputContext.StringWriter = null;
            }
            else
            {
                this.jsonStreamWriter.EndTextWriterValueScope();
            }
        }

        /// <summary>
        /// Start writing a deferred (non-expanded) nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void WriteDeferredNestedResourceInfo(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(this.jsonLightOutputContext.WritingResponse, "Deferred links are only supported in response, we should have verified this already.");

            // A deferred nested resource info is just the link metadata, no value.
            this.jsonLightResourceSerializer.WriteNavigationLinkMetadata(nestedResourceInfo, this.DuplicatePropertyNameChecker);
        }

        /// <summary>
        /// Start writing the nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void StartNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(!string.IsNullOrEmpty(nestedResourceInfo.Name), "The nested resource info name should have been verified by now.");

            if (this.jsonLightOutputContext.WritingResponse)
            {
                // Write @odata.context annotation for navigation property
                var containedEntitySet = this.CurrentScope.NavigationSource as IEdmContainedEntitySet;
                if (containedEntitySet != null
                    && this.jsonLightOutputContext.MessageWriterSettings.LibraryCompatibility < ODataLibraryCompatibility.Version7
                    && this.jsonLightOutputContext.MessageWriterSettings.Version < ODataVersion.V401)
                {
                    ODataContextUrlInfo info = ODataContextUrlInfo.Create(
                                                this.CurrentScope.NavigationSource,
                                                this.CurrentScope.ResourceType.FullTypeName(),
                                                containedEntitySet.NavigationProperty.Type.TypeKind() != EdmTypeKind.Collection,
                                                this.CurrentScope.ODataUri,
                                                this.jsonLightOutputContext.MessageWriterSettings.Version ?? ODataVersion.V4);

                    this.jsonLightResourceSerializer.WriteNestedResourceInfoContextUrl(nestedResourceInfo, info);
                }

                // Write the nested resource info metadata first. The rest is written by the content resource or resource set.
                this.jsonLightResourceSerializer.WriteNavigationLinkMetadata(nestedResourceInfo, this.DuplicatePropertyNameChecker);
            }
            else
            {
                this.WriterValidator.ValidateNestedResourceInfoHasCardinality(nestedResourceInfo);
            }
        }

        /// <summary>
        /// Finish writing nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void EndNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            JsonLightNestedResourceInfoScope navigationLinkScope = (JsonLightNestedResourceInfoScope)this.CurrentScope;

            // If we wrote entity reference links for a collection navigation property but no
            // resource set afterwards, we have to now close the array of links.
            if (!this.jsonLightOutputContext.WritingResponse)
            {
                if (navigationLinkScope.EntityReferenceLinkWritten && !navigationLinkScope.ResourceSetWritten && nestedResourceInfo.IsCollection.Value)
                {
                    this.jsonWriter.EndArrayScope();
                }

                // In requests, the nested resource info may have multiple entries in multiple resource sets in it; if we
                // wrote at least one resource set, close the resulting array here.
                if (navigationLinkScope.ResourceSetWritten)
                {
                    Debug.Assert(nestedResourceInfo.IsCollection == null || nestedResourceInfo.IsCollection.Value, "nestedResourceInfo.IsCollection.Value");
                    this.jsonWriter.EndArrayScope();
                }
            }
        }

        /// <summary>
        /// Write an entity reference link.
        /// </summary>
        /// <param name="parentNestedResourceInfo">The parent navigation link which is being written around the entity reference link.</param>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        protected override void WriteEntityReferenceInNavigationLinkContent(ODataNestedResourceInfo parentNestedResourceInfo, ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(parentNestedResourceInfo != null, "parentNestedResourceInfo != null");
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            // In JSON Light, we can only write entity reference links at the beginning of a navigation link in requests;
            // once we wrote a resource set, entity reference links are not allowed anymore (we require all the entity reference
            // link to come first because of the grouping in the JSON Light wire format).
            JsonLightNestedResourceInfoScope nestedResourceScope = this.CurrentScope as JsonLightNestedResourceInfoScope;
            if (nestedResourceScope == null)
            {
                nestedResourceScope = this.ParentNestedResourceInfoScope as JsonLightNestedResourceInfoScope;
            }

            if (nestedResourceScope.ResourceSetWritten)
            {
                throw new ODataException(Strings.ODataJsonLightWriter_EntityReferenceLinkAfterResourceSetInRequest);
            }

            if (!nestedResourceScope.EntityReferenceLinkWritten)
            {
                // In request
                if (!this.jsonLightOutputContext.WritingResponse)
                {
                    if (this.Version == null || this.Version < ODataVersion.V401)
                    {
                        // Write the property annotation for the entity reference link(s)
                        this.odataAnnotationWriter.WritePropertyAnnotationName(parentNestedResourceInfo.Name, ODataAnnotationNames.ODataBind);
                    }
                    else
                    {
                        this.jsonWriter.WriteName(parentNestedResourceInfo.Name);
                    }

                    Debug.Assert(parentNestedResourceInfo.IsCollection.HasValue, "parentNestedResourceInfo.IsCollection.HasValue");
                    if (parentNestedResourceInfo.IsCollection.Value)
                    {
                        // write [ for the collection
                        this.jsonWriter.StartArrayScope();
                    }
                }
                else
                {
                    // In response
                    Debug.Assert(parentNestedResourceInfo.IsCollection.HasValue, "parentNestedResourceInfo.IsCollection.HasValue");
                    if (!parentNestedResourceInfo.IsCollection.Value)
                    {
                        // Write the property name for single-nested resource,
                        // for the collection nested resource, it's write at top level when writing ODataResourceSet
                        this.jsonWriter.WriteName(parentNestedResourceInfo.Name);
                    }
                }

                nestedResourceScope.EntityReferenceLinkWritten = true;
            }

            if (!this.jsonLightOutputContext.WritingResponse &&
                (this.Version == null || this.Version < ODataVersion.V401))
            {
                Debug.Assert(entityReferenceLink.Url != null, "The entity reference link Url should have been validated by now.");
                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(entityReferenceLink.Url));
            }
            else
            {
                WriteEntityReferenceLinkImplementation(entityReferenceLink);
            }
        }

        /// <summary>
        /// Create a new resource set scope.
        /// </summary>
        /// <param name="resourceSet">The resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override ResourceSetScope CreateResourceSetScope(
            ODataResourceSet resourceSet,
            IEdmNavigationSource navigationSource,
            IEdmType itemType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri,
            bool isUndeclared)
        {
            return new JsonLightResourceSetScope(resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri, isUndeclared);
        }

        /// <summary>
        /// Create a new delta resource set scope.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override DeltaResourceSetScope CreateDeltaResourceSetScope(
            ODataDeltaResourceSet deltaResourceSet,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri,
            bool isUndeclared)
        {
            return new JsonLightDeltaResourceSetScope(deltaResourceSet, navigationSource, resourceType, selectedProperties, odataUri);
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="deltaResource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="resourceType">The entity type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override DeletedResourceScope CreateDeletedResourceScope(ODataDeletedResource deltaResource, IEdmNavigationSource navigationSource, IEdmEntityType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
       {
            return new JsonLightDeletedResourceScope(
                deltaResource,
                this.GetResourceSerializationInfo(deltaResource),
                navigationSource,
                resourceType,
                skipWriting,
                this.jsonLightOutputContext.MessageWriterSettings,
                selectedProperties,
                odataUri,
                isUndeclared);
        }

        /// <summary>
        /// Create a new property scope.
        /// </summary>
        /// <param name="property">The property for the new scope.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created property scope.</returns>
        protected override PropertyInfoScope CreatePropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightPropertyScope(property, navigationSource, resourceType, selectedProperties, odataUri);
        }

        /// <summary>
        /// Create a new delta link scope.
        /// </summary>
        /// <param name="link">The link for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly create scope.</returns>
        protected override DeltaLinkScope CreateDeltaLinkScope(ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightDeltaLinkScope(
                link is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink,
                link,
                this.GetLinkSerializationInfo(link),
                navigationSource,
                entityType,
                selectedProperties,
                odataUri);
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override ResourceScope CreateResourceScope(ODataResource resource, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            return new JsonLightResourceScope(
                resource,
                this.GetResourceSerializationInfo(resource),
                navigationSource,
                resourceType,
                skipWriting,
                this.jsonLightOutputContext.MessageWriterSettings,
                selectedProperties,
                odataUri,
                isUndeclared);
        }

        /// <summary>
        /// Creates a new JSON Light nested resource info scope.
        /// </summary>
        /// <param name="writerState">The writer state for the new scope.</param>
        /// <param name="navLink">The nested resource info for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="itemType">The type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created JSON Light  nested resource info scope.</returns>
        protected override NestedResourceInfoScope CreateNestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightNestedResourceInfoScope(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
        }

        /// <summary>
        /// Write the entity reference link.
        /// </summary>
        /// <param name="entityReferenceLink">The OData entity reference link.</param>
        private void WriteEntityReferenceLinkImplementation(ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            WriterValidationUtils.ValidateEntityReferenceLink(entityReferenceLink);

            this.jsonWriter.StartObjectScope();

            this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataId);

            Uri id = this.jsonLightOutputContext.MessageWriterSettings.MetadataDocumentUri.MakeRelativeUri(entityReferenceLink.Url);

            this.jsonWriter.WriteValue(id == null ? null : this.jsonLightResourceSerializer.UriToString(id));

            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(entityReferenceLink.InstanceAnnotations);

            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Sets resource's metadata builder based on current metadata level.
        /// </summary>
        /// <param name="resource">Resource to write.</param>
        /// <param name="typeContext">The context object to answer basic questions regarding the type of the resource or resource set.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        private void InnerPrepareResourceForWriteStart(ODataResourceBase resource, ODataResourceTypeContext typeContext, SelectedPropertiesNode selectedProperties)
        {
            ODataResourceSerializationInfo serializationInfo;
            IEdmStructuredType resourceType;
            ODataUri uri;

            if (resource is ODataResource)
            {
                ResourceScope resourceScope = (ResourceScope)this.CurrentScope;
                Debug.Assert(resourceScope != null, "resourceScope != null");
                serializationInfo = resourceScope.SerializationInfo;
                resourceType = resourceScope.ResourceType;
                uri = resourceScope.ODataUri;
            }
            else
            {
                DeletedResourceScope resourceScope = (DeletedResourceScope)this.CurrentScope;
                Debug.Assert(resourceScope != null, "resourceScope != null");
                serializationInfo = resourceScope.SerializationInfo;
                resourceType = resourceScope.ResourceType;
                uri = resourceScope.ODataUri;
            }

            ODataResourceMetadataBuilder builder = this.jsonLightOutputContext.MetadataLevel.CreateResourceMetadataBuilder(
                resource,
                typeContext,
                serializationInfo,
                resourceType,
                selectedProperties,
                this.jsonLightOutputContext.WritingResponse,
                this.jsonLightOutputContext.ODataSimplifiedOptions.EnableWritingKeyAsSegment,
                uri,
                this.jsonLightOutputContext.MessageWriterSettings);

            if (builder != null)
            {
                builder.NameAsProperty = this.BelongingNestedResourceInfo != null ? this.BelongingNestedResourceInfo.Name : null;
                builder.IsFromCollection = this.BelongingNestedResourceInfo != null && this.BelongingNestedResourceInfo.IsCollection == true;

                if (builder is ODataConventionalResourceMetadataBuilder)
                {
                    builder.ParentMetadataBuilder = this.FindParentResourceMetadataBuilder();
                }

                this.jsonLightOutputContext.MetadataLevel.InjectMetadataBuilder(resource, builder);
            }
        }

        /// <summary>
        /// Find instance of the metadata builder which belong to the parent odata resource
        /// </summary>
        /// <returns>
        /// The metadata builder of the parent odata resource
        /// Or null if there is no parent odata resource
        /// </returns>
        private ODataResourceMetadataBuilder FindParentResourceMetadataBuilder()
        {
            ResourceScope parentResourceScope = this.GetParentResourceScope();

            if (parentResourceScope != null)
            {
                ODataResourceBase resource = parentResourceScope.Item as ODataResourceBase;
                if (resource != null)
                {
                    return resource.MetadataBuilder;
                }
            }

            return null;
        }

        /// <summary>
        /// Writes the odata.count annotation for a resource set if it has not been written yet (and the count is specified on the resource set).
        /// </summary>
        /// <param name="count">The count to write for the resource set.</param>
        /// <param name="propertyName">The name of the expanded nav property or null for a top-level resource set.</param>
        private void WriteResourceSetCount(long? count, string propertyName)
        {
            if (count.HasValue)
            {
                if (propertyName == null)
                {
                    this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataCount);
                }
                else
                {
                    this.odataAnnotationWriter.WritePropertyAnnotationName(propertyName, ODataAnnotationNames.ODataCount);
                }

                this.jsonWriter.WriteValue(count.Value);
            }
        }

        /// <summary>
        /// Writes the odata.nextLink annotation for a resource set if it has not been written yet (and the next link is specified on the resource set).
        /// </summary>
        /// <param name="nextPageLink">The nextLink to write, if available.</param>
        /// <param name="propertyName">The name of the expanded nav property or null for a top-level resource set.</param>
        private void WriteResourceSetNextLink(Uri nextPageLink, string propertyName)
        {
            bool nextPageWritten = this.State == WriterState.ResourceSet ? this.CurrentResourceSetScope.NextPageLinkWritten : this.CurrentDeltaResourceSetScope.NextPageLinkWritten;
            if (nextPageLink != null && !nextPageWritten)
            {
                if (propertyName == null)
                {
                    this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataNextLink);
                }
                else
                {
                    this.odataAnnotationWriter.WritePropertyAnnotationName(propertyName, ODataAnnotationNames.ODataNextLink);
                }

                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(nextPageLink));

                if (this.State == WriterState.ResourceSet)
                {
                    this.CurrentResourceSetScope.NextPageLinkWritten = true;
                }
                else
                {
                    this.CurrentDeltaResourceSetScope.NextPageLinkWritten = true;
                }
            }
        }

        /// <summary>
        /// Writes the odata.deltaLink annotation for a resource set if it has not been written yet (and the delta link is specified on the resource set).
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        private void WriteResourceSetDeltaLink(Uri deltaLink)
        {
            if (deltaLink == null)
            {
                return;
            }

            Debug.Assert(this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "Write ResourceSet Delta Link called when not in ResourceSet or DeltaResourceSet state");

            bool deltaLinkWritten = this.State == WriterState.ResourceSet ? this.CurrentResourceSetScope.DeltaLinkWritten : this.CurrentDeltaResourceSetScope.DeltaLinkWritten;
            if (!deltaLinkWritten)
            {
                this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataDeltaLink);
                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(deltaLink));
                if (this.State == WriterState.ResourceSet)
                {
                    this.CurrentResourceSetScope.DeltaLinkWritten = true;
                }
                else
                {
                    this.CurrentDeltaResourceSetScope.DeltaLinkWritten = true;
                }
            }
        }

        private void WriteV4DeletedEntryContents(ODataDeletedResource resource)
        {
            this.WriteDeletedResourceId(resource);
            this.WriteDeltaResourceReason(resource);
        }

        private void WriteDeletedEntryContents(ODataDeletedResource resource)
        {
            this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataRemoved);
            this.jsonWriter.StartObjectScope();
            this.WriteDeltaResourceReason(resource);
            this.jsonWriter.EndObjectScope();

            JsonLightDeletedResourceScope resourceScope = this.CurrentDeletedResourceScope;

            // Write the metadata
            this.jsonLightResourceSerializer.WriteResourceStartMetadataProperties(resourceScope);
            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            this.jsonLightOutputContext.PropertyCacheHandler.SetCurrentResourceScopeLevel(this.ScopeLevel);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            this.WriteDeltaResourceProperties(resource);
            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
        }

        /// <summary>
        /// Writes the id property for a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write the id for.</param>
        private void WriteDeletedResourceId(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");
            if (this.Version == null || this.Version < ODataVersion.V401)
            {
                this.jsonWriter.WriteName(JsonLightConstants.ODataIdPropertyName);
                this.jsonWriter.WriteValue(resource.Id.OriginalString);
            }
            else
            {
                Uri id;
                if (resource.MetadataBuilder.TryGetIdForSerialization(out id))
                {
                    this.jsonWriter.WriteInstanceAnnotationName(JsonLightConstants.ODataIdPropertyName);
                    this.jsonWriter.WriteValue(id.OriginalString);
                }
            }
        }

        /// <summary>
        /// Writes the properties for a delta resource.
        /// </summary>
        /// <param name="resource">The resource whose properties to write.</param>
        private void WriteDeltaResourceProperties(ODataResourceBase resource)
        {
            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            if (resource.NonComputedProperties != null)
            {
                this.jsonLightResourceSerializer.WriteProperties(
                    this.ResourceType,
                    resource.NonComputedProperties,
                    false /* isComplexValue */,
                    this.DuplicatePropertyNameChecker,
                    resource.MetadataBuilder);
                this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            }
        }

        /// <summary>
        /// Writes the reason annotation for a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write the reason for.</param>
        private void WriteDeltaResourceReason(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");

            if (!resource.Reason.HasValue)
            {
                return;
            }

            this.jsonWriter.WriteName(JsonLightConstants.ODataReasonPropertyName);

            switch (resource.Reason.Value)
            {
                case DeltaDeletedEntryReason.Deleted:
                    this.jsonWriter.WriteValue(JsonLightConstants.ODataReasonDeletedValue);
                    break;
                case DeltaDeletedEntryReason.Changed:
                    this.jsonWriter.WriteValue(JsonLightConstants.ODataReasonChangedValue);
                    break;
                default:
                    Debug.Assert(false, "Unknown reason.");
                    break;
            }
        }

        /// <summary>
        /// Writes the context uri for a delta (deleted) link.
        /// </summary>
        /// <param name="kind">The delta kind of link.</param>
        private void WriteDeltaLinkContextUri(ODataDeltaKind kind)
        {
            Debug.Assert(kind == ODataDeltaKind.Link || kind == ODataDeltaKind.DeletedLink, "kind must be either DeltaLink or DeltaDeletedLink.");
            this.jsonLightResourceSerializer.WriteDeltaContextUri(this.CurrentDeltaLinkScope.GetOrCreateTypeContext(), kind);
        }

        /// <summary>
        /// Writes the source for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write source for.</param>
        private void WriteDeltaLinkSource(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataSourcePropertyName);
            this.jsonWriter.WriteValue(UriUtils.UriToString(link.Source));
        }

        /// <summary>
        /// Writes the relationship for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write relationship for.</param>
        private void WriteDeltaLinkRelationship(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataRelationshipPropertyName);
            this.jsonWriter.WriteValue(link.Relationship);
        }

        /// <summary>
        /// Writes the target for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write target for.</param>
        private void WriteDeltaLinkTarget(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataTargetPropertyName);
            this.jsonWriter.WriteValue(UriUtils.UriToString(link.Target));
        }

        /// <summary>
        /// Validates that the ODataResourceSet.InstanceAnnotations collection is empty for the given expanded resource set.
        /// </summary>
        /// <param name="resourceSet">The expanded resource set in question.</param>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "An instance field is used in a debug assert.")]
        private void ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(
                this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value == true),
                "This should only be called when writing an expanded resource set.");

            if (resourceSet.InstanceAnnotations.Count > 0)
            {
                throw new ODataException(Strings.ODataJsonLightWriter_InstanceAnnotationNotSupportedOnExpandedResourceSet);
            }
        }

        /// <summary>
        /// A scope for a JSON lite resource set.
        /// </summary>
        private sealed class JsonLightResourceSetScope : ResourceSetScope
        {
            /// <summary>true if the odata.nextLink was already written, false otherwise.</summary>
            private bool nextLinkWritten;

            /// <summary>true if the odata.deltaLink was already written, false otherwise.</summary>
            private bool deltaLinkWritten;

            /// <summary>true if the resource set represents a collection of complex property or a collection navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="resourceSet">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
            internal JsonLightResourceSetScope(ODataResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
                : base(resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// true if the odata.nextLink annotation was already written, false otherwise.
            /// </summary>
            internal bool NextPageLinkWritten
            {
                get
                {
                    return this.nextLinkWritten;
                }

                set
                {
                    this.nextLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the odata.deltaLink annotation was already written, false otherwise.
            /// </summary>
            internal bool DeltaLinkWritten
            {
                get
                {
                    return this.deltaLinkWritten;
                }

                set
                {
                    this.deltaLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the resource set represents a collection of complex property or a collection navigation property that is undeclared, false otherwise.
            /// </summary>
            internal bool IsUndeclared
            {
                get { return isUndeclared; }
            }
        }

        /// <summary>
        /// A scope for a deleted resource in JSON Light writer.
        /// </summary>
        private sealed class JsonLightDeletedResourceScope : DeletedResourceScope, IODataJsonLightWriterResourceState
        {
            /// <summary>Bit field of the JSON Light metadata properties written so far.</summary>
            private int alreadyWrittenMetadataProperties;

            /// <summary>true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
            internal JsonLightDeletedResourceScope(
                ODataDeletedResource resource,
                ODataResourceSerializationInfo serializationInfo,
                IEdmNavigationSource navigationSource,
                IEdmEntityType resourceType,
                bool skipWriting,
                ODataMessageWriterSettings writerSettings,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool isUndeclared)
                : base(resource, serializationInfo, navigationSource, resourceType, writerSettings, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// Enumeration of JSON Light metadata property flags, used to keep track of which properties were already written.
            /// </summary>
            [Flags]
            private enum JsonLightEntryMetadataProperty
            {
                /// <summary>The odata.editLink property.</summary>
                EditLink = 0x1,

                /// <summary>The odata.readLink property.</summary>
                ReadLink = 0x2,

                /// <summary>The odata.mediaEditLink property.</summary>
                MediaEditLink = 0x4,

                /// <summary>The odata.mediaReadLink property.</summary>
                MediaReadLink = 0x8,

                /// <summary>The odata.mediaContentType property.</summary>
                MediaContentType = 0x10,

                /// <summary>The odata.mediaEtag property.</summary>
                MediaETag = 0x20,
            }

            /// <summary>
            /// The resource being written.
            /// </summary>
            ODataResourceBase IODataJsonLightWriterResourceState.Resource
            {
                get { return (ODataResourceBase)this.Item; }
            }

            /// <summary>
            /// true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.
            /// </summary>
            public bool IsUndeclared
            {
                get { return isUndeclared; }
            }

            /// <summary>
            /// Flag which indicates that the odata.editLink metadata property has been written.
            /// </summary>
            public bool EditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.EditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.EditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.readLink metadata property has been written.
            /// </summary>
            public bool ReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.ReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.ReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEditLink metadata property has been written.
            /// </summary>
            public bool MediaEditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaEditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaEditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaReadLink metadata property has been written.
            /// </summary>
            public bool MediaReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaContentType metadata property has been written.
            /// </summary>
            public bool MediaContentTypeWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaContentType);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaContentType);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEtag metadata property has been written.
            /// </summary>
            public bool MediaETagWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaETag);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaETag);
                }
            }

            /// <summary>
            /// Marks the <paramref name="jsonLightMetadataProperty"/> as written in this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property which was written.</param>
            private void SetWrittenMetadataProperty(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                Debug.Assert(!this.IsMetadataPropertyWritten(jsonLightMetadataProperty), "Can't write the same metadata property twice.");
                this.alreadyWrittenMetadataProperties |= (int)jsonLightMetadataProperty;
            }

            /// <summary>
            /// Determines if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property to test for.</param>
            /// <returns>true if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope; false otherwise.</returns>
            private bool IsMetadataPropertyWritten(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                return (this.alreadyWrittenMetadataProperties & (int)jsonLightMetadataProperty) == (int)jsonLightMetadataProperty;
            }
        }

        /// <summary>
        /// A scope for a property in JSON Light writer.
        /// </summary>
        private sealed class JsonLightPropertyScope : PropertyInfoScope
        {
            /// <summary>
            /// Constructor to create a new property scope.
            /// </summary>
            /// <param name="property">The property for the new scope.</param>
            /// <param name="navigationSource">The navigation source.</param>
            /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal JsonLightPropertyScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(property, navigationSource, resourceType, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta link in JSON Light writer.
        /// </summary>
        private sealed class JsonLightDeltaLinkScope : DeltaLinkScope
        {
            /// <summary>
            /// Constructor to create a new delta link scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="link">The link for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            public JsonLightDeltaLinkScope(WriterState state, ODataItem link, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, link, serializationInfo, navigationSource, entityType, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a JSON lite resource set.
        /// </summary>
        private sealed class JsonLightDeltaResourceSetScope : DeltaResourceSetScope
        {
            /// <summary>true if the odata.nextLink was already written, false otherwise.</summary>
            private bool nextLinkWritten;

            /// <summary>true if the odata.deltaLink was already written, false otherwise.</summary>
            private bool deltaLinkWritten;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="resourceSet">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="resourceType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            public JsonLightDeltaResourceSetScope(ODataDeltaResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(resourceSet, navigationSource, resourceType, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// true if the odata.nextLink annotation was already written, false otherwise.
            /// </summary>
            internal bool NextPageLinkWritten
            {
                get
                {
                    return this.nextLinkWritten;
                }

                set
                {
                    this.nextLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the odata.deltaLink annotation was already written, false otherwise.
            /// </summary>
            internal bool DeltaLinkWritten
            {
                get
                {
                    return this.deltaLinkWritten;
                }

                set
                {
                    this.deltaLinkWritten = value;
                }
            }
        }

        /// <summary>
        /// A scope for a resource in JSON Light writer.
        /// </summary>
        private sealed class JsonLightResourceScope : ResourceScope, IODataJsonLightWriterResourceState
        {
            /// <summary>Bit field of the JSON Light metadata properties written so far.</summary>
            private int alreadyWrittenMetadataProperties;

            /// <summary>true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
            internal JsonLightResourceScope(
                ODataResource resource,
                ODataResourceSerializationInfo serializationInfo,
                IEdmNavigationSource navigationSource,
                IEdmStructuredType resourceType,
                bool skipWriting,
                ODataMessageWriterSettings writerSettings,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool isUndeclared)
                : base(resource, serializationInfo, navigationSource, resourceType, skipWriting, writerSettings, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// Enumeration of JSON Light metadata property flags, used to keep track of which properties were already written.
            /// </summary>
            [Flags]
            private enum JsonLightEntryMetadataProperty
            {
                /// <summary>The odata.editLink property.</summary>
                EditLink = 0x1,

                /// <summary>The odata.readLink property.</summary>
                ReadLink = 0x2,

                /// <summary>The odata.mediaEditLink property.</summary>
                MediaEditLink = 0x4,

                /// <summary>The odata.mediaReadLink property.</summary>
                MediaReadLink = 0x8,

                /// <summary>The odata.mediaContentType property.</summary>
                MediaContentType = 0x10,

                /// <summary>The odata.mediaEtag property.</summary>
                MediaETag = 0x20,
            }

            /// <summary>
            /// The resource being written.
            /// </summary>
            ODataResourceBase IODataJsonLightWriterResourceState.Resource
            {
                get { return (ODataResourceBase)this.Item; }
            }

            /// <summary>
            /// true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.
            /// </summary>
            public bool IsUndeclared
            {
                get { return isUndeclared; }
                set { isUndeclared = value; }
            }

            /// <summary>
            /// Flag which indicates that the odata.editLink metadata property has been written.
            /// </summary>
            public bool EditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.EditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.EditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.readLink metadata property has been written.
            /// </summary>
            public bool ReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.ReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.ReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEditLink metadata property has been written.
            /// </summary>
            public bool MediaEditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaEditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaEditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaReadLink metadata property has been written.
            /// </summary>
            public bool MediaReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaContentType metadata property has been written.
            /// </summary>
            public bool MediaContentTypeWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaContentType);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaContentType);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEtag metadata property has been written.
            /// </summary>
            public bool MediaETagWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaETag);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaETag);
                }
            }

            /// <summary>
            /// Marks the <paramref name="jsonLightMetadataProperty"/> as written in this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property which was written.</param>
            private void SetWrittenMetadataProperty(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                Debug.Assert(!this.IsMetadataPropertyWritten(jsonLightMetadataProperty), "Can't write the same metadata property twice.");
                this.alreadyWrittenMetadataProperties |= (int)jsonLightMetadataProperty;
            }

            /// <summary>
            /// Determines if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property to test for.</param>
            /// <returns>true if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope; false otherwise.</returns>
            private bool IsMetadataPropertyWritten(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                return (this.alreadyWrittenMetadataProperties & (int)jsonLightMetadataProperty) == (int)jsonLightMetadataProperty;
            }
        }

        /// <summary>
        /// A scope for a JSON Light nested resource info.
        /// </summary>
        private sealed class JsonLightNestedResourceInfoScope : NestedResourceInfoScope
        {
            /// <summary>true if we have already written an entity reference link for this nested resource info in requests; otherwise false.</summary>
            private bool entityReferenceLinkWritten;

            /// <summary>true if we have written at least one resource set for this nested resource info in requests; otherwise false.</summary>
            private bool resourceSetWritten;

            /// <summary>
            /// Constructor to create a new JSON Light nested resource info scope.
            /// </summary>
            /// <param name="writerState">The writer state for the new scope.</param>
            /// <param name="navLink">The nested resource info for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal JsonLightNestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// true if we have already written an entity reference link for this navigation link in requests; otherwise false.
            /// </summary>
            internal bool EntityReferenceLinkWritten
            {
                get
                {
                    return this.entityReferenceLinkWritten;
                }

                set
                {
                    this.entityReferenceLinkWritten = value;
                }
            }

            /// <summary>
            /// true if we have written at least one resource set for this nested resource info in requests; otherwise false.
            /// </summary>
            internal bool ResourceSetWritten
            {
                get
                {
                    return this.resourceSetWritten;
                }

                set
                {
                    this.resourceSetWritten = value;
                }
            }

            /// <summary>
            /// Clones this JSON Light nested resource info scope and sets a new writer state.
            /// </summary>
            /// <param name="newWriterState">The writer state to set.</param>
            /// <returns>The cloned nested resource info scope with the specified writer state.</returns>
            internal override NestedResourceInfoScope Clone(WriterState newWriterState)
            {
                return new JsonLightNestedResourceInfoScope(newWriterState, (ODataNestedResourceInfo)this.Item, this.NavigationSource, this.ItemType, this.SkipWriting, this.SelectedProperties, this.ODataUri)
                {
                    EntityReferenceLinkWritten = this.entityReferenceLinkWritten,
                    ResourceSetWritten = this.resourceSetWritten,
                    DerivedTypeConstraints = this.DerivedTypeConstraints
                };
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.OData.Edm;
using Microsoft.OData.Evaluation;
using Microsoft.OData.Metadata;
using Microsoft.OData.Json;

namespace Microsoft.OData.JsonLight
{
    /// <summary>
    /// Implementation of the ODataWriter for the JsonLight format.
    /// </summary>
    internal sealed class ODataJsonLightWriter : ODataWriterCore
    {
        /// <summary>
        /// The output context to write to.
        /// </summary>
        private readonly ODataJsonLightOutputContext jsonLightOutputContext;

        /// <summary>
        /// The JsonLight resource and resource set serializer to use.
        /// </summary>
        private readonly ODataJsonLightResourceSerializer jsonLightResourceSerializer;

        /// <summary>
        /// The JsonLight value serializer to use for primitive values in an untyped collection.
        /// </summary>
        private readonly ODataJsonLightValueSerializer jsonLightValueSerializer;

        /// <summary>
        /// The JsonLight property serializer.
        /// </summary>
        private readonly ODataJsonLightPropertySerializer jsonLightPropertySerializer;

        /// <summary>
        /// True if the writer was created for writing a parameter; false otherwise.
        /// </summary>
        private readonly bool writingParameter;

        /// <summary>
        /// The underlying JSON writer.
        /// </summary>
        private readonly IJsonWriter jsonWriter;

        /// <summary>
        /// The underlying JSON writer.
        /// </summary>
        private readonly IJsonStreamWriter jsonStreamWriter;

        /// <summary>
        /// OData annotation writer.
        /// </summary>
        private readonly JsonLightODataAnnotationWriter odataAnnotationWriter;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="jsonLightOutputContext">The output context to write to.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="writingResourceSet">true if the writer is created for writing a resource set; false when it is created for writing a resource.</param>
        /// <param name="writingParameter">true if the writer is created for writing a parameter; false otherwise.</param>
        /// <param name="writingDelta">True if the writer is created for writing delta payload; false otherwise.</param>
        /// <param name="listener">If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</param>
        internal ODataJsonLightWriter(
            ODataJsonLightOutputContext jsonLightOutputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool writingResourceSet,
            bool writingParameter = false,
            bool writingDelta = false,
            IODataReaderWriterListener listener = null)
            : base(jsonLightOutputContext, navigationSource, resourceType, writingResourceSet, writingDelta, listener)
        {
            Debug.Assert(jsonLightOutputContext != null, "jsonLightOutputContext != null");

            this.jsonLightOutputContext = jsonLightOutputContext;
            this.jsonLightResourceSerializer = new ODataJsonLightResourceSerializer(this.jsonLightOutputContext);
            this.jsonLightValueSerializer = new ODataJsonLightValueSerializer(this.jsonLightOutputContext);
            this.jsonLightPropertySerializer = new ODataJsonLightPropertySerializer(this.jsonLightOutputContext);

            this.writingParameter = writingParameter;
            this.jsonWriter = this.jsonLightOutputContext.JsonWriter;
            this.jsonStreamWriter = this.jsonWriter as IJsonStreamWriter;
            this.odataAnnotationWriter = new JsonLightODataAnnotationWriter(this.jsonWriter,
                this.jsonLightOutputContext.OmitODataPrefix, this.jsonLightOutputContext.MessageWriterSettings.Version);
        }

        /// <summary>
        /// Returns the current JsonLightResourceScope.
        /// </summary>
        private JsonLightResourceScope CurrentResourceScope
        {
            get
            {
                JsonLightResourceScope currentJsonLightResourceScope = this.CurrentScope as JsonLightResourceScope;
                Debug.Assert(currentJsonLightResourceScope != null, "Asking for JsonLightResourceScope when the current scope is not an JsonLightResourceScope.");
                return currentJsonLightResourceScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeletedResourceScope.
        /// </summary>
        private JsonLightDeletedResourceScope CurrentDeletedResourceScope
        {
            get
            {
                JsonLightDeletedResourceScope currentJsonLightDeletedResourceScope = this.CurrentScope as JsonLightDeletedResourceScope;
                Debug.Assert(currentJsonLightDeletedResourceScope != null, "Asking for JsonLightResourceScope when the current scope is not an JsonLightResourceScope.");
                return currentJsonLightDeletedResourceScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeltaLinkScope.
        /// </summary>
        private JsonLightDeltaLinkScope CurrentDeltaLinkScope
        {
            get
            {
                JsonLightDeltaLinkScope jsonLightDeltaLinkScope = this.CurrentScope as JsonLightDeltaLinkScope;
                Debug.Assert(jsonLightDeltaLinkScope != null, "Asking for JsonLightDeltaLinkScope when the current scope is not an JsonLightDeltaLinkScope.");
                return jsonLightDeltaLinkScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightResourceSetScope.
        /// </summary>
        private JsonLightResourceSetScope CurrentResourceSetScope
        {
            get
            {
                JsonLightResourceSetScope currentJsonLightResourceSetScope = this.CurrentScope as JsonLightResourceSetScope;
                Debug.Assert(currentJsonLightResourceSetScope != null, "Asking for JsonResourceSetScope when the current scope is not a JsonResourceSetScope.");
                return currentJsonLightResourceSetScope;
            }
        }

        /// <summary>
        /// Returns the current JsonLightDeltaResourceSetScope.
        /// </summary>
        private JsonLightDeltaResourceSetScope CurrentDeltaResourceSetScope
        {
            get
            {
                JsonLightDeltaResourceSetScope currentJsonLightDeltaResourceSetScope = this.CurrentScope as JsonLightDeltaResourceSetScope;
                Debug.Assert(currentJsonLightDeltaResourceSetScope != null, "Asking for JsonDeltaResourceSetScope when the current scope is not a JsonDeltaResourceSetScope.");
                return currentJsonLightDeltaResourceSetScope;
            }
        }

        /// <summary>
        /// Check if the object has been disposed; called from all public API methods. Throws an ObjectDisposedException if the object
        /// has already been disposed.
        /// </summary>
        protected override void VerifyNotDisposed()
        {
            this.jsonLightOutputContext.VerifyNotDisposed();
        }

        /// <summary>
        /// Flush the output.
        /// </summary>
        protected override void FlushSynchronously()
        {
            this.jsonLightOutputContext.Flush();
        }

        /// <summary>
        /// Flush the output.
        /// </summary>
        /// <returns>Task representing the pending flush operation.</returns>
        protected override Task FlushAsynchronously()
        {
            return this.jsonLightOutputContext.FlushAsync();
        }

        /// <summary>
        /// Starts writing a payload (called exactly once before anything else)
        /// </summary>
        protected override void StartPayload()
        {
            this.jsonLightResourceSerializer.WritePayloadStart();
        }

        /// <summary>
        /// Ends writing a payload (called exactly once after everything else in case of success)
        /// </summary>
        protected override void EndPayload()
        {
            this.jsonLightResourceSerializer.WritePayloadEnd();
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="resource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected override void PrepareResourceForWriteStart(ResourceScope resourceScope, ODataResource resource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            var typeContext = resourceScope.GetOrCreateTypeContext(writingResponse);
            if (this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel)
            {
                // 1. NoMetadata level: always enable its NullResourceMetadataBuilder
                InnerPrepareResourceForWriteStart(resource, typeContext, selectedProperties);
            }
            else
            {
                // 2. Minimal/Full Metadata level: Use ODataConventionalEntityMetadataBuilder for entity, ODataConventionalResourceMetadataBuilder for other cases.
                if (this.jsonLightOutputContext.Model.IsUserModel() || resourceScope.SerializationInfo != null)
                {
                    InnerPrepareResourceForWriteStart(resource, typeContext, selectedProperties);
                }

                // 3. Here fallback to the default NoOpResourceMetadataBuilder, when model and serializationInfo are both null.
            }
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the deleted resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="deletedResource">Deleted resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected override void PrepareDeletedResourceForWriteStart(DeletedResourceScope resourceScope, ODataDeletedResource deletedResource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            if (this.jsonLightOutputContext.MessageWriterSettings.Version > ODataVersion.V4)
            {
                // If:
                //      1. Minimal/Full Metadata level: Use ODataConventionalEntityMetadataBuilder for entity, ODataConventionalResourceMetadataBuilder for other cases.
                //      2. NoMetadata level: always enable its NullResourceMetadataBuilder
                // otherwise:
                //      3. Fallback to the default NoOpResourceMetadataBuilder, when model and serializationInfo are both null.
                if (this.jsonLightOutputContext.Model.IsUserModel() || resourceScope.SerializationInfo != null || this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel)
                {
                    var typeContext = resourceScope.GetOrCreateTypeContext(writingResponse);
                    InnerPrepareResourceForWriteStart(deletedResource, typeContext, selectedProperties);
                }
            }
            else if (deletedResource.Id == null && this.jsonLightOutputContext.Model.IsUserModel())
            {
                // Create an instance of the conventional UriBuilder and build id from key values
                if (deletedResource.SerializationInfo != null)
                {
                    string entityTypeName = deletedResource.SerializationInfo.ExpectedTypeName;
                    if (!String.IsNullOrEmpty(entityTypeName))
                    {
                        entityType = this.jsonLightOutputContext.Model.FindType(entityTypeName) as IEdmEntityType ?? entityType;
                    }
                }

                Debug.Assert(resourceScope.ResourceType is IEdmEntityType entityType, "No entity type specified in resourceScope or serializationInfo.");

                ODataConventionalUriBuilder uriBuilder = new ODataConventionalUriBuilder(
                    new Uri(this.jsonLightOutputContext.MessageWriterSettings.MetadataDocumentUri, "./"),
                    this.jsonLightOutputContext.ODataSimplifiedOptions.EnableWritingKeyAsSegment ? ODataUrlKeyDelimiter.Slash : ODataUrlKeyDelimiter.Parentheses
                    );

                Uri uri = uriBuilder.BuildBaseUri();
                uri = uriBuilder.BuildEntitySetUri(uri, resourceScope.NavigationSource.Name);
                uri = uriBuilder.BuildEntityInstanceUri(uri, ComputeKeyProperties(deletedResource, entityType, this.jsonLightOutputContext.Model), entityType.FullTypeName());

                deletedResource.Id = uri;
            }
        }

        internal static ICollection<KeyValuePair<string, object>> ComputeKeyProperties(ODataDeletedResource resource, IEdmEntityType entityType, IEdmModel model)
        {
            Debug.Assert(entityType.Key().Any(), "actual entity type has no keys defined");

            ICollection<KeyValuePair<string, object>> computedKeyProperties = new List<KeyValuePair<string, object>>();
            foreach (IEdmStructuralProperty edmKeyProperty in entityType.Key())
            {
                foreach(ODataProperty property in resource.NonComputedProperties)
                {
                    if (property.Name == edmKeyProperty.Name)
                    {
                        object newValue = model.ConvertToUnderlyingTypeIfUIntValue(property.Value);
                        computedKeyProperties.Add(new KeyValuePair<string, object>(edmKeyProperty.Name, newValue));
                        break;
                    }
                }
            }

            return computedKeyProperties;
        }

        /// <summary>
        /// Start writing a property.
        /// </summary>
        /// <param name="property">The property info to write.</param>
        protected override void StartProperty(ODataPropertyInfo property)
        {
            ResourceBaseScope scope = this.ParentScope as ResourceBaseScope;
            Debug.Assert(scope != null, "Writing a property and the parent scope is not a resource");
            ODataResource resource = scope.Item as ODataResource;
            Debug.Assert(resource?.MetadataBuilder != null, "Writing a property with no parent resource MetadataBuilder");

            if (property is ODataProperty propertyWithValue)
            {
                this.jsonLightPropertySerializer.WriteProperty(
                propertyWithValue,
                scope.ResourceType,
                false /*isTopLevel*/,
                this.DuplicatePropertyNameChecker,
                resource.MetadataBuilder);
            }
            else
            {
                this.jsonLightPropertySerializer.WritePropertyInfo(
                property,
                scope.ResourceType,
                false /*isTopLevel*/,
                this.DuplicatePropertyNameChecker,
                resource.MetadataBuilder);
            }
        }

        /// <summary>
        /// End writing a property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected override void EndProperty(ODataPropertyInfo property)
        {
            // nothing to do
        }

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void StartResource(ODataResource resource)
        {
            ODataNestedResourceInfo parentNavLink = this.ParentNestedResourceInfo;
            if (parentNavLink != null)
            {
                // For a null value, write the type as a property annotation
                if (resource == null)
                {
                    if (parentNavLink.TypeAnnotation != null && parentNavLink.TypeAnnotation.TypeName != null)
                    {
                        this.jsonLightResourceSerializer.ODataAnnotationWriter.WriteODataTypePropertyAnnotation(parentNavLink.Name, parentNavLink.TypeAnnotation.TypeName);
                    }

                    this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(parentNavLink.GetInstanceAnnotations(), parentNavLink.Name);
                }

                // Write the property name of an expanded navigation property to start the value.
                this.jsonWriter.WriteName(parentNavLink.Name);
            }

            if (resource == null)
            {
                this.jsonWriter.WriteValue((string)null);
                return;
            }

            // Write just the object start, nothing else, since we might not have complete information yet
            this.jsonWriter.StartObjectScope();

            JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            if (this.IsTopLevel && !(this.jsonLightOutputContext.MetadataLevel is JsonNoMetadataLevel))
            {
                var contextUriInfo = this.jsonLightResourceSerializer.WriteResourceContextUri(
                        resourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse));

                // Is writing an undeclared resource.
                if (contextUriInfo != null)
                {
                    resourceScope.IsUndeclared = contextUriInfo.IsUndeclared.HasValue && contextUriInfo.IsUndeclared.Value;
                }
            }
            else if (this.ParentScope.State == WriterState.DeltaResourceSet && this.ScopeLevel == 3)
            {
                Debug.Assert(this.ParentScope is DeltaResourceSetScope deltaResourceSetScope, "Writing child of delta set and parent scope is not DeltaResourceSetScope");

                string expectedNavigationSource =
                    deltaResourceSetScope.NavigationSource == null ? null : deltaResourceSetScope.NavigationSource.Name;
                string currentNavigationSource =
                    resource.SerializationInfo != null ? resource.SerializationInfo.NavigationSourceName :
                    resourceScope.NavigationSource == null ? null : resourceScope.NavigationSource.Name;

                if (String.IsNullOrEmpty(currentNavigationSource) || currentNavigationSource != expectedNavigationSource)
                {
                    this.jsonLightResourceSerializer.WriteDeltaContextUri(
                        this.CurrentResourceScope.GetOrCreateTypeContext(true), ODataDeltaKind.Resource,
                        deltaResourceSetScope.ContextUriInfo);
                }
            }

            // Write the metadata
            this.jsonLightResourceSerializer.WriteResourceStartMetadataProperties(resourceScope);
            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            this.jsonLightOutputContext.PropertyCacheHandler.SetCurrentResourceScopeLevel(this.ScopeLevel);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            if (resource.NonComputedProperties != null)
            {
                this.jsonLightResourceSerializer.WriteProperties(
                    this.ResourceType,
                    resource.NonComputedProperties,
                    false /* isComplexValue */,
                    this.DuplicatePropertyNameChecker,
                    resource.MetadataBuilder);
                this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            }

            // COMPAT 48: Position of navigation properties/links in JSON differs.
        }

        /// <summary>
        /// Finish writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void EndResource(ODataResource resource)
        {
            if (resource == null)
            {
                return;
            }

            // Get the projected properties
            JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.WriteResourceEndMetadataProperties(resourceScope, resourceScope.DuplicatePropertyNameChecker);

            // Close the object scope
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Finish writing a deleted resource.
        /// </summary>
        /// <param name="deletedResource">The resource to write.</param>
        protected override void EndDeletedResource(ODataDeletedResource deletedResource)
        {
            if (deletedResource == null)
            {
                return;
            }

            // Get the projected properties
            // JsonLightResourceScope resourceScope = this.CurrentResourceScope;

            // this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            // Write custom instance annotations
            // this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deletedResource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            // this.jsonLightResourceSerializer.WriteResourceEndMetadataProperties(resourceScope, resourceScope.DuplicatePropertyNameChecker);

            // Close the object scope
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Start writing a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        protected override void StartResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null && (this.writingParameter || this.ParentScope.State == WriterState.ResourceSet))
            {
                // Start array which will hold the entries in the resource set.
                this.jsonWriter.StartArrayScope();
            }
            else if (this.ParentNestedResourceInfo == null)
            {
                // Top-level resource set.
                // "{"
                this.jsonWriter.StartObjectScope();

                // @odata.context
                this.jsonLightResourceSerializer.WriteResourceSetContextUri(this.CurrentResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse));

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // write "odata.actions" metadata
                    IEnumerable<ODataAction> actions = resourceSet.Actions;
                    if (actions != null && actions.Any())
                    {
                        this.jsonLightResourceSerializer.WriteOperations(actions.Cast<ODataOperation>(), /*isAction*/ true);
                    }

                    // write "odata.functions" metadata
                    IEnumerable<ODataFunction> functions = resourceSet.Functions;
                    if (functions != null && functions.Any())
                    {
                        this.jsonLightResourceSerializer.WriteOperations(functions.Cast<ODataOperation>(), /*isAction*/ false);
                    }

                    // Write the inline count if it's available.
                    this.WriteResourceSetCount(resourceSet.Count, /*propertyName*/null);

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, /*propertyName*/null);

                    // Write the delta link if it's available.
                    this.WriteResourceSetDeltaLink(resourceSet.DeltaLink);
                }

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resourceSet.InstanceAnnotations, this.CurrentResourceSetScope.InstanceAnnotationWriteTracker);

                // "value":
                this.jsonWriter.WriteValuePropertyName();

                // Start array which will hold the entries in the resource set.
                this.jsonWriter.StartArrayScope();
            }
            else
            {
                // Expanded resource set.
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value),
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");

                this.ValidateNoDeltaLinkForExpandedResourceSet(resourceSet);
                this.ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(resourceSet);

                string propertyName = this.ParentNestedResourceInfo.Name;
                bool isUndeclared = (this.CurrentScope as JsonLightResourceSetScope).IsUndeclared;
                var expectedResourceTypeName =
                    this.CurrentResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse)
                    .ExpectedResourceTypeName;

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // Write the inline count if it's available.
                    this.WriteResourceSetCount(resourceSet.Count, propertyName);

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, propertyName);

                    // Write the odata type.
                    this.jsonLightResourceSerializer.WriteResourceSetStartMetadataProperties(resourceSet, propertyName, expectedResourceTypeName, isUndeclared);

                    // And then write the property name to start the value.
                    this.jsonWriter.WriteName(propertyName);

                    // Start array which will hold the entries in the resource set.
                    this.jsonWriter.StartArrayScope();
                }
                else
                {
                    JsonLightNestedResourceInfoScope navigationLinkScope = (JsonLightNestedResourceInfoScope)this.ParentNestedResourceInfoScope;
                    if (!navigationLinkScope.ResourceSetWritten)
                    {
                        // Close the entity reference link array (if written)
                        if (navigationLinkScope.EntityReferenceLinkWritten)
                        {
                            this.jsonWriter.EndArrayScope();
                        }

                        // Write the odata type.
                        this.jsonLightResourceSerializer.WriteResourceSetStartMetadataProperties(resourceSet, propertyName, expectedResourceTypeName, isUndeclared);

                        // And then write the property name to start the value.
                        this.jsonWriter.WriteName(propertyName);

                        // Start array which will hold the entries in the resource set.
                        this.jsonWriter.StartArrayScope();

                        navigationLinkScope.ResourceSetWritten = true;
                    }
                }
            }

            this.jsonLightOutputContext.PropertyCacheHandler.EnterResourceSetScope(this.CurrentResourceSetScope.ResourceType, this.ScopeLevel);
        }

        /// <summary>
        /// Finish writing a resource set.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        protected override void EndResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null && (this.writingParameter || this.ParentScope.State == WriterState.ResourceSet))
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();
            }
            else if (this.ParentNestedResourceInfo == null)
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resourceSet.InstanceAnnotations, this.CurrentResourceSetScope.InstanceAnnotationWriteTracker);

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, /*propertyName*/null);

                    // Write the delta link if it's available.
                    this.WriteResourceSetDeltaLink(resourceSet.DeltaLink);
                }

                // Close the object wrapper.
                this.jsonWriter.EndObjectScope();
            }
            else
            {
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value),
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");
                string propertyName = this.ParentNestedResourceInfo.Name;

                this.ValidateNoDeltaLinkForExpandedResourceSet(resourceSet);
                this.ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(resourceSet);

                if (this.jsonLightOutputContext.WritingResponse)
                {
                    // End the array which holds the entries in the resource set.
                    // NOTE: in requests we will only write the EndArray of a resource set
                    //       when we hit the nested resource info end since a nested resource info
                    //       can contain multiple resource sets that get collapsed into a single array value.
                    this.jsonWriter.EndArrayScope();

                    // Write the next link if it's available.
                    this.WriteResourceSetNextLink(resourceSet.NextPageLink, propertyName);
                }
            }

            this.jsonLightOutputContext.PropertyCacheHandler.LeaveResourceSetScope();
        }

        /// <summary>
        /// Start writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected override void StartDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            Debug.Assert(deltaResourceSet != null, "resourceSet != null");

            if (this.ParentNestedResourceInfo == null)
            {
                this.jsonWriter.StartObjectScope();

                // Write ContextUrl
                this.CurrentDeltaResourceSetScope.ContextUriInfo = this.jsonLightResourceSerializer.WriteDeltaContextUri(
                    this.CurrentDeltaResourceSetScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                    ODataDeltaKind.ResourceSet);

                // Write Count, if available
                this.WriteResourceSetCount(deltaResourceSet.Count, /*propertyname*/ null);

                // Write NextLink, if available
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, /*propertyname*/ null);

                // If we haven't written the delta link yet and it's available, write it.
                this.WriteResourceSetDeltaLink(deltaResourceSet.DeltaLink);

                // Write annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deltaResourceSet.InstanceAnnotations, this.CurrentDeltaResourceSetScope.InstanceAnnotationWriteTracker);

                // Write Value Start
                this.jsonWriter.WriteValuePropertyName();
                this.jsonWriter.StartArrayScope();
            }
            else
            {
                // Nested Delta
                Debug.Assert(
                    this.ParentNestedResourceInfo != null && this.ParentNestedResourceInfo.IsCollection.HasValue && this.ParentNestedResourceInfo.IsCollection.Value,
                    "We should have verified that resource sets can only be written into IsCollection = true links in requests.");

                string propertyName = this.ParentNestedResourceInfo.Name;

                // Write the inline count if it's available.
                this.WriteResourceSetCount(deltaResourceSet.Count, propertyName);

                // Write the next link if it's available.
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, propertyName);

                //// Write the name for the nested delta payload
                this.jsonWriter.WritePropertyAnnotationName(propertyName, JsonLightConstants.ODataDeltaPropertyName);

                // Start array which will hold the entries in the nested delta resource set.
                this.jsonWriter.StartArrayScope();
            }
        }

        /// <summary>
        /// Finish writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The resource set to write.</param>
        protected override void EndDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            Debug.Assert(deltaResourceSet != null, "deltaResourceSet != null");

            if (this.ParentNestedResourceInfo == null)
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();

                // Write custom instance annotations
                this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(deltaResourceSet.InstanceAnnotations, this.CurrentDeltaResourceSetScope.InstanceAnnotationWriteTracker);

                // Write the next link if it's available.
                this.WriteResourceSetNextLink(deltaResourceSet.NextPageLink, /*propertynamne*/ null);

                // Write the delta link if it's available.
                this.WriteResourceSetDeltaLink(deltaResourceSet.DeltaLink);

                // Close the object wrapper.
                this.jsonWriter.EndObjectScope();
            }
            else
            {
                // End the array which holds the entries in the resource set.
                this.jsonWriter.EndArrayScope();
            }
        }

        /// <summary>
        /// Start writing a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected override void StartDeletedResource(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");
            Debug.Assert(!this.IsTopLevel, "Delta resource cannot be on top level.");
            DeletedResourceScope resourceScope = this.CurrentDeletedResourceScope;
            Debug.Assert(resourceScope != null, "Writing deleted entry and scope is not DeltaResourceScope");
            ODataNestedResourceInfo parentNavLink = this.ParentNestedResourceInfo;
            if (parentNavLink != null)
            {
                // Writing a nested deleted resource
                if (this.Version == null || this.Version < ODataVersion.V401)
                {
                    throw new ODataException(Strings.ODataWriterCore_NestedContentNotAllowedIn40DeletedEntry);
                }
                else
                {
                    // Write the property name of an expanded navigation property to start the value.
                    this.jsonWriter.WriteName(parentNavLink.Name);
                    this.jsonWriter.StartObjectScope();
                    this.WriteDeletedEntryContents(resource);
                }
            }
            else
            {
                // Writing a deleted resource within an entity set
                Debug.Assert(this.ParentScope is DeltaResourceSetScope deltaResourceSetScope, "Writing child of delta set and parent scope is not DeltaResourceSetScope");

                this.jsonWriter.StartObjectScope();

                if (this.Version == null || this.Version < ODataVersion.V401)
                {
                    // Write ContextUrl
                    this.jsonLightResourceSerializer.WriteDeltaContextUri(
                            this.CurrentDeletedResourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                            ODataDeltaKind.DeletedEntry, deltaResourceSetScope.ContextUriInfo);
                    this.WriteV4DeletedEntryContents(resource);
                }
                else
                {
                    // Only write ContextUrl for V4.01 deleted resource if it is in a top level delta
                    // resource set and comes from a different entity set
                    string expectedNavigationSource =
                        deltaResourceSetScope.NavigationSource == null ? null : deltaResourceSetScope.NavigationSource.Name;
                    string currentNavigationSource =
                        resource.SerializationInfo != null ? resource.SerializationInfo.NavigationSourceName :
                        resourceScope.NavigationSource == null ? null : resourceScope.NavigationSource.Name;

                    if (String.IsNullOrEmpty(currentNavigationSource) || currentNavigationSource != expectedNavigationSource)
                    {
                        Debug.Assert(this.ScopeLevel == 3, "Writing a nested deleted resource of the wrong type should already have been caught.");

                        // We are writing a deleted resource in a top level delta resource set
                        // from a different entity set, so include the context Url
                        this.jsonLightResourceSerializer.WriteDeltaContextUri(
                                this.CurrentDeletedResourceScope.GetOrCreateTypeContext(this.jsonLightOutputContext.WritingResponse),
                                ODataDeltaKind.DeletedEntry, deltaResourceSetScope.ContextUriInfo);
                    }

                    this.WriteDeletedEntryContents(resource);
                }
            }
        }

        /// <summary>
        /// Start writing a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write.</param>
        protected override void StartDeltaLink(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");

            this.jsonWriter.StartObjectScope();

            if (link is ODataDeltaLink)
            {
                this.WriteDeltaLinkContextUri(ODataDeltaKind.Link);
            }
            else
            {
                Debug.Assert(link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");
                this.WriteDeltaLinkContextUri(ODataDeltaKind.DeletedLink);
            }

            this.WriteDeltaLinkSource(link);
            this.WriteDeltaLinkRelationship(link);
            this.WriteDeltaLinkTarget(link);
            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Write a primitive type inside an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">The primitive value to write.</param>
        protected override void WritePrimitiveValue(ODataPrimitiveValue primitiveValue)
        {
            ODataPropertyInfo property;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                this.jsonWriter.WriteName(property.Name);
            }

            if (primitiveValue == null)
            {
                this.jsonLightValueSerializer.WriteNullValue();
            }
            else
            {
                this.jsonLightValueSerializer.WritePrimitiveValue(primitiveValue.Value, /*expectedType*/ null);
            }
        }

        /// <summary>
        /// Create a stream for writing a binary value.
        /// </summary>
        /// <returns>Stream for writing a binary value.</returns>
        protected override Stream StartBinaryStream()
        {
            ODataPropertyInfo property;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                // writing a stream property - write the property name
                this.jsonWriter.WriteName(property.Name);
                this.jsonWriter.Flush();
            }

            Stream stream;
            if (this.jsonStreamWriter == null)
            {
                this.jsonLightOutputContext.BinaryValueStream = new MemoryStream();
                stream = this.jsonLightOutputContext.BinaryValueStream;
            }
            else
            {
                stream = this.jsonStreamWriter.StartStreamValueScope();
            }

            return stream;
        }

        /// <summary>
        /// Finish writing a stream value.
        /// </summary>
        protected sealed override void EndBinaryStream()
        {
            if (this.jsonStreamWriter == null)
            {
                this.jsonWriter.WriteValue(this.jsonLightOutputContext.BinaryValueStream.ToArray());
                this.jsonLightOutputContext.BinaryValueStream.Flush();
                this.jsonLightOutputContext.BinaryValueStream.Dispose();
                this.jsonLightOutputContext.BinaryValueStream = null;
            }
            else
            {
                this.jsonStreamWriter.EndStreamValueScope();
            }
        }

        /// <summary>
        /// Create a TextWriter for writing a string value.
        /// </summary>
        /// <returns>TextWriter for writing a string value.</returns>
        protected override TextWriter StartTextWriter()
        {
            ODataPropertyInfo property = null;
            if (this.ParentScope != null && (property = this.ParentScope.Item as ODataPropertyInfo) != null)
            {
                // writing a text property - write the property name
                this.jsonWriter.WriteName(property.Name);
                this.jsonWriter.Flush();
            }

            TextWriter writer;
            if (this.jsonStreamWriter == null)
            {
                this.jsonLightOutputContext.StringWriter = new StringWriter(System.Globalization.CultureInfo.InvariantCulture);
                writer = this.jsonLightOutputContext.StringWriter;
            }
            else
            {
                string contentType = "text/plain";
                ODataStreamPropertyInfo streamInfo = property as ODataStreamPropertyInfo;
                if (streamInfo?.ContentType != null)
                {
                    contentType = streamInfo.ContentType;
                }

                writer = this.jsonStreamWriter.StartTextWriterValueScope(contentType);
            }

            return writer;
        }

        /// <summary>
        /// Finish writing a text value.
        /// </summary>
        protected sealed override void EndTextWriter()
        {
            if (this.jsonStreamWriter == null)
            {
                Debug.Assert(this.jsonLightOutputContext.StringWriter != null, "Calling EndTextWriter with a non-streaming JsonWriter and a null StringWriter");
                this.jsonLightOutputContext.StringWriter.Flush();
                this.jsonWriter.WriteValue(this.jsonLightOutputContext.StringWriter.GetStringBuilder().ToString());
                this.jsonLightOutputContext.StringWriter.Dispose();
                this.jsonLightOutputContext.StringWriter = null;
            }
            else
            {
                this.jsonStreamWriter.EndTextWriterValueScope();
            }
        }

        /// <summary>
        /// Start writing a deferred (non-expanded) nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void WriteDeferredNestedResourceInfo(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(this.jsonLightOutputContext.WritingResponse, "Deferred links are only supported in response, we should have verified this already.");

            // A deferred nested resource info is just the link metadata, no value.
            this.jsonLightResourceSerializer.WriteNavigationLinkMetadata(nestedResourceInfo, this.DuplicatePropertyNameChecker);
        }

        /// <summary>
        /// Start writing the nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void StartNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");
            Debug.Assert(!string.IsNullOrEmpty(nestedResourceInfo.Name), "The nested resource info name should have been verified by now.");

            if (this.jsonLightOutputContext.WritingResponse)
            {
                // Write @odata.context annotation for navigation property
                if (this.CurrentScope.NavigationSource is IEdmContainedEntitySet containedEntitySet
                    && this.jsonLightOutputContext.MessageWriterSettings.LibraryCompatibility < ODataLibraryCompatibility.Version7
                    && this.jsonLightOutputContext.MessageWriterSettings.Version < ODataVersion.V401)
                {
                    ODataContextUrlInfo info = ODataContextUrlInfo.Create(
                                                this.CurrentScope.NavigationSource,
                                                this.CurrentScope.ResourceType.FullTypeName(),
                                                containedEntitySet.NavigationProperty.Type.TypeKind() != EdmTypeKind.Collection,
                                                this.CurrentScope.ODataUri,
                                                this.jsonLightOutputContext.MessageWriterSettings.Version ?? ODataVersion.V4);

                    this.jsonLightResourceSerializer.WriteNestedResourceInfoContextUrl(nestedResourceInfo, info);
                }

                // Write the nested resource info metadata first. The rest is written by the content resource or resource set.
                this.jsonLightResourceSerializer.WriteNavigationLinkMetadata(nestedResourceInfo, this.DuplicatePropertyNameChecker);
            }
            else
            {
                this.WriterValidator.ValidateNestedResourceInfoHasCardinality(nestedResourceInfo);
            }
        }

        /// <summary>
        /// Finish writing nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected override void EndNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            JsonLightNestedResourceInfoScope navigationLinkScope = (JsonLightNestedResourceInfoScope)this.CurrentScope;

            // If we wrote entity reference links for a collection navigation property but no
            // resource set afterwards, we have to now close the array of links.
            if (!this.jsonLightOutputContext.WritingResponse)
            {
                if (navigationLinkScope.EntityReferenceLinkWritten && !navigationLinkScope.ResourceSetWritten && nestedResourceInfo.IsCollection.Value)
                {
                    this.jsonWriter.EndArrayScope();
                }

                // In requests, the nested resource info may have multiple entries in multiple resource sets in it; if we
                // wrote at least one resource set, close the resulting array here.
                if (navigationLinkScope.ResourceSetWritten)
                {
                    Debug.Assert(nestedResourceInfo.IsCollection == null || nestedResourceInfo.IsCollection.Value, "nestedResourceInfo.IsCollection.Value");
                    this.jsonWriter.EndArrayScope();
                }
            }
        }

        /// <summary>
        /// Write an entity reference link.
        /// </summary>
        /// <param name="parentNestedResourceInfo">The parent navigation link which is being written around the entity reference link.</param>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        protected override void WriteEntityReferenceInNavigationLinkContent(ODataNestedResourceInfo parentNestedResourceInfo, ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(parentNestedResourceInfo != null, "parentNestedResourceInfo != null");
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            // In JSON Light, we can only write entity reference links at the beginning of a navigation link in requests;
            // once we wrote a resource set, entity reference links are not allowed anymore (we require all the entity reference
            // link to come first because of the grouping in the JSON Light wire format).
            JsonLightNestedResourceInfoScope nestedResourceScope = this.CurrentScope as JsonLightNestedResourceInfoScope;
            if (nestedResourceScope == null)
            {
                nestedResourceScope = this.ParentNestedResourceInfoScope as JsonLightNestedResourceInfoScope;
            }

            if (nestedResourceScope.ResourceSetWritten)
            {
                throw new ODataException(Strings.ODataJsonLightWriter_EntityReferenceLinkAfterResourceSetInRequest);
            }

            if (!nestedResourceScope.EntityReferenceLinkWritten)
            {
                // In request
                if (!this.jsonLightOutputContext.WritingResponse)
                {
                    if (this.Version == null || this.Version < ODataVersion.V401)
                    {
                        // Write the property annotation for the entity reference link(s)
                        this.odataAnnotationWriter.WritePropertyAnnotationName(parentNestedResourceInfo.Name, ODataAnnotationNames.ODataBind);
                    }
                    else
                    {
                        this.jsonWriter.WriteName(parentNestedResourceInfo.Name);
                    }

                    Debug.Assert(parentNestedResourceInfo.IsCollection.HasValue, "parentNestedResourceInfo.IsCollection.HasValue");
                    if (parentNestedResourceInfo.IsCollection.Value)
                    {
                        // write [ for the collection
                        this.jsonWriter.StartArrayScope();
                    }
                }
                else
                {
                    // In response
                    Debug.Assert(parentNestedResourceInfo.IsCollection.HasValue, "parentNestedResourceInfo.IsCollection.HasValue");
                    if (!parentNestedResourceInfo.IsCollection.Value)
                    {
                        // Write the property name for single-nested resource,
                        // for the collection nested resource, it's write at top level when writing ODataResourceSet
                        this.jsonWriter.WriteName(parentNestedResourceInfo.Name);
                    }
                }

                nestedResourceScope.EntityReferenceLinkWritten = true;
            }

            if (!this.jsonLightOutputContext.WritingResponse &&
                (this.Version == null || this.Version < ODataVersion.V401))
            {
                Debug.Assert(entityReferenceLink.Url != null, "The entity reference link Url should have been validated by now.");
                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(entityReferenceLink.Url));
            }
            else
            {
                WriteEntityReferenceLinkImplementation(entityReferenceLink);
            }
        }

        /// <summary>
        /// Create a new resource set scope.
        /// </summary>
        /// <param name="resourceSet">The resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override ResourceSetScope CreateResourceSetScope(
            ODataResourceSet resourceSet,
            IEdmNavigationSource navigationSource,
            IEdmType itemType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri,
            bool isUndeclared)
        {
            return new JsonLightResourceSetScope(resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri, isUndeclared);
        }

        /// <summary>
        /// Create a new delta resource set scope.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override DeltaResourceSetScope CreateDeltaResourceSetScope(
            ODataDeltaResourceSet deltaResourceSet,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri,
            bool isUndeclared)
        {
            return new JsonLightDeltaResourceSetScope(deltaResourceSet, navigationSource, resourceType, selectedProperties, odataUri);
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="deltaResource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="resourceType">The entity type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override DeletedResourceScope CreateDeletedResourceScope(ODataDeletedResource deltaResource, IEdmNavigationSource navigationSource, IEdmEntityType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
       {
            return new JsonLightDeletedResourceScope(
                deltaResource,
                this.GetResourceSerializationInfo(deltaResource),
                navigationSource,
                resourceType,
                skipWriting,
                this.jsonLightOutputContext.MessageWriterSettings,
                selectedProperties,
                odataUri,
                isUndeclared);
        }

        /// <summary>
        /// Create a new property scope.
        /// </summary>
        /// <param name="property">The property for the new scope.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created property scope.</returns>
        protected override PropertyInfoScope CreatePropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightPropertyScope(property, navigationSource, resourceType, selectedProperties, odataUri);
        }

        /// <summary>
        /// Create a new delta link scope.
        /// </summary>
        /// <param name="link">The link for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly create scope.</returns>
        protected override DeltaLinkScope CreateDeltaLinkScope(ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightDeltaLinkScope(
                link is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink,
                link,
                this.GetLinkSerializationInfo(link),
                navigationSource,
                entityType,
                selectedProperties,
                odataUri);
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected override ResourceScope CreateResourceScope(ODataResource resource, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            return new JsonLightResourceScope(
                resource,
                this.GetResourceSerializationInfo(resource),
                navigationSource,
                resourceType,
                skipWriting,
                this.jsonLightOutputContext.MessageWriterSettings,
                selectedProperties,
                odataUri,
                isUndeclared);
        }

        /// <summary>
        /// Creates a new JSON Light nested resource info scope.
        /// </summary>
        /// <param name="writerState">The writer state for the new scope.</param>
        /// <param name="navLink">The nested resource info for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="itemType">The type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created JSON Light  nested resource info scope.</returns>
        protected override NestedResourceInfoScope CreateNestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            return new JsonLightNestedResourceInfoScope(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
        }

        /// <summary>
        /// Write the entity reference link.
        /// </summary>
        /// <param name="entityReferenceLink">The OData entity reference link.</param>
        private void WriteEntityReferenceLinkImplementation(ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            WriterValidationUtils.ValidateEntityReferenceLink(entityReferenceLink);

            this.jsonWriter.StartObjectScope();

            this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataId);

            Uri id = this.jsonLightOutputContext.MessageWriterSettings.MetadataDocumentUri.MakeRelativeUri(entityReferenceLink.Url);

            this.jsonWriter.WriteValue(id == null ? null : this.jsonLightResourceSerializer.UriToString(id));

            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(entityReferenceLink.InstanceAnnotations);

            this.jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Sets resource's metadata builder based on current metadata level.
        /// </summary>
        /// <param name="resource">Resource to write.</param>
        /// <param name="typeContext">The context object to answer basic questions regarding the type of the resource or resource set.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        private void InnerPrepareResourceForWriteStart(ODataResourceBase resource, ODataResourceTypeContext typeContext, SelectedPropertiesNode selectedProperties)
        {
            ODataResourceSerializationInfo serializationInfo;
            IEdmStructuredType resourceType;
            ODataUri uri;

            if (resource is ODataResource)
            {
                ResourceScope resourceScope = (ResourceScope)this.CurrentScope;
                Debug.Assert(resourceScope != null, "resourceScope != null");
                serializationInfo = resourceScope.SerializationInfo;
                resourceType = resourceScope.ResourceType;
                uri = resourceScope.ODataUri;
            }
            else
            {
                DeletedResourceScope resourceScope = (DeletedResourceScope)this.CurrentScope;
                Debug.Assert(resourceScope != null, "resourceScope != null");
                serializationInfo = resourceScope.SerializationInfo;
                resourceType = resourceScope.ResourceType;
                uri = resourceScope.ODataUri;
            }

            ODataResourceMetadataBuilder builder = this.jsonLightOutputContext.MetadataLevel.CreateResourceMetadataBuilder(
                resource,
                typeContext,
                serializationInfo,
                resourceType,
                selectedProperties,
                this.jsonLightOutputContext.WritingResponse,
                this.jsonLightOutputContext.ODataSimplifiedOptions.EnableWritingKeyAsSegment,
                uri,
                this.jsonLightOutputContext.MessageWriterSettings);

            if (builder != null)
            {
                builder.NameAsProperty = this.BelongingNestedResourceInfo != null ? this.BelongingNestedResourceInfo.Name : null;
                builder.IsFromCollection = this.BelongingNestedResourceInfo != null && this.BelongingNestedResourceInfo.IsCollection == true;

                if (builder is ODataConventionalResourceMetadataBuilder)
                {
                    builder.ParentMetadataBuilder = this.FindParentResourceMetadataBuilder();
                }

                this.jsonLightOutputContext.MetadataLevel.InjectMetadataBuilder(resource, builder);
            }
        }

        /// <summary>
        /// Find instance of the metadata builder which belong to the parent odata resource
        /// </summary>
        /// <returns>
        /// The metadata builder of the parent odata resource
        /// Or null if there is no parent odata resource
        /// </returns>
        private ODataResourceMetadataBuilder FindParentResourceMetadataBuilder()
        {
            ResourceScope parentResourceScope = this.GetParentResourceScope();

            if (parentResourceScope != null)
            {
                if (parentResourceScope.Item is ODataResourceBase resource)
                {
                    return resource.MetadataBuilder;
                }
            }

            return null;
        }

        /// <summary>
        /// Writes the odata.count annotation for a resource set if it has not been written yet (and the count is specified on the resource set).
        /// </summary>
        /// <param name="count">The count to write for the resource set.</param>
        /// <param name="propertyName">The name of the expanded nav property or null for a top-level resource set.</param>
        private void WriteResourceSetCount(long? count, string propertyName)
        {
            if (count.HasValue)
            {
                if (propertyName == null)
                {
                    this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataCount);
                }
                else
                {
                    this.odataAnnotationWriter.WritePropertyAnnotationName(propertyName, ODataAnnotationNames.ODataCount);
                }

                this.jsonWriter.WriteValue(count.Value);
            }
        }

        /// <summary>
        /// Writes the odata.nextLink annotation for a resource set if it has not been written yet (and the next link is specified on the resource set).
        /// </summary>
        /// <param name="nextPageLink">The nextLink to write, if available.</param>
        /// <param name="propertyName">The name of the expanded nav property or null for a top-level resource set.</param>
        private void WriteResourceSetNextLink(Uri nextPageLink, string propertyName)
        {
            bool nextPageWritten = this.State == WriterState.ResourceSet ? this.CurrentResourceSetScope.NextPageLinkWritten : this.CurrentDeltaResourceSetScope.NextPageLinkWritten;
            if (nextPageLink != null && !nextPageWritten)
            {
                if (propertyName == null)
                {
                    this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataNextLink);
                }
                else
                {
                    this.odataAnnotationWriter.WritePropertyAnnotationName(propertyName, ODataAnnotationNames.ODataNextLink);
                }

                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(nextPageLink));

                if (this.State == WriterState.ResourceSet)
                {
                    this.CurrentResourceSetScope.NextPageLinkWritten = true;
                }
                else
                {
                    this.CurrentDeltaResourceSetScope.NextPageLinkWritten = true;
                }
            }
        }

        /// <summary>
        /// Writes the odata.deltaLink annotation for a resource set if it has not been written yet (and the delta link is specified on the resource set).
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        private void WriteResourceSetDeltaLink(Uri deltaLink)
        {
            if (deltaLink == null)
            {
                return;
            }

            Debug.Assert(this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "Write ResourceSet Delta Link called when not in ResourceSet or DeltaResourceSet state");

            bool deltaLinkWritten = this.State == WriterState.ResourceSet ? this.CurrentResourceSetScope.DeltaLinkWritten : this.CurrentDeltaResourceSetScope.DeltaLinkWritten;
            if (!deltaLinkWritten)
            {
                this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataDeltaLink);
                this.jsonWriter.WriteValue(this.jsonLightResourceSerializer.UriToString(deltaLink));
                if (this.State == WriterState.ResourceSet)
                {
                    this.CurrentResourceSetScope.DeltaLinkWritten = true;
                }
                else
                {
                    this.CurrentDeltaResourceSetScope.DeltaLinkWritten = true;
                }
            }
        }

        private void WriteV4DeletedEntryContents(ODataDeletedResource resource)
        {
            this.WriteDeletedResourceId(resource);
            this.WriteDeltaResourceReason(resource);
        }

        private void WriteDeletedEntryContents(ODataDeletedResource resource)
        {
            this.odataAnnotationWriter.WriteInstanceAnnotationName(ODataAnnotationNames.ODataRemoved);
            this.jsonWriter.StartObjectScope();
            this.WriteDeltaResourceReason(resource);
            this.jsonWriter.EndObjectScope();

            JsonLightDeletedResourceScope resourceScope = this.CurrentDeletedResourceScope;

            // Write the metadata
            this.jsonLightResourceSerializer.WriteResourceStartMetadataProperties(resourceScope);
            this.jsonLightResourceSerializer.WriteResourceMetadataProperties(resourceScope);

            this.jsonLightOutputContext.PropertyCacheHandler.SetCurrentResourceScopeLevel(this.ScopeLevel);

            // Write custom instance annotations
            this.jsonLightResourceSerializer.InstanceAnnotationWriter.WriteInstanceAnnotations(resource.InstanceAnnotations, resourceScope.InstanceAnnotationWriteTracker);

            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            this.WriteDeltaResourceProperties(resource);
            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
        }

        /// <summary>
        /// Writes the id property for a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write the id for.</param>
        private void WriteDeletedResourceId(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");
            if (this.Version == null || this.Version < ODataVersion.V401)
            {
                this.jsonWriter.WriteName(JsonLightConstants.ODataIdPropertyName);
                this.jsonWriter.WriteValue(resource.Id.OriginalString);
            }
            else
            {
                Uri id;
                if (resource.MetadataBuilder.TryGetIdForSerialization(out id))
                {
                    this.jsonWriter.WriteInstanceAnnotationName(JsonLightConstants.ODataIdPropertyName);
                    this.jsonWriter.WriteValue(id.OriginalString);
                }
            }
        }

        /// <summary>
        /// Writes the properties for a delta resource.
        /// </summary>
        /// <param name="resource">The resource whose properties to write.</param>
        private void WriteDeltaResourceProperties(ODataResourceBase resource)
        {
            this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            if (resource.NonComputedProperties != null)
            {
                this.jsonLightResourceSerializer.WriteProperties(
                    this.ResourceType,
                    resource.NonComputedProperties,
                    false /* isComplexValue */,
                    this.DuplicatePropertyNameChecker,
                    resource.MetadataBuilder);
                this.jsonLightResourceSerializer.JsonLightValueSerializer.AssertRecursionDepthIsZero();
            }
        }

        /// <summary>
        /// Writes the reason annotation for a delta deleted resource.
        /// </summary>
        /// <param name="resource">The resource to write the reason for.</param>
        private void WriteDeltaResourceReason(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");

            if (!resource.Reason.HasValue)
            {
                return;
            }

            this.jsonWriter.WriteName(JsonLightConstants.ODataReasonPropertyName);

            switch (resource.Reason.Value)
            {
                case DeltaDeletedEntryReason.Deleted:
                    this.jsonWriter.WriteValue(JsonLightConstants.ODataReasonDeletedValue);
                    break;
                case DeltaDeletedEntryReason.Changed:
                    this.jsonWriter.WriteValue(JsonLightConstants.ODataReasonChangedValue);
                    break;
                default:
                    Debug.Assert(false, "Unknown reason.");
                    break;
            }
        }

        /// <summary>
        /// Writes the context uri for a delta (deleted) link.
        /// </summary>
        /// <param name="kind">The delta kind of link.</param>
        private void WriteDeltaLinkContextUri(ODataDeltaKind kind)
        {
            Debug.Assert(kind == ODataDeltaKind.Link || kind == ODataDeltaKind.DeletedLink, "kind must be either DeltaLink or DeltaDeletedLink.");
            this.jsonLightResourceSerializer.WriteDeltaContextUri(this.CurrentDeltaLinkScope.GetOrCreateTypeContext(), kind);
        }

        /// <summary>
        /// Writes the source for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write source for.</param>
        private void WriteDeltaLinkSource(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataSourcePropertyName);
            this.jsonWriter.WriteValue(UriUtils.UriToString(link.Source));
        }

        /// <summary>
        /// Writes the relationship for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write relationship for.</param>
        private void WriteDeltaLinkRelationship(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataRelationshipPropertyName);
            this.jsonWriter.WriteValue(link.Relationship);
        }

        /// <summary>
        /// Writes the target for a delta (deleted) link.
        /// </summary>
        /// <param name="link">The link to write target for.</param>
        private void WriteDeltaLinkTarget(ODataDeltaLinkBase link)
        {
            Debug.Assert(link != null, "link != null");
            Debug.Assert(link is ODataDeltaLink || link is ODataDeltaDeletedLink, "link must be either DeltaLink or DeltaDeletedLink.");

            this.jsonWriter.WriteName(JsonLightConstants.ODataTargetPropertyName);
            this.jsonWriter.WriteValue(UriUtils.UriToString(link.Target));
        }

        /// <summary>
        /// Validates that the ODataResourceSet.InstanceAnnotations collection is empty for the given expanded resource set.
        /// </summary>
        /// <param name="resourceSet">The expanded resource set in question.</param>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "An instance field is used in a debug assert.")]
        private void ValidateNoCustomInstanceAnnotationsForExpandedResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(
                this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value == true),
                "This should only be called when writing an expanded resource set.");

            if (resourceSet.InstanceAnnotations.Count > 0)
            {
                throw new ODataException(Strings.ODataJsonLightWriter_InstanceAnnotationNotSupportedOnExpandedResourceSet);
            }
        }

        /// <summary>
        /// A scope for a JSON lite resource set.
        /// </summary>
        private sealed class JsonLightResourceSetScope : ResourceSetScope
        {
            /// <summary>true if the odata.nextLink was already written, false otherwise.</summary>
            private bool nextLinkWritten;

            /// <summary>true if the odata.deltaLink was already written, false otherwise.</summary>
            private bool deltaLinkWritten;

            /// <summary>true if the resource set represents a collection of complex property or a collection navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="resourceSet">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
            internal JsonLightResourceSetScope(ODataResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
                : base(resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// true if the odata.nextLink annotation was already written, false otherwise.
            /// </summary>
            internal bool NextPageLinkWritten
            {
                get
                {
                    return this.nextLinkWritten;
                }

                set
                {
                    this.nextLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the odata.deltaLink annotation was already written, false otherwise.
            /// </summary>
            internal bool DeltaLinkWritten
            {
                get
                {
                    return this.deltaLinkWritten;
                }

                set
                {
                    this.deltaLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the resource set represents a collection of complex property or a collection navigation property that is undeclared, false otherwise.
            /// </summary>
            internal bool IsUndeclared
            {
                get { return isUndeclared; }
            }
        }

        /// <summary>
        /// A scope for a deleted resource in JSON Light writer.
        /// </summary>
        private sealed class JsonLightDeletedResourceScope : DeletedResourceScope, IODataJsonLightWriterResourceState
        {
            /// <summary>Bit field of the JSON Light metadata properties written so far.</summary>
            private int alreadyWrittenMetadataProperties;

            /// <summary>true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
            internal JsonLightDeletedResourceScope(
                ODataDeletedResource resource,
                ODataResourceSerializationInfo serializationInfo,
                IEdmNavigationSource navigationSource,
                IEdmEntityType resourceType,
                bool skipWriting,
                ODataMessageWriterSettings writerSettings,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool isUndeclared)
                : base(resource, serializationInfo, navigationSource, resourceType, writerSettings, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// Enumeration of JSON Light metadata property flags, used to keep track of which properties were already written.
            /// </summary>
            [Flags]
            private enum JsonLightEntryMetadataProperty
            {
                /// <summary>The odata.editLink property.</summary>
                EditLink = 0x1,

                /// <summary>The odata.readLink property.</summary>
                ReadLink = 0x2,

                /// <summary>The odata.mediaEditLink property.</summary>
                MediaEditLink = 0x4,

                /// <summary>The odata.mediaReadLink property.</summary>
                MediaReadLink = 0x8,

                /// <summary>The odata.mediaContentType property.</summary>
                MediaContentType = 0x10,

                /// <summary>The odata.mediaEtag property.</summary>
                MediaETag = 0x20,
            }

            /// <summary>
            /// The resource being written.
            /// </summary>
            ODataResourceBase IODataJsonLightWriterResourceState.Resource
            {
                get { return (ODataResourceBase)this.Item; }
            }

            /// <summary>
            /// true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.
            /// </summary>
            public bool IsUndeclared
            {
                get { return isUndeclared; }
            }

            /// <summary>
            /// Flag which indicates that the odata.editLink metadata property has been written.
            /// </summary>
            public bool EditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.EditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.EditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.readLink metadata property has been written.
            /// </summary>
            public bool ReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.ReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.ReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEditLink metadata property has been written.
            /// </summary>
            public bool MediaEditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaEditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaEditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaReadLink metadata property has been written.
            /// </summary>
            public bool MediaReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaContentType metadata property has been written.
            /// </summary>
            public bool MediaContentTypeWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaContentType);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaContentType);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEtag metadata property has been written.
            /// </summary>
            public bool MediaETagWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaETag);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaETag);
                }
            }

            /// <summary>
            /// Marks the <paramref name="jsonLightMetadataProperty"/> as written in this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property which was written.</param>
            private void SetWrittenMetadataProperty(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                Debug.Assert(!this.IsMetadataPropertyWritten(jsonLightMetadataProperty), "Can't write the same metadata property twice.");
                this.alreadyWrittenMetadataProperties |= (int)jsonLightMetadataProperty;
            }

            /// <summary>
            /// Determines if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property to test for.</param>
            /// <returns>true if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope; false otherwise.</returns>
            private bool IsMetadataPropertyWritten(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                return (this.alreadyWrittenMetadataProperties & (int)jsonLightMetadataProperty) == (int)jsonLightMetadataProperty;
            }
        }

        /// <summary>
        /// A scope for a property in JSON Light writer.
        /// </summary>
        private sealed class JsonLightPropertyScope : PropertyInfoScope
        {
            /// <summary>
            /// Constructor to create a new property scope.
            /// </summary>
            /// <param name="property">The property for the new scope.</param>
            /// <param name="navigationSource">The navigation source.</param>
            /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal JsonLightPropertyScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(property, navigationSource, resourceType, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta link in JSON Light writer.
        /// </summary>
        private sealed class JsonLightDeltaLinkScope : DeltaLinkScope
        {
            /// <summary>
            /// Constructor to create a new delta link scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="link">The link for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            public JsonLightDeltaLinkScope(WriterState state, ODataItem link, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, link, serializationInfo, navigationSource, entityType, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a JSON lite resource set.
        /// </summary>
        private sealed class JsonLightDeltaResourceSetScope : DeltaResourceSetScope
        {
            /// <summary>true if the odata.nextLink was already written, false otherwise.</summary>
            private bool nextLinkWritten;

            /// <summary>true if the odata.deltaLink was already written, false otherwise.</summary>
            private bool deltaLinkWritten;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="resourceSet">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="resourceType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            public JsonLightDeltaResourceSetScope(ODataDeltaResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(resourceSet, navigationSource, resourceType, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// true if the odata.nextLink annotation was already written, false otherwise.
            /// </summary>
            internal bool NextPageLinkWritten
            {
                get
                {
                    return this.nextLinkWritten;
                }

                set
                {
                    this.nextLinkWritten = value;
                }
            }

            /// <summary>
            /// true if the odata.deltaLink annotation was already written, false otherwise.
            /// </summary>
            internal bool DeltaLinkWritten
            {
                get
                {
                    return this.deltaLinkWritten;
                }

                set
                {
                    this.deltaLinkWritten = value;
                }
            }
        }

        /// <summary>
        /// A scope for a resource in JSON Light writer.
        /// </summary>
        private sealed class JsonLightResourceScope : ResourceScope, IODataJsonLightWriterResourceState
        {
            /// <summary>Bit field of the JSON Light metadata properties written so far.</summary>
            private int alreadyWrittenMetadataProperties;

            /// <summary>true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.</summary>
            private bool isUndeclared;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resources for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
            internal JsonLightResourceScope(
                ODataResource resource,
                ODataResourceSerializationInfo serializationInfo,
                IEdmNavigationSource navigationSource,
                IEdmStructuredType resourceType,
                bool skipWriting,
                ODataMessageWriterSettings writerSettings,
                SelectedPropertiesNode selectedProperties,
                ODataUri odataUri,
                bool isUndeclared)
                : base(resource, serializationInfo, navigationSource, resourceType, skipWriting, writerSettings, selectedProperties, odataUri)
            {
                this.isUndeclared = isUndeclared;
            }

            /// <summary>
            /// Enumeration of JSON Light metadata property flags, used to keep track of which properties were already written.
            /// </summary>
            [Flags]
            private enum JsonLightEntryMetadataProperty
            {
                /// <summary>The odata.editLink property.</summary>
                EditLink = 0x1,

                /// <summary>The odata.readLink property.</summary>
                ReadLink = 0x2,

                /// <summary>The odata.mediaEditLink property.</summary>
                MediaEditLink = 0x4,

                /// <summary>The odata.mediaReadLink property.</summary>
                MediaReadLink = 0x8,

                /// <summary>The odata.mediaContentType property.</summary>
                MediaContentType = 0x10,

                /// <summary>The odata.mediaEtag property.</summary>
                MediaETag = 0x20,
            }

            /// <summary>
            /// The resource being written.
            /// </summary>
            ODataResourceBase IODataJsonLightWriterResourceState.Resource
            {
                get { return (ODataResourceBase)this.Item; }
            }

            /// <summary>
            /// true if the resource set represents a complex property or a singleton navigation property that is undeclared, false otherwise.
            /// </summary>
            public bool IsUndeclared
            {
                get { return isUndeclared; }
                set { isUndeclared = value; }
            }

            /// <summary>
            /// Flag which indicates that the odata.editLink metadata property has been written.
            /// </summary>
            public bool EditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.EditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.EditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.readLink metadata property has been written.
            /// </summary>
            public bool ReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.ReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.ReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEditLink metadata property has been written.
            /// </summary>
            public bool MediaEditLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaEditLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaEditLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaReadLink metadata property has been written.
            /// </summary>
            public bool MediaReadLinkWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaReadLink);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaReadLink);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaContentType metadata property has been written.
            /// </summary>
            public bool MediaContentTypeWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaContentType);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaContentType);
                }
            }

            /// <summary>
            /// Flag which indicates that the odata.mediaEtag metadata property has been written.
            /// </summary>
            public bool MediaETagWritten
            {
                get
                {
                    return this.IsMetadataPropertyWritten(JsonLightEntryMetadataProperty.MediaETag);
                }

                set
                {
                    Debug.Assert(value == true, "The flag that a metadata property has been written should only ever be set from false to true.");
                    this.SetWrittenMetadataProperty(JsonLightEntryMetadataProperty.MediaETag);
                }
            }

            /// <summary>
            /// Marks the <paramref name="jsonLightMetadataProperty"/> as written in this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property which was written.</param>
            private void SetWrittenMetadataProperty(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                Debug.Assert(!this.IsMetadataPropertyWritten(jsonLightMetadataProperty), "Can't write the same metadata property twice.");
                this.alreadyWrittenMetadataProperties |= (int)jsonLightMetadataProperty;
            }

            /// <summary>
            /// Determines if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope.
            /// </summary>
            /// <param name="jsonLightMetadataProperty">The metadata property to test for.</param>
            /// <returns>true if the <paramref name="jsonLightMetadataProperty"/> was already written for this resource scope; false otherwise.</returns>
            private bool IsMetadataPropertyWritten(JsonLightEntryMetadataProperty jsonLightMetadataProperty)
            {
                return (this.alreadyWrittenMetadataProperties & (int)jsonLightMetadataProperty) == (int)jsonLightMetadataProperty;
            }
        }

        /// <summary>
        /// A scope for a JSON Light nested resource info.
        /// </summary>
        private sealed class JsonLightNestedResourceInfoScope : NestedResourceInfoScope
        {
            /// <summary>true if we have already written an entity reference link for this nested resource info in requests; otherwise false.</summary>
            private bool entityReferenceLinkWritten;

            /// <summary>true if we have written at least one resource set for this nested resource info in requests; otherwise false.</summary>
            private bool resourceSetWritten;

            /// <summary>
            /// Constructor to create a new JSON Light nested resource info scope.
            /// </summary>
            /// <param name="writerState">The writer state for the new scope.</param>
            /// <param name="navLink">The nested resource info for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal JsonLightNestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// true if we have already written an entity reference link for this navigation link in requests; otherwise false.
            /// </summary>
            internal bool EntityReferenceLinkWritten
            {
                get
                {
                    return this.entityReferenceLinkWritten;
                }

                set
                {
                    this.entityReferenceLinkWritten = value;
                }
            }

            /// <summary>
            /// true if we have written at least one resource set for this nested resource info in requests; otherwise false.
            /// </summary>
            internal bool ResourceSetWritten
            {
                get
                {
                    return this.resourceSetWritten;
                }

                set
                {
                    this.resourceSetWritten = value;
                }
            }

            /// <summary>
            /// Clones this JSON Light nested resource info scope and sets a new writer state.
            /// </summary>
            /// <param name="newWriterState">The writer state to set.</param>
            /// <returns>The cloned nested resource info scope with the specified writer state.</returns>
            internal override NestedResourceInfoScope Clone(WriterState newWriterState)
            {
                return new JsonLightNestedResourceInfoScope(newWriterState, (ODataNestedResourceInfo)this.Item, this.NavigationSource, this.ItemType, this.SkipWriting, this.SelectedProperties, this.ODataUri)
                {
                    EntityReferenceLinkWritten = this.entityReferenceLinkWritten,
                    ResourceSetWritten = this.resourceSetWritten,
                    DerivedTypeConstraints = this.DerivedTypeConstraints
                };
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs(264,25): error CS0841: Cannot use local variable 'entityType' before it is declared,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs(264,118): error CS0841: Cannot use local variable 'entityType' before it is declared,D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs(395,21): error CS0165: Use of unassigned local variable 'deltaResourceSetScope',D:\a\1\s\src\Microsoft.OData.Core\JsonLight\ODataJsonLightWriter.cs(785,58): error CS0165: Use of unassigned local variable 'deltaResourceSetScope'
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.Json
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Text;

    /// <summary>
    /// Extension methods for the JSON reader.
    /// </summary>
    internal static class JsonReaderExtensions
    {
        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a StartObject node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadStartObject(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.StartObject);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an EndObject node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadEndObject(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an StartArray node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadStartArray(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.StartArray);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an EndArray node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadEndArray(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.EndArray);
        }

        /// <summary>
        /// Verifies that the current node is a property node and returns the property name.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The property name of the current property node.</returns>
        internal static string GetPropertyName(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(jsonReader.NodeType == JsonNodeType.Property, "jsonReader.NodeType == JsonNodeType.Property");

            // NOTE: the JSON reader already verifies that property names are strings and not null/empty
            string propertyName = (string)jsonReader.Value;

            return propertyName;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/>, verifies that it is a Property node and returns the property name.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The property name of the property node read.</returns>
        internal static string ReadPropertyName(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            jsonReader.ValidateNodeType(JsonNodeType.Property);
            string propertyName = jsonReader.GetPropertyName();
            jsonReader.ReadNext();
            return propertyName;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The primitive value read from the reader.</returns>
        internal static object ReadPrimitiveValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.Value;
            ReadNext(jsonReader, JsonNodeType.PrimitiveValue);
            return value;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The string value read from the reader; throws an exception if no string value could be read.</returns>
        internal static string ReadStringValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();
            string stringValue = value as string;
            if (value == null || stringValue != null)
            {
                return stringValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadValueAsString(value));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> as a URI and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The string value read from the reader as a URI; throws an exception if no string value could be read.</returns>
        internal static Uri ReadUriValue(this IJsonReader jsonReader)
        {
            return UriUtils.StringToUri(ReadStringValue(jsonReader));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="propertyName">The name of the property for which to read the string; used in error messages only.</param>
        /// <returns>The string value read from the reader; throws an exception if no string value could be read.</returns>
        internal static string ReadStringValue(this IJsonReader jsonReader, string propertyName)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();
            string stringValue = value as string;
            if (value == null || stringValue != null)
            {
                return stringValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadPropertyValueAsString(value, propertyName));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type double.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The double value read from the reader; throws an exception if no double value could be read.</returns>
        internal static double? ReadDoubleValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();
            double? doubleValue = value as double?;
            if (value == null || doubleValue != null)
            {
                return doubleValue;
            }

            int? intValue = value as int?;
            if (intValue != null)
            {
                return (double)intValue;
            }

            decimal? decimalValue = value as decimal?;
            if (decimalValue != null)
            {
                return (double)decimalValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadValueAsDouble(value));
        }

        /// <summary>
        /// Skips over a JSON value (primitive, object or array).
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.PrimitiveValue, JsonNodeType.StartArray or JsonNodeType.StartObject
        /// Post-Condition: JsonNodeType.PrimitiveValue, JsonNodeType.EndArray or JsonNodeType.EndObject
        /// </remarks>
        internal static void SkipValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            int depth = 0;
            do
            {
                switch (jsonReader.NodeType)
                {
                    case JsonNodeType.StartArray:
                    case JsonNodeType.StartObject:
                        depth++;
                        break;

                    case JsonNodeType.EndArray:
                    case JsonNodeType.EndObject:
                        Debug.Assert(depth > 0, "Seen too many scope ends.");
                        depth--;
                        break;

                    default:
                        Debug.Assert(
                            jsonReader.NodeType != JsonNodeType.EndOfInput,
                            "We should not have reached end of input, since the scopes should be well formed. Otherwise JsonReader should have failed by now.");
                        break;
                }
            }
            while (jsonReader.Read() && depth > 0);

            if (depth > 0)
            {
                // Not all open scopes were closed:
                // "Invalid JSON. Unexpected end of input was found in JSON content. Not all object and array scopes were closed."
                throw JsonReaderExtensions.CreateException(Strings.JsonReader_EndOfInputWithOpenScope);
            }
        }

        /// <summary>
        /// Skips over a JSON value (primitive, object or array), and append raw string to StringBuilder.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="jsonRawValueStringBuilder">The StringBuilder to receive JSON raw string.</param>
        internal static void SkipValue(this IJsonReader jsonReader, StringBuilder jsonRawValueStringBuilder)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            using (StringWriter stringWriter = new StringWriter(jsonRawValueStringBuilder, CultureInfo.InvariantCulture))
            {
                JsonWriter jsonWriter = new JsonWriter(stringWriter, isIeee754Compatible: false);
                int depth = 0;
                do
                {
                    switch (jsonReader.NodeType)
                    {
                        case JsonNodeType.PrimitiveValue:
                            if (jsonReader.Value == null)
                            {
                                jsonWriter.WriteValue((string)null);
                            }
                            else
                            {
                                jsonWriter.WritePrimitiveValue(jsonReader.Value);
                            }

                            break;

                        case JsonNodeType.StartArray:
                            jsonWriter.StartArrayScope();
                            depth++;
                            break;

                        case JsonNodeType.StartObject:
                            jsonWriter.StartObjectScope();
                            depth++;
                            break;

                        case JsonNodeType.EndArray:
                            jsonWriter.EndArrayScope();
                            Debug.Assert(depth > 0, "Seen too many scope ends.");
                            depth--;
                            break;

                        case JsonNodeType.EndObject:
                            jsonWriter.EndObjectScope();
                            Debug.Assert(depth > 0, "Seen too many scope ends.");
                            depth--;
                            break;

                        case JsonNodeType.Property:
                            jsonWriter.WriteName(jsonReader.GetPropertyName());
                            break;

                        default:
                            Debug.Assert(
                                jsonReader.NodeType != JsonNodeType.EndOfInput,
                                "We should not have reached end of input, since the scopes should be well formed. Otherwise JsonReader should have failed by now.");
                            break;
                    }
                }
                while (jsonReader.Read() && depth > 0);

                if (depth > 0)
                {
                    // Not all open scopes were closed:
                    // "Invalid JSON. Unexpected end of input was found in JSON content. Not all object and array scopes were closed."
                    throw JsonReaderExtensions.CreateException(Strings.JsonReader_EndOfInputWithOpenScope);
                }

                jsonWriter.Flush();
            }
        }

        internal static ODataValue ReadAsUntypedOrNullValue(this IJsonReader jsonReader)
        {
            StringBuilder builder = new StringBuilder();
            jsonReader.SkipValue(builder);
            Debug.Assert(builder.Length > 0, "builder.Length > 0");
            return new ODataUntypedValue()
            {
                RawValue = builder.ToString(),
            };
        }

        internal static ODataValue ReadODataValue(this IJsonReader jsonReader)
        {
            if (jsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                object primitiveValue = jsonReader.ReadPrimitiveValue();

                return primitiveValue.ToODataValue();
            }
            else if (jsonReader.NodeType == JsonNodeType.StartObject)
            {
                jsonReader.ReadStartObject();
                ODataResourceValue resourceValue = new ODataResourceValue();
                IList<ODataProperty> propertyList = new List<ODataProperty>();

                while (jsonReader.NodeType != JsonNodeType.EndObject)
                {
                    ODataProperty property = new ODataProperty();
                    property.Name = jsonReader.ReadPropertyName();
                    property.Value = jsonReader.ReadODataValue();
                    propertyList.Add(property);
                }

                resourceValue.Properties = propertyList;

                jsonReader.ReadEndObject();

                return resourceValue;
            }
            else if (jsonReader.NodeType == JsonNodeType.StartArray)
            {
                jsonReader.ReadStartArray();
                ODataCollectionValue collectionValue = new ODataCollectionValue();
                IList<object> propertyList = new List<object>();

                while (jsonReader.NodeType != JsonNodeType.EndArray)
                {
                    propertyList.Add(jsonReader.ReadODataValue());
                }

                collectionValue.Items = propertyList;
                jsonReader.ReadEndArray();

                return collectionValue;
            }
            else
            {
                return jsonReader.ReadAsUntypedOrNullValue();
            }
        }

        /// <summary>
        /// Reads the next node. Use this instead of the direct call to Read since this asserts that there actually is a next node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The node type of the node that reader is positioned on after reading.</returns>
        internal static JsonNodeType ReadNext(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

#if DEBUG
            bool result = jsonReader.Read();
            Debug.Assert(result, "JsonReader.Read returned false in an unexpected place.");
#else
            jsonReader.Read();
#endif
            return jsonReader.NodeType;
        }

        /// <summary>
        /// Determines if the reader is on a value node.
        /// </summary>
        /// <param name="jsonReader">The reader to inspect.</param>
        /// <returns>true if the reader is on PrimitiveValue, StartObject or StartArray node, false otherwise.</returns>
        internal static bool IsOnValueNode(this IJsonReader jsonReader)
        {
            JsonNodeType nodeType = jsonReader.NodeType;
            return nodeType == JsonNodeType.PrimitiveValue || nodeType == JsonNodeType.StartObject || nodeType == JsonNodeType.StartArray;
        }

        /// <summary>
        /// Asserts that the reader is not buffer.
        /// </summary>
        /// <param name="bufferedJsonReader">The <see cref="BufferingJsonReader"/> to read from.</param>
        [Conditional("DEBUG")]
        internal static void AssertNotBuffering(this BufferingJsonReader bufferedJsonReader)
        {
#if DEBUG
            Debug.Assert(!bufferedJsonReader.IsBuffering, "!bufferedJsonReader.IsBuffering");
#endif
        }

        /// <summary>
        /// Asserts that the reader is buffer.
        /// </summary>
        /// <param name="bufferedJsonReader">The <see cref="BufferingJsonReader"/> to read from.</param>
        [Conditional("DEBUG")]
        internal static void AssertBuffering(this BufferingJsonReader bufferedJsonReader)
        {
#if DEBUG
            Debug.Assert(bufferedJsonReader.IsBuffering, "bufferedJsonReader.IsBuffering");
#endif
        }

        /// <summary>
        /// Creates an exception instance that is appropriate for the current library being built.
        /// Allows the code in this class to be shared between ODataLib and the common spatial library.
        /// </summary>
        /// <param name="exceptionMessage">String to use for the exception message.</param>
        /// <returns>Exception to be thrown.</returns>
        internal static ODataException CreateException(string exceptionMessage)
        {
            return new ODataException(exceptionMessage);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is of the expected node type.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="expectedNodeType">The expected <see cref="JsonNodeType"/> of the read node.</param>
        private static void ReadNext(this IJsonReader jsonReader, JsonNodeType expectedNodeType)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(expectedNodeType != JsonNodeType.None, "expectedNodeType != JsonNodeType.None");

            jsonReader.ValidateNodeType(expectedNodeType);
            jsonReader.Read();
        }

        /// <summary>
        /// Validates that the reader is positioned on the specified node type.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to use.</param>
        /// <param name="expectedNodeType">The expected node type.</param>
        private static void ValidateNodeType(this IJsonReader jsonReader, JsonNodeType expectedNodeType)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(expectedNodeType != JsonNodeType.None, "expectedNodeType != JsonNodeType.None");

            if (jsonReader.NodeType != expectedNodeType)
            {
                throw CreateException(Strings.JsonReaderExtensions_UnexpectedNodeDetected(expectedNodeType, jsonReader.NodeType));
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.Json
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Text;

    /// <summary>
    /// Extension methods for the JSON reader.
    /// </summary>
    internal static class JsonReaderExtensions
    {
        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a StartObject node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadStartObject(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.StartObject);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an EndObject node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadEndObject(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.EndObject);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an StartArray node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadStartArray(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.StartArray);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is an EndArray node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        internal static void ReadEndArray(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            ReadNext(jsonReader, JsonNodeType.EndArray);
        }

        /// <summary>
        /// Verifies that the current node is a property node and returns the property name.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The property name of the current property node.</returns>
        internal static string GetPropertyName(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(jsonReader.NodeType == JsonNodeType.Property, "jsonReader.NodeType == JsonNodeType.Property");

            // NOTE: the JSON reader already verifies that property names are strings and not null/empty
            string propertyName = (string)jsonReader.Value;

            return propertyName;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/>, verifies that it is a Property node and returns the property name.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The property name of the property node read.</returns>
        internal static string ReadPropertyName(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            jsonReader.ValidateNodeType(JsonNodeType.Property);
            string propertyName = jsonReader.GetPropertyName();
            jsonReader.ReadNext();
            return propertyName;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The primitive value read from the reader.</returns>
        internal static object ReadPrimitiveValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.Value;
            ReadNext(jsonReader, JsonNodeType.PrimitiveValue);
            return value;
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The string value read from the reader; throws an exception if no string value could be read.</returns>
        internal static string ReadStringValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();

            if (value == null || value is string stringValue)
            {
                return stringValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadValueAsString(value));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> as a URI and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The string value read from the reader as a URI; throws an exception if no string value could be read.</returns>
        internal static Uri ReadUriValue(this IJsonReader jsonReader)
        {
            return UriUtils.StringToUri(ReadStringValue(jsonReader));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type string.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="propertyName">The name of the property for which to read the string; used in error messages only.</param>
        /// <returns>The string value read from the reader; throws an exception if no string value could be read.</returns>
        internal static string ReadStringValue(this IJsonReader jsonReader, string propertyName)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();

            if (value == null || value is string stringValue)
            {
                return stringValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadPropertyValueAsString(value, propertyName));
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is a PrimitiveValue node of type double.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The double value read from the reader; throws an exception if no double value could be read.</returns>
        internal static double? ReadDoubleValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

            object value = jsonReader.ReadPrimitiveValue();

            if (value == null || value is double? doubleValue)
            {
                return doubleValue;
            }

            if (value is int? intValue)
            {
                return (double)intValue;
            }

            if (value is decimal? decimalValue)
            {
                return (double)decimalValue;
            }

            throw CreateException(Strings.JsonReaderExtensions_CannotReadValueAsDouble(value));
        }

        /// <summary>
        /// Skips over a JSON value (primitive, object or array).
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <remarks>
        /// Pre-Condition: JsonNodeType.PrimitiveValue, JsonNodeType.StartArray or JsonNodeType.StartObject
        /// Post-Condition: JsonNodeType.PrimitiveValue, JsonNodeType.EndArray or JsonNodeType.EndObject
        /// </remarks>
        internal static void SkipValue(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            int depth = 0;
            do
            {
                switch (jsonReader.NodeType)
                {
                    case JsonNodeType.StartArray:
                    case JsonNodeType.StartObject:
                        depth++;
                        break;

                    case JsonNodeType.EndArray:
                    case JsonNodeType.EndObject:
                        Debug.Assert(depth > 0, "Seen too many scope ends.");
                        depth--;
                        break;

                    default:
                        Debug.Assert(
                            jsonReader.NodeType != JsonNodeType.EndOfInput,
                            "We should not have reached end of input, since the scopes should be well formed. Otherwise JsonReader should have failed by now.");
                        break;
                }
            }
            while (jsonReader.Read() && depth > 0);

            if (depth > 0)
            {
                // Not all open scopes were closed:
                // "Invalid JSON. Unexpected end of input was found in JSON content. Not all object and array scopes were closed."
                throw JsonReaderExtensions.CreateException(Strings.JsonReader_EndOfInputWithOpenScope);
            }
        }

        /// <summary>
        /// Skips over a JSON value (primitive, object or array), and append raw string to StringBuilder.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="jsonRawValueStringBuilder">The StringBuilder to receive JSON raw string.</param>
        internal static void SkipValue(this IJsonReader jsonReader, StringBuilder jsonRawValueStringBuilder)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            using (StringWriter stringWriter = new StringWriter(jsonRawValueStringBuilder, CultureInfo.InvariantCulture))
            {
                JsonWriter jsonWriter = new JsonWriter(stringWriter, isIeee754Compatible: false);
                int depth = 0;
                do
                {
                    switch (jsonReader.NodeType)
                    {
                        case JsonNodeType.PrimitiveValue:
                            if (jsonReader.Value == null)
                            {
                                jsonWriter.WriteValue((string)null);
                            }
                            else
                            {
                                jsonWriter.WritePrimitiveValue(jsonReader.Value);
                            }

                            break;

                        case JsonNodeType.StartArray:
                            jsonWriter.StartArrayScope();
                            depth++;
                            break;

                        case JsonNodeType.StartObject:
                            jsonWriter.StartObjectScope();
                            depth++;
                            break;

                        case JsonNodeType.EndArray:
                            jsonWriter.EndArrayScope();
                            Debug.Assert(depth > 0, "Seen too many scope ends.");
                            depth--;
                            break;

                        case JsonNodeType.EndObject:
                            jsonWriter.EndObjectScope();
                            Debug.Assert(depth > 0, "Seen too many scope ends.");
                            depth--;
                            break;

                        case JsonNodeType.Property:
                            jsonWriter.WriteName(jsonReader.GetPropertyName());
                            break;

                        default:
                            Debug.Assert(
                                jsonReader.NodeType != JsonNodeType.EndOfInput,
                                "We should not have reached end of input, since the scopes should be well formed. Otherwise JsonReader should have failed by now.");
                            break;
                    }
                }
                while (jsonReader.Read() && depth > 0);

                if (depth > 0)
                {
                    // Not all open scopes were closed:
                    // "Invalid JSON. Unexpected end of input was found in JSON content. Not all object and array scopes were closed."
                    throw JsonReaderExtensions.CreateException(Strings.JsonReader_EndOfInputWithOpenScope);
                }

                jsonWriter.Flush();
            }
        }

        internal static ODataValue ReadAsUntypedOrNullValue(this IJsonReader jsonReader)
        {
            StringBuilder builder = new StringBuilder();
            jsonReader.SkipValue(builder);
            Debug.Assert(builder.Length > 0, "builder.Length > 0");
            return new ODataUntypedValue()
            {
                RawValue = builder.ToString(),
            };
        }

        internal static ODataValue ReadODataValue(this IJsonReader jsonReader)
        {
            if (jsonReader.NodeType == JsonNodeType.PrimitiveValue)
            {
                object primitiveValue = jsonReader.ReadPrimitiveValue();

                return primitiveValue.ToODataValue();
            }
            else if (jsonReader.NodeType == JsonNodeType.StartObject)
            {
                jsonReader.ReadStartObject();
                ODataResourceValue resourceValue = new ODataResourceValue();
                IList<ODataProperty> propertyList = new List<ODataProperty>();

                while (jsonReader.NodeType != JsonNodeType.EndObject)
                {
                    ODataProperty property = new ODataProperty();
                    property.Name = jsonReader.ReadPropertyName();
                    property.Value = jsonReader.ReadODataValue();
                    propertyList.Add(property);
                }

                resourceValue.Properties = propertyList;

                jsonReader.ReadEndObject();

                return resourceValue;
            }
            else if (jsonReader.NodeType == JsonNodeType.StartArray)
            {
                jsonReader.ReadStartArray();
                ODataCollectionValue collectionValue = new ODataCollectionValue();
                IList<object> propertyList = new List<object>();

                while (jsonReader.NodeType != JsonNodeType.EndArray)
                {
                    propertyList.Add(jsonReader.ReadODataValue());
                }

                collectionValue.Items = propertyList;
                jsonReader.ReadEndArray();

                return collectionValue;
            }
            else
            {
                return jsonReader.ReadAsUntypedOrNullValue();
            }
        }

        /// <summary>
        /// Reads the next node. Use this instead of the direct call to Read since this asserts that there actually is a next node.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <returns>The node type of the node that reader is positioned on after reading.</returns>
        internal static JsonNodeType ReadNext(this IJsonReader jsonReader)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");

#if DEBUG
            bool result = jsonReader.Read();
            Debug.Assert(result, "JsonReader.Read returned false in an unexpected place.");
#else
            jsonReader.Read();
#endif
            return jsonReader.NodeType;
        }

        /// <summary>
        /// Determines if the reader is on a value node.
        /// </summary>
        /// <param name="jsonReader">The reader to inspect.</param>
        /// <returns>true if the reader is on PrimitiveValue, StartObject or StartArray node, false otherwise.</returns>
        internal static bool IsOnValueNode(this IJsonReader jsonReader)
        {
            JsonNodeType nodeType = jsonReader.NodeType;
            return nodeType == JsonNodeType.PrimitiveValue || nodeType == JsonNodeType.StartObject || nodeType == JsonNodeType.StartArray;
        }

        /// <summary>
        /// Asserts that the reader is not buffer.
        /// </summary>
        /// <param name="bufferedJsonReader">The <see cref="BufferingJsonReader"/> to read from.</param>
        [Conditional("DEBUG")]
        internal static void AssertNotBuffering(this BufferingJsonReader bufferedJsonReader)
        {
#if DEBUG
            Debug.Assert(!bufferedJsonReader.IsBuffering, "!bufferedJsonReader.IsBuffering");
#endif
        }

        /// <summary>
        /// Asserts that the reader is buffer.
        /// </summary>
        /// <param name="bufferedJsonReader">The <see cref="BufferingJsonReader"/> to read from.</param>
        [Conditional("DEBUG")]
        internal static void AssertBuffering(this BufferingJsonReader bufferedJsonReader)
        {
#if DEBUG
            Debug.Assert(bufferedJsonReader.IsBuffering, "bufferedJsonReader.IsBuffering");
#endif
        }

        /// <summary>
        /// Creates an exception instance that is appropriate for the current library being built.
        /// Allows the code in this class to be shared between ODataLib and the common spatial library.
        /// </summary>
        /// <param name="exceptionMessage">String to use for the exception message.</param>
        /// <returns>Exception to be thrown.</returns>
        internal static ODataException CreateException(string exceptionMessage)
        {
            return new ODataException(exceptionMessage);
        }

        /// <summary>
        /// Reads the next node from the <paramref name="jsonReader"/> and verifies that it is of the expected node type.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to read from.</param>
        /// <param name="expectedNodeType">The expected <see cref="JsonNodeType"/> of the read node.</param>
        private static void ReadNext(this IJsonReader jsonReader, JsonNodeType expectedNodeType)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(expectedNodeType != JsonNodeType.None, "expectedNodeType != JsonNodeType.None");

            jsonReader.ValidateNodeType(expectedNodeType);
            jsonReader.Read();
        }

        /// <summary>
        /// Validates that the reader is positioned on the specified node type.
        /// </summary>
        /// <param name="jsonReader">The <see cref="JsonReader"/> to use.</param>
        /// <param name="expectedNodeType">The expected node type.</param>
        private static void ValidateNodeType(this IJsonReader jsonReader, JsonNodeType expectedNodeType)
        {
            Debug.Assert(jsonReader != null, "jsonReader != null");
            Debug.Assert(expectedNodeType != JsonNodeType.None, "expectedNodeType != JsonNodeType.None");

            if (jsonReader.NodeType != expectedNodeType)
            {
                throw CreateException(Strings.JsonReaderExtensions_UnexpectedNodeDetected(expectedNodeType, jsonReader.NodeType));
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(123,24): error CS0165: Use of unassigned local variable 'stringValue',D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(153,24): error CS0165: Use of unassigned local variable 'stringValue',D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(170,43): error CS8116: It is not legal to use nullable type 'double?' in a pattern; use the underlying type 'double' instead.,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(175,26): error CS8116: It is not legal to use nullable type 'int?' in a pattern; use the underlying type 'int' instead.,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(180,26): error CS8116: It is not legal to use nullable type 'decimal?' in a pattern; use the underlying type 'decimal' instead.,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonReaderExtensions.cs(172,24): error CS0165: Use of unassigned local variable 'doubleValue'
######################################################################


######################################################################
Nr: 14 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.Json
{
    #region Namespaces
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;
    #endregion Namespaces

    /// <summary>
    /// Extension methods for the JSON writer.
    /// </summary>
    internal static class JsonWriterExtensions
    {
        /// <summary>
        /// Writes the json object value to the <paramref name="jsonWriter"/>.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="jsonObjectValue">Writes the given json object value to the underlying json writer.</param>
        /// <param name="injectPropertyAction">Called when the top-level object is started to possibly inject first property into the object.</param>
        internal static void WriteJsonObjectValue(this IJsonWriter jsonWriter, IDictionary<string, object> jsonObjectValue, Action<IJsonWriter> injectPropertyAction)
        {
            Debug.Assert(jsonWriter != null, "jsonWriter != null");
            Debug.Assert(jsonObjectValue != null, "jsonObjectValue != null");

            jsonWriter.StartObjectScope();

            if (injectPropertyAction != null)
            {
                injectPropertyAction(jsonWriter);
            }

            foreach (KeyValuePair<string, object> property in jsonObjectValue)
            {
                jsonWriter.WriteName(property.Key);
                jsonWriter.WriteJsonValue(property.Value);
            }

            jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Writes a primitive value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="value">The value to write.</param>
        internal static void WritePrimitiveValue(this IJsonWriter jsonWriter, object value)
        {
            if (value is bool)
            {
                jsonWriter.WriteValue((bool)value);
                return;
            }

            if (value is byte)
            {
                jsonWriter.WriteValue((byte)value);
                return;
            }

            if (value is decimal)
            {
                jsonWriter.WriteValue((decimal)value);
                return;
            }

            if (value is double)
            {
                jsonWriter.WriteValue((double)value);
                return;
            }

            if (value is Int16)
            {
                jsonWriter.WriteValue((Int16)value);
                return;
            }

            if (value is Int32)
            {
                jsonWriter.WriteValue((Int32)value);
                return;
            }

            if (value is Int64)
            {
                jsonWriter.WriteValue((Int64)value);
                return;
            }

            if (value is sbyte)
            {
                jsonWriter.WriteValue((sbyte)value);
                return;
            }

            if (value is Single)
            {
                jsonWriter.WriteValue((Single)value);
                return;
            }

            var str = value as string;
            if (str != null)
            {
                jsonWriter.WriteValue(str);
                return;
            }

            byte[] valueAsByteArray = value as byte[];
            if (valueAsByteArray != null)
            {
                jsonWriter.WriteValue(valueAsByteArray);
                return;
            }

            if (value is DateTimeOffset)
            {
                jsonWriter.WriteValue((DateTimeOffset)value);
                return;
            }

            if (value is Guid)
            {
                jsonWriter.WriteValue((Guid)value);
                return;
            }

            if (value is TimeSpan)
            {
                jsonWriter.WriteValue((TimeSpan)value);
                return;
            }

            if (value is Date)
            {
                jsonWriter.WriteValue((Date)value);
                return;
            }

            if (value is TimeOfDay)
            {
                jsonWriter.WriteValue((TimeOfDay)value);
                return;
            }

            throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(value.GetType().FullName));
        }

        /// <summary>
        /// Writes the ODataValue (primitive, collection or resource value) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="odataValue">value to write.</param>
        internal static void WriteODataValue(this IJsonWriter jsonWriter, ODataValue odataValue)
        {
            if (odataValue == null || odataValue is ODataNullValue)
            {
                jsonWriter.WriteValue((string)null);
                return;
            }

            object objectValue = odataValue.FromODataValue();
            if (EdmLibraryExtensions.IsPrimitiveType(objectValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(objectValue);
                return;
            }

            ODataResourceValue resourceValue = odataValue as ODataResourceValue;
            if (resourceValue != null)
            {
                jsonWriter.StartObjectScope();

                foreach (ODataProperty property in resourceValue.Properties)
                {
                    jsonWriter.WriteName(property.Name);
                    jsonWriter.WriteODataValue(property.ODataValue);
                }

                jsonWriter.EndObjectScope();
                return;
            }

            ODataCollectionValue collectionValue = odataValue as ODataCollectionValue;
            if (collectionValue != null)
            {
                jsonWriter.StartArrayScope();

                foreach (object item in collectionValue.Items)
                {
                    // Will not be able to accurately serialize complex objects unless they are ODataValues.
                    ODataValue collectionItem = item as ODataValue;
                    if (item != null)
                    {
                        jsonWriter.WriteODataValue(collectionItem);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueInCollection);
                    }
                }

                jsonWriter.EndArrayScope();

                return;
            }

            throw new ODataException(
                ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(odataValue.GetType().FullName));
        }

        /// <summary>
        /// Writes the json array value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="arrayValue">Writes the json array value to the underlying json writer.</param>
        private static void WriteJsonArrayValue(this IJsonWriter jsonWriter, IEnumerable arrayValue)
        {
            Debug.Assert(arrayValue != null, "arrayValue != null");

            jsonWriter.StartArrayScope();

            foreach (object element in arrayValue)
            {
                jsonWriter.WriteJsonValue(element);
            }

            jsonWriter.EndArrayScope();
        }

        /// <summary>
        /// Writes the json value (primitive, IDictionary or IEnumerable) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="propertyValue">value to write.</param>
        private static void WriteJsonValue(this IJsonWriter jsonWriter, object propertyValue)
        {
            if (propertyValue == null)
            {
                jsonWriter.WriteValue((string)null);
            }
            else if (EdmLibraryExtensions.IsPrimitiveType(propertyValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(propertyValue);
            }
            else
            {
                IDictionary<string, object> objectValue = propertyValue as IDictionary<string, object>;
                if (objectValue != null)
                {
                    jsonWriter.WriteJsonObjectValue(objectValue, null /*typeName */);
                }
                else
                {
                    IEnumerable arrayValue = propertyValue as IEnumerable;
                    Debug.Assert(arrayValue != null, "arrayValue != null");
                    jsonWriter.WriteJsonArrayValue(arrayValue);
                }
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.Json
{
    #region Namespaces
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;
    #endregion Namespaces

    /// <summary>
    /// Extension methods for the JSON writer.
    /// </summary>
    internal static class JsonWriterExtensions
    {
        /// <summary>
        /// Writes the json object value to the <paramref name="jsonWriter"/>.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="jsonObjectValue">Writes the given json object value to the underlying json writer.</param>
        /// <param name="injectPropertyAction">Called when the top-level object is started to possibly inject first property into the object.</param>
        internal static void WriteJsonObjectValue(this IJsonWriter jsonWriter, IDictionary<string, object> jsonObjectValue, Action<IJsonWriter> injectPropertyAction)
        {
            Debug.Assert(jsonWriter != null, "jsonWriter != null");
            Debug.Assert(jsonObjectValue != null, "jsonObjectValue != null");

            jsonWriter.StartObjectScope();

            if (injectPropertyAction != null)
            {
                injectPropertyAction(jsonWriter);
            }

            foreach (KeyValuePair<string, object> property in jsonObjectValue)
            {
                jsonWriter.WriteName(property.Key);
                jsonWriter.WriteJsonValue(property.Value);
            }

            jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Writes a primitive value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="value">The value to write.</param>
        internal static void WritePrimitiveValue(this IJsonWriter jsonWriter, object value)
        {
            if (value is bool b)
            {
                jsonWriter.WriteValue(b);
                return;
            }

            if (value is byte b)
            {
                jsonWriter.WriteValue(b);
                return;
            }

            if (value is decimal d)
            {
                jsonWriter.WriteValue(d);
                return;
            }

            if (value is double d)
            {
                jsonWriter.WriteValue(d);
                return;
            }

            if (value is Int16 i)
            {
                jsonWriter.WriteValue(i);
                return;
            }

            if (value is Int32 i)
            {
                jsonWriter.WriteValue(i);
                return;
            }

            if (value is Int64 i)
            {
                jsonWriter.WriteValue(i);
                return;
            }

            if (value is sbyte sb)
            {
                jsonWriter.WriteValue(sb);
                return;
            }

            if (value is Single single)
            {
                jsonWriter.WriteValue(single);
                return;
            }

            var str = value as string;
            if (str != null)
            {
                jsonWriter.WriteValue(str);
                return;
            }

            byte[] valueAsByteArray = value as byte[];
            if (valueAsByteArray != null)
            {
                jsonWriter.WriteValue(valueAsByteArray);
                return;
            }

            if (value is DateTimeOffset dateTimeOffset)
            {
                jsonWriter.WriteValue(dateTimeOffset);
                return;
            }

            if (value is Guid guid)
            {
                jsonWriter.WriteValue(guid);
                return;
            }

            if (value is TimeSpan timeSpan)
            {
                jsonWriter.WriteValue(timeSpan);
                return;
            }

            if (value is Date date)
            {
                jsonWriter.WriteValue(date);
                return;
            }

            if (value is TimeOfDay timeOfDay)
            {
                jsonWriter.WriteValue(timeOfDay);
                return;
            }

            throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(value.GetType().FullName));
        }

        /// <summary>
        /// Writes the ODataValue (primitive, collection or resource value) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="odataValue">value to write.</param>
        internal static void WriteODataValue(this IJsonWriter jsonWriter, ODataValue odataValue)
        {
            if (odataValue == null || odataValue is ODataNullValue)
            {
                jsonWriter.WriteValue((string)null);
                return;
            }

            object objectValue = odataValue.FromODataValue();
            if (EdmLibraryExtensions.IsPrimitiveType(objectValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(objectValue);
                return;
            }

            ODataResourceValue resourceValue = odataValue as ODataResourceValue;
            if (resourceValue != null)
            {
                jsonWriter.StartObjectScope();

                foreach (ODataProperty property in resourceValue.Properties)
                {
                    jsonWriter.WriteName(property.Name);
                    jsonWriter.WriteODataValue(property.ODataValue);
                }

                jsonWriter.EndObjectScope();
                return;
            }

            ODataCollectionValue collectionValue = odataValue as ODataCollectionValue;
            if (collectionValue != null)
            {
                jsonWriter.StartArrayScope();

                foreach (object item in collectionValue.Items)
                {
                    // Will not be able to accurately serialize complex objects unless they are ODataValues.
                    ODataValue collectionItem = item as ODataValue;
                    if (item != null)
                    {
                        jsonWriter.WriteODataValue(collectionItem);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueInCollection);
                    }
                }

                jsonWriter.EndArrayScope();

                return;
            }

            throw new ODataException(
                ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(odataValue.GetType().FullName));
        }

        /// <summary>
        /// Writes the json array value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="arrayValue">Writes the json array value to the underlying json writer.</param>
        private static void WriteJsonArrayValue(this IJsonWriter jsonWriter, IEnumerable arrayValue)
        {
            Debug.Assert(arrayValue != null, "arrayValue != null");

            jsonWriter.StartArrayScope();

            foreach (object element in arrayValue)
            {
                jsonWriter.WriteJsonValue(element);
            }

            jsonWriter.EndArrayScope();
        }

        /// <summary>
        /// Writes the json value (primitive, IDictionary or IEnumerable) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="propertyValue">value to write.</param>
        private static void WriteJsonValue(this IJsonWriter jsonWriter, object propertyValue)
        {
            if (propertyValue == null)
            {
                jsonWriter.WriteValue((string)null);
            }
            else if (EdmLibraryExtensions.IsPrimitiveType(propertyValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(propertyValue);
            }
            else
            {
                IDictionary<string, object> objectValue = propertyValue as IDictionary<string, object>;
                if (objectValue != null)
                {
                    jsonWriter.WriteJsonObjectValue(objectValue, null /*typeName */);
                }
                else
                {
                    IEnumerable arrayValue = propertyValue as IEnumerable;
                    Debug.Assert(arrayValue != null, "arrayValue != null");
                    jsonWriter.WriteJsonArrayValue(arrayValue);
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(64,31): error CS0128: A local variable or function named 'b' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(76,33): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(88,32): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(94,32): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(66,39): error CS0165: Use of unassigned local variable 'b',D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(78,39): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(90,39): error CS0165: Use of unassigned local variable 'i'
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.Json
{
    #region Namespaces
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;
    #endregion Namespaces

    /// <summary>
    /// Extension methods for the JSON writer.
    /// </summary>
    internal static class JsonWriterExtensions
    {
        /// <summary>
        /// Writes the json object value to the <paramref name="jsonWriter"/>.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="jsonObjectValue">Writes the given json object value to the underlying json writer.</param>
        /// <param name="injectPropertyAction">Called when the top-level object is started to possibly inject first property into the object.</param>
        internal static void WriteJsonObjectValue(this IJsonWriter jsonWriter, IDictionary<string, object> jsonObjectValue, Action<IJsonWriter> injectPropertyAction)
        {
            Debug.Assert(jsonWriter != null, "jsonWriter != null");
            Debug.Assert(jsonObjectValue != null, "jsonObjectValue != null");

            jsonWriter.StartObjectScope();

            if (injectPropertyAction != null)
            {
                injectPropertyAction(jsonWriter);
            }

            foreach (KeyValuePair<string, object> property in jsonObjectValue)
            {
                jsonWriter.WriteName(property.Key);
                jsonWriter.WriteJsonValue(property.Value);
            }

            jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Writes a primitive value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="value">The value to write.</param>
        internal static void WritePrimitiveValue(this IJsonWriter jsonWriter, object value)
        {
            if (value is bool)
            {
                jsonWriter.WriteValue((bool)value);
                return;
            }

            if (value is byte)
            {
                jsonWriter.WriteValue((byte)value);
                return;
            }

            if (value is decimal)
            {
                jsonWriter.WriteValue((decimal)value);
                return;
            }

            if (value is double)
            {
                jsonWriter.WriteValue((double)value);
                return;
            }

            if (value is Int16)
            {
                jsonWriter.WriteValue((Int16)value);
                return;
            }

            if (value is Int32)
            {
                jsonWriter.WriteValue((Int32)value);
                return;
            }

            if (value is Int64)
            {
                jsonWriter.WriteValue((Int64)value);
                return;
            }

            if (value is sbyte)
            {
                jsonWriter.WriteValue((sbyte)value);
                return;
            }

            if (value is Single)
            {
                jsonWriter.WriteValue((Single)value);
                return;
            }

            var str = value as string;
            if (str != null)
            {
                jsonWriter.WriteValue(str);
                return;
            }

            byte[] valueAsByteArray = value as byte[];
            if (valueAsByteArray != null)
            {
                jsonWriter.WriteValue(valueAsByteArray);
                return;
            }

            if (value is DateTimeOffset)
            {
                jsonWriter.WriteValue((DateTimeOffset)value);
                return;
            }

            if (value is Guid)
            {
                jsonWriter.WriteValue((Guid)value);
                return;
            }

            if (value is TimeSpan)
            {
                jsonWriter.WriteValue((TimeSpan)value);
                return;
            }

            if (value is Date)
            {
                jsonWriter.WriteValue((Date)value);
                return;
            }

            if (value is TimeOfDay)
            {
                jsonWriter.WriteValue((TimeOfDay)value);
                return;
            }

            throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(value.GetType().FullName));
        }

        /// <summary>
        /// Writes the ODataValue (primitive, collection or resource value) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="odataValue">value to write.</param>
        internal static void WriteODataValue(this IJsonWriter jsonWriter, ODataValue odataValue)
        {
            if (odataValue == null || odataValue is ODataNullValue)
            {
                jsonWriter.WriteValue((string)null);
                return;
            }

            object objectValue = odataValue.FromODataValue();
            if (EdmLibraryExtensions.IsPrimitiveType(objectValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(objectValue);
                return;
            }

            ODataResourceValue resourceValue = odataValue as ODataResourceValue;
            if (resourceValue != null)
            {
                jsonWriter.StartObjectScope();

                foreach (ODataProperty property in resourceValue.Properties)
                {
                    jsonWriter.WriteName(property.Name);
                    jsonWriter.WriteODataValue(property.ODataValue);
                }

                jsonWriter.EndObjectScope();
                return;
            }

            ODataCollectionValue collectionValue = odataValue as ODataCollectionValue;
            if (collectionValue != null)
            {
                jsonWriter.StartArrayScope();

                foreach (object item in collectionValue.Items)
                {
                    // Will not be able to accurately serialize complex objects unless they are ODataValues.
                    ODataValue collectionItem = item as ODataValue;
                    if (item != null)
                    {
                        jsonWriter.WriteODataValue(collectionItem);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueInCollection);
                    }
                }

                jsonWriter.EndArrayScope();

                return;
            }

            throw new ODataException(
                ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(odataValue.GetType().FullName));
        }

        /// <summary>
        /// Writes the json array value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="arrayValue">Writes the json array value to the underlying json writer.</param>
        private static void WriteJsonArrayValue(this IJsonWriter jsonWriter, IEnumerable arrayValue)
        {
            Debug.Assert(arrayValue != null, "arrayValue != null");

            jsonWriter.StartArrayScope();

            foreach (object element in arrayValue)
            {
                jsonWriter.WriteJsonValue(element);
            }

            jsonWriter.EndArrayScope();
        }

        /// <summary>
        /// Writes the json value (primitive, IDictionary or IEnumerable) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="propertyValue">value to write.</param>
        private static void WriteJsonValue(this IJsonWriter jsonWriter, object propertyValue)
        {
            if (propertyValue == null)
            {
                jsonWriter.WriteValue((string)null);
            }
            else if (EdmLibraryExtensions.IsPrimitiveType(propertyValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(propertyValue);
            }
            else
            {
                IDictionary<string, object> objectValue = propertyValue as IDictionary<string, object>;
                if (objectValue != null)
                {
                    jsonWriter.WriteJsonObjectValue(objectValue, null /*typeName */);
                }
                else
                {
                    IEnumerable arrayValue = propertyValue as IEnumerable;
                    Debug.Assert(arrayValue != null, "arrayValue != null");
                    jsonWriter.WriteJsonArrayValue(arrayValue);
                }
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData.Json
{
    #region Namespaces
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;
    #endregion Namespaces

    /// <summary>
    /// Extension methods for the JSON writer.
    /// </summary>
    internal static class JsonWriterExtensions
    {
        /// <summary>
        /// Writes the json object value to the <paramref name="jsonWriter"/>.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="jsonObjectValue">Writes the given json object value to the underlying json writer.</param>
        /// <param name="injectPropertyAction">Called when the top-level object is started to possibly inject first property into the object.</param>
        internal static void WriteJsonObjectValue(this IJsonWriter jsonWriter, IDictionary<string, object> jsonObjectValue, Action<IJsonWriter> injectPropertyAction)
        {
            Debug.Assert(jsonWriter != null, "jsonWriter != null");
            Debug.Assert(jsonObjectValue != null, "jsonObjectValue != null");

            jsonWriter.StartObjectScope();

            if (injectPropertyAction != null)
            {
                injectPropertyAction(jsonWriter);
            }

            foreach (KeyValuePair<string, object> property in jsonObjectValue)
            {
                jsonWriter.WriteName(property.Key);
                jsonWriter.WriteJsonValue(property.Value);
            }

            jsonWriter.EndObjectScope();
        }

        /// <summary>
        /// Writes a primitive value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="value">The value to write.</param>
        internal static void WritePrimitiveValue(this IJsonWriter jsonWriter, object value)
        {
            if (value is bool)
            {
                jsonWriter.WriteValue((bool)value);
                return;
            }

            if (value is byte)
            {
                jsonWriter.WriteValue((byte)value);
                return;
            }

            if (value is decimal)
            {
                jsonWriter.WriteValue((decimal)value);
                return;
            }

            if (value is double)
            {
                jsonWriter.WriteValue((double)value);
                return;
            }

            if (value is Int16)
            {
                jsonWriter.WriteValue((Int16)value);
                return;
            }

            if (value is Int32)
            {
                jsonWriter.WriteValue((Int32)value);
                return;
            }

            if (value is Int64)
            {
                jsonWriter.WriteValue((Int64)value);
                return;
            }

            if (value is sbyte)
            {
                jsonWriter.WriteValue((sbyte)value);
                return;
            }

            if (value is Single)
            {
                jsonWriter.WriteValue((Single)value);
                return;
            }

            if (value is string str)
            {
                jsonWriter.WriteValue(str);
                return;
            }

            if (value is byte[] valueAsByteArray)
            {
                jsonWriter.WriteValue(valueAsByteArray);
                return;
            }

            if (value is DateTimeOffset)
            {
                jsonWriter.WriteValue((DateTimeOffset)value);
                return;
            }

            if (value is Guid)
            {
                jsonWriter.WriteValue((Guid)value);
                return;
            }

            if (value is TimeSpan)
            {
                jsonWriter.WriteValue((TimeSpan)value);
                return;
            }

            if (value is Date)
            {
                jsonWriter.WriteValue((Date)value);
                return;
            }

            if (value is TimeOfDay)
            {
                jsonWriter.WriteValue((TimeOfDay)value);
                return;
            }

            throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(value.GetType().FullName));
        }

        /// <summary>
        /// Writes the ODataValue (primitive, collection or resource value) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="odataValue">value to write.</param>
        internal static void WriteODataValue(this IJsonWriter jsonWriter, ODataValue odataValue)
        {
            if (odataValue == null || odataValue is ODataNullValue)
            {
                jsonWriter.WriteValue((string)null);
                return;
            }

            object objectValue = odataValue.FromODataValue();
            if (EdmLibraryExtensions.IsPrimitiveType(objectValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(objectValue);
                return;
            }

            if (odataValue is ODataResourceValue resourceValue)
            {
                jsonWriter.StartObjectScope();

                foreach (ODataProperty property in resourceValue.Properties)
                {
                    jsonWriter.WriteName(property.Name);
                    jsonWriter.WriteODataValue(property.ODataValue);
                }

                jsonWriter.EndObjectScope();
                return;
            }

            if (odataValue is ODataCollectionValue collectionValue)
            {
                jsonWriter.StartArrayScope();

                foreach (object item in collectionValue.Items)
                {
                    // Will not be able to accurately serialize complex objects unless they are ODataValues.
                    ODataValue collectionItem = item as ODataValue;
                    if (item != null)
                    {
                        jsonWriter.WriteODataValue(collectionItem);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.ODataJsonWriter_UnsupportedValueInCollection);
                    }
                }

                jsonWriter.EndArrayScope();

                return;
            }

            throw new ODataException(
                ODataErrorStrings.ODataJsonWriter_UnsupportedValueType(odataValue.GetType().FullName));
        }

        /// <summary>
        /// Writes the json array value.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="arrayValue">Writes the json array value to the underlying json writer.</param>
        private static void WriteJsonArrayValue(this IJsonWriter jsonWriter, IEnumerable arrayValue)
        {
            Debug.Assert(arrayValue != null, "arrayValue != null");

            jsonWriter.StartArrayScope();

            foreach (object element in arrayValue)
            {
                jsonWriter.WriteJsonValue(element);
            }

            jsonWriter.EndArrayScope();
        }

        /// <summary>
        /// Writes the json value (primitive, IDictionary or IEnumerable) to the underlying json writer.
        /// </summary>
        /// <param name="jsonWriter">The <see cref="JsonWriter"/> to write to.</param>
        /// <param name="propertyValue">value to write.</param>
        private static void WriteJsonValue(this IJsonWriter jsonWriter, object propertyValue)
        {
            if (propertyValue == null)
            {
                jsonWriter.WriteValue((string)null);
            }
            else if (EdmLibraryExtensions.IsPrimitiveType(propertyValue.GetType()))
            {
                jsonWriter.WritePrimitiveValue(propertyValue);
            }
            else
            {
                if (propertyValue is IDictionary<string, object> objectValue)
                {
                    jsonWriter.WriteJsonObjectValue(objectValue, null /*typeName */);
                }
                else
                {
                    Debug.Assert(propertyValue is IEnumerable arrayValue, "arrayValue != null");
                    jsonWriter.WriteJsonArrayValue(arrayValue);
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Json\JsonWriterExtensions.cs(261,52): error CS0165: Use of unassigned local variable 'arrayValue'
######################################################################


######################################################################
Nr: 16 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData
{
    #region Namespaces
    using System;
    using System.Diagnostics;
    using System.Xml;
    using Microsoft.OData.Edm;
    #endregion Namespaces

    /// <summary>
    /// Utility methods around writing of raw values.
    /// </summary>
    internal static class ODataRawValueUtils
    {
        /// <summary>The characters that are considered to be whitespace by XmlConvert.</summary>
        private static readonly char[] XmlWhitespaceChars = new char[] { ' ', '\t', '\n', '\r' };

        /// <summary>Converts the specified value to a serializable string in ATOM format.</summary>
        /// <param name="value">Non-null value to convert.</param>
        /// <param name="result">The specified value converted to an ATOM string.</param>
        /// <returns>boolean value indicating conversion successful conversion</returns>
        internal static bool TryConvertPrimitiveToString(object value, out string result)
        {
            Debug.Assert(value != null, "value != null");

            if (value is bool)
            {
                result = ODataRawValueConverter.ToString((bool)value);
                return true;
            }

            if (value is byte)
            {
                result = ODataRawValueConverter.ToString((byte)value);
                return true;
            }

            if (value is decimal)
            {
                result = ODataRawValueConverter.ToString((decimal)value);
                return true;
            }

            if (value is double)
            {
                result = ODataRawValueConverter.ToString((double)value);
                return true;
            }

            if (value is Int16)
            {
                result = ODataRawValueConverter.ToString((Int16)value);
                return true;
            }

            if (value is Int32)
            {
                result = ODataRawValueConverter.ToString((Int32)value);
                return true;
            }

            if (value is Int64)
            {
                result = ODataRawValueConverter.ToString((Int64)value);
                return true;
            }

            if (value is SByte)
            {
                result = ODataRawValueConverter.ToString((SByte)value);
                return true;
            }

            var str = value as string;
            if (str != null)
            {
                result = str;
                return true;
            }

            if (value is Single)
            {
                result = ODataRawValueConverter.ToString((Single)value);
                return true;
            }

            byte[] bytes = value as byte[];
            if (bytes != null)
            {
                result = ODataRawValueConverter.ToString(bytes);
                return true;
            }

            if (value is DateTimeOffset)
            {
                result = ODataRawValueConverter.ToString((DateTimeOffset)value);
                return true;
            }

            if (value is Guid)
            {
                result = ODataRawValueConverter.ToString((Guid)value);
                return true;
            }

            if (value is TimeSpan)
            {
                // Edm.Duration
                result = ODataRawValueConverter.ToString((TimeSpan)value);
                return true;
            }

            if (value is Date)
            {
                // Edm.Date
                result = ODataRawValueConverter.ToString((Date)value);
                return true;
            }

            if (value is TimeOfDay)
            {
                // Edm.TimeOfDay
                result = ODataRawValueConverter.ToString((TimeOfDay)value);
                return true;
            }

            result = null;
            return false;
        }

        /// <summary>
        /// Converts a string to a primitive value.
        /// </summary>
        /// <param name="text">The string text to convert.</param>
        /// <param name="targetTypeReference">Type to convert the string to.</param>
        /// <returns>The value converted to the target type.</returns>
        /// <remarks>This method does not convert null value.</remarks>
        internal static object ConvertStringToPrimitive(string text, IEdmPrimitiveTypeReference targetTypeReference)
        {
            Debug.Assert(text != null, "text != null");
            Debug.Assert(targetTypeReference != null, "targetTypeReference != null");

            try
            {
                EdmPrimitiveTypeKind primitiveKind = targetTypeReference.PrimitiveKind();

                switch (primitiveKind)
                {
                    case EdmPrimitiveTypeKind.Binary:
                        return Convert.FromBase64String(text);
                    case EdmPrimitiveTypeKind.Boolean:
                        return ConvertXmlBooleanValue(text);
                    case EdmPrimitiveTypeKind.Byte:
                        return XmlConvert.ToByte(text);
                    case EdmPrimitiveTypeKind.DateTimeOffset:
                        return PlatformHelper.ConvertStringToDateTimeOffset(text);
                    case EdmPrimitiveTypeKind.Decimal:
                        return XmlConvert.ToDecimal(text);
                    case EdmPrimitiveTypeKind.Double:
                        return XmlConvert.ToDouble(text);
                    case EdmPrimitiveTypeKind.Guid:
                        return new Guid(text);
                    case EdmPrimitiveTypeKind.Int16:
                        return XmlConvert.ToInt16(text);
                    case EdmPrimitiveTypeKind.Int32:
                        return XmlConvert.ToInt32(text);
                    case EdmPrimitiveTypeKind.Int64:
                        return XmlConvert.ToInt64(text);
                    case EdmPrimitiveTypeKind.SByte:
                        return XmlConvert.ToSByte(text);
                    case EdmPrimitiveTypeKind.Single:
                        return XmlConvert.ToSingle(text);
                    case EdmPrimitiveTypeKind.String:
                    case EdmPrimitiveTypeKind.PrimitiveType:
                        return text;
                    case EdmPrimitiveTypeKind.Duration:
                        return EdmValueParser.ParseDuration(text);
                    case EdmPrimitiveTypeKind.Date:
                        return PlatformHelper.ConvertStringToDate(text);
                    case EdmPrimitiveTypeKind.TimeOfDay:
                        return PlatformHelper.ConvertStringToTimeOfDay(text);
                    case EdmPrimitiveTypeKind.Stream:
                    case EdmPrimitiveTypeKind.None:
                    case EdmPrimitiveTypeKind.Geography:
                    case EdmPrimitiveTypeKind.GeographyCollection:
                    case EdmPrimitiveTypeKind.GeographyPoint:
                    case EdmPrimitiveTypeKind.GeographyLineString:
                    case EdmPrimitiveTypeKind.GeographyPolygon:
                    case EdmPrimitiveTypeKind.GeometryCollection:
                    case EdmPrimitiveTypeKind.GeographyMultiPolygon:
                    case EdmPrimitiveTypeKind.GeographyMultiLineString:
                    case EdmPrimitiveTypeKind.GeographyMultiPoint:
                    case EdmPrimitiveTypeKind.Geometry:
                    case EdmPrimitiveTypeKind.GeometryPoint:
                    case EdmPrimitiveTypeKind.GeometryLineString:
                    case EdmPrimitiveTypeKind.GeometryPolygon:
                    case EdmPrimitiveTypeKind.GeometryMultiPolygon:
                    case EdmPrimitiveTypeKind.GeometryMultiLineString:
                    case EdmPrimitiveTypeKind.GeometryMultiPoint:
                    default:
                        // Note that Astoria supports XElement and Binary as well, but they are serialized as string or byte[]
                        // and the metadata will actually talk about string and byte[] as well. Astoria will perform the conversion if necessary.
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataRawValueUtils_ConvertStringToPrimitive));
                }
            }
            catch (Exception e)
            {
                if (!ExceptionUtils.IsCatchableExceptionType(e))
                {
                    throw;
                }

                throw ReaderValidationUtils.GetPrimitiveTypeConversionException(targetTypeReference, e, text);
            }
        }

        /// <summary>
        /// Reimplementation of XmlConvert.ToBoolean that accepts 'True' and 'False' in addition
        /// to 'true' and 'false'.
        /// </summary>
        /// <param name="text">The string value read from the Xml reader.</param>
        /// <returns>The converted boolean value.</returns>
        private static bool ConvertXmlBooleanValue(string text)
        {
            text = text.Trim(XmlWhitespaceChars);

            switch (text)
            {
                case "true":
                case "True":
                case "1":
                    return true;

                case "false":
                case "False":
                case "0":
                    return false;

                default:
                    // We know that this will throw; call XmlConvert for the appropriate error message.
                    return XmlConvert.ToBoolean(text);
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData
{
    #region Namespaces
    using System;
    using System.Diagnostics;
    using System.Xml;
    using Microsoft.OData.Edm;
    #endregion Namespaces

    /// <summary>
    /// Utility methods around writing of raw values.
    /// </summary>
    internal static class ODataRawValueUtils
    {
        /// <summary>The characters that are considered to be whitespace by XmlConvert.</summary>
        private static readonly char[] XmlWhitespaceChars = new char[] { ' ', '\t', '\n', '\r' };

        /// <summary>Converts the specified value to a serializable string in ATOM format.</summary>
        /// <param name="value">Non-null value to convert.</param>
        /// <param name="result">The specified value converted to an ATOM string.</param>
        /// <returns>boolean value indicating conversion successful conversion</returns>
        internal static bool TryConvertPrimitiveToString(object value, out string result)
        {
            Debug.Assert(value != null, "value != null");

            if (value is bool b)
            {
                result = ODataRawValueConverter.ToString(b);
                return true;
            }

            if (value is byte b)
            {
                result = ODataRawValueConverter.ToString(b);
                return true;
            }

            if (value is decimal d)
            {
                result = ODataRawValueConverter.ToString(d);
                return true;
            }

            if (value is double d)
            {
                result = ODataRawValueConverter.ToString(d);
                return true;
            }

            if (value is Int16 i)
            {
                result = ODataRawValueConverter.ToString(i);
                return true;
            }

            if (value is Int32 i)
            {
                result = ODataRawValueConverter.ToString(i);
                return true;
            }

            if (value is Int64 i)
            {
                result = ODataRawValueConverter.ToString(i);
                return true;
            }

            if (value is SByte sByte)
            {
                result = ODataRawValueConverter.ToString(sByte);
                return true;
            }

            var str = value as string;
            if (str != null)
            {
                result = str;
                return true;
            }

            if (value is Single single)
            {
                result = ODataRawValueConverter.ToString(single);
                return true;
            }

            byte[] bytes = value as byte[];
            if (bytes != null)
            {
                result = ODataRawValueConverter.ToString(bytes);
                return true;
            }

            if (value is DateTimeOffset dateTimeOffset)
            {
                result = ODataRawValueConverter.ToString(dateTimeOffset);
                return true;
            }

            if (value is Guid guid)
            {
                result = ODataRawValueConverter.ToString(guid);
                return true;
            }

            if (value is TimeSpan timeSpan)
            {
                // Edm.Duration
                result = ODataRawValueConverter.ToString(timeSpan);
                return true;
            }

            if (value is Date date)
            {
                // Edm.Date
                result = ODataRawValueConverter.ToString(date);
                return true;
            }

            if (value is TimeOfDay timeOfDay)
            {
                // Edm.TimeOfDay
                result = ODataRawValueConverter.ToString(timeOfDay);
                return true;
            }

            result = null;
            return false;
        }

        /// <summary>
        /// Converts a string to a primitive value.
        /// </summary>
        /// <param name="text">The string text to convert.</param>
        /// <param name="targetTypeReference">Type to convert the string to.</param>
        /// <returns>The value converted to the target type.</returns>
        /// <remarks>This method does not convert null value.</remarks>
        internal static object ConvertStringToPrimitive(string text, IEdmPrimitiveTypeReference targetTypeReference)
        {
            Debug.Assert(text != null, "text != null");
            Debug.Assert(targetTypeReference != null, "targetTypeReference != null");

            try
            {
                EdmPrimitiveTypeKind primitiveKind = targetTypeReference.PrimitiveKind();

                switch (primitiveKind)
                {
                    case EdmPrimitiveTypeKind.Binary:
                        return Convert.FromBase64String(text);
                    case EdmPrimitiveTypeKind.Boolean:
                        return ConvertXmlBooleanValue(text);
                    case EdmPrimitiveTypeKind.Byte:
                        return XmlConvert.ToByte(text);
                    case EdmPrimitiveTypeKind.DateTimeOffset:
                        return PlatformHelper.ConvertStringToDateTimeOffset(text);
                    case EdmPrimitiveTypeKind.Decimal:
                        return XmlConvert.ToDecimal(text);
                    case EdmPrimitiveTypeKind.Double:
                        return XmlConvert.ToDouble(text);
                    case EdmPrimitiveTypeKind.Guid:
                        return new Guid(text);
                    case EdmPrimitiveTypeKind.Int16:
                        return XmlConvert.ToInt16(text);
                    case EdmPrimitiveTypeKind.Int32:
                        return XmlConvert.ToInt32(text);
                    case EdmPrimitiveTypeKind.Int64:
                        return XmlConvert.ToInt64(text);
                    case EdmPrimitiveTypeKind.SByte:
                        return XmlConvert.ToSByte(text);
                    case EdmPrimitiveTypeKind.Single:
                        return XmlConvert.ToSingle(text);
                    case EdmPrimitiveTypeKind.String:
                    case EdmPrimitiveTypeKind.PrimitiveType:
                        return text;
                    case EdmPrimitiveTypeKind.Duration:
                        return EdmValueParser.ParseDuration(text);
                    case EdmPrimitiveTypeKind.Date:
                        return PlatformHelper.ConvertStringToDate(text);
                    case EdmPrimitiveTypeKind.TimeOfDay:
                        return PlatformHelper.ConvertStringToTimeOfDay(text);
                    case EdmPrimitiveTypeKind.Stream:
                    case EdmPrimitiveTypeKind.None:
                    case EdmPrimitiveTypeKind.Geography:
                    case EdmPrimitiveTypeKind.GeographyCollection:
                    case EdmPrimitiveTypeKind.GeographyPoint:
                    case EdmPrimitiveTypeKind.GeographyLineString:
                    case EdmPrimitiveTypeKind.GeographyPolygon:
                    case EdmPrimitiveTypeKind.GeometryCollection:
                    case EdmPrimitiveTypeKind.GeographyMultiPolygon:
                    case EdmPrimitiveTypeKind.GeographyMultiLineString:
                    case EdmPrimitiveTypeKind.GeographyMultiPoint:
                    case EdmPrimitiveTypeKind.Geometry:
                    case EdmPrimitiveTypeKind.GeometryPoint:
                    case EdmPrimitiveTypeKind.GeometryLineString:
                    case EdmPrimitiveTypeKind.GeometryPolygon:
                    case EdmPrimitiveTypeKind.GeometryMultiPolygon:
                    case EdmPrimitiveTypeKind.GeometryMultiLineString:
                    case EdmPrimitiveTypeKind.GeometryMultiPoint:
                    default:
                        // Note that Astoria supports XElement and Binary as well, but they are serialized as string or byte[]
                        // and the metadata will actually talk about string and byte[] as well. Astoria will perform the conversion if necessary.
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataRawValueUtils_ConvertStringToPrimitive));
                }
            }
            catch (Exception e)
            {
                if (!ExceptionUtils.IsCatchableExceptionType(e))
                {
                    throw;
                }

                throw ReaderValidationUtils.GetPrimitiveTypeConversionException(targetTypeReference, e, text);
            }
        }

        /// <summary>
        /// Reimplementation of XmlConvert.ToBoolean that accepts 'True' and 'False' in addition
        /// to 'true' and 'false'.
        /// </summary>
        /// <param name="text">The string value read from the Xml reader.</param>
        /// <returns>The converted boolean value.</returns>
        private static bool ConvertXmlBooleanValue(string text)
        {
            text = text.Trim(XmlWhitespaceChars);

            switch (text)
            {
                case "true":
                case "True":
                case "1":
                    return true;

                case "false":
                case "False":
                case "0":
                    return false;

                default:
                    // We know that this will throw; call XmlConvert for the appropriate error message.
                    return XmlConvert.ToBoolean(text);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(38,31): error CS0128: A local variable or function named 'b' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(50,33): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(62,32): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(68,32): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(40,58): error CS0165: Use of unassigned local variable 'b',D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(52,58): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\src\Microsoft.OData.Core\ODataRawValueUtils.cs(64,58): error CS0165: Use of unassigned local variable 'i'
######################################################################


######################################################################
Nr: 17 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\ODataReaderCore.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData
{
    #region Namespaces
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;

    #endregion Namespaces

    /// <summary>
    /// Base class for OData readers that verifies a proper sequence of read calls on the reader.
    /// </summary>
    internal abstract class ODataReaderCore : ODataReader, IODataStreamListener
    {
        /// <summary>The input to read the payload from.</summary>
        private readonly ODataInputContext inputContext;

        /// <summary>true if the reader is created for reading a resource set; false when it is created for reading a resource.</summary>
        private readonly bool readingResourceSet;

        /// <summary>true if the reader is created for reading expanded navigation property in delta response; false otherwise.</summary>
        private readonly bool readingDelta;

        /// <summary>Stack of reader scopes to keep track of the current context of the reader.</summary>
        private readonly Stack<Scope> scopes = new Stack<Scope>();

        /// <summary>If not null, the reader will notify the implementer of the interface of relevant state changes in the reader.</summary>
        private readonly IODataReaderWriterListener listener;

        /// <summary>The number of entries which have been started but not yet ended.</summary>
        private int currentResourceDepth;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="inputContext">The input to read the payload from.</param>
        /// <param name="readingResourceSet">true if the reader is created for reading a resource set; false when it is created for reading a resource.</param>
        /// <param name="readingDelta">true if the reader is created for reading expanded navigation property in delta response; false otherwise.</param>
        /// <param name="listener">If not null, the reader will notify the implementer of the interface of relevant state changes in the reader.</param>
        protected ODataReaderCore(
            ODataInputContext inputContext,
            bool readingResourceSet,
            bool readingDelta,
            IODataReaderWriterListener listener)
        {
            Debug.Assert(inputContext != null, "inputContext != null");

            this.inputContext = inputContext;
            this.readingResourceSet = readingResourceSet;
            this.readingDelta = readingDelta;
            this.listener = listener;
            this.currentResourceDepth = 0;
            this.Version = inputContext.MessageReaderSettings.Version;
        }

        /// <summary>
        /// Enum used to describe the current state of the stream.
        /// </summary>
        internal enum StreamingState
        {
            None = 0,
            Streaming,
            Completed
        }

        /// <summary>
        /// The current state of the reader.
        /// </summary>
        public override sealed ODataReaderState State
        {
            get
            {
                this.inputContext.VerifyNotDisposed();
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek().State;
            }
        }

        /// <summary>
        /// The most recent <see cref="ODataItem"/> that has been read.
        /// </summary>
        public override sealed ODataItem Item
        {
            get
            {
                this.inputContext.VerifyNotDisposed();
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek().Item;
            }
        }

        /// <summary>
        /// OData Version being read.
        /// </summary>
        internal ODataVersion? Version { get; }

        /// <summary>
        /// Returns the current item as <see cref="ODataResourceSet"/>. Must only be called if the item actually is a resource set.
        /// </summary>
        protected ODataResourceSet CurrentResourceSet
        {
            get
            {
                Debug.Assert(this.Item is ODataResourceSet, "this.Item is ODataResourceSet");
                return (ODataResourceSet)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataDeltaResourceSet"/>. Must only be called if the item actually is a delta resource set.
        /// </summary>
        protected ODataDeltaResourceSet CurrentDeltaResourceSet
        {
            get
            {
                Debug.Assert(this.Item is ODataDeltaResourceSet, "this.Item is ODataDeltaResourceSet");
                return (ODataDeltaResourceSet)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as ODataDeltaLink
        /// </summary>
        protected ODataDeltaLink CurrentDeltaLink
        {
            get
            {
                Debug.Assert(this.Item == null || this.Item is ODataDeltaLink, "this.Item is ODataDeltaLink");
                return (ODataDeltaLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as ODataDeltaDeletedLink.
        /// </summary>
        protected ODataDeltaDeletedLink CurrentDeltaDeletedLink
        {
            get
            {
                Debug.Assert(this.Item == null || this.Item is ODataDeltaDeletedLink, "this.Item is ODataDeltaDeletedLink");
                return (ODataDeltaDeletedLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the current resource depth.
        /// </summary>
        protected int CurrentResourceDepth
        {
            get
            {
                return this.currentResourceDepth;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataNestedResourceInfo"/>. Must only be called if the item actually is a nested resource info.
        /// </summary>
        protected ODataNestedResourceInfo CurrentNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.Item is ODataNestedResourceInfo, "this.Item is ODataNestedResourceInfo");
                return (ODataNestedResourceInfo)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataEntityReferenceLink"/>. Must only be called if the item actually is an entity reference link.
        /// </summary>
        protected ODataEntityReferenceLink CurrentEntityReferenceLink
        {
            get
            {
                Debug.Assert(this.Item is ODataEntityReferenceLink, "this.Item is ODataEntityReferenceLink");
                return (ODataEntityReferenceLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the expected resource type for the current scope.
        /// </summary>
        protected IEdmType CurrentResourceType
        {
            get
            {
                if (CurrentResourceTypeReference != null)
                {
                    return CurrentResourceTypeReference.Definition;
                }

                return null;
            }
        }

        /// <summary>
        /// Gets and Sets the expected resource type reference for the current scope.
        /// </summary>
        protected IEdmTypeReference CurrentResourceTypeReference
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                IEdmTypeReference resourceTypeReference = this.scopes.Peek().ResourceTypeReference;
                Debug.Assert(resourceTypeReference == null || this.inputContext.Model.IsUserModel(), "We can only have structured type if we also have metadata.");

                return resourceTypeReference;
            }

            set
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                this.scopes.Peek().ResourceTypeReference = value;
            }
        }

        /// <summary>
        /// Returns the navigation source for the current scope.
        /// </summary>
        protected IEdmNavigationSource CurrentNavigationSource
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                IEdmNavigationSource navigationSource = this.scopes.Peek().NavigationSource;
                Debug.Assert(navigationSource == null || this.inputContext.Model.IsUserModel(), "We can only have navigation source if we also have metadata.");
                return navigationSource;
            }
        }

        /// <summary>
        /// Returns the current scope.
        /// </summary>
        protected Scope CurrentScope
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek();
            }
        }

        protected Stack<Scope> Scopes
        {
            get { return this.scopes; }
        }

        /// <summary>
        /// Returns the parent scope.
        /// </summary>
        protected Scope ParentScope
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 1, "We must have at least two scopes in the stack.");
                return this.scopes.Skip(1).First();
            }
        }

        /// <summary>
        /// A flag indicating whether the reader is at the top level.
        /// </summary>
        protected bool IsTopLevel
        {
            get
            {
                Debug.Assert(this.scopes != null, "Scopes must exist.");

                // there is the root scope at the top (when the writer has not started or has completed)
                // and then the top-level scope (the top-level resource/resource set item) as the second scope on the stack
                return this.scopes.Count <= 2;
            }
        }

        /// <summary>
        /// If the current scope is a content of an expanded link, this returns the parent nested resource info scope, otherwise null.
        /// </summary>
        protected Scope ExpandedLinkContentParentScope
        {
            get
            {
                Debug.Assert(this.scopes != null, "this.scopes != null");
                if (this.scopes.Count > 1)
                {
                    Scope parentScope = this.scopes.Skip(1).First();
                    if (parentScope.State == ODataReaderState.NestedResourceInfoStart)
                    {
                        return parentScope;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// True if we are reading a resource or resource set that is the direct content of an expanded link. Otherwise false.
        /// </summary>
        protected bool IsExpandedLinkContent
        {
            get
            {
                return this.ExpandedLinkContentParentScope != null;
            }
        }

        /// <summary>
        /// Set to true if a resource set is being read.
        /// </summary>
        protected bool ReadingResourceSet
        {
            get
            {
                return this.readingResourceSet;
            }
        }

        /// <summary>
        /// Set to true if a delta response is being read.
        /// </summary>
        protected bool ReadingDelta
        {
            get
            {
                return this.readingDelta;
            }
        }

        /// <summary>
        /// Returns true if we are reading a nested payload,
        /// e.g. an expanded resource or resource set within a delta payload,
        /// or a resource or a resource set within a parameters payload.
        /// </summary>
        protected bool IsReadingNestedPayload
        {
            get
            {
                return this.listener != null;
            }
        }

        /// <summary>
        /// Validator to validate consistency of entries in top-level resource sets.
        /// </summary>
        /// <remarks>We only use this for top-level resource sets since we support collection validation for
        /// resource sets only when metadata is available and in these cases we already validate the
        /// types of the entries in nested resource sets.</remarks>
        protected ResourceSetWithoutExpectedTypeValidator CurrentResourceSetValidator
        {
            get
            {
                Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "CurrentResourceSetValidator should only be called while reading a resource.");
                return this.ParentScope == null ? null : this.ParentScope.ResourceTypeValidator;
            }
        }

        /// <summary>
        /// Validator to validate the derived type constraint.
        /// </summary>
        protected DerivedTypeValidator CurrentDerivedTypeValidator
        {
            get
            {
                Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "CurrentDerivedTypeValidator should only be called while reading a resource.");
                return this.ParentScope == null ? null : this.ParentScope.DerivedTypeValidator;
            }
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        public override sealed bool Read()
        {
            this.VerifyCanRead(true);
            return this.InterceptException(this.ReadSynchronously);
        }

        /// <summary>
        /// Asynchronously reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>A task that when completed indicates whether more items were read.</returns>
        public override sealed Task<bool> ReadAsync()
        {
            this.VerifyCanRead(false);
            return this.ReadAsynchronously().FollowOnFaultWith(t => this.EnterScope(new Scope(ODataReaderState.Exception, null, null)));
        }

        /// <summary>
        /// Creates a stream for reading an inline stream property.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        public override sealed Stream CreateReadStream()
        {
            if (this.State != ODataReaderState.Stream)
            {
                throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
            }

            StreamScope scope = this.CurrentScope as StreamScope;
            Debug.Assert(scope != null, "ODataReaderState.Stream when Scope is not a StreamScope");
            if (scope.StreamingState != StreamingState.None)
            {
                throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
            }

            scope.StreamingState = StreamingState.Streaming;
            return new ODataNotificationStream(this.InterceptException(this.CreateReadStreamImplementation), this);
        }

        /// <summary>
        /// Creates a TextWriter for reading an inline stream property.
        /// </summary>
        /// <returns>A TextWriter for reading the stream property.</returns>
        public override sealed TextReader CreateTextReader()
        {
            if (this.State == ODataReaderState.Stream)
            {
                StreamScope scope = this.CurrentScope as StreamScope;
                Debug.Assert(scope != null, "ODataReaderState.Stream when Scope is not a StreamScope");
                if (scope.StreamingState != StreamingState.None)
                {
                    throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
                }

                scope.StreamingState = StreamingState.Streaming;
                return new ODataNotificationReader(this.InterceptException(this.CreateTextReaderImplementation), this);
            }
            else
            {
                throw new ODataException(Strings.ODataReaderCore_CreateTextReaderCalledInInvalidState);
            }
        }

        /// <summary>
        /// This method is called when a stream is requested. It is a no-op.
        /// </summary>
        void IODataStreamListener.StreamRequested()
        {
        }

        /// <summary>
        /// This method is called when an async stream is requested. It is a no-op.
        /// </summary>
        /// <returns>A task for method called when a stream is requested.</returns>
        Task IODataStreamListener.StreamRequestedAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation(() => ((IODataStreamListener)this).StreamRequested());
        }

        /// <summary>
        /// This method is called when a stream is disposed.
        /// </summary>
        void IODataStreamListener.StreamDisposed()
        {
            Debug.Assert(this.State == ODataReaderState.Stream, "Stream was disposed when not in ReaderState.Stream state.");
            StreamScope scope = this.CurrentScope as StreamScope;
            Debug.Assert(scope != null, "Stream disposed when not in stream scope");
            Debug.Assert(scope.StreamingState == StreamingState.Streaming, "StreamDisposed called when reader was not streaming");
            scope.StreamingState = StreamingState.Completed;
        }

        /// <summary>
        /// Seek scope in the stack which is type of <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type of scope to seek.</typeparam>
        /// <param name="maxDepth">The max depth to seek.</param>
        /// <returns>The scope with type of <typeparamref name="T"/></returns>
        internal Scope SeekScope<T>(int maxDepth) where T : Scope
        {
            int count = 1;

            foreach (Scope scope in this.scopes)
            {
                if (count > maxDepth)
                {
                    return null;
                }

                if (scope is T)
                {
                    return scope;
                }

                count++;
            }

            return null;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceSetStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceSetEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtPrimitiveImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtNestedPropertyInfoImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtStreamImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a Stream for reading a stream property when in state 'Stream'.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        protected virtual Stream CreateReadStreamImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a TextReader for reading a string property when in state 'Text'.
        /// </summary>
        /// <returns>A TextReader for reading the string property.</returns>
        protected virtual TextReader CreateTextReaderImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtNestedResourceInfoStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtNestedResourceInfoEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtEntityReferenceLink();

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaResourceSetStartImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaResourceSetEndImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeletedResourceStartImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeletedResourceEndImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaLinkImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaDeletedLinkImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Pushes the <paramref name="scope"/> on the stack of scopes.
        /// </summary>
        /// <param name="scope">The scope to enter.</param>
        protected void EnterScope(Scope scope)
        {
            Debug.Assert(scope != null, "scope != null");

            if ((scope.State == ODataReaderState.ResourceSetStart || scope.State == ODataReaderState.DeltaResourceSetStart)
                && this.inputContext.Model.IsUserModel())
            {
                scope.ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(scope.ResourceType);
            }

            if (scope.State == ODataReaderState.ResourceSetStart || scope.State == ODataReaderState.DeltaResourceSetStart)
            {
                scope.DerivedTypeValidator = this.CurrentScope.DerivedTypeValidator;
            }

            // TODO: implement some basic validation that the transitions are ok
            this.scopes.Push(scope);
            if (this.listener != null)
            {
                if (scope.State == ODataReaderState.Exception)
                {
                    this.listener.OnException();
                }
                else if (scope.State == ODataReaderState.Completed)
                {
                    this.listener.OnCompleted();
                }
            }
        }

        /// <summary>
        /// Replaces the current scope with the specified <paramref name="scope"/>.
        /// </summary>
        /// <param name="scope">The scope to replace the current scope with.</param>
        protected void ReplaceScope(Scope scope)
        {
            Debug.Assert(this.scopes.Count > 0, "Stack must always be non-empty.");
            Debug.Assert(scope != null, "scope != null");
            Debug.Assert(scope.State != ODataReaderState.ResourceEnd, "Call EndEntry instead.");

            // TODO: implement some basic validation that the transitions are ok
            this.scopes.Pop();
            this.EnterScope(scope);
        }

        /// <summary>
        /// Removes the current scope from the stack of all scopes.
        /// </summary>
        /// <param name="state">The expected state of the current scope (to be popped).</param>
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "state", Justification = "Used in debug builds in assertions.")]
        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "scope", Justification = "Used in debug builds in assertions.")]
        protected void PopScope(ODataReaderState state)
        {
            Debug.Assert(this.scopes.Count > 1, "Stack must have more than 1 items in order to pop an item.");

            Scope scope = this.scopes.Pop();
            Debug.Assert(scope.State == state, "scope.State == state");
        }

        /// <summary>
        /// Called to transition into the EntryEnd state.
        /// </summary>
        /// <param name="scope">The scope for the EntryEnd state.</param>
        protected void EndEntry(Scope scope)
        {
            Debug.Assert(this.scopes.Count > 0, "Stack must always be non-empty.");
            Debug.Assert(scope != null, "scope != null");
            Debug.Assert(scope.State == ODataReaderState.ResourceEnd | scope.State == ODataReaderState.DeletedResourceEnd, "Called EndEntry when not in ResourceEnd or DeletedResourceEnd state");

            this.scopes.Pop();
            this.EnterScope(scope);
        }

        /// <summary>
        /// If an entity type name is found in the payload this method is called to apply it to the current scope.
        /// This method should be called even if the type name was not found in which case a null should be passed in.
        /// The method validates that some type will be available as the current entity type after it returns (if we are parsing using metadata).
        /// </summary>
        /// <param name="resourceTypeNameFromPayload">The entity type name found in the payload or null if no type was specified in the payload.</param>
        protected void ApplyResourceTypeNameFromPayload(string resourceTypeNameFromPayload)
        {
            Debug.Assert(
                this.scopes.Count > 0 && this.scopes.Peek().Item is ODataResourceBase,
                "Resource type can be applied only when in resource scope.");

            ODataTypeAnnotation typeAnnotation;
            EdmTypeKind targetTypeKind;
            IEdmStructuredTypeReference targetResourceTypeReference =
                this.inputContext.MessageReaderSettings.Validator.ResolvePayloadTypeNameAndComputeTargetType(
                    EdmTypeKind.None,
                    /*expectStructuredType*/ true,
                    /*defaultPrimitivePayloadType*/ null,
                    this.CurrentResourceTypeReference,
                    resourceTypeNameFromPayload,
                    this.inputContext.Model,
                    () => EdmTypeKind.Entity,
                    out targetTypeKind,
                    out typeAnnotation) as IEdmStructuredTypeReference;

            IEdmStructuredType targetResourceType = null;
            ODataResourceBase resource = this.Item as ODataResourceBase;
            if (targetResourceTypeReference != null)
            {
                targetResourceType = targetResourceTypeReference.StructuredDefinition();
                resource.TypeName = targetResourceType.FullTypeName();

                if (typeAnnotation != null)
                {
                    resource.TypeAnnotation = typeAnnotation;
                }
            }
            else if (resourceTypeNameFromPayload != null)
            {
                resource.TypeName = resourceTypeNameFromPayload;
            }
            else if (this.CurrentResourceTypeReference.IsUntyped())
            {
                targetResourceTypeReference = this.CurrentResourceTypeReference.IsNullable ?
                    EdmUntypedStructuredTypeReference.NullableTypeReference : 
                    EdmUntypedStructuredTypeReference.NonNullableTypeReference;
            }

            // Set the current resource type since the type might be derived from the expected one.
            this.CurrentResourceTypeReference = targetResourceTypeReference;
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        protected bool ReadSynchronously()
        {
            return this.ReadImplementation();
        }

        /// <summary>
        /// Asynchronously reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>A task that when completed indicates whether more items were read.</returns>
        protected virtual Task<bool> ReadAsynchronously()
        {
            // We are reading from the fully buffered read stream here; thus it is ok
            // to use synchronous reads and then return a completed task
            // NOTE: once we switch to fully async reading this will have to change
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadImplementation);
        }

        /// <summary>
        /// Increments the nested resource count by one and fails if the new value exceeds the maxium nested resource depth limit.
        /// </summary>
        protected void IncreaseResourceDepth()
        {
            this.currentResourceDepth++;

            if (this.currentResourceDepth > this.inputContext.MessageReaderSettings.MessageQuotas.MaxNestingDepth)
            {
                throw new ODataException(Strings.ValidationUtils_MaxDepthOfNestedEntriesExceeded(this.inputContext.MessageReaderSettings.MessageQuotas.MaxNestingDepth));
            }
        }

        /// <summary>
        /// Decrements the nested resource count by one.
        /// </summary>
        protected void DecreaseResourceDepth()
        {
            Debug.Assert(this.currentResourceDepth > 0, "Resource depth should never become negative.");

            this.currentResourceDepth--;
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        private bool ReadImplementation()
        {
            bool result;
            switch (this.State)
            {
                case ODataReaderState.Start:
                    result = this.ReadAtStartImplementation();
                    break;

                case ODataReaderState.ResourceSetStart:
                    result = this.ReadAtResourceSetStartImplementation();
                    break;

                case ODataReaderState.ResourceSetEnd:
                    result = this.ReadAtResourceSetEndImplementation();
                    break;

                case ODataReaderState.ResourceStart:
                    this.IncreaseResourceDepth();
                    result = this.ReadAtResourceStartImplementation();
                    break;

                case ODataReaderState.ResourceEnd:
                    this.DecreaseResourceDepth();
                    result = this.ReadAtResourceEndImplementation();
                    break;

                case ODataReaderState.Primitive:
                    result = this.ReadAtPrimitiveImplementation();
                    break;

                case ODataReaderState.Stream:
                    result = this.ReadAtStreamImplementation();
                    break;

                case ODataReaderState.NestedProperty:
                    result = this.ReadAtNestedPropertyInfoImplementation();
                    break;

                case ODataReaderState.NestedResourceInfoStart:
                    result = this.ReadAtNestedResourceInfoStartImplementation();
                    break;

                case ODataReaderState.NestedResourceInfoEnd:
                    result = this.ReadAtNestedResourceInfoEndImplementation();
                    break;

                case ODataReaderState.EntityReferenceLink:
                    result = this.ReadAtEntityReferenceLink();
                    break;

                case ODataReaderState.DeltaResourceSetStart:
                    result = this.ReadAtDeltaResourceSetStartImplementation();
                    break;

                case ODataReaderState.DeltaResourceSetEnd:
                    result = this.ReadAtDeltaResourceSetEndImplementation();
                    break;

                case ODataReaderState.DeletedResourceStart:
                    result = this.ReadAtDeletedResourceStartImplementation();
                    break;

                case ODataReaderState.DeletedResourceEnd:
                    result = this.ReadAtDeletedResourceEndImplementation();
                    break;

                case ODataReaderState.DeltaLink:
                    result = this.ReadAtDeltaLinkImplementation();
                    break;

                case ODataReaderState.DeltaDeletedLink:
                    result = this.ReadAtDeltaDeletedLinkImplementation();
                    break;

                case ODataReaderState.Exception:    // fall through
                case ODataReaderState.Completed:
                    throw new ODataException(Strings.ODataReaderCore_NoReadCallsAllowed(this.State));

                default:
                    Debug.Assert(false, "Unsupported reader state " + this.State + " detected.");
                    throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataReaderCore_ReadImplementation));
            }

            return result;
        }

        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the reader into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <typeparam name="T">The type returned from the <paramref name="action"/> to execute.</typeparam>
        /// <param name="action">The action to execute.</param>
        /// <returns>The result of executing the <paramref name="action"/>.</returns>
        private T InterceptException<T>(Func<T> action)
        {
            try
            {
                return action();
            }
            catch (Exception e)
            {
                if (ExceptionUtils.IsCatchableExceptionType(e))
                {
                    this.EnterScope(new Scope(ODataReaderState.Exception, null, null));
                }

                throw;
            }
        }

        /// <summary>
        /// Verifies that calling Read is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanRead(bool synchronousCall)
        {
            this.inputContext.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);

            if (this.State == ODataReaderState.Exception || this.State == ODataReaderState.Completed)
            {
                throw new ODataException(Strings.ODataReaderCore_ReadOrReadAsyncCalledInInvalidState(this.State));
            }

            if (this.State == ODataReaderState.Stream)
            {
                StreamScope scope = this.CurrentScope as StreamScope;
                Debug.Assert(scope != null, "In stream state without a stream scope");
                if (scope.StreamingState != StreamingState.Completed)
                {
                    throw new ODataException(Strings.ODataReaderCore_ReadCalledWithOpenStream);
                }
            }
        }

        /// <summary>
        /// Verifies that a call is allowed to the reader.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCallAllowed(bool synchronousCall)
        {
            if (synchronousCall)
            {
                if (!this.inputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataReaderCore_SyncCallOnAsyncReader);
                }
            }
            else
            {
                if (this.inputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataReaderCore_AsyncCallOnSyncReader);
                }
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        protected internal class Scope
        {
            /// <summary>The reader state of this scope.</summary>
            private readonly ODataReaderState state;

            /// <summary>The item attached to this scope.</summary>
            private readonly ODataItem item;

            /// <summary>The odataUri parsed based on the context uri attached to this scope.</summary>
            private readonly ODataUri odataUri;

            /// <summary>
            /// The <see cref="ResourceSetWithoutExpectedTypeValidator"/> to use for entries in this resourceSet.
            /// </summary>
            private ResourceSetWithoutExpectedTypeValidator resourceTypeValidator;

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
            internal Scope(ODataReaderState state, ODataItem item, ODataUri odataUri)
            {
                Debug.Assert(
                    state == ODataReaderState.Exception && item == null ||
                    state == ODataReaderState.ResourceStart && (item == null || item is ODataResource) ||
                    state == ODataReaderState.ResourceEnd && (item is ODataResource || item == null) ||
                    state == ODataReaderState.Primitive && (item == null || item is ODataPrimitiveValue || item is ODataNullValue) ||
                    state == ODataReaderState.Stream && (item == null || item is ODataStreamItem) ||
                    state == ODataReaderState.NestedProperty && (item == null || item is ODataPropertyInfo) ||
                    state == ODataReaderState.ResourceSetStart && item is ODataResourceSet ||
                    state == ODataReaderState.ResourceSetEnd && item is ODataResourceSet ||
                    state == ODataReaderState.NestedResourceInfoStart && item is ODataNestedResourceInfo ||
                    state == ODataReaderState.NestedResourceInfoEnd && item is ODataNestedResourceInfo ||
                    state == ODataReaderState.EntityReferenceLink && item is ODataEntityReferenceLink ||
                    state == ODataReaderState.DeletedResourceStart && (item == null || item is ODataDeletedResource) ||
                    state == ODataReaderState.DeletedResourceEnd && (item is ODataDeletedResource || item == null) ||
                    state == ODataReaderState.DeltaResourceSetStart && item is ODataDeltaResourceSet ||
                    state == ODataReaderState.DeltaResourceSetEnd && item is ODataDeltaResourceSet ||
                    state == ODataReaderState.DeltaLink && (item == null || item is ODataDeltaLink) ||
                    state == ODataReaderState.DeltaDeletedLink && (item == null || item is ODataDeltaDeletedLink) ||
                    state == ODataReaderState.Start && item == null ||
                    state == ODataReaderState.Completed && item == null,
                    "Reader state and associated item do not match.");

                this.state = state;
                this.item = item;
                this.odataUri = odataUri;
            }

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceTypeReference">The expected resource type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meanings for given state:
            /// Start -               it's the expected base type reference of the top-level resource or resources in the top-level resource set.
            /// ResourceSetStart -           it's the expected base type reference of the resources in the resource set.
            ///                       note that it might be a more derived type than the base type of the entity set for the resource set.
            /// EntryStart -          it's the expected base type reference of the resource. If the resource has no type name specified
            ///                       this type will be assumed. Otherwise the specified type name must be
            ///                       the expected type or a more derived type.
            /// NestedResourceInfoStart - it's the expected base type reference the entries in the expanded link (either the single resource
            ///                       or entries in the expanded resource set).
            /// EntityReferenceLink - it's null, no need for types on entity reference links.
            /// In all cases the specified type must be an structured type.</remarks>
            [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
            internal Scope(ODataReaderState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceTypeReference, ODataUri odataUri)
                : this(state, item, odataUri)
            {
                this.NavigationSource = navigationSource;
                this.ResourceTypeReference = expectedResourceTypeReference;
            }

            /// <summary>
            /// The reader state of this scope.
            /// </summary>
            internal ODataReaderState State
            {
                get
                {
                    return this.state;
                }
            }

            /// <summary>
            /// The item attached to this scope.
            /// </summary>
            internal ODataItem Item
            {
                get
                {
                    return this.item;
                }
            }

            /// <summary>
            /// The odataUri parsed based on the context url to this scope.
            /// </summary>
            internal ODataUri ODataUri
            {
                get
                {
                    return this.odataUri;
                }
            }

            /// <summary>
            /// The navigation source we are reading entries from (possibly null).
            /// </summary>
            internal IEdmNavigationSource NavigationSource { get; set; }

            /// <summary>
            /// The resource type for this scope. Can be either the expected one if the real one
            /// was not found yet, or the one specified in the payload itself (the real one).
            /// </summary>
            internal IEdmType ResourceType
            {
                get
                {
                    if (this.ResourceTypeReference != null)
                    {
                        return ResourceTypeReference.Definition;
                    }

                    return null;
                }
            }

            /// <summary>
            /// The resource type reference for this scope. Can be either the expected one if the real one
            /// was not found yet, or the one specified in the payload itself (the real one).
            /// </summary>
            internal IEdmTypeReference ResourceTypeReference { get; set; }

            /// <summary>
            /// Validator for resource type.
            /// </summary>
            internal ResourceSetWithoutExpectedTypeValidator ResourceTypeValidator
            {
                get
                {
                    return this.resourceTypeValidator;
                }

                set
                {
                    this.resourceTypeValidator = value;
                }
            }

            /// <summary>
            /// Gets or sets the derived type constraint validator.
            /// </summary>
            internal DerivedTypeValidator DerivedTypeValidator { get; set; }
        }

        protected internal class StreamScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceType">The expected resource type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal StreamScope(ODataReaderState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceType, ODataUri odataUri)
                : base(state, item, navigationSource, expectedResourceType, odataUri)
            {
                this.StreamingState = StreamingState.None;
            }

            /// <summary>
            /// Current state of the stream.
            /// </summary>
            internal StreamingState StreamingState { get; set; }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData
{
    #region Namespaces
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.OData.Edm;
    using Microsoft.OData.Metadata;

    #endregion Namespaces

    /// <summary>
    /// Base class for OData readers that verifies a proper sequence of read calls on the reader.
    /// </summary>
    internal abstract class ODataReaderCore : ODataReader, IODataStreamListener
    {
        /// <summary>The input to read the payload from.</summary>
        private readonly ODataInputContext inputContext;

        /// <summary>true if the reader is created for reading a resource set; false when it is created for reading a resource.</summary>
        private readonly bool readingResourceSet;

        /// <summary>true if the reader is created for reading expanded navigation property in delta response; false otherwise.</summary>
        private readonly bool readingDelta;

        /// <summary>Stack of reader scopes to keep track of the current context of the reader.</summary>
        private readonly Stack<Scope> scopes = new Stack<Scope>();

        /// <summary>If not null, the reader will notify the implementer of the interface of relevant state changes in the reader.</summary>
        private readonly IODataReaderWriterListener listener;

        /// <summary>The number of entries which have been started but not yet ended.</summary>
        private int currentResourceDepth;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="inputContext">The input to read the payload from.</param>
        /// <param name="readingResourceSet">true if the reader is created for reading a resource set; false when it is created for reading a resource.</param>
        /// <param name="readingDelta">true if the reader is created for reading expanded navigation property in delta response; false otherwise.</param>
        /// <param name="listener">If not null, the reader will notify the implementer of the interface of relevant state changes in the reader.</param>
        protected ODataReaderCore(
            ODataInputContext inputContext,
            bool readingResourceSet,
            bool readingDelta,
            IODataReaderWriterListener listener)
        {
            Debug.Assert(inputContext != null, "inputContext != null");

            this.inputContext = inputContext;
            this.readingResourceSet = readingResourceSet;
            this.readingDelta = readingDelta;
            this.listener = listener;
            this.currentResourceDepth = 0;
            this.Version = inputContext.MessageReaderSettings.Version;
        }

        /// <summary>
        /// Enum used to describe the current state of the stream.
        /// </summary>
        internal enum StreamingState
        {
            None = 0,
            Streaming,
            Completed
        }

        /// <summary>
        /// The current state of the reader.
        /// </summary>
        public override sealed ODataReaderState State
        {
            get
            {
                this.inputContext.VerifyNotDisposed();
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek().State;
            }
        }

        /// <summary>
        /// The most recent <see cref="ODataItem"/> that has been read.
        /// </summary>
        public override sealed ODataItem Item
        {
            get
            {
                this.inputContext.VerifyNotDisposed();
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek().Item;
            }
        }

        /// <summary>
        /// OData Version being read.
        /// </summary>
        internal ODataVersion? Version { get; }

        /// <summary>
        /// Returns the current item as <see cref="ODataResourceSet"/>. Must only be called if the item actually is a resource set.
        /// </summary>
        protected ODataResourceSet CurrentResourceSet
        {
            get
            {
                Debug.Assert(this.Item is ODataResourceSet, "this.Item is ODataResourceSet");
                return (ODataResourceSet)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataDeltaResourceSet"/>. Must only be called if the item actually is a delta resource set.
        /// </summary>
        protected ODataDeltaResourceSet CurrentDeltaResourceSet
        {
            get
            {
                Debug.Assert(this.Item is ODataDeltaResourceSet, "this.Item is ODataDeltaResourceSet");
                return (ODataDeltaResourceSet)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as ODataDeltaLink
        /// </summary>
        protected ODataDeltaLink CurrentDeltaLink
        {
            get
            {
                Debug.Assert(this.Item == null || this.Item is ODataDeltaLink, "this.Item is ODataDeltaLink");
                return (ODataDeltaLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as ODataDeltaDeletedLink.
        /// </summary>
        protected ODataDeltaDeletedLink CurrentDeltaDeletedLink
        {
            get
            {
                Debug.Assert(this.Item == null || this.Item is ODataDeltaDeletedLink, "this.Item is ODataDeltaDeletedLink");
                return (ODataDeltaDeletedLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the current resource depth.
        /// </summary>
        protected int CurrentResourceDepth
        {
            get
            {
                return this.currentResourceDepth;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataNestedResourceInfo"/>. Must only be called if the item actually is a nested resource info.
        /// </summary>
        protected ODataNestedResourceInfo CurrentNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.Item is ODataNestedResourceInfo, "this.Item is ODataNestedResourceInfo");
                return (ODataNestedResourceInfo)this.Item;
            }
        }

        /// <summary>
        /// Returns the current item as <see cref="ODataEntityReferenceLink"/>. Must only be called if the item actually is an entity reference link.
        /// </summary>
        protected ODataEntityReferenceLink CurrentEntityReferenceLink
        {
            get
            {
                Debug.Assert(this.Item is ODataEntityReferenceLink, "this.Item is ODataEntityReferenceLink");
                return (ODataEntityReferenceLink)this.Item;
            }
        }

        /// <summary>
        /// Returns the expected resource type for the current scope.
        /// </summary>
        protected IEdmType CurrentResourceType
        {
            get
            {
                if (CurrentResourceTypeReference != null)
                {
                    return CurrentResourceTypeReference.Definition;
                }

                return null;
            }
        }

        /// <summary>
        /// Gets and Sets the expected resource type reference for the current scope.
        /// </summary>
        protected IEdmTypeReference CurrentResourceTypeReference
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                IEdmTypeReference resourceTypeReference = this.scopes.Peek().ResourceTypeReference;
                Debug.Assert(resourceTypeReference == null || this.inputContext.Model.IsUserModel(), "We can only have structured type if we also have metadata.");

                return resourceTypeReference;
            }

            set
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                this.scopes.Peek().ResourceTypeReference = value;
            }
        }

        /// <summary>
        /// Returns the navigation source for the current scope.
        /// </summary>
        protected IEdmNavigationSource CurrentNavigationSource
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                IEdmNavigationSource navigationSource = this.scopes.Peek().NavigationSource;
                Debug.Assert(navigationSource == null || this.inputContext.Model.IsUserModel(), "We can only have navigation source if we also have metadata.");
                return navigationSource;
            }
        }

        /// <summary>
        /// Returns the current scope.
        /// </summary>
        protected Scope CurrentScope
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 0, "A scope must always exist.");
                return this.scopes.Peek();
            }
        }

        protected Stack<Scope> Scopes
        {
            get { return this.scopes; }
        }

        /// <summary>
        /// Returns the parent scope.
        /// </summary>
        protected Scope ParentScope
        {
            get
            {
                Debug.Assert(this.scopes != null && this.scopes.Count > 1, "We must have at least two scopes in the stack.");
                return this.scopes.Skip(1).First();
            }
        }

        /// <summary>
        /// A flag indicating whether the reader is at the top level.
        /// </summary>
        protected bool IsTopLevel
        {
            get
            {
                Debug.Assert(this.scopes != null, "Scopes must exist.");

                // there is the root scope at the top (when the writer has not started or has completed)
                // and then the top-level scope (the top-level resource/resource set item) as the second scope on the stack
                return this.scopes.Count <= 2;
            }
        }

        /// <summary>
        /// If the current scope is a content of an expanded link, this returns the parent nested resource info scope, otherwise null.
        /// </summary>
        protected Scope ExpandedLinkContentParentScope
        {
            get
            {
                Debug.Assert(this.scopes != null, "this.scopes != null");
                if (this.scopes.Count > 1)
                {
                    Scope parentScope = this.scopes.Skip(1).First();
                    if (parentScope.State == ODataReaderState.NestedResourceInfoStart)
                    {
                        return parentScope;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// True if we are reading a resource or resource set that is the direct content of an expanded link. Otherwise false.
        /// </summary>
        protected bool IsExpandedLinkContent
        {
            get
            {
                return this.ExpandedLinkContentParentScope != null;
            }
        }

        /// <summary>
        /// Set to true if a resource set is being read.
        /// </summary>
        protected bool ReadingResourceSet
        {
            get
            {
                return this.readingResourceSet;
            }
        }

        /// <summary>
        /// Set to true if a delta response is being read.
        /// </summary>
        protected bool ReadingDelta
        {
            get
            {
                return this.readingDelta;
            }
        }

        /// <summary>
        /// Returns true if we are reading a nested payload,
        /// e.g. an expanded resource or resource set within a delta payload,
        /// or a resource or a resource set within a parameters payload.
        /// </summary>
        protected bool IsReadingNestedPayload
        {
            get
            {
                return this.listener != null;
            }
        }

        /// <summary>
        /// Validator to validate consistency of entries in top-level resource sets.
        /// </summary>
        /// <remarks>We only use this for top-level resource sets since we support collection validation for
        /// resource sets only when metadata is available and in these cases we already validate the
        /// types of the entries in nested resource sets.</remarks>
        protected ResourceSetWithoutExpectedTypeValidator CurrentResourceSetValidator
        {
            get
            {
                Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "CurrentResourceSetValidator should only be called while reading a resource.");
                return this.ParentScope == null ? null : this.ParentScope.ResourceTypeValidator;
            }
        }

        /// <summary>
        /// Validator to validate the derived type constraint.
        /// </summary>
        protected DerivedTypeValidator CurrentDerivedTypeValidator
        {
            get
            {
                Debug.Assert(this.State == ODataReaderState.ResourceStart || this.State == ODataReaderState.DeletedResourceStart, "CurrentDerivedTypeValidator should only be called while reading a resource.");
                return this.ParentScope == null ? null : this.ParentScope.DerivedTypeValidator;
            }
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        public override sealed bool Read()
        {
            this.VerifyCanRead(true);
            return this.InterceptException(this.ReadSynchronously);
        }

        /// <summary>
        /// Asynchronously reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>A task that when completed indicates whether more items were read.</returns>
        public override sealed Task<bool> ReadAsync()
        {
            this.VerifyCanRead(false);
            return this.ReadAsynchronously().FollowOnFaultWith(t => this.EnterScope(new Scope(ODataReaderState.Exception, null, null)));
        }

        /// <summary>
        /// Creates a stream for reading an inline stream property.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        public override sealed Stream CreateReadStream()
        {
            if (this.State != ODataReaderState.Stream)
            {
                throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
            }

            StreamScope scope = this.CurrentScope as StreamScope;
            Debug.Assert(scope != null, "ODataReaderState.Stream when Scope is not a StreamScope");
            if (scope.StreamingState != StreamingState.None)
            {
                throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
            }

            scope.StreamingState = StreamingState.Streaming;
            return new ODataNotificationStream(this.InterceptException(this.CreateReadStreamImplementation), this);
        }

        /// <summary>
        /// Creates a TextWriter for reading an inline stream property.
        /// </summary>
        /// <returns>A TextWriter for reading the stream property.</returns>
        public override sealed TextReader CreateTextReader()
        {
            if (this.State == ODataReaderState.Stream)
            {
                Debug.Assert(this.CurrentScope is StreamScope scope, "ODataReaderState.Stream when Scope is not a StreamScope");
                if (scope.StreamingState != StreamingState.None)
                {
                    throw new ODataException(Strings.ODataReaderCore_CreateReadStreamCalledInInvalidState);
                }

                scope.StreamingState = StreamingState.Streaming;
                return new ODataNotificationReader(this.InterceptException(this.CreateTextReaderImplementation), this);
            }
            else
            {
                throw new ODataException(Strings.ODataReaderCore_CreateTextReaderCalledInInvalidState);
            }
        }

        /// <summary>
        /// This method is called when a stream is requested. It is a no-op.
        /// </summary>
        void IODataStreamListener.StreamRequested()
        {
        }

        /// <summary>
        /// This method is called when an async stream is requested. It is a no-op.
        /// </summary>
        /// <returns>A task for method called when a stream is requested.</returns>
        Task IODataStreamListener.StreamRequestedAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation(() => ((IODataStreamListener)this).StreamRequested());
        }

        /// <summary>
        /// This method is called when a stream is disposed.
        /// </summary>
        void IODataStreamListener.StreamDisposed()
        {
            Debug.Assert(this.State == ODataReaderState.Stream, "Stream was disposed when not in ReaderState.Stream state.");
            StreamScope scope = this.CurrentScope as StreamScope;
            Debug.Assert(scope != null, "Stream disposed when not in stream scope");
            Debug.Assert(scope.StreamingState == StreamingState.Streaming, "StreamDisposed called when reader was not streaming");
            scope.StreamingState = StreamingState.Completed;
        }

        /// <summary>
        /// Seek scope in the stack which is type of <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type of scope to seek.</typeparam>
        /// <param name="maxDepth">The max depth to seek.</param>
        /// <returns>The scope with type of <typeparamref name="T"/></returns>
        internal Scope SeekScope<T>(int maxDepth) where T : Scope
        {
            int count = 1;

            foreach (Scope scope in this.scopes)
            {
                if (count > maxDepth)
                {
                    return null;
                }

                if (scope is T)
                {
                    return scope;
                }

                count++;
            }

            return null;
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Start'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceSetStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'ResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceSetEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntryEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtResourceEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'Primitive'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtPrimitiveImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'PropertyInfo'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtNestedPropertyInfoImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'Stream'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtStreamImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a Stream for reading a stream property when in state 'Stream'.
        /// </summary>
        /// <returns>A stream for reading the stream property.</returns>
        protected virtual Stream CreateReadStreamImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Creates a TextReader for reading a string property when in state 'Text'.
        /// </summary>
        /// <returns>A TextReader for reading the string property.</returns>
        protected virtual TextReader CreateTextReaderImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtNestedResourceInfoStartImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'NestedResourceInfoEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtNestedResourceInfoEndImplementation();

        /// <summary>
        /// Implementation of the reader logic when in state 'EntityReferenceLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected abstract bool ReadAtEntityReferenceLink();

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaResourceSetStartImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaResourceSetEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaResourceSetEndImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceStart'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeletedResourceStartImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeletedResourceEnd'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeletedResourceEndImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaLinkImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Implementation of the reader logic when in state 'DeltaDeletedLink'.
        /// </summary>
        /// <returns>true if more items can be read from the reader; otherwise false.</returns>
        protected virtual bool ReadAtDeltaDeletedLinkImplementation()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Pushes the <paramref name="scope"/> on the stack of scopes.
        /// </summary>
        /// <param name="scope">The scope to enter.</param>
        protected void EnterScope(Scope scope)
        {
            Debug.Assert(scope != null, "scope != null");

            if ((scope.State == ODataReaderState.ResourceSetStart || scope.State == ODataReaderState.DeltaResourceSetStart)
                && this.inputContext.Model.IsUserModel())
            {
                scope.ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(scope.ResourceType);
            }

            if (scope.State == ODataReaderState.ResourceSetStart || scope.State == ODataReaderState.DeltaResourceSetStart)
            {
                scope.DerivedTypeValidator = this.CurrentScope.DerivedTypeValidator;
            }

            // TODO: implement some basic validation that the transitions are ok
            this.scopes.Push(scope);
            if (this.listener != null)
            {
                if (scope.State == ODataReaderState.Exception)
                {
                    this.listener.OnException();
                }
                else if (scope.State == ODataReaderState.Completed)
                {
                    this.listener.OnCompleted();
                }
            }
        }

        /// <summary>
        /// Replaces the current scope with the specified <paramref name="scope"/>.
        /// </summary>
        /// <param name="scope">The scope to replace the current scope with.</param>
        protected void ReplaceScope(Scope scope)
        {
            Debug.Assert(this.scopes.Count > 0, "Stack must always be non-empty.");
            Debug.Assert(scope != null, "scope != null");
            Debug.Assert(scope.State != ODataReaderState.ResourceEnd, "Call EndEntry instead.");

            // TODO: implement some basic validation that the transitions are ok
            this.scopes.Pop();
            this.EnterScope(scope);
        }

        /// <summary>
        /// Removes the current scope from the stack of all scopes.
        /// </summary>
        /// <param name="state">The expected state of the current scope (to be popped).</param>
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "state", Justification = "Used in debug builds in assertions.")]
        [SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "scope", Justification = "Used in debug builds in assertions.")]
        protected void PopScope(ODataReaderState state)
        {
            Debug.Assert(this.scopes.Count > 1, "Stack must have more than 1 items in order to pop an item.");

            Scope scope = this.scopes.Pop();
            Debug.Assert(scope.State == state, "scope.State == state");
        }

        /// <summary>
        /// Called to transition into the EntryEnd state.
        /// </summary>
        /// <param name="scope">The scope for the EntryEnd state.</param>
        protected void EndEntry(Scope scope)
        {
            Debug.Assert(this.scopes.Count > 0, "Stack must always be non-empty.");
            Debug.Assert(scope != null, "scope != null");
            Debug.Assert(scope.State == ODataReaderState.ResourceEnd | scope.State == ODataReaderState.DeletedResourceEnd, "Called EndEntry when not in ResourceEnd or DeletedResourceEnd state");

            this.scopes.Pop();
            this.EnterScope(scope);
        }

        /// <summary>
        /// If an entity type name is found in the payload this method is called to apply it to the current scope.
        /// This method should be called even if the type name was not found in which case a null should be passed in.
        /// The method validates that some type will be available as the current entity type after it returns (if we are parsing using metadata).
        /// </summary>
        /// <param name="resourceTypeNameFromPayload">The entity type name found in the payload or null if no type was specified in the payload.</param>
        protected void ApplyResourceTypeNameFromPayload(string resourceTypeNameFromPayload)
        {
            Debug.Assert(
                this.scopes.Count > 0 && this.scopes.Peek().Item is ODataResourceBase,
                "Resource type can be applied only when in resource scope.");

            ODataTypeAnnotation typeAnnotation;
            EdmTypeKind targetTypeKind;

            IEdmStructuredType targetResourceType = null;
            ODataResourceBase resource = this.Item as ODataResourceBase;

            if (                this.inputContext.MessageReaderSettings.Validator.ResolvePayloadTypeNameAndComputeTargetType(
                    EdmTypeKind.None,
                    /*expectStructuredType*/ true,
                    /*defaultPrimitivePayloadType*/ null,
                    this.CurrentResourceTypeReference,
                    resourceTypeNameFromPayload,
                    this.inputContext.Model,
                    () => EdmTypeKind.Entity,
                    out targetTypeKind,
                    out typeAnnotation) is IEdmStructuredTypeReference targetResourceTypeReference)
            {
                targetResourceType = targetResourceTypeReference.StructuredDefinition();
                resource.TypeName = targetResourceType.FullTypeName();

                if (typeAnnotation != null)
                {
                    resource.TypeAnnotation = typeAnnotation;
                }
            }
            else if (resourceTypeNameFromPayload != null)
            {
                resource.TypeName = resourceTypeNameFromPayload;
            }
            else if (this.CurrentResourceTypeReference.IsUntyped())
            {
                targetResourceTypeReference = this.CurrentResourceTypeReference.IsNullable ?
                    EdmUntypedStructuredTypeReference.NullableTypeReference : 
                    EdmUntypedStructuredTypeReference.NonNullableTypeReference;
            }

            // Set the current resource type since the type might be derived from the expected one.
            this.CurrentResourceTypeReference = targetResourceTypeReference;
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        protected bool ReadSynchronously()
        {
            return this.ReadImplementation();
        }

        /// <summary>
        /// Asynchronously reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>A task that when completed indicates whether more items were read.</returns>
        protected virtual Task<bool> ReadAsynchronously()
        {
            // We are reading from the fully buffered read stream here; thus it is ok
            // to use synchronous reads and then return a completed task
            // NOTE: once we switch to fully async reading this will have to change
            return TaskUtils.GetTaskForSynchronousOperation<bool>(this.ReadImplementation);
        }

        /// <summary>
        /// Increments the nested resource count by one and fails if the new value exceeds the maxium nested resource depth limit.
        /// </summary>
        protected void IncreaseResourceDepth()
        {
            this.currentResourceDepth++;

            if (this.currentResourceDepth > this.inputContext.MessageReaderSettings.MessageQuotas.MaxNestingDepth)
            {
                throw new ODataException(Strings.ValidationUtils_MaxDepthOfNestedEntriesExceeded(this.inputContext.MessageReaderSettings.MessageQuotas.MaxNestingDepth));
            }
        }

        /// <summary>
        /// Decrements the nested resource count by one.
        /// </summary>
        protected void DecreaseResourceDepth()
        {
            Debug.Assert(this.currentResourceDepth > 0, "Resource depth should never become negative.");

            this.currentResourceDepth--;
        }

        /// <summary>
        /// Reads the next <see cref="ODataItem"/> from the message payload.
        /// </summary>
        /// <returns>true if more items were read; otherwise false.</returns>
        private bool ReadImplementation()
        {
            bool result;
            switch (this.State)
            {
                case ODataReaderState.Start:
                    result = this.ReadAtStartImplementation();
                    break;

                case ODataReaderState.ResourceSetStart:
                    result = this.ReadAtResourceSetStartImplementation();
                    break;

                case ODataReaderState.ResourceSetEnd:
                    result = this.ReadAtResourceSetEndImplementation();
                    break;

                case ODataReaderState.ResourceStart:
                    this.IncreaseResourceDepth();
                    result = this.ReadAtResourceStartImplementation();
                    break;

                case ODataReaderState.ResourceEnd:
                    this.DecreaseResourceDepth();
                    result = this.ReadAtResourceEndImplementation();
                    break;

                case ODataReaderState.Primitive:
                    result = this.ReadAtPrimitiveImplementation();
                    break;

                case ODataReaderState.Stream:
                    result = this.ReadAtStreamImplementation();
                    break;

                case ODataReaderState.NestedProperty:
                    result = this.ReadAtNestedPropertyInfoImplementation();
                    break;

                case ODataReaderState.NestedResourceInfoStart:
                    result = this.ReadAtNestedResourceInfoStartImplementation();
                    break;

                case ODataReaderState.NestedResourceInfoEnd:
                    result = this.ReadAtNestedResourceInfoEndImplementation();
                    break;

                case ODataReaderState.EntityReferenceLink:
                    result = this.ReadAtEntityReferenceLink();
                    break;

                case ODataReaderState.DeltaResourceSetStart:
                    result = this.ReadAtDeltaResourceSetStartImplementation();
                    break;

                case ODataReaderState.DeltaResourceSetEnd:
                    result = this.ReadAtDeltaResourceSetEndImplementation();
                    break;

                case ODataReaderState.DeletedResourceStart:
                    result = this.ReadAtDeletedResourceStartImplementation();
                    break;

                case ODataReaderState.DeletedResourceEnd:
                    result = this.ReadAtDeletedResourceEndImplementation();
                    break;

                case ODataReaderState.DeltaLink:
                    result = this.ReadAtDeltaLinkImplementation();
                    break;

                case ODataReaderState.DeltaDeletedLink:
                    result = this.ReadAtDeltaDeletedLinkImplementation();
                    break;

                case ODataReaderState.Exception:    // fall through
                case ODataReaderState.Completed:
                    throw new ODataException(Strings.ODataReaderCore_NoReadCallsAllowed(this.State));

                default:
                    Debug.Assert(false, "Unsupported reader state " + this.State + " detected.");
                    throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataReaderCore_ReadImplementation));
            }

            return result;
        }

        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the reader into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <typeparam name="T">The type returned from the <paramref name="action"/> to execute.</typeparam>
        /// <param name="action">The action to execute.</param>
        /// <returns>The result of executing the <paramref name="action"/>.</returns>
        private T InterceptException<T>(Func<T> action)
        {
            try
            {
                return action();
            }
            catch (Exception e)
            {
                if (ExceptionUtils.IsCatchableExceptionType(e))
                {
                    this.EnterScope(new Scope(ODataReaderState.Exception, null, null));
                }

                throw;
            }
        }

        /// <summary>
        /// Verifies that calling Read is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanRead(bool synchronousCall)
        {
            this.inputContext.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);

            if (this.State == ODataReaderState.Exception || this.State == ODataReaderState.Completed)
            {
                throw new ODataException(Strings.ODataReaderCore_ReadOrReadAsyncCalledInInvalidState(this.State));
            }

            if (this.State == ODataReaderState.Stream)
            {
                Debug.Assert(this.CurrentScope is StreamScope scope, "In stream state without a stream scope");
                if (scope.StreamingState != StreamingState.Completed)
                {
                    throw new ODataException(Strings.ODataReaderCore_ReadCalledWithOpenStream);
                }
            }
        }

        /// <summary>
        /// Verifies that a call is allowed to the reader.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCallAllowed(bool synchronousCall)
        {
            if (synchronousCall)
            {
                if (!this.inputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataReaderCore_SyncCallOnAsyncReader);
                }
            }
            else
            {
                if (this.inputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataReaderCore_AsyncCallOnSyncReader);
                }
            }
        }

        /// <summary>
        /// A reader scope; keeping track of the current reader state and an item associated with this state.
        /// </summary>
        protected internal class Scope
        {
            /// <summary>The reader state of this scope.</summary>
            private readonly ODataReaderState state;

            /// <summary>The item attached to this scope.</summary>
            private readonly ODataItem item;

            /// <summary>The odataUri parsed based on the context uri attached to this scope.</summary>
            private readonly ODataUri odataUri;

            /// <summary>
            /// The <see cref="ResourceSetWithoutExpectedTypeValidator"/> to use for entries in this resourceSet.
            /// </summary>
            private ResourceSetWithoutExpectedTypeValidator resourceTypeValidator;

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
            internal Scope(ODataReaderState state, ODataItem item, ODataUri odataUri)
            {
                Debug.Assert(
                    state == ODataReaderState.Exception && item == null ||
                    state == ODataReaderState.ResourceStart && (item == null || item is ODataResource) ||
                    state == ODataReaderState.ResourceEnd && (item is ODataResource || item == null) ||
                    state == ODataReaderState.Primitive && (item == null || item is ODataPrimitiveValue || item is ODataNullValue) ||
                    state == ODataReaderState.Stream && (item == null || item is ODataStreamItem) ||
                    state == ODataReaderState.NestedProperty && (item == null || item is ODataPropertyInfo) ||
                    state == ODataReaderState.ResourceSetStart && item is ODataResourceSet ||
                    state == ODataReaderState.ResourceSetEnd && item is ODataResourceSet ||
                    state == ODataReaderState.NestedResourceInfoStart && item is ODataNestedResourceInfo ||
                    state == ODataReaderState.NestedResourceInfoEnd && item is ODataNestedResourceInfo ||
                    state == ODataReaderState.EntityReferenceLink && item is ODataEntityReferenceLink ||
                    state == ODataReaderState.DeletedResourceStart && (item == null || item is ODataDeletedResource) ||
                    state == ODataReaderState.DeletedResourceEnd && (item is ODataDeletedResource || item == null) ||
                    state == ODataReaderState.DeltaResourceSetStart && item is ODataDeltaResourceSet ||
                    state == ODataReaderState.DeltaResourceSetEnd && item is ODataDeltaResourceSet ||
                    state == ODataReaderState.DeltaLink && (item == null || item is ODataDeltaLink) ||
                    state == ODataReaderState.DeltaDeletedLink && (item == null || item is ODataDeltaDeletedLink) ||
                    state == ODataReaderState.Start && item == null ||
                    state == ODataReaderState.Completed && item == null,
                    "Reader state and associated item do not match.");

                this.state = state;
                this.item = item;
                this.odataUri = odataUri;
            }

            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceTypeReference">The expected resource type reference for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            /// <remarks>The <paramref name="expectedResourceTypeReference"/> has the following meanings for given state:
            /// Start -               it's the expected base type reference of the top-level resource or resources in the top-level resource set.
            /// ResourceSetStart -           it's the expected base type reference of the resources in the resource set.
            ///                       note that it might be a more derived type than the base type of the entity set for the resource set.
            /// EntryStart -          it's the expected base type reference of the resource. If the resource has no type name specified
            ///                       this type will be assumed. Otherwise the specified type name must be
            ///                       the expected type or a more derived type.
            /// NestedResourceInfoStart - it's the expected base type reference the entries in the expanded link (either the single resource
            ///                       or entries in the expanded resource set).
            /// EntityReferenceLink - it's null, no need for types on entity reference links.
            /// In all cases the specified type must be an structured type.</remarks>
            [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
            internal Scope(ODataReaderState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceTypeReference, ODataUri odataUri)
                : this(state, item, odataUri)
            {
                this.NavigationSource = navigationSource;
                this.ResourceTypeReference = expectedResourceTypeReference;
            }

            /// <summary>
            /// The reader state of this scope.
            /// </summary>
            internal ODataReaderState State
            {
                get
                {
                    return this.state;
                }
            }

            /// <summary>
            /// The item attached to this scope.
            /// </summary>
            internal ODataItem Item
            {
                get
                {
                    return this.item;
                }
            }

            /// <summary>
            /// The odataUri parsed based on the context url to this scope.
            /// </summary>
            internal ODataUri ODataUri
            {
                get
                {
                    return this.odataUri;
                }
            }

            /// <summary>
            /// The navigation source we are reading entries from (possibly null).
            /// </summary>
            internal IEdmNavigationSource NavigationSource { get; set; }

            /// <summary>
            /// The resource type for this scope. Can be either the expected one if the real one
            /// was not found yet, or the one specified in the payload itself (the real one).
            /// </summary>
            internal IEdmType ResourceType
            {
                get
                {
                    if (this.ResourceTypeReference != null)
                    {
                        return ResourceTypeReference.Definition;
                    }

                    return null;
                }
            }

            /// <summary>
            /// The resource type reference for this scope. Can be either the expected one if the real one
            /// was not found yet, or the one specified in the payload itself (the real one).
            /// </summary>
            internal IEdmTypeReference ResourceTypeReference { get; set; }

            /// <summary>
            /// Validator for resource type.
            /// </summary>
            internal ResourceSetWithoutExpectedTypeValidator ResourceTypeValidator
            {
                get
                {
                    return this.resourceTypeValidator;
                }

                set
                {
                    this.resourceTypeValidator = value;
                }
            }

            /// <summary>
            /// Gets or sets the derived type constraint validator.
            /// </summary>
            internal DerivedTypeValidator DerivedTypeValidator { get; set; }
        }

        protected internal class StreamScope : Scope
        {
            /// <summary>
            /// Constructor creating a new reader scope.
            /// </summary>
            /// <param name="state">The reader state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to read entities for.</param>
            /// <param name="expectedResourceType">The expected resource type for the scope.</param>
            /// <param name="odataUri">The odataUri parsed based on the context uri for current scope</param>
            internal StreamScope(ODataReaderState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceType, ODataUri odataUri)
                : base(state, item, navigationSource, expectedResourceType, odataUri)
            {
                this.StreamingState = StreamingState.None;
            }

            /// <summary>
            /// Current state of the stream.
            /// </summary>
            internal StreamingState StreamingState { get; set; }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\ODataReaderCore.cs(432,21): error CS0165: Use of unassigned local variable 'scope',D:\a\1\s\src\Microsoft.OData.Core\ODataReaderCore.cs(775,49): error CS0165: Use of unassigned local variable 'targetResourceTypeReference',D:\a\1\s\src\Microsoft.OData.Core\ODataReaderCore.cs(954,21): error CS0165: Use of unassigned local variable 'scope'
######################################################################


######################################################################
Nr: 18 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\ODataWriterCore.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading.Tasks;
using Microsoft.OData.Evaluation;
using Microsoft.OData.UriParser;
using Microsoft.OData.Edm;
using Microsoft.OData.Metadata;

namespace Microsoft.OData
{
    /// <summary>
    /// Base class for OData writers that verifies a proper sequence of write calls on the writer.
    /// </summary>
    internal abstract class ODataWriterCore : ODataWriter, IODataOutputInStreamErrorListener, IODataStreamListener
    {
        /// <summary>The writer validator to use.</summary>
        protected readonly IWriterValidator WriterValidator;

        /// <summary>The output context to write to.</summary>
        private readonly ODataOutputContext outputContext;

        /// <summary>True if the writer was created for writing a resourceSet; false when it was created for writing a resource.</summary>
        private readonly bool writingResourceSet;

        /// <summary>True if the writer was created for writing a delta response; false otherwise.</summary>
        private readonly bool writingDelta;

        /// <summary>If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</summary>
        private readonly IODataReaderWriterListener listener;

        /// <summary>Stack of writer scopes to keep track of the current context of the writer.</summary>
        private readonly ScopeStack scopeStack = new ScopeStack();

        /// <summary>The number of entries which have been started but not yet ended.</summary>
        private int currentResourceDepth;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="outputContext">The output context to write to.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="writingResourceSet">True if the writer is created for writing a resourceSet; false when it is created for writing a resource.</param>
        /// <param name="writingDelta">True if the writer is created for writing a delta response; false otherwise.</param>
        /// <param name="listener">If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</param>
        protected ODataWriterCore(
            ODataOutputContext outputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool writingResourceSet,
            bool writingDelta = false,
            IODataReaderWriterListener listener = null)
        {
            Debug.Assert(outputContext != null, "outputContext != null");

            this.outputContext = outputContext;
            this.writingResourceSet = writingResourceSet;
            this.writingDelta = writingDelta || (!writingResourceSet && !outputContext.WritingResponse);
            this.WriterValidator = outputContext.WriterValidator;
            this.Version = outputContext.MessageWriterSettings.Version;

            if (navigationSource != null && resourceType == null)
            {
                resourceType = this.outputContext.EdmTypeResolver.GetElementType(navigationSource);
            }

            ODataUri odataUri = outputContext.MessageWriterSettings.ODataUri.Clone();

            // Remove key for top level resource
            if (!writingResourceSet && odataUri != null && odataUri.Path != null)
            {
                odataUri.Path = odataUri.Path.TrimEndingKeySegment();
            }

            this.listener = listener;

            this.scopeStack.Push(new Scope(WriterState.Start, /*item*/null, navigationSource, resourceType, /*skipWriting*/false, outputContext.MessageWriterSettings.SelectedProperties, odataUri));
            this.CurrentScope.DerivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationSource);
        }

        /// <summary>
        /// An enumeration representing the current state of the writer.
        /// </summary>
        internal enum WriterState
        {
            /// <summary>The writer is at the start; nothing has been written yet.</summary>
            Start,

            /// <summary>The writer is currently writing a resource.</summary>
            Resource,

            /// <summary>The writer is currently writing a resourceSet.</summary>
            ResourceSet,

            /// <summary>The writer is currently writing a delta resource set.</summary>
            DeltaResourceSet,

            /// <summary>The writer is currently writing a deleted resource.</summary>
            DeletedResource,

            /// <summary>The writer is currently writing a delta link.</summary>
            DeltaLink,

            /// <summary>The writer is currently writing a delta deleted link.</summary>
            DeltaDeletedLink,

            /// <summary>The writer is currently writing a nested resource info (possibly an expanded link but we don't know yet).</summary>
            /// <remarks>
            /// This state is used when a nested resource info was started but we didn't see any children for it yet.
            /// </remarks>
            NestedResourceInfo,

            /// <summary>The writer is currently writing a nested resource info with content.</summary>
            /// <remarks>
            /// This state is used when a nested resource info with either an entity reference link or expanded resourceSet/resource was written.
            /// </remarks>
            NestedResourceInfoWithContent,

            /// <summary>The writer is currently writing a primitive value.</summary>
            Primitive,

            /// <summary>The writer is currently writing a single property.</summary>
            Property,

            /// <summary>The writer is currently writing a stream value.</summary>
            Stream,

            /// <summary>The writer is currently writing a string value.</summary>
            String,

            /// <summary>The writer has completed; nothing can be written anymore.</summary>
            Completed,

            /// <summary>The writer is in error state; nothing can be written anymore.</summary>
            Error
        }

        /// <summary>
        /// OData Version being written.
        /// </summary>
        internal ODataVersion? Version { get; }

        /// <summary>
        /// The current scope for the writer.
        /// </summary>
        protected Scope CurrentScope
        {
            get
            {
                Debug.Assert(this.scopeStack.Count > 0, "We should have at least one active scope all the time.");
                return this.scopeStack.Peek();
            }
        }

        /// <summary>
        /// The current state of the writer.
        /// </summary>
        protected WriterState State
        {
            get
            {
                return this.CurrentScope.State;
            }
        }

        /// <summary>
        /// true if the writer should not write any input specified and should just skip it.
        /// </summary>
        protected bool SkipWriting
        {
            get
            {
                return this.CurrentScope.SkipWriting;
            }
        }

        /// <summary>
        /// A flag indicating whether the writer is at the top level.
        /// </summary>
        protected bool IsTopLevel
        {
            get
            {
                Debug.Assert(this.State != WriterState.Start && this.State != WriterState.Completed, "IsTopLevel should only be called while writing the payload.");

                // there is the root scope at the top (when the writer has not started or has completed)
                // and then the top-level scope (the top-level resource/resourceSet item) as the second scope on the stack
                return this.scopeStack.Count == 2;
            }
        }

        /// <summary>
        /// The scope level the writer is writing.
        /// </summary>
        protected int ScopeLevel
        {
            get { return this.scopeStack.Count; }
        }

        /// <summary>
        /// Returns the immediate parent link which is being expanded, or null if no such link exists
        /// </summary>
        protected ODataNestedResourceInfo ParentNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "ParentNestedResourceInfo should only be called while writing a resource or a resourceSet.");

                Scope linkScope = this.scopeStack.ParentOrNull;
                return linkScope == null ? null : (linkScope.Item as ODataNestedResourceInfo);
            }
        }

        /// <summary>
        /// Returns the nested info that current resource belongs to.
        /// </summary>
        protected ODataNestedResourceInfo BelongingNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.ResourceSet || this.State == WriterState.DeletedResource || this.State == WriterState.DeltaResourceSet, "BelongingNestedResourceInfo should only be called while writing a (deleted) resource or a (delta) resourceSet.");

                Scope linkScope = this.scopeStack.ParentOrNull;

                // For single navigation
                if (linkScope is NestedResourceInfoScope)
                {
                    return linkScope.Item as ODataNestedResourceInfo;
                }
                else if (linkScope is ResourceSetBaseScope)
                {
                    // For resource under collection of navigation/complex, parent is ResourceSetScope, so we need find parent of parent.
                    linkScope = this.scopeStack.ParentOfParent;
                    return linkScope == null ? null : (linkScope.Item as ODataNestedResourceInfo);
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Returns the resource type of the immediate parent resource for which a nested resource info is being written.
        /// </summary>
        protected IEdmStructuredType ParentResourceType
        {
            get
            {
                Debug.Assert(
                    this.State == WriterState.NestedResourceInfo || this.State == WriterState.NestedResourceInfoWithContent,
                    "ParentResourceType should only be called while writing a nested resource info (with or without content), or within an untyped ResourceSet.");
                Scope resourceScope = this.scopeStack.Parent;
                return resourceScope.ResourceType;
            }
        }

        /// <summary>
        /// Returns the navigation source of the immediate parent resource for which a nested resource info is being written.
        /// </summary>
        protected IEdmNavigationSource ParentResourceNavigationSource
        {
            get
            {
                Scope resourceScope = this.scopeStack.Parent;
                return resourceScope == null ? null : resourceScope.NavigationSource;
            }
        }

        /// <summary>
        /// Returns the parent scope of current scope.
        /// </summary>
        protected Scope ParentScope
        {
            get
            {
                Debug.Assert(this.scopeStack.Count > 1);
                return this.scopeStack.Scopes.Skip(1).First();
            }
        }

        /// <summary>
        /// Returns the number of items seen so far on the current resource set scope.
        /// </summary>
        /// <remarks>Can only be accessed on a resource set scope.</remarks>
        protected int ResourceSetScopeResourceCount
        {
            get
            {
                Debug.Assert(this.State == WriterState.ResourceSet, "ResourceSetScopeResourceCount should only be called while writing a resource set.");
                return ((ResourceSetBaseScope)this.CurrentScope).ResourceCount;
            }
        }

        /// <summary>
        /// Checker to detect duplicate property names.
        /// </summary>
        protected IDuplicatePropertyNameChecker DuplicatePropertyNameChecker
        {
            get
            {
                Debug.Assert(
                    this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.NestedResourceInfo || this.State == WriterState.NestedResourceInfoWithContent || this.State == WriterState.Property,
                    "PropertyAndAnnotationCollector should only be called while writing a resource or an (expanded or deferred) nested resource info.");

                ResourceBaseScope resourceScope;
                switch (this.State)
                {
                    case WriterState.DeletedResource:
                    case WriterState.Resource:
                        resourceScope = (ResourceBaseScope)this.CurrentScope;
                        break;
                    case WriterState.Property:
                    case WriterState.NestedResourceInfo:
                    case WriterState.NestedResourceInfoWithContent:
                        resourceScope = (ResourceBaseScope)this.scopeStack.Parent;
                        break;
                    default:
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_PropertyAndAnnotationCollector));
                }

                return resourceScope.DuplicatePropertyNameChecker;
            }
        }

        /// <summary>
        /// The structured type of the current resource.
        /// </summary>
        protected IEdmStructuredType ResourceType
        {
            get
            {
                return this.CurrentScope.ResourceType;
            }
        }

        /// <summary>
        /// Returns the parent nested resource info scope of a resource in an expanded link (if it exists).
        /// The resource can either be the content of the expanded link directly or nested inside a resourceSet.
        /// </summary>
        /// <returns>The parent navigation scope of a resource in an expanded link (if it exists).</returns>
        protected NestedResourceInfoScope ParentNestedResourceInfoScope
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "ParentNestedResourceInfoScope should only be called while writing a resource or a resourceSet.");
                Debug.Assert(this.scopeStack.Count >= 2, "We should have at least the resource scope and the start scope on the stack.");

                Scope parentScope = this.scopeStack.Parent;
                if (parentScope.State == WriterState.Start)
                {
                    // Top-level resource.
                    return null;
                }

                if (parentScope.State == WriterState.ResourceSet || parentScope.State == WriterState.DeltaResourceSet)
                {
                    Debug.Assert(this.scopeStack.Count >= 3, "We should have at least the resource scope, the resourceSet scope and the start scope on the stack.");

                    // Get the resourceSet's parent
                    parentScope = this.scopeStack.ParentOfParent;
                    if (parentScope.State == WriterState.Start ||
                        (parentScope.State == WriterState.ResourceSet &&
                        parentScope.ResourceType != null &&
                        parentScope.ResourceType.TypeKind == EdmTypeKind.Untyped))
                    {
                        // Top-level resourceSet, or resourceSet within an untyped resourceSet.
                        return null;
                    }
                }

                if (parentScope.State == WriterState.NestedResourceInfoWithContent)
                {
                    // Get the scope of the nested resource info
                    return (NestedResourceInfoScope)parentScope;
                }

                // The parent scope of a resource can only be a resourceSet or an expanded nav link
                throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_ParentNestedResourceInfoScope));
            }
        }

        /// <summary>
        /// Validator to validate consistency of collection items (or null if no such validator applies to the current scope).
        /// </summary>
        private ResourceSetWithoutExpectedTypeValidator CurrentResourceSetValidator
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.Primitive, "CurrentCollectionValidator should only be called while writing a resource.");

                ResourceSetBaseScope resourceSetScope = this.ParentScope as ResourceSetBaseScope;
                return resourceSetScope == null ? null : resourceSetScope.ResourceTypeValidator;
            }
        }

        /// <summary>
        /// Flushes the write buffer to the underlying stream.
        /// </summary>
        public sealed override void Flush()
        {
            this.VerifyCanFlush(true);

            // Make sure we switch to writer state FatalExceptionThrown if an exception is thrown during flushing.
            try
            {
                this.FlushSynchronously();
            }
            catch
            {
                this.EnterScope(WriterState.Error, null);
                throw;
            }
        }


        /// <summary>
        /// Asynchronously flushes the write buffer to the underlying stream.
        /// </summary>
        /// <returns>A task instance that represents the asynchronous operation.</returns>
        public sealed override Task FlushAsync()
        {
            this.VerifyCanFlush(false);

            // Make sure we switch to writer state Error if an exception is thrown during flushing.
            return this.FlushAsynchronously().FollowOnFaultWith(t => this.EnterScope(WriterState.Error, null));
        }

        /// <summary>
        /// Start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        public sealed override void WriteStart(ODataResourceSet resourceSet)
        {
            this.VerifyCanWriteStartResourceSet(true, resourceSet);
            this.WriteStartResourceSetImplementation(resourceSet);
        }


        /// <summary>
        /// Asynchronously start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataResourceSet resourceSet)
        {
            this.VerifyCanWriteStartResourceSet(false, resourceSet);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartResourceSetImplementation(resourceSet));
        }

        /// <summary>
        /// Start writing a delta resource Set.
        /// </summary>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        public sealed override void WriteStart(ODataDeltaResourceSet deltaResourceSet)
        {
            this.VerifyCanWriteStartDeltaResourceSet(true, deltaResourceSet);
            this.WriteStartDeltaResourceSetImplementation(deltaResourceSet);
        }


        /// <summary>
        /// Asynchronously start writing a delta resourceSet.
        /// </summary>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataDeltaResourceSet deltaResourceSet)
        {
            this.VerifyCanWriteStartDeltaResourceSet(false, deltaResourceSet);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartDeltaResourceSetImplementation(deltaResourceSet));
        }

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        public sealed override void WriteStart(ODataResource resource)
        {
            this.VerifyCanWriteStartResource(true, resource);
            this.WriteStartResourceImplementation(resource);
        }


        /// <summary>
        /// Asynchronously start writing a resource.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataResource resource)
        {
            this.VerifyCanWriteStartResource(false, resource);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartResourceImplementation(resource));
        }

        /// <summary>
        /// Start writing a delta deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta deleted resource to write.</param>
        public sealed override void WriteStart(ODataDeletedResource deletedResource)
        {
            this.VerifyCanWriteStartDeletedResource(true, deletedResource);
            this.WriteStartDeletedResourceImplementation(deletedResource);
        }


        /// <summary>
        /// Asynchronously write a delta deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta deleted resource to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataDeletedResource deletedResource)
        {
            this.VerifyCanWriteStartDeletedResource(false, deletedResource);
            return TaskUtils.GetTaskForSynchronousOperation(() =>
            {
                this.WriteStartDeletedResourceImplementation(deletedResource);
            });
        }

        /// <summary>
        /// Writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        public override void WriteDeltaLink(ODataDeltaLink deltaLink)
        {
            this.VerifyCanWriteLink(true, deltaLink);
            this.WriteDeltaLinkImplementation(deltaLink);
        }


        /// <summary>
        /// Asynchronously writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public override Task WriteDeltaLinkAsync(ODataDeltaLink deltaLink)
        {
            this.VerifyCanWriteLink(false, deltaLink);
            return this.WriteDeltaLinkAsyncImplementation(deltaLink);
        }

        /// <summary>
        /// Writing a delta deleted link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        public override void WriteDeltaDeletedLink(ODataDeltaDeletedLink deltaLink)
        {
            this.VerifyCanWriteLink(true, deltaLink);
            this.WriteDeltaLinkImplementation(deltaLink);
        }


        /// <summary>
        /// Asynchronously writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public override Task WriteDeltaDeletedLinkAsync(ODataDeltaDeletedLink deltaLink)
        {
            this.VerifyCanWriteLink(false, deltaLink);
            return this.WriteDeltaLinkAsyncImplementation(deltaLink);
        }

        /// <summary>
        /// Write a primitive value within an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        public sealed override void WritePrimitive(ODataPrimitiveValue primitiveValue)
        {
            this.VerifyCanWritePrimitive(true, primitiveValue);
            this.WritePrimitiveValueImplementation(primitiveValue);
        }


        /// <summary>
        /// Asynchronously write a primitive value.
        /// </summary>
        /// <param name="primitiveValue"> Primitive value to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WritePrimitiveAsync(ODataPrimitiveValue primitiveValue)
        {
            this.VerifyCanWritePrimitive(false, primitiveValue);
            return this.WritePrimitiveValueAsyncImplementation(primitiveValue);
        }

        /// <summary>Writes a primitive property within a resource.</summary>
        /// <param name="primitiveProperty">The primitive property to write.</param>
        public sealed override void WriteStart(ODataPropertyInfo primitiveProperty)
        {
            this.VerifyCanWriteProperty(true, primitiveProperty);
            this.WriteStartPropertyImplementation(primitiveProperty);
        }

        /// <summary> Asynchronously write a primitive property within a resource. </summary>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        /// <param name="primitiveProperty">The primitive property to write.</param>
        public sealed override Task WriteStartAsync(ODataPropertyInfo primitiveProperty)
        {
            this.VerifyCanWriteProperty(false, primitiveProperty);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartPropertyImplementation(primitiveProperty));
        }

        /// <summary>Creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Stream CreateBinaryWriteStream()
        {
            this.VerifyCanCreateWriteStream(true);
            return this.CreateWriteStreamImplementation();
        }


        /// <summary>Asynchronously creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Task<Stream> CreateBinaryWriteStreamAsync()
        {
            this.VerifyCanCreateWriteStream(false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.CreateWriteStreamImplementation());
        }

        /// <summary>Creates a TextWriter for writing a string value.</summary>
        /// <returns>A TextWriter to write a string value to.</returns>
        public sealed override TextWriter CreateTextWriter()
        {
            this.VerifyCanCreateTextWriter(true);
            return this.CreateTextWriterImplementation();
        }


        /// <summary>Asynchronously creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Task<TextWriter> CreateTextWriterAsync()
        {
            this.VerifyCanCreateWriteStream(false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.CreateTextWriterImplementation());
        }

        /// <summary>
        /// Start writing a nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        public sealed override void WriteStart(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.VerifyCanWriteStartNestedResourceInfo(true, nestedResourceInfo);
            this.WriteStartNestedResourceInfoImplementation(nestedResourceInfo);
        }


        /// <summary>
        /// Asynchronously start writing a nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to writer.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.VerifyCanWriteStartNestedResourceInfo(false, nestedResourceInfo);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartNestedResourceInfoImplementation(nestedResourceInfo));
        }

        /// <summary>
        /// Finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        public sealed override void WriteEnd()
        {
            this.VerifyCanWriteEnd(true);
            this.WriteEndImplementation();
            if (this.CurrentScope.State == WriterState.Completed)
            {
                // Note that we intentionally go through the public API so that if the Flush fails the writer moves to the Error state.
                this.Flush();
            }
        }


        /// <summary>
        /// Asynchronously finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteEndAsync()
        {
            this.VerifyCanWriteEnd(false);
            return TaskUtils.GetTaskForSynchronousOperation(this.WriteEndImplementation)
                .FollowOnSuccessWithTask(
                    task =>
                    {
                        if (this.CurrentScope.State == WriterState.Completed)
                        {
                            // Note that we intentionally go through the public API so that if the Flush fails the writer moves to the Error state.
                            return this.FlushAsync();
                        }
                        else
                        {
                            return TaskUtils.CompletedTask;
                        }
                    });
        }

        /// <summary>
        /// Writes an entity reference link, which is used to represent binding to an existing resource in a request payload.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <remarks>
        /// This method can only be called for writing request messages. The entity reference link must be surrounded
        /// by a navigation link written through WriteStart/WriteEnd.
        /// The <see cref="ODataNestedResourceInfo.Url"/> will be ignored in that case and the Uri from the <see cref="ODataEntityReferenceLink.Url"/> will be used
        /// as the binding URL to be written.
        /// </remarks>
        public sealed override void WriteEntityReferenceLink(ODataEntityReferenceLink entityReferenceLink)
        {
            this.VerifyCanWriteEntityReferenceLink(entityReferenceLink, true);
            this.WriteEntityReferenceLinkImplementation(entityReferenceLink);
        }


        /// <summary>
        /// Asynchronously writes an entity reference link, which is used to represent binding to an existing resource in a request payload.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        /// <remarks>
        /// This method can only be called for writing request messages. The entity reference link must be surrounded
        /// by a navigation link written through WriteStart/WriteEnd.
        /// The <see cref="ODataNestedResourceInfo.Url"/> will be ignored in that case and the Uri from the <see cref="ODataEntityReferenceLink.Url"/> will be used
        /// as the binding URL to be written.
        /// </remarks>
        public sealed override Task WriteEntityReferenceLinkAsync(ODataEntityReferenceLink entityReferenceLink)
        {
            this.VerifyCanWriteEntityReferenceLink(entityReferenceLink, false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteEntityReferenceLinkImplementation(entityReferenceLink));
        }

        /// <summary>
        /// This method notifies the listener, that an in-stream error is to be written.
        /// </summary>
        /// <remarks>
        /// This listener can choose to fail, if the currently written payload doesn't support in-stream error at this position.
        /// If the listener returns, the writer should not allow any more writing, since the in-stream error is the last thing in the payload.
        /// </remarks>
        void IODataOutputInStreamErrorListener.OnInStreamError()
        {
            this.VerifyNotDisposed();

            // We're in a completed state trying to write an error (we can't write error after the payload was finished as it might
            // introduce another top-level element in XML)
            if (this.State == WriterState.Completed)
            {
                throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromCompleted(this.State.ToString(), WriterState.Error.ToString()));
            }

            this.StartPayloadInStartState();
            this.EnterScope(WriterState.Error, this.CurrentScope.Item);
        }

        /// <summary>
        /// This method is called when a stream is requested. It is a no-op.
        /// </summary>
        void IODataStreamListener.StreamRequested()
        {
        }


        /// <summary>
        /// This method is called when an async stream is requested. It is a no-op.
        /// </summary>
        /// <returns>A task for method called when a stream is requested.</returns>
        Task IODataStreamListener.StreamRequestedAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation(() => ((IODataStreamListener)this).StreamRequested());
        }

        /// <summary>
        /// This method is called when a stream is disposed.
        /// </summary>
        void IODataStreamListener.StreamDisposed()
        {
            Debug.Assert(this.State == WriterState.Stream || this.State == WriterState.String, "Stream was disposed when not in WriterState.Stream state.");

            // Complete writing the stream
            if (this.State == WriterState.Stream)
            {
                this.EndBinaryStream();
            }
            else if (this.State == WriterState.String)
            {
                this.EndTextWriter();
            }

            this.LeaveScope();
        }

        /// <summary>
        /// Get instance of the parent resource scope
        /// </summary>
        /// <returns>
        /// The parent resource scope
        /// Or null if there is no parent resource scope
        /// </returns>
        protected ResourceScope GetParentResourceScope()
        {
            ScopeStack scopeStack = new ScopeStack();
            Scope parentResourceScope = null;

            if (this.scopeStack.Count > 0)
            {
                // pop current scope and push into scope stack
                scopeStack.Push(this.scopeStack.Pop());
            }

            while (this.scopeStack.Count > 0)
            {
                Scope scope = this.scopeStack.Pop();
                scopeStack.Push(scope);

                if (scope is ResourceScope)
                {
                    parentResourceScope = scope;
                    break;
                }
            }

            while (scopeStack.Count > 0)
            {
                Scope scope = scopeStack.Pop();
                this.scopeStack.Push(scope);
            }

            return parentResourceScope as ResourceScope;
        }

        /// <summary>
        /// Determines whether a given writer state is considered an error state.
        /// </summary>
        /// <param name="state">The writer state to check.</param>
        /// <returns>True if the writer state is an error state; otherwise false.</returns>
        protected static bool IsErrorState(WriterState state)
        {
            return state == WriterState.Error;
        }

        /// <summary>
        /// Check if the object has been disposed; called from all public API methods. Throws an ObjectDisposedException if the object
        /// has already been disposed.
        /// </summary>
        protected abstract void VerifyNotDisposed();

        /// <summary>
        /// Flush the output.
        /// </summary>
        protected abstract void FlushSynchronously();


        /// <summary>
        /// Flush the output.
        /// </summary>
        /// <returns>Task representing the pending flush operation.</returns>
        protected abstract Task FlushAsynchronously();

        /// <summary>
        /// Start writing an OData payload.
        /// </summary>
        protected abstract void StartPayload();

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected abstract void StartResource(ODataResource resource);

        /// <summary>
        /// Finish writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected abstract void EndResource(ODataResource resource);

        /// <summary>
        /// Start writing a single property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected virtual void StartProperty(ODataPropertyInfo property)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected virtual void EndProperty(ODataPropertyInfo property)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">The resourceSet to write.</param>
        protected abstract void StartResourceSet(ODataResourceSet resourceSet);

        /// <summary>
        /// Start writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected virtual void StartDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Start writing a deleted resource.
        /// </summary>
        /// <param name="deletedEntry">The deleted entry to write.</param>
        protected virtual void StartDeletedResource(ODataDeletedResource deletedEntry)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a delta link or delta deleted link.
        /// </summary>
        /// <param name="deltaLink">The deleted entry to write.</param>
        protected virtual void StartDeltaLink(ODataDeltaLinkBase deltaLink)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a stream to write a binary value.
        /// </summary>
        /// <returns>A stream for writing the binary value.</returns>
        protected virtual Stream StartBinaryStream()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a stream.
        /// </summary>
        protected virtual void EndBinaryStream()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a TextWriter to write a string value.
        /// </summary>
        /// <returns>A TextWriter for writing the string value.</returns>
        protected virtual TextWriter StartTextWriter()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a string value.
        /// </summary>
        protected virtual void EndTextWriter()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing an OData payload.
        /// </summary>
        protected abstract void EndPayload();

        /// <summary>
        /// Finish writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">The resourceSet to write.</param>
        protected abstract void EndResourceSet(ODataResourceSet resourceSet);

        /// <summary>
        /// Finish writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected virtual void EndDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta resource set to write.</param>
        protected virtual void EndDeletedResource(ODataDeletedResource deletedResource)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a primitive value within an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">The primitive value to write.</param>
        protected virtual void WritePrimitiveValue(ODataPrimitiveValue primitiveValue)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a deferred (non-expanded) nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void WriteDeferredNestedResourceInfo(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Start writing a nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void StartNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Finish writing a nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void EndNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Write an entity reference link into a navigation link content.
        /// </summary>
        /// <param name="parentNestedResourceInfo">The parent navigation link which is being written around the entity reference link.</param>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        protected abstract void WriteEntityReferenceInNavigationLinkContent(ODataNestedResourceInfo parentNestedResourceInfo, ODataEntityReferenceLink entityReferenceLink);

        /// <summary>
        /// Create a new resource set scope.
        /// </summary>
        /// <param name="resourceSet">The resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected abstract ResourceSetScope CreateResourceSetScope(ODataResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared);

        /// <summary>
        /// Create a new delta resource set scope.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeltaResourceSetScope CreateDeltaResourceSetScope(ODataDeltaResourceSet deltaResourceSet, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected abstract ResourceScope CreateResourceScope(ODataResource resource, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared);

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The (deleted) resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeletedResourceScope CreateDeletedResourceScope(ODataDeletedResource resource, IEdmNavigationSource navigationSource, IEdmEntityType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new property scope.
        /// </summary>
        /// <param name="property">The property for the new scope.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created property scope.</returns>
        protected virtual PropertyInfoScope CreatePropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new delta link scope.
        /// </summary>
        /// <param name="link">The link for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeltaLinkScope CreateDeltaLinkScope(ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the serialization info for the given resource.
        /// </summary>
        /// <param name="resource">The resource to get the serialization info for.</param>
        /// <returns>The serialization info for the given resource.</returns>
        protected ODataResourceSerializationInfo GetResourceSerializationInfo(ODataResourceBase resource)
        {
            // Need to check for null for the resource since we can be writing a null reference to a navigation property.
            ODataResourceSerializationInfo serializationInfo = resource == null ? null : resource.SerializationInfo;

            // Always try to use the serialization info from the resource first. If it is not found on the resource, use the one inherited from the parent resourceSet.
            // Note that we don't try to guard against inconsistent serialization info between entries and their parent resourceSet.
            if (serializationInfo != null)
            {
                return serializationInfo;
            }

            ODataResourceSetBase resourceSet = this.CurrentScope.Item as ODataResourceSetBase;
            if (resourceSet != null)
            {
                return resourceSet.SerializationInfo;
            }

            return null;
        }

        /// <summary>
        /// Gets the serialization info for the given delta link.
        /// </summary>
        /// <param name="item">The resource to get the serialization info for.</param>
        /// <returns>The serialization info for the given resource.</returns>
        protected ODataResourceSerializationInfo GetLinkSerializationInfo(ODataItem item)
        {
            Debug.Assert(item != null, "item != null");

            ODataDeltaSerializationInfo deltaSerializationInfo = null;
            ODataResourceSerializationInfo resourceSerializationInfo = null;

            var deltaLink = item as ODataDeltaLink;
            if (deltaLink != null)
            {
                deltaSerializationInfo = deltaLink.SerializationInfo;
            }

            var deltaDeletedLink = item as ODataDeltaDeletedLink;
            if (deltaDeletedLink != null)
            {
                deltaSerializationInfo = deltaDeletedLink.SerializationInfo;
            }

            if (deltaSerializationInfo == null)
            {
                DeltaResourceSetScope parentDeltaResourceSetScope = this.CurrentScope as DeltaResourceSetScope;
                if (parentDeltaResourceSetScope != null)
                {
                    ODataDeltaResourceSet resourceSet = (ODataDeltaResourceSet)parentDeltaResourceSetScope.Item;
                    Debug.Assert(resourceSet != null, "resourceSet != null");

                    ODataResourceSerializationInfo deltaSetSerializationInfo = resourceSet.SerializationInfo;
                    if (deltaSetSerializationInfo != null)
                    {
                        resourceSerializationInfo = deltaSetSerializationInfo;
                    }
                }
            }
            else
            {
                resourceSerializationInfo = new ODataResourceSerializationInfo()
                {
                    NavigationSourceName = deltaSerializationInfo.NavigationSourceName
                };
            }

            return resourceSerializationInfo;
        }

        /// <summary>
        /// Creates a new nested resource info scope.
        /// </summary>
        /// <param name="writerState">The writer state for the new scope.</param>
        /// <param name="navLink">The nested resource info for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="itemType">The type for the items in the resourceSet to be written (or null if the resource set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created nested resource info scope.</returns>
        protected virtual NestedResourceInfoScope CreateNestedResourceInfoScope(
            WriterState writerState,
            ODataNestedResourceInfo navLink,
            IEdmNavigationSource navigationSource,
            IEdmType itemType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri)
        {
            return new NestedResourceInfoScope(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="resource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected virtual void PrepareResourceForWriteStart(ResourceScope resourceScope, ODataResource resource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            // No-op Atom and Verbose JSON. The JSON Light writer will override this method and inject the appropriate metadata builder
            // into the resource before writing.
            // Actually we can inject the metadata builder in here and
            // remove virtual from this method.
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the deleted resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="deletedResource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected virtual void PrepareDeletedResourceForWriteStart(DeletedResourceScope resourceScope, ODataDeletedResource deletedResource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            // No-op Atom and Verbose JSON. The JSON Light writer will override this method and inject the appropriate metadata builder
            // into the resource before writing.
            // Actually we can inject the metadata builder in here and
            // remove virtual from this method.
        }

        /// <summary>
        /// Gets the type of the resource and validates it against the model.
        /// </summary>
        /// <param name="resource">The resource to get the type for.</param>
        /// <returns>The validated structured type.</returns>
        protected IEdmStructuredType GetResourceType(ODataResourceBase resource)
        {
            return TypeNameOracle.ResolveAndValidateTypeFromTypeName(
                this.outputContext.Model,
                this.CurrentScope.ResourceType,
                resource.TypeName,
                this.WriterValidator);
        }

        /// <summary>
        /// Gets the element type of the resource set and validates it against the model.
        /// </summary>
        /// <param name="resourceSet">The resource set to get the element type for.</param>
        /// <returns>The validated structured element type.</returns>
        protected IEdmStructuredType GetResourceSetType(ODataResourceSetBase resourceSet)
        {
            return TypeNameOracle.ResolveAndValidateTypeFromTypeName(
                this.outputContext.Model,
                this.CurrentScope.ResourceType,
                EdmLibraryExtensions.GetCollectionItemTypeName(resourceSet.TypeName),
                this.WriterValidator);
        }

        /// <summary>
        /// Validates that the ODataResourceSet.DeltaLink is null for the given expanded resourceSet.
        /// </summary>
        /// <param name="resourceSet">The expanded resourceSet in question.</param>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "An instance field is used in a debug assert.")]
        protected void ValidateNoDeltaLinkForExpandedResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(
                this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value == true),
                "This should only be called when writing an expanded resourceSet.");

            if (resourceSet.DeltaLink != null)
            {
                throw new ODataException(Strings.ODataWriterCore_DeltaLinkNotSupportedOnExpandedResourceSet);
            }
        }

        /// <summary>
        /// Verifies that calling WriteStart resourceSet is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        private void VerifyCanWriteStartResourceSet(bool synchronousCall, ODataResourceSet resourceSet)
        {
            ExceptionUtils.CheckArgumentNotNull(resourceSet, "resourceSet");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
            this.StartPayloadInStartState();
        }

        /// <summary>
        /// Start writing a resourceSet - implementation of the actual functionality.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        private void WriteStartResourceSetImplementation(ODataResourceSet resourceSet)
        {
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.ResourceSet, resourceSet);
            this.EnterScope(WriterState.ResourceSet, resourceSet);

            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    // Verify query count
                    if (resourceSet.Count.HasValue)
                    {
                        // Check that Count is not set for requests
                        if (!this.outputContext.WritingResponse)
                        {
                            this.ThrowODataException(Strings.ODataWriterCore_QueryCountInRequest, resourceSet);
                        }

                        // Verify version requirements
                    }

                    this.StartResourceSet(resourceSet);
                });
            }
        }

        /// <summary>
        /// Verifies that calling WriteStart deltaResourceSet is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        private void VerifyCanWriteStartDeltaResourceSet(bool synchronousCall, ODataDeltaResourceSet deltaResourceSet)
        {
            ExceptionUtils.CheckArgumentNotNull(deltaResourceSet, "deltaResourceSet");

            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
            this.StartPayloadInStartState();
        }

        /// <summary>
        /// Start writing a delta resource set - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource Set to write.</param>
        private void WriteStartDeltaResourceSetImplementation(ODataDeltaResourceSet deltaResourceSet)
        {
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.ResourceSet, deltaResourceSet);
            this.EnterScope(WriterState.DeltaResourceSet, deltaResourceSet);

            this.InterceptException(() =>
            {
                // Check that links are not set for requests
                if (!this.outputContext.WritingResponse)
                {
                    if (deltaResourceSet.NextPageLink != null)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_QueryNextLinkInRequest, deltaResourceSet);
                    }

                    if (deltaResourceSet.DeltaLink != null)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_QueryDeltaLinkInRequest, deltaResourceSet);
                    }
                }

                this.StartDeltaResourceSet(deltaResourceSet);
            });
        }

        /// <summary>
        /// Verifies that calling WriteStart resource is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resource">Resource/item to write.</param>
        private void VerifyCanWriteStartResource(bool synchronousCall, ODataResource resource)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that calling WriteDeletedResource is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resource">Resource/item to write.</param>
        private void VerifyCanWriteStartDeletedResource(bool synchronousCall, ODataDeletedResource resource)
        {
            ExceptionUtils.CheckArgumentNotNull(resource, "resource");

            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a resource - implementation of the actual functionality.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        private void WriteStartResourceImplementation(ODataResource resource)
        {
            this.StartPayloadInStartState();
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.Resource, resource);
            this.EnterScope(WriterState.Resource, resource);
            if (!this.SkipWriting)
            {
                this.IncreaseResourceDepth();
                this.InterceptException(() =>
                {
                    if (resource != null)
                    {
                        ResourceScope resourceScope = (ResourceScope)this.CurrentScope;
                        this.ValidateResourceForResourceSet(resource, resourceScope);
                        this.PrepareResourceForWriteStart(
                            resourceScope,
                            resource,
                            this.outputContext.WritingResponse,
                            resourceScope.SelectedProperties);
                    }

                    this.StartResource(resource);
                });
            }
        }

        /// <summary>
        /// Start writing a delta deleted resource - implementation of the actual functionality.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        private void WriteStartDeletedResourceImplementation(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");

            this.StartPayloadInStartState();
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.Resource, resource);
            this.EnterScope(WriterState.DeletedResource, resource);
            this.IncreaseResourceDepth();

            this.InterceptException(() =>
            {
                DeletedResourceScope resourceScope = this.CurrentScope as DeletedResourceScope;
                this.ValidateResourceForResourceSet(resource, resourceScope);
                this.PrepareDeletedResourceForWriteStart(
                    resourceScope,
                    resource,
                    this.outputContext.WritingResponse,
                    resourceScope.SelectedProperties);
                this.StartDeletedResource(resource);
            });
        }

        /// <summary>
        /// Verifies that calling WriteStart for a property is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="property">Primitive property to write.</param>
        private void VerifyCanWriteProperty(bool synchronousCall, ODataPropertyInfo property)
        {
            ExceptionUtils.CheckArgumentNotNull(property, "property");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a property - implementation of the actual functionality.
        /// </summary>
        /// <param name="property">Property to write.</param>
        private void WriteStartPropertyImplementation(ODataPropertyInfo property)
        {
            this.EnterScope(WriterState.Property, property);
            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    this.StartProperty(property);
                    if (property is ODataProperty)
                    {
                        PropertyInfoScope scope = this.CurrentScope as PropertyInfoScope;
                        Debug.Assert(scope != null, "Scope for ODataPropertyInfo is not ODataPropertyInfoScope");
                        scope.ValueWritten = true;
                    }
                });
            }
        }

        /// <summary>
        /// Start writing a delta link or delta deleted link - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaLink">Delta (deleted) link to write.</param>
        private void WriteDeltaLinkImplementation(ODataDeltaLinkBase deltaLink)
        {
            this.EnterScope(deltaLink is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink, deltaLink);
            this.StartDeltaLink(deltaLink);
            this.WriteEnd();
        }

        /// <summary>
        /// Start writing a delta link or delta deleted link - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaLink">Delta (deleted) link to write.</param>
        /// <returns>The task.</returns>
        private async Task WriteDeltaLinkAsyncImplementation(ODataDeltaLinkBase deltaLink)
        {
            await TaskUtils.GetTaskForSynchronousOperation(() =>
            {
                EnterScope(deltaLink is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink, deltaLink);
                StartDeltaLink(deltaLink);
            }).FollowOnSuccessWithTask((t) => WriteEndAsync()).ConfigureAwait(false);
        }
        
        /// <summary>
        /// Verifies that calling WriteStart nested resource info is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        private void VerifyCanWriteStartNestedResourceInfo(bool synchronousCall, ODataNestedResourceInfo nestedResourceInfo)
        {
            ExceptionUtils.CheckArgumentNotNull(nestedResourceInfo, "nestedResourceInfo");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a nested resource info - implementation of the actual functionality.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        private void WriteStartNestedResourceInfoImplementation(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.EnterScope(WriterState.NestedResourceInfo, nestedResourceInfo);

            // If the parent resource has a metadata builder, use that metadatabuilder on the nested resource info as well.
            Debug.Assert(this.scopeStack.Parent != null, "Navigation link scopes must have a parent scope.");
            Debug.Assert(this.scopeStack.Parent.Item is ODataResourceBase, "The parent of a nested resource info scope should always be a resource");
            ODataResourceBase parentResource = (ODataResourceBase)this.scopeStack.Parent.Item;
            if (parentResource.MetadataBuilder != null)
            {
                nestedResourceInfo.MetadataBuilder = parentResource.MetadataBuilder;
            }
        }

        /// <summary>
        /// Verifies that calling WritePrimitive is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="primitiveValue">Primitive value to write.</param>
        private void VerifyCanWritePrimitive(bool synchronousCall, ODataPrimitiveValue primitiveValue)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Write primitive value - implementation of the actual functionality.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        private void WritePrimitiveValueImplementation(ODataPrimitiveValue primitiveValue)
        {
            this.InterceptException(() =>
            {
                this.EnterScope(WriterState.Primitive, primitiveValue);
                if (!(this.CurrentResourceSetValidator == null) && primitiveValue != null)
                {
                    Debug.Assert(primitiveValue.Value != null, "PrimitiveValue.Value should never be null!");
                    IEdmType itemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.Value.GetType()).Definition;
                    this.CurrentResourceSetValidator.ValidateResource(itemType);
                }

                this.WritePrimitiveValue(primitiveValue);
                this.WriteEnd();
            });
        }

        /// <summary>
        /// Write primitive value asynchronously - implementation of the actual functionality.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        /// <returns>The task.</returns>
        private async Task WritePrimitiveValueAsyncImplementation(ODataPrimitiveValue primitiveValue)
        {
            await InterceptExceptionAsync(async () =>
               {
                   await TaskUtils.GetTaskForSynchronousOperation(() =>
                   {
                       EnterScope(WriterState.Primitive, primitiveValue);
                       if (!(CurrentResourceSetValidator == null) && primitiveValue != null)
                       {
                           Debug.Assert(primitiveValue.Value != null, "PrimitiveValue.Value should never be null!");
                           IEdmType itemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.Value.GetType()).Definition;
                           CurrentResourceSetValidator.ValidateResource(itemType);
                       }

                       WritePrimitiveValue(primitiveValue);
                   }).FollowOnSuccessWithTask((t) => WriteEndAsync()).ConfigureAwait(false);
               }).ConfigureAwait(false);
        }
        
        /// <summary>
        /// Verifies that calling CreateWriteStream is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanCreateWriteStream(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Create a write stream - implementation of the actual functionality.
        /// </summary>
        /// <returns>A stream for writing the binary value.</returns>
        private Stream CreateWriteStreamImplementation()
        {
            this.EnterScope(WriterState.Stream, null);
            return new ODataNotificationStream(this.StartBinaryStream(), this);
        }

        /// <summary>
        /// Verifies that calling CreateTextWriter is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanCreateTextWriter(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Create a text writer - implementation of the actual functionality.
        /// </summary>
        /// <returns>A TextWriter for writing the string value.</returns>
        private TextWriter CreateTextWriterImplementation()
        {
            this.EnterScope(WriterState.String, null);
            return new ODataNotificationWriter(this.StartTextWriter(), this);
        }

        /// <summary>
        /// Verify that calling WriteEnd is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanWriteEnd(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        private void WriteEndImplementation()
        {
            this.InterceptException(() =>
            {
                Scope currentScope = this.CurrentScope;

                switch (currentScope.State)
                {
                    case WriterState.Resource:
                        if (!this.SkipWriting)
                        {
                            ODataResource resource = (ODataResource)currentScope.Item;

                            this.EndResource(resource);
                            this.DecreaseResourceDepth();
                        }

                        break;
                    case WriterState.DeletedResource:
                        if (!this.SkipWriting)
                        {
                            ODataDeletedResource resource = (ODataDeletedResource)currentScope.Item;

                            this.EndDeletedResource(resource);
                            this.DecreaseResourceDepth();
                        }

                        break;
                    case WriterState.ResourceSet:
                        if (!this.SkipWriting)
                        {
                            ODataResourceSet resourceSet = (ODataResourceSet)currentScope.Item;
                            WriterValidationUtils.ValidateResourceSetAtEnd(resourceSet, !this.outputContext.WritingResponse);
                            this.EndResourceSet(resourceSet);
                        }

                        break;
                    case WriterState.DeltaLink:
                    case WriterState.DeltaDeletedLink:
                        break;
                    case WriterState.DeltaResourceSet:
                        if (!this.SkipWriting)
                        {
                            ODataDeltaResourceSet deltaResourceSet = (ODataDeltaResourceSet)currentScope.Item;
                            WriterValidationUtils.ValidateDeltaResourceSetAtEnd(deltaResourceSet, !this.outputContext.WritingResponse);
                            this.EndDeltaResourceSet(deltaResourceSet);
                        }

                        break;
                    case WriterState.NestedResourceInfo:
                        if (!this.outputContext.WritingResponse)
                        {
                            throw new ODataException(Strings.ODataWriterCore_DeferredLinkInRequest);
                        }

                        if (!this.SkipWriting)
                        {
                            ODataNestedResourceInfo link = (ODataNestedResourceInfo)currentScope.Item;
                            this.DuplicatePropertyNameChecker.ValidatePropertyUniqueness(link);
                            this.WriteDeferredNestedResourceInfo(link);

                            this.MarkNestedResourceInfoAsProcessed(link);
                        }

                        break;
                    case WriterState.NestedResourceInfoWithContent:
                        if (!this.SkipWriting)
                        {
                            ODataNestedResourceInfo link = (ODataNestedResourceInfo)currentScope.Item;
                            this.EndNestedResourceInfoWithContent(link);

                            this.MarkNestedResourceInfoAsProcessed(link);
                        }

                        break;
                    case WriterState.Property:
                        {
                            ODataPropertyInfo property = (ODataPropertyInfo)currentScope.Item;
                            this.EndProperty(property);
                        }

                        break;
                    case WriterState.Primitive:
                        // WriteEnd for WriterState.Primitive is a no-op; just leave scope
                        break;
                    case WriterState.Stream:
                    case WriterState.String:
                        throw new ODataException(Strings.ODataWriterCore_StreamNotDisposed);
                    case WriterState.Start:                 // fall through
                    case WriterState.Completed:             // fall through
                    case WriterState.Error:                 // fall through
                        throw new ODataException(Strings.ODataWriterCore_WriteEndCalledInInvalidState(currentScope.State.ToString()));
                    default:
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_WriteEnd_UnreachableCodePath));
                }

                this.LeaveScope();
            });
        }

        /// <summary>
        /// Marks the navigation currently being written as processed in the parent entity's metadata builder.
        /// This is needed so that at the end of writing the resource we can query for all the unwritten navigation properties
        /// defined on the entity type and write out their metadata in fullmetadata mode.
        /// </summary>
        /// <param name="link">The nested resource info being written.</param>
        private void MarkNestedResourceInfoAsProcessed(ODataNestedResourceInfo link)
        {
            Debug.Assert(
                this.CurrentScope.State == WriterState.NestedResourceInfo || this.CurrentScope.State == WriterState.NestedResourceInfoWithContent,
                "This method should only be called when we're writing a nested resource info.");

            ODataResourceBase parent = (ODataResourceBase)this.scopeStack.Parent.Item;
            Debug.Assert(parent.MetadataBuilder != null, "parent.MetadataBuilder != null");
            parent.MetadataBuilder.MarkNestedResourceInfoProcessed(link.Name);
        }

        /// <summary>
        /// Verifies that calling WriteEntityReferenceLink is valid.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanWriteEntityReferenceLink(ODataEntityReferenceLink entityReferenceLink, bool synchronousCall)
        {
            ExceptionUtils.CheckArgumentNotNull(entityReferenceLink, "entityReferenceLink");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that calling Write(Deleted)DeltaLink is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="deltaLink">Delta link to write.</param>
        private void VerifyCanWriteLink(bool synchronousCall, ODataDeltaLinkBase deltaLink)
        {
            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);

            ExceptionUtils.CheckArgumentNotNull(deltaLink, "delta link");
        }

        /// <summary>
        /// Write an entity reference link.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        private void WriteEntityReferenceLinkImplementation(ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.EntityReferenceLink, null);
            Debug.Assert(
                this.CurrentScope.Item is ODataNestedResourceInfo || this.ParentNestedResourceInfoScope.Item is ODataNestedResourceInfo,
                "The CheckForNestedResourceInfoWithContent should have verified that entity reference link can only be written inside a nested resource info.");

            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    WriterValidationUtils.ValidateEntityReferenceLink(entityReferenceLink);

                    ODataNestedResourceInfo nestedInfo = this.CurrentScope.Item as ODataNestedResourceInfo;
                    if (nestedInfo == null)
                    {
                        NestedResourceInfoScope nestedResourceInfoScope = this.ParentNestedResourceInfoScope;
                        Debug.Assert(nestedResourceInfoScope != null);
                        nestedInfo = (ODataNestedResourceInfo)nestedResourceInfoScope.Item;
                    }

                    this.WriteEntityReferenceInNavigationLinkContent(nestedInfo, entityReferenceLink);
                });
            }
        }

        /// <summary>
        /// Verifies that calling Flush is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanFlush(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that a call is allowed to the writer.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCallAllowed(bool synchronousCall)
        {
            if (synchronousCall)
            {
                if (!this.outputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataWriterCore_SyncCallOnAsyncWriter);
                }
            }
            else
            {
                if (this.outputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataWriterCore_AsyncCallOnSyncWriter);
                }
            }
        }

        /// <summary>
        /// Verifies that the writer is a delta writer.
        /// </summary>
        private void VerifyWritingDelta()
        {
            if (!this.writingDelta)
            {
                throw new ODataException(Strings.ODataWriterCore_CannotWriteDeltaWithResourceSetWriter);
            }
        }

        /// <summary>
        /// Enters the 'ExceptionThrown' state and then throws an ODataException with the specified error message.
        /// </summary>
        /// <param name="errorMessage">The error message for the exception.</param>
        /// <param name="item">The OData item to associate with the 'ExceptionThrown' state.</param>
        private void ThrowODataException(string errorMessage, ODataItem item)
        {
            this.EnterScope(WriterState.Error, item);
            throw new ODataException(errorMessage);
        }

        /// <summary>
        /// Checks whether we are currently writing the first top-level element; if so call StartPayload
        /// </summary>
        private void StartPayloadInStartState()
        {
            if (this.State == WriterState.Start)
            {
                this.InterceptException(this.StartPayload);
            }
        }

        /// <summary>
        /// Checks whether we are currently writing a nested resource info and switches to NestedResourceInfoWithContent state if we do.
        /// </summary>
        /// <param name="contentPayloadKind">
        /// What kind of payload kind is being written as the content of a nested resource info.
        /// Only Resource Set, Resource or EntityReferenceLink are allowed.
        /// </param>
        /// <param name="contentPayload">The ODataResource or ODataResourceSet to write, or null for ODataEntityReferenceLink.</param>
        private void CheckForNestedResourceInfoWithContent(ODataPayloadKind contentPayloadKind, ODataItem contentPayload)
        {
            Debug.Assert(
                contentPayloadKind == ODataPayloadKind.ResourceSet || contentPayloadKind == ODataPayloadKind.Resource || contentPayloadKind == ODataPayloadKind.EntityReferenceLink,
                "Only ResourceSet, Resource or EntityReferenceLink can be specified as a payload kind for a nested resource info content.");

            Scope currentScope = this.CurrentScope;
            if (currentScope.State == WriterState.NestedResourceInfo || currentScope.State == WriterState.NestedResourceInfoWithContent)
            {
                ODataNestedResourceInfo currentNestedResourceInfo = (ODataNestedResourceInfo)currentScope.Item;
                this.InterceptException(() =>
                {
                    if (this.ParentResourceType != null)
                    {
                        IEdmStructuralProperty structuralProperty = this.ParentResourceType.FindProperty(currentNestedResourceInfo.Name) as IEdmStructuralProperty;
                        if (structuralProperty != null)
                        {
                            this.CurrentScope.ItemType = structuralProperty.Type.Definition.AsElementType();
                            IEdmNavigationSource parentNavigationSource = this.ParentResourceNavigationSource;

                            this.CurrentScope.NavigationSource = parentNavigationSource;
                        }
                        else
                        {
                            IEdmNavigationProperty navigationProperty =
                                 this.WriterValidator.ValidateNestedResourceInfo(currentNestedResourceInfo, this.ParentResourceType, contentPayloadKind);
                            if (navigationProperty != null)
                            {
                                this.CurrentScope.ResourceType = navigationProperty.ToEntityType();
                                IEdmNavigationSource parentNavigationSource = this.ParentResourceNavigationSource;

                                if (this.CurrentScope.NavigationSource == null)
                                {
                                    IEdmPathExpression bindingPath;
                                    this.CurrentScope.NavigationSource = parentNavigationSource == null ?
                                        null :
                                        parentNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, this.CurrentScope.ODataUri.Path.Segments, out bindingPath);
                                }
                            }
                        }
                    }
                });

                if (currentScope.State == WriterState.NestedResourceInfoWithContent)
                {
                    // If we are already in the NestedResourceInfoWithContent state, it means the caller is trying to write two items
                    // into the nested resource info content. This is only allowed for collection navigation property in request/response.
                    if (currentNestedResourceInfo.IsCollection != true)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_MultipleItemsInNestedResourceInfoWithContent, currentNestedResourceInfo);
                    }

                    // Note that we don't invoke duplicate property checker in this case as it's not necessary.
                    // What happens inside the nested resource info was already validated by the condition above.
                    // For collection in request we allow any combination anyway.
                    // For everything else we only allow a single item in the content and thus we will fail above.
                }
                else
                {
                    // we are writing a nested resource info with content; change the state
                    this.PromoteNestedResourceInfoScope(contentPayload);

                    if (!this.SkipWriting)
                    {
                        this.InterceptException(() =>
                        {
                            if (!(currentNestedResourceInfo.SerializationInfo != null && currentNestedResourceInfo.SerializationInfo.IsComplex)
                                && (this.CurrentScope.ItemType == null || this.CurrentScope.ItemType.IsEntityOrEntityCollectionType()))
                            {
                                this.DuplicatePropertyNameChecker.ValidatePropertyUniqueness(currentNestedResourceInfo);
                                this.StartNestedResourceInfoWithContent(currentNestedResourceInfo);
                            }
                        });
                    }
                }
            }
            else
            {
                if (contentPayloadKind == ODataPayloadKind.EntityReferenceLink)
                {
                    Scope parenScope = this.ParentNestedResourceInfoScope;
                    Debug.Assert(parenScope != null);
                    if (parenScope.State != WriterState.NestedResourceInfo && parenScope.State != WriterState.NestedResourceInfoWithContent)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_EntityReferenceLinkWithoutNavigationLink, null);
                    }
                }
            }
        }

        /// <summary>
        /// Verifies that the (deleted) resource has the correct type for the (delta) resource set.
        /// </summary>
        /// <param name="resource">The resource to be validated.</param>
        /// <param name="resourceScope">The scope for the resource to be validated.</param>
        private void ValidateResourceForResourceSet(ODataResourceBase resource, ResourceBaseScope resourceScope)
        {
            IEdmStructuredType resourceType = GetResourceType(resource);
            NestedResourceInfoScope parentNestedResourceInfoScope = this.ParentNestedResourceInfoScope;
            if (parentNestedResourceInfoScope != null)
            {
                // Validate the consistency of resource types in the nested resourceSet/resource
                this.WriterValidator.ValidateResourceInNestedResourceInfo(resourceType, parentNestedResourceInfoScope.ResourceType);
                resourceScope.ResourceTypeFromMetadata = parentNestedResourceInfoScope.ResourceType;

                this.WriterValidator.ValidateDerivedTypeConstraint(resourceType, resourceScope.ResourceTypeFromMetadata,
                    parentNestedResourceInfoScope.DerivedTypeConstraints, "property", ((ODataNestedResourceInfo)parentNestedResourceInfoScope.Item).Name);
            }
            else
            {
                resourceScope.ResourceTypeFromMetadata = this.ParentScope.ResourceType;
                if (this.CurrentResourceSetValidator != null)
                {
                    if (this.ParentScope.State == WriterState.DeltaResourceSet
                        && this.currentResourceDepth <= 1
                        && resourceScope.NavigationSource != null)
                    {
                        // if the (deleted) resource is in the top level of a delta resource set, it doesn't
                        // need to match the delta resource set, but must match the navigation source resolved for
                        // the current scope
                        if (!resourceScope.NavigationSource.EntityType().IsAssignableFrom(resourceType))
                        {
                            throw new ODataException(Strings.ResourceSetWithoutExpectedTypeValidator_IncompatibleTypes(resourceType.FullTypeName(), resourceScope.NavigationSource.EntityType()));
                        }

                        resourceScope.ResourceTypeFromMetadata = resourceScope.NavigationSource.EntityType();
                    }
                    else
                    {
                        // Validate the consistency of resource types
                        this.CurrentResourceSetValidator.ValidateResource(resourceType);
                    }
                }

                if (this.ParentScope.NavigationSource != null)
                {
                    this.WriterValidator.ValidateDerivedTypeConstraint(resourceType, resourceScope.ResourceTypeFromMetadata,
                        this.ParentScope.DerivedTypeConstraints, "navigation source", this.ParentScope.NavigationSource.Name);
                }
            }

            resourceScope.ResourceType = resourceType;

            // If writing in a delta resource set, the entity must have all key properties or the id set
            if (this.ParentScope.State == WriterState.DeltaResourceSet)
            {
                IEdmEntityType entityType = resourceType as IEdmEntityType;
                if (resource.Id == null &&
                    entityType != null &&
                    (this.outputContext.WritingResponse || resource is ODataDeletedResource) &&
                    !HasKeyProperties(entityType, resource.Properties))
                {
                    throw new ODataException(Strings.ODataWriterCore_DeltaResourceWithoutIdOrKeyProperties);
                }
            }
        }

        /// <summary>
        /// Determines whether a collection contains all key properties for a particular entity type.
        /// </summary>
        /// <param name="entityType">The entity type.</param>
        /// <param name="properties">The set of properties.</param>
        /// <returns>True if the set of properties include all key properties for the entity type; otherwise false.</returns>
        private static bool HasKeyProperties(IEdmEntityType entityType, IEnumerable<ODataProperty> properties)
        {
            Debug.Assert(entityType != null, "entityType null");
            if (properties == null)
            {
                return false;
            }

            return entityType.Key().All(keyProp => properties.Select(p => p.Name).Contains(keyProp.Name));
        }

        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the writer into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        private void InterceptException(Action action)
        {
            try
            {
                action();
            }
            catch
            {
                if (!IsErrorState(this.State))
                {
                    this.EnterScope(WriterState.Error, this.CurrentScope.Item);
                }

                throw;
            }
        }


        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the writer into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        /// <returns>The task.</returns>
        private async Task InterceptExceptionAsync(Func<Task> action)
        {
            try
            {
                await action().ConfigureAwait(false);
            }
            catch
            {
                if (!IsErrorState(this.State))
                {
                    this.EnterScope(WriterState.Error, this.CurrentScope.Item);
                }

                throw;
            }
        }
        
        /// <summary>
        /// Increments the nested resource count by one and fails if the new value exceeds the maximum nested resource depth limit.
        /// </summary>
        private void IncreaseResourceDepth()
        {
            this.currentResourceDepth++;

            if (this.currentResourceDepth > this.outputContext.MessageWriterSettings.MessageQuotas.MaxNestingDepth)
            {
                this.ThrowODataException(Strings.ValidationUtils_MaxDepthOfNestedEntriesExceeded(this.outputContext.MessageWriterSettings.MessageQuotas.MaxNestingDepth), null);
            }
        }

        /// <summary>
        /// Decrements the nested resource count by one.
        /// </summary>
        private void DecreaseResourceDepth()
        {
            Debug.Assert(this.currentResourceDepth > 0, "Resource depth should never become negative.");

            this.currentResourceDepth--;
        }


        /// <summary>
        /// Notifies the implementer of the <see cref="IODataReaderWriterListener"/> interface of relevant state changes in the writer.
        /// </summary>
        /// <param name="newState">The new writer state.</param>
        private void NotifyListener(WriterState newState)
        {
            if (this.listener != null)
            {
                if (IsErrorState(newState))
                {
                    this.listener.OnException();
                }
                else if (newState == WriterState.Completed)
                {
                    this.listener.OnCompleted();
                }
            }
        }

        /// <summary>
        /// Enter a new writer scope; verifies that the transition from the current state into new state is valid
        /// and attaches the item to the new scope.
        /// </summary>
        /// <param name="newState">The writer state to transition into.</param>
        /// <param name="item">The item to associate with the new scope.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug only cast.")]
        private void EnterScope(WriterState newState, ODataItem item)
        {
            this.InterceptException(() => this.ValidateTransition(newState));

            // If the parent scope was marked for skipping content, the new child scope should be as well.
            bool skipWriting = this.SkipWriting;

            Scope currentScope = this.CurrentScope;

            IEdmNavigationSource navigationSource = null;
            IEdmType itemType = null;
            SelectedPropertiesNode selectedProperties = currentScope.SelectedProperties;
            ODataUri odataUri = currentScope.ODataUri.Clone();
            if (odataUri.Path == null)
            {
                odataUri.Path = new ODataPath();
            }

            IEnumerable<string> derivedTypeConstraints = null;

            WriterState currentState = currentScope.State;

            if (newState == WriterState.Resource || newState == WriterState.ResourceSet || newState == WriterState.Primitive || newState == WriterState.DeltaResourceSet || newState == WriterState.DeletedResource)
            {
                // if we're in a DeltaResourceSet and writing a resource or deleted resource then the parent may not be the navigation source
                ODataResourceBase resource = item as ODataResourceBase;
                if (resource != null)
                {
                    IEdmModel model = this.outputContext.Model;
                    if (model != null && model.IsUserModel())
                    {
                        try
                        {
                            string typeNameFromResource = resource.TypeName;
                            if (!String.IsNullOrEmpty(typeNameFromResource))
                            {
                                // try resolving type from resource TypeName
                                itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                    model,
                                    typeNameFromResource,
                                    EdmTypeKind.None,
                                    /* expectStructuredType */ true,
                                    this.outputContext.WriterValidator);
                            }

                            // Try resolving navigation source from serialization info.
                            ODataResourceSerializationInfo serializationInfo = resource.SerializationInfo;
                            if (serializationInfo != null)
                            {
                                if (serializationInfo.NavigationSourceName != null)
                                {
                                    ODataUriParser uriParser = new ODataUriParser(model, new Uri(serializationInfo.NavigationSourceName, UriKind.Relative), this.outputContext.Container);
                                    odataUri = uriParser.ParseUri();
                                    navigationSource = odataUri.Path.NavigationSource();
                                    itemType = itemType ?? navigationSource.EntityType();
                                }

                                if (typeNameFromResource == null)
                                {
                                    // Try resolving entity type from SerializationInfo
                                    if (!string.IsNullOrEmpty(serializationInfo.ExpectedTypeName))
                                    {
                                        itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                            model,
                                            serializationInfo.ExpectedTypeName,
                                            EdmTypeKind.None,
                                            /* expectStructuredType */ true,
                                            this.outputContext.WriterValidator);
                                    }
                                    else if (!string.IsNullOrEmpty(serializationInfo.NavigationSourceEntityTypeName))
                                    {
                                        itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                            model,
                                            serializationInfo.NavigationSourceEntityTypeName,
                                            EdmTypeKind.Entity,
                                            /* expectStructuredType */ true,
                                            this.outputContext.WriterValidator);
                                    }
                                }
                            }
                        }
                        catch (ODataException)
                        {
                            // SerializationInfo doesn't match model.
                            // This should be an error but, for legacy reasons, we ignore this.
                        }
                    }
                }

                if (navigationSource == null)
                {
                    derivedTypeConstraints = currentScope.DerivedTypeConstraints;
                }
                else
                {
                    derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationSource);
                }

                navigationSource = navigationSource ?? currentScope.NavigationSource;
                itemType = itemType ?? currentScope.ItemType;

                // This is to resolve the item type for a resource set for an undeclared nested resource info.
                if (itemType == null
                    && (currentState == WriterState.Start || currentState == WriterState.NestedResourceInfo || currentState == WriterState.NestedResourceInfoWithContent)
                    && (newState == WriterState.ResourceSet || newState == WriterState.DeltaResourceSet))
                {
                    var resourceSet = item as ODataResourceSetBase;
                    if (resourceSet?.TypeName != null && this.outputContext.Model.IsUserModel())
                    {
                        var collectionType = TypeNameOracle.ResolveAndValidateTypeName(
                            this.outputContext.Model,
                            resourceSet.TypeName,
                            EdmTypeKind.Collection,
                            false,
                            this.outputContext.WriterValidator) as IEdmCollectionType;

                        if (collectionType != null)
                        {
                            itemType = collectionType.ElementType.Definition;
                        }
                    }
                }
            }

            // When writing a nested resource info, check if the link is being projected.
            // If we are projecting properties, but the nav. link is not projected mark it to skip its content.
            if ((currentState == WriterState.Resource || currentState == WriterState.DeletedResource) && newState == WriterState.NestedResourceInfo)
            {
                Debug.Assert(currentScope.Item is ODataResourceBase, "If the current state is Resource the current Item must be resource as well (and not null either).");
                Debug.Assert(item is ODataNestedResourceInfo, "If the new state is NestedResourceInfo the new item must be a nested resource info as well (and not null either).");
                ODataNestedResourceInfo nestedResourceInfo = (ODataNestedResourceInfo)item;

                if (!skipWriting)
                {
                    selectedProperties = currentScope.SelectedProperties.GetSelectedPropertiesForNavigationProperty(currentScope.ResourceType, nestedResourceInfo.Name);

                    if (this.outputContext.WritingResponse || this.writingDelta)
                    {
                        ODataPath odataPath = odataUri.Path;
                        IEdmStructuredType currentResourceType = currentScope.ResourceType;

                        var resourceScope = currentScope as ResourceBaseScope;
                        TypeSegment resourceTypeCast = null;
                        if (resourceScope.ResourceTypeFromMetadata != currentResourceType)
                        {
                            resourceTypeCast = new TypeSegment(currentResourceType, null);
                        }

                        var structuredProperty = this.WriterValidator.ValidatePropertyDefined(
                            nestedResourceInfo.Name, currentResourceType)
                            as IEdmStructuralProperty;

                        // Handle primitive or complex type property.
                        if (structuredProperty != null)
                        {
                            odataPath = AppendEntitySetKeySegment(odataPath, false);
                            itemType = structuredProperty.Type == null ? null : structuredProperty.Type.Definition.AsElementType();
                            navigationSource = null;

                            if (resourceTypeCast != null)
                            {
                                odataPath = odataPath.AddSegment(resourceTypeCast);
                            }

                            odataPath = odataPath.AddPropertySegment(structuredProperty);

                            derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(structuredProperty);
                        }
                        else
                        {
                            IEdmNavigationProperty navigationProperty = this.WriterValidator.ValidateNestedResourceInfo(nestedResourceInfo, currentResourceType, /*payloadKind*/null);
                            if (navigationProperty != null)
                            {
                                derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationProperty);

                                itemType = navigationProperty.ToEntityType();
                                if (!nestedResourceInfo.IsCollection.HasValue)
                                {
                                    nestedResourceInfo.IsCollection = navigationProperty.Type.IsEntityCollectionType();
                                }

                                if (!nestedResourceInfo.IsCollection.HasValue)
                                {
                                    nestedResourceInfo.IsCollection = navigationProperty.Type.IsEntityCollectionType();
                                }

                                IEdmNavigationSource currentNavigationSource = currentScope.NavigationSource;
                                IEdmPathExpression bindingPath;

                                if (resourceTypeCast != null)
                                {
                                    odataPath = odataPath.AddSegment(resourceTypeCast);
                                }

                                navigationSource = currentNavigationSource == null
                                    ? null
                                    : currentNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, odataPath.Segments, out bindingPath);

                                SelectExpandClause clause = odataUri.SelectAndExpand;
                                TypeSegment typeCastFromExpand = null;
                                if (clause != null)
                                {
                                    SelectExpandClause subClause;
                                    clause.GetSubSelectExpandClause(nestedResourceInfo.Name, out subClause, out typeCastFromExpand);
                                    odataUri.SelectAndExpand = subClause;
                                }

                                switch (navigationSource.NavigationSourceKind())
                                {
                                    case EdmNavigationSourceKind.ContainedEntitySet:
                                        // Containment cannot be written alone without odata uri.
                                        if (!odataPath.Any())
                                        {
                                            throw new ODataException(Strings.ODataWriterCore_PathInODataUriMustBeSetWhenWritingContainedElement);
                                        }

                                        odataPath = AppendEntitySetKeySegment(odataPath, true);

                                        if (odataPath != null && typeCastFromExpand != null)
                                        {
                                            odataPath = odataPath.AddSegment(typeCastFromExpand);
                                        }

                                        Debug.Assert(navigationSource is IEdmContainedEntitySet, "If the NavigationSourceKind is ContainedEntitySet, the navigationSource must be IEdmContainedEntitySet.");
                                        IEdmContainedEntitySet containedEntitySet = (IEdmContainedEntitySet)navigationSource;
                                        odataPath = odataPath.AddNavigationPropertySegment(containedEntitySet.NavigationProperty, containedEntitySet);
                                        break;
                                    case EdmNavigationSourceKind.EntitySet:
                                        odataPath = new ODataPath(new EntitySetSegment(navigationSource as IEdmEntitySet));
                                        break;
                                    case EdmNavigationSourceKind.Singleton:
                                        odataPath = new ODataPath(new SingletonSegment(navigationSource as IEdmSingleton));
                                        break;
                                    default:
                                        odataPath = null;
                                        break;
                                }
                            }
                        }

                        odataUri.Path = odataPath;
                    }
                }
            }
            else if ((currentState == WriterState.ResourceSet || currentState == WriterState.DeltaResourceSet) && (newState == WriterState.Resource || newState == WriterState.Primitive || newState == WriterState.ResourceSet || newState == WriterState.DeletedResource))
            {
                // When writing a new resource to a resourceSet, increment the count of entries on that resourceSet.
                if (currentState == WriterState.ResourceSet || currentState == WriterState.DeltaResourceSet)
                {
                    ((ResourceSetBaseScope)currentScope).ResourceCount++;
                }
            }

            if (navigationSource == null)
            {
                navigationSource = this.CurrentScope.NavigationSource ?? odataUri.Path.TargetNavigationSource();
            }

            this.PushScope(newState, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri, derivedTypeConstraints);

            this.NotifyListener(newState);
        }

        /// <summary>
        /// Attempt to append key segment to ODataPath.
        /// </summary>
        /// <param name="odataPath">The ODataPath to be evaluated.</param>
        /// <param name="throwIfFail">Whether throw if fails to append key segment.</param>
        /// <returns>The new odata path.</returns>
        private ODataPath AppendEntitySetKeySegment(ODataPath odataPath, bool throwIfFail)
        {
            ODataPath path = odataPath;

            try
            {
                if (EdmExtensionMethods.HasKey(this.CurrentScope.NavigationSource, this.CurrentScope.ResourceType))
                {
                    IEdmEntityType currentEntityType = this.CurrentScope.ResourceType as IEdmEntityType;
                    ODataResourceBase resource = this.CurrentScope.Item as ODataResourceBase;
                    Debug.Assert(resource != null,
                        "If the current state is Resource the current item must be an ODataResource as well (and not null either).");
                    KeyValuePair<string, object>[] keys = ODataResourceMetadataContext.GetKeyProperties(resource,
                        this.GetResourceSerializationInfo(resource), currentEntityType);
                    path = path.AddKeySegment(keys, currentEntityType, this.CurrentScope.NavigationSource);
                }
            }
            catch (ODataException)
            {
                if (throwIfFail)
                {
                    throw;
                }
            }

            return path;
        }

        /// <summary>
        /// Leave the current writer scope and return to the previous scope.
        /// When reaching the top-level replace the 'Started' scope with a 'Completed' scope.
        /// </summary>
        /// <remarks>Note that this method is never called once an error has been written or a fatal exception has been thrown.</remarks>
        private void LeaveScope()
        {
            Debug.Assert(this.State != WriterState.Error, "this.State != WriterState.Error");

            this.scopeStack.Pop();

            // if we are back at the root replace the 'Start' state with the 'Completed' state
            if (this.scopeStack.Count == 1)
            {
                Scope startScope = this.scopeStack.Pop();
                Debug.Assert(startScope.State == WriterState.Start, "startScope.State == WriterState.Start");
                this.PushScope(WriterState.Completed, /*item*/null, startScope.NavigationSource, startScope.ResourceType, /*skipWriting*/false, startScope.SelectedProperties, startScope.ODataUri, null);
                this.InterceptException(this.EndPayload);
                this.NotifyListener(WriterState.Completed);
            }
        }

        /// <summary>
        /// Promotes the current nested resource info scope to a nested resource info scope with content.
        /// </summary>
        /// <param name="content">The nested content to write. May be of either ODataResource or ODataResourceSet type.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Second cast only in debug.")]
        private void PromoteNestedResourceInfoScope(ODataItem content)
        {
            Debug.Assert(
                this.State == WriterState.NestedResourceInfo,
                "Only a NestedResourceInfo state can be promoted right now. If this changes please review the scope replacement code below.");
            Debug.Assert(
                this.CurrentScope.Item != null && this.CurrentScope.Item is ODataNestedResourceInfo,
                "Item must be a non-null nested resource info.");
            Debug.Assert(content == null || content is ODataResourceBase || content is ODataResourceSetBase);

            this.ValidateTransition(WriterState.NestedResourceInfoWithContent);
            NestedResourceInfoScope previousScope = (NestedResourceInfoScope)this.scopeStack.Pop();
            NestedResourceInfoScope newScope = previousScope.Clone(WriterState.NestedResourceInfoWithContent);

            this.scopeStack.Push(newScope);
            if (newScope.ItemType == null && content != null && !SkipWriting && !(content is ODataPrimitiveValue))
            {
                ODataPrimitiveValue primitiveValue = content as ODataPrimitiveValue;
                if (primitiveValue != null)
                {
                    newScope.ItemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.GetType()).Definition;
                }
                else
                {
                    ODataResourceBase resource = content as ODataResourceBase;
                    newScope.ResourceType = resource != null
                                            ? GetResourceType(resource)
                                            : GetResourceSetType(content as ODataResourceSetBase);
                }
            }
        }

        /// <summary>
        /// Verify that the transition from the current state into new state is valid .
        /// </summary>
        /// <param name="newState">The new writer state to transition into.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "All the transition checks are encapsulated in this method.")]
        private void ValidateTransition(WriterState newState)
        {
            if (!IsErrorState(this.State) && IsErrorState(newState))
            {
                // we can always transition into an error state if we are not already in an error state
                return;
            }

            switch (this.State)
            {
                case WriterState.Start:
                    if (newState != WriterState.ResourceSet && newState != WriterState.Resource && newState != WriterState.DeltaResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromStart(this.State.ToString(), newState.ToString()));
                    }

                    if ((newState == WriterState.ResourceSet || newState == WriterState.DeltaResourceSet) && !this.writingResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_CannotWriteTopLevelResourceSetWithResourceWriter);
                    }

                    if (newState == WriterState.Resource && this.writingResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_CannotWriteTopLevelResourceWithResourceSetWriter);
                    }

                    break;
                case WriterState.DeletedResource:
                case WriterState.Resource:
                    {
                        if (this.CurrentScope.Item == null)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromNullResource(this.State.ToString(), newState.ToString()));
                        }

                        if (newState != WriterState.NestedResourceInfo && newState != WriterState.Property)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResource(this.State.ToString(), newState.ToString()));
                        }

                        if (newState == WriterState.DeletedResource && this.ParentScope.State != WriterState.DeltaResourceSet)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                        }

                        if (this.State == WriterState.DeletedResource && this.Version < ODataVersion.V401 && newState == WriterState.NestedResourceInfo)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFrom40DeletedResource(this.State.ToString(), newState.ToString()));
                        }
                    }

                    break;
                case WriterState.ResourceSet:
                    // Within a typed resource set we can only write a resource.
                    // Within an untyped resource set we can also write a primitive value or nested resource set.
                    if (newState != WriterState.Resource &&
                        (this.CurrentScope.ResourceType != null &&
                            (this.CurrentScope.ResourceType.TypeKind != EdmTypeKind.Untyped ||
                                (newState != WriterState.Primitive && newState != WriterState.Stream && newState != WriterState.String && newState != WriterState.ResourceSet))))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.DeltaResourceSet:
                    if (newState != WriterState.Resource &&
                        newState != WriterState.DeletedResource &&
                        !(this.ScopeLevel < 3 && (newState == WriterState.DeltaDeletedLink || newState == WriterState.DeltaLink)))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.NestedResourceInfo:
                    if (newState != WriterState.NestedResourceInfoWithContent)
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidStateTransition(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.NestedResourceInfoWithContent:
                    if (newState != WriterState.ResourceSet && newState != WriterState.Resource && newState != WriterState.Primitive && (this.Version < ODataVersion.V401 || (newState != WriterState.DeltaResourceSet && newState != WriterState.DeletedResource)))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromExpandedLink(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.Property:
                    PropertyInfoScope propertyScope = this.CurrentScope as PropertyInfoScope;
                    Debug.Assert(propertyScope != null, "Scope in WriterState.Property is not PropertyInfoScope");
                    if (propertyScope.ValueWritten)
                    {
                        // we've already written the value for this property
                        ODataPropertyInfo propertyInfo = propertyScope.Item as ODataPropertyInfo;
                        Debug.Assert(propertyInfo != null, "Item in PropertyInfoScope is not ODataPropertyInfo");
                        throw new ODataException(Strings.ODataWriterCore_PropertyValueAlreadyWritten(propertyInfo.Name));
                    }

                    if (newState == WriterState.Stream || newState == WriterState.String || newState == WriterState.Primitive)
                    {
                        propertyScope.ValueWritten = true;
                    }
                    else
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidStateTransition(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.Stream:
                case WriterState.String:
                    throw new ODataException(Strings.ODataWriterCore_StreamNotDisposed);
                case WriterState.Completed:
                    // we should never see a state transition when in state 'Completed'
                    throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromCompleted(this.State.ToString(), newState.ToString()));
                case WriterState.Error:
                    if (newState != WriterState.Error)
                    {
                        // No more state transitions once we are in error state except for the fatal error
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromError(this.State.ToString(), newState.ToString()));
                    }

                    break;
                default:
                    throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_ValidateTransition_UnreachableCodePath));
            }
        }

        /// <summary>
        /// Create a new writer scope.
        /// </summary>
        /// <param name="state">The writer state of the scope to create.</param>
        /// <param name="item">The item attached to the scope to create.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The OdataUri info of this scope.</param>
        /// <param name="derivedTypeConstraints">The derived type constraints.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
        private void PushScope(WriterState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri,
            IEnumerable<string> derivedTypeConstraints)
        {
            IEdmStructuredType resourceType = itemType as IEdmStructuredType;

            Debug.Assert(
                state == WriterState.Error ||
                state == WriterState.Resource && (item == null || item is ODataResource) ||
                state == WriterState.DeletedResource && (item == null || item is ODataDeletedResource) ||
                state == WriterState.DeltaLink && (item == null || item is ODataDeltaLink) ||
                state == WriterState.DeltaDeletedLink && (item == null || item is ODataDeltaDeletedLink) ||
                state == WriterState.ResourceSet && item is ODataResourceSet ||
                state == WriterState.DeltaResourceSet && item is ODataDeltaResourceSet ||
                state == WriterState.Primitive && (item == null || item is ODataPrimitiveValue) ||
                state == WriterState.Property && (item is ODataPropertyInfo) ||
                state == WriterState.NestedResourceInfo && item is ODataNestedResourceInfo ||
                state == WriterState.NestedResourceInfoWithContent && item is ODataNestedResourceInfo ||
                state == WriterState.Stream && item == null ||
                state == WriterState.String && item == null ||
                state == WriterState.Start && item == null ||
                state == WriterState.Completed && item == null,
                "Writer state and associated item do not match.");

            bool isUndeclaredResourceOrResourceSet = false;
            if ((state == WriterState.Resource || state == WriterState.ResourceSet)
                && (this.CurrentScope.State == WriterState.NestedResourceInfo || this.CurrentScope.State == WriterState.NestedResourceInfoWithContent))
            {
                isUndeclaredResourceOrResourceSet = this.IsUndeclared(this.CurrentScope.Item as ODataNestedResourceInfo);
            }

            Scope scope;
            switch (state)
            {
                case WriterState.Resource:
                    scope = this.CreateResourceScope((ODataResource)item, navigationSource, resourceType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    break;
                case WriterState.DeletedResource:
                    scope = this.CreateDeletedResourceScope((ODataDeletedResource)item, navigationSource, (IEdmEntityType)itemType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    break;
                case WriterState.DeltaLink:
                case WriterState.DeltaDeletedLink:
                    scope = this.CreateDeltaLinkScope((ODataDeltaLinkBase)item, navigationSource, (IEdmEntityType)itemType, selectedProperties, odataUri);
                    break;
                case WriterState.ResourceSet:
                    scope = this.CreateResourceSetScope((ODataResourceSet)item, navigationSource, itemType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    if (this.outputContext.Model.IsUserModel())
                    {
                        Debug.Assert(scope is ResourceSetBaseScope, "Create a scope for a resource set that is not a ResourceSetBaseScope");
                        ((ResourceSetBaseScope)scope).ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(itemType);
                    }

                    break;
                case WriterState.DeltaResourceSet:
                    scope = this.CreateDeltaResourceSetScope((ODataDeltaResourceSet)item, navigationSource, resourceType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    if (this.outputContext.Model.IsUserModel())
                    {
                        Debug.Assert(scope is ResourceSetBaseScope, "Create a scope for a delta resource set that is not a ResourceSetBaseScope");
                        ((ResourceSetBaseScope)scope).ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(resourceType);
                    }

                    break;
                case WriterState.Property:
                    scope = this.CreatePropertyInfoScope((ODataPropertyInfo)item, navigationSource, resourceType, selectedProperties, odataUri);
                    break;
                case WriterState.NestedResourceInfo:            // fall through
                case WriterState.NestedResourceInfoWithContent:
                    scope = this.CreateNestedResourceInfoScope(state, (ODataNestedResourceInfo)item, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
                    break;
                case WriterState.Primitive:                 // fall through
                case WriterState.Stream:                    // fall through
                case WriterState.String:                    // fall through
                case WriterState.Start:                     // fall through
                case WriterState.Completed:                 // fall through
                case WriterState.Error:
                    scope = new Scope(state, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
                    break;
                default:
                    string errorMessage = Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_Scope_Create_UnreachableCodePath);
                    Debug.Assert(false, errorMessage);
                    throw new ODataException(errorMessage);
            }

            scope.DerivedTypeConstraints = derivedTypeConstraints;
            this.scopeStack.Push(scope);
        }

        /// <summary>
        /// Test to see if <paramref name="nestedResourceInfo"/> for a complex property or a collection of complex property, or a navigation property is declared or not.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested info in question</param>
        /// <returns>true if the nested info is undeclared; false if it is not, or if it cannot be determined</returns>
        private bool IsUndeclared(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            if (nestedResourceInfo.SerializationInfo != null)
            {
                return nestedResourceInfo.SerializationInfo.IsUndeclared;
            }
            else
            {
                return this.ParentResourceType != null && (this.ParentResourceType.FindProperty((this.CurrentScope.Item as ODataNestedResourceInfo).Name) == null);
            }
        }

        /// <summary>
        /// Lightweight wrapper for the stack of scopes which exposes a few helper properties for getting parent scopes.
        /// </summary>
        internal sealed class ScopeStack
        {
            /// <summary>
            /// Use a list to store the scopes instead of a true stack so that parent/grandparent lookups will be fast.
            /// </summary>
            private readonly Stack<Scope> scopes = new Stack<Scope>();

            /// <summary>
            /// Initializes a new instance of the <see cref="ScopeStack"/> class.
            /// </summary>
            internal ScopeStack()
            {
            }

            /// <summary>
            /// Gets the count of items in the stack.
            /// </summary>
            internal int Count
            {
                get
                {
                    return this.scopes.Count;
                }
            }

            /// <summary>
            /// Gets the scope below the current scope on top of the stack.
            /// </summary>
            internal Scope Parent
            {
                get
                {
                    Debug.Assert(this.scopes.Count > 1, "this.scopes.Count > 1");
                    Scope current = this.scopes.Pop();
                    Scope parent = this.scopes.Peek();
                    this.scopes.Push(current);
                    return parent;
                }
            }

            /// <summary>
            /// Gets the scope below the parent of the current scope on top of the stack.
            /// </summary>
            internal Scope ParentOfParent
            {
                get
                {
                    Debug.Assert(this.scopes.Count > 2, "this.scopes.Count > 2");
                    Scope current = this.scopes.Pop();
                    Scope parent = this.scopes.Pop();
                    Scope parentOfParent = this.scopes.Peek();
                    this.scopes.Push(parent);
                    this.scopes.Push(current);
                    return parentOfParent;
                }
            }

            /// <summary>
            /// Gets the scope below the current scope on top of the stack or null if there is only one item on the stack or the stack is empty.
            /// </summary>
            internal Scope ParentOrNull
            {
                get
                {
                    return this.Count == 0 ? null : this.Parent;
                }
            }

            internal Stack<Scope> Scopes
            {
                get { return this.scopes; }
            }

            /// <summary>
            /// Pushes the specified scope onto the stack.
            /// </summary>
            /// <param name="scope">The scope.</param>
            internal void Push(Scope scope)
            {
                Debug.Assert(scope != null, "scope != null");
                this.scopes.Push(scope);
            }

            /// <summary>
            /// Pops the current scope off the stack.
            /// </summary>
            /// <returns>The popped scope.</returns>
            internal Scope Pop()
            {
                Debug.Assert(this.scopes.Count > 0, "this.scopes.Count > 0");
                return this.scopes.Pop();
            }

            /// <summary>
            /// Peeks at the current scope on the top of the stack.
            /// </summary>
            /// <returns>The current scope at the top of the stack.</returns>
            internal Scope Peek()
            {
                Debug.Assert(this.scopes.Count > 0, "this.scopes.Count > 0");
                return this.scopes.Peek();
            }
        }

        /// <summary>
        /// A writer scope; keeping track of the current writer state and an item associated with this state.
        /// </summary>
        internal class Scope
        {
            /// <summary>The writer state of this scope.</summary>
            private readonly WriterState state;

            /// <summary>The item attached to this scope.</summary>
            private readonly ODataItem item;

            /// <summary>Set to true if the content of the scope should not be written.</summary>
            /// <remarks>This is used when writing navigation links which were not projected on the owning resource.</remarks>
            private readonly bool skipWriting;

            /// <summary>The selected properties for the current scope.</summary>
            private readonly SelectedPropertiesNode selectedProperties;

            /// <summary>The navigation source we are going to write entities for.</summary>
            private IEdmNavigationSource navigationSource;

            /// <summary>The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</summary>
            private IEdmStructuredType resourceType;

            /// <summary>The IEdmType of the item (may not be structured for primitive types).</summary>
            private IEdmType itemType;

            /// <summary>The odata uri info for current scope.</summary>
            private ODataUri odataUri;

            /// <summary>
            /// Constructor creating a new writer scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of this scope should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal Scope(WriterState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
            {
                this.state = state;
                this.item = item;
                this.itemType = itemType;
                this.resourceType = itemType as IEdmStructuredType;
                this.navigationSource = navigationSource;
                this.skipWriting = skipWriting;
                this.selectedProperties = selectedProperties;
                this.odataUri = odataUri;
            }

            /// <summary>
            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).
            /// </summary>
            public IEdmStructuredType ResourceType
            {
                get
                {
                    return this.resourceType;
                }

                set
                {
                    this.resourceType = value;
                    this.itemType = value;
                }
            }

            /// <summary>
            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).
            /// </summary>
            public IEdmType ItemType
            {
                get
                {
                    return this.itemType;
                }

                set
                {
                    this.itemType = value;
                    this.resourceType = value as IEdmStructuredType;
                }
            }

            /// <summary>
            /// The writer state of this scope.
            /// </summary>
            internal WriterState State
            {
                get
                {
                    return this.state;
                }
            }

            /// <summary>
            /// The item attached to this scope.
            /// </summary>
            internal ODataItem Item
            {
                get
                {
                    return this.item;
                }
            }

            /// <summary>The navigation source we are going to write entities for.</summary>
            internal IEdmNavigationSource NavigationSource
            {
                get
                {
                    return this.navigationSource;
                }

                set
                {
                    this.navigationSource = value;
                }
            }

            /// <summary>The selected properties for the current scope.</summary>
            internal SelectedPropertiesNode SelectedProperties
            {
                get
                {
                    return this.selectedProperties;
                }
            }

            /// <summary>The odata Uri for the current scope.</summary>
            internal ODataUri ODataUri
            {
                get
                {
                    Debug.Assert(this.odataUri != null, "this.odataUri != null");
                    return this.odataUri;
                }
            }

            /// <summary>
            /// Set to true if the content of this scope should not be written.
            /// </summary>
            internal bool SkipWriting
            {
                get
                {
                    return this.skipWriting;
                }
            }

            /// <summary>Gets or sets the derived type constraints for the current scope.</summary>
            internal IEnumerable<string> DerivedTypeConstraints { get; set; }
        }

        /// <summary>
        /// A base scope for a resourceSet.
        /// </summary>
        internal abstract class ResourceSetBaseScope : Scope
        {
            /// <summary>The serialization info for the current resourceSet.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>
            /// The <see cref="ResourceSetWithoutExpectedTypeValidator"/> to use for entries in this resourceSet.
            /// </summary>
            private ResourceSetWithoutExpectedTypeValidator resourceTypeValidator;

            /// <summary>The number of entries in this resourceSet seen so far.</summary>
            private int resourceCount;

            /// <summary>Maintains the write status for each annotation using its key.</summary>
            private InstanceAnnotationWriteTracker instanceAnnotationWriteTracker;

            /// <summary>The type context to answer basic questions regarding the type info of the resource.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="writerState">The writer state for the scope.</param>
            /// <param name="resourceSet">The resourceSet for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal ResourceSetBaseScope(WriterState writerState, ODataResourceSetBase resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                this.serializationInfo = resourceSet.SerializationInfo;
            }

            /// <summary>
            /// The number of entries in this resource Set seen so far.
            /// </summary>
            internal int ResourceCount
            {
                get
                {
                    return this.resourceCount;
                }

                set
                {
                    this.resourceCount = value;
                }
            }

            /// <summary>
            /// Tracks the write status of the annotations.
            /// </summary>
            internal InstanceAnnotationWriteTracker InstanceAnnotationWriteTracker
            {
                get
                {
                    if (this.instanceAnnotationWriteTracker == null)
                    {
                        this.instanceAnnotationWriteTracker = new InstanceAnnotationWriteTracker();
                    }

                    return this.instanceAnnotationWriteTracker;
                }
            }

            /// <summary>
            /// Validator for resource type.
            /// </summary>
            internal ResourceSetWithoutExpectedTypeValidator ResourceTypeValidator
            {
                get
                {
                    return this.resourceTypeValidator;
                }

                set
                {
                    this.resourceTypeValidator = value;
                }
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">True if writing a response payload, false otherwise.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            internal ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse)
            {
                if (this.typeContext == null)
                {
                    // For Entity, currently we check the navigation source.
                    // For Complex, we don't have navigation source, So we shouldn't check it.
                    // If ResourceType is not provided, serialization info or navigation source info should be provided.
                    var throwIfMissingTypeInfo = writingResponse && (this.ResourceType == null || this.ResourceType.TypeKind == EdmTypeKind.Entity);

                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        this.ResourceType,
                        throwIfMissingTypeInfo);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A scope for a resource set.
        /// </summary>
        internal abstract class ResourceSetScope : ResourceSetBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="item">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type of the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected ResourceSetScope(ODataResourceSet item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.ResourceSet, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta resource set.
        /// </summary>
        internal abstract class DeltaResourceSetScope : ResourceSetBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="item">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="resourceType">The structured type of the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeltaResourceSetScope(ODataDeltaResourceSet item, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.DeltaResourceSet, item, navigationSource, resourceType, false /*skip writing*/, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// The context uri info created for this scope.
            /// </summary>
            public ODataContextUrlInfo ContextUriInfo { get; set; }
        }

        /// <summary>
        /// A base scope for a resource.
        /// </summary>
        internal class ResourceBaseScope : Scope
        {
            /// <summary>Checker to detect duplicate property names.</summary>
            private readonly IDuplicatePropertyNameChecker duplicatePropertyNameChecker;

            /// <summary>The serialization info for the current resource.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>The resource type which was derived from the model (may be either the same as structured type or its base type.</summary>
            private IEdmStructuredType resourceTypeFromMetadata;

            /// <summary>The type context to answer basic questions regarding the type info of the resource.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>Maintains the write status for each annotation using its key.</summary>
            private InstanceAnnotationWriteTracker instanceAnnotationWriteTracker;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal ResourceBaseScope(WriterState state, ODataResourceBase resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, resource, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                Debug.Assert(writerSettings != null, "writerBehavior != null");

                if (resource != null)
                {
                    duplicatePropertyNameChecker = writerSettings.Validator.CreateDuplicatePropertyNameChecker();
                }

                this.serializationInfo = serializationInfo;
            }

            /// <summary>
            /// The structured type which was derived from the model, i.e. the expected structured type, which may be either the same as structured type or its base type.
            /// For example, if we are writing a resource set of Customers and the current resource is of DerivedCustomer, this.ResourceTypeFromMetadata would be Customer and this.ResourceType would be DerivedCustomer.
            /// </summary>
            public IEdmStructuredType ResourceTypeFromMetadata
            {
                get
                {
                    return this.resourceTypeFromMetadata;
                }

                internal set
                {
                    this.resourceTypeFromMetadata = value;
                }
            }

            /// <summary>
            /// The serialization info for the current resource.
            /// </summary>
            public ODataResourceSerializationInfo SerializationInfo
            {
                get { return this.serializationInfo; }
            }

            /// <summary>
            /// Checker to detect duplicate property names.
            /// </summary>
            internal IDuplicatePropertyNameChecker DuplicatePropertyNameChecker
            {
                get
                {
                    return duplicatePropertyNameChecker;
                }
            }

            /// <summary>
            /// Tracks the write status of the annotations.
            /// </summary>
            internal InstanceAnnotationWriteTracker InstanceAnnotationWriteTracker
            {
                get
                {
                    if (this.instanceAnnotationWriteTracker == null)
                    {
                        this.instanceAnnotationWriteTracker = new InstanceAnnotationWriteTracker();
                    }

                    return this.instanceAnnotationWriteTracker;
                }
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">True if writing a response payload, false otherwise.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            public ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse)
            {
                if (this.typeContext == null)
                {
                    IEdmStructuredType expectedResourceType = this.ResourceTypeFromMetadata ?? this.ResourceType;

                    // For entity, we will check the navigation source info
                    bool throwIfMissingTypeInfo = writingResponse && (expectedResourceType == null || expectedResourceType.TypeKind == EdmTypeKind.Entity);

                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        expectedResourceType,
                        throwIfMissingTypeInfo);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A base scope for a resource.
        /// </summary>
        internal class ResourceScope : ResourceBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected ResourceScope(ODataResource resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.Resource, resource, serializationInfo, navigationSource, resourceType, skipWriting, writerSettings, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// Base class for DeletedResourceScope.
        /// </summary>
        internal class DeletedResourceScope : ResourceBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeletedResourceScope(ODataDeletedResource resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.DeletedResource, resource, serializationInfo, navigationSource, entityType, false /*skipWriting*/, writerSettings, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta link.
        /// </summary>
        internal abstract class DeltaLinkScope : Scope
        {
            /// <summary>The serialization info for the current link.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>
            /// Fake entity type to be passed to context.
            /// </summary>
            private readonly EdmEntityType fakeEntityType = new EdmEntityType("MyNS", "Fake");

            /// <summary>The type context to answer basic questions regarding the type info of the link.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>
            /// Constructor to create a new delta link scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="link">The link for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeltaLinkScope(WriterState state, ODataItem link, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, link, navigationSource, entityType, /*skipWriting*/false, selectedProperties, odataUri)
            {
                Debug.Assert(link != null, "link != null");
                Debug.Assert(
                    state == WriterState.DeltaLink && link is ODataDeltaLink ||
                    state == WriterState.DeltaDeletedLink && link is ODataDeltaDeletedLink,
                    "link must be either DeltaLink or DeltaDeletedLink.");

                this.serializationInfo = serializationInfo;
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">Whether writing Json payload. Should always be true.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            public ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse = true)
            {
                if (this.typeContext == null)
                {
                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        this.fakeEntityType,
                        writingResponse);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A scope for writing a single property within a resource.
        /// </summary>
        internal class PropertyInfoScope : Scope
        {
            /// <summary>
            /// Constructor to create a new property scope.
            /// </summary>
            /// <param name="property">The property for the new scope.</param>
            /// <param name="navigationSource">The navigation source.</param>
            /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal PropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.Property, property, navigationSource, resourceType, /*skipWriting*/ false, selectedProperties, odataUri)
            {
                ValueWritten = false;
            }

            public ODataPropertyInfo Property
            {
                get
                {
                    Debug.Assert(this.Item is ODataProperty, "The item of a property scope is not an item.");
                    return this.Item as ODataProperty;
                }
            }

            internal bool ValueWritten { get; set; }
        }

        /// <summary>
        /// A scope for a nested resource info.
        /// </summary>
        internal class NestedResourceInfoScope : Scope
        {
            /// <summary>
            /// Constructor to create a new nested resource info scope.
            /// </summary>
            /// <param name="writerState">The writer state for the new scope.</param>
            /// <param name="navLink">The nested resource info for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal NestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// Clones this nested resource info scope and sets a new writer state.
            /// </summary>
            /// <param name="newWriterState">The <see cref="WriterState"/> to set.</param>
            /// <returns>The cloned nested resource info scope with the specified writer state.</returns>
            internal virtual NestedResourceInfoScope Clone(WriterState newWriterState)
            {
                return new NestedResourceInfoScope(newWriterState, (ODataNestedResourceInfo)this.Item, this.NavigationSource, this.ItemType, this.SkipWriting, this.SelectedProperties, this.ODataUri)
                {
                    DerivedTypeConstraints = this.DerivedTypeConstraints
                };
            }
        }
    }
}

---- Transformed Tree ----
using System.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Threading.Tasks;
using Microsoft.OData.Evaluation;
using Microsoft.OData.UriParser;
using Microsoft.OData.Edm;
using Microsoft.OData.Metadata;

namespace Microsoft.OData
{
    /// <summary>
    /// Base class for OData writers that verifies a proper sequence of write calls on the writer.
    /// </summary>
    internal abstract class ODataWriterCore : ODataWriter, IODataOutputInStreamErrorListener, IODataStreamListener
    {
        /// <summary>The writer validator to use.</summary>
        protected readonly IWriterValidator WriterValidator;

        /// <summary>The output context to write to.</summary>
        private readonly ODataOutputContext outputContext;

        /// <summary>True if the writer was created for writing a resourceSet; false when it was created for writing a resource.</summary>
        private readonly bool writingResourceSet;

        /// <summary>True if the writer was created for writing a delta response; false otherwise.</summary>
        private readonly bool writingDelta;

        /// <summary>If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</summary>
        private readonly IODataReaderWriterListener listener;

        /// <summary>Stack of writer scopes to keep track of the current context of the writer.</summary>
        private readonly ScopeStack scopeStack = new ScopeStack();

        /// <summary>The number of entries which have been started but not yet ended.</summary>
        private int currentResourceDepth;

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="outputContext">The output context to write to.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="writingResourceSet">True if the writer is created for writing a resourceSet; false when it is created for writing a resource.</param>
        /// <param name="writingDelta">True if the writer is created for writing a delta response; false otherwise.</param>
        /// <param name="listener">If not null, the writer will notify the implementer of the interface of relevant state changes in the writer.</param>
        protected ODataWriterCore(
            ODataOutputContext outputContext,
            IEdmNavigationSource navigationSource,
            IEdmStructuredType resourceType,
            bool writingResourceSet,
            bool writingDelta = false,
            IODataReaderWriterListener listener = null)
        {
            Debug.Assert(outputContext != null, "outputContext != null");

            this.outputContext = outputContext;
            this.writingResourceSet = writingResourceSet;
            this.writingDelta = writingDelta || (!writingResourceSet && !outputContext.WritingResponse);
            this.WriterValidator = outputContext.WriterValidator;
            this.Version = outputContext.MessageWriterSettings.Version;

            if (navigationSource != null && resourceType == null)
            {
                resourceType = this.outputContext.EdmTypeResolver.GetElementType(navigationSource);
            }

            ODataUri odataUri = outputContext.MessageWriterSettings.ODataUri.Clone();

            // Remove key for top level resource
            if (!writingResourceSet && odataUri != null && odataUri.Path != null)
            {
                odataUri.Path = odataUri.Path.TrimEndingKeySegment();
            }

            this.listener = listener;

            this.scopeStack.Push(new Scope(WriterState.Start, /*item*/null, navigationSource, resourceType, /*skipWriting*/false, outputContext.MessageWriterSettings.SelectedProperties, odataUri));
            this.CurrentScope.DerivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationSource);
        }

        /// <summary>
        /// An enumeration representing the current state of the writer.
        /// </summary>
        internal enum WriterState
        {
            /// <summary>The writer is at the start; nothing has been written yet.</summary>
            Start,

            /// <summary>The writer is currently writing a resource.</summary>
            Resource,

            /// <summary>The writer is currently writing a resourceSet.</summary>
            ResourceSet,

            /// <summary>The writer is currently writing a delta resource set.</summary>
            DeltaResourceSet,

            /// <summary>The writer is currently writing a deleted resource.</summary>
            DeletedResource,

            /// <summary>The writer is currently writing a delta link.</summary>
            DeltaLink,

            /// <summary>The writer is currently writing a delta deleted link.</summary>
            DeltaDeletedLink,

            /// <summary>The writer is currently writing a nested resource info (possibly an expanded link but we don't know yet).</summary>
            /// <remarks>
            /// This state is used when a nested resource info was started but we didn't see any children for it yet.
            /// </remarks>
            NestedResourceInfo,

            /// <summary>The writer is currently writing a nested resource info with content.</summary>
            /// <remarks>
            /// This state is used when a nested resource info with either an entity reference link or expanded resourceSet/resource was written.
            /// </remarks>
            NestedResourceInfoWithContent,

            /// <summary>The writer is currently writing a primitive value.</summary>
            Primitive,

            /// <summary>The writer is currently writing a single property.</summary>
            Property,

            /// <summary>The writer is currently writing a stream value.</summary>
            Stream,

            /// <summary>The writer is currently writing a string value.</summary>
            String,

            /// <summary>The writer has completed; nothing can be written anymore.</summary>
            Completed,

            /// <summary>The writer is in error state; nothing can be written anymore.</summary>
            Error
        }

        /// <summary>
        /// OData Version being written.
        /// </summary>
        internal ODataVersion? Version { get; }

        /// <summary>
        /// The current scope for the writer.
        /// </summary>
        protected Scope CurrentScope
        {
            get
            {
                Debug.Assert(this.scopeStack.Count > 0, "We should have at least one active scope all the time.");
                return this.scopeStack.Peek();
            }
        }

        /// <summary>
        /// The current state of the writer.
        /// </summary>
        protected WriterState State
        {
            get
            {
                return this.CurrentScope.State;
            }
        }

        /// <summary>
        /// true if the writer should not write any input specified and should just skip it.
        /// </summary>
        protected bool SkipWriting
        {
            get
            {
                return this.CurrentScope.SkipWriting;
            }
        }

        /// <summary>
        /// A flag indicating whether the writer is at the top level.
        /// </summary>
        protected bool IsTopLevel
        {
            get
            {
                Debug.Assert(this.State != WriterState.Start && this.State != WriterState.Completed, "IsTopLevel should only be called while writing the payload.");

                // there is the root scope at the top (when the writer has not started or has completed)
                // and then the top-level scope (the top-level resource/resourceSet item) as the second scope on the stack
                return this.scopeStack.Count == 2;
            }
        }

        /// <summary>
        /// The scope level the writer is writing.
        /// </summary>
        protected int ScopeLevel
        {
            get { return this.scopeStack.Count; }
        }

        /// <summary>
        /// Returns the immediate parent link which is being expanded, or null if no such link exists
        /// </summary>
        protected ODataNestedResourceInfo ParentNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "ParentNestedResourceInfo should only be called while writing a resource or a resourceSet.");

                Scope linkScope = this.scopeStack.ParentOrNull;
                return linkScope == null ? null : (linkScope.Item as ODataNestedResourceInfo);
            }
        }

        /// <summary>
        /// Returns the nested info that current resource belongs to.
        /// </summary>
        protected ODataNestedResourceInfo BelongingNestedResourceInfo
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.ResourceSet || this.State == WriterState.DeletedResource || this.State == WriterState.DeltaResourceSet, "BelongingNestedResourceInfo should only be called while writing a (deleted) resource or a (delta) resourceSet.");

                Scope linkScope = this.scopeStack.ParentOrNull;

                // For single navigation
                if (linkScope is NestedResourceInfoScope)
                {
                    return linkScope.Item as ODataNestedResourceInfo;
                }
                else if (linkScope is ResourceSetBaseScope)
                {
                    // For resource under collection of navigation/complex, parent is ResourceSetScope, so we need find parent of parent.
                    linkScope = this.scopeStack.ParentOfParent;
                    return linkScope == null ? null : (linkScope.Item as ODataNestedResourceInfo);
                }
                else
                {
                    return null;
                }
            }
        }

        /// <summary>
        /// Returns the resource type of the immediate parent resource for which a nested resource info is being written.
        /// </summary>
        protected IEdmStructuredType ParentResourceType
        {
            get
            {
                Debug.Assert(
                    this.State == WriterState.NestedResourceInfo || this.State == WriterState.NestedResourceInfoWithContent,
                    "ParentResourceType should only be called while writing a nested resource info (with or without content), or within an untyped ResourceSet.");
                Scope resourceScope = this.scopeStack.Parent;
                return resourceScope.ResourceType;
            }
        }

        /// <summary>
        /// Returns the navigation source of the immediate parent resource for which a nested resource info is being written.
        /// </summary>
        protected IEdmNavigationSource ParentResourceNavigationSource
        {
            get
            {
                Scope resourceScope = this.scopeStack.Parent;
                return resourceScope == null ? null : resourceScope.NavigationSource;
            }
        }

        /// <summary>
        /// Returns the parent scope of current scope.
        /// </summary>
        protected Scope ParentScope
        {
            get
            {
                Debug.Assert(this.scopeStack.Count > 1);
                return this.scopeStack.Scopes.Skip(1).First();
            }
        }

        /// <summary>
        /// Returns the number of items seen so far on the current resource set scope.
        /// </summary>
        /// <remarks>Can only be accessed on a resource set scope.</remarks>
        protected int ResourceSetScopeResourceCount
        {
            get
            {
                Debug.Assert(this.State == WriterState.ResourceSet, "ResourceSetScopeResourceCount should only be called while writing a resource set.");
                return ((ResourceSetBaseScope)this.CurrentScope).ResourceCount;
            }
        }

        /// <summary>
        /// Checker to detect duplicate property names.
        /// </summary>
        protected IDuplicatePropertyNameChecker DuplicatePropertyNameChecker
        {
            get
            {
                Debug.Assert(
                    this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.NestedResourceInfo || this.State == WriterState.NestedResourceInfoWithContent || this.State == WriterState.Property,
                    "PropertyAndAnnotationCollector should only be called while writing a resource or an (expanded or deferred) nested resource info.");

                ResourceBaseScope resourceScope;
                switch (this.State)
                {
                    case WriterState.DeletedResource:
                    case WriterState.Resource:
                        resourceScope = (ResourceBaseScope)this.CurrentScope;
                        break;
                    case WriterState.Property:
                    case WriterState.NestedResourceInfo:
                    case WriterState.NestedResourceInfoWithContent:
                        resourceScope = (ResourceBaseScope)this.scopeStack.Parent;
                        break;
                    default:
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_PropertyAndAnnotationCollector));
                }

                return resourceScope.DuplicatePropertyNameChecker;
            }
        }

        /// <summary>
        /// The structured type of the current resource.
        /// </summary>
        protected IEdmStructuredType ResourceType
        {
            get
            {
                return this.CurrentScope.ResourceType;
            }
        }

        /// <summary>
        /// Returns the parent nested resource info scope of a resource in an expanded link (if it exists).
        /// The resource can either be the content of the expanded link directly or nested inside a resourceSet.
        /// </summary>
        /// <returns>The parent navigation scope of a resource in an expanded link (if it exists).</returns>
        protected NestedResourceInfoScope ParentNestedResourceInfoScope
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.ResourceSet || this.State == WriterState.DeltaResourceSet, "ParentNestedResourceInfoScope should only be called while writing a resource or a resourceSet.");
                Debug.Assert(this.scopeStack.Count >= 2, "We should have at least the resource scope and the start scope on the stack.");

                Scope parentScope = this.scopeStack.Parent;
                if (parentScope.State == WriterState.Start)
                {
                    // Top-level resource.
                    return null;
                }

                if (parentScope.State == WriterState.ResourceSet || parentScope.State == WriterState.DeltaResourceSet)
                {
                    Debug.Assert(this.scopeStack.Count >= 3, "We should have at least the resource scope, the resourceSet scope and the start scope on the stack.");

                    // Get the resourceSet's parent
                    parentScope = this.scopeStack.ParentOfParent;
                    if (parentScope.State == WriterState.Start ||
                        (parentScope.State == WriterState.ResourceSet &&
                        parentScope.ResourceType != null &&
                        parentScope.ResourceType.TypeKind == EdmTypeKind.Untyped))
                    {
                        // Top-level resourceSet, or resourceSet within an untyped resourceSet.
                        return null;
                    }
                }

                if (parentScope.State == WriterState.NestedResourceInfoWithContent)
                {
                    // Get the scope of the nested resource info
                    return (NestedResourceInfoScope)parentScope;
                }

                // The parent scope of a resource can only be a resourceSet or an expanded nav link
                throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_ParentNestedResourceInfoScope));
            }
        }

        /// <summary>
        /// Validator to validate consistency of collection items (or null if no such validator applies to the current scope).
        /// </summary>
        private ResourceSetWithoutExpectedTypeValidator CurrentResourceSetValidator
        {
            get
            {
                Debug.Assert(this.State == WriterState.Resource || this.State == WriterState.DeletedResource || this.State == WriterState.Primitive, "CurrentCollectionValidator should only be called while writing a resource.");

                ResourceSetBaseScope resourceSetScope = this.ParentScope as ResourceSetBaseScope;
                return resourceSetScope == null ? null : resourceSetScope.ResourceTypeValidator;
            }
        }

        /// <summary>
        /// Flushes the write buffer to the underlying stream.
        /// </summary>
        public sealed override void Flush()
        {
            this.VerifyCanFlush(true);

            // Make sure we switch to writer state FatalExceptionThrown if an exception is thrown during flushing.
            try
            {
                this.FlushSynchronously();
            }
            catch
            {
                this.EnterScope(WriterState.Error, null);
                throw;
            }
        }


        /// <summary>
        /// Asynchronously flushes the write buffer to the underlying stream.
        /// </summary>
        /// <returns>A task instance that represents the asynchronous operation.</returns>
        public sealed override Task FlushAsync()
        {
            this.VerifyCanFlush(false);

            // Make sure we switch to writer state Error if an exception is thrown during flushing.
            return this.FlushAsynchronously().FollowOnFaultWith(t => this.EnterScope(WriterState.Error, null));
        }

        /// <summary>
        /// Start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        public sealed override void WriteStart(ODataResourceSet resourceSet)
        {
            this.VerifyCanWriteStartResourceSet(true, resourceSet);
            this.WriteStartResourceSetImplementation(resourceSet);
        }


        /// <summary>
        /// Asynchronously start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataResourceSet resourceSet)
        {
            this.VerifyCanWriteStartResourceSet(false, resourceSet);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartResourceSetImplementation(resourceSet));
        }

        /// <summary>
        /// Start writing a delta resource Set.
        /// </summary>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        public sealed override void WriteStart(ODataDeltaResourceSet deltaResourceSet)
        {
            this.VerifyCanWriteStartDeltaResourceSet(true, deltaResourceSet);
            this.WriteStartDeltaResourceSetImplementation(deltaResourceSet);
        }


        /// <summary>
        /// Asynchronously start writing a delta resourceSet.
        /// </summary>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataDeltaResourceSet deltaResourceSet)
        {
            this.VerifyCanWriteStartDeltaResourceSet(false, deltaResourceSet);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartDeltaResourceSetImplementation(deltaResourceSet));
        }

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        public sealed override void WriteStart(ODataResource resource)
        {
            this.VerifyCanWriteStartResource(true, resource);
            this.WriteStartResourceImplementation(resource);
        }


        /// <summary>
        /// Asynchronously start writing a resource.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataResource resource)
        {
            this.VerifyCanWriteStartResource(false, resource);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartResourceImplementation(resource));
        }

        /// <summary>
        /// Start writing a delta deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta deleted resource to write.</param>
        public sealed override void WriteStart(ODataDeletedResource deletedResource)
        {
            this.VerifyCanWriteStartDeletedResource(true, deletedResource);
            this.WriteStartDeletedResourceImplementation(deletedResource);
        }


        /// <summary>
        /// Asynchronously write a delta deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta deleted resource to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataDeletedResource deletedResource)
        {
            this.VerifyCanWriteStartDeletedResource(false, deletedResource);
            return TaskUtils.GetTaskForSynchronousOperation(() =>
            {
                this.WriteStartDeletedResourceImplementation(deletedResource);
            });
        }

        /// <summary>
        /// Writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        public override void WriteDeltaLink(ODataDeltaLink deltaLink)
        {
            this.VerifyCanWriteLink(true, deltaLink);
            this.WriteDeltaLinkImplementation(deltaLink);
        }


        /// <summary>
        /// Asynchronously writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public override Task WriteDeltaLinkAsync(ODataDeltaLink deltaLink)
        {
            this.VerifyCanWriteLink(false, deltaLink);
            return this.WriteDeltaLinkAsyncImplementation(deltaLink);
        }

        /// <summary>
        /// Writing a delta deleted link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        public override void WriteDeltaDeletedLink(ODataDeltaDeletedLink deltaLink)
        {
            this.VerifyCanWriteLink(true, deltaLink);
            this.WriteDeltaLinkImplementation(deltaLink);
        }


        /// <summary>
        /// Asynchronously writing a delta link.
        /// </summary>
        /// <param name="deltaLink">The delta link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public override Task WriteDeltaDeletedLinkAsync(ODataDeltaDeletedLink deltaLink)
        {
            this.VerifyCanWriteLink(false, deltaLink);
            return this.WriteDeltaLinkAsyncImplementation(deltaLink);
        }

        /// <summary>
        /// Write a primitive value within an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        public sealed override void WritePrimitive(ODataPrimitiveValue primitiveValue)
        {
            this.VerifyCanWritePrimitive(true, primitiveValue);
            this.WritePrimitiveValueImplementation(primitiveValue);
        }


        /// <summary>
        /// Asynchronously write a primitive value.
        /// </summary>
        /// <param name="primitiveValue"> Primitive value to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WritePrimitiveAsync(ODataPrimitiveValue primitiveValue)
        {
            this.VerifyCanWritePrimitive(false, primitiveValue);
            return this.WritePrimitiveValueAsyncImplementation(primitiveValue);
        }

        /// <summary>Writes a primitive property within a resource.</summary>
        /// <param name="primitiveProperty">The primitive property to write.</param>
        public sealed override void WriteStart(ODataPropertyInfo primitiveProperty)
        {
            this.VerifyCanWriteProperty(true, primitiveProperty);
            this.WriteStartPropertyImplementation(primitiveProperty);
        }

        /// <summary> Asynchronously write a primitive property within a resource. </summary>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        /// <param name="primitiveProperty">The primitive property to write.</param>
        public sealed override Task WriteStartAsync(ODataPropertyInfo primitiveProperty)
        {
            this.VerifyCanWriteProperty(false, primitiveProperty);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartPropertyImplementation(primitiveProperty));
        }

        /// <summary>Creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Stream CreateBinaryWriteStream()
        {
            this.VerifyCanCreateWriteStream(true);
            return this.CreateWriteStreamImplementation();
        }


        /// <summary>Asynchronously creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Task<Stream> CreateBinaryWriteStreamAsync()
        {
            this.VerifyCanCreateWriteStream(false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.CreateWriteStreamImplementation());
        }

        /// <summary>Creates a TextWriter for writing a string value.</summary>
        /// <returns>A TextWriter to write a string value to.</returns>
        public sealed override TextWriter CreateTextWriter()
        {
            this.VerifyCanCreateTextWriter(true);
            return this.CreateTextWriterImplementation();
        }


        /// <summary>Asynchronously creates a stream for writing a binary value.</summary>
        /// <returns>A stream to write a binary value to.</returns>
        public sealed override Task<TextWriter> CreateTextWriterAsync()
        {
            this.VerifyCanCreateWriteStream(false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.CreateTextWriterImplementation());
        }

        /// <summary>
        /// Start writing a nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        public sealed override void WriteStart(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.VerifyCanWriteStartNestedResourceInfo(true, nestedResourceInfo);
            this.WriteStartNestedResourceInfoImplementation(nestedResourceInfo);
        }


        /// <summary>
        /// Asynchronously start writing a nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to writer.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteStartAsync(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.VerifyCanWriteStartNestedResourceInfo(false, nestedResourceInfo);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteStartNestedResourceInfoImplementation(nestedResourceInfo));
        }

        /// <summary>
        /// Finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        public sealed override void WriteEnd()
        {
            this.VerifyCanWriteEnd(true);
            this.WriteEndImplementation();
            if (this.CurrentScope.State == WriterState.Completed)
            {
                // Note that we intentionally go through the public API so that if the Flush fails the writer moves to the Error state.
                this.Flush();
            }
        }


        /// <summary>
        /// Asynchronously finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        public sealed override Task WriteEndAsync()
        {
            this.VerifyCanWriteEnd(false);
            return TaskUtils.GetTaskForSynchronousOperation(this.WriteEndImplementation)
                .FollowOnSuccessWithTask(
                    task =>
                    {
                        if (this.CurrentScope.State == WriterState.Completed)
                        {
                            // Note that we intentionally go through the public API so that if the Flush fails the writer moves to the Error state.
                            return this.FlushAsync();
                        }
                        else
                        {
                            return TaskUtils.CompletedTask;
                        }
                    });
        }

        /// <summary>
        /// Writes an entity reference link, which is used to represent binding to an existing resource in a request payload.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <remarks>
        /// This method can only be called for writing request messages. The entity reference link must be surrounded
        /// by a navigation link written through WriteStart/WriteEnd.
        /// The <see cref="ODataNestedResourceInfo.Url"/> will be ignored in that case and the Uri from the <see cref="ODataEntityReferenceLink.Url"/> will be used
        /// as the binding URL to be written.
        /// </remarks>
        public sealed override void WriteEntityReferenceLink(ODataEntityReferenceLink entityReferenceLink)
        {
            this.VerifyCanWriteEntityReferenceLink(entityReferenceLink, true);
            this.WriteEntityReferenceLinkImplementation(entityReferenceLink);
        }


        /// <summary>
        /// Asynchronously writes an entity reference link, which is used to represent binding to an existing resource in a request payload.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <returns>A task instance that represents the asynchronous write operation.</returns>
        /// <remarks>
        /// This method can only be called for writing request messages. The entity reference link must be surrounded
        /// by a navigation link written through WriteStart/WriteEnd.
        /// The <see cref="ODataNestedResourceInfo.Url"/> will be ignored in that case and the Uri from the <see cref="ODataEntityReferenceLink.Url"/> will be used
        /// as the binding URL to be written.
        /// </remarks>
        public sealed override Task WriteEntityReferenceLinkAsync(ODataEntityReferenceLink entityReferenceLink)
        {
            this.VerifyCanWriteEntityReferenceLink(entityReferenceLink, false);
            return TaskUtils.GetTaskForSynchronousOperation(() => this.WriteEntityReferenceLinkImplementation(entityReferenceLink));
        }

        /// <summary>
        /// This method notifies the listener, that an in-stream error is to be written.
        /// </summary>
        /// <remarks>
        /// This listener can choose to fail, if the currently written payload doesn't support in-stream error at this position.
        /// If the listener returns, the writer should not allow any more writing, since the in-stream error is the last thing in the payload.
        /// </remarks>
        void IODataOutputInStreamErrorListener.OnInStreamError()
        {
            this.VerifyNotDisposed();

            // We're in a completed state trying to write an error (we can't write error after the payload was finished as it might
            // introduce another top-level element in XML)
            if (this.State == WriterState.Completed)
            {
                throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromCompleted(this.State.ToString(), WriterState.Error.ToString()));
            }

            this.StartPayloadInStartState();
            this.EnterScope(WriterState.Error, this.CurrentScope.Item);
        }

        /// <summary>
        /// This method is called when a stream is requested. It is a no-op.
        /// </summary>
        void IODataStreamListener.StreamRequested()
        {
        }


        /// <summary>
        /// This method is called when an async stream is requested. It is a no-op.
        /// </summary>
        /// <returns>A task for method called when a stream is requested.</returns>
        Task IODataStreamListener.StreamRequestedAsync()
        {
            return TaskUtils.GetTaskForSynchronousOperation(() => ((IODataStreamListener)this).StreamRequested());
        }

        /// <summary>
        /// This method is called when a stream is disposed.
        /// </summary>
        void IODataStreamListener.StreamDisposed()
        {
            Debug.Assert(this.State == WriterState.Stream || this.State == WriterState.String, "Stream was disposed when not in WriterState.Stream state.");

            // Complete writing the stream
            if (this.State == WriterState.Stream)
            {
                this.EndBinaryStream();
            }
            else if (this.State == WriterState.String)
            {
                this.EndTextWriter();
            }

            this.LeaveScope();
        }

        /// <summary>
        /// Get instance of the parent resource scope
        /// </summary>
        /// <returns>
        /// The parent resource scope
        /// Or null if there is no parent resource scope
        /// </returns>
        protected ResourceScope GetParentResourceScope()
        {
            ScopeStack scopeStack = new ScopeStack();
            Scope parentResourceScope = null;

            if (this.scopeStack.Count > 0)
            {
                // pop current scope and push into scope stack
                scopeStack.Push(this.scopeStack.Pop());
            }

            while (this.scopeStack.Count > 0)
            {
                Scope scope = this.scopeStack.Pop();
                scopeStack.Push(scope);

                if (scope is ResourceScope)
                {
                    parentResourceScope = scope;
                    break;
                }
            }

            while (scopeStack.Count > 0)
            {
                Scope scope = scopeStack.Pop();
                this.scopeStack.Push(scope);
            }

            return parentResourceScope as ResourceScope;
        }

        /// <summary>
        /// Determines whether a given writer state is considered an error state.
        /// </summary>
        /// <param name="state">The writer state to check.</param>
        /// <returns>True if the writer state is an error state; otherwise false.</returns>
        protected static bool IsErrorState(WriterState state)
        {
            return state == WriterState.Error;
        }

        /// <summary>
        /// Check if the object has been disposed; called from all public API methods. Throws an ObjectDisposedException if the object
        /// has already been disposed.
        /// </summary>
        protected abstract void VerifyNotDisposed();

        /// <summary>
        /// Flush the output.
        /// </summary>
        protected abstract void FlushSynchronously();


        /// <summary>
        /// Flush the output.
        /// </summary>
        /// <returns>Task representing the pending flush operation.</returns>
        protected abstract Task FlushAsynchronously();

        /// <summary>
        /// Start writing an OData payload.
        /// </summary>
        protected abstract void StartPayload();

        /// <summary>
        /// Start writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected abstract void StartResource(ODataResource resource);

        /// <summary>
        /// Finish writing a resource.
        /// </summary>
        /// <param name="resource">The resource to write.</param>
        protected abstract void EndResource(ODataResource resource);

        /// <summary>
        /// Start writing a single property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected virtual void StartProperty(ODataPropertyInfo property)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a property.
        /// </summary>
        /// <param name="property">The property to write.</param>
        protected virtual void EndProperty(ODataPropertyInfo property)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Start writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">The resourceSet to write.</param>
        protected abstract void StartResourceSet(ODataResourceSet resourceSet);

        /// <summary>
        /// Start writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected virtual void StartDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Start writing a deleted resource.
        /// </summary>
        /// <param name="deletedEntry">The deleted entry to write.</param>
        protected virtual void StartDeletedResource(ODataDeletedResource deletedEntry)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a delta link or delta deleted link.
        /// </summary>
        /// <param name="deltaLink">The deleted entry to write.</param>
        protected virtual void StartDeltaLink(ODataDeltaLinkBase deltaLink)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a stream to write a binary value.
        /// </summary>
        /// <returns>A stream for writing the binary value.</returns>
        protected virtual Stream StartBinaryStream()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a stream.
        /// </summary>
        protected virtual void EndBinaryStream()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a TextWriter to write a string value.
        /// </summary>
        /// <returns>A TextWriter for writing the string value.</returns>
        protected virtual TextWriter StartTextWriter()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a string value.
        /// </summary>
        protected virtual void EndTextWriter()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing an OData payload.
        /// </summary>
        protected abstract void EndPayload();

        /// <summary>
        /// Finish writing a resourceSet.
        /// </summary>
        /// <param name="resourceSet">The resourceSet to write.</param>
        protected abstract void EndResourceSet(ODataResourceSet resourceSet);

        /// <summary>
        /// Finish writing a delta resource set.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set to write.</param>
        protected virtual void EndDeltaResourceSet(ODataDeltaResourceSet deltaResourceSet)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Finish writing a deleted resource.
        /// </summary>
        /// <param name="deletedResource">The delta resource set to write.</param>
        protected virtual void EndDeletedResource(ODataDeletedResource deletedResource)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a primitive value within an untyped collection.
        /// </summary>
        /// <param name="primitiveValue">The primitive value to write.</param>
        protected virtual void WritePrimitiveValue(ODataPrimitiveValue primitiveValue)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Write a deferred (non-expanded) nested resource info.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void WriteDeferredNestedResourceInfo(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Start writing a nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void StartNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Finish writing a nested resource info with content.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested resource info to write.</param>
        protected abstract void EndNestedResourceInfoWithContent(ODataNestedResourceInfo nestedResourceInfo);

        /// <summary>
        /// Write an entity reference link into a navigation link content.
        /// </summary>
        /// <param name="parentNestedResourceInfo">The parent navigation link which is being written around the entity reference link.</param>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        protected abstract void WriteEntityReferenceInNavigationLinkContent(ODataNestedResourceInfo parentNestedResourceInfo, ODataEntityReferenceLink entityReferenceLink);

        /// <summary>
        /// Create a new resource set scope.
        /// </summary>
        /// <param name="resourceSet">The resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected abstract ResourceSetScope CreateResourceSetScope(ODataResourceSet resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared);

        /// <summary>
        /// Create a new delta resource set scope.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource set for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource set is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeltaResourceSetScope CreateDeltaResourceSetScope(ODataDeltaResourceSet deltaResourceSet, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected abstract ResourceScope CreateResourceScope(ODataResource resource, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared);

        /// <summary>
        /// Create a new resource scope.
        /// </summary>
        /// <param name="resource">The (deleted) resource for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="resourceType">The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <param name="isUndeclared">true if the resource is for an undeclared property</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeletedResourceScope CreateDeletedResourceScope(ODataDeletedResource resource, IEdmNavigationSource navigationSource, IEdmEntityType resourceType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri, bool isUndeclared)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new property scope.
        /// </summary>
        /// <param name="property">The property for the new scope.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created property scope.</returns>
        protected virtual PropertyInfoScope CreatePropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Create a new delta link scope.
        /// </summary>
        /// <param name="link">The link for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly create scope.</returns>
        protected virtual DeltaLinkScope CreateDeltaLinkScope(ODataDeltaLinkBase link, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets the serialization info for the given resource.
        /// </summary>
        /// <param name="resource">The resource to get the serialization info for.</param>
        /// <returns>The serialization info for the given resource.</returns>
        protected ODataResourceSerializationInfo GetResourceSerializationInfo(ODataResourceBase resource)
        {
            // Need to check for null for the resource since we can be writing a null reference to a navigation property.
            ODataResourceSerializationInfo serializationInfo = resource == null ? null : resource.SerializationInfo;

            // Always try to use the serialization info from the resource first. If it is not found on the resource, use the one inherited from the parent resourceSet.
            // Note that we don't try to guard against inconsistent serialization info between entries and their parent resourceSet.
            if (serializationInfo != null)
            {
                return serializationInfo;
            }

            if (this.CurrentScope.Item is ODataResourceSetBase resourceSet)
            {
                return resourceSet.SerializationInfo;
            }

            return null;
        }

        /// <summary>
        /// Gets the serialization info for the given delta link.
        /// </summary>
        /// <param name="item">The resource to get the serialization info for.</param>
        /// <returns>The serialization info for the given resource.</returns>
        protected ODataResourceSerializationInfo GetLinkSerializationInfo(ODataItem item)
        {
            Debug.Assert(item != null, "item != null");

            ODataDeltaSerializationInfo deltaSerializationInfo = null;
            ODataResourceSerializationInfo resourceSerializationInfo = null;

            if (item is ODataDeltaLink deltaLink)
            {
                deltaSerializationInfo = deltaLink.SerializationInfo;
            }

            if (item is ODataDeltaDeletedLink deltaDeletedLink)
            {
                deltaSerializationInfo = deltaDeletedLink.SerializationInfo;
            }

            if (deltaSerializationInfo == null)
            {
                if (this.CurrentScope is DeltaResourceSetScope parentDeltaResourceSetScope)
                {
                    ODataDeltaResourceSet resourceSet = (ODataDeltaResourceSet)parentDeltaResourceSetScope.Item;
                    Debug.Assert(resourceSet != null, "resourceSet != null");

                    ODataResourceSerializationInfo deltaSetSerializationInfo = resourceSet.SerializationInfo;
                    if (deltaSetSerializationInfo != null)
                    {
                        resourceSerializationInfo = deltaSetSerializationInfo;
                    }
                }
            }
            else
            {
                resourceSerializationInfo = new ODataResourceSerializationInfo()
                {
                    NavigationSourceName = deltaSerializationInfo.NavigationSourceName
                };
            }

            return resourceSerializationInfo;
        }

        /// <summary>
        /// Creates a new nested resource info scope.
        /// </summary>
        /// <param name="writerState">The writer state for the new scope.</param>
        /// <param name="navLink">The nested resource info for the new scope.</param>
        /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
        /// <param name="itemType">The type for the items in the resourceSet to be written (or null if the resource set base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The ODataUri info of this scope.</param>
        /// <returns>The newly created nested resource info scope.</returns>
        protected virtual NestedResourceInfoScope CreateNestedResourceInfoScope(
            WriterState writerState,
            ODataNestedResourceInfo navLink,
            IEdmNavigationSource navigationSource,
            IEdmType itemType,
            bool skipWriting,
            SelectedPropertiesNode selectedProperties,
            ODataUri odataUri)
        {
            return new NestedResourceInfoScope(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="resource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected virtual void PrepareResourceForWriteStart(ResourceScope resourceScope, ODataResource resource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            // No-op Atom and Verbose JSON. The JSON Light writer will override this method and inject the appropriate metadata builder
            // into the resource before writing.
            // Actually we can inject the metadata builder in here and
            // remove virtual from this method.
        }

        /// <summary>
        /// Place where derived writers can perform custom steps before the deleted resource is written, at the beginning of WriteStartEntryImplementation.
        /// </summary>
        /// <param name="resourceScope">The ResourceScope.</param>
        /// <param name="deletedResource">Resource to write.</param>
        /// <param name="writingResponse">True if writing response.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        protected virtual void PrepareDeletedResourceForWriteStart(DeletedResourceScope resourceScope, ODataDeletedResource deletedResource, bool writingResponse, SelectedPropertiesNode selectedProperties)
        {
            // No-op Atom and Verbose JSON. The JSON Light writer will override this method and inject the appropriate metadata builder
            // into the resource before writing.
            // Actually we can inject the metadata builder in here and
            // remove virtual from this method.
        }

        /// <summary>
        /// Gets the type of the resource and validates it against the model.
        /// </summary>
        /// <param name="resource">The resource to get the type for.</param>
        /// <returns>The validated structured type.</returns>
        protected IEdmStructuredType GetResourceType(ODataResourceBase resource)
        {
            return TypeNameOracle.ResolveAndValidateTypeFromTypeName(
                this.outputContext.Model,
                this.CurrentScope.ResourceType,
                resource.TypeName,
                this.WriterValidator);
        }

        /// <summary>
        /// Gets the element type of the resource set and validates it against the model.
        /// </summary>
        /// <param name="resourceSet">The resource set to get the element type for.</param>
        /// <returns>The validated structured element type.</returns>
        protected IEdmStructuredType GetResourceSetType(ODataResourceSetBase resourceSet)
        {
            return TypeNameOracle.ResolveAndValidateTypeFromTypeName(
                this.outputContext.Model,
                this.CurrentScope.ResourceType,
                EdmLibraryExtensions.GetCollectionItemTypeName(resourceSet.TypeName),
                this.WriterValidator);
        }

        /// <summary>
        /// Validates that the ODataResourceSet.DeltaLink is null for the given expanded resourceSet.
        /// </summary>
        /// <param name="resourceSet">The expanded resourceSet in question.</param>
        [SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "An instance field is used in a debug assert.")]
        protected void ValidateNoDeltaLinkForExpandedResourceSet(ODataResourceSet resourceSet)
        {
            Debug.Assert(resourceSet != null, "resourceSet != null");
            Debug.Assert(
                this.ParentNestedResourceInfo != null && (!this.ParentNestedResourceInfo.IsCollection.HasValue || this.ParentNestedResourceInfo.IsCollection.Value == true),
                "This should only be called when writing an expanded resourceSet.");

            if (resourceSet.DeltaLink != null)
            {
                throw new ODataException(Strings.ODataWriterCore_DeltaLinkNotSupportedOnExpandedResourceSet);
            }
        }

        /// <summary>
        /// Verifies that calling WriteStart resourceSet is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resourceSet">Resource Set/collection to write.</param>
        private void VerifyCanWriteStartResourceSet(bool synchronousCall, ODataResourceSet resourceSet)
        {
            ExceptionUtils.CheckArgumentNotNull(resourceSet, "resourceSet");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
            this.StartPayloadInStartState();
        }

        /// <summary>
        /// Start writing a resourceSet - implementation of the actual functionality.
        /// </summary>
        /// <param name="resourceSet">The resource set to write.</param>
        private void WriteStartResourceSetImplementation(ODataResourceSet resourceSet)
        {
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.ResourceSet, resourceSet);
            this.EnterScope(WriterState.ResourceSet, resourceSet);

            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    // Verify query count
                    if (resourceSet.Count.HasValue)
                    {
                        // Check that Count is not set for requests
                        if (!this.outputContext.WritingResponse)
                        {
                            this.ThrowODataException(Strings.ODataWriterCore_QueryCountInRequest, resourceSet);
                        }

                        // Verify version requirements
                    }

                    this.StartResourceSet(resourceSet);
                });
            }
        }

        /// <summary>
        /// Verifies that calling WriteStart deltaResourceSet is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="deltaResourceSet">Resource Set/collection to write.</param>
        private void VerifyCanWriteStartDeltaResourceSet(bool synchronousCall, ODataDeltaResourceSet deltaResourceSet)
        {
            ExceptionUtils.CheckArgumentNotNull(deltaResourceSet, "deltaResourceSet");

            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
            this.StartPayloadInStartState();
        }

        /// <summary>
        /// Start writing a delta resource set - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaResourceSet">The delta resource Set to write.</param>
        private void WriteStartDeltaResourceSetImplementation(ODataDeltaResourceSet deltaResourceSet)
        {
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.ResourceSet, deltaResourceSet);
            this.EnterScope(WriterState.DeltaResourceSet, deltaResourceSet);

            this.InterceptException(() =>
            {
                // Check that links are not set for requests
                if (!this.outputContext.WritingResponse)
                {
                    if (deltaResourceSet.NextPageLink != null)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_QueryNextLinkInRequest, deltaResourceSet);
                    }

                    if (deltaResourceSet.DeltaLink != null)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_QueryDeltaLinkInRequest, deltaResourceSet);
                    }
                }

                this.StartDeltaResourceSet(deltaResourceSet);
            });
        }

        /// <summary>
        /// Verifies that calling WriteStart resource is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resource">Resource/item to write.</param>
        private void VerifyCanWriteStartResource(bool synchronousCall, ODataResource resource)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that calling WriteDeletedResource is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="resource">Resource/item to write.</param>
        private void VerifyCanWriteStartDeletedResource(bool synchronousCall, ODataDeletedResource resource)
        {
            ExceptionUtils.CheckArgumentNotNull(resource, "resource");

            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a resource - implementation of the actual functionality.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        private void WriteStartResourceImplementation(ODataResource resource)
        {
            this.StartPayloadInStartState();
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.Resource, resource);
            this.EnterScope(WriterState.Resource, resource);
            if (!this.SkipWriting)
            {
                this.IncreaseResourceDepth();
                this.InterceptException(() =>
                {
                    if (resource != null)
                    {
                        ResourceScope resourceScope = (ResourceScope)this.CurrentScope;
                        this.ValidateResourceForResourceSet(resource, resourceScope);
                        this.PrepareResourceForWriteStart(
                            resourceScope,
                            resource,
                            this.outputContext.WritingResponse,
                            resourceScope.SelectedProperties);
                    }

                    this.StartResource(resource);
                });
            }
        }

        /// <summary>
        /// Start writing a delta deleted resource - implementation of the actual functionality.
        /// </summary>
        /// <param name="resource">Resource/item to write.</param>
        private void WriteStartDeletedResourceImplementation(ODataDeletedResource resource)
        {
            Debug.Assert(resource != null, "resource != null");

            this.StartPayloadInStartState();
            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.Resource, resource);
            this.EnterScope(WriterState.DeletedResource, resource);
            this.IncreaseResourceDepth();

            this.InterceptException(() =>
            {
                DeletedResourceScope resourceScope = this.CurrentScope as DeletedResourceScope;
                this.ValidateResourceForResourceSet(resource, resourceScope);
                this.PrepareDeletedResourceForWriteStart(
                    resourceScope,
                    resource,
                    this.outputContext.WritingResponse,
                    resourceScope.SelectedProperties);
                this.StartDeletedResource(resource);
            });
        }

        /// <summary>
        /// Verifies that calling WriteStart for a property is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="property">Primitive property to write.</param>
        private void VerifyCanWriteProperty(bool synchronousCall, ODataPropertyInfo property)
        {
            ExceptionUtils.CheckArgumentNotNull(property, "property");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a property - implementation of the actual functionality.
        /// </summary>
        /// <param name="property">Property to write.</param>
        private void WriteStartPropertyImplementation(ODataPropertyInfo property)
        {
            this.EnterScope(WriterState.Property, property);
            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    this.StartProperty(property);
                    if (property is ODataProperty)
                    {
                        Debug.Assert(this.CurrentScope is PropertyInfoScope scope, "Scope for ODataPropertyInfo is not ODataPropertyInfoScope");
                        scope.ValueWritten = true;
                    }
                });
            }
        }

        /// <summary>
        /// Start writing a delta link or delta deleted link - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaLink">Delta (deleted) link to write.</param>
        private void WriteDeltaLinkImplementation(ODataDeltaLinkBase deltaLink)
        {
            this.EnterScope(deltaLink is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink, deltaLink);
            this.StartDeltaLink(deltaLink);
            this.WriteEnd();
        }

        /// <summary>
        /// Start writing a delta link or delta deleted link - implementation of the actual functionality.
        /// </summary>
        /// <param name="deltaLink">Delta (deleted) link to write.</param>
        /// <returns>The task.</returns>
        private async Task WriteDeltaLinkAsyncImplementation(ODataDeltaLinkBase deltaLink)
        {
            await TaskUtils.GetTaskForSynchronousOperation(() =>
            {
                EnterScope(deltaLink is ODataDeltaLink ? WriterState.DeltaLink : WriterState.DeltaDeletedLink, deltaLink);
                StartDeltaLink(deltaLink);
            }).FollowOnSuccessWithTask((t) => WriteEndAsync()).ConfigureAwait(false);
        }
        
        /// <summary>
        /// Verifies that calling WriteStart nested resource info is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        private void VerifyCanWriteStartNestedResourceInfo(bool synchronousCall, ODataNestedResourceInfo nestedResourceInfo)
        {
            ExceptionUtils.CheckArgumentNotNull(nestedResourceInfo, "nestedResourceInfo");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Start writing a nested resource info - implementation of the actual functionality.
        /// </summary>
        /// <param name="nestedResourceInfo">Navigation link to write.</param>
        private void WriteStartNestedResourceInfoImplementation(ODataNestedResourceInfo nestedResourceInfo)
        {
            this.EnterScope(WriterState.NestedResourceInfo, nestedResourceInfo);

            // If the parent resource has a metadata builder, use that metadatabuilder on the nested resource info as well.
            Debug.Assert(this.scopeStack.Parent != null, "Navigation link scopes must have a parent scope.");
            Debug.Assert(this.scopeStack.Parent.Item is ODataResourceBase, "The parent of a nested resource info scope should always be a resource");
            ODataResourceBase parentResource = (ODataResourceBase)this.scopeStack.Parent.Item;
            if (parentResource.MetadataBuilder != null)
            {
                nestedResourceInfo.MetadataBuilder = parentResource.MetadataBuilder;
            }
        }

        /// <summary>
        /// Verifies that calling WritePrimitive is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="primitiveValue">Primitive value to write.</param>
        private void VerifyCanWritePrimitive(bool synchronousCall, ODataPrimitiveValue primitiveValue)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Write primitive value - implementation of the actual functionality.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        private void WritePrimitiveValueImplementation(ODataPrimitiveValue primitiveValue)
        {
            this.InterceptException(() =>
            {
                this.EnterScope(WriterState.Primitive, primitiveValue);
                if (!(this.CurrentResourceSetValidator == null) && primitiveValue != null)
                {
                    Debug.Assert(primitiveValue.Value != null, "PrimitiveValue.Value should never be null!");
                    IEdmType itemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.Value.GetType()).Definition;
                    this.CurrentResourceSetValidator.ValidateResource(itemType);
                }

                this.WritePrimitiveValue(primitiveValue);
                this.WriteEnd();
            });
        }

        /// <summary>
        /// Write primitive value asynchronously - implementation of the actual functionality.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to write.</param>
        /// <returns>The task.</returns>
        private async Task WritePrimitiveValueAsyncImplementation(ODataPrimitiveValue primitiveValue)
        {
            await InterceptExceptionAsync(async () =>
               {
                   await TaskUtils.GetTaskForSynchronousOperation(() =>
                   {
                       EnterScope(WriterState.Primitive, primitiveValue);
                       if (!(CurrentResourceSetValidator == null) && primitiveValue != null)
                       {
                           Debug.Assert(primitiveValue.Value != null, "PrimitiveValue.Value should never be null!");
                           IEdmType itemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.Value.GetType()).Definition;
                           CurrentResourceSetValidator.ValidateResource(itemType);
                       }

                       WritePrimitiveValue(primitiveValue);
                   }).FollowOnSuccessWithTask((t) => WriteEndAsync()).ConfigureAwait(false);
               }).ConfigureAwait(false);
        }
        
        /// <summary>
        /// Verifies that calling CreateWriteStream is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanCreateWriteStream(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Create a write stream - implementation of the actual functionality.
        /// </summary>
        /// <returns>A stream for writing the binary value.</returns>
        private Stream CreateWriteStreamImplementation()
        {
            this.EnterScope(WriterState.Stream, null);
            return new ODataNotificationStream(this.StartBinaryStream(), this);
        }

        /// <summary>
        /// Verifies that calling CreateTextWriter is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanCreateTextWriter(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Create a text writer - implementation of the actual functionality.
        /// </summary>
        /// <returns>A TextWriter for writing the string value.</returns>
        private TextWriter CreateTextWriterImplementation()
        {
            this.EnterScope(WriterState.String, null);
            return new ODataNotificationWriter(this.StartTextWriter(), this);
        }

        /// <summary>
        /// Verify that calling WriteEnd is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanWriteEnd(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Finish writing a resourceSet/resource/nested resource info.
        /// </summary>
        private void WriteEndImplementation()
        {
            this.InterceptException(() =>
            {
                Scope currentScope = this.CurrentScope;

                switch (currentScope.State)
                {
                    case WriterState.Resource:
                        if (!this.SkipWriting)
                        {
                            ODataResource resource = (ODataResource)currentScope.Item;

                            this.EndResource(resource);
                            this.DecreaseResourceDepth();
                        }

                        break;
                    case WriterState.DeletedResource:
                        if (!this.SkipWriting)
                        {
                            ODataDeletedResource resource = (ODataDeletedResource)currentScope.Item;

                            this.EndDeletedResource(resource);
                            this.DecreaseResourceDepth();
                        }

                        break;
                    case WriterState.ResourceSet:
                        if (!this.SkipWriting)
                        {
                            ODataResourceSet resourceSet = (ODataResourceSet)currentScope.Item;
                            WriterValidationUtils.ValidateResourceSetAtEnd(resourceSet, !this.outputContext.WritingResponse);
                            this.EndResourceSet(resourceSet);
                        }

                        break;
                    case WriterState.DeltaLink:
                    case WriterState.DeltaDeletedLink:
                        break;
                    case WriterState.DeltaResourceSet:
                        if (!this.SkipWriting)
                        {
                            ODataDeltaResourceSet deltaResourceSet = (ODataDeltaResourceSet)currentScope.Item;
                            WriterValidationUtils.ValidateDeltaResourceSetAtEnd(deltaResourceSet, !this.outputContext.WritingResponse);
                            this.EndDeltaResourceSet(deltaResourceSet);
                        }

                        break;
                    case WriterState.NestedResourceInfo:
                        if (!this.outputContext.WritingResponse)
                        {
                            throw new ODataException(Strings.ODataWriterCore_DeferredLinkInRequest);
                        }

                        if (!this.SkipWriting)
                        {
                            ODataNestedResourceInfo link = (ODataNestedResourceInfo)currentScope.Item;
                            this.DuplicatePropertyNameChecker.ValidatePropertyUniqueness(link);
                            this.WriteDeferredNestedResourceInfo(link);

                            this.MarkNestedResourceInfoAsProcessed(link);
                        }

                        break;
                    case WriterState.NestedResourceInfoWithContent:
                        if (!this.SkipWriting)
                        {
                            ODataNestedResourceInfo link = (ODataNestedResourceInfo)currentScope.Item;
                            this.EndNestedResourceInfoWithContent(link);

                            this.MarkNestedResourceInfoAsProcessed(link);
                        }

                        break;
                    case WriterState.Property:
                        {
                            ODataPropertyInfo property = (ODataPropertyInfo)currentScope.Item;
                            this.EndProperty(property);
                        }

                        break;
                    case WriterState.Primitive:
                        // WriteEnd for WriterState.Primitive is a no-op; just leave scope
                        break;
                    case WriterState.Stream:
                    case WriterState.String:
                        throw new ODataException(Strings.ODataWriterCore_StreamNotDisposed);
                    case WriterState.Start:                 // fall through
                    case WriterState.Completed:             // fall through
                    case WriterState.Error:                 // fall through
                        throw new ODataException(Strings.ODataWriterCore_WriteEndCalledInInvalidState(currentScope.State.ToString()));
                    default:
                        throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_WriteEnd_UnreachableCodePath));
                }

                this.LeaveScope();
            });
        }

        /// <summary>
        /// Marks the navigation currently being written as processed in the parent entity's metadata builder.
        /// This is needed so that at the end of writing the resource we can query for all the unwritten navigation properties
        /// defined on the entity type and write out their metadata in fullmetadata mode.
        /// </summary>
        /// <param name="link">The nested resource info being written.</param>
        private void MarkNestedResourceInfoAsProcessed(ODataNestedResourceInfo link)
        {
            Debug.Assert(
                this.CurrentScope.State == WriterState.NestedResourceInfo || this.CurrentScope.State == WriterState.NestedResourceInfoWithContent,
                "This method should only be called when we're writing a nested resource info.");

            ODataResourceBase parent = (ODataResourceBase)this.scopeStack.Parent.Item;
            Debug.Assert(parent.MetadataBuilder != null, "parent.MetadataBuilder != null");
            parent.MetadataBuilder.MarkNestedResourceInfoProcessed(link.Name);
        }

        /// <summary>
        /// Verifies that calling WriteEntityReferenceLink is valid.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanWriteEntityReferenceLink(ODataEntityReferenceLink entityReferenceLink, bool synchronousCall)
        {
            ExceptionUtils.CheckArgumentNotNull(entityReferenceLink, "entityReferenceLink");

            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that calling Write(Deleted)DeltaLink is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        /// <param name="deltaLink">Delta link to write.</param>
        private void VerifyCanWriteLink(bool synchronousCall, ODataDeltaLinkBase deltaLink)
        {
            this.VerifyWritingDelta();
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);

            ExceptionUtils.CheckArgumentNotNull(deltaLink, "delta link");
        }

        /// <summary>
        /// Write an entity reference link.
        /// </summary>
        /// <param name="entityReferenceLink">The entity reference link to write.</param>
        private void WriteEntityReferenceLinkImplementation(ODataEntityReferenceLink entityReferenceLink)
        {
            Debug.Assert(entityReferenceLink != null, "entityReferenceLink != null");

            this.CheckForNestedResourceInfoWithContent(ODataPayloadKind.EntityReferenceLink, null);
            Debug.Assert(
                this.CurrentScope.Item is ODataNestedResourceInfo || this.ParentNestedResourceInfoScope.Item is ODataNestedResourceInfo,
                "The CheckForNestedResourceInfoWithContent should have verified that entity reference link can only be written inside a nested resource info.");

            if (!this.SkipWriting)
            {
                this.InterceptException(() =>
                {
                    WriterValidationUtils.ValidateEntityReferenceLink(entityReferenceLink);

                    ODataNestedResourceInfo nestedInfo = this.CurrentScope.Item as ODataNestedResourceInfo;
                    if (nestedInfo == null)
                    {
                        NestedResourceInfoScope nestedResourceInfoScope = this.ParentNestedResourceInfoScope;
                        Debug.Assert(nestedResourceInfoScope != null);
                        nestedInfo = (ODataNestedResourceInfo)nestedResourceInfoScope.Item;
                    }

                    this.WriteEntityReferenceInNavigationLinkContent(nestedInfo, entityReferenceLink);
                });
            }
        }

        /// <summary>
        /// Verifies that calling Flush is valid.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCanFlush(bool synchronousCall)
        {
            this.VerifyNotDisposed();
            this.VerifyCallAllowed(synchronousCall);
        }

        /// <summary>
        /// Verifies that a call is allowed to the writer.
        /// </summary>
        /// <param name="synchronousCall">true if the call is to be synchronous; false otherwise.</param>
        private void VerifyCallAllowed(bool synchronousCall)
        {
            if (synchronousCall)
            {
                if (!this.outputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataWriterCore_SyncCallOnAsyncWriter);
                }
            }
            else
            {
                if (this.outputContext.Synchronous)
                {
                    throw new ODataException(Strings.ODataWriterCore_AsyncCallOnSyncWriter);
                }
            }
        }

        /// <summary>
        /// Verifies that the writer is a delta writer.
        /// </summary>
        private void VerifyWritingDelta()
        {
            if (!this.writingDelta)
            {
                throw new ODataException(Strings.ODataWriterCore_CannotWriteDeltaWithResourceSetWriter);
            }
        }

        /// <summary>
        /// Enters the 'ExceptionThrown' state and then throws an ODataException with the specified error message.
        /// </summary>
        /// <param name="errorMessage">The error message for the exception.</param>
        /// <param name="item">The OData item to associate with the 'ExceptionThrown' state.</param>
        private void ThrowODataException(string errorMessage, ODataItem item)
        {
            this.EnterScope(WriterState.Error, item);
            throw new ODataException(errorMessage);
        }

        /// <summary>
        /// Checks whether we are currently writing the first top-level element; if so call StartPayload
        /// </summary>
        private void StartPayloadInStartState()
        {
            if (this.State == WriterState.Start)
            {
                this.InterceptException(this.StartPayload);
            }
        }

        /// <summary>
        /// Checks whether we are currently writing a nested resource info and switches to NestedResourceInfoWithContent state if we do.
        /// </summary>
        /// <param name="contentPayloadKind">
        /// What kind of payload kind is being written as the content of a nested resource info.
        /// Only Resource Set, Resource or EntityReferenceLink are allowed.
        /// </param>
        /// <param name="contentPayload">The ODataResource or ODataResourceSet to write, or null for ODataEntityReferenceLink.</param>
        private void CheckForNestedResourceInfoWithContent(ODataPayloadKind contentPayloadKind, ODataItem contentPayload)
        {
            Debug.Assert(
                contentPayloadKind == ODataPayloadKind.ResourceSet || contentPayloadKind == ODataPayloadKind.Resource || contentPayloadKind == ODataPayloadKind.EntityReferenceLink,
                "Only ResourceSet, Resource or EntityReferenceLink can be specified as a payload kind for a nested resource info content.");

            Scope currentScope = this.CurrentScope;
            if (currentScope.State == WriterState.NestedResourceInfo || currentScope.State == WriterState.NestedResourceInfoWithContent)
            {
                ODataNestedResourceInfo currentNestedResourceInfo = (ODataNestedResourceInfo)currentScope.Item;
                this.InterceptException(() =>
                {
                    if (this.ParentResourceType != null)
                    {
                        if (this.ParentResourceType.FindProperty(currentNestedResourceInfo.Name) is IEdmStructuralProperty structuralProperty)
                        {
                            this.CurrentScope.ItemType = structuralProperty.Type.Definition.AsElementType();
                            IEdmNavigationSource parentNavigationSource = this.ParentResourceNavigationSource;

                            this.CurrentScope.NavigationSource = parentNavigationSource;
                        }
                        else
                        {
                            IEdmNavigationProperty navigationProperty =
                                 this.WriterValidator.ValidateNestedResourceInfo(currentNestedResourceInfo, this.ParentResourceType, contentPayloadKind);
                            if (navigationProperty != null)
                            {
                                this.CurrentScope.ResourceType = navigationProperty.ToEntityType();
                                IEdmNavigationSource parentNavigationSource = this.ParentResourceNavigationSource;

                                if (this.CurrentScope.NavigationSource == null)
                                {
                                    IEdmPathExpression bindingPath;
                                    this.CurrentScope.NavigationSource = parentNavigationSource == null ?
                                        null :
                                        parentNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, this.CurrentScope.ODataUri.Path.Segments, out bindingPath);
                                }
                            }
                        }
                    }
                });

                if (currentScope.State == WriterState.NestedResourceInfoWithContent)
                {
                    // If we are already in the NestedResourceInfoWithContent state, it means the caller is trying to write two items
                    // into the nested resource info content. This is only allowed for collection navigation property in request/response.
                    if (currentNestedResourceInfo.IsCollection != true)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_MultipleItemsInNestedResourceInfoWithContent, currentNestedResourceInfo);
                    }

                    // Note that we don't invoke duplicate property checker in this case as it's not necessary.
                    // What happens inside the nested resource info was already validated by the condition above.
                    // For collection in request we allow any combination anyway.
                    // For everything else we only allow a single item in the content and thus we will fail above.
                }
                else
                {
                    // we are writing a nested resource info with content; change the state
                    this.PromoteNestedResourceInfoScope(contentPayload);

                    if (!this.SkipWriting)
                    {
                        this.InterceptException(() =>
                        {
                            if (!(currentNestedResourceInfo.SerializationInfo != null && currentNestedResourceInfo.SerializationInfo.IsComplex)
                                && (this.CurrentScope.ItemType == null || this.CurrentScope.ItemType.IsEntityOrEntityCollectionType()))
                            {
                                this.DuplicatePropertyNameChecker.ValidatePropertyUniqueness(currentNestedResourceInfo);
                                this.StartNestedResourceInfoWithContent(currentNestedResourceInfo);
                            }
                        });
                    }
                }
            }
            else
            {
                if (contentPayloadKind == ODataPayloadKind.EntityReferenceLink)
                {
                    Scope parenScope = this.ParentNestedResourceInfoScope;
                    Debug.Assert(parenScope != null);
                    if (parenScope.State != WriterState.NestedResourceInfo && parenScope.State != WriterState.NestedResourceInfoWithContent)
                    {
                        this.ThrowODataException(Strings.ODataWriterCore_EntityReferenceLinkWithoutNavigationLink, null);
                    }
                }
            }
        }

        /// <summary>
        /// Verifies that the (deleted) resource has the correct type for the (delta) resource set.
        /// </summary>
        /// <param name="resource">The resource to be validated.</param>
        /// <param name="resourceScope">The scope for the resource to be validated.</param>
        private void ValidateResourceForResourceSet(ODataResourceBase resource, ResourceBaseScope resourceScope)
        {
            IEdmStructuredType resourceType = GetResourceType(resource);
            NestedResourceInfoScope parentNestedResourceInfoScope = this.ParentNestedResourceInfoScope;
            if (parentNestedResourceInfoScope != null)
            {
                // Validate the consistency of resource types in the nested resourceSet/resource
                this.WriterValidator.ValidateResourceInNestedResourceInfo(resourceType, parentNestedResourceInfoScope.ResourceType);
                resourceScope.ResourceTypeFromMetadata = parentNestedResourceInfoScope.ResourceType;

                this.WriterValidator.ValidateDerivedTypeConstraint(resourceType, resourceScope.ResourceTypeFromMetadata,
                    parentNestedResourceInfoScope.DerivedTypeConstraints, "property", ((ODataNestedResourceInfo)parentNestedResourceInfoScope.Item).Name);
            }
            else
            {
                resourceScope.ResourceTypeFromMetadata = this.ParentScope.ResourceType;
                if (this.CurrentResourceSetValidator != null)
                {
                    if (this.ParentScope.State == WriterState.DeltaResourceSet
                        && this.currentResourceDepth <= 1
                        && resourceScope.NavigationSource != null)
                    {
                        // if the (deleted) resource is in the top level of a delta resource set, it doesn't
                        // need to match the delta resource set, but must match the navigation source resolved for
                        // the current scope
                        if (!resourceScope.NavigationSource.EntityType().IsAssignableFrom(resourceType))
                        {
                            throw new ODataException(Strings.ResourceSetWithoutExpectedTypeValidator_IncompatibleTypes(resourceType.FullTypeName(), resourceScope.NavigationSource.EntityType()));
                        }

                        resourceScope.ResourceTypeFromMetadata = resourceScope.NavigationSource.EntityType();
                    }
                    else
                    {
                        // Validate the consistency of resource types
                        this.CurrentResourceSetValidator.ValidateResource(resourceType);
                    }
                }

                if (this.ParentScope.NavigationSource != null)
                {
                    this.WriterValidator.ValidateDerivedTypeConstraint(resourceType, resourceScope.ResourceTypeFromMetadata,
                        this.ParentScope.DerivedTypeConstraints, "navigation source", this.ParentScope.NavigationSource.Name);
                }
            }

            resourceScope.ResourceType = resourceType;

            // If writing in a delta resource set, the entity must have all key properties or the id set
            if (this.ParentScope.State == WriterState.DeltaResourceSet)
            {
                if (resource.Id == null &&
                    resourceType is IEdmEntityType entityType &&
                    (this.outputContext.WritingResponse || resource is ODataDeletedResource) &&
                    !HasKeyProperties(entityType, resource.Properties))
                {
                    throw new ODataException(Strings.ODataWriterCore_DeltaResourceWithoutIdOrKeyProperties);
                }
            }
        }

        /// <summary>
        /// Determines whether a collection contains all key properties for a particular entity type.
        /// </summary>
        /// <param name="entityType">The entity type.</param>
        /// <param name="properties">The set of properties.</param>
        /// <returns>True if the set of properties include all key properties for the entity type; otherwise false.</returns>
        private static bool HasKeyProperties(IEdmEntityType entityType, IEnumerable<ODataProperty> properties)
        {
            Debug.Assert(entityType != null, "entityType null");
            if (properties == null)
            {
                return false;
            }

            return entityType.Key().All(keyProp => properties.Select(p => p.Name).Contains(keyProp.Name));
        }

        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the writer into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        private void InterceptException(Action action)
        {
            try
            {
                action();
            }
            catch
            {
                if (!IsErrorState(this.State))
                {
                    this.EnterScope(WriterState.Error, this.CurrentScope.Item);
                }

                throw;
            }
        }


        /// <summary>
        /// Catch any exception thrown by the action passed in; in the exception case move the writer into
        /// state ExceptionThrown and then rethrow the exception.
        /// </summary>
        /// <param name="action">The action to execute.</param>
        /// <returns>The task.</returns>
        private async Task InterceptExceptionAsync(Func<Task> action)
        {
            try
            {
                await action().ConfigureAwait(false);
            }
            catch
            {
                if (!IsErrorState(this.State))
                {
                    this.EnterScope(WriterState.Error, this.CurrentScope.Item);
                }

                throw;
            }
        }
        
        /// <summary>
        /// Increments the nested resource count by one and fails if the new value exceeds the maximum nested resource depth limit.
        /// </summary>
        private void IncreaseResourceDepth()
        {
            this.currentResourceDepth++;

            if (this.currentResourceDepth > this.outputContext.MessageWriterSettings.MessageQuotas.MaxNestingDepth)
            {
                this.ThrowODataException(Strings.ValidationUtils_MaxDepthOfNestedEntriesExceeded(this.outputContext.MessageWriterSettings.MessageQuotas.MaxNestingDepth), null);
            }
        }

        /// <summary>
        /// Decrements the nested resource count by one.
        /// </summary>
        private void DecreaseResourceDepth()
        {
            Debug.Assert(this.currentResourceDepth > 0, "Resource depth should never become negative.");

            this.currentResourceDepth--;
        }


        /// <summary>
        /// Notifies the implementer of the <see cref="IODataReaderWriterListener"/> interface of relevant state changes in the writer.
        /// </summary>
        /// <param name="newState">The new writer state.</param>
        private void NotifyListener(WriterState newState)
        {
            if (this.listener != null)
            {
                if (IsErrorState(newState))
                {
                    this.listener.OnException();
                }
                else if (newState == WriterState.Completed)
                {
                    this.listener.OnCompleted();
                }
            }
        }

        /// <summary>
        /// Enter a new writer scope; verifies that the transition from the current state into new state is valid
        /// and attaches the item to the new scope.
        /// </summary>
        /// <param name="newState">The writer state to transition into.</param>
        /// <param name="item">The item to associate with the new scope.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug only cast.")]
        private void EnterScope(WriterState newState, ODataItem item)
        {
            this.InterceptException(() => this.ValidateTransition(newState));

            // If the parent scope was marked for skipping content, the new child scope should be as well.
            bool skipWriting = this.SkipWriting;

            Scope currentScope = this.CurrentScope;

            IEdmNavigationSource navigationSource = null;
            IEdmType itemType = null;
            SelectedPropertiesNode selectedProperties = currentScope.SelectedProperties;
            ODataUri odataUri = currentScope.ODataUri.Clone();
            if (odataUri.Path == null)
            {
                odataUri.Path = new ODataPath();
            }

            IEnumerable<string> derivedTypeConstraints = null;

            WriterState currentState = currentScope.State;

            if (newState == WriterState.Resource || newState == WriterState.ResourceSet || newState == WriterState.Primitive || newState == WriterState.DeltaResourceSet || newState == WriterState.DeletedResource)
            {
                // if we're in a DeltaResourceSet and writing a resource or deleted resource then the parent may not be the navigation source
                if (item is ODataResourceBase resource)
                {
                    IEdmModel model = this.outputContext.Model;
                    if (model != null && model.IsUserModel())
                    {
                        try
                        {
                            string typeNameFromResource = resource.TypeName;
                            if (!String.IsNullOrEmpty(typeNameFromResource))
                            {
                                // try resolving type from resource TypeName
                                itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                    model,
                                    typeNameFromResource,
                                    EdmTypeKind.None,
                                    /* expectStructuredType */ true,
                                    this.outputContext.WriterValidator);
                            }

                            // Try resolving navigation source from serialization info.
                            ODataResourceSerializationInfo serializationInfo = resource.SerializationInfo;
                            if (serializationInfo != null)
                            {
                                if (serializationInfo.NavigationSourceName != null)
                                {
                                    ODataUriParser uriParser = new ODataUriParser(model, new Uri(serializationInfo.NavigationSourceName, UriKind.Relative), this.outputContext.Container);
                                    odataUri = uriParser.ParseUri();
                                    navigationSource = odataUri.Path.NavigationSource();
                                    itemType = itemType ?? navigationSource.EntityType();
                                }

                                if (typeNameFromResource == null)
                                {
                                    // Try resolving entity type from SerializationInfo
                                    if (!string.IsNullOrEmpty(serializationInfo.ExpectedTypeName))
                                    {
                                        itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                            model,
                                            serializationInfo.ExpectedTypeName,
                                            EdmTypeKind.None,
                                            /* expectStructuredType */ true,
                                            this.outputContext.WriterValidator);
                                    }
                                    else if (!string.IsNullOrEmpty(serializationInfo.NavigationSourceEntityTypeName))
                                    {
                                        itemType = TypeNameOracle.ResolveAndValidateTypeName(
                                            model,
                                            serializationInfo.NavigationSourceEntityTypeName,
                                            EdmTypeKind.Entity,
                                            /* expectStructuredType */ true,
                                            this.outputContext.WriterValidator);
                                    }
                                }
                            }
                        }
                        catch (ODataException)
                        {
                            // SerializationInfo doesn't match model.
                            // This should be an error but, for legacy reasons, we ignore this.
                        }
                    }
                }

                if (navigationSource == null)
                {
                    derivedTypeConstraints = currentScope.DerivedTypeConstraints;
                }
                else
                {
                    derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationSource);
                }

                navigationSource = navigationSource ?? currentScope.NavigationSource;
                itemType = itemType ?? currentScope.ItemType;

                // This is to resolve the item type for a resource set for an undeclared nested resource info.
                if (itemType == null
                    && (currentState == WriterState.Start || currentState == WriterState.NestedResourceInfo || currentState == WriterState.NestedResourceInfoWithContent)
                    && (newState == WriterState.ResourceSet || newState == WriterState.DeltaResourceSet))
                {
                    var resourceSet = item as ODataResourceSetBase;
                    if (resourceSet?.TypeName != null && this.outputContext.Model.IsUserModel())
                    {
                        if (TypeNameOracle.ResolveAndValidateTypeName(
                            this.outputContext.Model,
                            resourceSet.TypeName,
                            EdmTypeKind.Collection,
                            false,
                            this.outputContext.WriterValidator) is IEdmCollectionType collectionType)
                        {
                            itemType = collectionType.ElementType.Definition;
                        }
                    }
                }
            }

            // When writing a nested resource info, check if the link is being projected.
            // If we are projecting properties, but the nav. link is not projected mark it to skip its content.
            if ((currentState == WriterState.Resource || currentState == WriterState.DeletedResource) && newState == WriterState.NestedResourceInfo)
            {
                Debug.Assert(currentScope.Item is ODataResourceBase, "If the current state is Resource the current Item must be resource as well (and not null either).");
                Debug.Assert(item is ODataNestedResourceInfo, "If the new state is NestedResourceInfo the new item must be a nested resource info as well (and not null either).");
                ODataNestedResourceInfo nestedResourceInfo = (ODataNestedResourceInfo)item;

                if (!skipWriting)
                {
                    selectedProperties = currentScope.SelectedProperties.GetSelectedPropertiesForNavigationProperty(currentScope.ResourceType, nestedResourceInfo.Name);

                    if (this.outputContext.WritingResponse || this.writingDelta)
                    {
                        ODataPath odataPath = odataUri.Path;
                        IEdmStructuredType currentResourceType = currentScope.ResourceType;

                        var resourceScope = currentScope as ResourceBaseScope;
                        TypeSegment resourceTypeCast = null;
                        if (resourceScope.ResourceTypeFromMetadata != currentResourceType)
                        {
                            resourceTypeCast = new TypeSegment(currentResourceType, null);
                        }

                        // Handle primitive or complex type property.
                        if (this.WriterValidator.ValidatePropertyDefined(
                            nestedResourceInfo.Name, currentResourceType) is IEdmStructuralProperty structuredProperty)
                        {
                            odataPath = AppendEntitySetKeySegment(odataPath, false);
                            itemType = structuredProperty.Type == null ? null : structuredProperty.Type.Definition.AsElementType();
                            navigationSource = null;

                            if (resourceTypeCast != null)
                            {
                                odataPath = odataPath.AddSegment(resourceTypeCast);
                            }

                            odataPath = odataPath.AddPropertySegment(structuredProperty);

                            derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(structuredProperty);
                        }
                        else
                        {
                            IEdmNavigationProperty navigationProperty = this.WriterValidator.ValidateNestedResourceInfo(nestedResourceInfo, currentResourceType, /*payloadKind*/null);
                            if (navigationProperty != null)
                            {
                                derivedTypeConstraints = this.outputContext.Model.GetDerivedTypeConstraints(navigationProperty);

                                itemType = navigationProperty.ToEntityType();
                                if (!nestedResourceInfo.IsCollection.HasValue)
                                {
                                    nestedResourceInfo.IsCollection = navigationProperty.Type.IsEntityCollectionType();
                                }

                                if (!nestedResourceInfo.IsCollection.HasValue)
                                {
                                    nestedResourceInfo.IsCollection = navigationProperty.Type.IsEntityCollectionType();
                                }

                                IEdmNavigationSource currentNavigationSource = currentScope.NavigationSource;
                                IEdmPathExpression bindingPath;

                                if (resourceTypeCast != null)
                                {
                                    odataPath = odataPath.AddSegment(resourceTypeCast);
                                }

                                navigationSource = currentNavigationSource == null
                                    ? null
                                    : currentNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, odataPath.Segments, out bindingPath);

                                SelectExpandClause clause = odataUri.SelectAndExpand;
                                TypeSegment typeCastFromExpand = null;
                                if (clause != null)
                                {
                                    SelectExpandClause subClause;
                                    clause.GetSubSelectExpandClause(nestedResourceInfo.Name, out subClause, out typeCastFromExpand);
                                    odataUri.SelectAndExpand = subClause;
                                }

                                switch (navigationSource.NavigationSourceKind())
                                {
                                    case EdmNavigationSourceKind.ContainedEntitySet:
                                        // Containment cannot be written alone without odata uri.
                                        if (!odataPath.Any())
                                        {
                                            throw new ODataException(Strings.ODataWriterCore_PathInODataUriMustBeSetWhenWritingContainedElement);
                                        }

                                        odataPath = AppendEntitySetKeySegment(odataPath, true);

                                        if (odataPath != null && typeCastFromExpand != null)
                                        {
                                            odataPath = odataPath.AddSegment(typeCastFromExpand);
                                        }

                                        Debug.Assert(navigationSource is IEdmContainedEntitySet, "If the NavigationSourceKind is ContainedEntitySet, the navigationSource must be IEdmContainedEntitySet.");
                                        IEdmContainedEntitySet containedEntitySet = (IEdmContainedEntitySet)navigationSource;
                                        odataPath = odataPath.AddNavigationPropertySegment(containedEntitySet.NavigationProperty, containedEntitySet);
                                        break;
                                    case EdmNavigationSourceKind.EntitySet:
                                        odataPath = new ODataPath(new EntitySetSegment(navigationSource as IEdmEntitySet));
                                        break;
                                    case EdmNavigationSourceKind.Singleton:
                                        odataPath = new ODataPath(new SingletonSegment(navigationSource as IEdmSingleton));
                                        break;
                                    default:
                                        odataPath = null;
                                        break;
                                }
                            }
                        }

                        odataUri.Path = odataPath;
                    }
                }
            }
            else if ((currentState == WriterState.ResourceSet || currentState == WriterState.DeltaResourceSet) && (newState == WriterState.Resource || newState == WriterState.Primitive || newState == WriterState.ResourceSet || newState == WriterState.DeletedResource))
            {
                // When writing a new resource to a resourceSet, increment the count of entries on that resourceSet.
                if (currentState == WriterState.ResourceSet || currentState == WriterState.DeltaResourceSet)
                {
                    ((ResourceSetBaseScope)currentScope).ResourceCount++;
                }
            }

            if (navigationSource == null)
            {
                navigationSource = this.CurrentScope.NavigationSource ?? odataUri.Path.TargetNavigationSource();
            }

            this.PushScope(newState, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri, derivedTypeConstraints);

            this.NotifyListener(newState);
        }

        /// <summary>
        /// Attempt to append key segment to ODataPath.
        /// </summary>
        /// <param name="odataPath">The ODataPath to be evaluated.</param>
        /// <param name="throwIfFail">Whether throw if fails to append key segment.</param>
        /// <returns>The new odata path.</returns>
        private ODataPath AppendEntitySetKeySegment(ODataPath odataPath, bool throwIfFail)
        {
            ODataPath path = odataPath;

            try
            {
                if (EdmExtensionMethods.HasKey(this.CurrentScope.NavigationSource, this.CurrentScope.ResourceType))
                {
                    IEdmEntityType currentEntityType = this.CurrentScope.ResourceType as IEdmEntityType;
                    Debug.Assert(this.CurrentScope.Item is ODataResourceBase resource,
                        "If the current state is Resource the current item must be an ODataResource as well (and not null either).");
                    KeyValuePair<string, object>[] keys = ODataResourceMetadataContext.GetKeyProperties(resource,
                        this.GetResourceSerializationInfo(resource), currentEntityType);
                    path = path.AddKeySegment(keys, currentEntityType, this.CurrentScope.NavigationSource);
                }
            }
            catch (ODataException)
            {
                if (throwIfFail)
                {
                    throw;
                }
            }

            return path;
        }

        /// <summary>
        /// Leave the current writer scope and return to the previous scope.
        /// When reaching the top-level replace the 'Started' scope with a 'Completed' scope.
        /// </summary>
        /// <remarks>Note that this method is never called once an error has been written or a fatal exception has been thrown.</remarks>
        private void LeaveScope()
        {
            Debug.Assert(this.State != WriterState.Error, "this.State != WriterState.Error");

            this.scopeStack.Pop();

            // if we are back at the root replace the 'Start' state with the 'Completed' state
            if (this.scopeStack.Count == 1)
            {
                Scope startScope = this.scopeStack.Pop();
                Debug.Assert(startScope.State == WriterState.Start, "startScope.State == WriterState.Start");
                this.PushScope(WriterState.Completed, /*item*/null, startScope.NavigationSource, startScope.ResourceType, /*skipWriting*/false, startScope.SelectedProperties, startScope.ODataUri, null);
                this.InterceptException(this.EndPayload);
                this.NotifyListener(WriterState.Completed);
            }
        }

        /// <summary>
        /// Promotes the current nested resource info scope to a nested resource info scope with content.
        /// </summary>
        /// <param name="content">The nested content to write. May be of either ODataResource or ODataResourceSet type.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Second cast only in debug.")]
        private void PromoteNestedResourceInfoScope(ODataItem content)
        {
            Debug.Assert(
                this.State == WriterState.NestedResourceInfo,
                "Only a NestedResourceInfo state can be promoted right now. If this changes please review the scope replacement code below.");
            Debug.Assert(
                this.CurrentScope.Item != null && this.CurrentScope.Item is ODataNestedResourceInfo,
                "Item must be a non-null nested resource info.");
            Debug.Assert(content == null || content is ODataResourceBase || content is ODataResourceSetBase);

            this.ValidateTransition(WriterState.NestedResourceInfoWithContent);
            NestedResourceInfoScope previousScope = (NestedResourceInfoScope)this.scopeStack.Pop();
            NestedResourceInfoScope newScope = previousScope.Clone(WriterState.NestedResourceInfoWithContent);

            this.scopeStack.Push(newScope);
            if (newScope.ItemType == null && content != null && !SkipWriting && !(content is ODataPrimitiveValue))
            {
                if (content is ODataPrimitiveValue primitiveValue)
                {
                    newScope.ItemType = EdmLibraryExtensions.GetPrimitiveTypeReference(primitiveValue.GetType()).Definition;
                }
                else
                {
                    newScope.ResourceType = content is ODataResourceBase resource
                                            ? GetResourceType(resource)
                                            : GetResourceSetType(content as ODataResourceSetBase);
                }
            }
        }

        /// <summary>
        /// Verify that the transition from the current state into new state is valid .
        /// </summary>
        /// <param name="newState">The new writer state to transition into.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "All the transition checks are encapsulated in this method.")]
        private void ValidateTransition(WriterState newState)
        {
            if (!IsErrorState(this.State) && IsErrorState(newState))
            {
                // we can always transition into an error state if we are not already in an error state
                return;
            }

            switch (this.State)
            {
                case WriterState.Start:
                    if (newState != WriterState.ResourceSet && newState != WriterState.Resource && newState != WriterState.DeltaResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromStart(this.State.ToString(), newState.ToString()));
                    }

                    if ((newState == WriterState.ResourceSet || newState == WriterState.DeltaResourceSet) && !this.writingResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_CannotWriteTopLevelResourceSetWithResourceWriter);
                    }

                    if (newState == WriterState.Resource && this.writingResourceSet)
                    {
                        throw new ODataException(Strings.ODataWriterCore_CannotWriteTopLevelResourceWithResourceSetWriter);
                    }

                    break;
                case WriterState.DeletedResource:
                case WriterState.Resource:
                    {
                        if (this.CurrentScope.Item == null)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromNullResource(this.State.ToString(), newState.ToString()));
                        }

                        if (newState != WriterState.NestedResourceInfo && newState != WriterState.Property)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResource(this.State.ToString(), newState.ToString()));
                        }

                        if (newState == WriterState.DeletedResource && this.ParentScope.State != WriterState.DeltaResourceSet)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                        }

                        if (this.State == WriterState.DeletedResource && this.Version < ODataVersion.V401 && newState == WriterState.NestedResourceInfo)
                        {
                            throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFrom40DeletedResource(this.State.ToString(), newState.ToString()));
                        }
                    }

                    break;
                case WriterState.ResourceSet:
                    // Within a typed resource set we can only write a resource.
                    // Within an untyped resource set we can also write a primitive value or nested resource set.
                    if (newState != WriterState.Resource &&
                        (this.CurrentScope.ResourceType != null &&
                            (this.CurrentScope.ResourceType.TypeKind != EdmTypeKind.Untyped ||
                                (newState != WriterState.Primitive && newState != WriterState.Stream && newState != WriterState.String && newState != WriterState.ResourceSet))))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.DeltaResourceSet:
                    if (newState != WriterState.Resource &&
                        newState != WriterState.DeletedResource &&
                        !(this.ScopeLevel < 3 && (newState == WriterState.DeltaDeletedLink || newState == WriterState.DeltaLink)))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromResourceSet(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.NestedResourceInfo:
                    if (newState != WriterState.NestedResourceInfoWithContent)
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidStateTransition(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.NestedResourceInfoWithContent:
                    if (newState != WriterState.ResourceSet && newState != WriterState.Resource && newState != WriterState.Primitive && (this.Version < ODataVersion.V401 || (newState != WriterState.DeltaResourceSet && newState != WriterState.DeletedResource)))
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromExpandedLink(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.Property:
                    PropertyInfoScope propertyScope = this.CurrentScope as PropertyInfoScope;
                    Debug.Assert(propertyScope != null, "Scope in WriterState.Property is not PropertyInfoScope");
                    if (propertyScope.ValueWritten)
                    {
                        // we've already written the value for this property
                        Debug.Assert(propertyScope.Item is ODataPropertyInfo propertyInfo, "Item in PropertyInfoScope is not ODataPropertyInfo");
                        throw new ODataException(Strings.ODataWriterCore_PropertyValueAlreadyWritten(propertyInfo.Name));
                    }

                    if (newState == WriterState.Stream || newState == WriterState.String || newState == WriterState.Primitive)
                    {
                        propertyScope.ValueWritten = true;
                    }
                    else
                    {
                        throw new ODataException(Strings.ODataWriterCore_InvalidStateTransition(this.State.ToString(), newState.ToString()));
                    }

                    break;
                case WriterState.Stream:
                case WriterState.String:
                    throw new ODataException(Strings.ODataWriterCore_StreamNotDisposed);
                case WriterState.Completed:
                    // we should never see a state transition when in state 'Completed'
                    throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromCompleted(this.State.ToString(), newState.ToString()));
                case WriterState.Error:
                    if (newState != WriterState.Error)
                    {
                        // No more state transitions once we are in error state except for the fatal error
                        throw new ODataException(Strings.ODataWriterCore_InvalidTransitionFromError(this.State.ToString(), newState.ToString()));
                    }

                    break;
                default:
                    throw new ODataException(Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_ValidateTransition_UnreachableCodePath));
            }
        }

        /// <summary>
        /// Create a new writer scope.
        /// </summary>
        /// <param name="state">The writer state of the scope to create.</param>
        /// <param name="item">The item attached to the scope to create.</param>
        /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
        /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the navigationSource base type should be used).</param>
        /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
        /// <param name="selectedProperties">The selected properties of this scope.</param>
        /// <param name="odataUri">The OdataUri info of this scope.</param>
        /// <param name="derivedTypeConstraints">The derived type constraints.</param>
        [SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Debug.Assert check only.")]
        private void PushScope(WriterState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri,
            IEnumerable<string> derivedTypeConstraints)
        {
            IEdmStructuredType resourceType = itemType as IEdmStructuredType;

            Debug.Assert(
                state == WriterState.Error ||
                state == WriterState.Resource && (item == null || item is ODataResource) ||
                state == WriterState.DeletedResource && (item == null || item is ODataDeletedResource) ||
                state == WriterState.DeltaLink && (item == null || item is ODataDeltaLink) ||
                state == WriterState.DeltaDeletedLink && (item == null || item is ODataDeltaDeletedLink) ||
                state == WriterState.ResourceSet && item is ODataResourceSet ||
                state == WriterState.DeltaResourceSet && item is ODataDeltaResourceSet ||
                state == WriterState.Primitive && (item == null || item is ODataPrimitiveValue) ||
                state == WriterState.Property && (item is ODataPropertyInfo) ||
                state == WriterState.NestedResourceInfo && item is ODataNestedResourceInfo ||
                state == WriterState.NestedResourceInfoWithContent && item is ODataNestedResourceInfo ||
                state == WriterState.Stream && item == null ||
                state == WriterState.String && item == null ||
                state == WriterState.Start && item == null ||
                state == WriterState.Completed && item == null,
                "Writer state and associated item do not match.");

            bool isUndeclaredResourceOrResourceSet = false;
            if ((state == WriterState.Resource || state == WriterState.ResourceSet)
                && (this.CurrentScope.State == WriterState.NestedResourceInfo || this.CurrentScope.State == WriterState.NestedResourceInfoWithContent))
            {
                isUndeclaredResourceOrResourceSet = this.IsUndeclared(this.CurrentScope.Item as ODataNestedResourceInfo);
            }

            Scope scope;
            switch (state)
            {
                case WriterState.Resource:
                    scope = this.CreateResourceScope((ODataResource)item, navigationSource, resourceType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    break;
                case WriterState.DeletedResource:
                    scope = this.CreateDeletedResourceScope((ODataDeletedResource)item, navigationSource, (IEdmEntityType)itemType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    break;
                case WriterState.DeltaLink:
                case WriterState.DeltaDeletedLink:
                    scope = this.CreateDeltaLinkScope((ODataDeltaLinkBase)item, navigationSource, (IEdmEntityType)itemType, selectedProperties, odataUri);
                    break;
                case WriterState.ResourceSet:
                    scope = this.CreateResourceSetScope((ODataResourceSet)item, navigationSource, itemType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    if (this.outputContext.Model.IsUserModel())
                    {
                        Debug.Assert(scope is ResourceSetBaseScope, "Create a scope for a resource set that is not a ResourceSetBaseScope");
                        ((ResourceSetBaseScope)scope).ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(itemType);
                    }

                    break;
                case WriterState.DeltaResourceSet:
                    scope = this.CreateDeltaResourceSetScope((ODataDeltaResourceSet)item, navigationSource, resourceType, skipWriting, selectedProperties, odataUri, isUndeclaredResourceOrResourceSet);
                    if (this.outputContext.Model.IsUserModel())
                    {
                        Debug.Assert(scope is ResourceSetBaseScope, "Create a scope for a delta resource set that is not a ResourceSetBaseScope");
                        ((ResourceSetBaseScope)scope).ResourceTypeValidator = new ResourceSetWithoutExpectedTypeValidator(resourceType);
                    }

                    break;
                case WriterState.Property:
                    scope = this.CreatePropertyInfoScope((ODataPropertyInfo)item, navigationSource, resourceType, selectedProperties, odataUri);
                    break;
                case WriterState.NestedResourceInfo:            // fall through
                case WriterState.NestedResourceInfoWithContent:
                    scope = this.CreateNestedResourceInfoScope(state, (ODataNestedResourceInfo)item, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
                    break;
                case WriterState.Primitive:                 // fall through
                case WriterState.Stream:                    // fall through
                case WriterState.String:                    // fall through
                case WriterState.Start:                     // fall through
                case WriterState.Completed:                 // fall through
                case WriterState.Error:
                    scope = new Scope(state, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri);
                    break;
                default:
                    string errorMessage = Strings.General_InternalError(InternalErrorCodes.ODataWriterCore_Scope_Create_UnreachableCodePath);
                    Debug.Assert(false, errorMessage);
                    throw new ODataException(errorMessage);
            }

            scope.DerivedTypeConstraints = derivedTypeConstraints;
            this.scopeStack.Push(scope);
        }

        /// <summary>
        /// Test to see if <paramref name="nestedResourceInfo"/> for a complex property or a collection of complex property, or a navigation property is declared or not.
        /// </summary>
        /// <param name="nestedResourceInfo">The nested info in question</param>
        /// <returns>true if the nested info is undeclared; false if it is not, or if it cannot be determined</returns>
        private bool IsUndeclared(ODataNestedResourceInfo nestedResourceInfo)
        {
            Debug.Assert(nestedResourceInfo != null, "nestedResourceInfo != null");

            if (nestedResourceInfo.SerializationInfo != null)
            {
                return nestedResourceInfo.SerializationInfo.IsUndeclared;
            }
            else
            {
                return this.ParentResourceType != null && (this.ParentResourceType.FindProperty((this.CurrentScope.Item as ODataNestedResourceInfo).Name) == null);
            }
        }

        /// <summary>
        /// Lightweight wrapper for the stack of scopes which exposes a few helper properties for getting parent scopes.
        /// </summary>
        internal sealed class ScopeStack
        {
            /// <summary>
            /// Use a list to store the scopes instead of a true stack so that parent/grandparent lookups will be fast.
            /// </summary>
            private readonly Stack<Scope> scopes = new Stack<Scope>();

            /// <summary>
            /// Initializes a new instance of the <see cref="ScopeStack"/> class.
            /// </summary>
            internal ScopeStack()
            {
            }

            /// <summary>
            /// Gets the count of items in the stack.
            /// </summary>
            internal int Count
            {
                get
                {
                    return this.scopes.Count;
                }
            }

            /// <summary>
            /// Gets the scope below the current scope on top of the stack.
            /// </summary>
            internal Scope Parent
            {
                get
                {
                    Debug.Assert(this.scopes.Count > 1, "this.scopes.Count > 1");
                    Scope current = this.scopes.Pop();
                    Scope parent = this.scopes.Peek();
                    this.scopes.Push(current);
                    return parent;
                }
            }

            /// <summary>
            /// Gets the scope below the parent of the current scope on top of the stack.
            /// </summary>
            internal Scope ParentOfParent
            {
                get
                {
                    Debug.Assert(this.scopes.Count > 2, "this.scopes.Count > 2");
                    Scope current = this.scopes.Pop();
                    Scope parent = this.scopes.Pop();
                    Scope parentOfParent = this.scopes.Peek();
                    this.scopes.Push(parent);
                    this.scopes.Push(current);
                    return parentOfParent;
                }
            }

            /// <summary>
            /// Gets the scope below the current scope on top of the stack or null if there is only one item on the stack or the stack is empty.
            /// </summary>
            internal Scope ParentOrNull
            {
                get
                {
                    return this.Count == 0 ? null : this.Parent;
                }
            }

            internal Stack<Scope> Scopes
            {
                get { return this.scopes; }
            }

            /// <summary>
            /// Pushes the specified scope onto the stack.
            /// </summary>
            /// <param name="scope">The scope.</param>
            internal void Push(Scope scope)
            {
                Debug.Assert(scope != null, "scope != null");
                this.scopes.Push(scope);
            }

            /// <summary>
            /// Pops the current scope off the stack.
            /// </summary>
            /// <returns>The popped scope.</returns>
            internal Scope Pop()
            {
                Debug.Assert(this.scopes.Count > 0, "this.scopes.Count > 0");
                return this.scopes.Pop();
            }

            /// <summary>
            /// Peeks at the current scope on the top of the stack.
            /// </summary>
            /// <returns>The current scope at the top of the stack.</returns>
            internal Scope Peek()
            {
                Debug.Assert(this.scopes.Count > 0, "this.scopes.Count > 0");
                return this.scopes.Peek();
            }
        }

        /// <summary>
        /// A writer scope; keeping track of the current writer state and an item associated with this state.
        /// </summary>
        internal class Scope
        {
            /// <summary>The writer state of this scope.</summary>
            private readonly WriterState state;

            /// <summary>The item attached to this scope.</summary>
            private readonly ODataItem item;

            /// <summary>Set to true if the content of the scope should not be written.</summary>
            /// <remarks>This is used when writing navigation links which were not projected on the owning resource.</remarks>
            private readonly bool skipWriting;

            /// <summary>The selected properties for the current scope.</summary>
            private readonly SelectedPropertiesNode selectedProperties;

            /// <summary>The navigation source we are going to write entities for.</summary>
            private IEdmNavigationSource navigationSource;

            /// <summary>The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</summary>
            private IEdmStructuredType resourceType;

            /// <summary>The IEdmType of the item (may not be structured for primitive types).</summary>
            private IEdmType itemType;

            /// <summary>The odata uri info for current scope.</summary>
            private ODataUri odataUri;

            /// <summary>
            /// Constructor creating a new writer scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="item">The item attached to this scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of this scope should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal Scope(WriterState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
            {
                this.state = state;
                this.item = item;
                this.itemType = itemType;
                this.resourceType = itemType as IEdmStructuredType;
                this.navigationSource = navigationSource;
                this.skipWriting = skipWriting;
                this.selectedProperties = selectedProperties;
                this.odataUri = odataUri;
            }

            /// <summary>
            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).
            /// </summary>
            public IEdmStructuredType ResourceType
            {
                get
                {
                    return this.resourceType;
                }

                set
                {
                    this.resourceType = value;
                    this.itemType = value;
                }
            }

            /// <summary>
            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).
            /// </summary>
            public IEdmType ItemType
            {
                get
                {
                    return this.itemType;
                }

                set
                {
                    this.itemType = value;
                    this.resourceType = value as IEdmStructuredType;
                }
            }

            /// <summary>
            /// The writer state of this scope.
            /// </summary>
            internal WriterState State
            {
                get
                {
                    return this.state;
                }
            }

            /// <summary>
            /// The item attached to this scope.
            /// </summary>
            internal ODataItem Item
            {
                get
                {
                    return this.item;
                }
            }

            /// <summary>The navigation source we are going to write entities for.</summary>
            internal IEdmNavigationSource NavigationSource
            {
                get
                {
                    return this.navigationSource;
                }

                set
                {
                    this.navigationSource = value;
                }
            }

            /// <summary>The selected properties for the current scope.</summary>
            internal SelectedPropertiesNode SelectedProperties
            {
                get
                {
                    return this.selectedProperties;
                }
            }

            /// <summary>The odata Uri for the current scope.</summary>
            internal ODataUri ODataUri
            {
                get
                {
                    Debug.Assert(this.odataUri != null, "this.odataUri != null");
                    return this.odataUri;
                }
            }

            /// <summary>
            /// Set to true if the content of this scope should not be written.
            /// </summary>
            internal bool SkipWriting
            {
                get
                {
                    return this.skipWriting;
                }
            }

            /// <summary>Gets or sets the derived type constraints for the current scope.</summary>
            internal IEnumerable<string> DerivedTypeConstraints { get; set; }
        }

        /// <summary>
        /// A base scope for a resourceSet.
        /// </summary>
        internal abstract class ResourceSetBaseScope : Scope
        {
            /// <summary>The serialization info for the current resourceSet.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>
            /// The <see cref="ResourceSetWithoutExpectedTypeValidator"/> to use for entries in this resourceSet.
            /// </summary>
            private ResourceSetWithoutExpectedTypeValidator resourceTypeValidator;

            /// <summary>The number of entries in this resourceSet seen so far.</summary>
            private int resourceCount;

            /// <summary>Maintains the write status for each annotation using its key.</summary>
            private InstanceAnnotationWriteTracker instanceAnnotationWriteTracker;

            /// <summary>The type context to answer basic questions regarding the type info of the resource.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="writerState">The writer state for the scope.</param>
            /// <param name="resourceSet">The resourceSet for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal ResourceSetBaseScope(WriterState writerState, ODataResourceSetBase resourceSet, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, resourceSet, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                this.serializationInfo = resourceSet.SerializationInfo;
            }

            /// <summary>
            /// The number of entries in this resource Set seen so far.
            /// </summary>
            internal int ResourceCount
            {
                get
                {
                    return this.resourceCount;
                }

                set
                {
                    this.resourceCount = value;
                }
            }

            /// <summary>
            /// Tracks the write status of the annotations.
            /// </summary>
            internal InstanceAnnotationWriteTracker InstanceAnnotationWriteTracker
            {
                get
                {
                    if (this.instanceAnnotationWriteTracker == null)
                    {
                        this.instanceAnnotationWriteTracker = new InstanceAnnotationWriteTracker();
                    }

                    return this.instanceAnnotationWriteTracker;
                }
            }

            /// <summary>
            /// Validator for resource type.
            /// </summary>
            internal ResourceSetWithoutExpectedTypeValidator ResourceTypeValidator
            {
                get
                {
                    return this.resourceTypeValidator;
                }

                set
                {
                    this.resourceTypeValidator = value;
                }
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">True if writing a response payload, false otherwise.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            internal ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse)
            {
                if (this.typeContext == null)
                {
                    // For Entity, currently we check the navigation source.
                    // For Complex, we don't have navigation source, So we shouldn't check it.
                    // If ResourceType is not provided, serialization info or navigation source info should be provided.
                    var throwIfMissingTypeInfo = writingResponse && (this.ResourceType == null || this.ResourceType.TypeKind == EdmTypeKind.Entity);

                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        this.ResourceType,
                        throwIfMissingTypeInfo);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A scope for a resource set.
        /// </summary>
        internal abstract class ResourceSetScope : ResourceSetBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="item">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type of the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected ResourceSetScope(ODataResourceSet item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.ResourceSet, item, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta resource set.
        /// </summary>
        internal abstract class DeltaResourceSetScope : ResourceSetBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource set scope.
            /// </summary>
            /// <param name="item">The resource set for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="resourceType">The structured type of the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeltaResourceSetScope(ODataDeltaResourceSet item, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.DeltaResourceSet, item, navigationSource, resourceType, false /*skip writing*/, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// The context uri info created for this scope.
            /// </summary>
            public ODataContextUrlInfo ContextUriInfo { get; set; }
        }

        /// <summary>
        /// A base scope for a resource.
        /// </summary>
        internal class ResourceBaseScope : Scope
        {
            /// <summary>Checker to detect duplicate property names.</summary>
            private readonly IDuplicatePropertyNameChecker duplicatePropertyNameChecker;

            /// <summary>The serialization info for the current resource.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>The resource type which was derived from the model (may be either the same as structured type or its base type.</summary>
            private IEdmStructuredType resourceTypeFromMetadata;

            /// <summary>The type context to answer basic questions regarding the type info of the resource.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>Maintains the write status for each annotation using its key.</summary>
            private InstanceAnnotationWriteTracker instanceAnnotationWriteTracker;

            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal ResourceBaseScope(WriterState state, ODataResourceBase resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, resource, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
                Debug.Assert(writerSettings != null, "writerBehavior != null");

                if (resource != null)
                {
                    duplicatePropertyNameChecker = writerSettings.Validator.CreateDuplicatePropertyNameChecker();
                }

                this.serializationInfo = serializationInfo;
            }

            /// <summary>
            /// The structured type which was derived from the model, i.e. the expected structured type, which may be either the same as structured type or its base type.
            /// For example, if we are writing a resource set of Customers and the current resource is of DerivedCustomer, this.ResourceTypeFromMetadata would be Customer and this.ResourceType would be DerivedCustomer.
            /// </summary>
            public IEdmStructuredType ResourceTypeFromMetadata
            {
                get
                {
                    return this.resourceTypeFromMetadata;
                }

                internal set
                {
                    this.resourceTypeFromMetadata = value;
                }
            }

            /// <summary>
            /// The serialization info for the current resource.
            /// </summary>
            public ODataResourceSerializationInfo SerializationInfo
            {
                get { return this.serializationInfo; }
            }

            /// <summary>
            /// Checker to detect duplicate property names.
            /// </summary>
            internal IDuplicatePropertyNameChecker DuplicatePropertyNameChecker
            {
                get
                {
                    return duplicatePropertyNameChecker;
                }
            }

            /// <summary>
            /// Tracks the write status of the annotations.
            /// </summary>
            internal InstanceAnnotationWriteTracker InstanceAnnotationWriteTracker
            {
                get
                {
                    if (this.instanceAnnotationWriteTracker == null)
                    {
                        this.instanceAnnotationWriteTracker = new InstanceAnnotationWriteTracker();
                    }

                    return this.instanceAnnotationWriteTracker;
                }
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">True if writing a response payload, false otherwise.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            public ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse)
            {
                if (this.typeContext == null)
                {
                    IEdmStructuredType expectedResourceType = this.ResourceTypeFromMetadata ?? this.ResourceType;

                    // For entity, we will check the navigation source info
                    bool throwIfMissingTypeInfo = writingResponse && (expectedResourceType == null || expectedResourceType.TypeKind == EdmTypeKind.Entity);

                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        expectedResourceType,
                        throwIfMissingTypeInfo);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A base scope for a resource.
        /// </summary>
        internal class ResourceScope : ResourceBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="resourceType">The structured type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected ResourceScope(ODataResource resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, bool skipWriting, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.Resource, resource, serializationInfo, navigationSource, resourceType, skipWriting, writerSettings, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// Base class for DeletedResourceScope.
        /// </summary>
        internal class DeletedResourceScope : ResourceBaseScope
        {
            /// <summary>
            /// Constructor to create a new resource scope.
            /// </summary>
            /// <param name="resource">The resource for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="writerSettings">The <see cref="ODataMessageWriterSettings"/> The settings of the writer.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeletedResourceScope(ODataDeletedResource resource, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, ODataMessageWriterSettings writerSettings, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.DeletedResource, resource, serializationInfo, navigationSource, entityType, false /*skipWriting*/, writerSettings, selectedProperties, odataUri)
            {
            }
        }

        /// <summary>
        /// A scope for a delta link.
        /// </summary>
        internal abstract class DeltaLinkScope : Scope
        {
            /// <summary>The serialization info for the current link.</summary>
            private readonly ODataResourceSerializationInfo serializationInfo;

            /// <summary>
            /// Fake entity type to be passed to context.
            /// </summary>
            private readonly EdmEntityType fakeEntityType = new EdmEntityType("MyNS", "Fake");

            /// <summary>The type context to answer basic questions regarding the type info of the link.</summary>
            private ODataResourceTypeContext typeContext;

            /// <summary>
            /// Constructor to create a new delta link scope.
            /// </summary>
            /// <param name="state">The writer state of this scope.</param>
            /// <param name="link">The link for the new scope.</param>
            /// <param name="serializationInfo">The serialization info for the current resource.</param>
            /// <param name="navigationSource">The navigation source we are going to write entities for.</param>
            /// <param name="entityType">The entity type for the entries in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            protected DeltaLinkScope(WriterState state, ODataItem link, ODataResourceSerializationInfo serializationInfo, IEdmNavigationSource navigationSource, IEdmEntityType entityType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(state, link, navigationSource, entityType, /*skipWriting*/false, selectedProperties, odataUri)
            {
                Debug.Assert(link != null, "link != null");
                Debug.Assert(
                    state == WriterState.DeltaLink && link is ODataDeltaLink ||
                    state == WriterState.DeltaDeletedLink && link is ODataDeltaDeletedLink,
                    "link must be either DeltaLink or DeltaDeletedLink.");

                this.serializationInfo = serializationInfo;
            }

            /// <summary>
            /// Gets or creates the type context to answer basic questions regarding the type info of the resource.
            /// </summary>
            /// <param name="writingResponse">Whether writing Json payload. Should always be true.</param>
            /// <returns>The type context to answer basic questions regarding the type info of the resource.</returns>
            public ODataResourceTypeContext GetOrCreateTypeContext(bool writingResponse = true)
            {
                if (this.typeContext == null)
                {
                    this.typeContext = ODataResourceTypeContext.Create(
                        this.serializationInfo,
                        this.NavigationSource,
                        EdmTypeWriterResolver.Instance.GetElementType(this.NavigationSource),
                        this.fakeEntityType,
                        writingResponse);
                }

                return this.typeContext;
            }
        }

        /// <summary>
        /// A scope for writing a single property within a resource.
        /// </summary>
        internal class PropertyInfoScope : Scope
        {
            /// <summary>
            /// Constructor to create a new property scope.
            /// </summary>
            /// <param name="property">The property for the new scope.</param>
            /// <param name="navigationSource">The navigation source.</param>
            /// <param name="resourceType">The structured type for the resource containing the property to be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal PropertyInfoScope(ODataPropertyInfo property, IEdmNavigationSource navigationSource, IEdmStructuredType resourceType, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(WriterState.Property, property, navigationSource, resourceType, /*skipWriting*/ false, selectedProperties, odataUri)
            {
                ValueWritten = false;
            }

            public ODataPropertyInfo Property
            {
                get
                {
                    Debug.Assert(this.Item is ODataProperty, "The item of a property scope is not an item.");
                    return this.Item as ODataProperty;
                }
            }

            internal bool ValueWritten { get; set; }
        }

        /// <summary>
        /// A scope for a nested resource info.
        /// </summary>
        internal class NestedResourceInfoScope : Scope
        {
            /// <summary>
            /// Constructor to create a new nested resource info scope.
            /// </summary>
            /// <param name="writerState">The writer state for the new scope.</param>
            /// <param name="navLink">The nested resource info for the new scope.</param>
            /// <param name="navigationSource">The navigation source we are going to write resource set for.</param>
            /// <param name="itemType">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>
            /// <param name="skipWriting">true if the content of the scope to create should not be written.</param>
            /// <param name="selectedProperties">The selected properties of this scope.</param>
            /// <param name="odataUri">The ODataUri info of this scope.</param>
            internal NestedResourceInfoScope(WriterState writerState, ODataNestedResourceInfo navLink, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)
                : base(writerState, navLink, navigationSource, itemType, skipWriting, selectedProperties, odataUri)
            {
            }

            /// <summary>
            /// Clones this nested resource info scope and sets a new writer state.
            /// </summary>
            /// <param name="newWriterState">The <see cref="WriterState"/> to set.</param>
            /// <returns>The cloned nested resource info scope with the specified writer state.</returns>
            internal virtual NestedResourceInfoScope Clone(WriterState newWriterState)
            {
                return new NestedResourceInfoScope(newWriterState, (ODataNestedResourceInfo)this.Item, this.NavigationSource, this.ItemType, this.SkipWriting, this.SelectedProperties, this.ODataUri)
                {
                    DerivedTypeConstraints = this.DerivedTypeConstraints
                };
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\ODataWriterCore.cs(1486,25): error CS0165: Use of unassigned local variable 'scope',D:\a\1\s\src\Microsoft.OData.Core\ODataWriterCore.cs(2448,105): error CS0165: Use of unassigned local variable 'resource',D:\a\1\s\src\Microsoft.OData.Core\ODataWriterCore.cs(2620,102): error CS0165: Use of unassigned local variable 'propertyInfo'
######################################################################


######################################################################
Nr: 19 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\StreamExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData
{
    using System.Diagnostics;
    using System.IO;

    /// <summary>
    /// Extension methods to Stream
    /// </summary>
    internal static class StreamExtensions
    {
        public static byte[] ReadAllBytes(this Stream instream)
        {
            Debug.Assert(instream != null, "instream != null");

            if (instream is MemoryStream)
            {
                return ((MemoryStream)instream).ToArray();
            }

            using (var memoryStream = new MemoryStream())
            {
                instream.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }
        }
    }
}

---- Transformed Tree ----
namespace Microsoft.OData
{
    using System.Diagnostics;
    using System.IO;

    /// <summary>
    /// Extension methods to Stream
    /// </summary>
    internal static class StreamExtensions
    {
        public static byte[] ReadAllBytes(this Stream instream)
        {
            Debug.Assert(instream != null, "instream != null");

            if (instream is MemoryStream memoryStream)
            {
                return memoryStream.ToArray();
            }

            using (var memoryStream = new MemoryStream())
            {
                instream.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\StreamExtensions.cs(26,24): error CS0136: A local or parameter named 'memoryStream' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 20 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using Microsoft.OData.Metadata;
using Microsoft.OData.Edm;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Class that knows how to bind function call tokens.
    /// </summary>
    internal sealed class FunctionCallBinder : BinderBase
    {
        /// <summary>
        /// The names of functions that we don't bind to BuiltInFunctions
        /// </summary>
        private static readonly string[] UnboundFunctionNames = new string[]
        {
            ExpressionConstants.UnboundFunctionCast,
            ExpressionConstants.UnboundFunctionIsOf,
        };

        /// <summary>
        /// Constructs a FunctionCallBinder with the given method to be used binding the parent token if needed.
        /// </summary>
        /// <param name="bindMethod">Method to use for binding the parent token, if needed.</param>
        /// <param name="state">State of the metadata binding.</param>
        internal FunctionCallBinder(MetadataBinder.QueryTokenVisitor bindMethod, BindingState state)
            : base(bindMethod, state)
        {
        }

        /// <summary>
        /// Promotes types of arguments to match signature if possible.
        /// </summary>
        /// <param name="signature">The signature to match the types to.</param>
        /// <param name="argumentNodes">The types to promote.</param>
        internal static void TypePromoteArguments(FunctionSignatureWithReturnType signature, List<QueryNode> argumentNodes)
        {
            // Convert all argument nodes to the best signature argument type
            Debug.Assert(signature.ArgumentTypes.Length == argumentNodes.Count, "The best signature match doesn't have the same number of arguments.");
            for (int i = 0; i < argumentNodes.Count; i++)
            {
                Debug.Assert(argumentNodes[i] is SingleValueNode, "We should have already verified that all arguments are single values.");
                SingleValueNode argumentNode = (SingleValueNode)argumentNodes[i];
                IEdmTypeReference signatureArgumentType = signature.ArgumentTypes[i];
                Debug.Assert(signatureArgumentType.IsODataPrimitiveTypeKind() || signatureArgumentType.IsODataEnumTypeKind(), "Only primitive or enum types should be able to get here.");
                argumentNodes[i] = MetadataBindingUtils.ConvertToTypeIfNeeded(argumentNode, signatureArgumentType);
            }
        }

        /// <summary>
        /// Checks that all arguments are SingleValueNodes
        /// </summary>
        /// <param name="functionName">The name of the function the arguments are from.</param>
        /// <param name="argumentNodes">The arguments to validate.</param>
        /// <returns>SingleValueNode array</returns>
        internal static SingleValueNode[] ValidateArgumentsAreSingleValue(string functionName, List<QueryNode> argumentNodes)
        {
            ExceptionUtils.CheckArgumentNotNull(functionName, "functionCallToken");
            ExceptionUtils.CheckArgumentNotNull(argumentNodes, "argumentNodes");

            // Right now all functions take a single value for all arguments
            SingleValueNode[] ret = new SingleValueNode[argumentNodes.Count];
            for (int i = 0; i < argumentNodes.Count; i++)
            {
                SingleValueNode argumentNode = argumentNodes[i] as SingleValueNode;
                if (argumentNode == null)
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_FunctionArgumentNotSingleValue(functionName));
                }

                ret[i] = argumentNode;
            }

            return ret;
        }

        /// <summary>
        /// Finds the signature that best matches the arguments
        /// </summary>
        /// <param name="functionCallToken">The name of the function</param>
        /// <param name="argumentNodes">The nodes of the arguments, can be new {null,null}.</param>
        /// <param name="nameSignatures">The name-signature pairs to match against</param>
        /// <returns>Returns the matching signature or throws</returns>
        internal static KeyValuePair<string, FunctionSignatureWithReturnType> MatchSignatureToUriFunction(string functionCallToken, SingleValueNode[] argumentNodes,
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures)
        {
            KeyValuePair<string, FunctionSignatureWithReturnType> nameSignature;

            IEdmTypeReference[] argumentTypes = argumentNodes.Select(s => s.TypeReference).ToArray();

            // Handle the cases where we don't have type information (null literal, open properties) for ANY of the arguments
            int argumentCount = argumentTypes.Length;
            if (argumentTypes.All(a => a == null) && argumentCount > 0)
            {
                // we specifically want to find just the first function that matches the number of arguments, we don't care about
                // ambiguity here because we're already in an ambiguous case where we don't know what kind of types
                // those arguments are.
                KeyValuePair<string, FunctionSignatureWithReturnType> found = nameSignatures.FirstOrDefault(pair => pair.Value.ArgumentTypes.Length == argumentCount);
                if (found.Equals(TypePromotionUtils.NotFoundKeyValuePair))
                {
                    throw new ODataException(ODataErrorStrings.FunctionCallBinder_CannotFindASuitableOverload(functionCallToken, argumentTypes.Length));
                }
                else
                {
                    // in this case we can't assert the return type, we can only assert that a function exists... so
                    // we need to set the return type to null.
                    nameSignature = new KeyValuePair<string, FunctionSignatureWithReturnType>(
                        found.Key, new FunctionSignatureWithReturnType(null, found.Value.ArgumentTypes));
                }
            }
            else
            {
                nameSignature =
                    TypePromotionUtils.FindBestFunctionSignature(nameSignatures, argumentNodes, functionCallToken);
                if (nameSignature.Equals(TypePromotionUtils.NotFoundKeyValuePair))
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_NoApplicableFunctionFound(
                        functionCallToken,
                        UriFunctionsHelper.BuildFunctionSignatureListDescription(functionCallToken, nameSignatures.Select(sig => sig.Value))));
                }
            }

            return nameSignature;
        }

        /// <summary>
        /// Finds all signatures for the given function name.
        /// Search in both BuiltIn uri functions and Custom uri functions.
        /// Combine and return the signatures overloads of the results.
        /// </summary>
        /// <param name="functionCallToken">The function call token to get the signatures for.</param>
        /// <param name="enableCaseInsensitive">Optional flag for whether case insensitive match is enabled.</param>
        /// <returns>The signatures which match the supplied function name.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "need to use lower characters for built-in functions.")]
        internal static IList<KeyValuePair<string, FunctionSignatureWithReturnType>> GetUriFunctionSignatures(string functionCallToken, bool enableCaseInsensitive = false)
        {
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> customUriFunctionsNameSignatures = null;
            FunctionSignatureWithReturnType[] builtInUriFunctionsSignatures = null;
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> builtInUriFunctionsNameSignatures = null;

            // Try to find the function in the user custom functions
            bool customFound = CustomUriFunctions.TryGetCustomFunction(functionCallToken, out customUriFunctionsNameSignatures,
                enableCaseInsensitive);

            // And find in our built-in functions
            // Since list of all built-in functions is a fixed list and is initialized with names in lower case,
            // such as "endswith", "geo.distance", "maxdatetime" and "round",
            // => For case-insensitive searching, it is more efficient to convert the search key to lower case first
            //    and then do a case-sensitive match.
            string nameKey = enableCaseInsensitive
                ? functionCallToken.ToLowerInvariant()
                : functionCallToken;
            bool builtInFound = BuiltInUriFunctions.TryGetBuiltInFunction(nameKey, out builtInUriFunctionsSignatures);

            // Populate the matched names found for built-in function
            if (builtInFound)
            {
                builtInUriFunctionsNameSignatures =
                    builtInUriFunctionsSignatures.Select(sig => new KeyValuePair<string, FunctionSignatureWithReturnType>(nameKey, sig)).ToList();
            }

            if (!customFound && !builtInFound)
            {
                // Not found in both built-in and custom.
                throw new ODataException(ODataErrorStrings.MetadataBinder_UnknownFunction(functionCallToken));
            }

            if (!customFound)
            {
                Debug.Assert(builtInUriFunctionsNameSignatures != null, "No Built-in functions found");
                return builtInUriFunctionsNameSignatures;
            }

            if (!builtInFound)
            {
                Debug.Assert(customUriFunctionsNameSignatures != null, "No Custom functions found");
                return customUriFunctionsNameSignatures;
            }

            return builtInUriFunctionsNameSignatures.Concat(customUriFunctionsNameSignatures).ToArray();
        }

        internal static FunctionSignatureWithReturnType[] ExtractSignatures(
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures)
        {
            return nameSignatures.Select(nameSig => nameSig.Value).ToArray();
        }

        /// <summary>
        /// Binds the token to a SingleValueFunctionCallNode or a SingleResourceFunctionCallNode for complex
        /// </summary>
        /// <param name="functionCallToken">Token to bind</param>
        /// <returns>The resulting SingleValueFunctionCallNode/SingleResourceFunctionCallNode</returns>
        internal QueryNode BindFunctionCall(FunctionCallToken functionCallToken)
        {
            ExceptionUtils.CheckArgumentNotNull(functionCallToken, "functionCallToken");
            ExceptionUtils.CheckArgumentNotNull(functionCallToken.Name, "functionCallToken.Name");

            // Bind the parent, if present.
            // TODO: parent can be a collection as well, so we need to loosen this to QueryNode.
            QueryNode parent = null;
            if (state.ImplicitRangeVariable != null)
            {
                if (functionCallToken.Source != null)
                {
                    parent = this.bindMethod(functionCallToken.Source);
                }
                else
                {
                    parent = NodeFactory.CreateRangeVariableReferenceNode(state.ImplicitRangeVariable);
                }
            }

            // First see if there is a custom function for this
            QueryNode boundFunction;
            if (this.TryBindIdentifier(functionCallToken.Name, functionCallToken.Arguments, parent, state, out boundFunction))
            {
                return boundFunction;
            }

            // then check if there is a global custom function(i.e with out a parent node)
            if (this.TryBindIdentifier(functionCallToken.Name, functionCallToken.Arguments, null, state, out boundFunction))
            {
                return boundFunction;
            }

            // If there isn't, bind as Uri function
            // Bind all arguments
            List<QueryNode> argumentNodes = new List<QueryNode>(functionCallToken.Arguments.Select(ar => this.bindMethod(ar)));
            return BindAsUriFunction(functionCallToken, argumentNodes);
        }

        /// <summary>
        /// Try to bind an end path token as a function call. Used for bound functions without parameters
        /// that parse as end path tokens syntactically
        /// </summary>
        /// <param name="endPathToken">the end path token to bind</param>
        /// <param name="parent">the parent node to this end path token.</param>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if it exists</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindEndPathAsFunctionCall(EndPathToken endPathToken, QueryNode parent, BindingState state, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(endPathToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Try to bind an inner path token as a function call. Used for bound functions without parameters
        /// that parse as inner path tokens syntactically
        /// </summary>
        /// <param name="innerPathToken">the end path token to bind</param>
        /// <param name="parent">the parent node to this end path token.</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if it exists</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindInnerPathAsFunctionCall(InnerPathToken innerPathToken, QueryNode parent, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(innerPathToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Try to bind a <see cref="DottedIdentifierToken"/> as a function call. Used for container qualified functions without parameters.
        /// </summary>
        /// <param name="dottedIdentifierToken">the dotted identifier token to bind</param>
        /// <param name="parent">the semantically bound parent node for this dotted identifier</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if we found one.</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindDottedIdentifierAsFunctionCall(DottedIdentifierToken dottedIdentifierToken, SingleValueNode parent, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(dottedIdentifierToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Bind this function call token as a Uri function
        /// </summary>
        /// <param name="functionCallToken">the function call token to bind</param>
        /// <param name="argumentNodes">list of semantically bound arguments</param>
        /// <returns>A function call node bound to this function.</returns>
        private QueryNode BindAsUriFunction(FunctionCallToken functionCallToken, List<QueryNode> argumentNodes)
        {
            if (functionCallToken.Source != null)
            {
                // the parent must be null for a Uri function.
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_UriFunctionMustHaveHaveNullParent(functionCallToken.Name));
            }

            // There are some functions (IsOf and Cast for example) that don't necessarily need to be bound to a function signature,
            // for these, we just Bind them directly to a SingleValueFunctionCallNode
            string matchedFunctionCallTokenName = IsUnboundFunction(functionCallToken.Name);
            if (matchedFunctionCallTokenName != null)
            {
                return CreateUnboundFunctionNode(matchedFunctionCallTokenName, argumentNodes);
            }

            // Do some validation and get potential Uri functions that could match what we saw
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures = GetUriFunctionSignatures(functionCallToken.Name,
                this.state.Configuration.EnableCaseInsensitiveUriFunctionIdentifier);

            SingleValueNode[] argumentNodeArray = ValidateArgumentsAreSingleValue(functionCallToken.Name, argumentNodes);
            KeyValuePair<string, FunctionSignatureWithReturnType> nameSignature = MatchSignatureToUriFunction(functionCallToken.Name, argumentNodeArray, nameSignatures);
            Debug.Assert(nameSignature.Key != null, "nameSignature.Key != null");

            string canonicalName = nameSignature.Key;
            FunctionSignatureWithReturnType signature = nameSignature.Value;
            if (signature.ReturnType != null)
            {
                TypePromoteArguments(signature, argumentNodes);
            }

            if (signature.ReturnType != null && signature.ReturnType.IsStructured())
            {
                return new SingleResourceFunctionCallNode(canonicalName, new ReadOnlyCollection<QueryNode>(argumentNodes), signature.ReturnType.AsStructured(), null);
            }

            return new SingleValueFunctionCallNode(canonicalName, new ReadOnlyCollection<QueryNode>(argumentNodes), signature.ReturnType);
        }

        /// <summary>
        /// Try to bind an identifier to a FunctionCallNode
        /// </summary>
        /// <param name="identifier">the identifier to bind</param>
        /// <param name="arguments">the semantically bound list of arguments.</param>
        /// <param name="parent">a semantically bound parent node.</param>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="boundFunction">a single value function call node representing this function call, if we found one.</param>
        /// <returns>true if we found a function for this token.</returns>
        private bool TryBindIdentifier(string identifier, IEnumerable<FunctionParameterToken> arguments, QueryNode parent, BindingState state, out QueryNode boundFunction)
        {
            boundFunction = null;

            IEdmType bindingType = null;
            SingleValueNode singleValueParent = parent as SingleValueNode;
            if (singleValueParent != null)
            {
                if (singleValueParent.TypeReference != null)
                {
                    bindingType = singleValueParent.TypeReference.Definition;
                }
            }
            else
            {
                CollectionNode collectionValueParent = parent as CollectionNode;
                if (collectionValueParent != null)
                {
                    bindingType = collectionValueParent.CollectionType.Definition;
                }
            }

            if (!UriEdmHelpers.IsBindingTypeValid(bindingType))
            {
                return false;
            }

            // All functions should be fully qualified, if they aren't they they aren't functions.
            // When using extension, there may be function call with unqualified name. So loose the restriction here.
            if (identifier.IndexOf(".", StringComparison.Ordinal) == -1 && this.Resolver.GetType() == typeof(ODataUriResolver))
            {
                return false;
            }

            IEdmOperation operation;
            List<FunctionParameterToken> syntacticArguments = arguments == null ? new List<FunctionParameterToken>() : arguments.ToList();
            if (!FunctionOverloadResolver.ResolveOperationFromList(identifier, syntacticArguments.Select(ar => ar.ParameterName).ToList(), bindingType, state.Model, out operation, this.Resolver))
            {
                // TODO: FunctionOverloadResolver.ResolveOperationFromList() looks up the function by parameter names, but it shouldn't ignore parameter types. (test case ParseFilter_AliasInFunction_PropertyAsValue_TypeMismatch should fail)
                return false;
            }

            if (singleValueParent != null && singleValueParent.TypeReference == null)
            {
                // if the parent exists, but has no type information, then we're in open type land, and we
                // shouldn't go any farther.
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_CallingFunctionOnOpenProperty(identifier));
            }

            if (operation.IsAction())
            {
                return false;
            }

            IEdmFunction function = (IEdmFunction)operation;

            // TODO:  $filter $orderby parameter expression which contains complex or collection should NOT be supported in this way
            //     but should be parsed into token tree, and binded to node tree: parsedParameters.Select(p => this.bindMethod(p));
            ICollection<FunctionParameterToken> parsedParameters = HandleComplexOrCollectionParameterValueIfExists(state.Configuration.Model, function, syntacticArguments, state.Configuration.Resolver.EnableCaseInsensitive);

            IEnumerable<QueryNode> boundArguments = parsedParameters.Select(p => this.bindMethod(p));
            boundArguments = boundArguments.ToList(); // force enumerable to run : will immediately evaluate all this.bindMethod(p).
            IEdmTypeReference returnType = function.ReturnType;
            IEdmEntitySetBase returnSet = null;
            SingleResourceNode singleEntityNode = parent as SingleResourceNode;
            if (singleEntityNode != null)
            {
                returnSet = function.GetTargetEntitySet(singleEntityNode.NavigationSource, state.Model);
            }

            string functionName = function.FullName();

            if (returnType.IsEntity())
            {
                boundFunction = new SingleResourceFunctionCallNode(functionName, new[] { function }, boundArguments, (IEdmEntityTypeReference)returnType.Definition.ToTypeReference(), returnSet, parent);
            }
            else if (returnType.IsStructuredCollection())
            {
                IEdmCollectionTypeReference collectionTypeReference = (IEdmCollectionTypeReference)returnType;
                boundFunction = new CollectionResourceFunctionCallNode(functionName, new[] { function }, boundArguments, collectionTypeReference, returnSet, parent);
            }
            else if (returnType.IsCollection())
            {
                IEdmCollectionTypeReference collectionTypeReference = (IEdmCollectionTypeReference)returnType;
                boundFunction = new CollectionFunctionCallNode(functionName, new[] { function }, boundArguments, collectionTypeReference, parent);
            }
            else
            {
                boundFunction = new SingleValueFunctionCallNode(functionName, new[] { function }, boundArguments,
                    returnType, parent);
            }

            return true;
        }

        /// <summary>
        /// Bind path segment's operation or operationImport's parameters.
        /// </summary>
        /// <param name="configuration">The ODataUriParserConfiguration.</param>
        /// <param name="functionOrOpertion">The function or operation.</param>
        /// <param name="segmentParameterTokens">The parameter tokens to be binded.</param>
        /// <returns>The binded semantic nodes.</returns>
        internal static List<OperationSegmentParameter> BindSegmentParameters(ODataUriParserConfiguration configuration, IEdmOperation functionOrOpertion, ICollection<FunctionParameterToken> segmentParameterTokens)
        {
            // TODO: HandleComplexOrCollectionParameterValueIfExists is temp work around for single copmlex or colleciton type, it can't handle nested complex or collection value.
            ICollection<FunctionParameterToken> parametersParsed = FunctionCallBinder.HandleComplexOrCollectionParameterValueIfExists(configuration.Model, functionOrOpertion, segmentParameterTokens, configuration.Resolver.EnableCaseInsensitive, configuration.EnableUriTemplateParsing);

            // Bind it to metadata
            BindingState state = new BindingState(configuration);
            state.ImplicitRangeVariable = null;
            state.RangeVariables.Clear();
            MetadataBinder binder = new MetadataBinder(state);
            List<OperationSegmentParameter> boundParameters = new List<OperationSegmentParameter>();

            IDictionary<string, SingleValueNode> input = new Dictionary<string, SingleValueNode>(StringComparer.Ordinal);
            foreach (FunctionParameterToken paraToken in parametersParsed)
            {
                // TODO: considering another better exception
                if (paraToken.ValueToken is EndPathToken)
                {
                    throw new ODataException(Strings.MetadataBinder_ParameterNotInScope(
                        string.Format(CultureInfo.InvariantCulture, "{0}={1}", paraToken.ParameterName, (paraToken.ValueToken as EndPathToken).Identifier)));
                }

                SingleValueNode boundNode = (SingleValueNode)binder.Bind(paraToken.ValueToken);

                if (!input.ContainsKey(paraToken.ParameterName))
                {
                    input.Add(paraToken.ParameterName, boundNode);
                }
            }

            IDictionary<IEdmOperationParameter, SingleValueNode> result = configuration.Resolver.ResolveOperationParameters(functionOrOpertion, input);

            foreach (KeyValuePair<IEdmOperationParameter, SingleValueNode> item in result)
            {
                SingleValueNode boundNode = item.Value;

                // ensure node type is compatible with parameter type.
                IEdmTypeReference sourceTypeReference = boundNode.GetEdmTypeReference();
                bool sourceIsNullOrOpenType = (sourceTypeReference == null);
                if (!sourceIsNullOrOpenType)
                {
                    // if the node has been rewritten, no further conversion is needed.
                    if (!TryRewriteIntegralConstantNode(ref boundNode, item.Key.Type))
                    {
                        boundNode = MetadataBindingUtils.ConvertToTypeIfNeeded(boundNode, item.Key.Type);
                    }
                }

                OperationSegmentParameter boundParamer = new OperationSegmentParameter(item.Key.Name, boundNode);
                boundParameters.Add(boundParamer);
            }

            return boundParameters;
        }

        /// <summary>
        /// Try to rewrite an Edm.Int32 constant node if its value is within the valid range of the target integer type.
        /// </summary>
        /// <param name="boundNode">The node to be rewritten.</param>
        /// <param name="targetType">The target type reference.</param>
        /// <returns>If the node is successfully rewritten.</returns>
        private static bool TryRewriteIntegralConstantNode(ref SingleValueNode boundNode, IEdmTypeReference targetType)
        {
            if (targetType == null || !targetType.IsByte() && !targetType.IsSByte() && !targetType.IsInt16())
            {
                return false;
            }

            ConstantNode constantNode = boundNode as ConstantNode;
            if (constantNode == null)
            {
                return false;
            }

            IEdmTypeReference sourceType = constantNode.TypeReference;
            if (sourceType == null || !sourceType.IsInt32())
            {
                return false;
            }

            int sourceValue = (int)constantNode.Value;
            object targetValue = null;
            switch (targetType.PrimitiveKind())
            {
                case EdmPrimitiveTypeKind.Byte:
                    if (sourceValue >= byte.MinValue && sourceValue <= byte.MaxValue)
                    {
                        targetValue = (byte)sourceValue;
                    }

                    break;
                case EdmPrimitiveTypeKind.SByte:
                    if (sourceValue >= sbyte.MinValue && sourceValue <= sbyte.MaxValue)
                    {
                        targetValue = (sbyte)sourceValue;
                    }

                    break;
                case EdmPrimitiveTypeKind.Int16:
                    if (sourceValue >= short.MinValue && sourceValue <= short.MaxValue)
                    {
                        targetValue = (short)sourceValue;
                    }

                    break;
            }

            if (targetValue == null)
            {
                return false;
            }

            boundNode = new ConstantNode(targetValue, constantNode.LiteralText, targetType);
            return true;
        }

        /// <summary>
        /// This is temp work around for $filter $orderby parameter expression which contains complex or collection
        ///     like "Fully.Qualified.Namespace.CanMoveToAddresses(addresses=[{\"Street\":\"NE 24th St.\",\"City\":\"Redmond\"},{\"Street\":\"Pine St.\",\"City\":\"Seattle\"}])";
        /// TODO:  $filter $orderby parameter expression which contains nested complex or collection should NOT be supported in this way
        ///     but should be parsed into token tree, and binded to node tree: parsedParameters.Select(p => this.bindMethod(p));
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="operation">IEdmFunction or IEdmOperation</param>
        /// <param name="parameterTokens">The tokens to bind.</param>
        /// <param name="enableCaseInsensitive">Whether to enable case-insensitive when resolving parameter name.</param>
        /// <param name="enableUriTemplateParsing">Whether Uri template parsing is enabled.</param>
        /// <returns>The FunctionParameterTokens with complex or collection values converted from string like "{...}", or "[..,..,..]".</returns>
        private static ICollection<FunctionParameterToken> HandleComplexOrCollectionParameterValueIfExists(IEdmModel model, IEdmOperation operation, ICollection<FunctionParameterToken> parameterTokens, bool enableCaseInsensitive, bool enableUriTemplateParsing = false)
        {
            ICollection<FunctionParameterToken> partiallyParsedParametersWithComplexOrCollection = new Collection<FunctionParameterToken>();
            foreach (FunctionParameterToken paraToken in parameterTokens)
            {
                FunctionParameterToken funcParaToken;
                IEdmOperationParameter functionParameter = operation.FindParameter(paraToken.ParameterName);
                if (enableCaseInsensitive && functionParameter == null)
                {
                    functionParameter = ODataUriResolver.ResolveOperationParameterNameCaseInsensitive(operation, paraToken.ParameterName);

                    // The functionParameter can not be null here, else this method won't be called.
                    funcParaToken = new FunctionParameterToken(functionParameter.Name, paraToken.ValueToken);
                }
                else
                {
                    funcParaToken = paraToken;
                }

                FunctionParameterAliasToken aliasToken = funcParaToken.ValueToken as FunctionParameterAliasToken;
                if (aliasToken != null)
                {
                    aliasToken.ExpectedParameterType = functionParameter.Type;
                }

                LiteralToken valueToken = funcParaToken.ValueToken as LiteralToken;
                string valueStr = null;
                if (valueToken != null && (valueStr = valueToken.Value as string) != null && !string.IsNullOrEmpty(valueToken.OriginalText))
                {
                    ExpressionLexer lexer = new ExpressionLexer(valueToken.OriginalText, true /*moveToFirstToken*/, false /*useSemicolonDelimiter*/, true /*parsingFunctionParameters*/);
                    if (lexer.CurrentToken.Kind == ExpressionTokenKind.BracketedExpression || lexer.CurrentToken.Kind == ExpressionTokenKind.BracedExpression)
                    {
                        object result;
                        UriTemplateExpression expression;

                        if (enableUriTemplateParsing && UriTemplateParser.TryParseLiteral(lexer.CurrentToken.Text, functionParameter.Type, out expression))
                        {
                            result = expression;
                        }
                        else if (!functionParameter.Type.IsStructured() && !functionParameter.Type.IsStructuredCollectionType())
                        {
                            // ExpressionTokenKind.BracketedExpression means text like [1,2]
                            // so now try convert it to collection type value:
                            result = ODataUriUtils.ConvertFromUriLiteral(valueStr, ODataVersion.V4, model, functionParameter.Type);
                        }
                        else
                        {
                            // For complex & colleciton of complex directly return the raw string.
                            partiallyParsedParametersWithComplexOrCollection.Add(funcParaToken);
                            continue;
                        }

                        LiteralToken newValueToken = new LiteralToken(result, valueToken.OriginalText);
                        FunctionParameterToken newFuncParaToken = new FunctionParameterToken(funcParaToken.ParameterName, newValueToken);
                        partiallyParsedParametersWithComplexOrCollection.Add(newFuncParaToken);
                        continue;
                    }
                }

                partiallyParsedParametersWithComplexOrCollection.Add(funcParaToken);
            }

            return partiallyParsedParametersWithComplexOrCollection;
        }

        /// <summary>
        /// Determines whether this is a unbound BuiltInFunction according to the configured case-sensitiveness.
        /// </summary>
        /// <param name="functionName">name of the function</param>
        /// <returns>matched unbound function names; null if no matches found.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "need to use lower characters for unbound functions.")]
        private string IsUnboundFunction(string functionName)
        {
            functionName = this.state.Configuration.EnableCaseInsensitiveUriFunctionIdentifier
                ? functionName.ToLowerInvariant()
                : functionName;
            return UnboundFunctionNames.FirstOrDefault(name => name.Equals(functionName, StringComparison.Ordinal));
        }

        /// <summary>
        /// Build a SingleValueFunctionCallNode for a function that isn't bound to a BuiltInFunction
        /// </summary>
        /// <param name="functionCallTokenName">Name for the function</param>
        /// <param name="args">list of already bound query nodes for this function</param>
        /// <returns>A single value function call node bound to this function.</returns>
        private SingleValueNode CreateUnboundFunctionNode(string functionCallTokenName, List<QueryNode> args)
        {
            // need to figure out the return type and check the correct number of arguments based on the function name
            IEdmTypeReference returnType = null;
            switch (functionCallTokenName)
            {
                case ExpressionConstants.UnboundFunctionIsOf:
                    {
                        returnType = ValidateAndBuildIsOfArgs(state, ref args);
                        break;
                    }

                case ExpressionConstants.UnboundFunctionCast:
                    {
                        returnType = ValidateAndBuildCastArgs(state, ref args);
                        if (returnType.IsStructured())
                        {
                            SingleResourceNode entityNode = args.ElementAt(0) as SingleResourceNode;

                            return new SingleResourceFunctionCallNode(functionCallTokenName, args,
                                returnType.AsStructured(), entityNode != null ? entityNode.NavigationSource : null);
                        }

                        break;
                    }

                default:
                    {
                        break;
                    }
            }

            // we have everything else we need, so return the new SingleValueFunctionCallNode.
            return new SingleValueFunctionCallNode(functionCallTokenName, args, returnType);
        }

        /// <summary>
        /// Validate the args list (adding the implicit range variable if necessary), and determine the correct return type for a cast function
        /// </summary>
        /// <param name="state">current binding state, used to get the implicit range variable if necessary</param>
        /// <param name="args">list of arguments, could be changed</param>
        /// <returns>the return type from this cast function</returns>
        private static IEdmTypeReference ValidateAndBuildCastArgs(BindingState state, ref List<QueryNode> args)
        {
            return ValidateIsOfOrCast(state, true, ref args);
        }

        /// <summary>
        /// Validate the arguments (adding the implicit range variable if necessary), and determine the correct return type
        /// for an IsOf function
        /// </summary>
        /// <param name="state">the current state of the binding algorithm, used to get the implicit range variable if necessary</param>
        /// <param name="args">current list of args, can be changed</param>
        /// <returns>the correct return type for this function.</returns>
        private static IEdmTypeReference ValidateAndBuildIsOfArgs(BindingState state, ref List<QueryNode> args)
        {
            return ValidateIsOfOrCast(state, false, ref args);
        }

        /// <summary>
        /// Validate the arguments to either isof or cast
        /// </summary>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="isCast">flag to indicate which function we're validating</param>
        /// <param name="args">the list of arguments, which could be changed</param>
        /// <returns>the return type of the function.</returns>
        private static IEdmTypeReference ValidateIsOfOrCast(BindingState state, bool isCast, ref List<QueryNode> args)
        {
            if (args.Count != 1 && args.Count != 2)
            {
                throw new ODataErrorException(
                    ODataErrorStrings.MetadataBinder_CastOrIsOfExpressionWithWrongNumberOfOperands(args.Count));
            }

            ConstantNode typeArgument = args.Last() as ConstantNode;

            IEdmTypeReference returnType = null;
            if (typeArgument != null)
            {
                returnType = TryGetTypeReference(state.Model, typeArgument.Value as string, state.Configuration.Resolver);
            }

            if (returnType == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfFunctionWithoutATypeArgument);
            }

            if (returnType.IsCollection())
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfCollectionsNotSupported);
            }

            // if we only have one argument, then add the implicit range variable as the first argument.
            if (args.Count == 1)
            {
                args = new List<QueryNode>()
                    {
                        new ResourceRangeVariableReferenceNode(
                                                             state.ImplicitRangeVariable.Name,
                                                             state.ImplicitRangeVariable as ResourceRangeVariable),
                        args[0]
                    };
            }
            else if (!(args[0] is SingleValueNode))
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfCollectionsNotSupported);
            }

            if (isCast && (args.Count == 2))
            {
                // throw if cast enum to not-string :
                if ((args[0].GetEdmTypeReference() is IEdmEnumTypeReference)
                    && !string.Equals(typeArgument.Value as string, Microsoft.OData.Metadata.EdmConstants.EdmStringTypeName, StringComparison.Ordinal))
                {
                    throw new ODataException(ODataErrorStrings.CastBinder_EnumOnlyCastToOrFromString);
                }

                // throw if cast not-string to enum :
                while (returnType is IEdmEnumTypeReference)
                {
                    IEdmTypeReference edmTypeReference = args[0].GetEdmTypeReference();
                    if (edmTypeReference == null)
                    {
                        // Support cast null to enum
                        break;
                    }

                    IEdmPrimitiveTypeReference referenceTmp = edmTypeReference as IEdmPrimitiveTypeReference;
                    if (referenceTmp != null)
                    {
                        IEdmPrimitiveType typeTmp = referenceTmp.Definition as IEdmPrimitiveType;
                        if ((typeTmp != null) && (typeTmp.PrimitiveKind == EdmPrimitiveTypeKind.String))
                        {
                            break;
                        }
                    }

                    throw new ODataException(ODataErrorStrings.CastBinder_EnumOnlyCastToOrFromString);
                }
            }

            if (isCast)
            {
                return returnType;
            }
            else
            {
                return EdmCoreModel.Instance.GetBoolean(true);
            }
        }

        /// <summary>
        /// Try to get an IEdmTypeReference for a given type as a string, returns null if none exists
        /// </summary>
        /// <param name="model">the model for validation</param>
        /// <param name="fullTypeName">the type name to find</param>
        /// <param name="resolver">Resolver for this func.</param>
        /// <returns>an IEdmTypeReference for this type string.</returns>
        private static IEdmTypeReference TryGetTypeReference(IEdmModel model, string fullTypeName, ODataUriResolver resolver)
        {
            IEdmTypeReference typeReference = UriEdmHelpers.FindTypeFromModel(model, fullTypeName, resolver).ToTypeReference();
            if (typeReference == null)
            {
                if (fullTypeName.StartsWith("Collection", StringComparison.Ordinal))
                {
                    string[] tokenizedString = fullTypeName.Split('(');
                    string baseElementType = tokenizedString[1].Split(')')[0];
                    return EdmCoreModel.GetCollection(UriEdmHelpers.FindTypeFromModel(model, baseElementType, resolver).ToTypeReference());
                }
                else
                {
                    return null;
                }
            }

            return typeReference;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using Microsoft.OData.Metadata;
using Microsoft.OData.Edm;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Class that knows how to bind function call tokens.
    /// </summary>
    internal sealed class FunctionCallBinder : BinderBase
    {
        /// <summary>
        /// The names of functions that we don't bind to BuiltInFunctions
        /// </summary>
        private static readonly string[] UnboundFunctionNames = new string[]
        {
            ExpressionConstants.UnboundFunctionCast,
            ExpressionConstants.UnboundFunctionIsOf,
        };

        /// <summary>
        /// Constructs a FunctionCallBinder with the given method to be used binding the parent token if needed.
        /// </summary>
        /// <param name="bindMethod">Method to use for binding the parent token, if needed.</param>
        /// <param name="state">State of the metadata binding.</param>
        internal FunctionCallBinder(MetadataBinder.QueryTokenVisitor bindMethod, BindingState state)
            : base(bindMethod, state)
        {
        }

        /// <summary>
        /// Promotes types of arguments to match signature if possible.
        /// </summary>
        /// <param name="signature">The signature to match the types to.</param>
        /// <param name="argumentNodes">The types to promote.</param>
        internal static void TypePromoteArguments(FunctionSignatureWithReturnType signature, List<QueryNode> argumentNodes)
        {
            // Convert all argument nodes to the best signature argument type
            Debug.Assert(signature.ArgumentTypes.Length == argumentNodes.Count, "The best signature match doesn't have the same number of arguments.");
            for (int i = 0; i < argumentNodes.Count; i++)
            {
                Debug.Assert(argumentNodes[i] is SingleValueNode, "We should have already verified that all arguments are single values.");
                SingleValueNode argumentNode = (SingleValueNode)argumentNodes[i];
                IEdmTypeReference signatureArgumentType = signature.ArgumentTypes[i];
                Debug.Assert(signatureArgumentType.IsODataPrimitiveTypeKind() || signatureArgumentType.IsODataEnumTypeKind(), "Only primitive or enum types should be able to get here.");
                argumentNodes[i] = MetadataBindingUtils.ConvertToTypeIfNeeded(argumentNode, signatureArgumentType);
            }
        }

        /// <summary>
        /// Checks that all arguments are SingleValueNodes
        /// </summary>
        /// <param name="functionName">The name of the function the arguments are from.</param>
        /// <param name="argumentNodes">The arguments to validate.</param>
        /// <returns>SingleValueNode array</returns>
        internal static SingleValueNode[] ValidateArgumentsAreSingleValue(string functionName, List<QueryNode> argumentNodes)
        {
            ExceptionUtils.CheckArgumentNotNull(functionName, "functionCallToken");
            ExceptionUtils.CheckArgumentNotNull(argumentNodes, "argumentNodes");

            // Right now all functions take a single value for all arguments
            SingleValueNode[] ret = new SingleValueNode[argumentNodes.Count];
            for (int i = 0; i < argumentNodes.Count; i++)
            {
                SingleValueNode argumentNode = argumentNodes[i] as SingleValueNode;
                if (argumentNode == null)
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_FunctionArgumentNotSingleValue(functionName));
                }

                ret[i] = argumentNode;
            }

            return ret;
        }

        /// <summary>
        /// Finds the signature that best matches the arguments
        /// </summary>
        /// <param name="functionCallToken">The name of the function</param>
        /// <param name="argumentNodes">The nodes of the arguments, can be new {null,null}.</param>
        /// <param name="nameSignatures">The name-signature pairs to match against</param>
        /// <returns>Returns the matching signature or throws</returns>
        internal static KeyValuePair<string, FunctionSignatureWithReturnType> MatchSignatureToUriFunction(string functionCallToken, SingleValueNode[] argumentNodes,
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures)
        {
            KeyValuePair<string, FunctionSignatureWithReturnType> nameSignature;

            IEdmTypeReference[] argumentTypes = argumentNodes.Select(s => s.TypeReference).ToArray();

            // Handle the cases where we don't have type information (null literal, open properties) for ANY of the arguments
            int argumentCount = argumentTypes.Length;
            if (argumentTypes.All(a => a == null) && argumentCount > 0)
            {
                // we specifically want to find just the first function that matches the number of arguments, we don't care about
                // ambiguity here because we're already in an ambiguous case where we don't know what kind of types
                // those arguments are.
                KeyValuePair<string, FunctionSignatureWithReturnType> found = nameSignatures.FirstOrDefault(pair => pair.Value.ArgumentTypes.Length == argumentCount);
                if (found.Equals(TypePromotionUtils.NotFoundKeyValuePair))
                {
                    throw new ODataException(ODataErrorStrings.FunctionCallBinder_CannotFindASuitableOverload(functionCallToken, argumentTypes.Length));
                }
                else
                {
                    // in this case we can't assert the return type, we can only assert that a function exists... so
                    // we need to set the return type to null.
                    nameSignature = new KeyValuePair<string, FunctionSignatureWithReturnType>(
                        found.Key, new FunctionSignatureWithReturnType(null, found.Value.ArgumentTypes));
                }
            }
            else
            {
                nameSignature =
                    TypePromotionUtils.FindBestFunctionSignature(nameSignatures, argumentNodes, functionCallToken);
                if (nameSignature.Equals(TypePromotionUtils.NotFoundKeyValuePair))
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_NoApplicableFunctionFound(
                        functionCallToken,
                        UriFunctionsHelper.BuildFunctionSignatureListDescription(functionCallToken, nameSignatures.Select(sig => sig.Value))));
                }
            }

            return nameSignature;
        }

        /// <summary>
        /// Finds all signatures for the given function name.
        /// Search in both BuiltIn uri functions and Custom uri functions.
        /// Combine and return the signatures overloads of the results.
        /// </summary>
        /// <param name="functionCallToken">The function call token to get the signatures for.</param>
        /// <param name="enableCaseInsensitive">Optional flag for whether case insensitive match is enabled.</param>
        /// <returns>The signatures which match the supplied function name.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "need to use lower characters for built-in functions.")]
        internal static IList<KeyValuePair<string, FunctionSignatureWithReturnType>> GetUriFunctionSignatures(string functionCallToken, bool enableCaseInsensitive = false)
        {
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> customUriFunctionsNameSignatures = null;
            FunctionSignatureWithReturnType[] builtInUriFunctionsSignatures = null;
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> builtInUriFunctionsNameSignatures = null;

            // Try to find the function in the user custom functions
            bool customFound = CustomUriFunctions.TryGetCustomFunction(functionCallToken, out customUriFunctionsNameSignatures,
                enableCaseInsensitive);

            // And find in our built-in functions
            // Since list of all built-in functions is a fixed list and is initialized with names in lower case,
            // such as "endswith", "geo.distance", "maxdatetime" and "round",
            // => For case-insensitive searching, it is more efficient to convert the search key to lower case first
            //    and then do a case-sensitive match.
            string nameKey = enableCaseInsensitive
                ? functionCallToken.ToLowerInvariant()
                : functionCallToken;
            bool builtInFound = BuiltInUriFunctions.TryGetBuiltInFunction(nameKey, out builtInUriFunctionsSignatures);

            // Populate the matched names found for built-in function
            if (builtInFound)
            {
                builtInUriFunctionsNameSignatures =
                    builtInUriFunctionsSignatures.Select(sig => new KeyValuePair<string, FunctionSignatureWithReturnType>(nameKey, sig)).ToList();
            }

            if (!customFound && !builtInFound)
            {
                // Not found in both built-in and custom.
                throw new ODataException(ODataErrorStrings.MetadataBinder_UnknownFunction(functionCallToken));
            }

            if (!customFound)
            {
                Debug.Assert(builtInUriFunctionsNameSignatures != null, "No Built-in functions found");
                return builtInUriFunctionsNameSignatures;
            }

            if (!builtInFound)
            {
                Debug.Assert(customUriFunctionsNameSignatures != null, "No Custom functions found");
                return customUriFunctionsNameSignatures;
            }

            return builtInUriFunctionsNameSignatures.Concat(customUriFunctionsNameSignatures).ToArray();
        }

        internal static FunctionSignatureWithReturnType[] ExtractSignatures(
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures)
        {
            return nameSignatures.Select(nameSig => nameSig.Value).ToArray();
        }

        /// <summary>
        /// Binds the token to a SingleValueFunctionCallNode or a SingleResourceFunctionCallNode for complex
        /// </summary>
        /// <param name="functionCallToken">Token to bind</param>
        /// <returns>The resulting SingleValueFunctionCallNode/SingleResourceFunctionCallNode</returns>
        internal QueryNode BindFunctionCall(FunctionCallToken functionCallToken)
        {
            ExceptionUtils.CheckArgumentNotNull(functionCallToken, "functionCallToken");
            ExceptionUtils.CheckArgumentNotNull(functionCallToken.Name, "functionCallToken.Name");

            // Bind the parent, if present.
            // TODO: parent can be a collection as well, so we need to loosen this to QueryNode.
            QueryNode parent = null;
            if (state.ImplicitRangeVariable != null)
            {
                if (functionCallToken.Source != null)
                {
                    parent = this.bindMethod(functionCallToken.Source);
                }
                else
                {
                    parent = NodeFactory.CreateRangeVariableReferenceNode(state.ImplicitRangeVariable);
                }
            }

            // First see if there is a custom function for this
            QueryNode boundFunction;
            if (this.TryBindIdentifier(functionCallToken.Name, functionCallToken.Arguments, parent, state, out boundFunction))
            {
                return boundFunction;
            }

            // then check if there is a global custom function(i.e with out a parent node)
            if (this.TryBindIdentifier(functionCallToken.Name, functionCallToken.Arguments, null, state, out boundFunction))
            {
                return boundFunction;
            }

            // If there isn't, bind as Uri function
            // Bind all arguments
            List<QueryNode> argumentNodes = new List<QueryNode>(functionCallToken.Arguments.Select(ar => this.bindMethod(ar)));
            return BindAsUriFunction(functionCallToken, argumentNodes);
        }

        /// <summary>
        /// Try to bind an end path token as a function call. Used for bound functions without parameters
        /// that parse as end path tokens syntactically
        /// </summary>
        /// <param name="endPathToken">the end path token to bind</param>
        /// <param name="parent">the parent node to this end path token.</param>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if it exists</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindEndPathAsFunctionCall(EndPathToken endPathToken, QueryNode parent, BindingState state, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(endPathToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Try to bind an inner path token as a function call. Used for bound functions without parameters
        /// that parse as inner path tokens syntactically
        /// </summary>
        /// <param name="innerPathToken">the end path token to bind</param>
        /// <param name="parent">the parent node to this end path token.</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if it exists</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindInnerPathAsFunctionCall(InnerPathToken innerPathToken, QueryNode parent, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(innerPathToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Try to bind a <see cref="DottedIdentifierToken"/> as a function call. Used for container qualified functions without parameters.
        /// </summary>
        /// <param name="dottedIdentifierToken">the dotted identifier token to bind</param>
        /// <param name="parent">the semantically bound parent node for this dotted identifier</param>
        /// <param name="boundFunction">a single value function call node representing the function call, if we found one.</param>
        /// <returns>true if we found a function for this token, false otherwise.</returns>
        internal bool TryBindDottedIdentifierAsFunctionCall(DottedIdentifierToken dottedIdentifierToken, SingleValueNode parent, out QueryNode boundFunction)
        {
            return this.TryBindIdentifier(dottedIdentifierToken.Identifier, null, parent, state, out boundFunction);
        }

        /// <summary>
        /// Bind this function call token as a Uri function
        /// </summary>
        /// <param name="functionCallToken">the function call token to bind</param>
        /// <param name="argumentNodes">list of semantically bound arguments</param>
        /// <returns>A function call node bound to this function.</returns>
        private QueryNode BindAsUriFunction(FunctionCallToken functionCallToken, List<QueryNode> argumentNodes)
        {
            if (functionCallToken.Source != null)
            {
                // the parent must be null for a Uri function.
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_UriFunctionMustHaveHaveNullParent(functionCallToken.Name));
            }

            // There are some functions (IsOf and Cast for example) that don't necessarily need to be bound to a function signature,
            // for these, we just Bind them directly to a SingleValueFunctionCallNode
            string matchedFunctionCallTokenName = IsUnboundFunction(functionCallToken.Name);
            if (matchedFunctionCallTokenName != null)
            {
                return CreateUnboundFunctionNode(matchedFunctionCallTokenName, argumentNodes);
            }

            // Do some validation and get potential Uri functions that could match what we saw
            IList<KeyValuePair<string, FunctionSignatureWithReturnType>> nameSignatures = GetUriFunctionSignatures(functionCallToken.Name,
                this.state.Configuration.EnableCaseInsensitiveUriFunctionIdentifier);

            SingleValueNode[] argumentNodeArray = ValidateArgumentsAreSingleValue(functionCallToken.Name, argumentNodes);
            KeyValuePair<string, FunctionSignatureWithReturnType> nameSignature = MatchSignatureToUriFunction(functionCallToken.Name, argumentNodeArray, nameSignatures);
            Debug.Assert(nameSignature.Key != null, "nameSignature.Key != null");

            string canonicalName = nameSignature.Key;
            FunctionSignatureWithReturnType signature = nameSignature.Value;
            if (signature.ReturnType != null)
            {
                TypePromoteArguments(signature, argumentNodes);
            }

            if (signature.ReturnType != null && signature.ReturnType.IsStructured())
            {
                return new SingleResourceFunctionCallNode(canonicalName, new ReadOnlyCollection<QueryNode>(argumentNodes), signature.ReturnType.AsStructured(), null);
            }

            return new SingleValueFunctionCallNode(canonicalName, new ReadOnlyCollection<QueryNode>(argumentNodes), signature.ReturnType);
        }

        /// <summary>
        /// Try to bind an identifier to a FunctionCallNode
        /// </summary>
        /// <param name="identifier">the identifier to bind</param>
        /// <param name="arguments">the semantically bound list of arguments.</param>
        /// <param name="parent">a semantically bound parent node.</param>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="boundFunction">a single value function call node representing this function call, if we found one.</param>
        /// <returns>true if we found a function for this token.</returns>
        private bool TryBindIdentifier(string identifier, IEnumerable<FunctionParameterToken> arguments, QueryNode parent, BindingState state, out QueryNode boundFunction)
        {
            boundFunction = null;

            IEdmType bindingType = null;

            if (parent is SingleValueNode singleValueParent)
            {
                if (singleValueParent.TypeReference != null)
                {
                    bindingType = singleValueParent.TypeReference.Definition;
                }
            }
            else
            {
                if (parent is CollectionNode collectionValueParent)
                {
                    bindingType = collectionValueParent.CollectionType.Definition;
                }
            }

            if (!UriEdmHelpers.IsBindingTypeValid(bindingType))
            {
                return false;
            }

            // All functions should be fully qualified, if they aren't they they aren't functions.
            // When using extension, there may be function call with unqualified name. So loose the restriction here.
            if (identifier.IndexOf(".", StringComparison.Ordinal) == -1 && this.Resolver.GetType() == typeof(ODataUriResolver))
            {
                return false;
            }

            IEdmOperation operation;
            List<FunctionParameterToken> syntacticArguments = arguments == null ? new List<FunctionParameterToken>() : arguments.ToList();
            if (!FunctionOverloadResolver.ResolveOperationFromList(identifier, syntacticArguments.Select(ar => ar.ParameterName).ToList(), bindingType, state.Model, out operation, this.Resolver))
            {
                // TODO: FunctionOverloadResolver.ResolveOperationFromList() looks up the function by parameter names, but it shouldn't ignore parameter types. (test case ParseFilter_AliasInFunction_PropertyAsValue_TypeMismatch should fail)
                return false;
            }

            if (parent is SingleValueNode singleValueParent && singleValueParent.TypeReference == null)
            {
                // if the parent exists, but has no type information, then we're in open type land, and we
                // shouldn't go any farther.
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_CallingFunctionOnOpenProperty(identifier));
            }

            if (operation.IsAction())
            {
                return false;
            }

            IEdmFunction function = (IEdmFunction)operation;

            // TODO:  $filter $orderby parameter expression which contains complex or collection should NOT be supported in this way
            //     but should be parsed into token tree, and binded to node tree: parsedParameters.Select(p => this.bindMethod(p));
            ICollection<FunctionParameterToken> parsedParameters = HandleComplexOrCollectionParameterValueIfExists(state.Configuration.Model, function, syntacticArguments, state.Configuration.Resolver.EnableCaseInsensitive);

            IEnumerable<QueryNode> boundArguments = parsedParameters.Select(p => this.bindMethod(p));
            boundArguments = boundArguments.ToList(); // force enumerable to run : will immediately evaluate all this.bindMethod(p).
            IEdmTypeReference returnType = function.ReturnType;
            IEdmEntitySetBase returnSet = null;

            if (parent is SingleResourceNode singleEntityNode)
            {
                returnSet = function.GetTargetEntitySet(singleEntityNode.NavigationSource, state.Model);
            }

            string functionName = function.FullName();

            if (returnType.IsEntity())
            {
                boundFunction = new SingleResourceFunctionCallNode(functionName, new[] { function }, boundArguments, (IEdmEntityTypeReference)returnType.Definition.ToTypeReference(), returnSet, parent);
            }
            else if (returnType.IsStructuredCollection())
            {
                IEdmCollectionTypeReference collectionTypeReference = (IEdmCollectionTypeReference)returnType;
                boundFunction = new CollectionResourceFunctionCallNode(functionName, new[] { function }, boundArguments, collectionTypeReference, returnSet, parent);
            }
            else if (returnType.IsCollection())
            {
                IEdmCollectionTypeReference collectionTypeReference = (IEdmCollectionTypeReference)returnType;
                boundFunction = new CollectionFunctionCallNode(functionName, new[] { function }, boundArguments, collectionTypeReference, parent);
            }
            else
            {
                boundFunction = new SingleValueFunctionCallNode(functionName, new[] { function }, boundArguments,
                    returnType, parent);
            }

            return true;
        }

        /// <summary>
        /// Bind path segment's operation or operationImport's parameters.
        /// </summary>
        /// <param name="configuration">The ODataUriParserConfiguration.</param>
        /// <param name="functionOrOpertion">The function or operation.</param>
        /// <param name="segmentParameterTokens">The parameter tokens to be binded.</param>
        /// <returns>The binded semantic nodes.</returns>
        internal static List<OperationSegmentParameter> BindSegmentParameters(ODataUriParserConfiguration configuration, IEdmOperation functionOrOpertion, ICollection<FunctionParameterToken> segmentParameterTokens)
        {
            // TODO: HandleComplexOrCollectionParameterValueIfExists is temp work around for single copmlex or colleciton type, it can't handle nested complex or collection value.
            ICollection<FunctionParameterToken> parametersParsed = FunctionCallBinder.HandleComplexOrCollectionParameterValueIfExists(configuration.Model, functionOrOpertion, segmentParameterTokens, configuration.Resolver.EnableCaseInsensitive, configuration.EnableUriTemplateParsing);

            // Bind it to metadata
            BindingState state = new BindingState(configuration);
            state.ImplicitRangeVariable = null;
            state.RangeVariables.Clear();
            MetadataBinder binder = new MetadataBinder(state);
            List<OperationSegmentParameter> boundParameters = new List<OperationSegmentParameter>();

            IDictionary<string, SingleValueNode> input = new Dictionary<string, SingleValueNode>(StringComparer.Ordinal);
            foreach (FunctionParameterToken paraToken in parametersParsed)
            {
                // TODO: considering another better exception
                if (paraToken.ValueToken is EndPathToken)
                {
                    throw new ODataException(Strings.MetadataBinder_ParameterNotInScope(
                        string.Format(CultureInfo.InvariantCulture, "{0}={1}", paraToken.ParameterName, (paraToken.ValueToken as EndPathToken).Identifier)));
                }

                SingleValueNode boundNode = (SingleValueNode)binder.Bind(paraToken.ValueToken);

                if (!input.ContainsKey(paraToken.ParameterName))
                {
                    input.Add(paraToken.ParameterName, boundNode);
                }
            }

            IDictionary<IEdmOperationParameter, SingleValueNode> result = configuration.Resolver.ResolveOperationParameters(functionOrOpertion, input);

            foreach (KeyValuePair<IEdmOperationParameter, SingleValueNode> item in result)
            {
                SingleValueNode boundNode = item.Value;

                // ensure node type is compatible with parameter type.
                IEdmTypeReference sourceTypeReference = boundNode.GetEdmTypeReference();
                bool sourceIsNullOrOpenType = (sourceTypeReference == null);
                if (!sourceIsNullOrOpenType)
                {
                    // if the node has been rewritten, no further conversion is needed.
                    if (!TryRewriteIntegralConstantNode(ref boundNode, item.Key.Type))
                    {
                        boundNode = MetadataBindingUtils.ConvertToTypeIfNeeded(boundNode, item.Key.Type);
                    }
                }

                OperationSegmentParameter boundParamer = new OperationSegmentParameter(item.Key.Name, boundNode);
                boundParameters.Add(boundParamer);
            }

            return boundParameters;
        }

        /// <summary>
        /// Try to rewrite an Edm.Int32 constant node if its value is within the valid range of the target integer type.
        /// </summary>
        /// <param name="boundNode">The node to be rewritten.</param>
        /// <param name="targetType">The target type reference.</param>
        /// <returns>If the node is successfully rewritten.</returns>
        private static bool TryRewriteIntegralConstantNode(ref SingleValueNode boundNode, IEdmTypeReference targetType)
        {
            if (targetType == null || !targetType.IsByte() && !targetType.IsSByte() && !targetType.IsInt16())
            {
                return false;
            }

            ConstantNode constantNode = boundNode as ConstantNode;
            if (constantNode == null)
            {
                return false;
            }

            IEdmTypeReference sourceType = constantNode.TypeReference;
            if (sourceType == null || !sourceType.IsInt32())
            {
                return false;
            }

            int sourceValue = (int)constantNode.Value;
            object targetValue = null;
            switch (targetType.PrimitiveKind())
            {
                case EdmPrimitiveTypeKind.Byte:
                    if (sourceValue >= byte.MinValue && sourceValue <= byte.MaxValue)
                    {
                        targetValue = (byte)sourceValue;
                    }

                    break;
                case EdmPrimitiveTypeKind.SByte:
                    if (sourceValue >= sbyte.MinValue && sourceValue <= sbyte.MaxValue)
                    {
                        targetValue = (sbyte)sourceValue;
                    }

                    break;
                case EdmPrimitiveTypeKind.Int16:
                    if (sourceValue >= short.MinValue && sourceValue <= short.MaxValue)
                    {
                        targetValue = (short)sourceValue;
                    }

                    break;
            }

            if (targetValue == null)
            {
                return false;
            }

            boundNode = new ConstantNode(targetValue, constantNode.LiteralText, targetType);
            return true;
        }

        /// <summary>
        /// This is temp work around for $filter $orderby parameter expression which contains complex or collection
        ///     like "Fully.Qualified.Namespace.CanMoveToAddresses(addresses=[{\"Street\":\"NE 24th St.\",\"City\":\"Redmond\"},{\"Street\":\"Pine St.\",\"City\":\"Seattle\"}])";
        /// TODO:  $filter $orderby parameter expression which contains nested complex or collection should NOT be supported in this way
        ///     but should be parsed into token tree, and binded to node tree: parsedParameters.Select(p => this.bindMethod(p));
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="operation">IEdmFunction or IEdmOperation</param>
        /// <param name="parameterTokens">The tokens to bind.</param>
        /// <param name="enableCaseInsensitive">Whether to enable case-insensitive when resolving parameter name.</param>
        /// <param name="enableUriTemplateParsing">Whether Uri template parsing is enabled.</param>
        /// <returns>The FunctionParameterTokens with complex or collection values converted from string like "{...}", or "[..,..,..]".</returns>
        private static ICollection<FunctionParameterToken> HandleComplexOrCollectionParameterValueIfExists(IEdmModel model, IEdmOperation operation, ICollection<FunctionParameterToken> parameterTokens, bool enableCaseInsensitive, bool enableUriTemplateParsing = false)
        {
            ICollection<FunctionParameterToken> partiallyParsedParametersWithComplexOrCollection = new Collection<FunctionParameterToken>();
            foreach (FunctionParameterToken paraToken in parameterTokens)
            {
                FunctionParameterToken funcParaToken;
                IEdmOperationParameter functionParameter = operation.FindParameter(paraToken.ParameterName);
                if (enableCaseInsensitive && functionParameter == null)
                {
                    functionParameter = ODataUriResolver.ResolveOperationParameterNameCaseInsensitive(operation, paraToken.ParameterName);

                    // The functionParameter can not be null here, else this method won't be called.
                    funcParaToken = new FunctionParameterToken(functionParameter.Name, paraToken.ValueToken);
                }
                else
                {
                    funcParaToken = paraToken;
                }

                if (funcParaToken.ValueToken is FunctionParameterAliasToken aliasToken)
                {
                    aliasToken.ExpectedParameterType = functionParameter.Type;
                }
                string valueStr = null;
                if (funcParaToken.ValueToken is LiteralToken valueToken && (valueStr = valueToken.Value as string) != null && !string.IsNullOrEmpty(valueToken.OriginalText))
                {
                    ExpressionLexer lexer = new ExpressionLexer(valueToken.OriginalText, true /*moveToFirstToken*/, false /*useSemicolonDelimiter*/, true /*parsingFunctionParameters*/);
                    if (lexer.CurrentToken.Kind == ExpressionTokenKind.BracketedExpression || lexer.CurrentToken.Kind == ExpressionTokenKind.BracedExpression)
                    {
                        object result;
                        UriTemplateExpression expression;

                        if (enableUriTemplateParsing && UriTemplateParser.TryParseLiteral(lexer.CurrentToken.Text, functionParameter.Type, out expression))
                        {
                            result = expression;
                        }
                        else if (!functionParameter.Type.IsStructured() && !functionParameter.Type.IsStructuredCollectionType())
                        {
                            // ExpressionTokenKind.BracketedExpression means text like [1,2]
                            // so now try convert it to collection type value:
                            result = ODataUriUtils.ConvertFromUriLiteral(valueStr, ODataVersion.V4, model, functionParameter.Type);
                        }
                        else
                        {
                            // For complex & colleciton of complex directly return the raw string.
                            partiallyParsedParametersWithComplexOrCollection.Add(funcParaToken);
                            continue;
                        }

                        LiteralToken newValueToken = new LiteralToken(result, valueToken.OriginalText);
                        FunctionParameterToken newFuncParaToken = new FunctionParameterToken(funcParaToken.ParameterName, newValueToken);
                        partiallyParsedParametersWithComplexOrCollection.Add(newFuncParaToken);
                        continue;
                    }
                }

                partiallyParsedParametersWithComplexOrCollection.Add(funcParaToken);
            }

            return partiallyParsedParametersWithComplexOrCollection;
        }

        /// <summary>
        /// Determines whether this is a unbound BuiltInFunction according to the configured case-sensitiveness.
        /// </summary>
        /// <param name="functionName">name of the function</param>
        /// <returns>matched unbound function names; null if no matches found.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "need to use lower characters for unbound functions.")]
        private string IsUnboundFunction(string functionName)
        {
            functionName = this.state.Configuration.EnableCaseInsensitiveUriFunctionIdentifier
                ? functionName.ToLowerInvariant()
                : functionName;
            return UnboundFunctionNames.FirstOrDefault(name => name.Equals(functionName, StringComparison.Ordinal));
        }

        /// <summary>
        /// Build a SingleValueFunctionCallNode for a function that isn't bound to a BuiltInFunction
        /// </summary>
        /// <param name="functionCallTokenName">Name for the function</param>
        /// <param name="args">list of already bound query nodes for this function</param>
        /// <returns>A single value function call node bound to this function.</returns>
        private SingleValueNode CreateUnboundFunctionNode(string functionCallTokenName, List<QueryNode> args)
        {
            // need to figure out the return type and check the correct number of arguments based on the function name
            IEdmTypeReference returnType = null;
            switch (functionCallTokenName)
            {
                case ExpressionConstants.UnboundFunctionIsOf:
                    {
                        returnType = ValidateAndBuildIsOfArgs(state, ref args);
                        break;
                    }

                case ExpressionConstants.UnboundFunctionCast:
                    {
                        returnType = ValidateAndBuildCastArgs(state, ref args);
                        if (returnType.IsStructured())
                        {

                            return new SingleResourceFunctionCallNode(functionCallTokenName, args,
                                returnType.AsStructured(), args.ElementAt(0) is SingleResourceNode entityNode ? entityNode.NavigationSource : null);
                        }

                        break;
                    }

                default:
                    {
                        break;
                    }
            }

            // we have everything else we need, so return the new SingleValueFunctionCallNode.
            return new SingleValueFunctionCallNode(functionCallTokenName, args, returnType);
        }

        /// <summary>
        /// Validate the args list (adding the implicit range variable if necessary), and determine the correct return type for a cast function
        /// </summary>
        /// <param name="state">current binding state, used to get the implicit range variable if necessary</param>
        /// <param name="args">list of arguments, could be changed</param>
        /// <returns>the return type from this cast function</returns>
        private static IEdmTypeReference ValidateAndBuildCastArgs(BindingState state, ref List<QueryNode> args)
        {
            return ValidateIsOfOrCast(state, true, ref args);
        }

        /// <summary>
        /// Validate the arguments (adding the implicit range variable if necessary), and determine the correct return type
        /// for an IsOf function
        /// </summary>
        /// <param name="state">the current state of the binding algorithm, used to get the implicit range variable if necessary</param>
        /// <param name="args">current list of args, can be changed</param>
        /// <returns>the correct return type for this function.</returns>
        private static IEdmTypeReference ValidateAndBuildIsOfArgs(BindingState state, ref List<QueryNode> args)
        {
            return ValidateIsOfOrCast(state, false, ref args);
        }

        /// <summary>
        /// Validate the arguments to either isof or cast
        /// </summary>
        /// <param name="state">the current state of the binding algorithm</param>
        /// <param name="isCast">flag to indicate which function we're validating</param>
        /// <param name="args">the list of arguments, which could be changed</param>
        /// <returns>the return type of the function.</returns>
        private static IEdmTypeReference ValidateIsOfOrCast(BindingState state, bool isCast, ref List<QueryNode> args)
        {
            if (args.Count != 1 && args.Count != 2)
            {
                throw new ODataErrorException(
                    ODataErrorStrings.MetadataBinder_CastOrIsOfExpressionWithWrongNumberOfOperands(args.Count));
            }

            IEdmTypeReference returnType = null;

            if (args.Last() is ConstantNode typeArgument)
            {
                returnType = TryGetTypeReference(state.Model, typeArgument.Value as string, state.Configuration.Resolver);
            }

            if (returnType == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfFunctionWithoutATypeArgument);
            }

            if (returnType.IsCollection())
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfCollectionsNotSupported);
            }

            // if we only have one argument, then add the implicit range variable as the first argument.
            if (args.Count == 1)
            {
                args = new List<QueryNode>()
                    {
                        new ResourceRangeVariableReferenceNode(
                                                             state.ImplicitRangeVariable.Name,
                                                             state.ImplicitRangeVariable as ResourceRangeVariable),
                        args[0]
                    };
            }
            else if (!(args[0] is SingleValueNode))
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_CastOrIsOfCollectionsNotSupported);
            }

            if (isCast && (args.Count == 2))
            {
                // throw if cast enum to not-string :
                if ((args[0].GetEdmTypeReference() is IEdmEnumTypeReference)
                    && !string.Equals(typeArgument.Value as string, Microsoft.OData.Metadata.EdmConstants.EdmStringTypeName, StringComparison.Ordinal))
                {
                    throw new ODataException(ODataErrorStrings.CastBinder_EnumOnlyCastToOrFromString);
                }

                // throw if cast not-string to enum :
                while (returnType is IEdmEnumTypeReference)
                {
                    IEdmTypeReference edmTypeReference = args[0].GetEdmTypeReference();
                    if (edmTypeReference == null)
                    {
                        // Support cast null to enum
                        break;
                    }

                    if (edmTypeReference is IEdmPrimitiveTypeReference referenceTmp)
                    {
                        if ((referenceTmp.Definition is IEdmPrimitiveType typeTmp) && (typeTmp.PrimitiveKind == EdmPrimitiveTypeKind.String))
                        {
                            break;
                        }
                    }

                    throw new ODataException(ODataErrorStrings.CastBinder_EnumOnlyCastToOrFromString);
                }
            }

            if (isCast)
            {
                return returnType;
            }
            else
            {
                return EdmCoreModel.Instance.GetBoolean(true);
            }
        }

        /// <summary>
        /// Try to get an IEdmTypeReference for a given type as a string, returns null if none exists
        /// </summary>
        /// <param name="model">the model for validation</param>
        /// <param name="fullTypeName">the type name to find</param>
        /// <param name="resolver">Resolver for this func.</param>
        /// <returns>an IEdmTypeReference for this type string.</returns>
        private static IEdmTypeReference TryGetTypeReference(IEdmModel model, string fullTypeName, ODataUriResolver resolver)
        {
            IEdmTypeReference typeReference = UriEdmHelpers.FindTypeFromModel(model, fullTypeName, resolver).ToTypeReference();
            if (typeReference == null)
            {
                if (fullTypeName.StartsWith("Collection", StringComparison.Ordinal))
                {
                    string[] tokenizedString = fullTypeName.Split('(');
                    string baseElementType = tokenizedString[1].Split(')')[0];
                    return EdmCoreModel.GetCollection(UriEdmHelpers.FindTypeFromModel(model, baseElementType, resolver).ToTypeReference());
                }
                else
                {
                    return null;
                }
            }

            return typeReference;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs(8,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs(381,43): error CS0128: A local variable or function named 'singleValueParent' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs(381,64): error CS0165: Use of unassigned local variable 'singleValueParent',D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs(761,39): error CS0165: Use of unassigned local variable 'typeArgument',D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\FunctionCallBinder.cs(8,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 21 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace Microsoft.OData.UriParser
{
    using System;
    using System.Diagnostics;
    using System.Linq;
    using Microsoft.OData.Edm;
    using Microsoft.OData;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;

    /// <summary>
    /// Helper methods for metadata binding.
    /// </summary>
    internal static class MetadataBindingUtils
    {
        /// <summary>
        /// If the source node is not of the specified type, then we check if type promotion is possible and inject a convert node.
        /// If the source node is the same type as the target type (or if the target type is null), we just return the source node as is.
        /// </summary>
        /// <param name="source">The source node to apply the conversion to.</param>
        /// <param name="targetTypeReference">The target primitive type. May be null - this method will do nothing in that case.</param>
        /// <returns>The converted query node, or the original source node unchanged.</returns>
        internal static SingleValueNode ConvertToTypeIfNeeded(SingleValueNode source, IEdmTypeReference targetTypeReference)
        {
            Debug.Assert(source != null, "source != null");

            if (targetTypeReference == null)
            {
                return source;
            }

            if (source.TypeReference != null)
            {
                if (source.TypeReference.IsEquivalentTo(targetTypeReference))
                {
                    // For source is type definition, if source's underlying type == target type.
                    // We create a conversion node from source to its underlying type (target type)
                    // so that the service can convert value of source clr type to underlying clr type.
                    if (source.TypeReference.IsTypeDefinition())
                    {
                        return new ConvertNode(source, targetTypeReference);
                    }

                    return source;
                }

                // Structured type in url will be translated into a node with raw string value.
                // We create a conversion node from string to structured type.
                if (targetTypeReference.IsStructured() || targetTypeReference.IsStructuredCollectionType())
                {
                    return new ConvertNode(source, targetTypeReference);
                }

                ConstantNode constantNode = source as ConstantNode;
                if (constantNode?.Value != null && source.TypeReference.IsString() && targetTypeReference.IsEnum())
                {
                    string memberName = constantNode.Value.ToString();
                    IEdmEnumType enumType = targetTypeReference.Definition as IEdmEnumType;
                    if (enumType.Members.Any(m => string.Compare(m.Name, memberName, StringComparison.Ordinal) == 0))
                    {
                        string literalText = ODataUriUtils.ConvertToUriLiteral(constantNode.Value, default(ODataVersion));
                        return new ConstantNode(new ODataEnumValue(constantNode.Value.ToString(), targetTypeReference.Definition.ToString()), literalText, targetTypeReference);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.Binder_IsNotValidEnumConstant(memberName));
                    }
                }

                if (!TypePromotionUtils.CanConvertTo(source, source.TypeReference, targetTypeReference))
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_CannotConvertToType(source.TypeReference.FullName(), targetTypeReference.FullName()));
                }
                else
                {
                    if (source.TypeReference.IsEnum() && constantNode != null)
                    {
                        return new ConstantNode(constantNode.Value, ODataUriUtils.ConvertToUriLiteral(constantNode.Value, ODataVersion.V4), targetTypeReference);
                    }

                    object originalPrimitiveValue;
                    if (MetadataUtilsCommon.TryGetConstantNodePrimitiveLDMF(source, out originalPrimitiveValue) && (originalPrimitiveValue != null))
                    {
                        // L F D M types : directly create a ConvertNode.
                        // 1. NodeToExpressionTranslator.cs won't allow implicitly converting single/double to decimal, which should be done here at Node tree level.
                        // 2. And prevent losing precision in float -> double, e.g. (double)1.234f => 1.2339999675750732d not 1.234d
                        object targetPrimitiveValue = ODataUriConversionUtils.CoerceNumericType(originalPrimitiveValue, targetTypeReference.AsPrimitive().Definition as IEdmPrimitiveType);

                        if (string.IsNullOrEmpty(constantNode.LiteralText))
                        {
                            return new ConstantNode(targetPrimitiveValue);
                        }

                        var candidate = new ConstantNode(targetPrimitiveValue, constantNode.LiteralText);
                        var decimalType = candidate.TypeReference as IEdmDecimalTypeReference;
                        if (decimalType != null)
                        {
                            var targetDecimalType = (IEdmDecimalTypeReference)targetTypeReference;
                            return decimalType.Precision == targetDecimalType.Precision &&
                                   decimalType.Scale == targetDecimalType.Scale ?
                                   (SingleValueNode)candidate :
                                   (SingleValueNode)(new ConvertNode(candidate, targetTypeReference));
                        }
                        else
                        {
                            return candidate;
                        }
                    }
                    else
                    {
                        // other type conversion : ConvertNode
                        return new ConvertNode(source, targetTypeReference);
                    }
                }
            }
            else
            {
                // If the source doesn't have a type (possibly an open property), then it's possible to convert it
                // cause we don't know for sure.
                return new ConvertNode(source, targetTypeReference);
            }
        }

        /// <summary>
        /// Retrieves type associated to a segment.
        /// </summary>
        /// <param name="segment">The node to retrieve the type from.</param>
        /// <returns>The type of the node, or item type for collections.</returns>
        internal static IEdmType GetEdmType(this QueryNode segment)
        {
            SingleValueNode singleNode = segment as SingleValueNode;

            if (singleNode != null)
            {
                IEdmTypeReference typeRef = singleNode.TypeReference;
                return (typeRef != null) ? typeRef.Definition : null;
            }

            CollectionNode collectionNode = segment as CollectionNode;

            if (collectionNode != null)
            {
                IEdmTypeReference typeRef = collectionNode.ItemType;
                return (typeRef != null) ? typeRef.Definition : null;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the type reference associated to a segment.
        /// </summary>
        /// <param name="segment">The node to retrieve the type reference from.</param>
        /// <returns>The Type reference of the node (item type reference for collections).</returns>
        internal static IEdmTypeReference GetEdmTypeReference(this QueryNode segment)
        {
            SingleValueNode singleNode = segment as SingleValueNode;

            if (singleNode != null)
            {
                return singleNode.TypeReference;
            }

            CollectionNode collectionNode = segment as CollectionNode;

            if (collectionNode != null)
            {
                return collectionNode.ItemType;
            }

            return null;
        }
    }
}
---- Transformed Tree ----
namespace Microsoft.OData.UriParser
{
    using System;
    using System.Diagnostics;
    using System.Linq;
    using Microsoft.OData.Edm;
    using Microsoft.OData;
    using Microsoft.OData.Metadata;
    using ODataErrorStrings = Microsoft.OData.Strings;

    /// <summary>
    /// Helper methods for metadata binding.
    /// </summary>
    internal static class MetadataBindingUtils
    {
        /// <summary>
        /// If the source node is not of the specified type, then we check if type promotion is possible and inject a convert node.
        /// If the source node is the same type as the target type (or if the target type is null), we just return the source node as is.
        /// </summary>
        /// <param name="source">The source node to apply the conversion to.</param>
        /// <param name="targetTypeReference">The target primitive type. May be null - this method will do nothing in that case.</param>
        /// <returns>The converted query node, or the original source node unchanged.</returns>
        internal static SingleValueNode ConvertToTypeIfNeeded(SingleValueNode source, IEdmTypeReference targetTypeReference)
        {
            Debug.Assert(source != null, "source != null");

            if (targetTypeReference == null)
            {
                return source;
            }

            if (source.TypeReference != null)
            {
                if (source.TypeReference.IsEquivalentTo(targetTypeReference))
                {
                    // For source is type definition, if source's underlying type == target type.
                    // We create a conversion node from source to its underlying type (target type)
                    // so that the service can convert value of source clr type to underlying clr type.
                    if (source.TypeReference.IsTypeDefinition())
                    {
                        return new ConvertNode(source, targetTypeReference);
                    }

                    return source;
                }

                // Structured type in url will be translated into a node with raw string value.
                // We create a conversion node from string to structured type.
                if (targetTypeReference.IsStructured() || targetTypeReference.IsStructuredCollectionType())
                {
                    return new ConvertNode(source, targetTypeReference);
                }
                if (constantNode?.Value != null && source.TypeReference.IsString() && targetTypeReference.IsEnum())
                {
                    string memberName = constantNode.Value.ToString();
                    IEdmEnumType enumType = targetTypeReference.Definition as IEdmEnumType;
                    if (enumType.Members.Any(m => string.Compare(m.Name, memberName, StringComparison.Ordinal) == 0))
                    {
                        string literalText = ODataUriUtils.ConvertToUriLiteral(constantNode.Value, default(ODataVersion));
                        return new ConstantNode(new ODataEnumValue(constantNode.Value.ToString(), targetTypeReference.Definition.ToString()), literalText, targetTypeReference);
                    }
                    else
                    {
                        throw new ODataException(ODataErrorStrings.Binder_IsNotValidEnumConstant(memberName));
                    }
                }

                if (!TypePromotionUtils.CanConvertTo(source, source.TypeReference, targetTypeReference))
                {
                    throw new ODataException(ODataErrorStrings.MetadataBinder_CannotConvertToType(source.TypeReference.FullName(), targetTypeReference.FullName()));
                }
                else
                {
                    if (source.TypeReference.IsEnum() && source is ConstantNode constantNode)
                    {
                        return new ConstantNode(constantNode.Value, ODataUriUtils.ConvertToUriLiteral(constantNode.Value, ODataVersion.V4), targetTypeReference);
                    }

                    object originalPrimitiveValue;
                    if (MetadataUtilsCommon.TryGetConstantNodePrimitiveLDMF(source, out originalPrimitiveValue) && (originalPrimitiveValue != null))
                    {
                        // L F D M types : directly create a ConvertNode.
                        // 1. NodeToExpressionTranslator.cs won't allow implicitly converting single/double to decimal, which should be done here at Node tree level.
                        // 2. And prevent losing precision in float -> double, e.g. (double)1.234f => 1.2339999675750732d not 1.234d
                        object targetPrimitiveValue = ODataUriConversionUtils.CoerceNumericType(originalPrimitiveValue, targetTypeReference.AsPrimitive().Definition as IEdmPrimitiveType);

                        if (string.IsNullOrEmpty(constantNode.LiteralText))
                        {
                            return new ConstantNode(targetPrimitiveValue);
                        }

                        var candidate = new ConstantNode(targetPrimitiveValue, constantNode.LiteralText);

                        if (candidate.TypeReference is IEdmDecimalTypeReference decimalType)
                        {
                            var targetDecimalType = (IEdmDecimalTypeReference)targetTypeReference;
                            return decimalType.Precision == targetDecimalType.Precision &&
                                   decimalType.Scale == targetDecimalType.Scale ?
                                   (SingleValueNode)candidate :
                                   (SingleValueNode)(new ConvertNode(candidate, targetTypeReference));
                        }
                        else
                        {
                            return candidate;
                        }
                    }
                    else
                    {
                        // other type conversion : ConvertNode
                        return new ConvertNode(source, targetTypeReference);
                    }
                }
            }
            else
            {
                // If the source doesn't have a type (possibly an open property), then it's possible to convert it
                // cause we don't know for sure.
                return new ConvertNode(source, targetTypeReference);
            }
        }

        /// <summary>
        /// Retrieves type associated to a segment.
        /// </summary>
        /// <param name="segment">The node to retrieve the type from.</param>
        /// <returns>The type of the node, or item type for collections.</returns>
        internal static IEdmType GetEdmType(this QueryNode segment)
        {
            if (segment is SingleValueNode singleNode)
            {
                IEdmTypeReference typeRef = singleNode.TypeReference;
                return (typeRef != null) ? typeRef.Definition : null;
            }

            if (segment is CollectionNode collectionNode)
            {
                IEdmTypeReference typeRef = collectionNode.ItemType;
                return (typeRef != null) ? typeRef.Definition : null;
            }

            return null;
        }

        /// <summary>
        /// Retrieves the type reference associated to a segment.
        /// </summary>
        /// <param name="segment">The node to retrieve the type reference from.</param>
        /// <returns>The Type reference of the node (item type reference for collections).</returns>
        internal static IEdmTypeReference GetEdmTypeReference(this QueryNode segment)
        {
            if (segment is SingleValueNode singleNode)
            {
                return singleNode.TypeReference;
            }

            if (segment is CollectionNode collectionNode)
            {
                return collectionNode.ItemType;
            }

            return null;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs(59,21): error CS0103: The name 'constantNode' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs(61,41): error CS0103: The name 'constantNode' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs(65,80): error CS0103: The name 'constantNode' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs(66,68): error CS0103: The name 'constantNode' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\MetadataBindingUtils.cs(93,50): error CS0165: Use of unassigned local variable 'constantNode'
######################################################################


######################################################################
Nr: 22 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectExpandBinder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.OData.Metadata;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser.Aggregation;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// ExpandOption variant of an SelectExpandBinder, where the default selection item for a given level is based on the select at that level
    /// instead of the top level select clause. If nothing is selected for a given expand in the ExpandOption syntax, then we by default
    /// select all from that item, instead of selecting nothing (and therefore pruning the expand off of the tree).
    /// </summary>
    internal sealed class SelectExpandBinder
    {
        /// <summary>
        /// The configuration used for binding.
        /// </summary>
        private readonly ODataUriParserConfiguration configuration;

        /// <summary>
        /// The navigation source at the current level expand.
        /// </summary>
        private readonly IEdmNavigationSource navigationSource;

        /// <summary>
        /// The navigation source at the resource path.
        /// </summary>
        private readonly IEdmNavigationSource resourcePathNavigationSource;

        /// <summary>
        /// The entity type at the current level expand.
        /// </summary>
        private readonly IEdmStructuredType edmType;

        /// <summary>
        /// The segments parsed in path and query option.
        /// </summary>
        private List<ODataPathSegment> parsedSegments = new List<ODataPathSegment>();

        private BindingState state;

        public SelectExpandBinder(ODataUriParserConfiguration configuration, ODataPathInfo odataPathInfo, BindingState state)
        {
            ExceptionUtils.CheckArgumentNotNull(configuration, "configuration");
            ExceptionUtils.CheckArgumentNotNull(odataPathInfo.TargetStructuredType, "edmType");

            this.configuration = configuration;
            this.edmType = odataPathInfo.TargetStructuredType;
            this.navigationSource = odataPathInfo.TargetNavigationSource;
            this.parsedSegments = odataPathInfo.Segments.ToList();
            this.state = state;

            if (this.state != null)
            {
                this.resourcePathNavigationSource = this.state.ResourcePathNavigationSource;
            }
            else
            {
                this.resourcePathNavigationSource = odataPathInfo.TargetNavigationSource;
            }
        }

        /// <summary>
        /// The model used for binding.
        /// </summary>
        public IEdmModel Model
        {
            get { return this.configuration.Model; }
        }

        /// <summary>
        /// The top level type.
        /// </summary>
        public IEdmStructuredType EdmType
        {
            get { return this.edmType; }
        }

        /// <summary>
        /// The top level navigation source for this level.
        /// </summary>
        public IEdmNavigationSource NavigationSource
        {
            get { return this.navigationSource; }
        }

        /// <summary>
        /// The navigation source at the resource path.
        /// </summary>
        public IEdmNavigationSource ResourcePathNavigationSource
        {
            get { return this.resourcePathNavigationSource; }
        }

        /// <summary>
        /// The settings to use when binding.
        /// </summary>
        private ODataUriParserSettings Settings
        {
            get
            {
                return this.configuration.Settings;
            }
        }

        /// <summary>
        /// The configuration used for binding.
        /// </summary>
        private ODataUriParserConfiguration Configuration
        {
            get
            {
                return this.configuration;
            }
        }

        /// <summary>
        /// Bind the $expand <see cref="ExpandToken"/> and $select <see cref="SelectToken"/> at this level.
        /// </summary>
        /// <param name="expandToken">the expand token to visit.</param>
        /// <param name="selectToken">the select token to visit.</param>
        /// <returns>a SelectExpand clause based on <see cref="ExpandToken"/> and <see cref="SelectToken"/>.</returns>
        public SelectExpandClause Bind(ExpandToken expandToken, SelectToken selectToken)
        {
            List<SelectItem> selectExpandItems = new List<SelectItem>();

            // $expand=
            if (expandToken != null && expandToken.ExpandTerms.Any())
            {
                selectExpandItems.AddRange(expandToken.ExpandTerms.Select(this.GenerateExpandItem).Where(s => s != null));
            }

            // $select=
            bool isAllSelected = true;
            if (selectToken != null && selectToken.SelectTerms.Any())
            {
                // if there are any select items at this level then allSelected is false, otherwise it's true.
                isAllSelected = false;

                foreach (SelectTermToken selectTermToken in selectToken.SelectTerms)
                {
                    SelectItem selectItem = GenerateSelectItem(selectTermToken);
                    PathSelectItem selectPathItem = selectItem as PathSelectItem;
                    bool duplicate = false;

                    if (selectPathItem != null)
                    {
                        // It's not allowed to have multiple select clause with the same path.
                        // For example: $select=abc($top=2),abc($skip=2) is not allowed by design.
                        // Customer should combine them together, for example: $select=abc($top=2;$skip=2).
                        // The logic is different with ExpandTreeNormalizer. We should change the logic in ExpandTreeNormalizer
                        // in next breaking change version.
                        // For backward compatibility with previous versions of OData Library, we only validate
                        // if one of the select items has options.
                        foreach (PathSelectItem existingItem in selectExpandItems.OfType<PathSelectItem>())
                        {
                            if ((selectPathItem.HasOptions && OverLaps(selectPathItem, existingItem)) || (existingItem.HasOptions && OverLaps(existingItem, selectPathItem)))
                            {
                                throw new ODataException(ODataErrorStrings.SelectTreeNormalizer_MultipleSelecTermWithSamePathFound(ToPathString(selectTermToken.PathToProperty)));
                            }

                            // two items without options are identical -- for backward compat just ignore the new one
                            if (selectPathItem.SelectedPath.Equals(existingItem.SelectedPath))
                            {
                                duplicate = true;
                            }
                        }
                    }

                    if (!duplicate)
                    {
                        AddToSelectedItems(selectItem, selectExpandItems);
                    }
                }
            }

            // It's better to return "null" if both expand and select are null.
            // However, in order to be consistent, we returns empty "SelectExpandClause" with AllSelected = true.
            return new SelectExpandClause(selectExpandItems, isAllSelected);
        }

        /// <summary>
        /// Get the path string for a path segment token.
        /// </summary>
        /// <param name="head">The head of the path</param>
        /// <returns>The path string.</returns>
        internal static string ToPathString(PathSegmentToken head)
        {
            StringBuilder sb = new StringBuilder();
            PathSegmentToken curr = head;
            while (curr != null)
            {
                sb.Append(curr.Identifier);

                NonSystemToken nonSystem = curr as NonSystemToken;
                if (nonSystem?.NamedValues != null)
                {
                    sb.Append("(");
                    bool first = true;
                    foreach (var item in nonSystem.NamedValues)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else
                        {
                            sb.Append(",");
                        }

                        sb.Append(item.Name).Append("=").Append(item.Value.Value);
                    }

                    sb.Append(")");
                }

                curr = curr.NextToken;
                if (curr != null)
                {
                    sb.Append("/");
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Determines whether the first path is entirely contained in the second path.
        /// </summary>
        /// <param name="firstPath">First path item</param>
        /// <param name="secondPath">Second path item</param>
        /// <returns>The boolean value.</returns>
        private static bool OverLaps(PathSelectItem firstPath, PathSelectItem secondPath)
        {
            IEnumerator<ODataPathSegment> first = firstPath.SelectedPath.GetEnumerator();
            IEnumerator<ODataPathSegment> second = secondPath.SelectedPath.GetEnumerator();

            bool completed;
            while ((completed = first.MoveNext()) && second.MoveNext() && first.Current.Identifier == second.Current.Identifier)
            {
            }

            return !completed;
        }

        /// <summary>
        /// Generate a select item <see cref="SelectItem"/> based on a <see cref="SelectTermToken"/>.
        /// for example:  abc/efg($count=true;$filter=....;$top=1)
        /// </summary>
        /// <param name="tokenIn">the select term token to visit</param>
        /// <returns>the select item for this select term token.</returns>
        private SelectItem GenerateSelectItem(SelectTermToken tokenIn)
        {
            ExceptionUtils.CheckArgumentNotNull(tokenIn, "tokenIn");
            ExceptionUtils.CheckArgumentNotNull(tokenIn.PathToProperty, "pathToProperty");

            VerifySelectedPath(tokenIn);

            SelectItem newSelectItem;
            if (ProcessWildcardTokenPath(tokenIn, out newSelectItem))
            {
                return newSelectItem;
            }

            IList<ODataPathSegment> selectedPath = ProcessSelectTokenPath(tokenIn.PathToProperty);
            Debug.Assert(selectedPath.Count > 0);

            // Navigation property should be the last segment in select path.
            if (VerifySelectedNavigationProperty(selectedPath, tokenIn))
            {
                return new PathSelectItem(new ODataSelectPath(selectedPath));
            }

            // We should use the "NavigationSource" at this level for the next level binding.
            IEdmNavigationSource targetNavigationSource = this.NavigationSource;
            ODataPathSegment lastSegment = selectedPath.Last();
            IEdmType targetElementType = lastSegment.TargetEdmType;
            IEdmCollectionType collection = targetElementType as IEdmCollectionType;
            if (collection != null)
            {
                targetElementType = collection.ElementType.Definition;
            }

            IEdmTypeReference elementTypeReference = targetElementType.ToTypeReference();

            // $compute
            ComputeClause compute = BindCompute(tokenIn.ComputeOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference);
            HashSet<EndPathToken> generatedProperties = GetGeneratedProperties(compute, null);

            // $filter
            FilterClause filter = BindFilter(tokenIn.FilterOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            // $orderby
            OrderByClause orderBy = BindOrderby(tokenIn.OrderByOptions, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            // $search
            SearchClause search = BindSearch(tokenIn.SearchOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference);

            // $select
            List<ODataPathSegment> parsedPath = new List<ODataPathSegment>(this.parsedSegments);
            parsedPath.AddRange(selectedPath);
            SelectExpandClause selectExpand = BindSelectExpand(null, tokenIn.SelectOption, parsedPath, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            return new PathSelectItem(new ODataSelectPath(selectedPath),
                targetNavigationSource,
                selectExpand,
                filter,
                orderBy,
                tokenIn.TopOption,
                tokenIn.SkipOption,
                tokenIn.CountQueryOption,
                search,
                compute);
        }

        /// <summary>
        /// Generate an expand item (and a select item for the implicit nav prop if necessary) based on an ExpandTermToken
        /// </summary>
        /// <param name="tokenIn">the expandTerm token to visit</param>
        /// <returns>the expand item for this expand term token.</returns>
        private SelectItem GenerateExpandItem(ExpandTermToken tokenIn)
        {
            ExceptionUtils.CheckArgumentNotNull(tokenIn, "tokenIn");

            PathSegmentToken currentToken = tokenIn.PathToNavigationProp;

            IEdmStructuredType currentLevelEntityType = this.EdmType;
            List<ODataPathSegment> pathSoFar = new List<ODataPathSegment>();
            PathSegmentToken firstNonTypeToken = currentToken;

            if (currentToken.IsNamespaceOrContainerQualified())
            {
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(currentToken, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentLevelEntityType, out firstNonTypeToken));
            }

            IEdmProperty edmProperty = this.configuration.Resolver.ResolveProperty(currentLevelEntityType, firstNonTypeToken.Identifier);
            if (edmProperty == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_PropertyNotDeclared(currentLevelEntityType.FullTypeName(), currentToken.Identifier));
            }

            IEdmNavigationProperty currentNavProp = edmProperty as IEdmNavigationProperty;
            IEdmStructuralProperty currentComplexProp = edmProperty as IEdmStructuralProperty;
            if (currentNavProp == null && currentComplexProp == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, currentLevelEntityType.FullTypeName()));
            }

            if (currentComplexProp != null)
            {
                currentNavProp = ParseComplexTypesBeforeNavigation(currentComplexProp, ref firstNonTypeToken, pathSoFar);
            }

            // ensure that we're always dealing with proper V4 syntax
            if (firstNonTypeToken.NextToken != null && firstNonTypeToken.NextToken.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_TraversingMultipleNavPropsInTheSamePath);
            }

            bool isRef = false;
            if (firstNonTypeToken.NextToken != null)
            {
                // lastly... make sure that, since we're on a NavProp, that the next token isn't null.
                if (firstNonTypeToken.NextToken.Identifier == UriQueryConstants.RefSegment)
                {
                    isRef = true;
                }
                else
                {
                    throw new ODataException(ODataErrorStrings.ExpandItemBinder_TraversingMultipleNavPropsInTheSamePath);
                }
            }

            // Add the segments in select and expand to parsed segments
            List<ODataPathSegment> parsedPath = new List<ODataPathSegment>(this.parsedSegments);
            parsedPath.AddRange(pathSoFar);

            IEdmNavigationSource targetNavigationSource = null;
            if (this.NavigationSource != null)
            {
                IEdmPathExpression bindingPath;
                targetNavigationSource = this.NavigationSource.FindNavigationTarget(currentNavProp, BindingPathHelper.MatchBindingPath, parsedPath, out bindingPath);
            }

            NavigationPropertySegment navSegment = new NavigationPropertySegment(currentNavProp, targetNavigationSource);
            pathSoFar.Add(navSegment);
            parsedPath.Add(navSegment); // Add the navigation property segment to parsed segments for future usage.
            ODataExpandPath pathToNavProp = new ODataExpandPath(pathSoFar);

            // $apply
            ApplyClause applyOption = BindApply(tokenIn.ApplyOptions, this.ResourcePathNavigationSource, targetNavigationSource);

            // $compute
            ComputeClause computeOption = BindCompute(tokenIn.ComputeOption, this.ResourcePathNavigationSource, targetNavigationSource);

            var generatedProperties = GetGeneratedProperties(computeOption, applyOption);
            bool collapsed = applyOption?.Transformations.Any(t => t.Kind == TransformationNodeKind.Aggregate || t.Kind == TransformationNodeKind.GroupBy) ?? false;

            // $filter
            FilterClause filterOption = BindFilter(tokenIn.FilterOption, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $orderby
            OrderByClause orderbyOption = BindOrderby(tokenIn.OrderByOptions, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $search
            SearchClause searchOption = BindSearch(tokenIn.SearchOption, this.ResourcePathNavigationSource, targetNavigationSource, null);

            if (isRef)
            {
                return new ExpandedReferenceSelectItem(pathToNavProp, targetNavigationSource, filterOption, orderbyOption, tokenIn.TopOption, tokenIn.SkipOption, tokenIn.CountQueryOption, searchOption, computeOption, applyOption);
            }

            // $select & $expand
            SelectExpandClause subSelectExpand = BindSelectExpand(tokenIn.ExpandOption, tokenIn.SelectOption, parsedPath, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $levels
            LevelsClause levelsOption = ParseLevels(tokenIn.LevelsOption, currentLevelEntityType, currentNavProp);

            return new ExpandedNavigationSelectItem(pathToNavProp,
                targetNavigationSource, subSelectExpand, filterOption, orderbyOption, tokenIn.TopOption, tokenIn.SkipOption, tokenIn.CountQueryOption, searchOption, levelsOption, computeOption, applyOption);
        }

        /// <summary>
        /// Bind the apply clause <see cref="ApplyClause"/> at this level.
        /// </summary>
        /// <param name="applyToken">The apply tokens to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <returns>The null or the built apply clause.</returns>
        private ApplyClause BindApply(IEnumerable<QueryToken> applyToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource)
        {
            if (applyToken != null && applyToken.Any())
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, null);
                ApplyBinder applyBinder = new ApplyBinder(binder.Bind, binder.BindingState);
                return applyBinder.BindApply(applyToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the compute clause <see cref="ComputeToken"/> at this level.
        /// </summary>
        /// <param name="computeToken">The compute token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The target element type.</param>
        /// <returns>The null or the built compute clause.</returns>
        private ComputeClause BindCompute(ComputeToken computeToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType = null)
        {
            if (computeToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType);
                ComputeBinder computeBinder = new ComputeBinder(binder.Bind);
                return computeBinder.BindCompute(computeToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the filter clause <see cref="FilterClause"/> at this level.
        /// </summary>
        /// <param name="filterToken">The filter token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built filter clause.</returns>
        private FilterClause BindFilter(QueryToken filterToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties, bool collapsed = false)
        {
            if (filterToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
                FilterBinder filterBinder = new FilterBinder(binder.Bind, binder.BindingState);
                return filterBinder.BindFilter(filterToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the orderby clause <see cref="OrderByClause"/> at this level.
        /// </summary>
        /// <param name="orderByToken">The orderby token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built filter clause.</returns>
        /// <returns>The null or the built orderby clause.</returns>
        private OrderByClause BindOrderby(IEnumerable<OrderByToken> orderByToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties, bool collapsed = false)
        {
            if (orderByToken != null && orderByToken.Any())
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
                OrderByBinder orderByBinder = new OrderByBinder(binder.Bind);
                return orderByBinder.BindOrderBy(binder.BindingState, orderByToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the search clause <see cref="SearchClause"/> at this level.
        /// </summary>
        /// <param name="searchToken">The search token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <returns>The null or the built search clause.</returns>
        private SearchClause BindSearch(QueryToken searchToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType)
        {
            if (searchToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType);
                SearchBinder searchBinder = new SearchBinder(binder.Bind);
                return searchBinder.BindSearch(searchToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the select and expand clause <see cref="SelectExpandClause"/> at this level.
        /// </summary>
        /// <param name="expandToken">The expand token to visit.</param>
        /// <param name="selectToken">The select token to visit.</param>
        /// <param name="segments">The parsed segments to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built select and expand clause.</returns>
        private SelectExpandClause BindSelectExpand(ExpandToken expandToken, SelectToken selectToken,
            IList<ODataPathSegment> segments, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType,
            HashSet<EndPathToken> generatedProperties = null, bool collapsed = false)
        {
            if (expandToken != null || selectToken != null)
            {
                BindingState binding = CreateBindingState(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);

                SelectExpandBinder selectExpandBinder = new SelectExpandBinder(this.Configuration,
                new ODataPathInfo(new ODataPath(segments)), binding);

                return selectExpandBinder.Bind(expandToken, selectToken);
            }
            else
            {
                // It's better to return null for both Expand and Select are null.
                // However, in order to be consistent, we returns the empty SelectExpandClause with AllSelected = true.
                return new SelectExpandClause(new Collection<SelectItem>(), true);
            }
        }

        /// <summary>
        /// Process a <see cref="SelectTermToken"/> to identify whether it's a Wildcard path.
        /// </summary>
        /// <param name="selectToken">the select token to process.</param>
        /// <param name="newSelectItem">the built select item to out.</param>
        /// <returns>A boolean value indicates the result of processing wildcard token path.</returns>
        private bool ProcessWildcardTokenPath(SelectTermToken selectToken, out SelectItem newSelectItem)
        {
            newSelectItem = null;
            if (selectToken == null || selectToken.PathToProperty == null)
            {
                return false;
            }

            PathSegmentToken pathToken = selectToken.PathToProperty;
            if (SelectPathSegmentTokenBinder.TryBindAsWildcard(pathToken, this.Model, out newSelectItem))
            {
                // * or Namespace.*
                if (pathToken.NextToken != null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_InvalidIdentifierAfterWildcard(pathToken.NextToken.Identifier));
                }

                VerifyNoQueryOptionsNested(selectToken, pathToken.Identifier);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Process a <see cref="PathSegmentToken"/> following any type segments if necessary.
        /// </summary>
        /// <param name="tokenIn">the path token to process.</param>
        /// <returns>The processed OData segments.</returns>
        private List<ODataPathSegment> ProcessSelectTokenPath(PathSegmentToken tokenIn)
        {
            Debug.Assert(tokenIn != null, "tokenIn != null");

            List<ODataPathSegment> pathSoFar = new List<ODataPathSegment>();
            IEdmStructuredType currentLevelType = this.edmType;

            // first, walk through all type segments in a row, converting them from tokens into segments.
            if (tokenIn.IsNamespaceOrContainerQualified() && !UriParserHelper.IsAnnotation(tokenIn.Identifier))
            {
                PathSegmentToken firstNonTypeToken;
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(tokenIn, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentLevelType, out firstNonTypeToken));
                Debug.Assert(firstNonTypeToken != null, "Did not get last token.");
                tokenIn = firstNonTypeToken as NonSystemToken;
                if (tokenIn == null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_SystemTokenInSelect(firstNonTypeToken.Identifier));
                }
            }

            // next, create a segment for the first non-type segment in the path.
            ODataPathSegment lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(tokenIn, this.Model, currentLevelType, this.configuration.Resolver, this.state);

            // next, create an ODataPath and add the segments to it.
            if (lastSegment != null)
            {
                pathSoFar.Add(lastSegment);

                // try create a complex type property path.
                while (true)
                {
                    // no need to go on if the current property is not of complex type or collection of complex type,
                    // unless the segment is a primitive type cast or a property on an open complex property.
                    currentLevelType = lastSegment.EdmType as IEdmStructuredType;
                    IEdmCollectionType collectionType = lastSegment.EdmType as IEdmCollectionType;
                    IEdmPrimitiveType primitiveType = lastSegment.EdmType as IEdmPrimitiveType;
                    DynamicPathSegment dynamicPath = lastSegment as DynamicPathSegment;
                    if ((currentLevelType == null || currentLevelType.TypeKind != EdmTypeKind.Complex)
                        && (collectionType == null || collectionType.ElementType.TypeKind() != EdmTypeKind.Complex)
                        && (primitiveType == null || primitiveType.TypeKind != EdmTypeKind.Primitive)
                        && (dynamicPath == null || tokenIn.NextToken == null))
                    {
                        break;
                    }

                    NonSystemToken nextToken = tokenIn.NextToken as NonSystemToken;
                    if (nextToken == null)
                    {
                        break;
                    }

                    if (UriParserHelper.IsAnnotation(nextToken.Identifier))
                    {
                        lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(nextToken, this.Model,
                            currentLevelType, this.configuration.Resolver, null);
                    }
                    else if (primitiveType == null && dynamicPath == null)
                    {
                        // This means last segment a collection of complex type,
                        // current segment can only be type cast and cannot be property name.
                        if (currentLevelType == null)
                        {
                            currentLevelType = collectionType.ElementType.Definition as IEdmStructuredType;
                        }

                        // If there is no collection type in the path yet, will try to bind property for the next token
                        // first try bind the segment as property.
                        lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(nextToken, this.Model,
                            currentLevelType, this.configuration.Resolver, null);
                    }
                    else
                    {
                        // determine whether we are looking at a type cast or a dynamic path segment.
                        EdmPrimitiveTypeKind nextTypeKind = EdmCoreModel.Instance.GetPrimitiveTypeKind(nextToken.Identifier);
                        IEdmPrimitiveType castType = EdmCoreModel.Instance.GetPrimitiveType(nextTypeKind);
                        if (castType != null)
                        {
                            lastSegment = new TypeSegment(castType, castType, null);
                        }
                        else if (dynamicPath != null)
                        {
                            lastSegment = new DynamicPathSegment(nextToken.Identifier);
                        }
                        else
                        {
                            throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
                        }
                    }

                    // then try bind the segment as type cast.
                    if (lastSegment == null)
                    {
                        IEdmStructuredType typeFromNextToken =
                            UriEdmHelpers.FindTypeFromModel(this.Model, nextToken.Identifier, this.configuration.Resolver) as
                                IEdmStructuredType;

                        if (typeFromNextToken.IsOrInheritsFrom(currentLevelType))
                        {
                            lastSegment = new TypeSegment(typeFromNextToken, /*entitySet*/null);
                        }
                    }

                    // type cast failed too.
                    if (lastSegment == null)
                    {
                        break;
                    }

                    // try move to and add next path segment.
                    tokenIn = nextToken;
                    pathSoFar.Add(lastSegment);
                }
            }

            // non-navigation cases do not allow further segments in $select.
            if (tokenIn.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
            }

            // Later, we can consider to create a "DynamicOperationSegment" to handle this.
            // But now, Let's throw exception.
            if (lastSegment == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_InvalidIdentifierInQueryOption(tokenIn.Identifier));
            }

            // navigation property is not allowed to append sub path in the selection.
            NavigationPropertySegment navPropSegment = pathSoFar.LastOrDefault() as NavigationPropertySegment;
            if (navPropSegment != null && tokenIn.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
            }

            return pathSoFar;
        }

        private static HashSet<EndPathToken> GetGeneratedProperties(ComputeClause computeOption, ApplyClause applyOption)
        {
            HashSet<EndPathToken> generatedProperties = null;

            if (applyOption != null)
            {
                generatedProperties = applyOption.GetLastAggregatedPropertyNames();
            }

            if (computeOption != null)
            {
                var computedProperties = new HashSet<EndPathToken>(computeOption.ComputedItems.Select(i => new EndPathToken(i.Alias, null)));
                if (generatedProperties == null)
                {
                    generatedProperties = computedProperties;
                }
                else
                {
                    generatedProperties.UnionWith(computedProperties);
                }
            }

            return generatedProperties;
        }

        private IEdmNavigationProperty ParseComplexTypesBeforeNavigation(IEdmStructuralProperty edmProperty, ref PathSegmentToken currentToken, List<ODataPathSegment> pathSoFar)
        {
            pathSoFar.Add(new PropertySegment(edmProperty));

            if (currentToken.NextToken == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, edmProperty.DeclaringType.FullTypeName()));
            }

            currentToken = currentToken.NextToken;

            IEdmType complexType = edmProperty.Type.Definition;

            IEdmCollectionType collectionType = complexType as IEdmCollectionType;
            if (collectionType != null)
            {
                complexType = collectionType.ElementType.Definition;
            }

            IEdmStructuredType currentType = complexType as IEdmStructuredType;
            if (currentType == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_InvaidSegmentInExpand(currentToken.Identifier));
            }

            if (currentToken.IsNamespaceOrContainerQualified())
            {
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(currentToken, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentType, out currentToken));
            }

            IEdmProperty property = this.configuration.Resolver.ResolveProperty(currentType, currentToken.Identifier);
            if (edmProperty == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_PropertyNotDeclared(currentType.FullTypeName(), currentToken.Identifier));
            }

            IEdmStructuralProperty complexProp = property as IEdmStructuralProperty;
            if (complexProp != null)
            {
                property = ParseComplexTypesBeforeNavigation(complexProp, ref currentToken, pathSoFar);
            }

            IEdmNavigationProperty navProp = property as IEdmNavigationProperty;
            if (navProp != null)
            {
                return navProp;
            }
            else
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, currentType.FullTypeName()));
            }
        }

        /// <summary>
        /// Parse from levelsOption token to LevelsClause.
        /// Negative value would be treated as max.
        /// </summary>
        /// <param name="levelsOption">The levelsOption for current expand.</param>
        /// <param name="sourceType">The type of current level navigation source.</param>
        /// <param name="property">Navigation property for current expand.</param>
        /// <returns>The LevelsClause parsed, null if levelsOption is null</returns>
        private static LevelsClause ParseLevels(long? levelsOption, IEdmType sourceType, IEdmNavigationProperty property)
        {
            if (!levelsOption.HasValue)
            {
                return null;
            }

            IEdmType relatedType = property.ToEntityType();

            if (sourceType != null && relatedType != null && !UriEdmHelpers.IsRelatedTo(sourceType, relatedType))
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_LevelsNotAllowedOnIncompatibleRelatedType(property.Name, relatedType.FullTypeName(), sourceType.FullTypeName()));
            }

            return new LevelsClause(levelsOption.Value < 0, levelsOption.Value);
        }

        private static MetadataBinder BuildNewMetadataBinder(ODataUriParserConfiguration config,
            IEdmNavigationSource resourcePathNavigationSource,
            IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType,
            HashSet<EndPathToken> generatedProperties = null,
            bool collapsed = false)
        {
            BindingState state = CreateBindingState(config, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
            return new MetadataBinder(state);
        }

        private static BindingState CreateBindingState(ODataUriParserConfiguration config,
            IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties = null,
            bool collapsed = false)
        {
            if (targetNavigationSource == null && elementType == null)
            {
                return null;
            }

            // For example if we have https://url/Books?$expand=Authors($filter=Name eq $it/Name)
            // $filter=Name will reference Authors(the expanded entity).
            // $it/Name will reference Books(the resource identified by the path).
            // The BindingState ImplicitRangeVariable property will store the $it that references the expanded/selected item (The Implicit Range Variable).
            // We add to the Stack, the $it that references the resource identified by the path (The Explicit Range Variable).

            BindingState state = new BindingState(config)
            {
                ImplicitRangeVariable =
                    NodeFactory.CreateImplicitRangeVariable(elementType != null ? elementType :
                        targetNavigationSource.EntityType().ToTypeReference(), targetNavigationSource)
            };

            state.AggregatedPropertyNames = generatedProperties;
            state.IsCollapsed = collapsed;
            state.ResourcePathNavigationSource = resourcePathNavigationSource;

            if (resourcePathNavigationSource != null)
            {
                // This $it rangeVariable will be added the Stack.
                // We are adding a rangeVariable whose navigationSource is the resource path entity set.
                // ODATA spec: Example 106 http://docs.oasis-open.org/odata/odata/v4.01/csprd05/part2-url-conventions/odata-v4.01-csprd05-part2-url-conventions.html#sec_it
                RangeVariable explicitRangeVariable = NodeFactory.CreateImplicitRangeVariable(
                    resourcePathNavigationSource.EntityType().ToTypeReference(), resourcePathNavigationSource);
                state.RangeVariables.Push(explicitRangeVariable);
            }

            return state;
        }

        private static void VerifySelectedPath(SelectTermToken selectedToken)
        {
            PathSegmentToken current = selectedToken.PathToProperty;
            while (current != null)
            {
                if (current is SystemToken)
                {
                    // It's not allowed to set a system token in a select clause.
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_SystemTokenInSelect(current.Identifier));
                }

                current = current.NextToken;
            }
        }

        private static bool VerifySelectedNavigationProperty(IList<ODataPathSegment> selectedPath, SelectTermToken tokenIn)
        {
            NavigationPropertySegment navPropSegment = selectedPath.LastOrDefault() as NavigationPropertySegment;
            if (navPropSegment != null)
            {
                // After navigation property, it's not allowed to nest query options
                VerifyNoQueryOptionsNested(tokenIn, navPropSegment.Identifier);

                return true;
            }

            return false;
        }

        private static void VerifyNoQueryOptionsNested(SelectTermToken selectToken, string identifier)
        {
            if (selectToken != null)
            {
                if (selectToken.ComputeOption != null ||
                    selectToken.FilterOption != null ||
                    selectToken.OrderByOptions != null ||
                    selectToken.SearchOption != null ||
                    selectToken.CountQueryOption != null ||
                    selectToken.SelectOption != null ||
                    selectToken.TopOption != null ||
                    selectToken.SkipOption != null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_InvalidQueryOptionNestedSelection(identifier));
                }
            }
        }

        private static void AddToSelectedItems(SelectItem itemToAdd, List<SelectItem> selectItems)
        {
            if (itemToAdd == null)
            {
                return;
            }

            // ignore all property selection if there's a wildcard select item.
            if (selectItems.Any(x => x is WildcardSelectItem) && IsStructuralOrNavigationPropertySelectionItem(itemToAdd))
            {
                return;
            }

            // if the selected item is a nav prop, then see if its already there before we add it.
            PathSelectItem pathSelectItem = itemToAdd as PathSelectItem;
            if (pathSelectItem != null)
            {
                NavigationPropertySegment trailingNavPropSegment = pathSelectItem.SelectedPath.LastSegment as NavigationPropertySegment;
                if (trailingNavPropSegment != null)
                {
                    if (selectItems.OfType<PathSelectItem>().Any(i => i.SelectedPath.Equals(pathSelectItem.SelectedPath)))
                    {
                        return;
                    }
                }
            }

            // if the selected item is "*", filter the existing property selection.
            if (itemToAdd is WildcardSelectItem)
            {
                var shouldFilter = selectItems.Where(s => IsStructuralSelectionItem(s)).ToList();
                foreach (var filterItem in shouldFilter)
                {
                    selectItems.Remove(filterItem);
                }
            }

            selectItems.Add(itemToAdd);
        }

        private static bool IsStructuralOrNavigationPropertySelectionItem(SelectItem selectItem)
        {
            PathSelectItem pathSelectItem = selectItem as PathSelectItem;
            return pathSelectItem != null &&
                (pathSelectItem.SelectedPath.LastSegment is NavigationPropertySegment ||
                pathSelectItem.SelectedPath.LastSegment is PropertySegment);
        }

        private static bool IsStructuralSelectionItem(SelectItem selectItem)
        {
            PathSelectItem pathSelectItem = selectItem as PathSelectItem;
            return pathSelectItem != null && (pathSelectItem.SelectedPath.LastSegment is PropertySegment);
        }
    }
}
---- Transformed Tree ----
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.OData.Metadata;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser.Aggregation;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// ExpandOption variant of an SelectExpandBinder, where the default selection item for a given level is based on the select at that level
    /// instead of the top level select clause. If nothing is selected for a given expand in the ExpandOption syntax, then we by default
    /// select all from that item, instead of selecting nothing (and therefore pruning the expand off of the tree).
    /// </summary>
    internal sealed class SelectExpandBinder
    {
        /// <summary>
        /// The configuration used for binding.
        /// </summary>
        private readonly ODataUriParserConfiguration configuration;

        /// <summary>
        /// The navigation source at the current level expand.
        /// </summary>
        private readonly IEdmNavigationSource navigationSource;

        /// <summary>
        /// The navigation source at the resource path.
        /// </summary>
        private readonly IEdmNavigationSource resourcePathNavigationSource;

        /// <summary>
        /// The entity type at the current level expand.
        /// </summary>
        private readonly IEdmStructuredType edmType;

        /// <summary>
        /// The segments parsed in path and query option.
        /// </summary>
        private List<ODataPathSegment> parsedSegments = new List<ODataPathSegment>();

        private BindingState state;

        public SelectExpandBinder(ODataUriParserConfiguration configuration, ODataPathInfo odataPathInfo, BindingState state)
        {
            ExceptionUtils.CheckArgumentNotNull(configuration, "configuration");
            ExceptionUtils.CheckArgumentNotNull(odataPathInfo.TargetStructuredType, "edmType");

            this.configuration = configuration;
            this.edmType = odataPathInfo.TargetStructuredType;
            this.navigationSource = odataPathInfo.TargetNavigationSource;
            this.parsedSegments = odataPathInfo.Segments.ToList();
            this.state = state;

            if (this.state != null)
            {
                this.resourcePathNavigationSource = this.state.ResourcePathNavigationSource;
            }
            else
            {
                this.resourcePathNavigationSource = odataPathInfo.TargetNavigationSource;
            }
        }

        /// <summary>
        /// The model used for binding.
        /// </summary>
        public IEdmModel Model
        {
            get { return this.configuration.Model; }
        }

        /// <summary>
        /// The top level type.
        /// </summary>
        public IEdmStructuredType EdmType
        {
            get { return this.edmType; }
        }

        /// <summary>
        /// The top level navigation source for this level.
        /// </summary>
        public IEdmNavigationSource NavigationSource
        {
            get { return this.navigationSource; }
        }

        /// <summary>
        /// The navigation source at the resource path.
        /// </summary>
        public IEdmNavigationSource ResourcePathNavigationSource
        {
            get { return this.resourcePathNavigationSource; }
        }

        /// <summary>
        /// The settings to use when binding.
        /// </summary>
        private ODataUriParserSettings Settings
        {
            get
            {
                return this.configuration.Settings;
            }
        }

        /// <summary>
        /// The configuration used for binding.
        /// </summary>
        private ODataUriParserConfiguration Configuration
        {
            get
            {
                return this.configuration;
            }
        }

        /// <summary>
        /// Bind the $expand <see cref="ExpandToken"/> and $select <see cref="SelectToken"/> at this level.
        /// </summary>
        /// <param name="expandToken">the expand token to visit.</param>
        /// <param name="selectToken">the select token to visit.</param>
        /// <returns>a SelectExpand clause based on <see cref="ExpandToken"/> and <see cref="SelectToken"/>.</returns>
        public SelectExpandClause Bind(ExpandToken expandToken, SelectToken selectToken)
        {
            List<SelectItem> selectExpandItems = new List<SelectItem>();

            // $expand=
            if (expandToken != null && expandToken.ExpandTerms.Any())
            {
                selectExpandItems.AddRange(expandToken.ExpandTerms.Select(this.GenerateExpandItem).Where(s => s != null));
            }

            // $select=
            bool isAllSelected = true;
            if (selectToken != null && selectToken.SelectTerms.Any())
            {
                // if there are any select items at this level then allSelected is false, otherwise it's true.
                isAllSelected = false;

                foreach (SelectTermToken selectTermToken in selectToken.SelectTerms)
                {
                    SelectItem selectItem = GenerateSelectItem(selectTermToken);
                    bool duplicate = false;

                    if (selectItem is PathSelectItem selectPathItem)
                    {
                        // It's not allowed to have multiple select clause with the same path.
                        // For example: $select=abc($top=2),abc($skip=2) is not allowed by design.
                        // Customer should combine them together, for example: $select=abc($top=2;$skip=2).
                        // The logic is different with ExpandTreeNormalizer. We should change the logic in ExpandTreeNormalizer
                        // in next breaking change version.
                        // For backward compatibility with previous versions of OData Library, we only validate
                        // if one of the select items has options.
                        foreach (PathSelectItem existingItem in selectExpandItems.OfType<PathSelectItem>())
                        {
                            if ((selectPathItem.HasOptions && OverLaps(selectPathItem, existingItem)) || (existingItem.HasOptions && OverLaps(existingItem, selectPathItem)))
                            {
                                throw new ODataException(ODataErrorStrings.SelectTreeNormalizer_MultipleSelecTermWithSamePathFound(ToPathString(selectTermToken.PathToProperty)));
                            }

                            // two items without options are identical -- for backward compat just ignore the new one
                            if (selectPathItem.SelectedPath.Equals(existingItem.SelectedPath))
                            {
                                duplicate = true;
                            }
                        }
                    }

                    if (!duplicate)
                    {
                        AddToSelectedItems(selectItem, selectExpandItems);
                    }
                }
            }

            // It's better to return "null" if both expand and select are null.
            // However, in order to be consistent, we returns empty "SelectExpandClause" with AllSelected = true.
            return new SelectExpandClause(selectExpandItems, isAllSelected);
        }

        /// <summary>
        /// Get the path string for a path segment token.
        /// </summary>
        /// <param name="head">The head of the path</param>
        /// <returns>The path string.</returns>
        internal static string ToPathString(PathSegmentToken head)
        {
            StringBuilder sb = new StringBuilder();
            PathSegmentToken curr = head;
            while (curr != null)
            {
                sb.Append(curr.Identifier);

                NonSystemToken nonSystem = curr as NonSystemToken;
                if (nonSystem?.NamedValues != null)
                {
                    sb.Append("(");
                    bool first = true;
                    foreach (var item in nonSystem.NamedValues)
                    {
                        if (first)
                        {
                            first = false;
                        }
                        else
                        {
                            sb.Append(",");
                        }

                        sb.Append(item.Name).Append("=").Append(item.Value.Value);
                    }

                    sb.Append(")");
                }

                curr = curr.NextToken;
                if (curr != null)
                {
                    sb.Append("/");
                }
            }

            return sb.ToString();
        }

        /// <summary>
        /// Determines whether the first path is entirely contained in the second path.
        /// </summary>
        /// <param name="firstPath">First path item</param>
        /// <param name="secondPath">Second path item</param>
        /// <returns>The boolean value.</returns>
        private static bool OverLaps(PathSelectItem firstPath, PathSelectItem secondPath)
        {
            IEnumerator<ODataPathSegment> first = firstPath.SelectedPath.GetEnumerator();
            IEnumerator<ODataPathSegment> second = secondPath.SelectedPath.GetEnumerator();

            bool completed;
            while ((completed = first.MoveNext()) && second.MoveNext() && first.Current.Identifier == second.Current.Identifier)
            {
            }

            return !completed;
        }

        /// <summary>
        /// Generate a select item <see cref="SelectItem"/> based on a <see cref="SelectTermToken"/>.
        /// for example:  abc/efg($count=true;$filter=....;$top=1)
        /// </summary>
        /// <param name="tokenIn">the select term token to visit</param>
        /// <returns>the select item for this select term token.</returns>
        private SelectItem GenerateSelectItem(SelectTermToken tokenIn)
        {
            ExceptionUtils.CheckArgumentNotNull(tokenIn, "tokenIn");
            ExceptionUtils.CheckArgumentNotNull(tokenIn.PathToProperty, "pathToProperty");

            VerifySelectedPath(tokenIn);

            SelectItem newSelectItem;
            if (ProcessWildcardTokenPath(tokenIn, out newSelectItem))
            {
                return newSelectItem;
            }

            IList<ODataPathSegment> selectedPath = ProcessSelectTokenPath(tokenIn.PathToProperty);
            Debug.Assert(selectedPath.Count > 0);

            // Navigation property should be the last segment in select path.
            if (VerifySelectedNavigationProperty(selectedPath, tokenIn))
            {
                return new PathSelectItem(new ODataSelectPath(selectedPath));
            }

            // We should use the "NavigationSource" at this level for the next level binding.
            IEdmNavigationSource targetNavigationSource = this.NavigationSource;
            ODataPathSegment lastSegment = selectedPath.Last();
            IEdmType targetElementType = lastSegment.TargetEdmType;

            if (targetElementType is IEdmCollectionType collection)
            {
                targetElementType = collection.ElementType.Definition;
            }

            IEdmTypeReference elementTypeReference = targetElementType.ToTypeReference();

            // $compute
            ComputeClause compute = BindCompute(tokenIn.ComputeOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference);
            HashSet<EndPathToken> generatedProperties = GetGeneratedProperties(compute, null);

            // $filter
            FilterClause filter = BindFilter(tokenIn.FilterOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            // $orderby
            OrderByClause orderBy = BindOrderby(tokenIn.OrderByOptions, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            // $search
            SearchClause search = BindSearch(tokenIn.SearchOption, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference);

            // $select
            List<ODataPathSegment> parsedPath = new List<ODataPathSegment>(this.parsedSegments);
            parsedPath.AddRange(selectedPath);
            SelectExpandClause selectExpand = BindSelectExpand(null, tokenIn.SelectOption, parsedPath, this.ResourcePathNavigationSource, targetNavigationSource, elementTypeReference, generatedProperties);

            return new PathSelectItem(new ODataSelectPath(selectedPath),
                targetNavigationSource,
                selectExpand,
                filter,
                orderBy,
                tokenIn.TopOption,
                tokenIn.SkipOption,
                tokenIn.CountQueryOption,
                search,
                compute);
        }

        /// <summary>
        /// Generate an expand item (and a select item for the implicit nav prop if necessary) based on an ExpandTermToken
        /// </summary>
        /// <param name="tokenIn">the expandTerm token to visit</param>
        /// <returns>the expand item for this expand term token.</returns>
        private SelectItem GenerateExpandItem(ExpandTermToken tokenIn)
        {
            ExceptionUtils.CheckArgumentNotNull(tokenIn, "tokenIn");

            PathSegmentToken currentToken = tokenIn.PathToNavigationProp;

            IEdmStructuredType currentLevelEntityType = this.EdmType;
            List<ODataPathSegment> pathSoFar = new List<ODataPathSegment>();
            PathSegmentToken firstNonTypeToken = currentToken;

            if (currentToken.IsNamespaceOrContainerQualified())
            {
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(currentToken, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentLevelEntityType, out firstNonTypeToken));
            }

            IEdmProperty edmProperty = this.configuration.Resolver.ResolveProperty(currentLevelEntityType, firstNonTypeToken.Identifier);
            if (edmProperty == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_PropertyNotDeclared(currentLevelEntityType.FullTypeName(), currentToken.Identifier));
            }

            IEdmNavigationProperty currentNavProp = edmProperty as IEdmNavigationProperty;
            if (currentNavProp == null && currentComplexProp == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, currentLevelEntityType.FullTypeName()));
            }

            if (edmProperty is IEdmStructuralProperty currentComplexProp)
            {
                currentNavProp = ParseComplexTypesBeforeNavigation(currentComplexProp, ref firstNonTypeToken, pathSoFar);
            }

            // ensure that we're always dealing with proper V4 syntax
            if (firstNonTypeToken.NextToken != null && firstNonTypeToken.NextToken.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_TraversingMultipleNavPropsInTheSamePath);
            }

            bool isRef = false;
            if (firstNonTypeToken.NextToken != null)
            {
                // lastly... make sure that, since we're on a NavProp, that the next token isn't null.
                if (firstNonTypeToken.NextToken.Identifier == UriQueryConstants.RefSegment)
                {
                    isRef = true;
                }
                else
                {
                    throw new ODataException(ODataErrorStrings.ExpandItemBinder_TraversingMultipleNavPropsInTheSamePath);
                }
            }

            // Add the segments in select and expand to parsed segments
            List<ODataPathSegment> parsedPath = new List<ODataPathSegment>(this.parsedSegments);
            parsedPath.AddRange(pathSoFar);

            IEdmNavigationSource targetNavigationSource = null;
            if (this.NavigationSource != null)
            {
                IEdmPathExpression bindingPath;
                targetNavigationSource = this.NavigationSource.FindNavigationTarget(currentNavProp, BindingPathHelper.MatchBindingPath, parsedPath, out bindingPath);
            }

            NavigationPropertySegment navSegment = new NavigationPropertySegment(currentNavProp, targetNavigationSource);
            pathSoFar.Add(navSegment);
            parsedPath.Add(navSegment); // Add the navigation property segment to parsed segments for future usage.
            ODataExpandPath pathToNavProp = new ODataExpandPath(pathSoFar);

            // $apply
            ApplyClause applyOption = BindApply(tokenIn.ApplyOptions, this.ResourcePathNavigationSource, targetNavigationSource);

            // $compute
            ComputeClause computeOption = BindCompute(tokenIn.ComputeOption, this.ResourcePathNavigationSource, targetNavigationSource);

            var generatedProperties = GetGeneratedProperties(computeOption, applyOption);
            bool collapsed = applyOption?.Transformations.Any(t => t.Kind == TransformationNodeKind.Aggregate || t.Kind == TransformationNodeKind.GroupBy) ?? false;

            // $filter
            FilterClause filterOption = BindFilter(tokenIn.FilterOption, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $orderby
            OrderByClause orderbyOption = BindOrderby(tokenIn.OrderByOptions, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $search
            SearchClause searchOption = BindSearch(tokenIn.SearchOption, this.ResourcePathNavigationSource, targetNavigationSource, null);

            if (isRef)
            {
                return new ExpandedReferenceSelectItem(pathToNavProp, targetNavigationSource, filterOption, orderbyOption, tokenIn.TopOption, tokenIn.SkipOption, tokenIn.CountQueryOption, searchOption, computeOption, applyOption);
            }

            // $select & $expand
            SelectExpandClause subSelectExpand = BindSelectExpand(tokenIn.ExpandOption, tokenIn.SelectOption, parsedPath, this.ResourcePathNavigationSource, targetNavigationSource, null, generatedProperties, collapsed);

            // $levels
            LevelsClause levelsOption = ParseLevels(tokenIn.LevelsOption, currentLevelEntityType, currentNavProp);

            return new ExpandedNavigationSelectItem(pathToNavProp,
                targetNavigationSource, subSelectExpand, filterOption, orderbyOption, tokenIn.TopOption, tokenIn.SkipOption, tokenIn.CountQueryOption, searchOption, levelsOption, computeOption, applyOption);
        }

        /// <summary>
        /// Bind the apply clause <see cref="ApplyClause"/> at this level.
        /// </summary>
        /// <param name="applyToken">The apply tokens to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <returns>The null or the built apply clause.</returns>
        private ApplyClause BindApply(IEnumerable<QueryToken> applyToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource)
        {
            if (applyToken != null && applyToken.Any())
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, null);
                ApplyBinder applyBinder = new ApplyBinder(binder.Bind, binder.BindingState);
                return applyBinder.BindApply(applyToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the compute clause <see cref="ComputeToken"/> at this level.
        /// </summary>
        /// <param name="computeToken">The compute token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The target element type.</param>
        /// <returns>The null or the built compute clause.</returns>
        private ComputeClause BindCompute(ComputeToken computeToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType = null)
        {
            if (computeToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType);
                ComputeBinder computeBinder = new ComputeBinder(binder.Bind);
                return computeBinder.BindCompute(computeToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the filter clause <see cref="FilterClause"/> at this level.
        /// </summary>
        /// <param name="filterToken">The filter token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built filter clause.</returns>
        private FilterClause BindFilter(QueryToken filterToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties, bool collapsed = false)
        {
            if (filterToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
                FilterBinder filterBinder = new FilterBinder(binder.Bind, binder.BindingState);
                return filterBinder.BindFilter(filterToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the orderby clause <see cref="OrderByClause"/> at this level.
        /// </summary>
        /// <param name="orderByToken">The orderby token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built filter clause.</returns>
        /// <returns>The null or the built orderby clause.</returns>
        private OrderByClause BindOrderby(IEnumerable<OrderByToken> orderByToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties, bool collapsed = false)
        {
            if (orderByToken != null && orderByToken.Any())
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
                OrderByBinder orderByBinder = new OrderByBinder(binder.Bind);
                return orderByBinder.BindOrderBy(binder.BindingState, orderByToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the search clause <see cref="SearchClause"/> at this level.
        /// </summary>
        /// <param name="searchToken">The search token to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <returns>The null or the built search clause.</returns>
        private SearchClause BindSearch(QueryToken searchToken, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType)
        {
            if (searchToken != null)
            {
                MetadataBinder binder = BuildNewMetadataBinder(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType);
                SearchBinder searchBinder = new SearchBinder(binder.Bind);
                return searchBinder.BindSearch(searchToken);
            }

            return null;
        }

        /// <summary>
        /// Bind the select and expand clause <see cref="SelectExpandClause"/> at this level.
        /// </summary>
        /// <param name="expandToken">The expand token to visit.</param>
        /// <param name="selectToken">The select token to visit.</param>
        /// <param name="segments">The parsed segments to visit.</param>
        /// <param name="resourcePathNavigationSource">The navigation source at the resource path.</param>
        /// <param name="targetNavigationSource">The target navigation source at the current level.</param>
        /// <param name="elementType">The Edm element type.</param>
        /// <param name="generatedProperties">The generated properties.</param>
        /// <param name="collapsed">The collapsed boolean value.</param>
        /// <returns>The null or the built select and expand clause.</returns>
        private SelectExpandClause BindSelectExpand(ExpandToken expandToken, SelectToken selectToken,
            IList<ODataPathSegment> segments, IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource, IEdmTypeReference elementType,
            HashSet<EndPathToken> generatedProperties = null, bool collapsed = false)
        {
            if (expandToken != null || selectToken != null)
            {
                BindingState binding = CreateBindingState(this.Configuration, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);

                SelectExpandBinder selectExpandBinder = new SelectExpandBinder(this.Configuration,
                new ODataPathInfo(new ODataPath(segments)), binding);

                return selectExpandBinder.Bind(expandToken, selectToken);
            }
            else
            {
                // It's better to return null for both Expand and Select are null.
                // However, in order to be consistent, we returns the empty SelectExpandClause with AllSelected = true.
                return new SelectExpandClause(new Collection<SelectItem>(), true);
            }
        }

        /// <summary>
        /// Process a <see cref="SelectTermToken"/> to identify whether it's a Wildcard path.
        /// </summary>
        /// <param name="selectToken">the select token to process.</param>
        /// <param name="newSelectItem">the built select item to out.</param>
        /// <returns>A boolean value indicates the result of processing wildcard token path.</returns>
        private bool ProcessWildcardTokenPath(SelectTermToken selectToken, out SelectItem newSelectItem)
        {
            newSelectItem = null;
            if (selectToken == null || selectToken.PathToProperty == null)
            {
                return false;
            }

            PathSegmentToken pathToken = selectToken.PathToProperty;
            if (SelectPathSegmentTokenBinder.TryBindAsWildcard(pathToken, this.Model, out newSelectItem))
            {
                // * or Namespace.*
                if (pathToken.NextToken != null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_InvalidIdentifierAfterWildcard(pathToken.NextToken.Identifier));
                }

                VerifyNoQueryOptionsNested(selectToken, pathToken.Identifier);

                return true;
            }

            return false;
        }

        /// <summary>
        /// Process a <see cref="PathSegmentToken"/> following any type segments if necessary.
        /// </summary>
        /// <param name="tokenIn">the path token to process.</param>
        /// <returns>The processed OData segments.</returns>
        private List<ODataPathSegment> ProcessSelectTokenPath(PathSegmentToken tokenIn)
        {
            Debug.Assert(tokenIn != null, "tokenIn != null");

            List<ODataPathSegment> pathSoFar = new List<ODataPathSegment>();
            IEdmStructuredType currentLevelType = this.edmType;

            // first, walk through all type segments in a row, converting them from tokens into segments.
            if (tokenIn.IsNamespaceOrContainerQualified() && !UriParserHelper.IsAnnotation(tokenIn.Identifier))
            {
                PathSegmentToken firstNonTypeToken;
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(tokenIn, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentLevelType, out firstNonTypeToken));
                Debug.Assert(firstNonTypeToken != null, "Did not get last token.");
                tokenIn = firstNonTypeToken as NonSystemToken;
                if (tokenIn == null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_SystemTokenInSelect(firstNonTypeToken.Identifier));
                }
            }

            // next, create a segment for the first non-type segment in the path.
            ODataPathSegment lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(tokenIn, this.Model, currentLevelType, this.configuration.Resolver, this.state);

            // next, create an ODataPath and add the segments to it.
            if (lastSegment != null)
            {
                pathSoFar.Add(lastSegment);

                // try create a complex type property path.
                while (true)
                {
                    // no need to go on if the current property is not of complex type or collection of complex type,
                    // unless the segment is a primitive type cast or a property on an open complex property.
                    currentLevelType = lastSegment.EdmType as IEdmStructuredType;
                    IEdmCollectionType collectionType = lastSegment.EdmType as IEdmCollectionType;
                    IEdmPrimitiveType primitiveType = lastSegment.EdmType as IEdmPrimitiveType;
                    if ((currentLevelType == null || currentLevelType.TypeKind != EdmTypeKind.Complex)
                        && (collectionType == null || collectionType.ElementType.TypeKind() != EdmTypeKind.Complex)
                        && (primitiveType == null || primitiveType.TypeKind != EdmTypeKind.Primitive)
                        && (dynamicPath == null || tokenIn.NextToken == null))
                    {
                        break;
                    }

                    NonSystemToken nextToken = tokenIn.NextToken as NonSystemToken;
                    if (nextToken == null)
                    {
                        break;
                    }

                    if (UriParserHelper.IsAnnotation(nextToken.Identifier))
                    {
                        lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(nextToken, this.Model,
                            currentLevelType, this.configuration.Resolver, null);
                    }
                    else if (primitiveType == null && dynamicPath == null)
                    {
                        // This means last segment a collection of complex type,
                        // current segment can only be type cast and cannot be property name.
                        if (currentLevelType == null)
                        {
                            currentLevelType = collectionType.ElementType.Definition as IEdmStructuredType;
                        }

                        // If there is no collection type in the path yet, will try to bind property for the next token
                        // first try bind the segment as property.
                        lastSegment = SelectPathSegmentTokenBinder.ConvertNonTypeTokenToSegment(nextToken, this.Model,
                            currentLevelType, this.configuration.Resolver, null);
                    }
                    else
                    {
                        // determine whether we are looking at a type cast or a dynamic path segment.
                        EdmPrimitiveTypeKind nextTypeKind = EdmCoreModel.Instance.GetPrimitiveTypeKind(nextToken.Identifier);
                        IEdmPrimitiveType castType = EdmCoreModel.Instance.GetPrimitiveType(nextTypeKind);
                        if (castType != null)
                        {
                            lastSegment = new TypeSegment(castType, castType, null);
                        }
                        else if (lastSegment is DynamicPathSegment dynamicPath)
                        {
                            lastSegment = new DynamicPathSegment(nextToken.Identifier);
                        }
                        else
                        {
                            throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
                        }
                    }

                    // then try bind the segment as type cast.
                    if (lastSegment == null)
                    {
                        IEdmStructuredType typeFromNextToken =
                            UriEdmHelpers.FindTypeFromModel(this.Model, nextToken.Identifier, this.configuration.Resolver) as
                                IEdmStructuredType;

                        if (typeFromNextToken.IsOrInheritsFrom(currentLevelType))
                        {
                            lastSegment = new TypeSegment(typeFromNextToken, /*entitySet*/null);
                        }
                    }

                    // type cast failed too.
                    if (lastSegment == null)
                    {
                        break;
                    }

                    // try move to and add next path segment.
                    tokenIn = nextToken;
                    pathSoFar.Add(lastSegment);
                }
            }

            // non-navigation cases do not allow further segments in $select.
            if (tokenIn.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
            }

            // Later, we can consider to create a "DynamicOperationSegment" to handle this.
            // But now, Let's throw exception.
            if (lastSegment == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_InvalidIdentifierInQueryOption(tokenIn.Identifier));
            }

            // navigation property is not allowed to append sub path in the selection.
            if (pathSoFar.LastOrDefault() is NavigationPropertySegment navPropSegment && tokenIn.NextToken != null)
            {
                throw new ODataException(ODataErrorStrings.SelectBinder_MultiLevelPathInSelect);
            }

            return pathSoFar;
        }

        private static HashSet<EndPathToken> GetGeneratedProperties(ComputeClause computeOption, ApplyClause applyOption)
        {
            HashSet<EndPathToken> generatedProperties = null;

            if (applyOption != null)
            {
                generatedProperties = applyOption.GetLastAggregatedPropertyNames();
            }

            if (computeOption != null)
            {
                var computedProperties = new HashSet<EndPathToken>(computeOption.ComputedItems.Select(i => new EndPathToken(i.Alias, null)));
                if (generatedProperties == null)
                {
                    generatedProperties = computedProperties;
                }
                else
                {
                    generatedProperties.UnionWith(computedProperties);
                }
            }

            return generatedProperties;
        }

        private IEdmNavigationProperty ParseComplexTypesBeforeNavigation(IEdmStructuralProperty edmProperty, ref PathSegmentToken currentToken, List<ODataPathSegment> pathSoFar)
        {
            pathSoFar.Add(new PropertySegment(edmProperty));

            if (currentToken.NextToken == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, edmProperty.DeclaringType.FullTypeName()));
            }

            currentToken = currentToken.NextToken;

            IEdmType complexType = edmProperty.Type.Definition;

            if (complexType is IEdmCollectionType collectionType)
            {
                complexType = collectionType.ElementType.Definition;
            }

            IEdmStructuredType currentType = complexType as IEdmStructuredType;
            if (currentType == null)
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_InvaidSegmentInExpand(currentToken.Identifier));
            }

            if (currentToken.IsNamespaceOrContainerQualified())
            {
                pathSoFar.AddRange(SelectExpandPathBinder.FollowTypeSegments(currentToken, this.Model, this.Settings.SelectExpandLimit, this.configuration.Resolver, ref currentType, out currentToken));
            }

            IEdmProperty property = this.configuration.Resolver.ResolveProperty(currentType, currentToken.Identifier);
            if (edmProperty == null)
            {
                throw new ODataException(ODataErrorStrings.MetadataBinder_PropertyNotDeclared(currentType.FullTypeName(), currentToken.Identifier));
            }

            if (property is IEdmStructuralProperty complexProp)
            {
                property = ParseComplexTypesBeforeNavigation(complexProp, ref currentToken, pathSoFar);
            }

            if (property is IEdmNavigationProperty navProp)
            {
                return navProp;
            }
            else
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_PropertyIsNotANavigationPropertyOrComplexProperty(currentToken.Identifier, currentType.FullTypeName()));
            }
        }

        /// <summary>
        /// Parse from levelsOption token to LevelsClause.
        /// Negative value would be treated as max.
        /// </summary>
        /// <param name="levelsOption">The levelsOption for current expand.</param>
        /// <param name="sourceType">The type of current level navigation source.</param>
        /// <param name="property">Navigation property for current expand.</param>
        /// <returns>The LevelsClause parsed, null if levelsOption is null</returns>
        private static LevelsClause ParseLevels(long? levelsOption, IEdmType sourceType, IEdmNavigationProperty property)
        {
            if (!levelsOption.HasValue)
            {
                return null;
            }

            IEdmType relatedType = property.ToEntityType();

            if (sourceType != null && relatedType != null && !UriEdmHelpers.IsRelatedTo(sourceType, relatedType))
            {
                throw new ODataException(ODataErrorStrings.ExpandItemBinder_LevelsNotAllowedOnIncompatibleRelatedType(property.Name, relatedType.FullTypeName(), sourceType.FullTypeName()));
            }

            return new LevelsClause(levelsOption.Value < 0, levelsOption.Value);
        }

        private static MetadataBinder BuildNewMetadataBinder(ODataUriParserConfiguration config,
            IEdmNavigationSource resourcePathNavigationSource,
            IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType,
            HashSet<EndPathToken> generatedProperties = null,
            bool collapsed = false)
        {
            BindingState state = CreateBindingState(config, resourcePathNavigationSource, targetNavigationSource, elementType, generatedProperties, collapsed);
            return new MetadataBinder(state);
        }

        private static BindingState CreateBindingState(ODataUriParserConfiguration config,
            IEdmNavigationSource resourcePathNavigationSource, IEdmNavigationSource targetNavigationSource,
            IEdmTypeReference elementType, HashSet<EndPathToken> generatedProperties = null,
            bool collapsed = false)
        {
            if (targetNavigationSource == null && elementType == null)
            {
                return null;
            }

            // For example if we have https://url/Books?$expand=Authors($filter=Name eq $it/Name)
            // $filter=Name will reference Authors(the expanded entity).
            // $it/Name will reference Books(the resource identified by the path).
            // The BindingState ImplicitRangeVariable property will store the $it that references the expanded/selected item (The Implicit Range Variable).
            // We add to the Stack, the $it that references the resource identified by the path (The Explicit Range Variable).

            BindingState state = new BindingState(config)
            {
                ImplicitRangeVariable =
                    NodeFactory.CreateImplicitRangeVariable(elementType != null ? elementType :
                        targetNavigationSource.EntityType().ToTypeReference(), targetNavigationSource)
            };

            state.AggregatedPropertyNames = generatedProperties;
            state.IsCollapsed = collapsed;
            state.ResourcePathNavigationSource = resourcePathNavigationSource;

            if (resourcePathNavigationSource != null)
            {
                // This $it rangeVariable will be added the Stack.
                // We are adding a rangeVariable whose navigationSource is the resource path entity set.
                // ODATA spec: Example 106 http://docs.oasis-open.org/odata/odata/v4.01/csprd05/part2-url-conventions/odata-v4.01-csprd05-part2-url-conventions.html#sec_it
                RangeVariable explicitRangeVariable = NodeFactory.CreateImplicitRangeVariable(
                    resourcePathNavigationSource.EntityType().ToTypeReference(), resourcePathNavigationSource);
                state.RangeVariables.Push(explicitRangeVariable);
            }

            return state;
        }

        private static void VerifySelectedPath(SelectTermToken selectedToken)
        {
            PathSegmentToken current = selectedToken.PathToProperty;
            while (current != null)
            {
                if (current is SystemToken)
                {
                    // It's not allowed to set a system token in a select clause.
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_SystemTokenInSelect(current.Identifier));
                }

                current = current.NextToken;
            }
        }

        private static bool VerifySelectedNavigationProperty(IList<ODataPathSegment> selectedPath, SelectTermToken tokenIn)
        {
            if (selectedPath.LastOrDefault() is NavigationPropertySegment navPropSegment)
            {
                // After navigation property, it's not allowed to nest query options
                VerifyNoQueryOptionsNested(tokenIn, navPropSegment.Identifier);

                return true;
            }

            return false;
        }

        private static void VerifyNoQueryOptionsNested(SelectTermToken selectToken, string identifier)
        {
            if (selectToken != null)
            {
                if (selectToken.ComputeOption != null ||
                    selectToken.FilterOption != null ||
                    selectToken.OrderByOptions != null ||
                    selectToken.SearchOption != null ||
                    selectToken.CountQueryOption != null ||
                    selectToken.SelectOption != null ||
                    selectToken.TopOption != null ||
                    selectToken.SkipOption != null)
                {
                    throw new ODataException(ODataErrorStrings.SelectExpandBinder_InvalidQueryOptionNestedSelection(identifier));
                }
            }
        }

        private static void AddToSelectedItems(SelectItem itemToAdd, List<SelectItem> selectItems)
        {
            if (itemToAdd == null)
            {
                return;
            }

            // ignore all property selection if there's a wildcard select item.
            if (selectItems.Any(x => x is WildcardSelectItem) && IsStructuralOrNavigationPropertySelectionItem(itemToAdd))
            {
                return;
            }

            // if the selected item is a nav prop, then see if its already there before we add it.
            if (itemToAdd is PathSelectItem pathSelectItem)
            {
                if (pathSelectItem.SelectedPath.LastSegment is NavigationPropertySegment trailingNavPropSegment)
                {
                    if (selectItems.OfType<PathSelectItem>().Any(i => i.SelectedPath.Equals(pathSelectItem.SelectedPath)))
                    {
                        return;
                    }
                }
            }

            // if the selected item is "*", filter the existing property selection.
            if (itemToAdd is WildcardSelectItem)
            {
                var shouldFilter = selectItems.Where(s => IsStructuralSelectionItem(s)).ToList();
                foreach (var filterItem in shouldFilter)
                {
                    selectItems.Remove(filterItem);
                }
            }

            selectItems.Add(itemToAdd);
        }

        private static bool IsStructuralOrNavigationPropertySelectionItem(SelectItem selectItem)
        {
            return selectItem is PathSelectItem pathSelectItem &&
                (pathSelectItem.SelectedPath.LastSegment is NavigationPropertySegment ||
                pathSelectItem.SelectedPath.LastSegment is PropertySegment);
        }

        private static bool IsStructuralSelectionItem(SelectItem selectItem)
        {
            return selectItem is PathSelectItem pathSelectItem && (pathSelectItem.SelectedPath.LastSegment is PropertySegment);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectExpandBinder.cs(353,43): error CS0841: Cannot use local variable 'currentComplexProp' before it is declared,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectExpandBinder.cs(646,29): error CS0103: The name 'dynamicPath' does not exist in the current context,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Binders\SelectExpandBinder.cs(662,55): error CS0103: The name 'dynamicPath' does not exist in the current context
######################################################################


######################################################################
Nr: 23 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\NodeFactory.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Factory class to build IParameterQueryNodes.
    /// </summary>
    internal static class NodeFactory
    {
        /// <summary>
        /// Creates a <see cref="RangeVariable"/> for an implicit parameter ($it) from an <see cref="ODataPath"/>.
        /// </summary>
        /// <param name="path"><see cref="ODataPath"/> that the range variable is iterating over.</param>
        /// <returns>A new <see cref="RangeVariable"/>.</returns>
        internal static RangeVariable CreateImplicitRangeVariable(ODataPath path)
        {
            ExceptionUtils.CheckArgumentNotNull(path, "path");
            IEdmTypeReference elementType = path.EdmType();

            if (elementType == null)
            {
                // This case if for something like a void service operation
                // This is pretty ugly; if practice we shouldn't be creating a parameter node for this case I think
                return null;
            }

            if (elementType.IsCollection())
            {
                elementType = elementType.AsCollection().ElementType();
            }

            if (elementType.IsStructured())
            {
                IEdmStructuredTypeReference structuredTypeReference = elementType.AsStructured();
                return new ResourceRangeVariable(ExpressionConstants.It, structuredTypeReference, path.NavigationSource());
            }

            return new NonResourceRangeVariable(ExpressionConstants.It, elementType, null);
        }

        /// <summary>
        /// Creates a ParameterQueryNode for an implicit parameter ($it).
        /// </summary>
        /// <param name="elementType">Element type the parameter represents.</param>
        /// <param name="navigationSource">The navigation source. May be null and must be null for non structured types.</param>
        /// <returns>A new IParameterNode.</returns>
        internal static RangeVariable CreateImplicitRangeVariable(IEdmTypeReference elementType, IEdmNavigationSource navigationSource)
        {
            if (elementType.IsStructured())
            {
                return new ResourceRangeVariable(ExpressionConstants.It, elementType as IEdmStructuredTypeReference, navigationSource);
            }

            Debug.Assert(navigationSource == null, "if the type wasn't a structured type then there should be no navigation source");
            return new NonResourceRangeVariable(ExpressionConstants.It, elementType, null);
        }

        /// <summary>
        /// Creates a RangeVariableReferenceNode for a given range variable
        /// </summary>
        /// <param name="rangeVariable">Name of the rangeVariable.</param>
        /// <returns>A new SingleValueNode (either a Resource or NonResource RangeVariableReferenceNode.</returns>
        internal static SingleValueNode CreateRangeVariableReferenceNode(RangeVariable rangeVariable)
        {
            if (rangeVariable.Kind == RangeVariableKind.NonResource)
            {
                return new NonResourceRangeVariableReferenceNode(rangeVariable.Name, (NonResourceRangeVariable)rangeVariable);
            }
            else
            {
                ResourceRangeVariable resourceRangeVariable = (ResourceRangeVariable)rangeVariable;
                return new ResourceRangeVariableReferenceNode(resourceRangeVariable.Name, resourceRangeVariable);
            }
        }

        /// <summary>
        /// Creates a ParameterQueryNode for an explicit parameter.
        /// </summary>
        /// <param name="parameter">Name of the parameter.</param>
        /// <param name="nodeToIterateOver">CollectionNode that the parameter is iterating over.</param>
        /// <returns>A new RangeVariable.</returns>
        internal static RangeVariable CreateParameterNode(string parameter, CollectionNode nodeToIterateOver)
        {
            IEdmTypeReference elementType = nodeToIterateOver.ItemType;

            if (elementType != null && elementType.IsStructured())
            {
                var collectionResourceNode = nodeToIterateOver as CollectionResourceNode;
                Debug.Assert(collectionResourceNode != null, "IF the element type was structured, the node type should be a resource collection");
                return new ResourceRangeVariable(parameter, elementType as IEdmStructuredTypeReference, collectionResourceNode);
            }

            return new NonResourceRangeVariable(parameter, elementType, null);
        }

        /// <summary>
        /// Creates an AnyNode or an AllNode from the given
        /// </summary>
        /// <param name="state">State of binding.</param>
        /// <param name="parent">Parent node to the lambda.</param>
        /// <param name="lambdaExpression">Bound Lambda expression.</param>
        /// <param name="newRangeVariable">The new range variable being added by this lambda node.</param>
        /// <param name="queryTokenKind">Token kind.</param>
        /// <returns>A new LambdaNode bound to metadata.</returns>
        internal static LambdaNode CreateLambdaNode(
            BindingState state,
            CollectionNode parent,
            SingleValueNode lambdaExpression,
            RangeVariable newRangeVariable,
            QueryTokenKind queryTokenKind)
        {
            LambdaNode lambdaNode;
            if (queryTokenKind == QueryTokenKind.Any)
            {
                lambdaNode = new AnyNode(new Collection<RangeVariable>(state.RangeVariables.ToList()), newRangeVariable)
                    {
                        Body = lambdaExpression,
                        Source = parent,
                    };
            }
            else
            {
                Debug.Assert(queryTokenKind == QueryTokenKind.All, "LambdaQueryNodes must be Any or All only.");
                lambdaNode = new AllNode(new Collection<RangeVariable>(state.RangeVariables.ToList()), newRangeVariable)
                    {
                        Body = lambdaExpression,
                        Source = parent,
                    };
            }

            return lambdaNode;
        }
    }
}
---- Transformed Tree ----
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Linq;
using Microsoft.OData.Edm;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Factory class to build IParameterQueryNodes.
    /// </summary>
    internal static class NodeFactory
    {
        /// <summary>
        /// Creates a <see cref="RangeVariable"/> for an implicit parameter ($it) from an <see cref="ODataPath"/>.
        /// </summary>
        /// <param name="path"><see cref="ODataPath"/> that the range variable is iterating over.</param>
        /// <returns>A new <see cref="RangeVariable"/>.</returns>
        internal static RangeVariable CreateImplicitRangeVariable(ODataPath path)
        {
            ExceptionUtils.CheckArgumentNotNull(path, "path");
            IEdmTypeReference elementType = path.EdmType();

            if (elementType == null)
            {
                // This case if for something like a void service operation
                // This is pretty ugly; if practice we shouldn't be creating a parameter node for this case I think
                return null;
            }

            if (elementType.IsCollection())
            {
                elementType = elementType.AsCollection().ElementType();
            }

            if (elementType.IsStructured())
            {
                IEdmStructuredTypeReference structuredTypeReference = elementType.AsStructured();
                return new ResourceRangeVariable(ExpressionConstants.It, structuredTypeReference, path.NavigationSource());
            }

            return new NonResourceRangeVariable(ExpressionConstants.It, elementType, null);
        }

        /// <summary>
        /// Creates a ParameterQueryNode for an implicit parameter ($it).
        /// </summary>
        /// <param name="elementType">Element type the parameter represents.</param>
        /// <param name="navigationSource">The navigation source. May be null and must be null for non structured types.</param>
        /// <returns>A new IParameterNode.</returns>
        internal static RangeVariable CreateImplicitRangeVariable(IEdmTypeReference elementType, IEdmNavigationSource navigationSource)
        {
            if (elementType.IsStructured())
            {
                return new ResourceRangeVariable(ExpressionConstants.It, elementType as IEdmStructuredTypeReference, navigationSource);
            }

            Debug.Assert(navigationSource == null, "if the type wasn't a structured type then there should be no navigation source");
            return new NonResourceRangeVariable(ExpressionConstants.It, elementType, null);
        }

        /// <summary>
        /// Creates a RangeVariableReferenceNode for a given range variable
        /// </summary>
        /// <param name="rangeVariable">Name of the rangeVariable.</param>
        /// <returns>A new SingleValueNode (either a Resource or NonResource RangeVariableReferenceNode.</returns>
        internal static SingleValueNode CreateRangeVariableReferenceNode(RangeVariable rangeVariable)
        {
            if (rangeVariable.Kind == RangeVariableKind.NonResource)
            {
                return new NonResourceRangeVariableReferenceNode(rangeVariable.Name, (NonResourceRangeVariable)rangeVariable);
            }
            else
            {
                ResourceRangeVariable resourceRangeVariable = (ResourceRangeVariable)rangeVariable;
                return new ResourceRangeVariableReferenceNode(resourceRangeVariable.Name, resourceRangeVariable);
            }
        }

        /// <summary>
        /// Creates a ParameterQueryNode for an explicit parameter.
        /// </summary>
        /// <param name="parameter">Name of the parameter.</param>
        /// <param name="nodeToIterateOver">CollectionNode that the parameter is iterating over.</param>
        /// <returns>A new RangeVariable.</returns>
        internal static RangeVariable CreateParameterNode(string parameter, CollectionNode nodeToIterateOver)
        {
            IEdmTypeReference elementType = nodeToIterateOver.ItemType;

            if (elementType != null && elementType.IsStructured())
            {
                Debug.Assert(nodeToIterateOver is CollectionResourceNode collectionResourceNode, "IF the element type was structured, the node type should be a resource collection");
                return new ResourceRangeVariable(parameter, elementType as IEdmStructuredTypeReference, collectionResourceNode);
            }

            return new NonResourceRangeVariable(parameter, elementType, null);
        }

        /// <summary>
        /// Creates an AnyNode or an AllNode from the given
        /// </summary>
        /// <param name="state">State of binding.</param>
        /// <param name="parent">Parent node to the lambda.</param>
        /// <param name="lambdaExpression">Bound Lambda expression.</param>
        /// <param name="newRangeVariable">The new range variable being added by this lambda node.</param>
        /// <param name="queryTokenKind">Token kind.</param>
        /// <returns>A new LambdaNode bound to metadata.</returns>
        internal static LambdaNode CreateLambdaNode(
            BindingState state,
            CollectionNode parent,
            SingleValueNode lambdaExpression,
            RangeVariable newRangeVariable,
            QueryTokenKind queryTokenKind)
        {
            LambdaNode lambdaNode;
            if (queryTokenKind == QueryTokenKind.Any)
            {
                lambdaNode = new AnyNode(new Collection<RangeVariable>(state.RangeVariables.ToList()), newRangeVariable)
                    {
                        Body = lambdaExpression,
                        Source = parent,
                    };
            }
            else
            {
                Debug.Assert(queryTokenKind == QueryTokenKind.All, "LambdaQueryNodes must be Any or All only.");
                lambdaNode = new AllNode(new Collection<RangeVariable>(state.RangeVariables.ToList()), newRangeVariable)
                    {
                        Body = lambdaExpression,
                        Source = parent,
                    };
            }

            return lambdaNode;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\NodeFactory.cs(98,105): error CS0165: Use of unassigned local variable 'collectionResourceNode'
######################################################################


######################################################################
Nr: 24 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ODataPathParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.Metadata;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Semantic parser for the path of the request URI.
    /// </summary>
    internal sealed class ODataPathParser
    {
        /// <summary>
        /// regex pattern to match a contentID
        /// </summary>
        internal static readonly Regex ContentIdRegex = PlatformHelper.CreateCompiled(@"^\$[0-9]+$", RegexOptions.Singleline);

        /// <summary>Empty list of strings.</summary>
        private static readonly IList<string> EmptyList = new List<string>();

        /// <summary>
        /// The queue of segments remaining to be parsed. Should be populated and cleared out on each pass through the main path parsing loop.
        /// </summary>
        private readonly Queue<string> segmentQueue = new Queue<string>();

        /// <summary>
        /// The collection of segments that have been parsed so far.
        /// </summary>
        private readonly List<ODataPathSegment> parsedSegments = new List<ODataPathSegment>();

        /// <summary>
        /// The parser's current configuration.
        /// </summary>
        private readonly ODataUriParserConfiguration configuration;

        /// <summary>
        /// Indicates that the next segment encountered must refer to something in 'metadata-space' and cannot be a key expression.
        /// </summary>
        private bool nextSegmentMustReferToMetadata;

        /// <summary>
        /// Last navigation source that has been parsed.
        /// </summary>
        private IEdmNavigationSource lastNavigationSource;

        /// <summary>
        /// Initializes a new instance of <see cref="ODataPathParser"/>.
        /// </summary>
        /// <param name="configuration">The parser's current configuration.</param>
        internal ODataPathParser(ODataUriParserConfiguration configuration)
        {
            Debug.Assert(configuration != null, "configuration != null");

            this.configuration = configuration;
        }

        /// <summary>
        /// Extracts the segment identifier and, if there are parenthesis in the segment, the expression in the parenthesis.
        /// Will throw if identifier is not found or if the parenthesis expression is malformed. This function does not validate
        /// anything and simply provides the raw text of both the identifier and parenthetical expression.
        /// </summary>
        /// <remarks>Internal only so it can be called from tests. Should not be used outside <see cref="ODataPathParser"/>.</remarks>
        /// <param name="segmentText">The segment text.</param>
        /// <param name="identifier">The identifier that was found.</param>
        /// <param name="parenthesisExpression">The query portion that was found. Will be null after the call if no query portion was present.</param>
        internal static void ExtractSegmentIdentifierAndParenthesisExpression(string segmentText, out string identifier, out string parenthesisExpression)
        {
            Debug.Assert(segmentText != null, "segment != null");

            int parenthesisStart = segmentText.IndexOf('(');
            if (parenthesisStart < 0)
            {
                identifier = segmentText;
                parenthesisExpression = null;
            }
            else
            {
                if (segmentText[segmentText.Length - 1] != ')')
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                // split the string to grab the identifier and remove the parentheses
                identifier = segmentText.Substring(0, parenthesisStart);
                parenthesisExpression = segmentText.Substring(parenthesisStart + 1, segmentText.Length - identifier.Length - 2);
            }

            // We allow a single trailing '/', which results in an empty segment.
            // However System.Uri removes it, so any empty segment we see is a 404 error.
            if (identifier.Length == 0)
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_EmptySegmentInRequestUrl);
            }
        }

        /// <summary>Creates an <see cref="ODataPathSegment"/> array for the given <paramref name="segments"/>.</summary>
        /// <param name="segments">Segments to process.</param>
        /// <returns>Segment information describing the given <paramref name="segments"/>.</returns>
        internal IList<ODataPathSegment> ParsePath(ICollection<string> segments)
        {
            Debug.Assert(segments != null, "segments != null");
            Debug.Assert(this.parsedSegments.Count == 0, "Segment storage should be empty.");
            Debug.Assert(this.segmentQueue.Count == 0, "Segment queue should be empty.");

            // populate the queue that will be used to drive the rest of the algorithm.
            foreach (var segment in segments)
            {
                this.segmentQueue.Enqueue(segment);
            }

            string segmentText = null;

            try
            {
                while (this.TryGetNextSegmentText(out segmentText))
                {
                    if (this.parsedSegments.Count == 0)
                    {
                        this.CreateFirstSegment(segmentText);
                    }
                    else
                    {
                        this.CreateNextSegment(segmentText);
                    }

                    // Keep track of last navigation source.
                    IEdmNavigationSource navigationSource = parsedSegments.Last().TranslateWith(new DetermineNavigationSourceTranslator());
                    if (navigationSource != null)
                    {
                        lastNavigationSource = navigationSource;
                    }
                }
            }
            catch (ODataUnrecognizedPathException ex)
            {
                ex.ParsedSegments = this.parsedSegments;
                ex.CurrentSegment = segmentText;
                ex.UnparsedSegments = this.segmentQueue.ToList();
                throw;
            }

            List<ODataPathSegment> validatedSegments = CreateValidatedPathSegments();
            this.parsedSegments.Clear();

            return validatedSegments;
        }

        /// <summary>
        /// Tries to find a single matching operation import for the given identifier, and parameters.
        /// </summary>
        /// <param name="identifier">The identifier from the URI.</param>
        /// <param name="parenthesisExpression">The parenthesis expression containing parameters, if any.</param>
        /// <param name="configuration">The configuration of the parser.</param>
        /// <param name="boundParameters">The parsed parameters from the parenthesis expression.</param>
        /// <param name="matchingFunctionImport">The single matching operation import if one could be determined.</param>
        /// <returns>Whether or not a matching operation import could be found.</returns>
        private static bool TryBindingParametersAndMatchingOperationImport(string identifier, string parenthesisExpression, ODataUriParserConfiguration configuration, out ICollection<OperationSegmentParameter> boundParameters, out IEdmOperationImport matchingFunctionImport)
        {
            matchingFunctionImport = null;
            ICollection<FunctionParameterToken> splitParameters = null;
            if (!String.IsNullOrEmpty(parenthesisExpression))
            {
                if (!FunctionParameterParser.TrySplitOperationParameters(parenthesisExpression, configuration, out splitParameters))
                {
                    IEdmOperationImport possibleMatchingOperationImport = null;

                    // Look for an overload that returns an entity collection by the specified name. If so parenthesis is just key parameters.
                    if (FunctionOverloadResolver.ResolveOperationImportFromList(identifier, EmptyList, configuration.Model, out possibleMatchingOperationImport, configuration.Resolver))
                    {
                        IEdmCollectionTypeReference collectionReturnType = possibleMatchingOperationImport.Operation.ReturnType as IEdmCollectionTypeReference;
                        if (collectionReturnType != null && collectionReturnType.ElementType().IsEntity())
                        {
                            matchingFunctionImport = possibleMatchingOperationImport;
                            boundParameters = null;
                            return true;
                        }
                        else
                        {
                            throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_SegmentDoesNotSupportKeyPredicates(identifier));
                        }
                    }

                    boundParameters = null;
                    return false;
                }
            }
            else
            {
                splitParameters = new Collection<FunctionParameterToken>();
            }

            // Resolve the specific overload.
            if (FunctionOverloadResolver.ResolveOperationImportFromList(identifier, splitParameters.Select(k => k.ParameterName).ToList(), configuration.Model, out matchingFunctionImport, configuration.Resolver))
            {
                var matchingOperation = matchingFunctionImport.Operation;
                boundParameters = FunctionCallBinder.BindSegmentParameters(configuration, matchingOperation, splitParameters);
                return true;
            }

            boundParameters = null;
            return false;
        }

        /// <summary>
        /// Tries to find a single matching operation import for the given identifier, parameters, and binding type.
        /// </summary>
        /// <param name="identifier">The identifier from the URI.</param>
        /// <param name="parenthesisExpression">The parenthesis expression containing parameters, if any.</param>
        /// <param name="bindingType">The current binding type or null if there isn't one.</param>
        /// <param name="configuration">The configuration of the parser.</param>
        /// <param name="boundParameters">The parsed parameters from the parenthesis expression.</param>
        /// <param name="matchingOperation">The single matching operation import if one could be determined.</param>
        /// <returns>Whether or not a matching operation import could be found.</returns>
        private static bool TryBindingParametersAndMatchingOperation(string identifier, string parenthesisExpression, IEdmType bindingType, ODataUriParserConfiguration configuration, out ICollection<OperationSegmentParameter> boundParameters, out IEdmOperation matchingOperation)
        {
            // If the name isn't fully qualified then it can't be a function or action.
            // When using extension, there may be function call with unqualified name. So loose the restriction here.
            if (identifier != null && identifier.IndexOf(".", StringComparison.Ordinal) == -1 && configuration.Resolver.GetType() == typeof(ODataUriResolver))
            {
                boundParameters = null;
                matchingOperation = null;
                return false;
            }

            // TODO: update code that is duplicate between operation and operation import, add more tests.
            matchingOperation = null;
            ICollection<FunctionParameterToken> splitParameters;
            if (!String.IsNullOrEmpty(parenthesisExpression))
            {
                if (!FunctionParameterParser.TrySplitOperationParameters(parenthesisExpression, configuration, out splitParameters))
                {
                    IEdmOperation possibleMatchingOperation = null;

                    // Look for an overload that returns an entity collection by the specified name. If so parenthesis is just key parameters.
                    if (FunctionOverloadResolver.ResolveOperationFromList(identifier, new List<string>(), bindingType, configuration.Model, out possibleMatchingOperation, configuration.Resolver))
                    {
                        IEdmCollectionTypeReference collectionReturnType = possibleMatchingOperation.ReturnType as IEdmCollectionTypeReference;
                        if (collectionReturnType != null && collectionReturnType.ElementType().IsEntity())
                        {
                            matchingOperation = possibleMatchingOperation;
                            boundParameters = null;
                            return true;
                        }
                        else
                        {
                            throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_SegmentDoesNotSupportKeyPredicates(identifier));
                        }
                    }

                    boundParameters = null;
                    return false;
                }
            }
            else
            {
                splitParameters = new Collection<FunctionParameterToken>();
            }

            // Resolve the specific overload.
            if (FunctionOverloadResolver.ResolveOperationFromList(identifier, splitParameters.Select(k => k.ParameterName).ToList(), bindingType, configuration.Model, out matchingOperation, configuration.Resolver))
            {
                boundParameters = FunctionCallBinder.BindSegmentParameters(configuration, matchingOperation, splitParameters);
                return true;
            }

            boundParameters = null;
            return false;
        }

        /// <summary>
        /// Checks for single result, otherwise throws.
        /// </summary>
        /// <param name="isSingleResult">indicates whether the current result is single result or not.</param>
        /// <param name="identifier">current segment identifier.</param>
        private static void CheckSingleResult(bool isSingleResult, string identifier)
        {
            if (!isSingleResult)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_CannotQueryCollections(identifier));
            }
        }

        /// <summary>
        /// Tries to get the next segment's text to parse.
        /// </summary>
        /// <param name="segmentText">The segment text to parse.</param>
        /// <returns>Whether there was a next segment.</returns>
        private bool TryGetNextSegmentText(out string segmentText)
        {
            return TryGetNextSegmentText(false, out segmentText);
        }

        /// <summary>
        /// Tries to get the next segment's text to parse. Should not be called except by the other overload which does not have the extra parameter.
        /// </summary>
        /// <param name="previousSegmentWasEscapeMarker">Whether the previous segment was an escape marker.</param>
        /// <param name="segmentText">The segment text to parse.</param>
        /// <returns>Whether there was a next segment.</returns>
        private bool TryGetNextSegmentText(bool previousSegmentWasEscapeMarker, out string segmentText)
        {
            if (this.segmentQueue.Count == 0)
            {
                segmentText = null;
                return false;
            }

            segmentText = this.segmentQueue.Dequeue();

            // If this segment is the special escape-marker segment, then remember that the next segment cannot be a key,
            // even if we are in key-as-segments mode. Essentially, it is an escape into 'metadata-space', so to speak.
            //
            // DEVNOTE (mmeehan): We went back and forth several times on whether this should be allowed everywhere or only
            // where a key could appear. We landed on allowing it absolutely everywhere for several reasons:
            //   1) The WCF DS client naively adds the escape marker before all type segments, regardless of whether the
            //      prior segment is a collection.
            //   2) The WCF DS server already allowed the escape marker almost everywhere in 5.3
            //   3) It's better to be either extremely loose or extremely strict than allow it in some cases and not in others.
            // Note that this is not publicly documented in OData V3 nor is it planned to be documented in OData V4, but it
            // is a part of supporting the Key-As-Segment conventions that are used by many Azure services.
            if (segmentText == "$")
            {
                this.nextSegmentMustReferToMetadata = true;
                return TryGetNextSegmentText(true, out segmentText);
            }

            if (!previousSegmentWasEscapeMarker)
            {
                this.nextSegmentMustReferToMetadata = false;
            }

            if (this.parsedSegments.Count > 0)
            {
                ThrowIfMustBeLeafSegment(this.parsedSegments[this.parsedSegments.Count - 1]);
            }

            return true;
        }

        /// <summary>
        /// Tries to handle the given text as a key if the URL conventions support it and it was not preceded by an escape segment.
        /// </summary>
        /// <param name="segmentText">The text which might be a key.</param>
        /// <returns>Whether or not the text was handled as a key.</returns>
        private bool TryHandleAsKeySegment(string segmentText)
        {
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            KeySegment previousKeySegment = this.FindPreviousKeySegment();

            KeySegment keySegment;
            if (!this.nextSegmentMustReferToMetadata && SegmentKeyHandler.TryHandleSegmentAsKey(segmentText, previous, previousKeySegment, this.configuration.UrlKeyDelimiter, this.configuration.Resolver, out keySegment, this.configuration.EnableUriTemplateParsing))
            {
                this.parsedSegments.Add(keySegment);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Find the ParentNode's key segment
        /// </summary>
        /// <returns>The parent nodes key segment.</returns>
        private KeySegment FindPreviousKeySegment()
        {
            return (KeySegment)this.parsedSegments.LastOrDefault(s => s is KeySegment);
        }

        /// <summary>
        /// Throws if the given segment must be a leaf, as a later segment is being created.
        /// </summary>
        /// <param name="previous">The previous segment which may need to be a leaf.</param>
        private static void ThrowIfMustBeLeafSegment(ODataPathSegment previous)
        {
            OperationImportSegment operationImportSegment = previous as OperationImportSegment;
            if (operationImportSegment != null)
            {
                foreach (var operationImport in operationImportSegment.OperationImports)
                {
                    if (operationImport.IsActionImport() || (operationImport.IsFunctionImport() && !((IEdmFunctionImport)operationImport).Function.IsComposable))
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
                    }
                }
            }

            OperationSegment operationSegment = previous as OperationSegment;
            if (operationSegment != null)
            {
                foreach (var operation in operationSegment.Operations)
                {
                    if (operation.IsAction() || (operation.IsFunction() && !((IEdmFunction)operation).IsComposable))
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
                    }
                }
            }

            if (previous.TargetKind == RequestTargetKind.Batch                  /* $batch */
                || previous.TargetKind == RequestTargetKind.Metadata            /* $metadata */
                || previous.TargetKind == RequestTargetKind.PrimitiveValue      /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.DynamicValue   /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.EnumValue           /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.MediaResource       /* $value or Media resource, see TryCreateValueSegment/CreateNamedStreamSegment */
                || previous.TargetKind == RequestTargetKind.VoidOperation       /* service operation with void return type */
                || previous.TargetKind == RequestTargetKind.Nothing             /* Nothing targeted (e.g. PathTemplate) */)
            {
                // Nothing can come after a $metadata, $value or $batch segment.
                // Nothing can come after a service operation with void return type.
                // Nothing can come after a collection property.
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
            }
        }

        /// <summary>
        /// Try to handle the segment as $count.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $count.</returns>
        private bool TryCreateCountSegment(string identifier, string parenthesisExpression)
        {
            if (!IdentifierIs(UriQueryConstants.CountSegment, identifier))
            {
                return false;
            }

            // The server used to allow arbitrary key expressions after $count because this check was missing.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            if ((previous.TargetKind != RequestTargetKind.Resource || previous.SingleResult) && previous.TargetKind != RequestTargetKind.Collection)
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_CountNotSupported(previous.Identifier));
            }

            this.parsedSegments.Add(CountSegment.Instance);
            return true;
        }

        /// <summary>
        /// Creates a filter clause from a navigation source and filter expression.
        /// </summary>
        /// <param name="navigationSource">Navigation source to which the filter refers.</param>
        /// <param name="targetEdmType">Target type for the entity being referenced.</param>
        /// <param name="filter">Filter expression.</param>
        /// <returns>Filter clause with the navigation source and filter information.</returns>
        private FilterClause GenerateFilterClause(IEdmNavigationSource navigationSource, IEdmType targetEdmType, string filter)
        {
            Debug.Assert(navigationSource != null, "navigationSource != null");
            Debug.Assert(targetEdmType != null, "targetEdmType != null");
            Debug.Assert(filter.Length > 0, "filter.Length > 0");

            ODataPathInfo currentOdataPathInfo = new ODataPathInfo(targetEdmType, navigationSource);

            // Get the syntactic representation of the filter expression.
            UriQueryExpressionParser expressionParser = new UriQueryExpressionParser(
                configuration.Settings.FilterLimit, configuration.EnableCaseInsensitiveUriFunctionIdentifier);
            QueryToken filterToken = expressionParser.ParseFilter(filter);

            // Bind it to metadata.
            BindingState state = new BindingState(configuration, currentOdataPathInfo.Segments.ToList())
            {
                ImplicitRangeVariable = NodeFactory.CreateImplicitRangeVariable(
                    currentOdataPathInfo.TargetEdmType.ToTypeReference(), currentOdataPathInfo.TargetNavigationSource)
            };
            state.RangeVariables.Push(state.ImplicitRangeVariable);

            MetadataBinder binder = new MetadataBinder(state);
            FilterBinder filterBinder = new FilterBinder(binder.Bind, state);

            return filterBinder.BindFilter(filterToken);
        }

        /// <summary>
        /// Try to handle the segment as $filter.
        /// </summary>
        /// <param name="segmentText">The raw segment text.</param>
        /// <returns>Whether the segment was $filter.</returns>
        /// <remarks>
        /// $filter path segment is different from existing path segments in that it strictly
        /// follows the format of "$filter(expression)", expression could be an alias or inline expression
        /// that resolves to a boolean. Thus, this function should validate the format of the path
        /// segment closely.
        /// </remarks>
        private bool TryCreateFilterSegment(string segmentText)
        {
            Debug.Assert(segmentText != null, "segmentText != null");
            Debug.Assert(parsedSegments.Count > 0, "parsedSegments.Count > 0");

            /*
             * 1) Check whether the path segment starts with $filter.
             * 2) Ensure that the expression that follows the identifier is enclosed in parentheses.
             * 3) Extract the expression and validate it syntactically.
             * 4) Add the filter segment to list of parsed segments.
             */

            // 1) Check whether the path segment starts with $filter. Past this point, we will throw invalid syntax exceptions
            // because we will assume that the user is attempting to use the $filter path segment.
            if (!segmentText.StartsWith(
                UriQueryConstants.FilterSegment,
                this.configuration.EnableCaseInsensitiveUriFunctionIdentifier ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal))
            {
                return false;
            }

            // 2) The expression that follows UriQueryConstants.FilterSegment should be enclosed in parentheses.
            // Step 3) performs the expression validation (e.g. illegal characters).
            //      - the length of this segment should be longer than "$filter()", indicating that there's a valid expression
            int index = UriQueryConstants.FilterSegment.Length;
            if (segmentText.Length <= index + 2 || segmentText[index] != '(' || segmentText[segmentText.Length - 1] != ')')
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_FilterPathSegmentSyntaxError);
            }

            // 3) Extract the expression and perform the rest of the validations on it.
            if (lastNavigationSource == null)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_NoNavigationSourceFound(UriQueryConstants.FilterSegment));
            }

            if (lastNavigationSource is IEdmSingleton || this.parsedSegments.Last() is KeySegment)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_CannotApplyFilterOnSingleEntities(lastNavigationSource.Name));
            }

            // The "index + 1" is to move past the '(' and the '-2' accounts for the two paren characters.
            string filterExpression = segmentText.Substring(index + 1, segmentText.Length - UriQueryConstants.FilterSegment.Length - 2);

            // If the previous segment is a type segment, then the entity set has been casted and the filter expression should reflect the cast.
            TypeSegment typeSegment = this.parsedSegments.Last() as TypeSegment;

            // Creating a filter clause helps validate the expression and create the expression nodes (including nested parameter aliases).
            FilterClause filterClause = GenerateFilterClause(
                lastNavigationSource,
                typeSegment == null ? lastNavigationSource.EntityType() : typeSegment.TargetEdmType,
                filterExpression);

            // 4) Create filter segment with the validated expression and add it to parsed segments.
            FilterSegment filterSegment = new FilterSegment(filterClause.Expression, filterClause.RangeVariable, lastNavigationSource);
            this.parsedSegments.Add(filterSegment);

            return true;
        }

        /// <summary>
        /// Try to handle the segment as $each.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $each.</returns>
        private bool TryCreateEachSegment(string identifier, string parenthesisExpression)
        {
            if (!IdentifierIs(UriQueryConstants.EachSegment, identifier))
            {
                return false;
            }

            // $each is not supposed to have parenthesis expressions after it.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment prevSegment = this.parsedSegments.Last();
            if (lastNavigationSource == null)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_NoNavigationSourceFound(UriQueryConstants.EachSegment));
            }

            if (lastNavigationSource is IEdmSingleton || prevSegment is KeySegment)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_CannotApplyEachOnSingleEntities(lastNavigationSource.Name));
            }

            EachSegment eachSegment = new EachSegment(lastNavigationSource, prevSegment.TargetEdmType.AsElementType());
            this.parsedSegments.Add(eachSegment);

            return true;
        }

        /// <summary>
        /// Tries to handle the segment as $ref. If it is $ref, then the rest of the path will be parsed/validated in this call.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the text was $ref.</returns>
        private bool TryCreateEntityReferenceSegment(string identifier, string parenthesisExpression)
        {
            if (!this.IdentifierIs(UriQueryConstants.RefSegment, identifier))
            {
                return false;
            }

            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            // The algorithm below looks for the last NavigationPropertySegment before the $ref segment. Whether a NavPropSeg exists
            // becomes two different code paths:
            // 1) Backwards compatibility behavior (<= ODL 7.4.x): If the NavPropSeg exists, then it is expected to either be before
            // KeySegments or before the $ref (i.e. NavPropSeg/KeySeg/KeySeg/.../$ref or NavPropSeg/$ref). Then the NavPropSeg is replaced
            // with NavigationPropertyLinkSegment. In a previous implementation, if a NavPropSeg didn't exist before KeySegments or
            // $ref, then this function would throw. This was not correct as $ref can apply to entity sets and similar segments
            // (e.g. TypeSegment and FilterSegment), and therefore 2) below is implemented to support those scenarios.
            // 2) If the NavPropSeg does not exist, then this algorithm appends a ReferenceSegment to the existing list of parsed segments.

            // Determine the index of the NavigationPropertySegment in either of the following formats:
            // NavPropSeg/KeySeg/KeySeg/.../$ref or NavPropSeg/$ref
            int indexOfNavPropSeg = this.parsedSegments.Count - 1;
            while (indexOfNavPropSeg > 0 && this.parsedSegments[indexOfNavPropSeg] is KeySegment)
            {
                --indexOfNavPropSeg;
            }

            NavigationPropertySegment navPropSegment = this.parsedSegments[indexOfNavPropSeg] as NavigationPropertySegment;
            if (navPropSegment != null)
            {
                if (navPropSegment.TargetKind != RequestTargetKind.Resource)
                {
                    throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.PathParser_EntityReferenceNotSupported(navPropSegment.Identifier));
                }

                // If this is a navigation property, find target navigation source
                Debug.Assert(indexOfNavPropSeg - 1 >= 0, "indexOfNavPropSeg - 1 >= 0");
                IEdmPathExpression bindingPath;
                var targetNavigationSource = this.parsedSegments[indexOfNavPropSeg - 1].TargetEdmNavigationSource.FindNavigationTarget(
                    navPropSegment.NavigationProperty, BindingPathHelper.MatchBindingPath, this.parsedSegments, out bindingPath);

                // If we can't compute the target navigation source, then pretend the navigation property does not exist
                if (targetNavigationSource == null)
                {
                    throw ExceptionUtil.CreateResourceNotFoundError(navPropSegment.NavigationProperty.Name);
                }

                // Create new NavigationPropertyLinkSegment
                var navPropLinkSegment = new NavigationPropertyLinkSegment(navPropSegment.NavigationProperty, targetNavigationSource);

                // Replace the NavigationPropertySegment with the $ref NavigationPropertyLinkSegment
                this.parsedSegments[indexOfNavPropSeg] = navPropLinkSegment;
            }
            else
            {
                ODataPathSegment lastSegment = this.parsedSegments.Last();
                if (lastSegment.TargetKind != RequestTargetKind.Resource)
                {
                    throw ExceptionUtil.CreateBadRequestError(
                        ODataErrorStrings.PathParser_EntityReferenceNotSupported(lastSegment.Identifier));
                }

                ReferenceSegment referenceSegment = new ReferenceSegment(lastNavigationSource);
                referenceSegment.SingleResult = lastSegment.SingleResult;
                this.parsedSegments.Add(referenceSegment);
            }

            // Nothing is allowed after $ref.
            string nextSegmentText;
            if (this.TryGetNextSegmentText(out nextSegmentText))
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(UriQueryConstants.RefSegment));
            }

            return true;
        }

        /// <summary>
        /// Tries to bind a key from the parenthetical section of a segment.
        /// </summary>
        /// <param name="parenthesesSection">The section of the segment inside parentheses, or null if there was none.</param>
        /// <returns>Returns True if a key segment was found and added from the parentheses section otherwise false.</returns>
        private bool TryBindKeyFromParentheses(string parenthesesSection)
        {
            if (parenthesesSection == null)
            {
                return false;
            }

            ODataPathSegment keySegment;
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            KeySegment previousKeySegment = this.FindPreviousKeySegment();
            if (!SegmentKeyHandler.TryCreateKeySegmentFromParentheses(previous, previousKeySegment, parenthesesSection, this.configuration.Resolver, out keySegment, this.configuration.EnableUriTemplateParsing))
            {
                return false;
            }

            this.parsedSegments.Add(keySegment);
            return true;
        }

        /// <summary>
        /// Try to handle the segment as $value.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $value.</returns>
        private bool TryCreateValueSegment(string identifier, string parenthesisExpression)
        {
            if (!this.IdentifierIs(UriQueryConstants.ValueSegment, identifier))
            {
                return false;
            }

            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];

            ODataPathSegment segment = new ValueSegment(previous.EdmType);
            if ((previous.TargetKind == RequestTargetKind.Primitive)
                || (previous.TargetKind == RequestTargetKind.Enum))
            {
                segment.CopyValuesFrom(previous);
            }
            else
            {
                segment.TargetEdmType = previous.TargetEdmType;
            }

            segment.Identifier = UriQueryConstants.ValueSegment;
            segment.SingleResult = true;
            CheckSingleResult(previous.SingleResult, previous.Identifier);

            if (previous.TargetKind == RequestTargetKind.Primitive)
            {
                segment.TargetKind = RequestTargetKind.PrimitiveValue;
            }
            else if (previous.TargetKind == RequestTargetKind.Enum)
            {
                segment.TargetKind = RequestTargetKind.EnumValue;
            }
            else if (previous.TargetKind == RequestTargetKind.Dynamic)
            {
                segment.TargetKind = RequestTargetKind.DynamicValue;
            }
            else
            {
                // If the previous segment is an entity, we expect it to be an MLE. We cannot validate our assumption
                // until later when we get the actual instance of the entity because the type hierarchy can contain
                // a mix of MLE and non-MLE types.
                segment.TargetKind = RequestTargetKind.MediaResource;
            }

            this.parsedSegments.Add(segment);
            return true;
        }

        /// <summary>
        /// Creates a new segment for an unknown path segment or an open property.
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="identifier">name of the segment.</param>
        /// <param name="parenthesisExpression">whether this segment has a query portion or not.</param>
        private void CreateDynamicPathSegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            if (this.configuration.ParseDynamicPathSegmentFunc != null)
            {
                var segments = this.configuration.ParseDynamicPathSegmentFunc(previous, identifier, parenthesisExpression);
                this.parsedSegments.AddRange(segments);
                return;
            }

            if (previous == null)
            {
                throw ExceptionUtil.CreateResourceNotFoundError(identifier);
            }

            CheckSingleResult(previous.SingleResult, previous.Identifier);

            // Handle an open type property. If the current leaf isn't an
            // object (which implies it's already an open type), then
            // it should be marked as an open type.
            if ((previous.TargetEdmType != null && !previous.TargetEdmType.IsOpen()))
            {
                throw ExceptionUtil.CreateResourceNotFoundError(identifier);
            }

            // Open navigation properties are not supported on OpenTypes.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.OpenNavigationPropertiesNotSupportedOnOpenTypes(identifier));
            }

            ODataPathSegment segment = new DynamicPathSegment(identifier);
            this.parsedSegments.Add(segment);
        }

        /// <summary>
        /// Creates a named stream segment
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="streamProperty">stream property to create the segment for.</param>
        private void CreateNamedStreamSegment(ODataPathSegment previous, IEdmProperty streamProperty)
        {
            Debug.Assert(streamProperty.Type.IsStream(), "streamProperty.Type.IsStream()");

            // Handle Named Stream.
            ODataPathSegment segment = new PropertySegment((IEdmStructuralProperty)streamProperty);
            segment.TargetKind = RequestTargetKind.MediaResource;
            segment.SingleResult = true;
            segment.TargetEdmType = previous.TargetEdmType;
            Debug.Assert(segment.Identifier != UriQueryConstants.ValueSegment, "'$value' cannot be the name of a named stream.");

            this.parsedSegments.Add(segment);
        }

        /// <summary>Creates the first <see cref="ODataPathSegment"/> for a request.</summary>
        /// <param name="segmentText">The text of the segment.</param>
        private void CreateFirstSegment(string segmentText)
        {
            if (segmentText[segmentText.Length - 1] == ':' && this.TryCreateEscapeFunctionSegment(segmentText))
            {
                return;
            }

            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(segmentText, out identifier, out parenthesisExpression);
            Debug.Assert(identifier != null, "identifier != null");

            // Look for well-known system resource points.
            if (this.IdentifierIs(UriQueryConstants.MetadataSegment, identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.parsedSegments.Add(MetadataSegment.Instance);
                return;
            }

            if (this.IdentifierIs(UriQueryConstants.BatchSegment, identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.parsedSegments.Add(BatchSegment.Instance);
                return;
            }

            if (this.IdentifierIs(UriQueryConstants.CountSegment, identifier))
            {
                // $count on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_CountOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.FilterSegment, identifier))
            {
                // $filter on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_FilterOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.EachSegment, identifier))
            {
                // $each on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_EachOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.RefSegment, identifier))
            {
                // $ref on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_RefOnRoot);
            }

            if (this.configuration.BatchReferenceCallback != null && ContentIdRegex.IsMatch(identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                BatchReferenceSegment crossReferencedSegment = this.configuration.BatchReferenceCallback(identifier);
                if (crossReferencedSegment != null)
                {
                    this.parsedSegments.Add(crossReferencedSegment);
                    return;
                }
            }

            if (this.TryCreateSegmentForNavigationSource(identifier, parenthesisExpression))
            {
                return;
            }

            if (this.TryCreateSegmentForOperationImport(identifier, parenthesisExpression))
            {
                return;
            }

            this.CreateDynamicPathSegment(null, identifier, parenthesisExpression);
        }

        /// <summary>Creates a <see cref="ODataPathSegment"/> that an escape function can bind to, which can be a
        /// a navigation source or an operation import it is the first segment to be created. Otherwise, it can be a 
        /// filter segment, property segment, typecast segment, operation segment or a key segment.
        /// </summary>
        /// <param name="segmentText">The text of the segment.</param>
        /// <returns>boolean value.</returns>
        private bool BindSegmentBeforeEscapeFunction(string segmentText)
        {
            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(segmentText, out identifier, out parenthesisExpression);

            if (this.parsedSegments.Count == 0)
            {
                if (this.TryCreateSegmentForNavigationSource(identifier, parenthesisExpression))
                {
                    return true;
                }

                if (this.TryCreateSegmentForOperationImport(identifier, parenthesisExpression))
                {
                    return true;
                }
            }
            else
            {
                if (this.TryCreateFilterSegment(segmentText))
                {
                    return true;
                }

                ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];

                if (this.TryCreatePropertySegment(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // Type cast
                if (this.TryCreateTypeNameSegment(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // Operation
                if (this.TryCreateSegmentForOperation(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // For KeyAsSegment, try to handle as key segment
                if (this.configuration.UrlKeyDelimiter.EnableKeyAsSegment && this.TryHandleAsKeySegment(segmentText))
                {
                    return true;
                }
            }

            return false;
        }

        private bool TryCreatePropertySegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            // property if previous is single
            if (previous.SingleResult)
            {
                // if its not one of the recognized special segments, then it must be a property, type-segment, or key value.
                Debug.Assert(
                    previous.TargetKind == RequestTargetKind.Resource
                    || previous.TargetKind == RequestTargetKind.Dynamic,
                    "previous.TargetKind(" + previous.TargetKind + ") can have properties");

                if (previous.TargetEdmType == null)
                {
                    // A segment will correspond to a property in the object model;
                    // if we are processing an open type, anything further in the
                    // URI also represents an open type property.
                    Debug.Assert(previous.TargetKind == RequestTargetKind.Dynamic, "For open properties, the target resource type must be null");
                }
                else
                {
                    // if the segment corresponds to a declared property, handle it
                    // otherwise, fall back to type-segments, actions, and dynamic/open properties
                    IEdmProperty projectedProperty;
                    if (this.TryBindProperty(identifier, out projectedProperty))
                    {
                        CheckSingleResult(previous.SingleResult, previous.Identifier);
                        this.CreatePropertySegment(previous, projectedProperty, parenthesisExpression);

                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Tries to parse a segment as an entity set or singleton.
        /// </summary>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The parenthesis expression</param>
        /// <returns>Whether or not the identifier referred to an entity set or singleton.</returns>
        private bool TryCreateSegmentForNavigationSource(string identifier, string parenthesisExpression)
        {
            ODataPathSegment segment = null;
            IEdmEntitySet targetEdmEntitySet;
            IEdmSingleton targetEdmSingleton;

            IEdmNavigationSource source = this.configuration.Resolver.ResolveNavigationSource(this.configuration.Model, identifier);

            if ((targetEdmEntitySet = source as IEdmEntitySet) != null)
            {
                segment = new EntitySetSegment(targetEdmEntitySet) { Identifier = identifier };
            }
            else if ((targetEdmSingleton = source as IEdmSingleton) != null)
            {
                segment = new SingletonSegment(targetEdmSingleton) { Identifier = identifier };
            }

            if (segment != null)
            {
                this.parsedSegments.Add(segment);
                this.TryBindKeyFromParentheses(parenthesisExpression);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Tries to parse a segment as a functionImport or actionImport.
        /// </summary>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The query portion</param>
        /// <returns>Whether or not the identifier referred to an action.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private bool TryCreateSegmentForOperationImport(string identifier, string parenthesisExpression)
        {
            ICollection<OperationSegmentParameter> resolvedParameters;
            IEdmOperationImport singleImport;
            if (!TryBindingParametersAndMatchingOperationImport(identifier, parenthesisExpression, this.configuration, out resolvedParameters, out singleImport))
            {
                return false;
            }

            IEdmTypeReference returnType = singleImport.Operation.ReturnType;
            IEdmEntitySetBase targetset = null;

            if (returnType != null)
            {
                targetset = singleImport.GetTargetEntitySet(null, this.configuration.Model);
            }

            ODataPathSegment segment = new OperationImportSegment(singleImport, targetset, resolvedParameters);

            this.parsedSegments.Add(segment);

            this.TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(parenthesisExpression, returnType, resolvedParameters, segment);

            return true;
        }

        /// <summary>
        /// Tries the bind key segment if no resolved parameters and parenthesis value exists.
        /// </summary>
        /// <param name="parenthesisExpression">The parenthesis expression.</param>
        /// <param name="returnType">Type of the return.</param>
        /// <param name="resolvedParameters">The resolved parameters.</param>
        /// <param name="segment">The segment.</param>
        private void TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(string parenthesisExpression, IEdmTypeReference returnType, ICollection<OperationSegmentParameter> resolvedParameters, ODataPathSegment segment)
        {
            IEdmCollectionTypeReference collectionTypeReference = returnType as IEdmCollectionTypeReference;
            if (collectionTypeReference != null && collectionTypeReference.ElementType().IsEntity() && resolvedParameters == null && parenthesisExpression != null)
            {
                // The parameters in the parenthesis is a key segment.
                if (this.TryBindKeyFromParentheses(parenthesisExpression))
                {
                    ThrowIfMustBeLeafSegment(segment);
                }
            }
        }

        /// <summary>
        /// Tries to parse a segment as a function or action.
        /// </summary>
        /// <param name="previousSegment">The previous segment before the operation to be invoked.</param>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The query portion</param>
        /// <returns>Whether or not the identifier referred to an action.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private bool TryCreateSegmentForOperation(ODataPathSegment previousSegment, string identifier, string parenthesisExpression)
        {
            // Parse Arguments syntactically
            IEdmType bindingType = null;
            if (previousSegment != null)
            {
                // Use TargetEdmType for EachSegment to represent a pseudo-single entity.
                bindingType = (previousSegment is EachSegment) ? previousSegment.TargetEdmType : previousSegment.EdmType;
            }

            ICollection<OperationSegmentParameter> resolvedParameters;
            IEdmOperation singleOperation;
            if (!TryBindingParametersAndMatchingOperation(identifier, parenthesisExpression, bindingType, this.configuration, out resolvedParameters, out singleOperation))
            {
                return false;
            }

            if (!UriEdmHelpers.IsBindingTypeValid(bindingType))
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_OperationSegmentBoundToANonEntityType);
            }

            if (previousSegment != null && bindingType == null)
            {
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_CallingFunctionOnOpenProperty(identifier));
            }

            CreateOperationSegment(previousSegment, singleOperation, resolvedParameters, identifier, parenthesisExpression);

            return true;
        }

        private void CreateOperationSegment(ODataPathSegment previousSegment, IEdmOperation singleOperation, ICollection<OperationSegmentParameter> resolvedParameters, string identifier, string parenthesisExpression)
        {
            IEdmTypeReference returnType = singleOperation.ReturnType;
            IEdmEntitySetBase targetset = null;

            if (returnType != null)
            {
                IEdmNavigationSource source = previousSegment == null ? null : previousSegment.TargetEdmNavigationSource;
                targetset = singleOperation.GetTargetEntitySet(source, this.configuration.Model);
            }

            // If previous segment is cross-referenced then we explicitly disallow the service action call
            if (previousSegment is BatchReferenceSegment)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_BatchedActionOnEntityCreatedInSameChangeset(identifier));
            }

            CheckOperationTypeCastSegmentRestriction(singleOperation);

            ODataPathSegment segment = new OperationSegment(singleOperation, resolvedParameters, targetset)
            {
                Identifier = identifier
            };

            this.parsedSegments.Add(segment);
            this.TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(parenthesisExpression, returnType, resolvedParameters, segment);

            return;
        }

        /// <summary>
        /// Creates the next segment.
        /// </summary>
        /// <param name="text">The text for the next segment.</param>
        private void CreateNextSegment(string text)
        {
            if (text[text.Length - 1] == ':' && this.TryCreateEscapeFunctionSegment(text))
            {
                return;
            }

            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(text, out identifier, out parenthesisExpression);
            /*
             * For Non-KeyAsSegment, try to handle it as a key property value, unless it was preceded by an escape - marker segment('$').
             * For KeyAsSegment, the following precedence rules should be supported[ODATA - 799]:
             * Try to match an OData segment(starting with “$”).
             *   - Note: $filter path segment is a special case that has the format "$filter(@a)", where @a represents an alias.
             * Try to match an alias - qualified bound action name, bound function overload, or type name.
             * Try to match a namespace-qualified bound action name, bound function overload, or type name.
             * Try to match an unqualified bound action name, bound function overload, or type name in a default namespace.
             * Treat as a key.
             */

            // $value
            if (this.TryCreateValueSegment(identifier, parenthesisExpression))
            {
                return;
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            if (previous.TargetKind == RequestTargetKind.Primitive)
            {
                // only $value is allowed after a primitive property
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_ValueSegmentAfterScalarPropertySegment(previous.Identifier, text));
            }

            // $ref
            if (this.TryCreateEntityReferenceSegment(identifier, parenthesisExpression))
            {
                return;
            }

            // $count
            if (this.TryCreateCountSegment(identifier, parenthesisExpression))
            {
                return;
            }

            // $filter
            if (this.TryCreateFilterSegment(text))
            {
                return;
            }

            // $each
            if (this.TryCreateEachSegment(identifier, parenthesisExpression))
            {
                return;
            }

            if (this.TryCreatePropertySegment(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // Type cast
            if (this.TryCreateTypeNameSegment(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // Operation
            if (this.TryCreateSegmentForOperation(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // For KeyAsSegment, try to handle as key segment
            if (this.configuration.UrlKeyDelimiter.EnableKeyAsSegment && this.TryHandleAsKeySegment(text))
            {
                return;
            }

            // Parse as path template segment if EnableUriTemplateParsing is enabled.
            if (this.configuration.EnableUriTemplateParsing && UriTemplateParser.IsValidTemplateLiteral(text))
            {
                this.parsedSegments.Add(new PathTemplateSegment(text));
                return;
            }

            // Dynamic property
            this.CreateDynamicPathSegment(previous, identifier, parenthesisExpression);
        }

        private bool TryCreateEscapeFunctionSegment(string segmentText)
        {
            Debug.Assert(segmentText[segmentText.Length - 1] == ':');

            int numberOfSegmentsParsed = this.parsedSegments.Count;
            string newSegmentText = segmentText.Substring(0, segmentText.Length - 1);

            // Try to binding the segment optimisitically to which the escape function must bind to
            if (newSegmentText.Length > 0 && !BindSegmentBeforeEscapeFunction(newSegmentText))
            {
                return false;
            }

            if (this.TryBindEscapeFunction())
            {
                return true;
            }
            else
            {
                // The caller of this function will try binding the original segment as key value.
                // We need to roll back the optimistic binding that we did in this step.
                while (this.parsedSegments.Count > numberOfSegmentsParsed)
                {
                    // Keep on poping the last segment. 
                    this.parsedSegments.RemoveAt(this.parsedSegments.Count - 1);
                }
            }

            return false;
        }

        /// <summary>
        /// Tries to bind the identifier as a property.
        /// </summary>
        /// <param name="identifier">The identifier to bind.</param>
        /// <param name="projectedProperty">The property, if one was found.</param>
        /// <returns>Whether a property matching the identifier was found.</returns>
        private bool TryBindProperty(string identifier, out IEdmProperty projectedProperty)
        {
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            Debug.Assert(previous.TargetEdmType != null, "Previous wasn't open, so it should have a resource type");
            Debug.Assert(previous.TargetEdmNavigationSource == null || previous.TargetEdmType.IsStructuredOrStructuredCollectionType(), "if the previous segment has a target resource set, then its target resource type must be an entity or a complex");

            // Note that we try resolve the property on the root entity type for the set. Properties/Name streams defined on derived types
            // are not supported. This is a general problem with properties as we don't have the entity instance here to validate
            // whether the property exists.
            projectedProperty = null;
            var structuredType = previous.TargetEdmType as IEdmStructuredType;
            if (structuredType == null)
            {
                var collectionType = previous.TargetEdmType as IEdmCollectionType;
                if (collectionType != null)
                {
                    structuredType = collectionType.ElementType.Definition as IEdmStructuredType;
                }
            }

            if (structuredType == null)
            {
                return false;
            }

            projectedProperty = this.configuration.Resolver.ResolveProperty(structuredType, identifier);
            return projectedProperty != null;
        }

        private bool TryBindEscapeFunction()
        {
            ODataPathSegment previous = null;
            if (this.parsedSegments.Count > 0)
            {
                previous = this.parsedSegments[this.parsedSegments.Count - 1];
            }

            string newIdentifier, newParenthesisExpression;
            bool anotherEscapeFunctionStarts;
            IEdmFunction escapeFunction;
            if (this.TryResolveEscapeFunction(previous, out newIdentifier, out newParenthesisExpression, out anotherEscapeFunctionStarts, out escapeFunction))
            {
                ICollection<FunctionParameterToken> splitParameters;
                FunctionParameterParser.TrySplitOperationParameters(newParenthesisExpression, configuration, out splitParameters);
                ICollection<OperationSegmentParameter> resolvedParameters = FunctionCallBinder.BindSegmentParameters(configuration, escapeFunction, splitParameters);
                CreateOperationSegment(previous, escapeFunction, resolvedParameters, newIdentifier, newParenthesisExpression);
                if (anotherEscapeFunctionStarts)
                {
                    // When we encounter an invalid escape function as a parameter, we should throw.
                    // i.e. we should throw for entitySet(key):/ComposableEscapeFunctionPath::/InvalidEscapeFunction
                    if (!TryBindEscapeFunction())
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_ComposableEscapeFunctionShouldHaveValidParameter);
                    }
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Tries to create a type name segment if the given identifier refers to a known type.
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="identifier">The current raw segment identifier being interpreted.</param>
        /// <param name="parenthesisExpression">Parenthesis expression of this segment.</param>
        /// <returns>Whether or not a type segment was created for the identifier.</returns>
        private bool TryCreateTypeNameSegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            if (identifier.IndexOf('.') < 0)
            {
                return false;
            }

            IEdmType targetEdmType;
            if (previous.TargetEdmType == null || (targetEdmType = UriEdmHelpers.FindTypeFromModel(this.configuration.Model, identifier, this.configuration.Resolver)) == null)
            {
                return false;
            }

            // if the new type segment prevents any results from possibly being returned, then short-circuit and throw a 404.
            IEdmType previousEdmType = previous.TargetEdmType;
            Debug.Assert(previousEdmType != null, "previous.TargetEdmType != null");

            if (previousEdmType.TypeKind == EdmTypeKind.Collection)
            {
                previousEdmType = ((IEdmCollectionType)previousEdmType).ElementType.Definition;
            }

            if (!targetEdmType.IsOrInheritsFrom(previousEdmType) && !previousEdmType.IsOrInheritsFrom(targetEdmType))
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_InvalidTypeIdentifier_UnrelatedType(targetEdmType.FullTypeName(), previousEdmType.FullTypeName()));
            }

            CheckTypeCastSegmentRestriction(previous, targetEdmType);

            // We want the type of the type segment to be a collection if the previous segment was a collection
            IEdmType actualTypeOfTheTypeSegment = targetEdmType;

            if (previous.EdmType.TypeKind == EdmTypeKind.Collection)
            {
                // creating a new collection type here because the type in the request is just the item type, there is no user-provided collection type.
                var actualEntityTypeOfTheTypeSegment = actualTypeOfTheTypeSegment as IEdmEntityType;
                if (actualEntityTypeOfTheTypeSegment != null)
                {
                    actualTypeOfTheTypeSegment = new EdmCollectionType(new EdmEntityTypeReference(actualEntityTypeOfTheTypeSegment, false));
                }
                else
                {
                    // Complex collection supports type cast too.
                    var actualComplexTypeOfTheTypeSegment = actualTypeOfTheTypeSegment as IEdmComplexType;
                    if (actualComplexTypeOfTheTypeSegment != null)
                    {
                        actualTypeOfTheTypeSegment = new EdmCollectionType(new EdmComplexTypeReference(actualComplexTypeOfTheTypeSegment, false));
                    }
                    else
                    {
                        throw new ODataException(Strings.PathParser_TypeCastOnlyAllowedAfterStructuralCollection(identifier));
                    }
                }
            }

            var typeNameSegment = (ODataPathSegment)new TypeSegment(actualTypeOfTheTypeSegment, previous.EdmType, previous.TargetEdmNavigationSource)
            {
                Identifier = identifier,
                TargetKind = previous.TargetKind,
                SingleResult = previous.SingleResult,
                TargetEdmType = targetEdmType
            };

            this.parsedSegments.Add(typeNameSegment);

            // Key expressions are allowed on Type segments
            this.TryBindKeyFromParentheses(parenthesisExpression);

            return true;
        }

        /// <summary>
        /// Creates a property segment
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="property">property to create the segment for.</param>
        /// <param name="queryPortion">query portion for this segment, if specified.</param>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private void CreatePropertySegment(ODataPathSegment previous, IEdmProperty property, string queryPortion)
        {
            Debug.Assert(previous != null, "previous != null");

            if (property.Type.IsStream())
            {
                // The server used to allow arbitrary key expressions after named streams because this check was missing.
                if (queryPortion != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.CreateNamedStreamSegment(previous, property);
                return;
            }

            // Handle a strongly-typed property.
            ODataPathSegment segment = null;

            if (property.PropertyKind == EdmPropertyKind.Navigation)
            {
                var navigationProperty = (IEdmNavigationProperty)property;

                IEdmNavigationSource navigationSource = null;
                if (previous.TargetEdmNavigationSource != null)
                {
                    IEdmPathExpression bindingPath;
                    navigationSource = previous.TargetEdmNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, this.parsedSegments, out bindingPath);
                }

                // Relationship between TargetMultiplicity and navigation property:
                //  1) EdmMultiplicity.Many <=> collection navigation property
                //  2) EdmMultiplicity.ZeroOrOne <=> nullable singleton navigation property
                //  3) EdmMultiplicity.One <=> non-nullable singleton navigation property
                //
                // According to OData Spec CSDL 7.1.3:
                //  1) non-nullable singleton navigation property => navigation source required
                //  2) the other cases => navigation source optional
                if (navigationProperty.TargetMultiplicity() == EdmMultiplicity.One
                    && navigationSource is IEdmUnknownEntitySet)
                {
                    // Specifically not throwing ODataUriParserException since it's more an an internal server error
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_TargetEntitySetNotFound(property.Name));
                }

                segment = new NavigationPropertySegment(navigationProperty, navigationSource);
            }
            else
            {
                segment = new PropertySegment((IEdmStructuralProperty)property);
                switch (property.Type.TypeKind())
                {
                    case EdmTypeKind.Complex:
                        segment.TargetKind = RequestTargetKind.Resource;
                        segment.TargetEdmNavigationSource = previous.TargetEdmNavigationSource;
                        break;
                    case EdmTypeKind.Collection:
                        if (property.Type.IsStructuredCollectionType())
                        {
                            segment.TargetKind = RequestTargetKind.Resource;
                            segment.TargetEdmNavigationSource = previous.TargetEdmNavigationSource;
                        }

                        segment.TargetKind = RequestTargetKind.Collection;
                        break;
                    case EdmTypeKind.Enum:
                        segment.TargetKind = RequestTargetKind.Enum;
                        break;
                    default:
                        Debug.Assert(property.Type.IsPrimitive() || property.Type.IsTypeDefinition(), "must be primitive type or type definition property");
                        segment.TargetKind = RequestTargetKind.Primitive;
                        break;
                }
            }

            this.parsedSegments.Add(segment);

            if (!(queryPortion == null || property.Type.IsCollection() && property.Type.AsCollection().ElementType().IsEntity()))
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            this.TryBindKeyFromParentheses(queryPortion);
        }

        /// <summary>
        /// Check whether identifiers matches according to case in sensitive option.
        /// </summary>
        /// <param name="expected">The expected identifier.</param>
        /// <param name="identifier">Identifier to be evaluated.</param>
        /// <returns>Whether the identifier matches.</returns>
        private bool IdentifierIs(string expected, string identifier)
        {
            return string.Equals(
                expected,
                identifier,
                this.configuration.EnableCaseInsensitiveUriFunctionIdentifier ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
        }

        /// <summary>
        /// Validates the existing parsed segments and returns a list of validated segments.
        /// </summary>
        /// <returns>List of validated path segments.</returns>
        private List<ODataPathSegment> CreateValidatedPathSegments()
        {
            List<ODataPathSegment> validatedSegments = new List<ODataPathSegment>(this.parsedSegments.Count);
            for (int index = 0, segmentCount = this.parsedSegments.Count; index < segmentCount; ++index)
            {
                CheckDollarEachSegmentRestrictions(index);
#if DEBUG
                this.parsedSegments[index].AssertValid();
#endif
                validatedSegments.Add(this.parsedSegments[index]);
            }

            return validatedSegments;
        }

        /// <summary>
        /// Per OData 4.01 spec, only one operation may follow $each. This function enforces that restriction.
        /// </summary>
        /// <param name="index">Index of path segment to examine in the list of parsed segments.</param>
        /// <exception cref="ODataException">Throws if there's a violation of $each restrictions.</exception>
        /// <remarks>Should the restrictions on the $each be removed, this function can be deleted.</remarks>
        private void CheckDollarEachSegmentRestrictions(int index)
        {
            Debug.Assert(index < this.parsedSegments.Count, "index < this.parsedSegments.Count");

            int numOfSegmentsAfterDollarEach = this.parsedSegments.Count - index - 1;

            // Perform restriction checks only if the current segment being examined is $each and there are subsequent segments.
            if (this.parsedSegments[index] is EachSegment && numOfSegmentsAfterDollarEach > 0)
            {
                // Only one segment is allowed after $each...
                if (numOfSegmentsAfterDollarEach > 1)
                {
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_OnlySingleOperationCanFollowEachPathSegment);
                }

                // And if there exists a single segment after $each, then it must be an OperationSegment.
                if (!(this.parsedSegments[index + 1] is OperationSegment))
                {
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_OnlySingleOperationCanFollowEachPathSegment);
                }
            }
        }

        private void CheckTypeCastSegmentRestriction(ODataPathSegment previous, IEdmType targetEdmType)
        {
            Debug.Assert(previous != null);
            Debug.Assert(targetEdmType != null);

            // Make sure: cast to itself can pass the validation.
            IEdmType previousTargetEdmType = previous.TargetEdmType.AsElementType();
            if (previousTargetEdmType == targetEdmType)
            {
                return;
            }

            string fullTypeName = targetEdmType.FullTypeName();

            // Singleton, for example: ~/Me/NS.Cast
            SingletonSegment singletonSegment = previous as SingletonSegment;
            if (singletonSegment != null)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, singletonSegment.Singleton, fullTypeName, "singleton", singletonSegment.Singleton.Name);
                return;
            }

            // EntitySet, for example: ~/Users/NS.Cast
            EntitySetSegment entitySetSegment = previous as EntitySetSegment;
            if (entitySetSegment != null)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, entitySetSegment.EntitySet, fullTypeName, "entity set", entitySetSegment.EntitySet.Name);
                return;
            }

            // EntitySet with key, for example: ~/Users(1)/NS.Cast
            // Or Navigation Property with key ~/Users(1)/Orders(2)/NS.Cast
            NavigationPropertySegment navigationPropertySegment;
            KeySegment keySegment = previous as KeySegment;
            if (keySegment != null)
            {
                ODataPathSegment previousPrevious = this.parsedSegments[this.parsedSegments.Count - 2]; // -2 means skip the "KeySegment"
                entitySetSegment = previousPrevious as EntitySetSegment;
                navigationPropertySegment = previousPrevious as NavigationPropertySegment;
                if (entitySetSegment != null || navigationPropertySegment != null)
                {
                    // entitySet or  Navigation property
                    IEdmVocabularyAnnotatable target;
                    string kind, name;
                    if (entitySetSegment != null)
                    {
                        target = entitySetSegment.EntitySet;
                        kind = "entity set";
                        name = entitySetSegment.EntitySet.Name;
                    }
                    else
                    {
                        target = navigationPropertySegment.NavigationProperty;
                        kind = "navigation property";
                        name = navigationPropertySegment.NavigationProperty.Name;
                    }

                    VerifyDerivedTypeConstraints(this.configuration.Model, target, fullTypeName, kind, name);
                }

                return;
            }

            // Navigation property: ~/Users(1)/Orders/NS.Cast
            navigationPropertySegment = previous as NavigationPropertySegment;
            if (navigationPropertySegment != null)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, navigationPropertySegment.NavigationProperty, fullTypeName, "navigation property", navigationPropertySegment.NavigationProperty.Name);
                return;
            }

            // Structural property:  ~/Users(1)/Addresses/NS.Cast
            PropertySegment propertySegment = previous as PropertySegment;
            if (propertySegment != null)
            {
                // Verify the DerivedTypeConstrictions on property.
                IEdmProperty edmProperty = propertySegment.Property;
                VerifyDerivedTypeConstraints(this.configuration.Model, edmProperty, fullTypeName, "property", edmProperty.Name);

                // Verify the Type Definition, the following codes should work if fix: https://github.com/OData/odata.net/issues/1326
                /*
                IEdmTypeReference propertyTypeReference = edmProperty.Type;
                if (edmProperty.Type.IsCollection())
                {
                    propertyTypeReference = edmProperty.Type.AsCollection().ElementType();
                }

                if (propertyTypeReference.IsTypeDefinition())
                {
                    IEdmTypeDefinition edmTypeDefinition = propertyTypeReference.AsTypeDefinition().TypeDefinition();
                    VerifyDerivedTypeConstraints(this.configuration.Model, edmTypeDefinition, fullTypeName, "type definition", edmTypeDefinition.FullName());
                }
                */

                return;
            }

            // operation: ~/Users(1)/NS.Operation(...)/NS.Cast
            // TODO: we should support to verify the casting for the operation return type.
            // however, ODL doesn't support to annotation on the return type, see https://github.com/OData/odata.net/issues/52
            // Once ODL supports to annotation on the return type, we should support to verify it.
            /*
            OperationSegment operationSegment = previous as OperationSegment;
            if (operationSegment != null)
            {
            }
            */
        }

        private void CheckOperationTypeCastSegmentRestriction(IEdmOperation operation)
        {
            Debug.Assert(operation != null);

            if (this.parsedSegments == null)
            {
                return;
            }

            TypeSegment lastTypeSegment = this.parsedSegments.LastOrDefault(s => s is TypeSegment) as TypeSegment;
            if (lastTypeSegment == null)
            {
                return;
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            ODataPathSegment previousPrevious = this.parsedSegments.Count >= 2 ? this.parsedSegments[this.parsedSegments.Count - 2] : null;

            if ((lastTypeSegment == previous) || (lastTypeSegment == previousPrevious && previous is KeySegment))
            {
                if (!operation.IsBound)
                {
                    return;
                }

                string fullTypeName = lastTypeSegment.TargetEdmType.FullTypeName();
                IEdmOperationParameter bindingParameter = operation.Parameters.First();
                IEdmType bindingType = bindingParameter.Type.Definition;
                bindingType = bindingType.AsElementType();
                if (fullTypeName == bindingType.FullTypeName())
                {
                    return;
                }

                VerifyDerivedTypeConstraints(this.configuration.Model, bindingParameter, fullTypeName, "operation", operation.Name);
            }
        }

        private static void VerifyDerivedTypeConstraints(IEdmModel model, IEdmVocabularyAnnotatable target, string fullTypeName, string kind, string name)
        {
            IEnumerable<string> derivedTypes = model.GetDerivedTypeConstraints(target);
            if (derivedTypes == null || derivedTypes.Any(d => d == fullTypeName))
            {
                return;
            }

            throw new ODataException(Strings.PathParser_TypeCastOnlyAllowedInDerivedTypeConstraint(fullTypeName, kind, name));
        }

        private bool TryResolveEscapeFunction(ODataPathSegment previous, out string qualifiedName, out string parenthesisExpression, out bool anotherEscapeFunctionStarts, out IEdmFunction function)
        {
            qualifiedName = null;
            parenthesisExpression = null;
            anotherEscapeFunctionStarts = false;
            IEdmType bindingType = null;
            IEdmModel model = configuration.Model;
            function = null;

            if (previous != null)
            {
                bindingType = previous.TargetEdmType;
            }

            if (bindingType == null || model == null)
            {
                // escape function is only for bound functions
                return false;
            }

            IEnumerable<IEdmFunction> candidates = model.FindBoundOperations(bindingType).OfType<IEdmFunction>().Where(f => IsUrlEscapeFunction(model, f));

            if (!candidates.HasAny())
            {
                return false;
            }

            string nextPiece = null;
            StringBuilder sb = new StringBuilder();

            while (this.TryGetNextSegmentText(out nextPiece))
            {
                if (sb.Length >= 1)
                {
                    sb.Append('/');
                }

                sb.Append(nextPiece);

                if (nextPiece[nextPiece.Length - 1] == ':')
                {
                    break;
                }
            }

            string identifier = sb.ToString();

            if (identifier != null && identifier.Length >= 2 && identifier[identifier.Length - 2] == ':')
            {
                anotherEscapeFunctionStarts = true;
            }

            bool isComposableRequired = identifier != null && identifier.Length >= 1 && identifier[identifier.Length - 1] == ':';

            function = FindBestMatchForEscapeFunction(candidates, isComposableRequired, bindingType);

            if (function == null)
            {
                // We need to throw because we have consumed segments from the queue and we don't put them back. This is fair because early checks did show an escape function bound to the type. 
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_NoBoundEscapeFunctionSupported(bindingType.FullTypeName()));
            }

            parenthesisExpression = function.Parameters.ElementAt(1).Name + "='" + (isComposableRequired ? identifier.Substring(0, identifier.Length - 1) : identifier) + "'";
            qualifiedName = function.FullName();

            return true;
        }

        private static IEdmFunction FindBestMatchForEscapeFunction(IEnumerable<IEdmFunction> candidates, bool isComposable, IEdmType bindingType)
        {
            IEdmFunction bestCandidate = null;
            foreach (IEdmFunction f in candidates)
            {
                // If the composability of the above found function does not match, we cannot use the function
                if (f.IsComposable != isComposable)
                {
                    continue;
                }

                IEdmOperationParameter firstParameter;
                if (ParametersMatchEscapeFunction(f.Parameters, out firstParameter))
                {
                    // The first parameter of the function is not an exact match for the binding type then try to find a better match.
                    if (firstParameter.Type.Definition == bindingType)
                    {
                        return f;
                    }
                    else if (bestCandidate != null)
                    {
                        // If the binding parameter for the  bestcandidate so far is a base type of first parameter of the current candidate
                        // then we should use the more specific function, which is the current function. 
                        if (bestCandidate.HasEquivalentBindingType(firstParameter.Type.Definition))
                        {
                            bestCandidate = f;
                        }
                    }
                    else
                    {
                        bestCandidate = f;
                    }
                }
            }

            return bestCandidate;
        }

        private static bool ParametersMatchEscapeFunction(IEnumerable<IEdmOperationParameter> parameters, out IEdmOperationParameter firstParameter)
        {
            firstParameter = null;
            if (parameters == null)
            {
                return false;
            }

            int count = 0;
            foreach (IEdmOperationParameter p in parameters)
            {
                if (++count > 2)
                {
                    return false;
                }

                if (count == 1)
                {
                    firstParameter = p;
                }

                if (count == 2 && !p.Type.IsString())
                {
                    return false;
                }
            }

            return true;
        }

        internal static bool IsUrlEscapeFunction(IEdmModel model, IEdmFunction function)
        {
            Debug.Assert(model != null);
            Debug.Assert(function != null);

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(function,
                Edm.Vocabularies.Community.V1.CommunityVocabularyModel.UrlEscapeFunctionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value == null)
                {
                    // If the annotation is applied but a value is not specified then the value is assumed to be true.
                    return true;
                }

                IEdmBooleanConstantExpression tagConstant = annotation.Value as IEdmBooleanConstantExpression;
                if (tagConstant != null)
                {
                    return tagConstant.Value;
                }
            }

            return false;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.Metadata;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData.UriParser
{
    /// <summary>
    /// Semantic parser for the path of the request URI.
    /// </summary>
    internal sealed class ODataPathParser
    {
        /// <summary>
        /// regex pattern to match a contentID
        /// </summary>
        internal static readonly Regex ContentIdRegex = PlatformHelper.CreateCompiled(@"^\$[0-9]+$", RegexOptions.Singleline);

        /// <summary>Empty list of strings.</summary>
        private static readonly IList<string> EmptyList = new List<string>();

        /// <summary>
        /// The queue of segments remaining to be parsed. Should be populated and cleared out on each pass through the main path parsing loop.
        /// </summary>
        private readonly Queue<string> segmentQueue = new Queue<string>();

        /// <summary>
        /// The collection of segments that have been parsed so far.
        /// </summary>
        private readonly List<ODataPathSegment> parsedSegments = new List<ODataPathSegment>();

        /// <summary>
        /// The parser's current configuration.
        /// </summary>
        private readonly ODataUriParserConfiguration configuration;

        /// <summary>
        /// Indicates that the next segment encountered must refer to something in 'metadata-space' and cannot be a key expression.
        /// </summary>
        private bool nextSegmentMustReferToMetadata;

        /// <summary>
        /// Last navigation source that has been parsed.
        /// </summary>
        private IEdmNavigationSource lastNavigationSource;

        /// <summary>
        /// Initializes a new instance of <see cref="ODataPathParser"/>.
        /// </summary>
        /// <param name="configuration">The parser's current configuration.</param>
        internal ODataPathParser(ODataUriParserConfiguration configuration)
        {
            Debug.Assert(configuration != null, "configuration != null");

            this.configuration = configuration;
        }

        /// <summary>
        /// Extracts the segment identifier and, if there are parenthesis in the segment, the expression in the parenthesis.
        /// Will throw if identifier is not found or if the parenthesis expression is malformed. This function does not validate
        /// anything and simply provides the raw text of both the identifier and parenthetical expression.
        /// </summary>
        /// <remarks>Internal only so it can be called from tests. Should not be used outside <see cref="ODataPathParser"/>.</remarks>
        /// <param name="segmentText">The segment text.</param>
        /// <param name="identifier">The identifier that was found.</param>
        /// <param name="parenthesisExpression">The query portion that was found. Will be null after the call if no query portion was present.</param>
        internal static void ExtractSegmentIdentifierAndParenthesisExpression(string segmentText, out string identifier, out string parenthesisExpression)
        {
            Debug.Assert(segmentText != null, "segment != null");

            int parenthesisStart = segmentText.IndexOf('(');
            if (parenthesisStart < 0)
            {
                identifier = segmentText;
                parenthesisExpression = null;
            }
            else
            {
                if (segmentText[segmentText.Length - 1] != ')')
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                // split the string to grab the identifier and remove the parentheses
                identifier = segmentText.Substring(0, parenthesisStart);
                parenthesisExpression = segmentText.Substring(parenthesisStart + 1, segmentText.Length - identifier.Length - 2);
            }

            // We allow a single trailing '/', which results in an empty segment.
            // However System.Uri removes it, so any empty segment we see is a 404 error.
            if (identifier.Length == 0)
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_EmptySegmentInRequestUrl);
            }
        }

        /// <summary>Creates an <see cref="ODataPathSegment"/> array for the given <paramref name="segments"/>.</summary>
        /// <param name="segments">Segments to process.</param>
        /// <returns>Segment information describing the given <paramref name="segments"/>.</returns>
        internal IList<ODataPathSegment> ParsePath(ICollection<string> segments)
        {
            Debug.Assert(segments != null, "segments != null");
            Debug.Assert(this.parsedSegments.Count == 0, "Segment storage should be empty.");
            Debug.Assert(this.segmentQueue.Count == 0, "Segment queue should be empty.");

            // populate the queue that will be used to drive the rest of the algorithm.
            foreach (var segment in segments)
            {
                this.segmentQueue.Enqueue(segment);
            }

            string segmentText = null;

            try
            {
                while (this.TryGetNextSegmentText(out segmentText))
                {
                    if (this.parsedSegments.Count == 0)
                    {
                        this.CreateFirstSegment(segmentText);
                    }
                    else
                    {
                        this.CreateNextSegment(segmentText);
                    }

                    // Keep track of last navigation source.
                    IEdmNavigationSource navigationSource = parsedSegments.Last().TranslateWith(new DetermineNavigationSourceTranslator());
                    if (navigationSource != null)
                    {
                        lastNavigationSource = navigationSource;
                    }
                }
            }
            catch (ODataUnrecognizedPathException ex)
            {
                ex.ParsedSegments = this.parsedSegments;
                ex.CurrentSegment = segmentText;
                ex.UnparsedSegments = this.segmentQueue.ToList();
                throw;
            }

            List<ODataPathSegment> validatedSegments = CreateValidatedPathSegments();
            this.parsedSegments.Clear();

            return validatedSegments;
        }

        /// <summary>
        /// Tries to find a single matching operation import for the given identifier, and parameters.
        /// </summary>
        /// <param name="identifier">The identifier from the URI.</param>
        /// <param name="parenthesisExpression">The parenthesis expression containing parameters, if any.</param>
        /// <param name="configuration">The configuration of the parser.</param>
        /// <param name="boundParameters">The parsed parameters from the parenthesis expression.</param>
        /// <param name="matchingFunctionImport">The single matching operation import if one could be determined.</param>
        /// <returns>Whether or not a matching operation import could be found.</returns>
        private static bool TryBindingParametersAndMatchingOperationImport(string identifier, string parenthesisExpression, ODataUriParserConfiguration configuration, out ICollection<OperationSegmentParameter> boundParameters, out IEdmOperationImport matchingFunctionImport)
        {
            matchingFunctionImport = null;
            ICollection<FunctionParameterToken> splitParameters = null;
            if (!String.IsNullOrEmpty(parenthesisExpression))
            {
                if (!FunctionParameterParser.TrySplitOperationParameters(parenthesisExpression, configuration, out splitParameters))
                {
                    IEdmOperationImport possibleMatchingOperationImport = null;

                    // Look for an overload that returns an entity collection by the specified name. If so parenthesis is just key parameters.
                    if (FunctionOverloadResolver.ResolveOperationImportFromList(identifier, EmptyList, configuration.Model, out possibleMatchingOperationImport, configuration.Resolver))
                    {
                        if (possibleMatchingOperationImport.Operation.ReturnType is IEdmCollectionTypeReference collectionReturnType && collectionReturnType.ElementType().IsEntity())
                        {
                            matchingFunctionImport = possibleMatchingOperationImport;
                            boundParameters = null;
                            return true;
                        }
                        else
                        {
                            throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_SegmentDoesNotSupportKeyPredicates(identifier));
                        }
                    }

                    boundParameters = null;
                    return false;
                }
            }
            else
            {
                splitParameters = new Collection<FunctionParameterToken>();
            }

            // Resolve the specific overload.
            if (FunctionOverloadResolver.ResolveOperationImportFromList(identifier, splitParameters.Select(k => k.ParameterName).ToList(), configuration.Model, out matchingFunctionImport, configuration.Resolver))
            {
                var matchingOperation = matchingFunctionImport.Operation;
                boundParameters = FunctionCallBinder.BindSegmentParameters(configuration, matchingOperation, splitParameters);
                return true;
            }

            boundParameters = null;
            return false;
        }

        /// <summary>
        /// Tries to find a single matching operation import for the given identifier, parameters, and binding type.
        /// </summary>
        /// <param name="identifier">The identifier from the URI.</param>
        /// <param name="parenthesisExpression">The parenthesis expression containing parameters, if any.</param>
        /// <param name="bindingType">The current binding type or null if there isn't one.</param>
        /// <param name="configuration">The configuration of the parser.</param>
        /// <param name="boundParameters">The parsed parameters from the parenthesis expression.</param>
        /// <param name="matchingOperation">The single matching operation import if one could be determined.</param>
        /// <returns>Whether or not a matching operation import could be found.</returns>
        private static bool TryBindingParametersAndMatchingOperation(string identifier, string parenthesisExpression, IEdmType bindingType, ODataUriParserConfiguration configuration, out ICollection<OperationSegmentParameter> boundParameters, out IEdmOperation matchingOperation)
        {
            // If the name isn't fully qualified then it can't be a function or action.
            // When using extension, there may be function call with unqualified name. So loose the restriction here.
            if (identifier != null && identifier.IndexOf(".", StringComparison.Ordinal) == -1 && configuration.Resolver.GetType() == typeof(ODataUriResolver))
            {
                boundParameters = null;
                matchingOperation = null;
                return false;
            }

            // TODO: update code that is duplicate between operation and operation import, add more tests.
            matchingOperation = null;
            ICollection<FunctionParameterToken> splitParameters;
            if (!String.IsNullOrEmpty(parenthesisExpression))
            {
                if (!FunctionParameterParser.TrySplitOperationParameters(parenthesisExpression, configuration, out splitParameters))
                {
                    IEdmOperation possibleMatchingOperation = null;

                    // Look for an overload that returns an entity collection by the specified name. If so parenthesis is just key parameters.
                    if (FunctionOverloadResolver.ResolveOperationFromList(identifier, new List<string>(), bindingType, configuration.Model, out possibleMatchingOperation, configuration.Resolver))
                    {
                        if (possibleMatchingOperation.ReturnType is IEdmCollectionTypeReference collectionReturnType && collectionReturnType.ElementType().IsEntity())
                        {
                            matchingOperation = possibleMatchingOperation;
                            boundParameters = null;
                            return true;
                        }
                        else
                        {
                            throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_SegmentDoesNotSupportKeyPredicates(identifier));
                        }
                    }

                    boundParameters = null;
                    return false;
                }
            }
            else
            {
                splitParameters = new Collection<FunctionParameterToken>();
            }

            // Resolve the specific overload.
            if (FunctionOverloadResolver.ResolveOperationFromList(identifier, splitParameters.Select(k => k.ParameterName).ToList(), bindingType, configuration.Model, out matchingOperation, configuration.Resolver))
            {
                boundParameters = FunctionCallBinder.BindSegmentParameters(configuration, matchingOperation, splitParameters);
                return true;
            }

            boundParameters = null;
            return false;
        }

        /// <summary>
        /// Checks for single result, otherwise throws.
        /// </summary>
        /// <param name="isSingleResult">indicates whether the current result is single result or not.</param>
        /// <param name="identifier">current segment identifier.</param>
        private static void CheckSingleResult(bool isSingleResult, string identifier)
        {
            if (!isSingleResult)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_CannotQueryCollections(identifier));
            }
        }

        /// <summary>
        /// Tries to get the next segment's text to parse.
        /// </summary>
        /// <param name="segmentText">The segment text to parse.</param>
        /// <returns>Whether there was a next segment.</returns>
        private bool TryGetNextSegmentText(out string segmentText)
        {
            return TryGetNextSegmentText(false, out segmentText);
        }

        /// <summary>
        /// Tries to get the next segment's text to parse. Should not be called except by the other overload which does not have the extra parameter.
        /// </summary>
        /// <param name="previousSegmentWasEscapeMarker">Whether the previous segment was an escape marker.</param>
        /// <param name="segmentText">The segment text to parse.</param>
        /// <returns>Whether there was a next segment.</returns>
        private bool TryGetNextSegmentText(bool previousSegmentWasEscapeMarker, out string segmentText)
        {
            if (this.segmentQueue.Count == 0)
            {
                segmentText = null;
                return false;
            }

            segmentText = this.segmentQueue.Dequeue();

            // If this segment is the special escape-marker segment, then remember that the next segment cannot be a key,
            // even if we are in key-as-segments mode. Essentially, it is an escape into 'metadata-space', so to speak.
            //
            // DEVNOTE (mmeehan): We went back and forth several times on whether this should be allowed everywhere or only
            // where a key could appear. We landed on allowing it absolutely everywhere for several reasons:
            //   1) The WCF DS client naively adds the escape marker before all type segments, regardless of whether the
            //      prior segment is a collection.
            //   2) The WCF DS server already allowed the escape marker almost everywhere in 5.3
            //   3) It's better to be either extremely loose or extremely strict than allow it in some cases and not in others.
            // Note that this is not publicly documented in OData V3 nor is it planned to be documented in OData V4, but it
            // is a part of supporting the Key-As-Segment conventions that are used by many Azure services.
            if (segmentText == "$")
            {
                this.nextSegmentMustReferToMetadata = true;
                return TryGetNextSegmentText(true, out segmentText);
            }

            if (!previousSegmentWasEscapeMarker)
            {
                this.nextSegmentMustReferToMetadata = false;
            }

            if (this.parsedSegments.Count > 0)
            {
                ThrowIfMustBeLeafSegment(this.parsedSegments[this.parsedSegments.Count - 1]);
            }

            return true;
        }

        /// <summary>
        /// Tries to handle the given text as a key if the URL conventions support it and it was not preceded by an escape segment.
        /// </summary>
        /// <param name="segmentText">The text which might be a key.</param>
        /// <returns>Whether or not the text was handled as a key.</returns>
        private bool TryHandleAsKeySegment(string segmentText)
        {
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            KeySegment previousKeySegment = this.FindPreviousKeySegment();

            KeySegment keySegment;
            if (!this.nextSegmentMustReferToMetadata && SegmentKeyHandler.TryHandleSegmentAsKey(segmentText, previous, previousKeySegment, this.configuration.UrlKeyDelimiter, this.configuration.Resolver, out keySegment, this.configuration.EnableUriTemplateParsing))
            {
                this.parsedSegments.Add(keySegment);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Find the ParentNode's key segment
        /// </summary>
        /// <returns>The parent nodes key segment.</returns>
        private KeySegment FindPreviousKeySegment()
        {
            return (KeySegment)this.parsedSegments.LastOrDefault(s => s is KeySegment);
        }

        /// <summary>
        /// Throws if the given segment must be a leaf, as a later segment is being created.
        /// </summary>
        /// <param name="previous">The previous segment which may need to be a leaf.</param>
        private static void ThrowIfMustBeLeafSegment(ODataPathSegment previous)
        {
            if (previous is OperationImportSegment operationImportSegment)
            {
                foreach (var operationImport in operationImportSegment.OperationImports)
                {
                    if (operationImport.IsActionImport() || (operationImport.IsFunctionImport() && !((IEdmFunctionImport)operationImport).Function.IsComposable))
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
                    }
                }
            }

            if (previous is OperationSegment operationSegment)
            {
                foreach (var operation in operationSegment.Operations)
                {
                    if (operation.IsAction() || (operation.IsFunction() && !((IEdmFunction)operation).IsComposable))
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
                    }
                }
            }

            if (previous.TargetKind == RequestTargetKind.Batch                  /* $batch */
                || previous.TargetKind == RequestTargetKind.Metadata            /* $metadata */
                || previous.TargetKind == RequestTargetKind.PrimitiveValue      /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.DynamicValue   /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.EnumValue           /* $value, see TryCreateValueSegment */
                || previous.TargetKind == RequestTargetKind.MediaResource       /* $value or Media resource, see TryCreateValueSegment/CreateNamedStreamSegment */
                || previous.TargetKind == RequestTargetKind.VoidOperation       /* service operation with void return type */
                || previous.TargetKind == RequestTargetKind.Nothing             /* Nothing targeted (e.g. PathTemplate) */)
            {
                // Nothing can come after a $metadata, $value or $batch segment.
                // Nothing can come after a service operation with void return type.
                // Nothing can come after a collection property.
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(previous.Identifier));
            }
        }

        /// <summary>
        /// Try to handle the segment as $count.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $count.</returns>
        private bool TryCreateCountSegment(string identifier, string parenthesisExpression)
        {
            if (!IdentifierIs(UriQueryConstants.CountSegment, identifier))
            {
                return false;
            }

            // The server used to allow arbitrary key expressions after $count because this check was missing.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            if ((previous.TargetKind != RequestTargetKind.Resource || previous.SingleResult) && previous.TargetKind != RequestTargetKind.Collection)
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_CountNotSupported(previous.Identifier));
            }

            this.parsedSegments.Add(CountSegment.Instance);
            return true;
        }

        /// <summary>
        /// Creates a filter clause from a navigation source and filter expression.
        /// </summary>
        /// <param name="navigationSource">Navigation source to which the filter refers.</param>
        /// <param name="targetEdmType">Target type for the entity being referenced.</param>
        /// <param name="filter">Filter expression.</param>
        /// <returns>Filter clause with the navigation source and filter information.</returns>
        private FilterClause GenerateFilterClause(IEdmNavigationSource navigationSource, IEdmType targetEdmType, string filter)
        {
            Debug.Assert(navigationSource != null, "navigationSource != null");
            Debug.Assert(targetEdmType != null, "targetEdmType != null");
            Debug.Assert(filter.Length > 0, "filter.Length > 0");

            ODataPathInfo currentOdataPathInfo = new ODataPathInfo(targetEdmType, navigationSource);

            // Get the syntactic representation of the filter expression.
            UriQueryExpressionParser expressionParser = new UriQueryExpressionParser(
                configuration.Settings.FilterLimit, configuration.EnableCaseInsensitiveUriFunctionIdentifier);
            QueryToken filterToken = expressionParser.ParseFilter(filter);

            // Bind it to metadata.
            BindingState state = new BindingState(configuration, currentOdataPathInfo.Segments.ToList())
            {
                ImplicitRangeVariable = NodeFactory.CreateImplicitRangeVariable(
                    currentOdataPathInfo.TargetEdmType.ToTypeReference(), currentOdataPathInfo.TargetNavigationSource)
            };
            state.RangeVariables.Push(state.ImplicitRangeVariable);

            MetadataBinder binder = new MetadataBinder(state);
            FilterBinder filterBinder = new FilterBinder(binder.Bind, state);

            return filterBinder.BindFilter(filterToken);
        }

        /// <summary>
        /// Try to handle the segment as $filter.
        /// </summary>
        /// <param name="segmentText">The raw segment text.</param>
        /// <returns>Whether the segment was $filter.</returns>
        /// <remarks>
        /// $filter path segment is different from existing path segments in that it strictly
        /// follows the format of "$filter(expression)", expression could be an alias or inline expression
        /// that resolves to a boolean. Thus, this function should validate the format of the path
        /// segment closely.
        /// </remarks>
        private bool TryCreateFilterSegment(string segmentText)
        {
            Debug.Assert(segmentText != null, "segmentText != null");
            Debug.Assert(parsedSegments.Count > 0, "parsedSegments.Count > 0");

            /*
             * 1) Check whether the path segment starts with $filter.
             * 2) Ensure that the expression that follows the identifier is enclosed in parentheses.
             * 3) Extract the expression and validate it syntactically.
             * 4) Add the filter segment to list of parsed segments.
             */

            // 1) Check whether the path segment starts with $filter. Past this point, we will throw invalid syntax exceptions
            // because we will assume that the user is attempting to use the $filter path segment.
            if (!segmentText.StartsWith(
                UriQueryConstants.FilterSegment,
                this.configuration.EnableCaseInsensitiveUriFunctionIdentifier ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal))
            {
                return false;
            }

            // 2) The expression that follows UriQueryConstants.FilterSegment should be enclosed in parentheses.
            // Step 3) performs the expression validation (e.g. illegal characters).
            //      - the length of this segment should be longer than "$filter()", indicating that there's a valid expression
            int index = UriQueryConstants.FilterSegment.Length;
            if (segmentText.Length <= index + 2 || segmentText[index] != '(' || segmentText[segmentText.Length - 1] != ')')
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_FilterPathSegmentSyntaxError);
            }

            // 3) Extract the expression and perform the rest of the validations on it.
            if (lastNavigationSource == null)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_NoNavigationSourceFound(UriQueryConstants.FilterSegment));
            }

            if (lastNavigationSource is IEdmSingleton || this.parsedSegments.Last() is KeySegment)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_CannotApplyFilterOnSingleEntities(lastNavigationSource.Name));
            }

            // The "index + 1" is to move past the '(' and the '-2' accounts for the two paren characters.
            string filterExpression = segmentText.Substring(index + 1, segmentText.Length - UriQueryConstants.FilterSegment.Length - 2);

            // If the previous segment is a type segment, then the entity set has been casted and the filter expression should reflect the cast.
            TypeSegment typeSegment = this.parsedSegments.Last() as TypeSegment;

            // Creating a filter clause helps validate the expression and create the expression nodes (including nested parameter aliases).
            FilterClause filterClause = GenerateFilterClause(
                lastNavigationSource,
                typeSegment == null ? lastNavigationSource.EntityType() : typeSegment.TargetEdmType,
                filterExpression);

            // 4) Create filter segment with the validated expression and add it to parsed segments.
            FilterSegment filterSegment = new FilterSegment(filterClause.Expression, filterClause.RangeVariable, lastNavigationSource);
            this.parsedSegments.Add(filterSegment);

            return true;
        }

        /// <summary>
        /// Try to handle the segment as $each.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $each.</returns>
        private bool TryCreateEachSegment(string identifier, string parenthesisExpression)
        {
            if (!IdentifierIs(UriQueryConstants.EachSegment, identifier))
            {
                return false;
            }

            // $each is not supposed to have parenthesis expressions after it.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment prevSegment = this.parsedSegments.Last();
            if (lastNavigationSource == null)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_NoNavigationSourceFound(UriQueryConstants.EachSegment));
            }

            if (lastNavigationSource is IEdmSingleton || prevSegment is KeySegment)
            {
                throw new ODataException(ODataErrorStrings.RequestUriProcessor_CannotApplyEachOnSingleEntities(lastNavigationSource.Name));
            }

            EachSegment eachSegment = new EachSegment(lastNavigationSource, prevSegment.TargetEdmType.AsElementType());
            this.parsedSegments.Add(eachSegment);

            return true;
        }

        /// <summary>
        /// Tries to handle the segment as $ref. If it is $ref, then the rest of the path will be parsed/validated in this call.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the text was $ref.</returns>
        private bool TryCreateEntityReferenceSegment(string identifier, string parenthesisExpression)
        {
            if (!this.IdentifierIs(UriQueryConstants.RefSegment, identifier))
            {
                return false;
            }

            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            // The algorithm below looks for the last NavigationPropertySegment before the $ref segment. Whether a NavPropSeg exists
            // becomes two different code paths:
            // 1) Backwards compatibility behavior (<= ODL 7.4.x): If the NavPropSeg exists, then it is expected to either be before
            // KeySegments or before the $ref (i.e. NavPropSeg/KeySeg/KeySeg/.../$ref or NavPropSeg/$ref). Then the NavPropSeg is replaced
            // with NavigationPropertyLinkSegment. In a previous implementation, if a NavPropSeg didn't exist before KeySegments or
            // $ref, then this function would throw. This was not correct as $ref can apply to entity sets and similar segments
            // (e.g. TypeSegment and FilterSegment), and therefore 2) below is implemented to support those scenarios.
            // 2) If the NavPropSeg does not exist, then this algorithm appends a ReferenceSegment to the existing list of parsed segments.

            // Determine the index of the NavigationPropertySegment in either of the following formats:
            // NavPropSeg/KeySeg/KeySeg/.../$ref or NavPropSeg/$ref
            int indexOfNavPropSeg = this.parsedSegments.Count - 1;
            while (indexOfNavPropSeg > 0 && this.parsedSegments[indexOfNavPropSeg] is KeySegment)
            {
                --indexOfNavPropSeg;
            }

            if (this.parsedSegments[indexOfNavPropSeg] is NavigationPropertySegment navPropSegment)
            {
                if (navPropSegment.TargetKind != RequestTargetKind.Resource)
                {
                    throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.PathParser_EntityReferenceNotSupported(navPropSegment.Identifier));
                }

                // If this is a navigation property, find target navigation source
                Debug.Assert(indexOfNavPropSeg - 1 >= 0, "indexOfNavPropSeg - 1 >= 0");
                IEdmPathExpression bindingPath;
                var targetNavigationSource = this.parsedSegments[indexOfNavPropSeg - 1].TargetEdmNavigationSource.FindNavigationTarget(
                    navPropSegment.NavigationProperty, BindingPathHelper.MatchBindingPath, this.parsedSegments, out bindingPath);

                // If we can't compute the target navigation source, then pretend the navigation property does not exist
                if (targetNavigationSource == null)
                {
                    throw ExceptionUtil.CreateResourceNotFoundError(navPropSegment.NavigationProperty.Name);
                }

                // Create new NavigationPropertyLinkSegment
                var navPropLinkSegment = new NavigationPropertyLinkSegment(navPropSegment.NavigationProperty, targetNavigationSource);

                // Replace the NavigationPropertySegment with the $ref NavigationPropertyLinkSegment
                this.parsedSegments[indexOfNavPropSeg] = navPropLinkSegment;
            }
            else
            {
                ODataPathSegment lastSegment = this.parsedSegments.Last();
                if (lastSegment.TargetKind != RequestTargetKind.Resource)
                {
                    throw ExceptionUtil.CreateBadRequestError(
                        ODataErrorStrings.PathParser_EntityReferenceNotSupported(lastSegment.Identifier));
                }

                ReferenceSegment referenceSegment = new ReferenceSegment(lastNavigationSource);
                referenceSegment.SingleResult = lastSegment.SingleResult;
                this.parsedSegments.Add(referenceSegment);
            }

            // Nothing is allowed after $ref.
            string nextSegmentText;
            if (this.TryGetNextSegmentText(out nextSegmentText))
            {
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_MustBeLeafSegment(UriQueryConstants.RefSegment));
            }

            return true;
        }

        /// <summary>
        /// Tries to bind a key from the parenthetical section of a segment.
        /// </summary>
        /// <param name="parenthesesSection">The section of the segment inside parentheses, or null if there was none.</param>
        /// <returns>Returns True if a key segment was found and added from the parentheses section otherwise false.</returns>
        private bool TryBindKeyFromParentheses(string parenthesesSection)
        {
            if (parenthesesSection == null)
            {
                return false;
            }

            ODataPathSegment keySegment;
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            KeySegment previousKeySegment = this.FindPreviousKeySegment();
            if (!SegmentKeyHandler.TryCreateKeySegmentFromParentheses(previous, previousKeySegment, parenthesesSection, this.configuration.Resolver, out keySegment, this.configuration.EnableUriTemplateParsing))
            {
                return false;
            }

            this.parsedSegments.Add(keySegment);
            return true;
        }

        /// <summary>
        /// Try to handle the segment as $value.
        /// </summary>
        /// <param name="identifier">The identifier that was parsed from this raw segment.</param>
        /// <param name="parenthesisExpression">The query portion was parsed from this raw segment.
        /// This value can be null if there is no query portion.</param>
        /// <returns>Whether the segment was $value.</returns>
        private bool TryCreateValueSegment(string identifier, string parenthesisExpression)
        {
            if (!this.IdentifierIs(UriQueryConstants.ValueSegment, identifier))
            {
                return false;
            }

            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];

            ODataPathSegment segment = new ValueSegment(previous.EdmType);
            if ((previous.TargetKind == RequestTargetKind.Primitive)
                || (previous.TargetKind == RequestTargetKind.Enum))
            {
                segment.CopyValuesFrom(previous);
            }
            else
            {
                segment.TargetEdmType = previous.TargetEdmType;
            }

            segment.Identifier = UriQueryConstants.ValueSegment;
            segment.SingleResult = true;
            CheckSingleResult(previous.SingleResult, previous.Identifier);

            if (previous.TargetKind == RequestTargetKind.Primitive)
            {
                segment.TargetKind = RequestTargetKind.PrimitiveValue;
            }
            else if (previous.TargetKind == RequestTargetKind.Enum)
            {
                segment.TargetKind = RequestTargetKind.EnumValue;
            }
            else if (previous.TargetKind == RequestTargetKind.Dynamic)
            {
                segment.TargetKind = RequestTargetKind.DynamicValue;
            }
            else
            {
                // If the previous segment is an entity, we expect it to be an MLE. We cannot validate our assumption
                // until later when we get the actual instance of the entity because the type hierarchy can contain
                // a mix of MLE and non-MLE types.
                segment.TargetKind = RequestTargetKind.MediaResource;
            }

            this.parsedSegments.Add(segment);
            return true;
        }

        /// <summary>
        /// Creates a new segment for an unknown path segment or an open property.
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="identifier">name of the segment.</param>
        /// <param name="parenthesisExpression">whether this segment has a query portion or not.</param>
        private void CreateDynamicPathSegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            if (this.configuration.ParseDynamicPathSegmentFunc != null)
            {
                var segments = this.configuration.ParseDynamicPathSegmentFunc(previous, identifier, parenthesisExpression);
                this.parsedSegments.AddRange(segments);
                return;
            }

            if (previous == null)
            {
                throw ExceptionUtil.CreateResourceNotFoundError(identifier);
            }

            CheckSingleResult(previous.SingleResult, previous.Identifier);

            // Handle an open type property. If the current leaf isn't an
            // object (which implies it's already an open type), then
            // it should be marked as an open type.
            if ((previous.TargetEdmType != null && !previous.TargetEdmType.IsOpen()))
            {
                throw ExceptionUtil.CreateResourceNotFoundError(identifier);
            }

            // Open navigation properties are not supported on OpenTypes.
            if (parenthesisExpression != null)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.OpenNavigationPropertiesNotSupportedOnOpenTypes(identifier));
            }

            ODataPathSegment segment = new DynamicPathSegment(identifier);
            this.parsedSegments.Add(segment);
        }

        /// <summary>
        /// Creates a named stream segment
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="streamProperty">stream property to create the segment for.</param>
        private void CreateNamedStreamSegment(ODataPathSegment previous, IEdmProperty streamProperty)
        {
            Debug.Assert(streamProperty.Type.IsStream(), "streamProperty.Type.IsStream()");

            // Handle Named Stream.
            ODataPathSegment segment = new PropertySegment((IEdmStructuralProperty)streamProperty);
            segment.TargetKind = RequestTargetKind.MediaResource;
            segment.SingleResult = true;
            segment.TargetEdmType = previous.TargetEdmType;
            Debug.Assert(segment.Identifier != UriQueryConstants.ValueSegment, "'$value' cannot be the name of a named stream.");

            this.parsedSegments.Add(segment);
        }

        /// <summary>Creates the first <see cref="ODataPathSegment"/> for a request.</summary>
        /// <param name="segmentText">The text of the segment.</param>
        private void CreateFirstSegment(string segmentText)
        {
            if (segmentText[segmentText.Length - 1] == ':' && this.TryCreateEscapeFunctionSegment(segmentText))
            {
                return;
            }

            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(segmentText, out identifier, out parenthesisExpression);
            Debug.Assert(identifier != null, "identifier != null");

            // Look for well-known system resource points.
            if (this.IdentifierIs(UriQueryConstants.MetadataSegment, identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.parsedSegments.Add(MetadataSegment.Instance);
                return;
            }

            if (this.IdentifierIs(UriQueryConstants.BatchSegment, identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.parsedSegments.Add(BatchSegment.Instance);
                return;
            }

            if (this.IdentifierIs(UriQueryConstants.CountSegment, identifier))
            {
                // $count on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_CountOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.FilterSegment, identifier))
            {
                // $filter on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_FilterOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.EachSegment, identifier))
            {
                // $each on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_EachOnRoot);
            }

            if (this.IdentifierIs(UriQueryConstants.RefSegment, identifier))
            {
                // $ref on root: throw
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_RefOnRoot);
            }

            if (this.configuration.BatchReferenceCallback != null && ContentIdRegex.IsMatch(identifier))
            {
                if (parenthesisExpression != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                BatchReferenceSegment crossReferencedSegment = this.configuration.BatchReferenceCallback(identifier);
                if (crossReferencedSegment != null)
                {
                    this.parsedSegments.Add(crossReferencedSegment);
                    return;
                }
            }

            if (this.TryCreateSegmentForNavigationSource(identifier, parenthesisExpression))
            {
                return;
            }

            if (this.TryCreateSegmentForOperationImport(identifier, parenthesisExpression))
            {
                return;
            }

            this.CreateDynamicPathSegment(null, identifier, parenthesisExpression);
        }

        /// <summary>Creates a <see cref="ODataPathSegment"/> that an escape function can bind to, which can be a
        /// a navigation source or an operation import it is the first segment to be created. Otherwise, it can be a 
        /// filter segment, property segment, typecast segment, operation segment or a key segment.
        /// </summary>
        /// <param name="segmentText">The text of the segment.</param>
        /// <returns>boolean value.</returns>
        private bool BindSegmentBeforeEscapeFunction(string segmentText)
        {
            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(segmentText, out identifier, out parenthesisExpression);

            if (this.parsedSegments.Count == 0)
            {
                if (this.TryCreateSegmentForNavigationSource(identifier, parenthesisExpression))
                {
                    return true;
                }

                if (this.TryCreateSegmentForOperationImport(identifier, parenthesisExpression))
                {
                    return true;
                }
            }
            else
            {
                if (this.TryCreateFilterSegment(segmentText))
                {
                    return true;
                }

                ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];

                if (this.TryCreatePropertySegment(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // Type cast
                if (this.TryCreateTypeNameSegment(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // Operation
                if (this.TryCreateSegmentForOperation(previous, identifier, parenthesisExpression))
                {
                    return true;
                }

                // For KeyAsSegment, try to handle as key segment
                if (this.configuration.UrlKeyDelimiter.EnableKeyAsSegment && this.TryHandleAsKeySegment(segmentText))
                {
                    return true;
                }
            }

            return false;
        }

        private bool TryCreatePropertySegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            // property if previous is single
            if (previous.SingleResult)
            {
                // if its not one of the recognized special segments, then it must be a property, type-segment, or key value.
                Debug.Assert(
                    previous.TargetKind == RequestTargetKind.Resource
                    || previous.TargetKind == RequestTargetKind.Dynamic,
                    "previous.TargetKind(" + previous.TargetKind + ") can have properties");

                if (previous.TargetEdmType == null)
                {
                    // A segment will correspond to a property in the object model;
                    // if we are processing an open type, anything further in the
                    // URI also represents an open type property.
                    Debug.Assert(previous.TargetKind == RequestTargetKind.Dynamic, "For open properties, the target resource type must be null");
                }
                else
                {
                    // if the segment corresponds to a declared property, handle it
                    // otherwise, fall back to type-segments, actions, and dynamic/open properties
                    IEdmProperty projectedProperty;
                    if (this.TryBindProperty(identifier, out projectedProperty))
                    {
                        CheckSingleResult(previous.SingleResult, previous.Identifier);
                        this.CreatePropertySegment(previous, projectedProperty, parenthesisExpression);

                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Tries to parse a segment as an entity set or singleton.
        /// </summary>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The parenthesis expression</param>
        /// <returns>Whether or not the identifier referred to an entity set or singleton.</returns>
        private bool TryCreateSegmentForNavigationSource(string identifier, string parenthesisExpression)
        {
            ODataPathSegment segment = null;
            IEdmEntitySet targetEdmEntitySet;
            IEdmSingleton targetEdmSingleton;

            IEdmNavigationSource source = this.configuration.Resolver.ResolveNavigationSource(this.configuration.Model, identifier);

            if ((targetEdmEntitySet = source as IEdmEntitySet) != null)
            {
                segment = new EntitySetSegment(targetEdmEntitySet) { Identifier = identifier };
            }
            else if ((targetEdmSingleton = source as IEdmSingleton) != null)
            {
                segment = new SingletonSegment(targetEdmSingleton) { Identifier = identifier };
            }

            if (segment != null)
            {
                this.parsedSegments.Add(segment);
                this.TryBindKeyFromParentheses(parenthesisExpression);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Tries to parse a segment as a functionImport or actionImport.
        /// </summary>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The query portion</param>
        /// <returns>Whether or not the identifier referred to an action.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private bool TryCreateSegmentForOperationImport(string identifier, string parenthesisExpression)
        {
            ICollection<OperationSegmentParameter> resolvedParameters;
            IEdmOperationImport singleImport;
            if (!TryBindingParametersAndMatchingOperationImport(identifier, parenthesisExpression, this.configuration, out resolvedParameters, out singleImport))
            {
                return false;
            }

            IEdmTypeReference returnType = singleImport.Operation.ReturnType;
            IEdmEntitySetBase targetset = null;

            if (returnType != null)
            {
                targetset = singleImport.GetTargetEntitySet(null, this.configuration.Model);
            }

            ODataPathSegment segment = new OperationImportSegment(singleImport, targetset, resolvedParameters);

            this.parsedSegments.Add(segment);

            this.TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(parenthesisExpression, returnType, resolvedParameters, segment);

            return true;
        }

        /// <summary>
        /// Tries the bind key segment if no resolved parameters and parenthesis value exists.
        /// </summary>
        /// <param name="parenthesisExpression">The parenthesis expression.</param>
        /// <param name="returnType">Type of the return.</param>
        /// <param name="resolvedParameters">The resolved parameters.</param>
        /// <param name="segment">The segment.</param>
        private void TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(string parenthesisExpression, IEdmTypeReference returnType, ICollection<OperationSegmentParameter> resolvedParameters, ODataPathSegment segment)
        {
            if (returnType is IEdmCollectionTypeReference collectionTypeReference && collectionTypeReference.ElementType().IsEntity() && resolvedParameters == null && parenthesisExpression != null)
            {
                // The parameters in the parenthesis is a key segment.
                if (this.TryBindKeyFromParentheses(parenthesisExpression))
                {
                    ThrowIfMustBeLeafSegment(segment);
                }
            }
        }

        /// <summary>
        /// Tries to parse a segment as a function or action.
        /// </summary>
        /// <param name="previousSegment">The previous segment before the operation to be invoked.</param>
        /// <param name="identifier">The name of the segment</param>
        /// <param name="parenthesisExpression">The query portion</param>
        /// <returns>Whether or not the identifier referred to an action.</returns>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private bool TryCreateSegmentForOperation(ODataPathSegment previousSegment, string identifier, string parenthesisExpression)
        {
            // Parse Arguments syntactically
            IEdmType bindingType = null;
            if (previousSegment != null)
            {
                // Use TargetEdmType for EachSegment to represent a pseudo-single entity.
                bindingType = (previousSegment is EachSegment) ? previousSegment.TargetEdmType : previousSegment.EdmType;
            }

            ICollection<OperationSegmentParameter> resolvedParameters;
            IEdmOperation singleOperation;
            if (!TryBindingParametersAndMatchingOperation(identifier, parenthesisExpression, bindingType, this.configuration, out resolvedParameters, out singleOperation))
            {
                return false;
            }

            if (!UriEdmHelpers.IsBindingTypeValid(bindingType))
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_OperationSegmentBoundToANonEntityType);
            }

            if (previousSegment != null && bindingType == null)
            {
                throw new ODataException(ODataErrorStrings.FunctionCallBinder_CallingFunctionOnOpenProperty(identifier));
            }

            CreateOperationSegment(previousSegment, singleOperation, resolvedParameters, identifier, parenthesisExpression);

            return true;
        }

        private void CreateOperationSegment(ODataPathSegment previousSegment, IEdmOperation singleOperation, ICollection<OperationSegmentParameter> resolvedParameters, string identifier, string parenthesisExpression)
        {
            IEdmTypeReference returnType = singleOperation.ReturnType;
            IEdmEntitySetBase targetset = null;

            if (returnType != null)
            {
                IEdmNavigationSource source = previousSegment == null ? null : previousSegment.TargetEdmNavigationSource;
                targetset = singleOperation.GetTargetEntitySet(source, this.configuration.Model);
            }

            // If previous segment is cross-referenced then we explicitly disallow the service action call
            if (previousSegment is BatchReferenceSegment)
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_BatchedActionOnEntityCreatedInSameChangeset(identifier));
            }

            CheckOperationTypeCastSegmentRestriction(singleOperation);

            ODataPathSegment segment = new OperationSegment(singleOperation, resolvedParameters, targetset)
            {
                Identifier = identifier
            };

            this.parsedSegments.Add(segment);
            this.TryBindKeySegmentIfNoResolvedParametersAndParenthesisValueExists(parenthesisExpression, returnType, resolvedParameters, segment);

            return;
        }

        /// <summary>
        /// Creates the next segment.
        /// </summary>
        /// <param name="text">The text for the next segment.</param>
        private void CreateNextSegment(string text)
        {
            if (text[text.Length - 1] == ':' && this.TryCreateEscapeFunctionSegment(text))
            {
                return;
            }

            string identifier;
            string parenthesisExpression;
            ExtractSegmentIdentifierAndParenthesisExpression(text, out identifier, out parenthesisExpression);
            /*
             * For Non-KeyAsSegment, try to handle it as a key property value, unless it was preceded by an escape - marker segment('$').
             * For KeyAsSegment, the following precedence rules should be supported[ODATA - 799]:
             * Try to match an OData segment(starting with “$”).
             *   - Note: $filter path segment is a special case that has the format "$filter(@a)", where @a represents an alias.
             * Try to match an alias - qualified bound action name, bound function overload, or type name.
             * Try to match a namespace-qualified bound action name, bound function overload, or type name.
             * Try to match an unqualified bound action name, bound function overload, or type name in a default namespace.
             * Treat as a key.
             */

            // $value
            if (this.TryCreateValueSegment(identifier, parenthesisExpression))
            {
                return;
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            if (previous.TargetKind == RequestTargetKind.Primitive)
            {
                // only $value is allowed after a primitive property
                throw ExceptionUtil.ResourceNotFoundError(ODataErrorStrings.RequestUriProcessor_ValueSegmentAfterScalarPropertySegment(previous.Identifier, text));
            }

            // $ref
            if (this.TryCreateEntityReferenceSegment(identifier, parenthesisExpression))
            {
                return;
            }

            // $count
            if (this.TryCreateCountSegment(identifier, parenthesisExpression))
            {
                return;
            }

            // $filter
            if (this.TryCreateFilterSegment(text))
            {
                return;
            }

            // $each
            if (this.TryCreateEachSegment(identifier, parenthesisExpression))
            {
                return;
            }

            if (this.TryCreatePropertySegment(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // Type cast
            if (this.TryCreateTypeNameSegment(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // Operation
            if (this.TryCreateSegmentForOperation(previous, identifier, parenthesisExpression))
            {
                return;
            }

            // For KeyAsSegment, try to handle as key segment
            if (this.configuration.UrlKeyDelimiter.EnableKeyAsSegment && this.TryHandleAsKeySegment(text))
            {
                return;
            }

            // Parse as path template segment if EnableUriTemplateParsing is enabled.
            if (this.configuration.EnableUriTemplateParsing && UriTemplateParser.IsValidTemplateLiteral(text))
            {
                this.parsedSegments.Add(new PathTemplateSegment(text));
                return;
            }

            // Dynamic property
            this.CreateDynamicPathSegment(previous, identifier, parenthesisExpression);
        }

        private bool TryCreateEscapeFunctionSegment(string segmentText)
        {
            Debug.Assert(segmentText[segmentText.Length - 1] == ':');

            int numberOfSegmentsParsed = this.parsedSegments.Count;
            string newSegmentText = segmentText.Substring(0, segmentText.Length - 1);

            // Try to binding the segment optimisitically to which the escape function must bind to
            if (newSegmentText.Length > 0 && !BindSegmentBeforeEscapeFunction(newSegmentText))
            {
                return false;
            }

            if (this.TryBindEscapeFunction())
            {
                return true;
            }
            else
            {
                // The caller of this function will try binding the original segment as key value.
                // We need to roll back the optimistic binding that we did in this step.
                while (this.parsedSegments.Count > numberOfSegmentsParsed)
                {
                    // Keep on poping the last segment. 
                    this.parsedSegments.RemoveAt(this.parsedSegments.Count - 1);
                }
            }

            return false;
        }

        /// <summary>
        /// Tries to bind the identifier as a property.
        /// </summary>
        /// <param name="identifier">The identifier to bind.</param>
        /// <param name="projectedProperty">The property, if one was found.</param>
        /// <returns>Whether a property matching the identifier was found.</returns>
        private bool TryBindProperty(string identifier, out IEdmProperty projectedProperty)
        {
            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            Debug.Assert(previous.TargetEdmType != null, "Previous wasn't open, so it should have a resource type");
            Debug.Assert(previous.TargetEdmNavigationSource == null || previous.TargetEdmType.IsStructuredOrStructuredCollectionType(), "if the previous segment has a target resource set, then its target resource type must be an entity or a complex");

            // Note that we try resolve the property on the root entity type for the set. Properties/Name streams defined on derived types
            // are not supported. This is a general problem with properties as we don't have the entity instance here to validate
            // whether the property exists.
            projectedProperty = null;
            var structuredType = previous.TargetEdmType as IEdmStructuredType;
            if (structuredType == null)
            {
                if (previous.TargetEdmType is IEdmCollectionType collectionType)
                {
                    structuredType = collectionType.ElementType.Definition as IEdmStructuredType;
                }
            }

            if (structuredType == null)
            {
                return false;
            }

            projectedProperty = this.configuration.Resolver.ResolveProperty(structuredType, identifier);
            return projectedProperty != null;
        }

        private bool TryBindEscapeFunction()
        {
            ODataPathSegment previous = null;
            if (this.parsedSegments.Count > 0)
            {
                previous = this.parsedSegments[this.parsedSegments.Count - 1];
            }

            string newIdentifier, newParenthesisExpression;
            bool anotherEscapeFunctionStarts;
            IEdmFunction escapeFunction;
            if (this.TryResolveEscapeFunction(previous, out newIdentifier, out newParenthesisExpression, out anotherEscapeFunctionStarts, out escapeFunction))
            {
                ICollection<FunctionParameterToken> splitParameters;
                FunctionParameterParser.TrySplitOperationParameters(newParenthesisExpression, configuration, out splitParameters);
                ICollection<OperationSegmentParameter> resolvedParameters = FunctionCallBinder.BindSegmentParameters(configuration, escapeFunction, splitParameters);
                CreateOperationSegment(previous, escapeFunction, resolvedParameters, newIdentifier, newParenthesisExpression);
                if (anotherEscapeFunctionStarts)
                {
                    // When we encounter an invalid escape function as a parameter, we should throw.
                    // i.e. we should throw for entitySet(key):/ComposableEscapeFunctionPath::/InvalidEscapeFunction
                    if (!TryBindEscapeFunction())
                    {
                        throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_ComposableEscapeFunctionShouldHaveValidParameter);
                    }
                }

                return true;
            }

            return false;
        }

        /// <summary>
        /// Tries to create a type name segment if the given identifier refers to a known type.
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="identifier">The current raw segment identifier being interpreted.</param>
        /// <param name="parenthesisExpression">Parenthesis expression of this segment.</param>
        /// <returns>Whether or not a type segment was created for the identifier.</returns>
        private bool TryCreateTypeNameSegment(ODataPathSegment previous, string identifier, string parenthesisExpression)
        {
            if (identifier.IndexOf('.') < 0)
            {
                return false;
            }

            IEdmType targetEdmType;
            if (previous.TargetEdmType == null || (targetEdmType = UriEdmHelpers.FindTypeFromModel(this.configuration.Model, identifier, this.configuration.Resolver)) == null)
            {
                return false;
            }

            // if the new type segment prevents any results from possibly being returned, then short-circuit and throw a 404.
            IEdmType previousEdmType = previous.TargetEdmType;
            Debug.Assert(previousEdmType != null, "previous.TargetEdmType != null");

            if (previousEdmType.TypeKind == EdmTypeKind.Collection)
            {
                previousEdmType = ((IEdmCollectionType)previousEdmType).ElementType.Definition;
            }

            if (!targetEdmType.IsOrInheritsFrom(previousEdmType) && !previousEdmType.IsOrInheritsFrom(targetEdmType))
            {
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_InvalidTypeIdentifier_UnrelatedType(targetEdmType.FullTypeName(), previousEdmType.FullTypeName()));
            }

            CheckTypeCastSegmentRestriction(previous, targetEdmType);

            // We want the type of the type segment to be a collection if the previous segment was a collection
            IEdmType actualTypeOfTheTypeSegment = targetEdmType;

            if (previous.EdmType.TypeKind == EdmTypeKind.Collection)
            {
                // creating a new collection type here because the type in the request is just the item type, there is no user-provided collection type.
                if (actualTypeOfTheTypeSegment is IEdmEntityType actualEntityTypeOfTheTypeSegment)
                {
                    actualTypeOfTheTypeSegment = new EdmCollectionType(new EdmEntityTypeReference(actualEntityTypeOfTheTypeSegment, false));
                }
                else
                {
                    // Complex collection supports type cast too.
                    if (actualTypeOfTheTypeSegment is IEdmComplexType actualComplexTypeOfTheTypeSegment)
                    {
                        actualTypeOfTheTypeSegment = new EdmCollectionType(new EdmComplexTypeReference(actualComplexTypeOfTheTypeSegment, false));
                    }
                    else
                    {
                        throw new ODataException(Strings.PathParser_TypeCastOnlyAllowedAfterStructuralCollection(identifier));
                    }
                }
            }

            var typeNameSegment = (ODataPathSegment)new TypeSegment(actualTypeOfTheTypeSegment, previous.EdmType, previous.TargetEdmNavigationSource)
            {
                Identifier = identifier,
                TargetKind = previous.TargetKind,
                SingleResult = previous.SingleResult,
                TargetEdmType = targetEdmType
            };

            this.parsedSegments.Add(typeNameSegment);

            // Key expressions are allowed on Type segments
            this.TryBindKeyFromParentheses(parenthesisExpression);

            return true;
        }

        /// <summary>
        /// Creates a property segment
        /// </summary>
        /// <param name="previous">previous segment info.</param>
        /// <param name="property">property to create the segment for.</param>
        /// <param name="queryPortion">query portion for this segment, if specified.</param>
        [SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "IEdmModel", Justification = "The spelling is correct.")]
        private void CreatePropertySegment(ODataPathSegment previous, IEdmProperty property, string queryPortion)
        {
            Debug.Assert(previous != null, "previous != null");

            if (property.Type.IsStream())
            {
                // The server used to allow arbitrary key expressions after named streams because this check was missing.
                if (queryPortion != null)
                {
                    throw ExceptionUtil.CreateSyntaxError();
                }

                this.CreateNamedStreamSegment(previous, property);
                return;
            }

            // Handle a strongly-typed property.
            ODataPathSegment segment = null;

            if (property.PropertyKind == EdmPropertyKind.Navigation)
            {
                var navigationProperty = (IEdmNavigationProperty)property;

                IEdmNavigationSource navigationSource = null;
                if (previous.TargetEdmNavigationSource != null)
                {
                    IEdmPathExpression bindingPath;
                    navigationSource = previous.TargetEdmNavigationSource.FindNavigationTarget(navigationProperty, BindingPathHelper.MatchBindingPath, this.parsedSegments, out bindingPath);
                }

                // Relationship between TargetMultiplicity and navigation property:
                //  1) EdmMultiplicity.Many <=> collection navigation property
                //  2) EdmMultiplicity.ZeroOrOne <=> nullable singleton navigation property
                //  3) EdmMultiplicity.One <=> non-nullable singleton navigation property
                //
                // According to OData Spec CSDL 7.1.3:
                //  1) non-nullable singleton navigation property => navigation source required
                //  2) the other cases => navigation source optional
                if (navigationProperty.TargetMultiplicity() == EdmMultiplicity.One
                    && navigationSource is IEdmUnknownEntitySet)
                {
                    // Specifically not throwing ODataUriParserException since it's more an an internal server error
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_TargetEntitySetNotFound(property.Name));
                }

                segment = new NavigationPropertySegment(navigationProperty, navigationSource);
            }
            else
            {
                segment = new PropertySegment((IEdmStructuralProperty)property);
                switch (property.Type.TypeKind())
                {
                    case EdmTypeKind.Complex:
                        segment.TargetKind = RequestTargetKind.Resource;
                        segment.TargetEdmNavigationSource = previous.TargetEdmNavigationSource;
                        break;
                    case EdmTypeKind.Collection:
                        if (property.Type.IsStructuredCollectionType())
                        {
                            segment.TargetKind = RequestTargetKind.Resource;
                            segment.TargetEdmNavigationSource = previous.TargetEdmNavigationSource;
                        }

                        segment.TargetKind = RequestTargetKind.Collection;
                        break;
                    case EdmTypeKind.Enum:
                        segment.TargetKind = RequestTargetKind.Enum;
                        break;
                    default:
                        Debug.Assert(property.Type.IsPrimitive() || property.Type.IsTypeDefinition(), "must be primitive type or type definition property");
                        segment.TargetKind = RequestTargetKind.Primitive;
                        break;
                }
            }

            this.parsedSegments.Add(segment);

            if (!(queryPortion == null || property.Type.IsCollection() && property.Type.AsCollection().ElementType().IsEntity()))
            {
                throw ExceptionUtil.CreateSyntaxError();
            }

            this.TryBindKeyFromParentheses(queryPortion);
        }

        /// <summary>
        /// Check whether identifiers matches according to case in sensitive option.
        /// </summary>
        /// <param name="expected">The expected identifier.</param>
        /// <param name="identifier">Identifier to be evaluated.</param>
        /// <returns>Whether the identifier matches.</returns>
        private bool IdentifierIs(string expected, string identifier)
        {
            return string.Equals(
                expected,
                identifier,
                this.configuration.EnableCaseInsensitiveUriFunctionIdentifier ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
        }

        /// <summary>
        /// Validates the existing parsed segments and returns a list of validated segments.
        /// </summary>
        /// <returns>List of validated path segments.</returns>
        private List<ODataPathSegment> CreateValidatedPathSegments()
        {
            List<ODataPathSegment> validatedSegments = new List<ODataPathSegment>(this.parsedSegments.Count);
            for (int index = 0, segmentCount = this.parsedSegments.Count; index < segmentCount; ++index)
            {
                CheckDollarEachSegmentRestrictions(index);
#if DEBUG
                this.parsedSegments[index].AssertValid();
#endif
                validatedSegments.Add(this.parsedSegments[index]);
            }

            return validatedSegments;
        }

        /// <summary>
        /// Per OData 4.01 spec, only one operation may follow $each. This function enforces that restriction.
        /// </summary>
        /// <param name="index">Index of path segment to examine in the list of parsed segments.</param>
        /// <exception cref="ODataException">Throws if there's a violation of $each restrictions.</exception>
        /// <remarks>Should the restrictions on the $each be removed, this function can be deleted.</remarks>
        private void CheckDollarEachSegmentRestrictions(int index)
        {
            Debug.Assert(index < this.parsedSegments.Count, "index < this.parsedSegments.Count");

            int numOfSegmentsAfterDollarEach = this.parsedSegments.Count - index - 1;

            // Perform restriction checks only if the current segment being examined is $each and there are subsequent segments.
            if (this.parsedSegments[index] is EachSegment && numOfSegmentsAfterDollarEach > 0)
            {
                // Only one segment is allowed after $each...
                if (numOfSegmentsAfterDollarEach > 1)
                {
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_OnlySingleOperationCanFollowEachPathSegment);
                }

                // And if there exists a single segment after $each, then it must be an OperationSegment.
                if (!(this.parsedSegments[index + 1] is OperationSegment))
                {
                    throw new ODataException(ODataErrorStrings.RequestUriProcessor_OnlySingleOperationCanFollowEachPathSegment);
                }
            }
        }

        private void CheckTypeCastSegmentRestriction(ODataPathSegment previous, IEdmType targetEdmType)
        {
            Debug.Assert(previous != null);
            Debug.Assert(targetEdmType != null);

            // Make sure: cast to itself can pass the validation.
            IEdmType previousTargetEdmType = previous.TargetEdmType.AsElementType();
            if (previousTargetEdmType == targetEdmType)
            {
                return;
            }

            string fullTypeName = targetEdmType.FullTypeName();

            // Singleton, for example: ~/Me/NS.Cast
            if (previous is SingletonSegment singletonSegment)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, singletonSegment.Singleton, fullTypeName, "singleton", singletonSegment.Singleton.Name);
                return;
            }

            // EntitySet, for example: ~/Users/NS.Cast
            if (previous is EntitySetSegment entitySetSegment)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, entitySetSegment.EntitySet, fullTypeName, "entity set", entitySetSegment.EntitySet.Name);
                return;
            }

            // EntitySet with key, for example: ~/Users(1)/NS.Cast
            // Or Navigation Property with key ~/Users(1)/Orders(2)/NS.Cast
            NavigationPropertySegment navigationPropertySegment;

            if (previous is KeySegment keySegment)
            {
                ODataPathSegment previousPrevious = this.parsedSegments[this.parsedSegments.Count - 2]; // -2 means skip the "KeySegment"
                entitySetSegment = previousPrevious as EntitySetSegment;
                navigationPropertySegment = previousPrevious as NavigationPropertySegment;
                if (previous is EntitySetSegment entitySetSegment || navigationPropertySegment != null)
                {
                    // entitySet or  Navigation property
                    IEdmVocabularyAnnotatable target;
                    string kind, name;
                    if (previous is EntitySetSegment entitySetSegment)
                    {
                        target = entitySetSegment.EntitySet;
                        kind = "entity set";
                        name = entitySetSegment.EntitySet.Name;
                    }
                    else
                    {
                        target = navigationPropertySegment.NavigationProperty;
                        kind = "navigation property";
                        name = navigationPropertySegment.NavigationProperty.Name;
                    }

                    VerifyDerivedTypeConstraints(this.configuration.Model, target, fullTypeName, kind, name);
                }

                return;
            }

            // Navigation property: ~/Users(1)/Orders/NS.Cast
            navigationPropertySegment = previous as NavigationPropertySegment;
            if (navigationPropertySegment != null)
            {
                VerifyDerivedTypeConstraints(this.configuration.Model, navigationPropertySegment.NavigationProperty, fullTypeName, "navigation property", navigationPropertySegment.NavigationProperty.Name);
                return;
            }

            // Structural property:  ~/Users(1)/Addresses/NS.Cast
            if (previous is PropertySegment propertySegment)
            {
                // Verify the DerivedTypeConstrictions on property.
                IEdmProperty edmProperty = propertySegment.Property;
                VerifyDerivedTypeConstraints(this.configuration.Model, edmProperty, fullTypeName, "property", edmProperty.Name);

                // Verify the Type Definition, the following codes should work if fix: https://github.com/OData/odata.net/issues/1326
                /*
                IEdmTypeReference propertyTypeReference = edmProperty.Type;
                if (edmProperty.Type.IsCollection())
                {
                    propertyTypeReference = edmProperty.Type.AsCollection().ElementType();
                }

                if (propertyTypeReference.IsTypeDefinition())
                {
                    IEdmTypeDefinition edmTypeDefinition = propertyTypeReference.AsTypeDefinition().TypeDefinition();
                    VerifyDerivedTypeConstraints(this.configuration.Model, edmTypeDefinition, fullTypeName, "type definition", edmTypeDefinition.FullName());
                }
                */

                return;
            }

            // operation: ~/Users(1)/NS.Operation(...)/NS.Cast
            // TODO: we should support to verify the casting for the operation return type.
            // however, ODL doesn't support to annotation on the return type, see https://github.com/OData/odata.net/issues/52
            // Once ODL supports to annotation on the return type, we should support to verify it.
            /*
            OperationSegment operationSegment = previous as OperationSegment;
            if (operationSegment != null)
            {
            }
            */
        }

        private void CheckOperationTypeCastSegmentRestriction(IEdmOperation operation)
        {
            Debug.Assert(operation != null);

            if (this.parsedSegments == null)
            {
                return;
            }

            TypeSegment lastTypeSegment = this.parsedSegments.LastOrDefault(s => s is TypeSegment) as TypeSegment;
            if (lastTypeSegment == null)
            {
                return;
            }

            ODataPathSegment previous = this.parsedSegments[this.parsedSegments.Count - 1];
            ODataPathSegment previousPrevious = this.parsedSegments.Count >= 2 ? this.parsedSegments[this.parsedSegments.Count - 2] : null;

            if ((lastTypeSegment == previous) || (lastTypeSegment == previousPrevious && previous is KeySegment))
            {
                if (!operation.IsBound)
                {
                    return;
                }

                string fullTypeName = lastTypeSegment.TargetEdmType.FullTypeName();
                IEdmOperationParameter bindingParameter = operation.Parameters.First();
                IEdmType bindingType = bindingParameter.Type.Definition;
                bindingType = bindingType.AsElementType();
                if (fullTypeName == bindingType.FullTypeName())
                {
                    return;
                }

                VerifyDerivedTypeConstraints(this.configuration.Model, bindingParameter, fullTypeName, "operation", operation.Name);
            }
        }

        private static void VerifyDerivedTypeConstraints(IEdmModel model, IEdmVocabularyAnnotatable target, string fullTypeName, string kind, string name)
        {
            IEnumerable<string> derivedTypes = model.GetDerivedTypeConstraints(target);
            if (derivedTypes == null || derivedTypes.Any(d => d == fullTypeName))
            {
                return;
            }

            throw new ODataException(Strings.PathParser_TypeCastOnlyAllowedInDerivedTypeConstraint(fullTypeName, kind, name));
        }

        private bool TryResolveEscapeFunction(ODataPathSegment previous, out string qualifiedName, out string parenthesisExpression, out bool anotherEscapeFunctionStarts, out IEdmFunction function)
        {
            qualifiedName = null;
            parenthesisExpression = null;
            anotherEscapeFunctionStarts = false;
            IEdmType bindingType = null;
            IEdmModel model = configuration.Model;
            function = null;

            if (previous != null)
            {
                bindingType = previous.TargetEdmType;
            }

            if (bindingType == null || model == null)
            {
                // escape function is only for bound functions
                return false;
            }

            IEnumerable<IEdmFunction> candidates = model.FindBoundOperations(bindingType).OfType<IEdmFunction>().Where(f => IsUrlEscapeFunction(model, f));

            if (!candidates.HasAny())
            {
                return false;
            }

            string nextPiece = null;
            StringBuilder sb = new StringBuilder();

            while (this.TryGetNextSegmentText(out nextPiece))
            {
                if (sb.Length >= 1)
                {
                    sb.Append('/');
                }

                sb.Append(nextPiece);

                if (nextPiece[nextPiece.Length - 1] == ':')
                {
                    break;
                }
            }

            string identifier = sb.ToString();

            if (identifier != null && identifier.Length >= 2 && identifier[identifier.Length - 2] == ':')
            {
                anotherEscapeFunctionStarts = true;
            }

            bool isComposableRequired = identifier != null && identifier.Length >= 1 && identifier[identifier.Length - 1] == ':';

            function = FindBestMatchForEscapeFunction(candidates, isComposableRequired, bindingType);

            if (function == null)
            {
                // We need to throw because we have consumed segments from the queue and we don't put them back. This is fair because early checks did show an escape function bound to the type. 
                throw ExceptionUtil.CreateBadRequestError(ODataErrorStrings.RequestUriProcessor_NoBoundEscapeFunctionSupported(bindingType.FullTypeName()));
            }

            parenthesisExpression = function.Parameters.ElementAt(1).Name + "='" + (isComposableRequired ? identifier.Substring(0, identifier.Length - 1) : identifier) + "'";
            qualifiedName = function.FullName();

            return true;
        }

        private static IEdmFunction FindBestMatchForEscapeFunction(IEnumerable<IEdmFunction> candidates, bool isComposable, IEdmType bindingType)
        {
            IEdmFunction bestCandidate = null;
            foreach (IEdmFunction f in candidates)
            {
                // If the composability of the above found function does not match, we cannot use the function
                if (f.IsComposable != isComposable)
                {
                    continue;
                }

                IEdmOperationParameter firstParameter;
                if (ParametersMatchEscapeFunction(f.Parameters, out firstParameter))
                {
                    // The first parameter of the function is not an exact match for the binding type then try to find a better match.
                    if (firstParameter.Type.Definition == bindingType)
                    {
                        return f;
                    }
                    else if (bestCandidate != null)
                    {
                        // If the binding parameter for the  bestcandidate so far is a base type of first parameter of the current candidate
                        // then we should use the more specific function, which is the current function. 
                        if (bestCandidate.HasEquivalentBindingType(firstParameter.Type.Definition))
                        {
                            bestCandidate = f;
                        }
                    }
                    else
                    {
                        bestCandidate = f;
                    }
                }
            }

            return bestCandidate;
        }

        private static bool ParametersMatchEscapeFunction(IEnumerable<IEdmOperationParameter> parameters, out IEdmOperationParameter firstParameter)
        {
            firstParameter = null;
            if (parameters == null)
            {
                return false;
            }

            int count = 0;
            foreach (IEdmOperationParameter p in parameters)
            {
                if (++count > 2)
                {
                    return false;
                }

                if (count == 1)
                {
                    firstParameter = p;
                }

                if (count == 2 && !p.Type.IsString())
                {
                    return false;
                }
            }

            return true;
        }

        internal static bool IsUrlEscapeFunction(IEdmModel model, IEdmFunction function)
        {
            Debug.Assert(model != null);
            Debug.Assert(function != null);

            IEdmVocabularyAnnotation annotation = model.FindVocabularyAnnotations<IEdmVocabularyAnnotation>(function,
                Edm.Vocabularies.Community.V1.CommunityVocabularyModel.UrlEscapeFunctionTerm).FirstOrDefault();
            if (annotation != null)
            {
                if (annotation.Value == null)
                {
                    // If the annotation is applied but a value is not specified then the value is assumed to be true.
                    return true;
                }

                if (annotation.Value is IEdmBooleanConstantExpression tagConstant)
                {
                    return tagConstant.Value;
                }
            }

            return false;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ODataPathParser.cs(1623,17): error CS0841: Cannot use local variable 'entitySetSegment' before it is declared,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ODataPathParser.cs(1625,50): error CS0136: A local or parameter named 'entitySetSegment' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Microsoft.OData.Core\UriParser\Parsers\ODataPathParser.cs(1630,54): error CS0136: A local or parameter named 'entitySetSegment' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 25 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Text;
using Microsoft.OData.Edm;
using Microsoft.OData.Evaluation;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Metadata;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData
{
    /// <summary>
    /// Utility functions for writing values for use in a URL.
    /// </summary>
    internal static class ODataUriConversionUtils
    {
        /// <summary>
        /// Converts a primitive to a string for use in a Url.
        /// </summary>
        /// <param name="value">Value to convert.</param>
        /// <param name="version">OData version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="value"/> to be added to a Url.</returns>
        internal static string ConvertToUriPrimitiveLiteral(object value, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(value, "value");

            // TODO: Differences between Astoria and ODL's Uri literals
            /* This should have the same behavior of Astoria with these differences:
             * 1) Cannot handle the System.Data.Linq.Binary type
             * 2) Cannot handle the System.Data.Linq.XElement type
             * 3) Astoria does not put a 'd' or 'D' on double values
             */

            // for legacy backwards compatibility reasons, use the formatter which does not URL-encode the resulting string.
            return LiteralFormatter.ForConstantsWithoutEncoding.Format(value);
        }

        /// <summary>
        /// Converts an enum value to a string for use in a Url.
        /// </summary>
        /// <param name="value">Value to convert.</param>
        /// <param name="version">OData version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="value"/> to be added to a Url.</returns>
        internal static string ConvertToUriEnumLiteral(ODataEnumValue value, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(value, "value");
            ExceptionUtils.CheckArgumentNotNull(value.TypeName, "value.TypeName");
            ExceptionUtils.CheckArgumentNotNull(value.Value, "value.Value");

            // not URL-encode the resulting string:
            return string.Format(CultureInfo.InvariantCulture, "{0}'{1}'", value.TypeName, value.Value);
        }

        /// <summary>
        /// Converts the given string <paramref name="value"/> to an ODataResourceValue and returns it.
        /// </summary>
        /// <remarks>Does not handle primitive values.</remarks>
        /// <param name="value">Value to be deserialized.</param>
        /// <param name="model">Model to use for verification.</param>
        /// <param name="typeReference">Expected type reference from deserialization. If null, verification will be skipped.</param>
        /// <returns>An ODataResourceValue that results from the deserialization of <paramref name="value"/>.</returns>
        internal static object ConvertFromResourceValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            object result = ConvertFromResourceOrCollectionValue(value, model, typeReference);
            Debug.Assert(result is ODataResourceValue, "result is ODataResourceValue");
            return result;
        }

        /// <summary>
        /// Converts the given string <paramref name="value"/> to an ODataCollectionValue and returns it.
        /// Tries in both JSON light and Verbose JSON.
        /// </summary>
        /// <remarks>Does not handle primitive values.</remarks>
        /// <param name="value">Value to be deserialized.</param>
        /// <param name="model">Model to use for verification.</param>
        /// <param name="typeReference">Expected type reference from deserialization. If null, verification will be skipped.</param>
        /// <returns>An ODataCollectionValue that results from the deserialization of <paramref name="value"/>.</returns>
        internal static object ConvertFromCollectionValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            object result = ConvertFromResourceOrCollectionValue(value, model, typeReference);
            Debug.Assert(result is ODataCollectionValue, "result is ODataCollectionValue");
            return result;
        }

        /// <summary>
        /// Verifies that the given <paramref name="primitiveValue"/> is or can be coerced to <paramref name="expectedTypeReference"/>, and coerces it if necessary.
        /// </summary>
        /// <param name="primitiveValue">An EDM primitive value to verify.</param>
        /// <param name="literalValue">The literal value that was parsed as this primitiveValue.</param>
        /// <param name="model">Model to verify against.</param>
        /// <param name="expectedTypeReference">Expected type reference.</param>
        /// <returns>Coerced version of the <paramref name="primitiveValue"/>.</returns>
        internal static object VerifyAndCoerceUriPrimitiveLiteral(
            object primitiveValue,
            string literalValue,
            IEdmModel model,
            IEdmTypeReference expectedTypeReference)
        {
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(literalValue, "literalValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");
            ExceptionUtils.CheckArgumentNotNull(expectedTypeReference, "expectedTypeReference");

            // First deal with null literal
            ODataNullValue nullValue = primitiveValue as ODataNullValue;
            if (nullValue != null)
            {
                if (!expectedTypeReference.IsNullable)
                {
                    throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralNullOnNonNullableType(expectedTypeReference.FullName()));
                }

                return nullValue;
            }

            // Only other positive case is a numeric primitive that needs to be coerced
            IEdmPrimitiveTypeReference expectedPrimitiveTypeReference = expectedTypeReference.AsPrimitiveOrNull();
            if (expectedPrimitiveTypeReference == null)
            {
                throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralTypeVerificationFailure(expectedTypeReference.FullName(), literalValue));
            }

            object coercedResult = CoerceNumericType(primitiveValue, expectedPrimitiveTypeReference.PrimitiveDefinition());
            if (coercedResult != null)
            {
                return coercedResult;
            }

            // if expectedTypeReference is set, need to coerce cast
            coercedResult = CoerceTemporalType(primitiveValue, expectedPrimitiveTypeReference.PrimitiveDefinition());
            if (coercedResult != null)
            {
                return coercedResult;
            }

            Type actualType = primitiveValue.GetType();
            Type targetType = TypeUtils.GetNonNullableType(EdmLibraryExtensions.GetPrimitiveClrType(expectedPrimitiveTypeReference));

            // If target type is assignable from actual type, we're OK
            if (targetType.IsAssignableFrom(actualType))
            {
                return primitiveValue;
            }

            throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralTypeVerificationFailure(expectedPrimitiveTypeReference.FullName(), literalValue));
        }

        /// <summary>
        /// Converts a <see cref="ODataResourceBase"/> to a string for use in a Url.
        /// </summary>
        /// <param name="resource">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="resource"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityLiteral(ODataResourceBase resource, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(resource, "resource");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(
                model,
                context =>
            {
                ODataWriter writer = context.CreateODataUriParameterResourceWriter(null, null);
                WriteStartResource(writer, resource);
                writer.WriteEnd();
            });
        }

        /// <summary>
        /// Converts a list of <see cref="ODataResourceBase"/> to a string for use in a Url.
        /// </summary>
        /// <param name="entries">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="entries"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntitiesLiteral(IEnumerable<ODataResourceBase> entries, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(entries, "entries");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(
                model,
                context =>
            {
                ODataWriter writer = context.CreateODataUriParameterResourceSetWriter(null, null);
                writer.WriteStart(new ODataResourceSet());

                // TODO: Write Complex Properties in entry
                foreach (var resource in entries)
                {
                    WriteStartResource(writer, resource);
                    writer.WriteEnd();
                }

                writer.WriteEnd();
            });
        }

        /// <summary>
        /// Converts a <see cref="ODataEntityReferenceLink"/> to a string for use in a Url.
        /// </summary>
        /// <param name="link">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="link"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityReferenceLiteral(ODataEntityReferenceLink link, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(link, "link");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(model, context => context.WriteEntityReferenceLink(link));
        }

        /// <summary>
        /// Converts a <see cref="ODataEntityReferenceLinks"/> to a string for use in a Url.
        /// </summary>
        /// <param name="links">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="links"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityReferencesLiteral(ODataEntityReferenceLinks links, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(links, "links");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(model, context => context.WriteEntityReferenceLinks(links));
        }

        /// <summary>
        /// Converts a <see cref="ODataResourceValue"/> to a string.
        /// </summary>
        /// <param name="resourceValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="resourceValue"/> to be added.</returns>
        internal static string ConvertToResourceLiteral(ODataResourceValue resourceValue, IEdmModel model, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(resourceValue, "resourceValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            StringBuilder builder = new StringBuilder();
            using (TextWriter textWriter = new StringWriter(builder, CultureInfo.InvariantCulture))
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = version,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,

                    // Should write instance annotations for the literal
                    ShouldIncludeAnnotation = ODataUtils.CreateAnnotationFilter("*")
                };

                WriteJsonLightLiteral(
                    model,
                    messageWriterSettings,
                    textWriter,
                    (serializer) => serializer.WriteResourceValue(
                        resourceValue, /* resourceValue */
                        null, /* metadataTypeReference */
                        true, /* isOpenPropertyType */
                        serializer.CreateDuplicatePropertyNameChecker()));
            }

            return builder.ToString();
        }

        /// <summary>
        /// Converts a <see cref="ODataCollectionValue"/> to a string for use in a Url.
        /// </summary>
        /// <param name="collectionValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with. Collection requires >= V3.</param>
        /// <returns>A string representation of <paramref name="collectionValue"/> to be added to a Url.</returns>
        internal static string ConvertToUriCollectionLiteral(ODataCollectionValue collectionValue, IEdmModel model, ODataVersion version)
        {
            return ConvertToUriCollectionLiteral(collectionValue, model, version, true);
        }

        /// <summary>
        /// Converts a <see cref="ODataCollectionValue"/> to a string for use in a Url.
        /// </summary>
        /// <param name="collectionValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with. Collection requires >= V3.</param>
        /// <param name="isIeee754Compatible">true if value should be IEEE 754 compatible.</param>
        /// <returns>A string representation of <paramref name="collectionValue"/> to be added to a Url.</returns>
        internal static string ConvertToUriCollectionLiteral(ODataCollectionValue collectionValue, IEdmModel model, ODataVersion version, bool isIeee754Compatible)
        {
            ExceptionUtils.CheckArgumentNotNull(collectionValue, "collectionValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            StringBuilder builder = new StringBuilder();
            using (TextWriter textWriter = new StringWriter(builder, CultureInfo.InvariantCulture))
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = version,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,

                    // TBD: Should write instance annotations for the literal???
                    ShouldIncludeAnnotation = ODataUtils.CreateAnnotationFilter("*"),
                    IsIeee754Compatible = isIeee754Compatible
                };

                WriteJsonLightLiteral(
                    model,
                    messageWriterSettings,
                    textWriter,
                    (serializer) => serializer.WriteCollectionValue(
                        collectionValue,
                        null /*metadataTypeReference*/,
                        null /*valueTypeReference*/,
                        false /*isTopLevelProperty*/,
                        true /*isInUri*/,
                        false /*isOpenPropertyType*/));
            }

            return builder.ToString();
        }

        /// <summary>
        /// Coerces the given <paramref name="primitiveValue"/> to the appropriate CLR type based on <paramref name="targetEdmType"/>.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to coerce.</param>
        /// <param name="targetEdmType">Edm primitive type to check against.</param>
        /// <returns><paramref name="primitiveValue"/> as the corresponding CLR type indicated by <paramref name="targetEdmType"/>, or null if unable to coerce.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Centralized method for coercing numeric types in easiest to understand.")]
        internal static object CoerceNumericType(object primitiveValue, IEdmPrimitiveType targetEdmType)
        {
            // This is implemented to match TypePromotionUtils and MetadataUtilsCommon.CanConvertPrimitiveTypeTo()
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(targetEdmType, "targetEdmType");

            EdmPrimitiveTypeKind targetPrimitiveKind = targetEdmType.PrimitiveKind;

            if (primitiveValue is SByte)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.SByte:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int16:
                        return Convert.ToInt16((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((SByte)primitiveValue);
                }
            }

            if (primitiveValue is Byte)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Byte:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int16:
                        return Convert.ToInt16((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Byte)primitiveValue);
                }
            }

            if (primitiveValue is Int16)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Int16:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int16)primitiveValue);
                }
            }

            if (primitiveValue is Int32)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Byte: // Int32 -> byte
                        return ConvertToTargetType(targetEdmType, () => Convert.ToByte((Int32)primitiveValue));
                    case EdmPrimitiveTypeKind.SByte: // Int32 -> sbyte
                        return ConvertToTargetType(targetEdmType, () => Convert.ToSByte((Int32)primitiveValue));
                    case EdmPrimitiveTypeKind.Int16: // Int32 -> short
                        return ConvertToTargetType(targetEdmType, () => Convert.ToInt16((Int32)primitiveValue));
                    case EdmPrimitiveTypeKind.Int32:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int32)primitiveValue);
                }
            }

            if (primitiveValue is Int64)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Int64:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Int64)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int64)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int64)primitiveValue);
                }
            }

            if (primitiveValue is Single)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Single:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Double:
                        /*to string then to double, avoid losing precision like "(double)123.001f" which is 123.00099945068359, instead of 123.001d.*/
                        return double.Parse(((Single)primitiveValue).ToString("R", CultureInfo.InvariantCulture),
                            CultureInfo.InvariantCulture);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Single)primitiveValue);
                }
            }

            if (primitiveValue is Double)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Double:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Decimal:
                        // TODO: extract these conversion steps to an individual function
                        decimal doubleToDecimalR;

                        // To keep the full precision of the current value, which if necessary is all 17 digits of precision supported by the Double type.
                        if (decimal.TryParse(((Double)primitiveValue).ToString("R", CultureInfo.InvariantCulture),
                            out doubleToDecimalR))
                        {
                            return doubleToDecimalR;
                        }

                        return Convert.ToDecimal((Double)primitiveValue);
                }
            }

            if (primitiveValue is Decimal)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Decimal:
                        return primitiveValue;
                }
            }

            return null;
        }

        /// <summary>
        /// Coerces the given <paramref name="primitiveValue"/> to the appropriate CLR type based on <paramref name="targetEdmType"/>.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to coerce.</param>
        /// <param name="targetEdmType">Edm primitive type to check against.</param>
        /// <returns><paramref name="primitiveValue"/> as the corresponding CLR type indicated by <paramref name="targetEdmType"/>, or null if unable to coerce.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
            Justification = "Centralized method for coercing temporal types in easiest to understand.")]
        internal static object CoerceTemporalType(object primitiveValue, IEdmPrimitiveType targetEdmType)
        {
            // This is implemented to match TypePromotionUtils and MetadataUtilsCommon.CanConvertPrimitiveTypeTo()
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(targetEdmType, "targetEdmType");

            EdmPrimitiveTypeKind targetPrimitiveKind = targetEdmType.PrimitiveKind;

            switch (targetPrimitiveKind)
            {
                case EdmPrimitiveTypeKind.DateTimeOffset:
                    if (primitiveValue is Date)
                    {
                        var dateValue = (Date)primitiveValue;
                        return new DateTimeOffset(dateValue.Year, dateValue.Month, dateValue.Day, 0, 0, 0, new TimeSpan(0));
                    }

                    break;

                case EdmPrimitiveTypeKind.Date:
                    var stringValue = primitiveValue as string;
                    if (stringValue != null)
                    {
                        // Coerce to Date Type from String.
                        return PlatformHelper.ConvertStringToDate(stringValue);
                    }

                    break;
            }

            return null;
        }

        /// <summary>
        /// Writes an <see cref="ODataResourceBase"/> as either a resource or a deleted resource.
        /// </summary>
        /// <param name="writer">The <see cref="ODataWriter"/> to use to write the (deleted) resource.</param>
        /// <param name="resource">The resource, or deleted resource, to write.</param>
        private static void WriteStartResource(ODataWriter writer, ODataResourceBase resource)
        {
            ODataDeletedResource deletedResource = resource as ODataDeletedResource;
            if (deletedResource != null)
            {
                writer.WriteStart(deletedResource);
            }
            else
            {
                // will write a null resource if resource is not an ODataResource
                writer.WriteStart(resource as ODataResource);
            }
        }

        /// <summary>
        /// Write a literal value in JSON Light format.
        /// </summary>
        /// <param name="model">EDM Model to use for validation and type lookups.</param>
        /// <param name="messageWriterSettings">Settings to use when writing.</param>
        /// <param name="textWriter">TextWriter to use as the output for the value.</param>
        /// <param name="writeValue">Delegate to use to actually write the value.</param>
        private static void WriteJsonLightLiteral(IEdmModel model, ODataMessageWriterSettings messageWriterSettings, TextWriter textWriter, Action<ODataJsonLightValueSerializer> writeValue)
        {
            IEnumerable<KeyValuePair<string, string>> parameters = new Dictionary<string, string>
            {
                { MimeConstants.MimeIeee754CompatibleParameterName, messageWriterSettings.IsIeee754Compatible.ToString() }
            };
            ODataMediaType mediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType, parameters);

            // Calling dispose since it's the right thing to do, but when created from a custom-built TextWriter
            // the output context Dispose will not actually dispose anything, it will just cleanup itself.
            // TODO: URI parser will also support DI container in the future but set the container to null at this moment.
            ODataMessageInfo messageInfo = new ODataMessageInfo
            {
                Model = model,
                IsAsync = false,
                IsResponse = false,
                MediaType = mediaType
            };

            using (ODataJsonLightOutputContext jsonOutputContext =
                new ODataJsonLightOutputContext(textWriter, messageInfo, messageWriterSettings))
            {
                ODataJsonLightValueSerializer jsonLightValueSerializer = new ODataJsonLightValueSerializer(jsonOutputContext);
                writeValue(jsonLightValueSerializer);
                jsonLightValueSerializer.AssertRecursionDepthIsZero();
            }
        }

        /// <summary>
        /// Convert to a literal value in JSON Light format.
        /// </summary>
        /// <param name="model">EDM Model to use for validation and type lookups.</param>
        /// <param name="writeAction">Delegate to use to actually write the value.</param>
        /// <returns>The literal value string.</returns>
        private static string ConvertToJsonLightLiteral(IEdmModel model, Action<ODataOutputContext> writeAction)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = ODataVersion.V4,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,
                };

                ODataMediaType mediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType);

                ODataMessageInfo messageInfo = new ODataMessageInfo
                {
                    MessageStream = stream,
                    Encoding = Encoding.UTF8,
                    IsAsync = false,
                    IsResponse = false,
                    MediaType = mediaType,
                    Model = model
                };

                // TODO: URI parser will also support DI container in the future but set the container to null at this moment.
                using (ODataJsonLightOutputContext jsonOutputContext =
                    new ODataJsonLightOutputContext(messageInfo, messageWriterSettings))
                {
                    writeAction(jsonOutputContext);
                    stream.Position = 0;
                    return new StreamReader(stream).ReadToEnd();
                }
            }
        }

        private static object ConvertFromResourceOrCollectionValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            ODataMessageReaderSettings settings = new ODataMessageReaderSettings();
            settings.Validations &= ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType;

            using (StringReader reader = new StringReader(value))
            {
                ODataMessageInfo messageInfo = new ODataMessageInfo
                {
                    MediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType),
                    Model = model,
                    IsResponse = false,
                    IsAsync = false,
                    MessageStream = null,
                };

                using (ODataJsonLightInputContext context = new ODataJsonLightInputContext(reader, messageInfo, settings))
                {
                    ODataJsonLightPropertyAndValueDeserializer deserializer = new ODataJsonLightPropertyAndValueDeserializer(context);

                    // TODO: The way JSON array literals look in the URI is different that response payload with an array in it.
                    // The fact that we have to manually setup the underlying reader shows this different in the protocol.
                    // There is a discussion on if we should change this or not.
                    deserializer.JsonReader.Read(); // Move to first thing
                    object rawResult = deserializer.ReadNonEntityValue(
                        null /*payloadTypeName*/,
                        typeReference,
                        null /*DuplicatePropertyNameChecker*/,
                        null /*CollectionWithoutExpectedTypeValidator*/,
                        true /*validateNullValue*/,
                        false /*isTopLevelPropertyValue*/,
                        false /*insideResourceValue*/,
                        null /*propertyName*/);
                    deserializer.ReadPayloadEnd(false);

                    return rawResult;
                }
            }
        }

        private static object ConvertToTargetType(IEdmPrimitiveType targetEdmType, Func<object> converter)
        {
            try
            {
                return converter();
            }
            catch (OverflowException ex)
            {
                throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralOverflowNumber(targetEdmType.FullName(), ex.Message));
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Text;
using Microsoft.OData.Edm;
using Microsoft.OData.Evaluation;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Metadata;
using ODataErrorStrings = Microsoft.OData.Strings;

namespace Microsoft.OData
{
    /// <summary>
    /// Utility functions for writing values for use in a URL.
    /// </summary>
    internal static class ODataUriConversionUtils
    {
        /// <summary>
        /// Converts a primitive to a string for use in a Url.
        /// </summary>
        /// <param name="value">Value to convert.</param>
        /// <param name="version">OData version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="value"/> to be added to a Url.</returns>
        internal static string ConvertToUriPrimitiveLiteral(object value, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(value, "value");

            // TODO: Differences between Astoria and ODL's Uri literals
            /* This should have the same behavior of Astoria with these differences:
             * 1) Cannot handle the System.Data.Linq.Binary type
             * 2) Cannot handle the System.Data.Linq.XElement type
             * 3) Astoria does not put a 'd' or 'D' on double values
             */

            // for legacy backwards compatibility reasons, use the formatter which does not URL-encode the resulting string.
            return LiteralFormatter.ForConstantsWithoutEncoding.Format(value);
        }

        /// <summary>
        /// Converts an enum value to a string for use in a Url.
        /// </summary>
        /// <param name="value">Value to convert.</param>
        /// <param name="version">OData version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="value"/> to be added to a Url.</returns>
        internal static string ConvertToUriEnumLiteral(ODataEnumValue value, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(value, "value");
            ExceptionUtils.CheckArgumentNotNull(value.TypeName, "value.TypeName");
            ExceptionUtils.CheckArgumentNotNull(value.Value, "value.Value");

            // not URL-encode the resulting string:
            return string.Format(CultureInfo.InvariantCulture, "{0}'{1}'", value.TypeName, value.Value);
        }

        /// <summary>
        /// Converts the given string <paramref name="value"/> to an ODataResourceValue and returns it.
        /// </summary>
        /// <remarks>Does not handle primitive values.</remarks>
        /// <param name="value">Value to be deserialized.</param>
        /// <param name="model">Model to use for verification.</param>
        /// <param name="typeReference">Expected type reference from deserialization. If null, verification will be skipped.</param>
        /// <returns>An ODataResourceValue that results from the deserialization of <paramref name="value"/>.</returns>
        internal static object ConvertFromResourceValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            object result = ConvertFromResourceOrCollectionValue(value, model, typeReference);
            Debug.Assert(result is ODataResourceValue, "result is ODataResourceValue");
            return result;
        }

        /// <summary>
        /// Converts the given string <paramref name="value"/> to an ODataCollectionValue and returns it.
        /// Tries in both JSON light and Verbose JSON.
        /// </summary>
        /// <remarks>Does not handle primitive values.</remarks>
        /// <param name="value">Value to be deserialized.</param>
        /// <param name="model">Model to use for verification.</param>
        /// <param name="typeReference">Expected type reference from deserialization. If null, verification will be skipped.</param>
        /// <returns>An ODataCollectionValue that results from the deserialization of <paramref name="value"/>.</returns>
        internal static object ConvertFromCollectionValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            object result = ConvertFromResourceOrCollectionValue(value, model, typeReference);
            Debug.Assert(result is ODataCollectionValue, "result is ODataCollectionValue");
            return result;
        }

        /// <summary>
        /// Verifies that the given <paramref name="primitiveValue"/> is or can be coerced to <paramref name="expectedTypeReference"/>, and coerces it if necessary.
        /// </summary>
        /// <param name="primitiveValue">An EDM primitive value to verify.</param>
        /// <param name="literalValue">The literal value that was parsed as this primitiveValue.</param>
        /// <param name="model">Model to verify against.</param>
        /// <param name="expectedTypeReference">Expected type reference.</param>
        /// <returns>Coerced version of the <paramref name="primitiveValue"/>.</returns>
        internal static object VerifyAndCoerceUriPrimitiveLiteral(
            object primitiveValue,
            string literalValue,
            IEdmModel model,
            IEdmTypeReference expectedTypeReference)
        {
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(literalValue, "literalValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");
            ExceptionUtils.CheckArgumentNotNull(expectedTypeReference, "expectedTypeReference");

            // First deal with null literal
            ODataNullValue nullValue = primitiveValue as ODataNullValue;
            if (nullValue != null)
            {
                if (!expectedTypeReference.IsNullable)
                {
                    throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralNullOnNonNullableType(expectedTypeReference.FullName()));
                }

                return nullValue;
            }

            // Only other positive case is a numeric primitive that needs to be coerced
            IEdmPrimitiveTypeReference expectedPrimitiveTypeReference = expectedTypeReference.AsPrimitiveOrNull();
            if (expectedPrimitiveTypeReference == null)
            {
                throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralTypeVerificationFailure(expectedTypeReference.FullName(), literalValue));
            }

            object coercedResult = CoerceNumericType(primitiveValue, expectedPrimitiveTypeReference.PrimitiveDefinition());
            if (coercedResult != null)
            {
                return coercedResult;
            }

            // if expectedTypeReference is set, need to coerce cast
            coercedResult = CoerceTemporalType(primitiveValue, expectedPrimitiveTypeReference.PrimitiveDefinition());
            if (coercedResult != null)
            {
                return coercedResult;
            }

            Type actualType = primitiveValue.GetType();
            Type targetType = TypeUtils.GetNonNullableType(EdmLibraryExtensions.GetPrimitiveClrType(expectedPrimitiveTypeReference));

            // If target type is assignable from actual type, we're OK
            if (targetType.IsAssignableFrom(actualType))
            {
                return primitiveValue;
            }

            throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralTypeVerificationFailure(expectedPrimitiveTypeReference.FullName(), literalValue));
        }

        /// <summary>
        /// Converts a <see cref="ODataResourceBase"/> to a string for use in a Url.
        /// </summary>
        /// <param name="resource">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="resource"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityLiteral(ODataResourceBase resource, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(resource, "resource");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(
                model,
                context =>
            {
                ODataWriter writer = context.CreateODataUriParameterResourceWriter(null, null);
                WriteStartResource(writer, resource);
                writer.WriteEnd();
            });
        }

        /// <summary>
        /// Converts a list of <see cref="ODataResourceBase"/> to a string for use in a Url.
        /// </summary>
        /// <param name="entries">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="entries"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntitiesLiteral(IEnumerable<ODataResourceBase> entries, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(entries, "entries");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(
                model,
                context =>
            {
                ODataWriter writer = context.CreateODataUriParameterResourceSetWriter(null, null);
                writer.WriteStart(new ODataResourceSet());

                // TODO: Write Complex Properties in entry
                foreach (var resource in entries)
                {
                    WriteStartResource(writer, resource);
                    writer.WriteEnd();
                }

                writer.WriteEnd();
            });
        }

        /// <summary>
        /// Converts a <see cref="ODataEntityReferenceLink"/> to a string for use in a Url.
        /// </summary>
        /// <param name="link">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="link"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityReferenceLiteral(ODataEntityReferenceLink link, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(link, "link");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(model, context => context.WriteEntityReferenceLink(link));
        }

        /// <summary>
        /// Converts a <see cref="ODataEntityReferenceLinks"/> to a string for use in a Url.
        /// </summary>
        /// <param name="links">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <returns>A string representation of <paramref name="links"/> to be added to a Url.</returns>
        internal static string ConvertToUriEntityReferencesLiteral(ODataEntityReferenceLinks links, IEdmModel model)
        {
            ExceptionUtils.CheckArgumentNotNull(links, "links");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            return ConvertToJsonLightLiteral(model, context => context.WriteEntityReferenceLinks(links));
        }

        /// <summary>
        /// Converts a <see cref="ODataResourceValue"/> to a string.
        /// </summary>
        /// <param name="resourceValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with.</param>
        /// <returns>A string representation of <paramref name="resourceValue"/> to be added.</returns>
        internal static string ConvertToResourceLiteral(ODataResourceValue resourceValue, IEdmModel model, ODataVersion version)
        {
            ExceptionUtils.CheckArgumentNotNull(resourceValue, "resourceValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            StringBuilder builder = new StringBuilder();
            using (TextWriter textWriter = new StringWriter(builder, CultureInfo.InvariantCulture))
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = version,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,

                    // Should write instance annotations for the literal
                    ShouldIncludeAnnotation = ODataUtils.CreateAnnotationFilter("*")
                };

                WriteJsonLightLiteral(
                    model,
                    messageWriterSettings,
                    textWriter,
                    (serializer) => serializer.WriteResourceValue(
                        resourceValue, /* resourceValue */
                        null, /* metadataTypeReference */
                        true, /* isOpenPropertyType */
                        serializer.CreateDuplicatePropertyNameChecker()));
            }

            return builder.ToString();
        }

        /// <summary>
        /// Converts a <see cref="ODataCollectionValue"/> to a string for use in a Url.
        /// </summary>
        /// <param name="collectionValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with. Collection requires >= V3.</param>
        /// <returns>A string representation of <paramref name="collectionValue"/> to be added to a Url.</returns>
        internal static string ConvertToUriCollectionLiteral(ODataCollectionValue collectionValue, IEdmModel model, ODataVersion version)
        {
            return ConvertToUriCollectionLiteral(collectionValue, model, version, true);
        }

        /// <summary>
        /// Converts a <see cref="ODataCollectionValue"/> to a string for use in a Url.
        /// </summary>
        /// <param name="collectionValue">Instance to convert.</param>
        /// <param name="model">Model to be used for validation. User model is optional. The EdmLib core model is expected as a minimum.</param>
        /// <param name="version">Version to be compliant with. Collection requires >= V3.</param>
        /// <param name="isIeee754Compatible">true if value should be IEEE 754 compatible.</param>
        /// <returns>A string representation of <paramref name="collectionValue"/> to be added to a Url.</returns>
        internal static string ConvertToUriCollectionLiteral(ODataCollectionValue collectionValue, IEdmModel model, ODataVersion version, bool isIeee754Compatible)
        {
            ExceptionUtils.CheckArgumentNotNull(collectionValue, "collectionValue");
            ExceptionUtils.CheckArgumentNotNull(model, "model");

            StringBuilder builder = new StringBuilder();
            using (TextWriter textWriter = new StringWriter(builder, CultureInfo.InvariantCulture))
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = version,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,

                    // TBD: Should write instance annotations for the literal???
                    ShouldIncludeAnnotation = ODataUtils.CreateAnnotationFilter("*"),
                    IsIeee754Compatible = isIeee754Compatible
                };

                WriteJsonLightLiteral(
                    model,
                    messageWriterSettings,
                    textWriter,
                    (serializer) => serializer.WriteCollectionValue(
                        collectionValue,
                        null /*metadataTypeReference*/,
                        null /*valueTypeReference*/,
                        false /*isTopLevelProperty*/,
                        true /*isInUri*/,
                        false /*isOpenPropertyType*/));
            }

            return builder.ToString();
        }

        /// <summary>
        /// Coerces the given <paramref name="primitiveValue"/> to the appropriate CLR type based on <paramref name="targetEdmType"/>.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to coerce.</param>
        /// <param name="targetEdmType">Edm primitive type to check against.</param>
        /// <returns><paramref name="primitiveValue"/> as the corresponding CLR type indicated by <paramref name="targetEdmType"/>, or null if unable to coerce.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "Centralized method for coercing numeric types in easiest to understand.")]
        internal static object CoerceNumericType(object primitiveValue, IEdmPrimitiveType targetEdmType)
        {
            // This is implemented to match TypePromotionUtils and MetadataUtilsCommon.CanConvertPrimitiveTypeTo()
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(targetEdmType, "targetEdmType");

            EdmPrimitiveTypeKind targetPrimitiveKind = targetEdmType.PrimitiveKind;

            if (primitiveValue is SByte sByte)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.SByte:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int16:
                        return Convert.ToInt16(sByte);
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((SByte)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((SByte)primitiveValue);
                }
            }

            if (primitiveValue is Byte byte)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Byte:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int16:
                        return Convert.ToInt16(byte);
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Byte)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Byte)primitiveValue);
                }
            }

            if (primitiveValue is Int16 i)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Int16:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int32:
                        return Convert.ToInt32(i);
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int16)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int16)primitiveValue);
                }
            }

            if (primitiveValue is Int32 i)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Byte: // Int32 -> byte
                        return ConvertToTargetType(targetEdmType, () => Convert.ToByte(i));
                    case EdmPrimitiveTypeKind.SByte: // Int32 -> sbyte
                        return ConvertToTargetType(targetEdmType, () => Convert.ToSByte((Int32)primitiveValue));
                    case EdmPrimitiveTypeKind.Int16: // Int32 -> short
                        return ConvertToTargetType(targetEdmType, () => Convert.ToInt16((Int32)primitiveValue));
                    case EdmPrimitiveTypeKind.Int32:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Int64:
                        return Convert.ToInt64((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int32)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int32)primitiveValue);
                }
            }

            if (primitiveValue is Int64 i)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Int64:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Single:
                        return Convert.ToSingle(i);
                    case EdmPrimitiveTypeKind.Double:
                        return Convert.ToDouble((Int64)primitiveValue);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Int64)primitiveValue);
                }
            }

            if (primitiveValue is Single single)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Single:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Double:
                        /*to string then to double, avoid losing precision like "(double)123.001f" which is 123.00099945068359, instead of 123.001d.*/
                        return double.Parse(single.ToString("R", CultureInfo.InvariantCulture),
                            CultureInfo.InvariantCulture);
                    case EdmPrimitiveTypeKind.Decimal:
                        return Convert.ToDecimal((Single)primitiveValue);
                }
            }

            if (primitiveValue is Double d)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Double:
                        return primitiveValue;
                    case EdmPrimitiveTypeKind.Decimal:
                        // TODO: extract these conversion steps to an individual function
                        decimal doubleToDecimalR;

                        // To keep the full precision of the current value, which if necessary is all 17 digits of precision supported by the Double type.
                        if (decimal.TryParse(d.ToString("R", CultureInfo.InvariantCulture),
                            out doubleToDecimalR))
                        {
                            return doubleToDecimalR;
                        }

                        return Convert.ToDecimal((Double)primitiveValue);
                }
            }

            if (primitiveValue is Decimal)
            {
                switch (targetPrimitiveKind)
                {
                    case EdmPrimitiveTypeKind.Decimal:
                        return primitiveValue;
                }
            }

            return null;
        }

        /// <summary>
        /// Coerces the given <paramref name="primitiveValue"/> to the appropriate CLR type based on <paramref name="targetEdmType"/>.
        /// </summary>
        /// <param name="primitiveValue">Primitive value to coerce.</param>
        /// <param name="targetEdmType">Edm primitive type to check against.</param>
        /// <returns><paramref name="primitiveValue"/> as the corresponding CLR type indicated by <paramref name="targetEdmType"/>, or null if unable to coerce.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
            Justification = "Centralized method for coercing temporal types in easiest to understand.")]
        internal static object CoerceTemporalType(object primitiveValue, IEdmPrimitiveType targetEdmType)
        {
            // This is implemented to match TypePromotionUtils and MetadataUtilsCommon.CanConvertPrimitiveTypeTo()
            ExceptionUtils.CheckArgumentNotNull(primitiveValue, "primitiveValue");
            ExceptionUtils.CheckArgumentNotNull(targetEdmType, "targetEdmType");

            EdmPrimitiveTypeKind targetPrimitiveKind = targetEdmType.PrimitiveKind;

            switch (targetPrimitiveKind)
            {
                case EdmPrimitiveTypeKind.DateTimeOffset:
                    if (primitiveValue is Date dateValue)
                    {
                        return new DateTimeOffset(dateValue.Year, dateValue.Month, dateValue.Day, 0, 0, 0, new TimeSpan(0));
                    }

                    break;

                case EdmPrimitiveTypeKind.Date:
                    var stringValue = primitiveValue as string;
                    if (stringValue != null)
                    {
                        // Coerce to Date Type from String.
                        return PlatformHelper.ConvertStringToDate(stringValue);
                    }

                    break;
            }

            return null;
        }

        /// <summary>
        /// Writes an <see cref="ODataResourceBase"/> as either a resource or a deleted resource.
        /// </summary>
        /// <param name="writer">The <see cref="ODataWriter"/> to use to write the (deleted) resource.</param>
        /// <param name="resource">The resource, or deleted resource, to write.</param>
        private static void WriteStartResource(ODataWriter writer, ODataResourceBase resource)
        {
            ODataDeletedResource deletedResource = resource as ODataDeletedResource;
            if (deletedResource != null)
            {
                writer.WriteStart(deletedResource);
            }
            else
            {
                // will write a null resource if resource is not an ODataResource
                writer.WriteStart(resource as ODataResource);
            }
        }

        /// <summary>
        /// Write a literal value in JSON Light format.
        /// </summary>
        /// <param name="model">EDM Model to use for validation and type lookups.</param>
        /// <param name="messageWriterSettings">Settings to use when writing.</param>
        /// <param name="textWriter">TextWriter to use as the output for the value.</param>
        /// <param name="writeValue">Delegate to use to actually write the value.</param>
        private static void WriteJsonLightLiteral(IEdmModel model, ODataMessageWriterSettings messageWriterSettings, TextWriter textWriter, Action<ODataJsonLightValueSerializer> writeValue)
        {
            IEnumerable<KeyValuePair<string, string>> parameters = new Dictionary<string, string>
            {
                { MimeConstants.MimeIeee754CompatibleParameterName, messageWriterSettings.IsIeee754Compatible.ToString() }
            };
            ODataMediaType mediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType, parameters);

            // Calling dispose since it's the right thing to do, but when created from a custom-built TextWriter
            // the output context Dispose will not actually dispose anything, it will just cleanup itself.
            // TODO: URI parser will also support DI container in the future but set the container to null at this moment.
            ODataMessageInfo messageInfo = new ODataMessageInfo
            {
                Model = model,
                IsAsync = false,
                IsResponse = false,
                MediaType = mediaType
            };

            using (ODataJsonLightOutputContext jsonOutputContext =
                new ODataJsonLightOutputContext(textWriter, messageInfo, messageWriterSettings))
            {
                ODataJsonLightValueSerializer jsonLightValueSerializer = new ODataJsonLightValueSerializer(jsonOutputContext);
                writeValue(jsonLightValueSerializer);
                jsonLightValueSerializer.AssertRecursionDepthIsZero();
            }
        }

        /// <summary>
        /// Convert to a literal value in JSON Light format.
        /// </summary>
        /// <param name="model">EDM Model to use for validation and type lookups.</param>
        /// <param name="writeAction">Delegate to use to actually write the value.</param>
        /// <returns>The literal value string.</returns>
        private static string ConvertToJsonLightLiteral(IEdmModel model, Action<ODataOutputContext> writeAction)
        {
            using (MemoryStream stream = new MemoryStream())
            {
                ODataMessageWriterSettings messageWriterSettings = new ODataMessageWriterSettings()
                {
                    Version = ODataVersion.V4,
                    Validations = ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType,
                };

                ODataMediaType mediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType);

                ODataMessageInfo messageInfo = new ODataMessageInfo
                {
                    MessageStream = stream,
                    Encoding = Encoding.UTF8,
                    IsAsync = false,
                    IsResponse = false,
                    MediaType = mediaType,
                    Model = model
                };

                // TODO: URI parser will also support DI container in the future but set the container to null at this moment.
                using (ODataJsonLightOutputContext jsonOutputContext =
                    new ODataJsonLightOutputContext(messageInfo, messageWriterSettings))
                {
                    writeAction(jsonOutputContext);
                    stream.Position = 0;
                    return new StreamReader(stream).ReadToEnd();
                }
            }
        }

        private static object ConvertFromResourceOrCollectionValue(string value, IEdmModel model, IEdmTypeReference typeReference)
        {
            ODataMessageReaderSettings settings = new ODataMessageReaderSettings();
            settings.Validations &= ~ValidationKinds.ThrowOnUndeclaredPropertyForNonOpenType;

            using (StringReader reader = new StringReader(value))
            {
                ODataMessageInfo messageInfo = new ODataMessageInfo
                {
                    MediaType = new ODataMediaType(MimeConstants.MimeApplicationType, MimeConstants.MimeJsonSubType),
                    Model = model,
                    IsResponse = false,
                    IsAsync = false,
                    MessageStream = null,
                };

                using (ODataJsonLightInputContext context = new ODataJsonLightInputContext(reader, messageInfo, settings))
                {
                    ODataJsonLightPropertyAndValueDeserializer deserializer = new ODataJsonLightPropertyAndValueDeserializer(context);

                    // TODO: The way JSON array literals look in the URI is different that response payload with an array in it.
                    // The fact that we have to manually setup the underlying reader shows this different in the protocol.
                    // There is a discussion on if we should change this or not.
                    deserializer.JsonReader.Read(); // Move to first thing
                    object rawResult = deserializer.ReadNonEntityValue(
                        null /*payloadTypeName*/,
                        typeReference,
                        null /*DuplicatePropertyNameChecker*/,
                        null /*CollectionWithoutExpectedTypeValidator*/,
                        true /*validateNullValue*/,
                        false /*isTopLevelPropertyValue*/,
                        false /*insideResourceValue*/,
                        null /*propertyName*/);
                    deserializer.ReadPayloadEnd(false);

                    return rawResult;
                }
            }
        }

        private static object ConvertToTargetType(IEdmPrimitiveType targetEdmType, Func<object> converter)
        {
            try
            {
                return converter();
            }
            catch (OverflowException ex)
            {
                throw new ODataException(ODataErrorStrings.ODataUriUtils_ConvertFromUriLiteralOverflowNumber(targetEdmType.FullName(), ex.Message));
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs(404,41): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs(427,41): error CS0128: A local variable or function named 'i' is already defined in this scope,D:\a\1\s\src\Microsoft.OData.Core\Uri\ODataUriConversionUtils.cs(409,88): error CS0165: Use of unassigned local variable 'i'
######################################################################


######################################################################
Nr: 26 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\ODataJsonLightWriterShortSpanIntegrationTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Edm;
using Microsoft.Spatial;
using Xunit;

namespace Microsoft.OData.Tests.IntegrationTests.Writer.JsonLight
{
    public class ODataJsonLightWriterShortSpanIntegrationTests
    {
        private readonly Uri metadataDocumentUri = new Uri("http://odata.org/test/");
        private readonly IEdmModel userModel;
        private readonly EdmEntitySet entitySet;
        private readonly EdmEntityType entityType;
        private readonly EdmEntityType derivedEntityType;
        private readonly EdmEntityType mleEntityType;

        public ODataJsonLightWriterShortSpanIntegrationTests()
        {
            EdmModel tmpModel = new EdmModel();

            EdmComplexType complexType = new EdmComplexType("NS", "MyComplexType");
            EdmComplexTypeReference complexTypeReference = new EdmComplexTypeReference(complexType, isNullable: true);
            complexType.AddProperty(new EdmStructuralProperty(complexType, "StringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));
            complexType.AddProperty(new EdmStructuralProperty(complexType, "ComplexProperty", complexTypeReference));

            EdmComplexType derivedComplexType = new EdmComplexType("NS", "MyDerivedComplexType", complexType, false);
            derivedComplexType.AddProperty(new EdmStructuralProperty(derivedComplexType, "DerivedStringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));

            this.entityType = new EdmEntityType("NS", "MyEntityType", isAbstract: false, isOpen: true, baseType: null);
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "StreamProperty", EdmCoreModel.Instance.GetStream(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "StringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "ComplexProperty", complexTypeReference));
            EdmCollectionTypeReference stringCollectionType = new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(isNullable: false)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "PrimitiveCollectionProperty", stringCollectionType));
            EdmCollectionTypeReference nullableStringCollectionType = new EdmCollectionTypeReference(
                new EdmCollectionType(EdmCoreModel.Instance.GetString(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(
                this.entityType,
                "NullablePrimitiveCollectionProperty",
                nullableStringCollectionType));
            EdmCollectionTypeReference nullableIntCollectionType = new EdmCollectionTypeReference(
                new EdmCollectionType(EdmCoreModel.Instance.GetInt32(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(
                this.entityType,
                "NullableIntCollectionProperty",
                nullableIntCollectionType));
            EdmCollectionTypeReference complexCollectionType = new EdmCollectionTypeReference(new EdmCollectionType(complexTypeReference));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "ComplexCollectionProperty", complexCollectionType));

            this.entityType.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "EntityReferenceProperty", Target = this.entityType, TargetMultiplicity = EdmMultiplicity.ZeroOrOne });
            this.entityType.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "EntitySetReferenceProperty", Target = this.entityType, TargetMultiplicity = EdmMultiplicity.Many });

            this.derivedEntityType = new EdmEntityType("NS", "MyDerivedEntityType", isAbstract: false, isOpen: true, baseType: this.entityType);
            this.mleEntityType = new EdmEntityType("NS", "MyMleEntityType", isAbstract: false, isOpen: true, hasStream: true, baseType: this.derivedEntityType);

            tmpModel.AddElement(this.entityType);
            tmpModel.AddElement(this.derivedEntityType);
            tmpModel.AddElement(this.mleEntityType);
            tmpModel.AddElement(complexType);
            tmpModel.AddElement(derivedComplexType);

            var defaultContainer = new EdmEntityContainer("NS", "DefaultContainer_sub");
            tmpModel.AddElement(defaultContainer);

            this.entitySet = new EdmEntitySet(defaultContainer, "MySet", this.entityType);

            var entityTypeReference = new EdmEntityTypeReference(this.entityType, isNullable: false);

            EdmAction action = new EdmAction("NS", "Action1", null /*returnType*/, true /*isBound*/, null /*entitySetPath*/);
            action.AddParameter( "bindingParameter", entityTypeReference);
            tmpModel.AddElement(action);
            defaultContainer.AddActionImport("Action1", action);

            EdmFunction function = new EdmFunction("NS", "Action1", EdmCoreModel.Instance.GetInt32(true) /*returnType*/, true /*isBound*/, null /*entitySetPath*/, false /*isComposable*/);
            function.AddParameter("bindingParameter", entityTypeReference);
            tmpModel.AddElement(function);
            defaultContainer.AddFunctionImport("Function1", function);

            this.userModel = TestUtils.WrapReferencedModelsToMainModel("NS", "DefaultContainer", tmpModel);
        }

        #region Context Uri tests

        #region Without Metadata Document Uri
        [Fact]
        public void ShouldThrowWhenCreatingResponseWriterWithoutMetadataDocumentUri()
        {
            var stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse: true, userModel: null, serviceDocumentUri: null);
            Action action = () => new ODataJsonLightWriter(outputContext, navigationSource: null, resourceType: null, writingResourceSet: true);
            action.Throws<ODataException>(Strings.ODataOutputContext_MetadataDocumentUriMissing);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithoutUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload("MySet", "NS.MyDerivedEntitytype", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithoutUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload("MySet", "NS.MyDerivedEntitytype", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false, setMetadataDocumentUri: false);
        }
        #endregion Without Metadata Document Uri

        [Fact]
        public void ShouldWriteContextUriForFeedRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedResponseWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingFeedResponseWithoutUserModelAndWithoutSetName()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\"}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryResponseWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingEntryResponseWithoutUserModelAndWithoutSetName()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.entityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedResponseWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingFeedResponseWithUserModelAndWithoutSet()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(/*entitySet*/ null, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.entityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\"}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryResponseWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingEntryResponseWithUserModelAndWithoutSet()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(/*entitySet*/ null, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }
        #endregion Context Uri tests

        #region Media Link Entry tests
        [Fact]
        public void ShouldWriteDefaultStreamForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void StreamReadLinkShouldNotBeOmittedWhenNotIdenticalToEditLink()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob/read"), EditLink = new Uri("http://odata.org/test/Blob/edit") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaEditLink\":\"http://odata.org/test/Blob/edit\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob/read\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void StreamReadLinkShouldBeOmittedWhenIdenticalToEditLink()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob"), EditLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaEditLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyMleEntityType\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: false);
        }
        #endregion Media Link Entry tests

        #region Stream Property tests
        [Fact]
        public void ShouldWriteStreamPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StreamProperty@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteStreamPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StreamProperty@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteStreamPropertyForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: "", writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_StreamPropertyInRequest("StreamProperty"));
        }

        [Fact]
        public void ShouldWriteStreamPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: "", writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_StreamPropertyInRequest("StreamProperty"));
        }
        #endregion Stream Property tests

        #region Null Primitive Property Value tests
        [Fact]
        public void ShouldWriteNullPropertyValueForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Null Primitive Property Value tests

        #region Open Primitive Property tests
        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty + "K\uFFFF") };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\",\"OpenStringProperty\":\"K\\uffff\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\",\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: this.derivedEntityType, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) } } };
            const string expectedPayload = "{\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: this.derivedEntityType, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }
        #endregion Open Primitive Property tests

        #region Complex Property tests
        [Fact]
        public void ShouldWriteComplexPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        #endregion Complex Property tests

        #region Complex Property Inheritance tests
        [Fact]
        public void ShouldWriteComplexPropertyInheritForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Complex Property Inheritance tests

        private ODataItem[] CreateResourceWithComplexProperties(bool inherit = false, bool withTypeName = false)
        {
            var nestedResourceInfo = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource = new ODataResource();
            if (inherit)
            {
                if (withTypeName)
                {
                    nestedResource.TypeName = "NS.MyDerivedComplexType";
                }

                nestedResource.Properties = new ODataProperty[]
                {
                    new ODataProperty { Name = "DerivedStringProperty", Value = "deriveString" }
                };
            }

            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource1 = new ODataResource();
            var resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };

            return new ODataItem[] { resource, nestedResourceInfo, nestedResource, nestedResourceInfo1, nestedResource1 };
        }

        #region Open Complex Property tests
        [Fact]
        public void ShouldWriteOpenComplexPropertyWithoutTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyWithoutTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(false);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        private ODataItem[] CreateEntityWithOpenComplexProperties(bool withTypeName)
        {
            var nestedResourceInfo = new ODataNestedResourceInfo() { Name = "OpenComplexProperty", IsCollection = false };
            var nestedResource = new ODataResource();
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource1 = new ODataResource();
            var resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };

            if (withTypeName)
            {
                nestedResource.TypeName = "NS.MyComplexType";
            }
            return new ODataItem[] { resource, nestedResourceInfo, nestedResource, nestedResourceInfo1, nestedResource1 };
        }

        #endregion Open Complex Property tests

        #region Primitive Collection property tests
        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteNullablePrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "NullablePrimitiveCollectionProperty",
                        Value = new ODataCollectionValue { Items = new[] { null, "string2" } }
                    }
                }
            };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"NullablePrimitiveCollectionProperty\":[null,\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullableIntCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "NullableIntCollectionProperty",
                        Value = new ODataCollectionValue { Items = new object[] { null, 1 } }
                    }
                }
            };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"NullableIntCollectionProperty\":[null,1]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }
        #endregion Primitive Collection property tests

        #region Open Primitive Collection property tests
        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var primitiveCollectionValue = new ODataCollectionValue { TypeName = "Collection(String)", Items = new[] { "string1", "string2" } };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = primitiveCollectionValue } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty@odata.type\":\"#Collection(String)\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var primitiveCollectionValue = new ODataCollectionValue { TypeName = "Collection(String)", Items = new[] { "string1", "string2" } };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = primitiveCollectionValue } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty@odata.type\":\"#Collection(String)\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Open Primitive Collection property tests

        #region Complex Collection property tests
        [Fact]
        public void ShouldWriteComplexCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            Action<ODataWriter> write;
            ODataResource resource = CreateResources(out write);

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}},{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, topLevelItem: resource, writeItems: write, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, false);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            Action<ODataWriter> write;
            ODataResource resource = CreateResources(out write);

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}},{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, topLevelItem: resource, writeItems:write, expectedPayload: expectedPayload, writingResponse: false);
        }

        private  ODataResource CreateResources(out Action<ODataWriter> write)
        {
            ODataResource topLeveResource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexCollectionProperty", IsCollection = true };
            var nestedResourceSet = new ODataResourceSet();
            var nestedResource1 = new ODataResource()
            {
                TypeName = "NS.MyDerivedComplexType",
                Properties = new[] { new ODataProperty { Name = "DerivedStringProperty", Value = "deriveString" } }
            };

            var nestedResourceInfo11 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource11 = new ODataResource();

            var nestedResource2 = new ODataResource();
            var nestedResourceInfo21 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource21 = new ODataResource();

            write = (writer) =>
            {
                writer.WriteStart(topLeveResource);
                writer.WriteStart(nestedResourceInfo1);
                writer.WriteStart(nestedResourceSet);

                writer.WriteStart(nestedResource1);
                writer.WriteStart(nestedResourceInfo11);
                writer.WriteStart(nestedResource11);
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteStart(nestedResource2);
                writer.WriteStart(nestedResourceInfo21);
                writer.WriteStart(nestedResource21);
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();

                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();
            };

            return topLeveResource;

        }
        #endregion Complex Collection property tests

        #region Open Complex Collection property tests

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResources(false, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySet: this.entitySet,
                entityType: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: null,
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResources(false, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySet: null,
                entityType: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: false);
        }

        public ODataItem[] CreateResources(bool withoutModel, bool forOpen)
        {
            ODataResource resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexCollectionProperty", IsCollection = true };
            var nestedResourceSet = new ODataResourceSet();
            var nestedResource1 = new ODataResource();
            var nestedResourceInfo2 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource2 = new ODataResource();

            if (withoutModel)
            {
                if (forOpen)
                {
                    nestedResourceInfo1.SetSerializationInfo(new ODataNestedResourceInfoSerializationInfo() { IsUndeclared = true });
                    nestedResourceSet.TypeName = "Collection(NS.MyComplexType)";
                    nestedResourceSet.SetSerializationInfo(new ODataResourceSerializationInfo { ExpectedTypeName = "NS.MyComplexType", IsFromCollection = true });
                }
            }
            else
            {
                nestedResourceSet.TypeName = "Collection(NS.MyComplexType)";
            }

            if (forOpen)
            {
                nestedResourceInfo1.Name = "OpenComplexCollectionProperty";
            }

            return new ODataItem[] { resource, nestedResourceInfo1, nestedResourceSet, nestedResource1, nestedResourceInfo2, nestedResource2 };
        }

        #endregion Open Complex Collection property tests

        #region Actions tests
        [Fact]
        public void ShouldWriteActionForResponseEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteActionForResponseEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteActionForRequestEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Action1"));
        }

        [Fact]
        public void ShouldWriteActionForRequestEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Action1"));
        }
        #endregion Actions tests

        #region Functions tests
        [Fact]
        public void ShouldWriteFunctionForResponseEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction { Metadata = new Uri("#Function1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteFunctionForResponseEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction { Metadata = new Uri("#Function1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteFunctionForRequestEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction {Metadata = new Uri("#Function1", UriKind.Relative)});
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Function1"));
        }

        [Fact]
        public void ShouldWriteFunctionForRequestEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction {Metadata = new Uri("#Function1", UriKind.Relative)});
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Function1"));
        }
        #endregion Functions tests

        #region Expanded Entry tests
        [Fact]
        public void ShouldWriteExpandedEntryForResponseFeedPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForResponseFeedPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForRequestFeedPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForRequestFeedPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#Collection(NS.MyEntityType)\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: this.entityType, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Expanded Entry tests

        #region Expanded Feed tests
        [Fact]
        public void ShouldWriteExpandedFeedForResponseEntryPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForResponseEntryPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForRequestEntryPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForRequestEntryPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyEntityType\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: this.entityType, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWritePayloadWhenFeedAndEntryHasSerializationInfo()
        {
            var feed = new ODataResourceSet();
            feed.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType" });
            var entry = new ODataResource();
            entry.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet2", NavigationSourceEntityTypeName = "NS.MyEntityType2" });
            List<ODataItem> itemsToWrite = new List<ODataItem>() { feed, entry };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePayloadWhenExpandedFeedAndEntryHasSerializationInfo()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            var entry1 = new ODataResource();
            entry1.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType" });
            itemsToWrite.Add(entry1);
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            var feed = new ODataResourceSet();
            feed.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType"});
            itemsToWrite.Add(feed);
            var entry2 = new ODataResource();
            entry2.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet2", NavigationSourceEntityTypeName = "NS.MyEntityType2" });
            itemsToWrite.Add(entry2);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }
        #endregion Expanded Feed tests

        #region Enum tests
        public enum Color
        {
            Red = 1,
            Green = 2,
            Blue = 3
        }

        [Fact]
        public void WriteEnumWithoutModel()
        {
            var entry = new ODataResource
                {
                    TypeName = "NS.MyDerivedEntityType",
                    Properties = new[]
                        {
                            new ODataProperty
                            {
                                Name = "Color",
                                Value = new ODataEnumValue(Color.Green.ToString())
                            }
                        }
                };

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"Color\":\"Green\"}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: new[] { entry },
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void WriteEnumIntWithoutModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                        {
                            new ODataProperty
                            {
                                Name = "Color",
                                Value = new ODataEnumValue(((int)Color.Green).ToString())
                            }
                        }
            };

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"Color\":\"2\"}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: new[] { entry },
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        #endregion

        #region Prefixing type tests

        [Fact]
        public void WritePrimitivePropertyWithDurationWithUserModel()
        {
            var property = new ODataProperty { Name = "DurationProperty", Value = new ODataPrimitiveValue(new TimeSpan(1, 1, 1)) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"DurationProperty@odata.type\":\"#Duration\",\"DurationProperty\":\"PT1H1M1S\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithByteWithoutUserModel()
        {
            var property = new ODataProperty { Name = "ByteProperty", Value = new ODataPrimitiveValue(Byte.MaxValue) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ByteProperty@odata.type\":\"#Byte\",\"ByteProperty\":255}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithGeographyWithUserModel()
        {
            var property = new ODataProperty { Name = "GeographyProperty", Value = new ODataPrimitiveValue(GeographyFactory.MultiPoint().Point(1.5, 1.0).Point(2.5, 2.0).Build()) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\","
                + "\"@odata.type\":\"#NS.MyDerivedEntityType\","
                + "\"GeographyProperty@odata.type\":\"#GeographyMultiPoint\","
                + "\"GeographyProperty\":{\"type\":\"MultiPoint\",\"coordinates\":[[1.0,1.5],[2.0,2.5]],\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithGeometryWithUserModel()
        {
            var property = new ODataProperty { Name = "GeometryProperty", Value = new ODataPrimitiveValue(GeometryFactory.Collection().Point(-19.99, -12.0).Build()) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\","
                + "\"@odata.type\":\"#NS.MyDerivedEntityType\","
                + "\"GeometryProperty@odata.type\":\"#GeometryCollection\","
                + "\"GeometryProperty\":{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[-19.99,-12.0]}],\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:0\"}}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        #endregion

        private void WriteNestedItemsAndValidatePayload(IEdmEntitySet entitySet, IEdmEntityType entityType, ODataItem[] nestedItemToWrite, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, this.userModel, setMetadataDocumentUri ? this.metadataDocumentUri : null);
            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, entitySet, entityType, nestedItemToWrite[0] is ODataResourceSet);
            WriteNestedItems(nestedItemToWrite, writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(IEdmEntitySet entitySet, IEdmEntityType entityType, ODataItem topLevelItem, Action<ODataWriter> writeItems, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, this.userModel, setMetadataDocumentUri ? this.metadataDocumentUri : null);
            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, entitySet, entityType, topLevelItem is ODataResourceSet);
            writeItems(writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(string entitySetFullName, string derivedEntityTypeFullName, ODataItem[] nestedItemToWrite, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, EdmCoreModel.Instance, setMetadataDocumentUri ? this.metadataDocumentUri : null);

            ODataItem topLevelItem = nestedItemToWrite[0];
            ODataResourceSet topLevelFeed = topLevelItem as ODataResourceSet;

            if (entitySetFullName != null)
            {
                ODataResourceSerializationInfo serializationInfo = entitySetFullName == null ? null : new ODataResourceSerializationInfo { NavigationSourceName = entitySetFullName, NavigationSourceEntityTypeName = "NS.MyEntityType", ExpectedTypeName = derivedEntityTypeFullName ?? "NS.MyEntityType", NavigationSourceKind = EdmNavigationSourceKind.EntitySet };
                if (topLevelFeed != null)
                {
                    topLevelFeed.SetSerializationInfo(serializationInfo);
                }
                else
                {
                    ((ODataResource)topLevelItem).SetSerializationInfo(serializationInfo);
                }
            }

            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, /*entitySet*/ null, /*entityType*/ null, /*writingFeed*/ topLevelFeed != null);
            WriteNestedItems(nestedItemToWrite, writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(string entitySetFullName, string derivedEntityTypeFullName, ODataItem topLevelItem, Action<ODataWriter> writeItems, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, EdmCoreModel.Instance, setMetadataDocumentUri ? this.metadataDocumentUri : null);

            ODataResourceSet topLevelFeed = topLevelItem as ODataResourceSet;

            if (entitySetFullName != null)
            {
                ODataResourceSerializationInfo serializationInfo = entitySetFullName == null ? null : new ODataResourceSerializationInfo { NavigationSourceName = entitySetFullName, NavigationSourceEntityTypeName = "NS.MyEntityType", ExpectedTypeName = derivedEntityTypeFullName ?? "NS.MyEntityType" };
                if (topLevelFeed != null)
                {
                    topLevelFeed.SetSerializationInfo(serializationInfo);
                }
                else
                {
                    ((ODataResource)topLevelItem).SetSerializationInfo(serializationInfo);
                }
            }

            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, /*entitySet*/ null, /*entityType*/ null, /*writingFeed*/ topLevelFeed != null);
            writeItems(writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private static void WriteNestedItems(ODataItem[] nestedItemsToWrite, ODataJsonLightWriter writer)
        {
            foreach (ODataItem itemToWrite in nestedItemsToWrite)
            {
                ODataResourceSet feedToWrite = itemToWrite as ODataResourceSet;
                if (feedToWrite != null)
                {
                    writer.WriteStart(feedToWrite);
                }
                else
                {
                    ODataResource entryToWrite = itemToWrite as ODataResource;
                    if (entryToWrite != null)
                    {
                        writer.WriteStart(entryToWrite);
                    }
                    else
                    {
                        writer.WriteStart((ODataNestedResourceInfo)itemToWrite);
                    }
                }
            }

            for (int count = 0; count < nestedItemsToWrite.Length; count++)
            {
                writer.WriteEnd();
            }
        }

        private static void ValidateWrittenPayload(MemoryStream stream, ODataJsonLightWriter writer, string expectedPayload)
        {
            writer.Flush();
            stream.Seek(0, SeekOrigin.Begin);
            string payload = (new StreamReader(stream)).ReadToEnd();
            Assert.Equal(expectedPayload, payload);
        }

        private static ODataJsonLightOutputContext CreateJsonLightOutputContext(MemoryStream stream, bool writingResponse = true, IEdmModel userModel = null, Uri serviceDocumentUri = null)
        {
            var settings = new ODataMessageWriterSettings { Version = ODataVersion.V4 };
            if (serviceDocumentUri != null)
            {
                settings.SetServiceDocumentUri(serviceDocumentUri);
            }

            var messageInfo = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = new ODataMediaType("application", "json"),
                Encoding = Encoding.UTF8,
                IsResponse = writingResponse,
                IsAsync = false,
                Model = userModel ?? EdmCoreModel.Instance
            };

            return new ODataJsonLightOutputContext(messageInfo, settings);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Edm;
using Microsoft.Spatial;
using Xunit;

namespace Microsoft.OData.Tests.IntegrationTests.Writer.JsonLight
{
    public class ODataJsonLightWriterShortSpanIntegrationTests
    {
        private readonly Uri metadataDocumentUri = new Uri("http://odata.org/test/");
        private readonly IEdmModel userModel;
        private readonly EdmEntitySet entitySet;
        private readonly EdmEntityType entityType;
        private readonly EdmEntityType derivedEntityType;
        private readonly EdmEntityType mleEntityType;

        public ODataJsonLightWriterShortSpanIntegrationTests()
        {
            EdmModel tmpModel = new EdmModel();

            EdmComplexType complexType = new EdmComplexType("NS", "MyComplexType");
            EdmComplexTypeReference complexTypeReference = new EdmComplexTypeReference(complexType, isNullable: true);
            complexType.AddProperty(new EdmStructuralProperty(complexType, "StringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));
            complexType.AddProperty(new EdmStructuralProperty(complexType, "ComplexProperty", complexTypeReference));

            EdmComplexType derivedComplexType = new EdmComplexType("NS", "MyDerivedComplexType", complexType, false);
            derivedComplexType.AddProperty(new EdmStructuralProperty(derivedComplexType, "DerivedStringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));

            this.entityType = new EdmEntityType("NS", "MyEntityType", isAbstract: false, isOpen: true, baseType: null);
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "StreamProperty", EdmCoreModel.Instance.GetStream(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "StringProperty", EdmCoreModel.Instance.GetString(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "ComplexProperty", complexTypeReference));
            EdmCollectionTypeReference stringCollectionType = new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(isNullable: false)));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "PrimitiveCollectionProperty", stringCollectionType));
            EdmCollectionTypeReference nullableStringCollectionType = new EdmCollectionTypeReference(
                new EdmCollectionType(EdmCoreModel.Instance.GetString(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(
                this.entityType,
                "NullablePrimitiveCollectionProperty",
                nullableStringCollectionType));
            EdmCollectionTypeReference nullableIntCollectionType = new EdmCollectionTypeReference(
                new EdmCollectionType(EdmCoreModel.Instance.GetInt32(isNullable: true)));
            this.entityType.AddProperty(new EdmStructuralProperty(
                this.entityType,
                "NullableIntCollectionProperty",
                nullableIntCollectionType));
            EdmCollectionTypeReference complexCollectionType = new EdmCollectionTypeReference(new EdmCollectionType(complexTypeReference));
            this.entityType.AddProperty(new EdmStructuralProperty(this.entityType, "ComplexCollectionProperty", complexCollectionType));

            this.entityType.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "EntityReferenceProperty", Target = this.entityType, TargetMultiplicity = EdmMultiplicity.ZeroOrOne });
            this.entityType.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "EntitySetReferenceProperty", Target = this.entityType, TargetMultiplicity = EdmMultiplicity.Many });

            this.derivedEntityType = new EdmEntityType("NS", "MyDerivedEntityType", isAbstract: false, isOpen: true, baseType: this.entityType);
            this.mleEntityType = new EdmEntityType("NS", "MyMleEntityType", isAbstract: false, isOpen: true, hasStream: true, baseType: this.derivedEntityType);

            tmpModel.AddElement(this.entityType);
            tmpModel.AddElement(this.derivedEntityType);
            tmpModel.AddElement(this.mleEntityType);
            tmpModel.AddElement(complexType);
            tmpModel.AddElement(derivedComplexType);

            var defaultContainer = new EdmEntityContainer("NS", "DefaultContainer_sub");
            tmpModel.AddElement(defaultContainer);

            this.entitySet = new EdmEntitySet(defaultContainer, "MySet", this.entityType);

            var entityTypeReference = new EdmEntityTypeReference(this.entityType, isNullable: false);

            EdmAction action = new EdmAction("NS", "Action1", null /*returnType*/, true /*isBound*/, null /*entitySetPath*/);
            action.AddParameter( "bindingParameter", entityTypeReference);
            tmpModel.AddElement(action);
            defaultContainer.AddActionImport("Action1", action);

            EdmFunction function = new EdmFunction("NS", "Action1", EdmCoreModel.Instance.GetInt32(true) /*returnType*/, true /*isBound*/, null /*entitySetPath*/, false /*isComposable*/);
            function.AddParameter("bindingParameter", entityTypeReference);
            tmpModel.AddElement(function);
            defaultContainer.AddFunctionImport("Function1", function);

            this.userModel = TestUtils.WrapReferencedModelsToMainModel("NS", "DefaultContainer", tmpModel);
        }

        #region Context Uri tests

        #region Without Metadata Document Uri
        [Fact]
        public void ShouldThrowWhenCreatingResponseWriterWithoutMetadataDocumentUri()
        {
            var stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse: true, userModel: null, serviceDocumentUri: null);
            Action action = () => new ODataJsonLightWriter(outputContext, navigationSource: null, resourceType: null, writingResourceSet: true);
            action.Throws<ODataException>(Strings.ODataOutputContext_MetadataDocumentUriMissing);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithoutUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload("MySet", "NS.MyDerivedEntitytype", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithoutUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload("MySet", "NS.MyDerivedEntitytype", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithUserModelAndWithoutMetadataDocumentUri()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false, setMetadataDocumentUri: false);
        }
        #endregion Without Metadata Document Uri

        [Fact]
        public void ShouldWriteContextUriForFeedRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedResponseWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingFeedResponseWithoutUserModelAndWithoutSetName()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\"}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForEntryRequestWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryResponseWithoutUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingEntryResponseWithoutUserModelAndWithoutSetName()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.entityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldNotWriteContextUriForFeedRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"value\":[]}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForFeedResponseWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingFeedResponseWithUserModelAndWithoutSet()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(/*entitySet*/ null, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResourceSet() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType\",\"value\":[]}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryRequestWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.entityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\"}", writingResponse: false);
        }

        [Fact]
        public void ShouldWriteContextUriForEntryResponseWithUserModel()
        {
            this.WriteNestedItemsAndValidatePayload(this.entitySet, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
        }

        [Fact]
        public void ShouldThrowWhenWritingEntryResponseWithUserModelAndWithoutSet()
        {
            Action action = () => this.WriteNestedItemsAndValidatePayload(/*entitySet*/ null, this.derivedEntityType, nestedItemToWrite: new[] { new ODataResource() }, expectedPayload: "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\"}", writingResponse: true);
            action.Throws<ODataException>(Strings.ODataResourceTypeContext_MetadataOrSerializationInfoMissing);
        }
        #endregion Context Uri tests

        #region Media Link Entry tests
        [Fact]
        public void ShouldWriteDefaultStreamForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void StreamReadLinkShouldNotBeOmittedWhenNotIdenticalToEditLink()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob/read"), EditLink = new Uri("http://odata.org/test/Blob/edit") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaEditLink\":\"http://odata.org/test/Blob/edit\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob/read\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void StreamReadLinkShouldBeOmittedWhenIdenticalToEditLink()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob"), EditLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaEditLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteDefaultStreamForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyMleEntityType", MediaResource = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } };
            const string payload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyMleEntityType\",\"@odata.type\":\"#NS.MyMleEntityType\",\"@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: payload, writingResponse: false);
        }
        #endregion Media Link Entry tests

        #region Stream Property tests
        [Fact]
        public void ShouldWriteStreamPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StreamProperty@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteStreamPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StreamProperty@odata.mediaReadLink\":\"http://odata.org/test/Blob\"}";
            this.WriteNestedItemsAndValidatePayload(this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteStreamPropertyForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: "", writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_StreamPropertyInRequest("StreamProperty"));
        }

        [Fact]
        public void ShouldWriteStreamPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StreamProperty", Value = new ODataStreamReferenceValue { ReadLink = new Uri("http://odata.org/test/Blob") } } } };
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: "", writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_StreamPropertyInRequest("StreamProperty"));
        }
        #endregion Stream Property tests

        #region Null Primitive Property Value tests
        [Fact]
        public void ShouldWriteNullPropertyValueForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteNullPropertyValueForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "StringProperty", Value = new ODataNullValue() } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"StringProperty\":null}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Null Primitive Property Value tests

        #region Open Primitive Property tests
        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithTypeNameForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenGuidProperty", Value = new ODataPrimitiveValue(Guid.Empty) } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenGuidProperty@odata.type\":\"#Guid\",\"OpenGuidProperty\":\"00000000-0000-0000-0000-000000000000\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty + "K\uFFFF") };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\",\"OpenStringProperty\":\"K\\uffff\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/NS.MyDerivedEntityType/$entity\",\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: this.derivedEntityType, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: "NS.MyDerivedEntityType", nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitivePropertyWithoutTypeNameForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenStringProperty", Value = new ODataPrimitiveValue(String.Empty) } } };
            const string expectedPayload = "{\"OpenStringProperty\":\"\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: this.derivedEntityType, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false, setMetadataDocumentUri: false);
        }
        #endregion Open Primitive Property tests

        #region Complex Property tests
        [Fact]
        public void ShouldWriteComplexPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties();
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        #endregion Complex Property tests

        #region Complex Property Inheritance tests
        [Fact]
        public void ShouldWriteComplexPropertyInheritForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexPropertyInheritForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResourceWithComplexProperties(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexProperty\":{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Complex Property Inheritance tests

        private ODataItem[] CreateResourceWithComplexProperties(bool inherit = false, bool withTypeName = false)
        {
            var nestedResourceInfo = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource = new ODataResource();
            if (inherit)
            {
                if (withTypeName)
                {
                    nestedResource.TypeName = "NS.MyDerivedComplexType";
                }

                nestedResource.Properties = new ODataProperty[]
                {
                    new ODataProperty { Name = "DerivedStringProperty", Value = "deriveString" }
                };
            }

            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource1 = new ODataResource();
            var resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };

            return new ODataItem[] { resource, nestedResourceInfo, nestedResource, nestedResourceInfo1, nestedResource1 };
        }

        #region Open Complex Property tests
        [Fact]
        public void ShouldWriteOpenComplexPropertyWithoutTypeNameForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyWithoutTypeNameForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(false);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateEntityWithOpenComplexProperties(true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexProperty\":{\"@odata.type\":\"#NS.MyComplexType\",\"ComplexProperty\":{}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        private ODataItem[] CreateEntityWithOpenComplexProperties(bool withTypeName)
        {
            var nestedResourceInfo = new ODataNestedResourceInfo() { Name = "OpenComplexProperty", IsCollection = false };
            var nestedResource = new ODataResource();
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource1 = new ODataResource();
            var resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };

            if (withTypeName)
            {
                nestedResource.TypeName = "NS.MyComplexType";
            }
            return new ODataItem[] { resource, nestedResourceInfo, nestedResource, nestedResourceInfo1, nestedResource1 };
        }

        #endregion Open Complex Property tests

        #region Primitive Collection property tests
        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWritePrimitiveCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "PrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"PrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteNullablePrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "NullablePrimitiveCollectionProperty",
                        Value = new ODataCollectionValue { Items = new[] { null, "string2" } }
                    }
                }
            };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"NullablePrimitiveCollectionProperty\":[null,\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteNullableIntCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "NullableIntCollectionProperty",
                        Value = new ODataCollectionValue { Items = new object[] { null, 1 } }
                    }
                }
            };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"NullableIntCollectionProperty\":[null,1]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }
        #endregion Primitive Collection property tests

        #region Open Primitive Collection property tests
        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var primitiveCollectionValue = new ODataCollectionValue { TypeName = "Collection(String)", Items = new[] { "string1", "string2" } };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = primitiveCollectionValue } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty@odata.type\":\"#Collection(String)\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var property = new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = new ODataCollectionValue { Items = new[] { "string1", "string2" } } };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenPrimitiveCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var primitiveCollectionValue = new ODataCollectionValue { TypeName = "Collection(String)", Items = new[] { "string1", "string2" } };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { new ODataProperty { Name = "OpenPrimitiveCollectionProperty", Value = primitiveCollectionValue } } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenPrimitiveCollectionProperty@odata.type\":\"#Collection(String)\",\"OpenPrimitiveCollectionProperty\":[\"string1\",\"string2\"]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Open Primitive Collection property tests

        #region Complex Collection property tests
        [Fact]
        public void ShouldWriteComplexCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, false);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            Action<ODataWriter> write;
            ODataResource resource = CreateResources(out write);

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}},{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, topLevelItem: resource, writeItems: write, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, false);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: items, expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteComplexCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            Action<ODataWriter> write;
            ODataResource resource = CreateResources(out write);

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ComplexCollectionProperty\":[{\"@odata.type\":\"#NS.MyDerivedComplexType\",\"DerivedStringProperty\":\"deriveString\",\"ComplexProperty\":{}},{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, topLevelItem: resource, writeItems:write, expectedPayload: expectedPayload, writingResponse: false);
        }

        private  ODataResource CreateResources(out Action<ODataWriter> write)
        {
            ODataResource topLeveResource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexCollectionProperty", IsCollection = true };
            var nestedResourceSet = new ODataResourceSet();
            var nestedResource1 = new ODataResource()
            {
                TypeName = "NS.MyDerivedComplexType",
                Properties = new[] { new ODataProperty { Name = "DerivedStringProperty", Value = "deriveString" } }
            };

            var nestedResourceInfo11 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource11 = new ODataResource();

            var nestedResource2 = new ODataResource();
            var nestedResourceInfo21 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource21 = new ODataResource();

            write = (writer) =>
            {
                writer.WriteStart(topLeveResource);
                writer.WriteStart(nestedResourceInfo1);
                writer.WriteStart(nestedResourceSet);

                writer.WriteStart(nestedResource1);
                writer.WriteStart(nestedResourceInfo11);
                writer.WriteStart(nestedResource11);
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteStart(nestedResource2);
                writer.WriteStart(nestedResourceInfo21);
                writer.WriteStart(nestedResource21);
                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();

                writer.WriteEnd();
                writer.WriteEnd();
                writer.WriteEnd();
            };

            return topLeveResource;

        }
        #endregion Complex Collection property tests

        #region Open Complex Collection property tests

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForResponseEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForResponseEntryPayloadWithUserModel()
        {
            var items = CreateResources(false, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySet: this.entitySet,
                entityType: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForRequestEntryPayloadWithoutUserModel()
        {
            var items = CreateResources(true, true);
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: null,
                derivedEntityTypeFullName: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: false);
        }

        [Fact]
        public void ShouldWriteOpenComplexCollectionPropertyForRequestEntryPayloadWithUserModel()
        {
            var items = CreateResources(false, true);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyDerivedEntityType\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"OpenComplexCollectionProperty@odata.type\":\"#Collection(NS.MyComplexType)\",\"OpenComplexCollectionProperty\":[{\"ComplexProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(
                entitySet: null,
                entityType: null,
                nestedItemToWrite: items,
                expectedPayload: expectedPayload,
                writingResponse: false);
        }

        public ODataItem[] CreateResources(bool withoutModel, bool forOpen)
        {
            ODataResource resource = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            var nestedResourceInfo1 = new ODataNestedResourceInfo() { Name = "ComplexCollectionProperty", IsCollection = true };
            var nestedResourceSet = new ODataResourceSet();
            var nestedResource1 = new ODataResource();
            var nestedResourceInfo2 = new ODataNestedResourceInfo() { Name = "ComplexProperty", IsCollection = false };
            var nestedResource2 = new ODataResource();

            if (withoutModel)
            {
                if (forOpen)
                {
                    nestedResourceInfo1.SetSerializationInfo(new ODataNestedResourceInfoSerializationInfo() { IsUndeclared = true });
                    nestedResourceSet.TypeName = "Collection(NS.MyComplexType)";
                    nestedResourceSet.SetSerializationInfo(new ODataResourceSerializationInfo { ExpectedTypeName = "NS.MyComplexType", IsFromCollection = true });
                }
            }
            else
            {
                nestedResourceSet.TypeName = "Collection(NS.MyComplexType)";
            }

            if (forOpen)
            {
                nestedResourceInfo1.Name = "OpenComplexCollectionProperty";
            }

            return new ODataItem[] { resource, nestedResourceInfo1, nestedResourceSet, nestedResource1, nestedResourceInfo2, nestedResource2 };
        }

        #endregion Open Complex Collection property tests

        #region Actions tests
        [Fact]
        public void ShouldWriteActionForResponseEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteActionForResponseEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteActionForRequestEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Action1"));
        }

        [Fact]
        public void ShouldWriteActionForRequestEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddAction(new ODataAction { Metadata = new Uri("#Action1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Action1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Action1"));
        }
        #endregion Actions tests

        #region Functions tests
        [Fact]
        public void ShouldWriteFunctionForResponseEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction { Metadata = new Uri("#Function1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteFunctionForResponseEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction { Metadata = new Uri("#Function1", UriKind.Relative) });
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteFunctionForRequestEntryPayloadWithoutUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction {Metadata = new Uri("#Function1", UriKind.Relative)});
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Function1"));
        }

        [Fact]
        public void ShouldWriteFunctionForRequestEntryPayloadWithUserModel()
        {
            ODataResource entry = new ODataResource { TypeName = "NS.MyDerivedEntityType" };
            entry.AddFunction(new ODataFunction {Metadata = new Uri("#Function1", UriKind.Relative)});
            const string expectedPayload = "{\"@odata.type\":\"#NS.MyDerivedEntityType\",\"#Function1\":{}}";
            Action action = () => this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: false);
            action.Throws<ODataException>(Strings.WriterValidationUtils_OperationInRequest("#Function1"));
        }
        #endregion Functions tests

        #region Expanded Entry tests
        [Fact]
        public void ShouldWriteExpandedEntryForResponseFeedPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForResponseFeedPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForRequestFeedPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteExpandedEntryForRequestFeedPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntityReferenceProperty", IsCollection = false });
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#Collection(NS.MyEntityType)\",\"value\":[{\"EntityReferenceProperty\":{}}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: this.entityType, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }
        #endregion Expanded Entry tests

        #region Expanded Feed tests
        [Fact]
        public void ShouldWriteExpandedFeedForResponseEntryPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForResponseEntryPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForRequestEntryPayloadWithoutUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWriteExpandedFeedForRequestEntryPayloadWithUserModel()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            itemsToWrite.Add(new ODataResource());
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            itemsToWrite.Add(new ODataResourceSet());
            itemsToWrite.Add(new ODataResource());
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#NS.MyEntityType\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySet: null, entityType: this.entityType, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: false);
        }

        [Fact]
        public void ShouldWritePayloadWhenFeedAndEntryHasSerializationInfo()
        {
            var feed = new ODataResourceSet();
            feed.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType" });
            var entry = new ODataResource();
            entry.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet2", NavigationSourceEntityTypeName = "NS.MyEntityType2" });
            List<ODataItem> itemsToWrite = new List<ODataItem>() { feed, entry };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet\",\"value\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void ShouldWritePayloadWhenExpandedFeedAndEntryHasSerializationInfo()
        {
            List<ODataItem> itemsToWrite = new List<ODataItem>();
            var entry1 = new ODataResource();
            entry1.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType" });
            itemsToWrite.Add(entry1);
            itemsToWrite.Add(new ODataNestedResourceInfo { Name = "EntitySetReferenceProperty", IsCollection = true });
            var feed = new ODataResourceSet();
            feed.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet", NavigationSourceEntityTypeName = "NS.MyEntityType"});
            itemsToWrite.Add(feed);
            var entry2 = new ODataResource();
            entry2.SetSerializationInfo(new ODataResourceSerializationInfo { NavigationSourceName = "MySet2", NavigationSourceEntityTypeName = "NS.MyEntityType2" });
            itemsToWrite.Add(entry2);
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"EntitySetReferenceProperty\":[{}]}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: null, derivedEntityTypeFullName: null, nestedItemToWrite: itemsToWrite.ToArray(), expectedPayload: expectedPayload, writingResponse: true);
        }
        #endregion Expanded Feed tests

        #region Enum tests
        public enum Color
        {
            Red = 1,
            Green = 2,
            Blue = 3
        }

        [Fact]
        public void WriteEnumWithoutModel()
        {
            var entry = new ODataResource
                {
                    TypeName = "NS.MyDerivedEntityType",
                    Properties = new[]
                        {
                            new ODataProperty
                            {
                                Name = "Color",
                                Value = new ODataEnumValue(Color.Green.ToString())
                            }
                        }
                };

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"Color\":\"Green\"}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: new[] { entry },
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        [Fact]
        public void WriteEnumIntWithoutModel()
        {
            var entry = new ODataResource
            {
                TypeName = "NS.MyDerivedEntityType",
                Properties = new[]
                        {
                            new ODataProperty
                            {
                                Name = "Color",
                                Value = new ODataEnumValue(((int)Color.Green).ToString())
                            }
                        }
            };

            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"Color\":\"2\"}";
            this.WriteNestedItemsAndValidatePayload(
                entitySetFullName: "MySet",
                derivedEntityTypeFullName: null,
                nestedItemToWrite: new[] { entry },
                expectedPayload: expectedPayload,
                writingResponse: true);
        }

        #endregion

        #region Prefixing type tests

        [Fact]
        public void WritePrimitivePropertyWithDurationWithUserModel()
        {
            var property = new ODataProperty { Name = "DurationProperty", Value = new ODataPrimitiveValue(new TimeSpan(1, 1, 1)) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"DurationProperty@odata.type\":\"#Duration\",\"DurationProperty\":\"PT1H1M1S\"}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithByteWithoutUserModel()
        {
            var property = new ODataProperty { Name = "ByteProperty", Value = new ODataPrimitiveValue(Byte.MaxValue) };
            property.SetSerializationInfo(new ODataPropertySerializationInfo { PropertyKind = ODataPropertyKind.Open });
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\",\"@odata.type\":\"#NS.MyDerivedEntityType\",\"ByteProperty@odata.type\":\"#Byte\",\"ByteProperty\":255}";
            this.WriteNestedItemsAndValidatePayload(entitySetFullName: "MySet", derivedEntityTypeFullName: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithGeographyWithUserModel()
        {
            var property = new ODataProperty { Name = "GeographyProperty", Value = new ODataPrimitiveValue(GeographyFactory.MultiPoint().Point(1.5, 1.0).Point(2.5, 2.0).Build()) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\","
                + "\"@odata.type\":\"#NS.MyDerivedEntityType\","
                + "\"GeographyProperty@odata.type\":\"#GeographyMultiPoint\","
                + "\"GeographyProperty\":{\"type\":\"MultiPoint\",\"coordinates\":[[1.0,1.5],[2.0,2.5]],\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:4326\"}}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        [Fact]
        public void WritePrimitivePropertyWithGeometryWithUserModel()
        {
            var property = new ODataProperty { Name = "GeometryProperty", Value = new ODataPrimitiveValue(GeometryFactory.Collection().Point(-19.99, -12.0).Build()) };
            var entry = new ODataResource { TypeName = "NS.MyDerivedEntityType", Properties = new[] { property } };
            const string expectedPayload = "{\"@odata.context\":\"http://odata.org/test/$metadata#MySet/$entity\","
                + "\"@odata.type\":\"#NS.MyDerivedEntityType\","
                + "\"GeometryProperty@odata.type\":\"#GeometryCollection\","
                + "\"GeometryProperty\":{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[-19.99,-12.0]}],\"crs\":{\"type\":\"name\",\"properties\":{\"name\":\"EPSG:0\"}}}}";
            this.WriteNestedItemsAndValidatePayload(entitySet: this.entitySet, entityType: null, nestedItemToWrite: new[] { entry }, expectedPayload: expectedPayload, writingResponse: true);
        }

        #endregion

        private void WriteNestedItemsAndValidatePayload(IEdmEntitySet entitySet, IEdmEntityType entityType, ODataItem[] nestedItemToWrite, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, this.userModel, setMetadataDocumentUri ? this.metadataDocumentUri : null);
            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, entitySet, entityType, nestedItemToWrite[0] is ODataResourceSet);
            WriteNestedItems(nestedItemToWrite, writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(IEdmEntitySet entitySet, IEdmEntityType entityType, ODataItem topLevelItem, Action<ODataWriter> writeItems, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, this.userModel, setMetadataDocumentUri ? this.metadataDocumentUri : null);
            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, entitySet, entityType, topLevelItem is ODataResourceSet);
            writeItems(writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(string entitySetFullName, string derivedEntityTypeFullName, ODataItem[] nestedItemToWrite, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, EdmCoreModel.Instance, setMetadataDocumentUri ? this.metadataDocumentUri : null);

            ODataItem topLevelItem = nestedItemToWrite[0];

            if (entitySetFullName != null)
            {
                ODataResourceSerializationInfo serializationInfo = entitySetFullName == null ? null : new ODataResourceSerializationInfo { NavigationSourceName = entitySetFullName, NavigationSourceEntityTypeName = "NS.MyEntityType", ExpectedTypeName = derivedEntityTypeFullName ?? "NS.MyEntityType", NavigationSourceKind = EdmNavigationSourceKind.EntitySet };

                if (topLevelItem is ODataResourceSet topLevelFeed)
                {
                    topLevelFeed.SetSerializationInfo(serializationInfo);
                }
                else
                {
                    ((ODataResource)topLevelItem).SetSerializationInfo(serializationInfo);
                }
            }

            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, /*entitySet*/ null, /*entityType*/ null, /*writingFeed*/ topLevelItem is ODataResourceSet topLevelFeed);
            WriteNestedItems(nestedItemToWrite, writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private void WriteNestedItemsAndValidatePayload(string entitySetFullName, string derivedEntityTypeFullName, ODataItem topLevelItem, Action<ODataWriter> writeItems, string expectedPayload, bool writingResponse = true, bool setMetadataDocumentUri = true)
        {
            MemoryStream stream = new MemoryStream();
            ODataJsonLightOutputContext outputContext = CreateJsonLightOutputContext(stream, writingResponse, EdmCoreModel.Instance, setMetadataDocumentUri ? this.metadataDocumentUri : null);

            if (entitySetFullName != null)
            {
                ODataResourceSerializationInfo serializationInfo = entitySetFullName == null ? null : new ODataResourceSerializationInfo { NavigationSourceName = entitySetFullName, NavigationSourceEntityTypeName = "NS.MyEntityType", ExpectedTypeName = derivedEntityTypeFullName ?? "NS.MyEntityType" };

                if (topLevelItem is ODataResourceSet topLevelFeed)
                {
                    topLevelFeed.SetSerializationInfo(serializationInfo);
                }
                else
                {
                    ((ODataResource)topLevelItem).SetSerializationInfo(serializationInfo);
                }
            }

            ODataJsonLightWriter writer = new ODataJsonLightWriter(outputContext, /*entitySet*/ null, /*entityType*/ null, /*writingFeed*/ topLevelItem is ODataResourceSet topLevelFeed);
            writeItems(writer);
            ValidateWrittenPayload(stream, writer, expectedPayload);
        }

        private static void WriteNestedItems(ODataItem[] nestedItemsToWrite, ODataJsonLightWriter writer)
        {
            foreach (ODataItem itemToWrite in nestedItemsToWrite)
            {
                if (itemToWrite is ODataResourceSet feedToWrite)
                {
                    writer.WriteStart(feedToWrite);
                }
                else
                {
                    if (itemToWrite is ODataResource entryToWrite)
                    {
                        writer.WriteStart(entryToWrite);
                    }
                    else
                    {
                        writer.WriteStart((ODataNestedResourceInfo)itemToWrite);
                    }
                }
            }

            for (int count = 0; count < nestedItemsToWrite.Length; count++)
            {
                writer.WriteEnd();
            }
        }

        private static void ValidateWrittenPayload(MemoryStream stream, ODataJsonLightWriter writer, string expectedPayload)
        {
            writer.Flush();
            stream.Seek(0, SeekOrigin.Begin);
            string payload = (new StreamReader(stream)).ReadToEnd();
            Assert.Equal(expectedPayload, payload);
        }

        private static ODataJsonLightOutputContext CreateJsonLightOutputContext(MemoryStream stream, bool writingResponse = true, IEdmModel userModel = null, Uri serviceDocumentUri = null)
        {
            var settings = new ODataMessageWriterSettings { Version = ODataVersion.V4 };
            if (serviceDocumentUri != null)
            {
                settings.SetServiceDocumentUri(serviceDocumentUri);
            }

            var messageInfo = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = new ODataMediaType("application", "json"),
                Encoding = Encoding.UTF8,
                IsResponse = writingResponse,
                IsAsync = false,
                Model = userModel ?? EdmCoreModel.Instance
            };

            return new ODataJsonLightOutputContext(messageInfo, settings);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\ODataJsonLightWriterShortSpanIntegrationTests.cs(1209,54): error CS0136: A local or parameter named 'topLevelFeed' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\IntegrationTests\Writer\JsonLight\ODataJsonLightWriterShortSpanIntegrationTests.cs(1233,54): error CS0136: A local or parameter named 'topLevelFeed' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 27 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\PrimitiveValuesRoundtripJsonLightTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Tests.JsonLight;
using Microsoft.OData.Edm;
using Microsoft.Spatial;
using Microsoft.Test.OData.DependencyInjection;
using Xunit;

namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip.JsonLight
{
    public class PrimitiveValuesRoundtripJsonLightTests
    {
        private EdmModel model;
        private IServiceProvider container;

        public PrimitiveValuesRoundtripJsonLightTests()
        {
            model = new EdmModel();
        }

        [Fact]
        public void BinaryRoundtripJsonLightTest()
        {
            var values = new byte[][]
            {
                new byte[0],
                new byte[] { 0 },
                new byte[] { 42, Byte.MinValue, Byte.MaxValue },
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Binary");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void BinaryPayloadAsStringRoundtripJsonLightTest()
        {
            var values = new byte[][]
            {
                new byte[0],
                new byte[] { 0 },
                new byte[] { 42, Byte.MinValue, Byte.MaxValue },
            };

            var expectedValues = new string[]
            {
                Convert.ToBase64String(values[0]),
                Convert.ToBase64String(values[1]),
                Convert.ToBase64String(values[2])
            };

            this.container = ContainerBuilderHelper.BuildContainer(
                builder => builder.AddService<ODataPayloadValueConverter, BinaryFieldAsStringPrimitivePayloadValueConverter>(ServiceLifetime.Singleton));

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationAndWithExpectedValues(values, "Edm.Binary", expectedValues);
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(expectedValues, "Edm.Binary");
        }

        [Fact]
        public void BooleanRoundtripJsonLightTest()
        {
            var values = new bool[]
            {
                true, 
                false,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Boolean");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void ByteRoundtripJsonLightTest()
        {
            var values = new byte[]
            {
                0,
                42,
                Byte.MaxValue,
                Byte.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Byte");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DateRoundtripJsonLightTest()
        {
            var values = new Date[]
            {
                new Date(2012, 4, 13),
                new Date(1, 1, 1),
                new Date(9999, 12, 31),
                new Date(), 
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Date");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DateTimeOffsetRoundtripJsonLightTest()
        {
            var values = new DateTimeOffset[]
            {
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, TimeSpan.Zero),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(840)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(-840)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(123)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(-42)),
                DateTimeOffset.MinValue,
                DateTimeOffset.MaxValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.DateTimeOffset");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DecimalRoundtripJsonLightTest()
        {
            var values = new decimal[]
            {
                0,
                1,
                -1,
                Decimal.MinValue,
                Decimal.MaxValue,
                10^-28,
                10^28,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Decimal");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DecimalRoundTripJsonLightTestWithIeee754CompatibleFalse()
        {
            var values = new decimal[]
            {
                0,
                1,
                -1,
                Decimal.MinValue,
                Decimal.MaxValue,
                10^-28,
                10^28,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(values, "Edm.Decimal");

            // precision lose for Ieee754Compatible=false
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(new[] { Decimal.MaxValue, Decimal.MinValue });
        }

        [Fact]
        public void DoubleRoundtripJsonLightTest()
        {
            IEnumerable<double> valuesWrittenAsDigits = new double[]
            {
                0,
                42,
                42.42,
                Double.MaxValue,
                Double.MinValue,
                -4.42330604244772E-305,
                42E20,
            };

            IEnumerable<double> valuesWrittenAsString = new double[]
            {
                Double.PositiveInfinity,
                Double.NegativeInfinity,
                Double.NaN,                       
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(valuesWrittenAsDigits.Concat(valuesWrittenAsString), "Edm.Double");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(valuesWrittenAsDigits);
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(valuesWrittenAsString);
        }

        [Fact]
        public void GuidRoundtripJsonLightTest()
        {
            var values = new Guid[]
            {
                new Guid(0, 0, 0, new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }),
                new Guid("C8864E5E-BDB1-4FB2-A1C4-8F8E49C271EA"),
                Guid.Empty,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Guid");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int16RoundtripJsonLightTest()
        {
            var values = new Int16[]
            {
                0,
                42,
                -43,
                Int16.MaxValue,
                Int16.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int16");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int32RoundtripJsonLightTest()
        {
            var values = new Int32[]
            {
                0,
                42,
                -43,
                Int32.MaxValue,
                Int32.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int32");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int64RoundtripJsonLightTest()
        {
            var values = new Int64[]
            {
                0,
                42,
                -43,
                Int64.MaxValue,
                Int64.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int64");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int64RoundTripJsonLightTestWithIeee754CompatibleFalse()
        {
            var values = new Int64[]
            {
                0,
                42,
                -43,
                Int64.MaxValue,
                Int64.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(values, "Edm.Int64");

            // precision lose for Ieee754Compatible=false
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(new[] { Int64.MaxValue, Int64.MinValue });
        }

        [Fact]
        public void SByteRoundtripJsonLightTest()
        {
            var values = new SByte[]
            {
                0,
                42,
                -43,
                SByte.MaxValue,
                SByte.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.SByte");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void StringRoundtripJsonLightTest()
        {
            var values = new string[]
            {
                string.Empty,
                " ",
                "testvalue",
                "TestValue",
                "\r\n\t",
                "\"",
                "\'",
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.String");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void SingleRoundtripJsonLightTest()
        {
            var values = new Single[]
            {
                0,
                42,
                (float)-43.43,
                Single.MaxValue,
                Single.MinValue,
                Single.PositiveInfinity,
                Single.NegativeInfinity,
                Single.NaN,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Single");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void TimeRoundtripJsonLightTest()
        {
            var values = new TimeSpan[]
            {
                new TimeSpan(1, 2, 3, 4, 5),
                TimeSpan.Zero,
                TimeSpan.MinValue,
                TimeSpan.MaxValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Duration");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void TimeOfDayRoundtripJsonLightTest()
        {
            var values = new TimeOfDay[]
            {
                new TimeOfDay(10, 5, 30, 90),
                new TimeOfDay(TimeOfDay.MinTickValue),
                new TimeOfDay(TimeOfDay.MaxTickValue),
                new TimeOfDay(), 
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.TimeOfDay");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void GeographyMultiLineStringRoundtripJsonLightTest()
        {
            var values = new GeographyMultiLineString[]
            {
                GeographyFactory.MultiLineString().LineString(0, 0).LineTo(0, 0).Build(), 
                GeographyFactory.MultiLineString().LineString(-90.0, -90.0).LineTo(0, 0).LineString(90.0, 90.0).LineTo(0, 0).Build(), 
                GeographyFactory.MultiLineString().LineString(-90.0, 0).LineTo(0, 0).LineString(0, 0).LineTo(0, 0).LineString(0, 90.0).LineTo(0, 0).Build()
            };
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "GeographyMultiLineString");
        }

        [Fact]
        public void GeometryCollectionRoundtripJsonLightTest()
        {
            var values = new GeometryCollection[]
            {
                GeometryFactory.Collection().Build(),
                GeometryFactory.Collection().Point(0, 0).Build()
            };
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "GeometryCollection");
        }

        [Fact]
        public void UInt16RoundtripJsonLightTest()
        {
            var uint16 = new EdmTypeDefinition("NS", "UInt16", EdmPrimitiveTypeKind.Double);
            var uint16Ref = new EdmTypeDefinitionReference(uint16, true);
            this.model.AddElement(uint16);
            this.model.SetPrimitiveValueConverter(uint16Ref, UInt16ValueConverter.Instance);
            var values = new[]
            {
                (UInt16)123,
                UInt16.MinValue,
                UInt16.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt16");
        }

        [Fact]
        public void UInt32RoundtripJsonLightTest()
        {
            var uint32 = new EdmTypeDefinition("NS", "UInt32", EdmPrimitiveTypeKind.String);
            var uint32Ref = new EdmTypeDefinitionReference(uint32, true);
            this.model.AddElement(uint32);
            this.model.SetPrimitiveValueConverter(uint32Ref, UInt32ValueConverter.Instance);
            var values = new[]
            {
                (UInt32)456,
                UInt32.MinValue,
                UInt32.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt32");
        }

        [Fact]
        public void UInt64RoundtripJsonLightTest()
        {
            var uint64 = new EdmTypeDefinition("NS", "UInt64", EdmPrimitiveTypeKind.String);
            var uint64Ref = new EdmTypeDefinitionReference(uint64, true);
            this.model.AddElement(uint64);
            this.model.SetPrimitiveValueConverter(uint64Ref, UInt64ValueConverter.Instance);
            var values = new[]
            {
                (UInt64)456,
                UInt64.MinValue,
                UInt64.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt64");
        }

        [Fact]
        public void UnsignedIntAndTypeDefinitionRoundtripJsonLightIntegrationTest()
        {
            var model = new EdmModel();

            var uint16 = new EdmTypeDefinition("MyNS", "UInt16", EdmPrimitiveTypeKind.Double);
            var uint16Ref = new EdmTypeDefinitionReference(uint16, false);
            model.AddElement(uint16);
            model.SetPrimitiveValueConverter(uint16Ref, UInt16ValueConverter.Instance);

            var uint64 = new EdmTypeDefinition("MyNS", "UInt64", EdmPrimitiveTypeKind.String);
            var uint64Ref = new EdmTypeDefinitionReference(uint64, false);
            model.AddElement(uint64);
            model.SetPrimitiveValueConverter(uint64Ref, UInt64ValueConverter.Instance);

            var guidType = new EdmTypeDefinition("MyNS", "Guid", EdmPrimitiveTypeKind.Int64);
            var guidRef = new EdmTypeDefinitionReference(guidType, true);
            model.AddElement(guidType);

            var personType = new EdmEntityType("MyNS", "Person");
            personType.AddKeys(personType.AddStructuralProperty("ID", uint64Ref));
            personType.AddStructuralProperty("Name", EdmPrimitiveTypeKind.String);
            personType.AddStructuralProperty("FavoriteNumber", uint16Ref);
            personType.AddStructuralProperty("Age", model.GetUInt32("MyNS", true));
            personType.AddStructuralProperty("Guid", guidRef);
            personType.AddStructuralProperty("Weight", EdmPrimitiveTypeKind.Double);
            personType.AddStructuralProperty("Money", EdmPrimitiveTypeKind.Decimal);
            model.AddElement(personType);

            var container = new EdmEntityContainer("MyNS", "Container");
            var peopleSet = container.AddEntitySet("People", personType);
            model.AddElement(container);

            var stream = new MemoryStream();
            IODataResponseMessage message = new InMemoryMessage { Stream = stream };
            message.StatusCode = 200;

            var writerSettings = new ODataMessageWriterSettings();
            writerSettings.SetServiceDocumentUri(new Uri("http://host/service"));

            var messageWriter = new ODataMessageWriter(message, writerSettings, model);
            var entryWriter = messageWriter.CreateODataResourceWriter(peopleSet);

            var entry = new ODataResource
            {
                TypeName = "MyNS.Person",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "ID",
                        Value = UInt64.MaxValue
                    },
                    new ODataProperty
                    {
                        Name = "Name",
                        Value = "Foo"
                    },
                    new ODataProperty
                    {
                        Name = "FavoriteNumber",
                        Value = (UInt16)250
                    },
                    new ODataProperty
                    {
                        Name = "Age",
                        Value = (UInt32)123
                    },
                    new ODataProperty
                    {
                        Name = "Guid",
                        Value = Int64.MinValue
                    },
                    new ODataProperty
                    {
                        Name = "Weight",
                        Value = 123.45
                    },
                    new ODataProperty
                    {
                        Name = "Money",
                        Value = Decimal.MaxValue
                    }
                }
            };

            entryWriter.WriteStart(entry);
            entryWriter.WriteEnd();
            entryWriter.Flush();

            stream.Position = 0;

            StreamReader reader = new StreamReader(stream);
            string payload = reader.ReadToEnd();
            Assert.Equal("{\"@odata.context\":\"http://host/service/$metadata#People/$entity\",\"ID\":\"18446744073709551615\",\"Name\":\"Foo\",\"FavoriteNumber\":250.0,\"Age\":123,\"Guid\":-9223372036854775808,\"Weight\":123.45,\"Money\":79228162514264337593543950335}", payload);

#if NETCOREAPP1_1
            stream = new MemoryStream(Encoding.GetEncoding(0).GetBytes(payload));
#else
            stream = new MemoryStream(Encoding.Default.GetBytes(payload));
#endif
            message = new InMemoryMessage { Stream = stream };
            message.StatusCode = 200;

            var readerSettings = new ODataMessageReaderSettings();

            var messageReader = new ODataMessageReader(message, readerSettings, model);
            var entryReader = messageReader.CreateODataResourceReader(peopleSet, personType);
            Assert.True(entryReader.Read());
            var entryReaded = entryReader.Item as ODataResource;

            var propertiesReaded = entryReaded.Properties.ToList();
            var propertiesGiven = entry.Properties.ToList();
            Assert.Equal(propertiesReaded.Count, propertiesGiven.Count);
            for (int i = 0; i < propertiesReaded.Count; ++i)
            {
                Assert.Equal(propertiesReaded[i].Name, propertiesGiven[i].Name);
                Assert.Equal(propertiesReaded[i].Value.GetType(), propertiesGiven[i].Value.GetType());
                Assert.Equal(propertiesReaded[i].Value, propertiesGiven[i].Value);
            }
        }

        [Theory]
        [MemberData(nameof(DecimalInExponentialFormTestData))]
        public void DecimalInExponentialFormJsonLightTest(string untypedValue, decimal expectedValue)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType("Edm.Decimal"), true);

            object actualValue = WriteAsUntypedThenReadValue(untypedValue, typeReference, ODataVersion.V4);

            Assert.True(actualValue.GetType().Equals(typeof(decimal)));
            Assert.Equal(expectedValue, actualValue);
        }

        [Theory]
        [MemberData(nameof(DecimalInExponentialFormOutOfRangeTestData))]
        public void DecimalInExponentialFormJsonLightTest_ExceptionThrownForValueOutOfRange(string untypedValue)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType("Edm.Decimal"), true);

            // Consistent with the behaviour in ASP.NET/ASP.NET Core, exception should be thrown is value is out of range
            Assert.Throws<ODataException>(() => WriteAsUntypedThenReadValue(untypedValue, typeReference, ODataVersion.V4));
        }

        public static IEnumerable<object[]> DecimalInExponentialFormTestData()
        {
            foreach (var item in new object[][]
            {
                new object[] { "7.5e3", 7500 },
                new object[] { "7500", 7500 },
                new object[] { "7500.0", 7500 },
                new object[] { "7.5e-3", 0.0075 },
                new object[]
                {
                    // NOTE: The choice of precision specifier here is deliberate to prevent rounding up. 
                    // That would push the value out of decimals range
                    decimal.MaxValue.ToString("E14"), // 7.92281625142643E+028
                    // To ensure exactness
                    decimal.Parse(decimal.MaxValue.ToString("E14"), System.Globalization.NumberStyles.Float)
                },
                new object[] {
                    decimal.MinValue.ToString("E14"), // -7.92281625142643E+028
                    decimal.Parse(decimal.MinValue.ToString("E14"), System.Globalization.NumberStyles.Float)
                }
            })
                yield return item;
        }

        public static IEnumerable<object[]> DecimalInExponentialFormOutOfRangeTestData()
        {
            yield return new object[] { double.MaxValue.ToString("E16") };
            yield return new object[] { double.MinValue.ToString("E16") };
        }

        private void VerifyUIntValuesRoundtripWithTypeInformation(IEnumerable clrValues, string edmTypeDefinitionName)
        {
            var typeReference = new EdmTypeDefinitionReference((IEdmTypeDefinition)this.model.FindType(edmTypeDefinitionName), true);
            foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
            {
                foreach (object clrValue in clrValues)
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithTypeInformation(IEnumerable clrValues, string edmTypeName)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version,isIeee754Compatible: true);
                }
            }
        }


        private void VerifyPrimitiveValuesRoundtripWithTypeInformationAndWithExpectedValues(Array clrValues, string edmTypeName, Array expectedValues)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);

            Assert.Equal(clrValues.Length, expectedValues.Length);

            for (int iterator = 0; iterator < clrValues.Length; iterator++)
            {
                object clrValue = clrValues.GetValue(iterator);
                object expectedValue = expectedValues.GetValue(iterator);
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: true, expectedValue: expectedValue);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithoutTypeInformation(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, null, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueDoesNotRoundtrip(clrValue, null, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueDoesNotRoundtrip(clrValue, null, version, isIeee754Compatible: false);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(IEnumerable clrValues, string edmTypeName)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: false);
                }
            }
        }

        private void VerifyPrimitiveValueRoundtrips(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible, clrValue);
        }

        private void VerifyPrimitiveValueRoundtrips(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible, object expectedValue)
        {
            var actualValue = this.WriteThenReadValue(clrValue, typeReference, version, isIeee754Compatible);

            if (expectedValue is byte[])
            {
                Assert.Equal((byte[])actualValue, (byte[])expectedValue);
            }
            else
            {
                Assert.Equal(actualValue.GetType(), expectedValue.GetType());
                Assert.Equal(actualValue, expectedValue);
            }
        }

        private void VerifyPrimitiveValueDoesNotRoundtrip(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            var actualValue = this.WriteThenReadValue(clrValue, typeReference, version, isIeee754Compatible);

            if (clrValue is byte[])
            {
                if (actualValue is byte[])
                {
                    Assert.NotEqual((byte[])actualValue, (byte[])clrValue);
                }
                else if (actualValue != null)
                {
                    Assert.NotEqual(actualValue.GetType(), clrValue.GetType());
                }

                Assert.True(true);
            }
            else
            {
                Assert.NotEqual(actualValue, clrValue);
            }
        }

        private object WriteThenReadValue(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            var stream = new MemoryStream();

            var settings = new ODataMessageWriterSettings { Version = version };
            settings.SetServiceDocumentUri(new Uri("http://odata.org/test/"));

            var mediaType = isIeee754Compatible
                ? new ODataMediaType("application", "json", new KeyValuePair<string, string>("IEEE754Compatible", "true"))
                : new ODataMediaType("application", "json");

            var messageInfoForWriter = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = mediaType,
                Encoding = Encoding.UTF8,
                IsResponse = true,
                IsAsync = false,
                Model = this.model,
                Container = this.container
            };

            using (var outputContext = new ODataJsonLightOutputContext(messageInfoForWriter, settings))
            {
                var serializer = new ODataJsonLightValueSerializer(outputContext);
                serializer.WritePrimitiveValue(clrValue, typeReference);
            }

            stream.Position = 0;

            var messageInfoForReader = new ODataMessageInfo
            {
                Encoding = Encoding.UTF8,
                IsResponse = true,
                MediaType = mediaType,
                IsAsync = false,
                Model = this.model,
                MessageStream = stream,
                Container = this.container
            };

            object actualValue;
            using (var inputContext = new ODataJsonLightInputContext(
                messageInfoForReader, new ODataMessageReaderSettings()))
            {
                var deserializer = new ODataJsonLightPropertyAndValueDeserializer(inputContext);
                deserializer.JsonReader.Read();
                actualValue = deserializer.ReadNonEntityValue(
                    /*payloadTypeName*/ null,
                    typeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevel*/ true,
                    /*insideResourceValue*/ false,
                    /*propertyName*/ null);

            }

            return actualValue;
        }

        private object WriteAsUntypedThenReadValue(string value, IEdmTypeReference typeReference, ODataVersion version)
        {
            var stream = new MemoryStream();

            var settings = new ODataMessageWriterSettings { Version = version };
            settings.SetServiceDocumentUri(new Uri("http://tempuri.org/"));

            var mediaType = new ODataMediaType("application", "json");

            var messageInfoForWriter = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = mediaType,
                Encoding = Encoding.UTF8,
                IsResponse = true,
                IsAsync = false,
                Model = this.model,
                Container = this.container
            };

            using (var outputContext = new ODataJsonLightOutputContext(messageInfoForWriter, settings))
            {
                var serializer = new ODataJsonLightValueSerializer(outputContext);
                // Writing the value as untyped it remains in its original form
                serializer.WriteUntypedValue(new ODataUntypedValue { RawValue = value });
            }

            stream.Position = 0;

            var messageInfoForReader = new ODataMessageInfo
            {
                Encoding = Encoding.UTF8,
                IsResponse = true,
                MediaType = mediaType,
                IsAsync = false,
                Model = this.model,
                MessageStream = stream,
                Container = this.container
            };

            object actualValue;
            using (var inputContext = new ODataJsonLightInputContext(
                messageInfoForReader, new ODataMessageReaderSettings()))
            {
                var deserializer = new ODataJsonLightPropertyAndValueDeserializer(inputContext);
                deserializer.JsonReader.Read();
                actualValue = deserializer.ReadNonEntityValue(
                    /*payloadTypeName*/ null,
                    typeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevel*/ true,
                    /*insideResourceValue*/ false,
                    /*propertyName*/ null);
            }

            return actualValue;
        }
    }

    internal class UInt16ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt16ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToDouble(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt16(value);
        }
    }

    internal class UInt32ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt32ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToString(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt32(value);
        }
    }

    internal class UInt64ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt64ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToString(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt64(value);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.OData.JsonLight;
using Microsoft.OData.Tests.JsonLight;
using Microsoft.OData.Edm;
using Microsoft.Spatial;
using Microsoft.Test.OData.DependencyInjection;
using Xunit;

namespace Microsoft.OData.Tests.ScenarioTests.Roundtrip.JsonLight
{
    public class PrimitiveValuesRoundtripJsonLightTests
    {
        private EdmModel model;
        private IServiceProvider container;

        public PrimitiveValuesRoundtripJsonLightTests()
        {
            model = new EdmModel();
        }

        [Fact]
        public void BinaryRoundtripJsonLightTest()
        {
            var values = new byte[][]
            {
                new byte[0],
                new byte[] { 0 },
                new byte[] { 42, Byte.MinValue, Byte.MaxValue },
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Binary");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void BinaryPayloadAsStringRoundtripJsonLightTest()
        {
            var values = new byte[][]
            {
                new byte[0],
                new byte[] { 0 },
                new byte[] { 42, Byte.MinValue, Byte.MaxValue },
            };

            var expectedValues = new string[]
            {
                Convert.ToBase64String(values[0]),
                Convert.ToBase64String(values[1]),
                Convert.ToBase64String(values[2])
            };

            this.container = ContainerBuilderHelper.BuildContainer(
                builder => builder.AddService<ODataPayloadValueConverter, BinaryFieldAsStringPrimitivePayloadValueConverter>(ServiceLifetime.Singleton));

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationAndWithExpectedValues(values, "Edm.Binary", expectedValues);
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(expectedValues, "Edm.Binary");
        }

        [Fact]
        public void BooleanRoundtripJsonLightTest()
        {
            var values = new bool[]
            {
                true, 
                false,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Boolean");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void ByteRoundtripJsonLightTest()
        {
            var values = new byte[]
            {
                0,
                42,
                Byte.MaxValue,
                Byte.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Byte");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DateRoundtripJsonLightTest()
        {
            var values = new Date[]
            {
                new Date(2012, 4, 13),
                new Date(1, 1, 1),
                new Date(9999, 12, 31),
                new Date(), 
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Date");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DateTimeOffsetRoundtripJsonLightTest()
        {
            var values = new DateTimeOffset[]
            {
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, TimeSpan.Zero),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(840)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(-840)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(123)),
                new DateTimeOffset(2012, 4, 13, 2, 43, 10, 215, TimeSpan.FromMinutes(-42)),
                DateTimeOffset.MinValue,
                DateTimeOffset.MaxValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.DateTimeOffset");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DecimalRoundtripJsonLightTest()
        {
            var values = new decimal[]
            {
                0,
                1,
                -1,
                Decimal.MinValue,
                Decimal.MaxValue,
                10^-28,
                10^28,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Decimal");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void DecimalRoundTripJsonLightTestWithIeee754CompatibleFalse()
        {
            var values = new decimal[]
            {
                0,
                1,
                -1,
                Decimal.MinValue,
                Decimal.MaxValue,
                10^-28,
                10^28,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(values, "Edm.Decimal");

            // precision lose for Ieee754Compatible=false
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(new[] { Decimal.MaxValue, Decimal.MinValue });
        }

        [Fact]
        public void DoubleRoundtripJsonLightTest()
        {
            IEnumerable<double> valuesWrittenAsDigits = new double[]
            {
                0,
                42,
                42.42,
                Double.MaxValue,
                Double.MinValue,
                -4.42330604244772E-305,
                42E20,
            };

            IEnumerable<double> valuesWrittenAsString = new double[]
            {
                Double.PositiveInfinity,
                Double.NegativeInfinity,
                Double.NaN,                       
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(valuesWrittenAsDigits.Concat(valuesWrittenAsString), "Edm.Double");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(valuesWrittenAsDigits);
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(valuesWrittenAsString);
        }

        [Fact]
        public void GuidRoundtripJsonLightTest()
        {
            var values = new Guid[]
            {
                new Guid(0, 0, 0, new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }),
                new Guid("C8864E5E-BDB1-4FB2-A1C4-8F8E49C271EA"),
                Guid.Empty,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Guid");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int16RoundtripJsonLightTest()
        {
            var values = new Int16[]
            {
                0,
                42,
                -43,
                Int16.MaxValue,
                Int16.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int16");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int32RoundtripJsonLightTest()
        {
            var values = new Int32[]
            {
                0,
                42,
                -43,
                Int32.MaxValue,
                Int32.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int32");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int64RoundtripJsonLightTest()
        {
            var values = new Int64[]
            {
                0,
                42,
                -43,
                Int64.MaxValue,
                Int64.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Int64");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void Int64RoundTripJsonLightTestWithIeee754CompatibleFalse()
        {
            var values = new Int64[]
            {
                0,
                42,
                -43,
                Int64.MaxValue,
                Int64.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(values, "Edm.Int64");

            // precision lose for Ieee754Compatible=false
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(new[] { Int64.MaxValue, Int64.MinValue });
        }

        [Fact]
        public void SByteRoundtripJsonLightTest()
        {
            var values = new SByte[]
            {
                0,
                42,
                -43,
                SByte.MaxValue,
                SByte.MinValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.SByte");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void StringRoundtripJsonLightTest()
        {
            var values = new string[]
            {
                string.Empty,
                " ",
                "testvalue",
                "TestValue",
                "\r\n\t",
                "\"",
                "\'",
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.String");
            this.VerifyPrimitiveValuesRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void SingleRoundtripJsonLightTest()
        {
            var values = new Single[]
            {
                0,
                42,
                (float)-43.43,
                Single.MaxValue,
                Single.MinValue,
                Single.PositiveInfinity,
                Single.NegativeInfinity,
                Single.NaN,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Single");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void TimeRoundtripJsonLightTest()
        {
            var values = new TimeSpan[]
            {
                new TimeSpan(1, 2, 3, 4, 5),
                TimeSpan.Zero,
                TimeSpan.MinValue,
                TimeSpan.MaxValue,
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.Duration");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void TimeOfDayRoundtripJsonLightTest()
        {
            var values = new TimeOfDay[]
            {
                new TimeOfDay(10, 5, 30, 90),
                new TimeOfDay(TimeOfDay.MinTickValue),
                new TimeOfDay(TimeOfDay.MaxTickValue),
                new TimeOfDay(), 
            };

            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "Edm.TimeOfDay");
            this.VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(values);
        }

        [Fact]
        public void GeographyMultiLineStringRoundtripJsonLightTest()
        {
            var values = new GeographyMultiLineString[]
            {
                GeographyFactory.MultiLineString().LineString(0, 0).LineTo(0, 0).Build(), 
                GeographyFactory.MultiLineString().LineString(-90.0, -90.0).LineTo(0, 0).LineString(90.0, 90.0).LineTo(0, 0).Build(), 
                GeographyFactory.MultiLineString().LineString(-90.0, 0).LineTo(0, 0).LineString(0, 0).LineTo(0, 0).LineString(0, 90.0).LineTo(0, 0).Build()
            };
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "GeographyMultiLineString");
        }

        [Fact]
        public void GeometryCollectionRoundtripJsonLightTest()
        {
            var values = new GeometryCollection[]
            {
                GeometryFactory.Collection().Build(),
                GeometryFactory.Collection().Point(0, 0).Build()
            };
            this.VerifyPrimitiveValuesRoundtripWithTypeInformation(values, "GeometryCollection");
        }

        [Fact]
        public void UInt16RoundtripJsonLightTest()
        {
            var uint16 = new EdmTypeDefinition("NS", "UInt16", EdmPrimitiveTypeKind.Double);
            var uint16Ref = new EdmTypeDefinitionReference(uint16, true);
            this.model.AddElement(uint16);
            this.model.SetPrimitiveValueConverter(uint16Ref, UInt16ValueConverter.Instance);
            var values = new[]
            {
                (UInt16)123,
                UInt16.MinValue,
                UInt16.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt16");
        }

        [Fact]
        public void UInt32RoundtripJsonLightTest()
        {
            var uint32 = new EdmTypeDefinition("NS", "UInt32", EdmPrimitiveTypeKind.String);
            var uint32Ref = new EdmTypeDefinitionReference(uint32, true);
            this.model.AddElement(uint32);
            this.model.SetPrimitiveValueConverter(uint32Ref, UInt32ValueConverter.Instance);
            var values = new[]
            {
                (UInt32)456,
                UInt32.MinValue,
                UInt32.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt32");
        }

        [Fact]
        public void UInt64RoundtripJsonLightTest()
        {
            var uint64 = new EdmTypeDefinition("NS", "UInt64", EdmPrimitiveTypeKind.String);
            var uint64Ref = new EdmTypeDefinitionReference(uint64, true);
            this.model.AddElement(uint64);
            this.model.SetPrimitiveValueConverter(uint64Ref, UInt64ValueConverter.Instance);
            var values = new[]
            {
                (UInt64)456,
                UInt64.MinValue,
                UInt64.MaxValue
            };
            this.VerifyUIntValuesRoundtripWithTypeInformation(values, "NS.UInt64");
        }

        [Fact]
        public void UnsignedIntAndTypeDefinitionRoundtripJsonLightIntegrationTest()
        {
            var model = new EdmModel();

            var uint16 = new EdmTypeDefinition("MyNS", "UInt16", EdmPrimitiveTypeKind.Double);
            var uint16Ref = new EdmTypeDefinitionReference(uint16, false);
            model.AddElement(uint16);
            model.SetPrimitiveValueConverter(uint16Ref, UInt16ValueConverter.Instance);

            var uint64 = new EdmTypeDefinition("MyNS", "UInt64", EdmPrimitiveTypeKind.String);
            var uint64Ref = new EdmTypeDefinitionReference(uint64, false);
            model.AddElement(uint64);
            model.SetPrimitiveValueConverter(uint64Ref, UInt64ValueConverter.Instance);

            var guidType = new EdmTypeDefinition("MyNS", "Guid", EdmPrimitiveTypeKind.Int64);
            var guidRef = new EdmTypeDefinitionReference(guidType, true);
            model.AddElement(guidType);

            var personType = new EdmEntityType("MyNS", "Person");
            personType.AddKeys(personType.AddStructuralProperty("ID", uint64Ref));
            personType.AddStructuralProperty("Name", EdmPrimitiveTypeKind.String);
            personType.AddStructuralProperty("FavoriteNumber", uint16Ref);
            personType.AddStructuralProperty("Age", model.GetUInt32("MyNS", true));
            personType.AddStructuralProperty("Guid", guidRef);
            personType.AddStructuralProperty("Weight", EdmPrimitiveTypeKind.Double);
            personType.AddStructuralProperty("Money", EdmPrimitiveTypeKind.Decimal);
            model.AddElement(personType);

            var container = new EdmEntityContainer("MyNS", "Container");
            var peopleSet = container.AddEntitySet("People", personType);
            model.AddElement(container);

            var stream = new MemoryStream();
            IODataResponseMessage message = new InMemoryMessage { Stream = stream };
            message.StatusCode = 200;

            var writerSettings = new ODataMessageWriterSettings();
            writerSettings.SetServiceDocumentUri(new Uri("http://host/service"));

            var messageWriter = new ODataMessageWriter(message, writerSettings, model);
            var entryWriter = messageWriter.CreateODataResourceWriter(peopleSet);

            var entry = new ODataResource
            {
                TypeName = "MyNS.Person",
                Properties = new[]
                {
                    new ODataProperty
                    {
                        Name = "ID",
                        Value = UInt64.MaxValue
                    },
                    new ODataProperty
                    {
                        Name = "Name",
                        Value = "Foo"
                    },
                    new ODataProperty
                    {
                        Name = "FavoriteNumber",
                        Value = (UInt16)250
                    },
                    new ODataProperty
                    {
                        Name = "Age",
                        Value = (UInt32)123
                    },
                    new ODataProperty
                    {
                        Name = "Guid",
                        Value = Int64.MinValue
                    },
                    new ODataProperty
                    {
                        Name = "Weight",
                        Value = 123.45
                    },
                    new ODataProperty
                    {
                        Name = "Money",
                        Value = Decimal.MaxValue
                    }
                }
            };

            entryWriter.WriteStart(entry);
            entryWriter.WriteEnd();
            entryWriter.Flush();

            stream.Position = 0;

            StreamReader reader = new StreamReader(stream);
            string payload = reader.ReadToEnd();
            Assert.Equal("{\"@odata.context\":\"http://host/service/$metadata#People/$entity\",\"ID\":\"18446744073709551615\",\"Name\":\"Foo\",\"FavoriteNumber\":250.0,\"Age\":123,\"Guid\":-9223372036854775808,\"Weight\":123.45,\"Money\":79228162514264337593543950335}", payload);

#if NETCOREAPP1_1
            stream = new MemoryStream(Encoding.GetEncoding(0).GetBytes(payload));
#else
            stream = new MemoryStream(Encoding.Default.GetBytes(payload));
#endif
            message = new InMemoryMessage { Stream = stream };
            message.StatusCode = 200;

            var readerSettings = new ODataMessageReaderSettings();

            var messageReader = new ODataMessageReader(message, readerSettings, model);
            var entryReader = messageReader.CreateODataResourceReader(peopleSet, personType);
            Assert.True(entryReader.Read());
            var entryReaded = entryReader.Item as ODataResource;

            var propertiesReaded = entryReaded.Properties.ToList();
            var propertiesGiven = entry.Properties.ToList();
            Assert.Equal(propertiesReaded.Count, propertiesGiven.Count);
            for (int i = 0; i < propertiesReaded.Count; ++i)
            {
                Assert.Equal(propertiesReaded[i].Name, propertiesGiven[i].Name);
                Assert.Equal(propertiesReaded[i].Value.GetType(), propertiesGiven[i].Value.GetType());
                Assert.Equal(propertiesReaded[i].Value, propertiesGiven[i].Value);
            }
        }

        [Theory]
        [MemberData(nameof(DecimalInExponentialFormTestData))]
        public void DecimalInExponentialFormJsonLightTest(string untypedValue, decimal expectedValue)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType("Edm.Decimal"), true);

            object actualValue = WriteAsUntypedThenReadValue(untypedValue, typeReference, ODataVersion.V4);

            Assert.True(actualValue.GetType().Equals(typeof(decimal)));
            Assert.Equal(expectedValue, actualValue);
        }

        [Theory]
        [MemberData(nameof(DecimalInExponentialFormOutOfRangeTestData))]
        public void DecimalInExponentialFormJsonLightTest_ExceptionThrownForValueOutOfRange(string untypedValue)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType("Edm.Decimal"), true);

            // Consistent with the behaviour in ASP.NET/ASP.NET Core, exception should be thrown is value is out of range
            Assert.Throws<ODataException>(() => WriteAsUntypedThenReadValue(untypedValue, typeReference, ODataVersion.V4));
        }

        public static IEnumerable<object[]> DecimalInExponentialFormTestData()
        {
            foreach (var item in new object[][]
            {
                new object[] { "7.5e3", 7500 },
                new object[] { "7500", 7500 },
                new object[] { "7500.0", 7500 },
                new object[] { "7.5e-3", 0.0075 },
                new object[]
                {
                    // NOTE: The choice of precision specifier here is deliberate to prevent rounding up. 
                    // That would push the value out of decimals range
                    decimal.MaxValue.ToString("E14"), // 7.92281625142643E+028
                    // To ensure exactness
                    decimal.Parse(decimal.MaxValue.ToString("E14"), System.Globalization.NumberStyles.Float)
                },
                new object[] {
                    decimal.MinValue.ToString("E14"), // -7.92281625142643E+028
                    decimal.Parse(decimal.MinValue.ToString("E14"), System.Globalization.NumberStyles.Float)
                }
            })
                yield return item;
        }

        public static IEnumerable<object[]> DecimalInExponentialFormOutOfRangeTestData()
        {
            yield return new object[] { double.MaxValue.ToString("E16") };
            yield return new object[] { double.MinValue.ToString("E16") };
        }

        private void VerifyUIntValuesRoundtripWithTypeInformation(IEnumerable clrValues, string edmTypeDefinitionName)
        {
            var typeReference = new EdmTypeDefinitionReference((IEdmTypeDefinition)this.model.FindType(edmTypeDefinitionName), true);
            foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
            {
                foreach (object clrValue in clrValues)
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithTypeInformation(IEnumerable clrValues, string edmTypeName)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version,isIeee754Compatible: true);
                }
            }
        }


        private void VerifyPrimitiveValuesRoundtripWithTypeInformationAndWithExpectedValues(Array clrValues, string edmTypeName, Array expectedValues)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);

            Assert.Equal(clrValues.Length, expectedValues.Length);

            for (int iterator = 0; iterator < clrValues.Length; iterator++)
            {
                object clrValue = clrValues.GetValue(iterator);
                object expectedValue = expectedValues.GetValue(iterator);
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: true, expectedValue: expectedValue);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithoutTypeInformation(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, null, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformation(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueDoesNotRoundtrip(clrValue, null, version, isIeee754Compatible: true);
                }
            }
        }

        private void VerifyPrimitiveValuesDoNotRoundtripWithoutTypeInformationIeee754CompatibleFalse(IEnumerable clrValues)
        {
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueDoesNotRoundtrip(clrValue, null, version, isIeee754Compatible: false);
                }
            }
        }

        private void VerifyPrimitiveValuesRoundtripWithTypeInformationIeee754CompatibleFalse(IEnumerable clrValues, string edmTypeName)
        {
            var typeReference = new EdmPrimitiveTypeReference((IEdmPrimitiveType)this.model.FindType(edmTypeName), true);
            foreach (object clrValue in clrValues)
            {
                foreach (ODataVersion version in new ODataVersion[] { ODataVersion.V4, ODataVersion.V401 })
                {
                    this.VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible: false);
                }
            }
        }

        private void VerifyPrimitiveValueRoundtrips(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            VerifyPrimitiveValueRoundtrips(clrValue, typeReference, version, isIeee754Compatible, clrValue);
        }

        private void VerifyPrimitiveValueRoundtrips(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible, object expectedValue)
        {
            var actualValue = this.WriteThenReadValue(clrValue, typeReference, version, isIeee754Compatible);

            if (expectedValue is byte[] bytes)
            {
                Assert.Equal((byte[])actualValue, bytes);
            }
            else
            {
                Assert.Equal(actualValue.GetType(), expectedValue.GetType());
                Assert.Equal(actualValue, expectedValue);
            }
        }

        private void VerifyPrimitiveValueDoesNotRoundtrip(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            var actualValue = this.WriteThenReadValue(clrValue, typeReference, version, isIeee754Compatible);

            if (clrValue is byte[] bytes)
            {
                if (actualValue is byte[] bytes)
                {
                    Assert.NotEqual(bytes, bytes);
                }
                else if (actualValue != null)
                {
                    Assert.NotEqual(actualValue.GetType(), clrValue.GetType());
                }

                Assert.True(true);
            }
            else
            {
                Assert.NotEqual(actualValue, clrValue);
            }
        }

        private object WriteThenReadValue(object clrValue, IEdmTypeReference typeReference, ODataVersion version, bool isIeee754Compatible)
        {
            var stream = new MemoryStream();

            var settings = new ODataMessageWriterSettings { Version = version };
            settings.SetServiceDocumentUri(new Uri("http://odata.org/test/"));

            var mediaType = isIeee754Compatible
                ? new ODataMediaType("application", "json", new KeyValuePair<string, string>("IEEE754Compatible", "true"))
                : new ODataMediaType("application", "json");

            var messageInfoForWriter = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = mediaType,
                Encoding = Encoding.UTF8,
                IsResponse = true,
                IsAsync = false,
                Model = this.model,
                Container = this.container
            };

            using (var outputContext = new ODataJsonLightOutputContext(messageInfoForWriter, settings))
            {
                var serializer = new ODataJsonLightValueSerializer(outputContext);
                serializer.WritePrimitiveValue(clrValue, typeReference);
            }

            stream.Position = 0;

            var messageInfoForReader = new ODataMessageInfo
            {
                Encoding = Encoding.UTF8,
                IsResponse = true,
                MediaType = mediaType,
                IsAsync = false,
                Model = this.model,
                MessageStream = stream,
                Container = this.container
            };

            object actualValue;
            using (var inputContext = new ODataJsonLightInputContext(
                messageInfoForReader, new ODataMessageReaderSettings()))
            {
                var deserializer = new ODataJsonLightPropertyAndValueDeserializer(inputContext);
                deserializer.JsonReader.Read();
                actualValue = deserializer.ReadNonEntityValue(
                    /*payloadTypeName*/ null,
                    typeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevel*/ true,
                    /*insideResourceValue*/ false,
                    /*propertyName*/ null);

            }

            return actualValue;
        }

        private object WriteAsUntypedThenReadValue(string value, IEdmTypeReference typeReference, ODataVersion version)
        {
            var stream = new MemoryStream();

            var settings = new ODataMessageWriterSettings { Version = version };
            settings.SetServiceDocumentUri(new Uri("http://tempuri.org/"));

            var mediaType = new ODataMediaType("application", "json");

            var messageInfoForWriter = new ODataMessageInfo
            {
                MessageStream = new NonDisposingStream(stream),
                MediaType = mediaType,
                Encoding = Encoding.UTF8,
                IsResponse = true,
                IsAsync = false,
                Model = this.model,
                Container = this.container
            };

            using (var outputContext = new ODataJsonLightOutputContext(messageInfoForWriter, settings))
            {
                var serializer = new ODataJsonLightValueSerializer(outputContext);
                // Writing the value as untyped it remains in its original form
                serializer.WriteUntypedValue(new ODataUntypedValue { RawValue = value });
            }

            stream.Position = 0;

            var messageInfoForReader = new ODataMessageInfo
            {
                Encoding = Encoding.UTF8,
                IsResponse = true,
                MediaType = mediaType,
                IsAsync = false,
                Model = this.model,
                MessageStream = stream,
                Container = this.container
            };

            object actualValue;
            using (var inputContext = new ODataJsonLightInputContext(
                messageInfoForReader, new ODataMessageReaderSettings()))
            {
                var deserializer = new ODataJsonLightPropertyAndValueDeserializer(inputContext);
                deserializer.JsonReader.Read();
                actualValue = deserializer.ReadNonEntityValue(
                    /*payloadTypeName*/ null,
                    typeReference,
                    /*propertyAndAnnotationCollector*/ null,
                    /*collectionValidator*/ null,
                    /*validateNullValue*/ true,
                    /*isTopLevel*/ true,
                    /*insideResourceValue*/ false,
                    /*propertyName*/ null);
            }

            return actualValue;
        }
    }

    internal class UInt16ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt16ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToDouble(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt16(value);
        }
    }

    internal class UInt32ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt32ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToString(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt32(value);
        }
    }

    internal class UInt64ValueConverter : IPrimitiveValueConverter
    {
        private static readonly IPrimitiveValueConverter instance = new UInt64ValueConverter();

        internal static IPrimitiveValueConverter Instance
        {
            get { return instance; }
        }

        public object ConvertToUnderlyingType(object value)
        {
            return Convert.ToString(value);
        }

        public object ConvertFromUnderlyingType(object value)
        {
            return Convert.ToUInt64(value);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\ScenarioTests\Roundtrip\JsonLight\PrimitiveValuesRoundtripJsonLightTests.cs(716,43): error CS0136: A local or parameter named 'bytes' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 28 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\TestUtils.cs
Description: Error: Unable to create valid SyntaxTree for document: TestUtils.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (value1 is ODataPrimitiveValue primitiveValue1 && value2 is ODataPrimitiveValue primitiveValue2)
            {
                AssertODataPrimitiveValueAreEqual(primitiveValue1, primitiveValue2);
            }
            else
            {
                if (value1 is ODataResourceValue resourceValue1 && value2 is ODataResourceValue resourceValue2)
                {
                    AssertODataResourceValueAreEqual(resourceValue1, resourceValue2);
                    return;
                }
                if (value1 is ODataEnumValue enumValue1 && value2 is ODataEnumValue enumValue2)
                {
                    AssertODataEnumValueAreEqual(enumValue1, enumValue2);
                }
                else
                {
                    if (value1 is ODataCollectionValue collectionValue1 && value2 is ODataCollectionValue collectionValue2)
                    {
                        AssertODataCollectionValueAreEqual(collectionValue1, collectionValue2);
                    }
                    else
                    {
                        ODataUntypedValue untyped1 = value1 as ODataUntypedValue;
                        ODataUntypedValue untyped2 = value2 as ODataUntypedValue;
                        Assert.Equal(untyped1.RawValue, untyped2.RawValue);
                    }
                }
            }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (value1 is ODataPrimitiveValue primitiveValue1 && value2 is ODataPrimitiveValue primitiveValue2)
            {
                AssertODataPrimitiveValueAreEqual(primitiveValue1, primitiveValue2);
            }
            else
            {
                if (value1 is ODataResourceValue resourceValue1 && value2 is ODataResourceValue resourceValue2)
                {
                    AssertODataResourceValueAreEqual(resourceValue1, resourceValue2);
                    return;
                }
                if (value1 is ODataEnumValue enumValue1 && value2 is ODataEnumValue enumValue2)
                {
                    AssertODataEnumValueAreEqual(enumValue1, enumValue2);
                }
                else
                {
                    if (value1 is ODataCollectionValue collectionValue1 && value2 is ODataCollectionValue collectionValue2)
                    {
                        AssertODataCollectionValueAreEqual(collectionValue1, collectionValue2);
                    }
                    else
                    {
                        ODataUntypedValue untyped1 = value1 as ODataUntypedValue;
                        ODataUntypedValue untyped2 = value2 as ODataUntypedValue;
                        Assert.Equal(untyped1.RawValue, untyped2.RawValue);
                    }
                }
            }
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using Microsoft.OData.Evaluation;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Csdl;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;
using Xunit;

namespace Microsoft.OData.Tests
{
    public static class TestUtils
    {
        /// <summary>
        /// Creates a new ODataResource from the specified entity set, instance, and type.
        /// </summary>
        /// <param name="entitySet">Entity set for the new entry.</param>
        /// <param name="value">Entity instance for the new entry.</param>
        /// <param name="entityType">Entity type for the new entry.</param>
        /// <returns>New ODataResource with the specified entity set and type, property values from the specified instance.</returns>
        internal static ODataResource CreateODataEntry(IEdmEntitySet entitySet, IEdmStructuredValue value, IEdmEntityType entityType)
        {
            var entry = new ODataResource();
            entry.TypeAnnotation = new ODataTypeAnnotation(entityType.FullTypeName());
            entry.Properties = value.PropertyValues.Select(p =>
            {
                object propertyValue;
                if (p.Value.ValueKind == EdmValueKind.Null)
                {
                    propertyValue = null;
                }
                else if (p.Value is IEdmPrimitiveValue)
                {
                    propertyValue = ((IEdmPrimitiveValue)p.Value).ToClrValue();
                }
                else
                {
                    Assert.True(false, "Test only currently supports creating ODataResource from IEdmPrimitiveValue instances.");
                    return null;
                }

                return new ODataProperty() { Name = p.Name, Value = propertyValue };
            });

            return entry;
        }

        /// <summary>
        /// Easily wrap existing models as referenced models, and return a main model.
        /// </summary>
        /// <param name="referencedModels">NONE of them should have the container to extend.</param>
        /// <returns>The main model.</returns>
        public static IEdmModel WrapReferencedModelsToMainModel(params IEdmModel[] referencedModels)
        {
            Assert.True(referencedModels[0] != null, "referencedModels[0] != null");
            string mainModelxml = @"<?xml version=""1.0"" encoding=""utf-16""?>
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:Reference Uri=""http://host/schema/Location.xml"">
    <edmx:Include Namespace=""Test.Chh"" Alias=""NO_Alias"" />
  </edmx:Reference>
  <edmx:DataServices>
    <Schema Namespace=""MainModel_NS1"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"">
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            IEdmModel ret;
            IEnumerable<EdmError> errors;
            if (CsdlReader.TryParse(XmlReader.Create(new StringReader(mainModelxml)), new List<IEdmModel>(referencedModels), out ret, out errors))
            {
                return ret;
            }

            Assert.False(errors.Any(), "should be zero error.");
            return null;
        }

        /// <summary>
        /// Easily wrap existing models as referenced models, and return a main model.
        /// </summary>
        /// <param name="namespaceOfContainerToExtend"></param>
        /// <param name="nameOfContainerToExtend"></param>
        /// <param name="referencedModels">Ths first one should have the container (of namespaceOfContainerToExtend) to extend.</param>
        /// <returns>The main model.</returns>
        public static IEdmModel WrapReferencedModelsToMainModel(string namespaceOfContainerToExtend, string nameOfContainerToExtend, params IEdmModel[] referencedModels)
        {
            Assert.True(nameOfContainerToExtend + "_sub" == referencedModels[0].EntityContainer.Name, "the container name of '" + nameOfContainerToExtend + "' will be used by main model, so the container name in referenced model must have been appended with '_sub'.");
            string mainModelxml = @"<?xml version=""1.0"" encoding=""utf-16""?>
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:Reference Uri=""http://host/schema/Location.xml"">
    <edmx:Include Namespace=""Test.Chh"" Alias=""NO_Alias"" />
  </edmx:Reference>
  <edmx:DataServices>
    <Schema Namespace=""{0}"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"">  
        <EntityContainer Name=""{1}"" Extends=""{0}.{1}_sub"">
        </EntityContainer>  
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            mainModelxml = string.Format(mainModelxml, namespaceOfContainerToExtend, nameOfContainerToExtend);
            IEdmModel ret;
            IEnumerable<EdmError> errors;
            if (CsdlReader.TryParse(XmlReader.Create(new StringReader(mainModelxml)), new List<IEdmModel>(referencedModels), out ret, out errors))
            {
                return ret;
            }

            Assert.False(errors.Any(), "should be zero error.");
            return null;
        }
        #region Util methods to AssertAreEqual ODataValues

        public static void AssertODataResourceAreEqual(ODataResource value1, ODataResource value2)
        {
            Assert.NotNull(value1);
            Assert.NotNull(value2);
            Assert.Equal(value1.TypeName, value2.TypeName);
            AssertODataPropertiesAreEqual(value1.Properties, value2.Properties);
        }

        public static void AssertODataResourceSetAreEqual(List<ODataResource> collectionValue1, List<ODataResource> collectionValue2)
        {
            Assert.NotNull(collectionValue1);
            Assert.NotNull(collectionValue2);

            Assert.Equal(collectionValue1.Count, collectionValue2.Count);
            for (int i = 0; i < collectionValue1.Count; i++)
            {
                AssertODataResourceAreEqual(collectionValue1[i], collectionValue2[i]);
            }
        }

        public static void AssertODataValueAreEqual(ODataValue value1, ODataValue value2)
        {
            if (value1.IsNullValue && value2.IsNullValue)
            {
                return;
            }

            ODataPrimitiveValue primitiveValue1 = value1 as ODataPrimitiveValue;
            ODataPrimitiveValue primitiveValue2 = value2 as ODataPrimitiveValue;
            if (primitiveValue1 != null && primitiveValue2 != null)
            {
                AssertODataPrimitiveValueAreEqual(primitiveValue1, primitiveValue2);
            }
            else
            {
                ODataResourceValue resourceValue1 = value1 as ODataResourceValue;
                ODataResourceValue resourceValue2 = value2 as ODataResourceValue;
                if (resourceValue1 != null && resourceValue2 != null)
                {
                    AssertODataResourceValueAreEqual(resourceValue1, resourceValue2);
                    return;
                }

                ODataEnumValue enumValue1 = value1 as ODataEnumValue;
                ODataEnumValue enumValue2 = value2 as ODataEnumValue;
                if (enumValue1 != null && enumValue2 != null)
                {
                    AssertODataEnumValueAreEqual(enumValue1, enumValue2);
                }
                else
                {
                    ODataCollectionValue collectionValue1 = value1 as ODataCollectionValue;
                    ODataCollectionValue collectionValue2 = value2 as ODataCollectionValue;
                    if (collectionValue1 != null && collectionValue2 != null)
                    {
                        AssertODataCollectionValueAreEqual(collectionValue1, collectionValue2);
                    }
                    else
                    {
                        ODataUntypedValue untyped1 = value1 as ODataUntypedValue;
                        ODataUntypedValue untyped2 = value2 as ODataUntypedValue;
                        Assert.Equal(untyped1.RawValue, untyped2.RawValue);
                    }
                }
            }
        }

        private static void AssertODataCollectionValueAreEqual(ODataCollectionValue collectionValue1, ODataCollectionValue collectionValue2)
        {
            Assert.NotNull(collectionValue1);
            Assert.NotNull(collectionValue2);
            Assert.Equal(collectionValue1.TypeName, collectionValue2.TypeName);
            var itemsArray1 = collectionValue1.Items.OfType<object>().ToArray();
            var itemsArray2 = collectionValue2.Items.OfType<object>().ToArray();

            Assert.Equal(itemsArray1.Length, itemsArray2.Length);
            for (int i = 0; i < itemsArray1.Length; i++)
            {
                var odataValue1 = itemsArray1[i] as ODataValue;
                var odataValue2 = itemsArray2[i] as ODataValue;
                if (odataValue1 != null && odataValue2 != null)
                {
                    AssertODataValueAreEqual(odataValue1, odataValue2);
                }
                else
                {
                    Assert.Equal(itemsArray1[i], itemsArray2[i]);
                }
            }
        }

        private static void AssertODataResourceValueAreEqual(ODataResourceValue resourceValue1, ODataResourceValue resourceValue2)
        {
            Assert.NotNull(resourceValue1);
            Assert.NotNull(resourceValue2);
            Assert.Equal(resourceValue1.TypeName, resourceValue2.TypeName);
            AssertODataPropertiesAreEqual(resourceValue1.Properties, resourceValue2.Properties);
        }

        public static void AssertODataPropertiesAreEqual(IEnumerable<ODataProperty> properties1, IEnumerable<ODataProperty> properties2)
        {
            if (properties1 == null && properties2 == null)
            {
                return;
            }

            Assert.NotNull(properties1);
            Assert.NotNull(properties2);
            var propertyArray1 = properties1.ToArray();
            var propertyArray2 = properties2.ToArray();
            Assert.Equal(propertyArray1.Length, propertyArray2.Length);
            for (int i = 0; i < propertyArray1.Length; i++)
            {
                AssertODataPropertyAreEqual(propertyArray1[i], propertyArray2[i]);
            }
        }

        public static void AssertODataPropertyAreEqual(ODataProperty odataProperty1, ODataProperty odataProperty2)
        {
            Assert.NotNull(odataProperty1);
            Assert.NotNull(odataProperty2);
            Assert.Equal(odataProperty1.Name, odataProperty2.Name);
            AssertODataValueAreEqual(ToODataValue(odataProperty1.Value), ToODataValue(odataProperty2.Value));
        }

        private static ODataValue ToODataValue(object value)
        {
            if (value == null)
            {
                return new ODataNullValue();
            }

            var odataValue = value as ODataValue;
            if (odataValue != null)
            {
                return odataValue;
            }

            return new ODataPrimitiveValue(value);
        }

        private static void AssertODataPrimitiveValueAreEqual(ODataPrimitiveValue primitiveValue1, ODataPrimitiveValue primitiveValue2)
        {
            Assert.NotNull(primitiveValue1);
            Assert.NotNull(primitiveValue2);
            Assert.Equal(primitiveValue1.Value, primitiveValue2.Value);
        }

        private static void AssertODataEnumValueAreEqual(ODataEnumValue enumValue1, ODataEnumValue enumValue2)
        {
            Assert.NotNull(enumValue1);
            Assert.NotNull(enumValue2);
            Assert.Equal(enumValue1.Value, enumValue2.Value);
            Assert.Equal(enumValue1.TypeName, enumValue2.TypeName);
        }
        #endregion Util methods to AssertAreEqual ODataValues
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 29 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\test\FunctionalTests\Microsoft.OData.Core.Tests\UriParser\HardCodedTestModel.cs
Description: Error: Unable to create valid SyntaxTree for document: HardCodedTestModel.cs. Caught exception: System.ArgumentException: Syntax node is not within syntax tree
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckSyntaxNode(CSharpSyntaxNode syntax)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken)
   at Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 58
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBinaryExpression(BinaryExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgument(ArgumentSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SeparatedSyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitArgumentList(ArgumentListSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitInvocationExpression(InvocationExpressionSyntax node)
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 197
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitReturnStatement(ReturnStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Syntax node is not within syntax tree
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using Microsoft.OData.UriParser;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Csdl;
using Microsoft.OData.Edm.Validation;
using Microsoft.OData.Edm.Vocabularies;

namespace Microsoft.OData.Tests.UriParser
{
    /// <summary>
    /// Class to provide a test model for semantic unit tests.
    /// TODO: Use constructable APIs instead of string CSDL and remember all the objects.
    /// </summary>
    /// <remarks>
    /// Try not to use this class anymore. Too many tests have a dependency on the same model.
    /// </remarks>
    internal class HardCodedTestModel
    {
        private static readonly IEdmModel Model = GetEdmModel();

        public static IEdmModel TestModel
        {
            get { return Model; }
        }

        internal static IEdmModel GetEdmModel()
        {
            var model = new EdmModel();

            #region Type Definitions

            var FullyQualifiedNamespaceIdType = new EdmTypeDefinition("Fully.Qualified.Namespace", "IdType", EdmPrimitiveTypeKind.Double);
            var FullyQualifiedNamespaceIdTypeReference = new EdmTypeDefinitionReference(FullyQualifiedNamespaceIdType, false);
            model.AddElement(FullyQualifiedNamespaceIdType);

            var FullyQualifiedNamespaceNameType = new EdmTypeDefinition("Fully.Qualified.Namespace", "NameType", EdmPrimitiveTypeKind.String);
            var FullyQualifiedNamespaceNameTypeReference = new EdmTypeDefinitionReference(FullyQualifiedNamespaceNameType, false);
            model.AddElement(FullyQualifiedNamespaceNameType);

            var FullyQualifiedNamespaceUInt16Reference = model.GetUInt16("Fully.Qualified.Namespace", false);
            var FullyQualifiedNamespaceUInt32Reference = model.GetUInt32("Fully.Qualified.Namespace", false);
            var FullyQualifiedNamespaceUInt64Reference = model.GetUInt64("Fully.Qualified.Namespace", false);

            #endregion

            #region Enum Types
            var colorType = new EdmEnumType("Fully.Qualified.Namespace", "ColorPattern", EdmPrimitiveTypeKind.Int64, true);
            colorType.AddMember("Red", new EdmEnumMemberValue(1L));
            colorType.AddMember("Blue", new EdmEnumMemberValue(2L));
            colorType.AddMember("Yellow", new EdmEnumMemberValue(4L));
            colorType.AddMember("Solid", new EdmEnumMemberValue(8L));
            colorType.AddMember("Striped", new EdmEnumMemberValue(16L));
            colorType.AddMember("SolidRed", new EdmEnumMemberValue(9L));
            colorType.AddMember("SolidBlue", new EdmEnumMemberValue(10L));
            colorType.AddMember("SolidYellow", new EdmEnumMemberValue(12L));
            colorType.AddMember("RedBlueStriped", new EdmEnumMemberValue(19L));
            colorType.AddMember("RedYellowStriped", new EdmEnumMemberValue(21L));
            colorType.AddMember("BlueYellowStriped", new EdmEnumMemberValue(22L));
            model.AddElement(colorType);
            var colorTypeReference = new EdmEnumTypeReference(colorType, false);
            var nullableColorTypeReference = new EdmEnumTypeReference(colorType, true);

            var NonFlagShapeType = new EdmEnumType("Fully.Qualified.Namespace", "NonFlagShape", EdmPrimitiveTypeKind.SByte, false);
            NonFlagShapeType.AddMember("Rectangle", new EdmEnumMemberValue(1));
            NonFlagShapeType.AddMember("Triangle", new EdmEnumMemberValue(2));
            NonFlagShapeType.AddMember("foursquare", new EdmEnumMemberValue(3));
            model.AddElement(NonFlagShapeType);
            #endregion

            #region Structured Types
            var FullyQualifiedNamespacePerson = new EdmEntityType("Fully.Qualified.Namespace", "Person", null, false, false);
            var FullyQualifiedNamespaceEmployee = new EdmEntityType("Fully.Qualified.Namespace", "Employee", FullyQualifiedNamespacePerson, false, false);
            var FullyQualifiedNamespaceManager = new EdmEntityType("Fully.Qualified.Namespace", "Manager", FullyQualifiedNamespaceEmployee, false, false);
            var FullyQualifiedNamespaceOpenEmployee = new EdmEntityType("Fully.Qualified.Namespace", "OpenEmployee", FullyQualifiedNamespaceEmployee, false, true);
            var FullyQualifiedNamespaceDog = new EdmEntityType("Fully.Qualified.Namespace", "Dog", null, false, false);
            var FullyQualifiedNamespaceLion = new EdmEntityType("Fully.Qualified.Namespace", "Lion", null, false, false);
            var FullyQualifiedNamespaceChimera = new EdmEntityType("Fully.Qualified.Namespace", "Chimera", null, false, true);
            var FullyQualifiedNamespacePainting = new EdmEntityType("Fully.Qualified.Namespace", "Painting", null, false, true);
            var FullyQualifiedNamespaceFramedPainting = new EdmEntityType("Fully.Qualified.Namespace", "FramedPainting", FullyQualifiedNamespacePainting, false, true);
            var FullyQualifiedNamespaceUserAccount = new EdmEntityType("Fully.Qualified.Namespace", "UserAccount", null, false, false);
            var FullyQualifiedNamespacePet1 = new EdmEntityType("Fully.Qualified.Namespace", "Pet1", null, false, false);
            var FullyQualifiedNamespacePet2 = new EdmEntityType("Fully.Qualified.Namespace", "Pet2", null, false, false);
            var FullyQualifiedNamespacePet3 = new EdmEntityType("Fully.Qualified.Namespace", "Pet3", null, false, false);
            var FullyQualifiedNamespacePet4 = new EdmEntityType("Fully.Qualified.Namespace", "Pet4", null, false, false);
            var FullyQualifiedNamespacePet5 = new EdmEntityType("Fully.Qualified.Namespace", "Pet5", null, false, false);
            var FullyQualifiedNamespacePet6 = new EdmEntityType("Fully.Qualified.Namespace", "Pet6", null, false, false);

            var FullyQualifiedNamespaceAddress = new EdmComplexType("Fully.Qualified.Namespace", "Address");
            var FullyQualifiedNamespaceOpenAddress = new EdmComplexType("Fully.Qualified.Namespace", "OpenAddress", null, false, true);
            var FullyQualifiedNamespaceHomeAddress = new EdmComplexType("Fully.Qualified.Namespace", "HomeAddress", FullyQualifiedNamespaceAddress);

            var FullyQualifiedNamespaceHeartbeat = new EdmComplexType("Fully.Qualified.Namespace", "Heartbeat");
            var FullyQualifiedNamespaceFilm = new EdmEntityType("Fully.Qualified.Namespace", "Film", null, false, false);

            var FullyQualifiedNamespacePersonTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePerson, true);
            var FullyQualifiedNamespaceEmployeeTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceEmployee, true);
            var FullyQualifiedNamespaceManagerTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceManager, true);
            var FullyQualifiedNamespaceOpenEmployeeTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceOpenEmployee, true);
            var FullyQualifiedNamespaceDogTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceDog, true);
            var FullyQualifiedNamespaceLionTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceLion, true);
            var FullyQualifiedNamespacePet1TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet1, true);
            var FullyQualifiedNamespacePet2TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet2, true);
            var FullyQualifiedNamespacePet3TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet3, true);
            var FullyQualifiedNamespacePet4TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet4, true);
            var FullyQualifiedNamespacePet5TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet5, true);
            var FullyQualifiedNamespacePet6TypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePet6, true);
            var FullyQualifiedNamespacePaintingTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespacePainting, true);
            var FullyQualifiedNamespaceFramedPaintingTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceFramedPainting, true);
            var FullyQualifiedNamespaceUserAccountTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceUserAccount, true);
            var FullyQualifiedNamespaceFilmTypeReference = new EdmEntityTypeReference(FullyQualifiedNamespaceFilm, true);

            var FullyQualifiedNamespaceLion_ID1 = FullyQualifiedNamespaceLion.AddStructuralProperty("ID1", EdmCoreModel.Instance.GetInt32(false));
            var FullyQualifiedNamespaceLion_ID2 = FullyQualifiedNamespaceLion.AddStructuralProperty("ID2", EdmCoreModel.Instance.GetInt32(false));
            FullyQualifiedNamespaceLion.AddStructuralProperty("AngerLevel", EdmCoreModel.Instance.GetDouble(true));
            FullyQualifiedNamespaceLion.AddStructuralProperty("AttackDates", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetDateTimeOffset(true))));
            FullyQualifiedNamespaceLion.AddStructuralProperty("LionHeartbeat", new EdmComplexTypeReference(FullyQualifiedNamespaceHeartbeat, true));
            FullyQualifiedNamespaceLion.AddKeys(new IEdmStructuralProperty[] { FullyQualifiedNamespaceLion_ID1, FullyQualifiedNamespaceLion_ID2, });
            model.AddElement(FullyQualifiedNamespaceLion);

            var FullyQualifiedNamespaceAddressTypeReference = new EdmComplexTypeReference(FullyQualifiedNamespaceAddress, true);
            var FullyQualifiedNamespaceOpenAddressTypeReference = new EdmComplexTypeReference(FullyQualifiedNamespaceOpenAddress, true);
            var FullyQualifiedNamespacePerson_ID = FullyQualifiedNamespacePerson.AddStructuralProperty("ID", EdmCoreModel.Instance.GetInt32(false));
            var FullyQualifiedNamespacePerson_SSN = FullyQualifiedNamespacePerson.AddStructuralProperty("SSN", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("Shoe", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("Geography", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.Geography, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeographyPoint", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeographyPoint, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeographyLineString", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeographyLineString, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeographyPolygon", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeographyPolygon, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeometryPoint", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeometryPoint, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeometryLineString", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeometryLineString, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeometryPolygon", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeometryPolygon, true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeographyCollection", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeographyPoint, true))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeographyParentCollection", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.Geography, true))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("GeometryCollection", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeometryPoint, true))));
            var FullyQualifiedNamespacePerson_Name = FullyQualifiedNamespacePerson.AddStructuralProperty("Name", EdmCoreModel.Instance.GetString(true));
            var FullyQualifiedNamespacePerson_FirstName = FullyQualifiedNamespacePerson.AddStructuralProperty("FirstName", FullyQualifiedNamespaceNameTypeReference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("Prop.With.Periods", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyDate", EdmCoreModel.Instance.GetDate(false));
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyDates", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetDate(true))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyTimeOfDay", EdmCoreModel.Instance.GetTimeOfDay(false));
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyTimeOfDays", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetTimeOfDay(true))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("Birthdate", EdmCoreModel.Instance.GetDateTimeOffset(false));
            FullyQualifiedNamespacePerson.AddStructuralProperty("FavoriteDate", EdmCoreModel.Instance.GetDateTimeOffset(true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("TimeEmployed", EdmCoreModel.Instance.GetDuration(true));
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyAddress", FullyQualifiedNamespaceAddressTypeReference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyOpenAddress", FullyQualifiedNamespaceOpenAddressTypeReference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("PreviousAddresses", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceAddressTypeReference)));
            FullyQualifiedNamespacePerson.AddStructuralProperty("FavoriteColors", new EdmCollectionTypeReference(new EdmCollectionType(colorTypeReference)));
            FullyQualifiedNamespacePerson.AddStructuralProperty("FavoriteNumber", FullyQualifiedNamespaceUInt16Reference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("RelatedIDs", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetInt32(false))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("RelatedSSNs", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(true))));
            FullyQualifiedNamespacePerson.AddStructuralProperty("StockQuantity", FullyQualifiedNamespaceUInt32Reference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("LifeTime", FullyQualifiedNamespaceUInt64Reference);
            FullyQualifiedNamespacePerson.AddStructuralProperty("MyGuid", EdmPrimitiveTypeKind.Guid);
            FullyQualifiedNamespacePerson.AddKeys(FullyQualifiedNamespacePerson_ID);
            var FullyQualifiedNamespacePerson_MyDog = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyDog", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespaceDog });
            var FullyQualifiedNamespacePerson_MyRelatedDogs = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyFriendsDogs", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespaceDog });
            var FullyQualifiedNamespacePerson_MyPaintings = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyPaintings", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespacePainting });
            var FullyQualifiedNamespacePerson_MyFavoritePainting = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyFavoritePainting", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespacePainting });
            var FullyQualifiedNamespacePerson_MyLions = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo
            {
                Name = "MyLions",
                TargetMultiplicity = EdmMultiplicity.Many,
                Target = FullyQualifiedNamespaceLion,
                DependentProperties = new List<IEdmStructuralProperty>()
                {
                    FullyQualifiedNamespacePerson_ID
                },
                PrincipalProperties = new List<IEdmStructuralProperty>()
                {
                    FullyQualifiedNamespaceLion_ID1
                }
            });
            FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(
                new EdmNavigationPropertyInfo
                {
                    Name = "MyContainedDog",
                    TargetMultiplicity = EdmMultiplicity.ZeroOrOne,
                    Target = FullyQualifiedNamespaceDog,
                    ContainsTarget = true
                });
            FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(
                new EdmNavigationPropertyInfo
                {
                    Name = "MyContainedChimeras",
                    TargetMultiplicity = EdmMultiplicity.Many,
                    Target = FullyQualifiedNamespaceChimera,
                    ContainsTarget = true
                });

            var FullyQualifiedNamespacePerson_MyPet2Set = FullyQualifiedNamespacePerson.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyPet2Set", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespacePet2, });

            model.AddAlternateKeyAnnotation(FullyQualifiedNamespacePerson, new Dictionary<string, IEdmProperty>()
            {
                {"SocialSN", FullyQualifiedNamespacePerson_SSN}
            });

            model.AddAlternateKeyAnnotation(FullyQualifiedNamespacePerson, new Dictionary<string, IEdmProperty>()
            {
                {"NameAlias", FullyQualifiedNamespacePerson_Name},
                {"FirstNameAlias", FullyQualifiedNamespacePerson_FirstName}
            });

            model.AddElement(FullyQualifiedNamespacePerson);

            FullyQualifiedNamespaceEmployee.AddStructuralProperty("WorkEmail", EdmCoreModel.Instance.GetString(true));
            var FullyQualifiedNamespaceEmployee_PaintingsInOffice = FullyQualifiedNamespaceEmployee.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "PaintingsInOffice", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespacePainting });
            var FullyQualifiedNamespaceEmployee_Manager = FullyQualifiedNamespaceEmployee.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "Manager", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespaceManager });
            var FullyQualifiedNamespaceEmployee_OfficeDog = FullyQualifiedNamespaceDog.AddBidirectionalNavigation
                (
                    new EdmNavigationPropertyInfo()
                    {
                        Name = "EmployeeOwner",
                        TargetMultiplicity = EdmMultiplicity.One,
                        Target = FullyQualifiedNamespaceEmployee
                    },

                    new EdmNavigationPropertyInfo()
                    {
                        Name = "OfficeDog",
                        TargetMultiplicity = EdmMultiplicity.One,
                        Target = FullyQualifiedNamespaceDog
                    }
                );
            model.AddElement(FullyQualifiedNamespaceEmployee);

            FullyQualifiedNamespaceManager.AddStructuralProperty("NumberOfReports", EdmCoreModel.Instance.GetInt32(true));
            var FullyQualifiedNamespaceManager_DirectReports = FullyQualifiedNamespaceManager.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "DirectReports", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespaceEmployee });
            model.AddElement(FullyQualifiedNamespaceManager);

            model.AddElement(FullyQualifiedNamespaceOpenEmployee);

            var FullyQualifiedNamespaceDog_ID = FullyQualifiedNamespaceDog.AddStructuralProperty("ID", EdmCoreModel.Instance.GetInt32(false));
            FullyQualifiedNamespaceDog.AddStructuralProperty("Color", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespaceDog.AddStructuralProperty("Nicknames", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(true))));
            FullyQualifiedNamespaceDog.AddStructuralProperty("Breed", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespaceDog.AddStructuralProperty("NamedStream", EdmCoreModel.Instance.GetStream(true));
            FullyQualifiedNamespaceDog.AddStructuralProperty("Weight", EdmCoreModel.Instance.GetDouble(true));
            FullyQualifiedNamespaceDog.AddKeys(new IEdmStructuralProperty[] { FullyQualifiedNamespaceDog_ID, });
            var FullyQualifiedNamespaceDog_MyPeople = FullyQualifiedNamespaceDog.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "MyPeople", TargetMultiplicity = EdmMultiplicity.Many, Target = FullyQualifiedNamespacePerson });
            var FullyQualifiedNamespaceDog_FastestOwner = FullyQualifiedNamespaceDog.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "FastestOwner", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespacePerson });
            var FullyQualifiedNamespaceDog_LionWhoAteMe = FullyQualifiedNamespaceDog.AddBidirectionalNavigation(
                new EdmNavigationPropertyInfo()
                {
                    Name = "LionWhoAteMe",
                    TargetMultiplicity = EdmMultiplicity.One,
                    Target = FullyQualifiedNamespaceLion,
                },
                new EdmNavigationPropertyInfo()
                {
                    Name = "DogThatIAte",
                    TargetMultiplicity = EdmMultiplicity.One,
                    Target = FullyQualifiedNamespaceDog,
                    DependentProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceLion_ID1
                    },
                    PrincipalProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceDog_ID
                    }
                });
            var FullyQualifiedNamespaceDog_LionsISaw = FullyQualifiedNamespaceDog.AddBidirectionalNavigation(
                new EdmNavigationPropertyInfo()
                {
                    Name = "LionsISaw",
                    TargetMultiplicity = EdmMultiplicity.Many,
                    Target = FullyQualifiedNamespaceLion,
                },
                new EdmNavigationPropertyInfo()
                {
                    Name = "DogsSeenMe",
                    TargetMultiplicity = EdmMultiplicity.Many,
                    Target = FullyQualifiedNamespaceDog,
                    DependentProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceLion_ID1
                    },
                    PrincipalProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceDog_ID
                    }
                });
            var FullyQualifiedNamespaceLion_Friends = FullyQualifiedNamespaceLion.AddUnidirectionalNavigation(
                new EdmNavigationPropertyInfo()
                {
                    Name = "Friends",
                    TargetMultiplicity = EdmMultiplicity.Many,
                    Target = FullyQualifiedNamespaceLion,
                    DependentProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceLion_ID2
                    },
                    PrincipalProperties = new List<IEdmStructuralProperty>()
                    {
                        FullyQualifiedNamespaceLion_ID1
                    }
                });
            model.AddElement(FullyQualifiedNamespaceDog);

            var fullyQualifiedNamespaceChimeraKey1 = FullyQualifiedNamespaceChimera.AddStructuralProperty("Rid", EdmCoreModel.Instance.GetInt32(false));
            var fullyQualifiedNamespaceChimeraKey2 = FullyQualifiedNamespaceChimera.AddStructuralProperty("Gid", EdmPrimitiveTypeKind.Guid);
            var fullyQualifiedNamespaceChimeraKey3 = FullyQualifiedNamespaceChimera.AddStructuralProperty("Name", EdmPrimitiveTypeKind.String);
            var fullyQualifiedNamespaceChimeraKey4 = FullyQualifiedNamespaceChimera.AddStructuralProperty("Upgraded", EdmPrimitiveTypeKind.Boolean);
            FullyQualifiedNamespaceChimera.AddStructuralProperty("Level", EdmPrimitiveTypeKind.Int32);
            FullyQualifiedNamespaceChimera.AddKeys(new IEdmStructuralProperty[] { fullyQualifiedNamespaceChimeraKey1, fullyQualifiedNamespaceChimeraKey2, fullyQualifiedNamespaceChimeraKey3, fullyQualifiedNamespaceChimeraKey4 });
            model.AddElement(FullyQualifiedNamespaceChimera);

            var FullyQualifiedNamespacePainting_ID = FullyQualifiedNamespacePainting.AddStructuralProperty("ID", EdmCoreModel.Instance.GetInt32(false));
            FullyQualifiedNamespacePainting.AddStructuralProperty("Artist", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespacePainting.AddStructuralProperty("ArtistAddress", FullyQualifiedNamespaceAddressTypeReference);
            FullyQualifiedNamespacePainting.AddStructuralProperty("Value", EdmCoreModel.Instance.GetDecimal(true));
            FullyQualifiedNamespacePainting.AddStructuralProperty("Colors", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(true))));
            FullyQualifiedNamespacePainting.AddKeys(new IEdmStructuralProperty[] { FullyQualifiedNamespacePainting_ID, });
            var FullyQualifiedNamespacePainting_Owner = FullyQualifiedNamespacePainting.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "Owner", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespacePerson });
            model.AddElement(FullyQualifiedNamespacePainting);

            FullyQualifiedNamespaceFramedPainting.AddStructuralProperty("FrameColor", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceFramedPainting);

            var FullyQualifiedNamespaceUserAccount_UserName = FullyQualifiedNamespaceUserAccount.AddStructuralProperty("UserName", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespaceUserAccount.AddKeys(new IEdmStructuralProperty[] { FullyQualifiedNamespaceUserAccount_UserName, });
            model.AddElement(FullyQualifiedNamespaceUserAccount);

            FullyQualifiedNamespaceAddress.AddStructuralProperty("Street", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespaceAddress.AddStructuralProperty("City", EdmCoreModel.Instance.GetString(true));
            FullyQualifiedNamespaceAddress.AddStructuralProperty("NextHome", FullyQualifiedNamespaceAddressTypeReference);
            FullyQualifiedNamespaceAddress.AddStructuralProperty("MyNeighbors", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(true))));
            FullyQualifiedNamespaceAddress.AddUnidirectionalNavigation(new EdmNavigationPropertyInfo { Name = "PostBoxPainting", TargetMultiplicity = EdmMultiplicity.ZeroOrOne, Target = FullyQualifiedNamespacePainting });
            model.AddElement(FullyQualifiedNamespaceAddress);

            FullyQualifiedNamespaceHomeAddress.AddStructuralProperty("HomeNO", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceHomeAddress);

            model.AddElement(FullyQualifiedNamespaceOpenAddress);

            FullyQualifiedNamespaceHeartbeat.AddStructuralProperty("Frequency", EdmCoreModel.Instance.GetDouble(true));
            model.AddElement(FullyQualifiedNamespaceHeartbeat);

            FullyQualifiedNamespacePet1.AddKeys(FullyQualifiedNamespacePet1.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Int64, false));
            FullyQualifiedNamespacePet1.AddStructuralProperty("SingleID", EdmPrimitiveTypeKind.Single, false);
            FullyQualifiedNamespacePet1.AddStructuralProperty("DoubleID", EdmPrimitiveTypeKind.Double, false);
            FullyQualifiedNamespacePet1.AddStructuralProperty("DecimalID", EdmPrimitiveTypeKind.Decimal, false);
            FullyQualifiedNamespacePet1.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespacePet1);

            FullyQualifiedNamespacePet2.AddKeys(FullyQualifiedNamespacePet2.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Single, false));
            FullyQualifiedNamespacePet2.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            FullyQualifiedNamespacePet2.AddStructuralProperty("PetColorPattern", colorTypeReference);
            FullyQualifiedNamespacePet2.AddStructuralProperty("Shape", new EdmEnumTypeReference(NonFlagShapeType, false));
            model.AddElement(FullyQualifiedNamespacePet2);

            FullyQualifiedNamespacePet3.AddKeys(FullyQualifiedNamespacePet3.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Double, false));
            FullyQualifiedNamespacePet3.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespacePet3);

            FullyQualifiedNamespacePet4.AddKeys(FullyQualifiedNamespacePet4.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Decimal, false));
            FullyQualifiedNamespacePet4.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespacePet4);

            FullyQualifiedNamespacePet5.AddKeys(FullyQualifiedNamespacePet5.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Boolean, false));
            FullyQualifiedNamespacePet5.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespacePet5);

            FullyQualifiedNamespacePet6.AddKeys(FullyQualifiedNamespacePet6.AddStructuralProperty("ID", FullyQualifiedNamespaceIdTypeReference));
            FullyQualifiedNamespacePet6.AddStructuralProperty("Color", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespacePet6);

            // entity type with enum as key
            var fullyQualifiedNamespaceShape = new EdmEntityType("Fully.Qualified.Namespace", "Shape", null, false, false);
            fullyQualifiedNamespaceShape.AddKeys(fullyQualifiedNamespaceShape.AddStructuralProperty("Color", colorTypeReference));

            FullyQualifiedNamespaceFilm.AddKeys(FullyQualifiedNamespaceFilm.AddStructuralProperty("ID", EdmPrimitiveTypeKind.Int32, false));
            FullyQualifiedNamespaceFilm.AddStructuralProperty("Title", EdmPrimitiveTypeKind.String);
            model.AddElement(FullyQualifiedNamespaceFilm);
            #endregion

            #region Annotation Terms
            var fullyQualifiedAnnotationTerm = new EdmTerm("Fully.Qualified.Namespace", "PrimitiveTerm", EdmPrimitiveTypeKind.String);
            model.AddElement(fullyQualifiedAnnotationTerm);

            var fullyQualifiedStructuredAnnotationTerm = new EdmTerm("Fully.Qualified.Namespace", "ComplexTerm", new EdmComplexTypeReference(FullyQualifiedNamespaceAddress, false));
            model.AddElement(fullyQualifiedStructuredAnnotationTerm);

            #endregion

            #region Operations

            var FullyQualifiedNamespaceGetPersonByDTOFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPersonByDTO", FullyQualifiedNamespacePersonTypeReference, false, null, true);
            FullyQualifiedNamespaceGetPersonByDTOFunction.AddParameter("dto", EdmCoreModel.Instance.GetDateTimeOffset(false));
            model.AddElement(FullyQualifiedNamespaceGetPersonByDTOFunction);

            var FullyQualifiedNamespaceGetPersonByDateFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPersonByDate", FullyQualifiedNamespacePersonTypeReference, false, null, true);
            FullyQualifiedNamespaceGetPersonByDateFunction.AddParameter("date", EdmCoreModel.Instance.GetDate(false));
            model.AddElement(FullyQualifiedNamespaceGetPersonByDateFunction);

            var FullyQualifiedNamespaceGetPet1Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet1", FullyQualifiedNamespacePet1TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet1Function.AddParameter("id", EdmCoreModel.Instance.GetInt64(false));
            model.AddElement(FullyQualifiedNamespaceGetPet1Function);

            var FullyQualifiedNamespaceGetPet2Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet2", FullyQualifiedNamespacePet2TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet2Function.AddParameter("id", EdmCoreModel.Instance.GetSingle(false));
            model.AddElement(FullyQualifiedNamespaceGetPet2Function);

            var FullyQualifiedNamespaceGetPet3Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet3", FullyQualifiedNamespacePet3TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet3Function.AddParameter("id", EdmCoreModel.Instance.GetDouble(false));
            model.AddElement(FullyQualifiedNamespaceGetPet3Function);

            var FullyQualifiedNamespaceGetPet4Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet4", FullyQualifiedNamespacePet4TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet4Function.AddParameter("id", EdmCoreModel.Instance.GetDecimal(false));
            model.AddElement(FullyQualifiedNamespaceGetPet4Function);

            var FullyQualifiedNamespaceGetPet5Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet5", FullyQualifiedNamespacePet5TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet5Function.AddParameter("id", EdmCoreModel.Instance.GetBoolean(false));
            model.AddElement(FullyQualifiedNamespaceGetPet5Function);

            var FullyQualifiedNamespaceGetPet6Function = new EdmFunction("Fully.Qualified.Namespace", "GetPet6", FullyQualifiedNamespacePet6TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPet6Function.AddParameter("id", FullyQualifiedNamespaceIdTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetPet6Function);

            var FullyQualifiedNamespaceGetPetCountFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPetCount", FullyQualifiedNamespacePet5TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPetCountFunction.AddParameter("colorPattern", colorTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetPetCountFunction);

            var FullyQualifiedNamespaceTryGetPetCountFunction = new EdmFunction("Fully.Qualified.Namespace", "TryGetPetCount", FullyQualifiedNamespacePet5TypeReference, false, null, true);
            FullyQualifiedNamespaceGetPetCountFunction.AddParameter("colorPattern", nullableColorTypeReference);
            model.AddElement(FullyQualifiedNamespaceTryGetPetCountFunction);

            var FullyQualifiedNamespaceWalkAction = new EdmAction("Fully.Qualified.Namespace", "Walk", FullyQualifiedNamespaceAddressTypeReference, true, null);
            FullyQualifiedNamespaceWalkAction.AddParameter("dog", FullyQualifiedNamespaceDogTypeReference);
            model.AddElement(FullyQualifiedNamespaceWalkAction);

            var FullyQualifiedNamespaceFindMyOwnerFunction = new EdmFunction("Fully.Qualified.Namespace", "FindMyOwner", FullyQualifiedNamespacePersonTypeReference, false, null, false);
            FullyQualifiedNamespaceFindMyOwnerFunction.AddParameter("dogsName", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceFindMyOwnerFunction);

            var FullyQualifiedNamespaceHasHatFunction = new EdmFunction("Fully.Qualified.Namespace", "HasHat", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasHatFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceHasHatFunction);

            var FullyQualifiedNamespaceHasHatFunction2 = new EdmFunction("Fully.Qualified.Namespace", "HasHat", EdmCoreModel.Instance.GetInt32(true), true, null, false);
            FullyQualifiedNamespaceHasHatFunction2.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceHasHatFunction2.AddParameter("onCat", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceHasHatFunction2);

            var FullyQualifiedNamespaceHasJobFunction = new EdmFunction("Fully.Qualified.Namespace", "HasJob", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasJobFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceHasJobFunction);

            var FullyQualifiedNamespaceAllHaveDogFunction = new EdmFunction("Fully.Qualified.Namespace", "AllHaveDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceAllHaveDogFunction.AddParameter("people", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            model.AddElement(FullyQualifiedNamespaceAllHaveDogFunction);

            var FullyQualifiedNamespaceAllHaveDogFunction2 = new EdmFunction("Fully.Qualified.Namespace", "AllHaveDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceAllHaveDogFunction2.AddParameter("people", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            FullyQualifiedNamespaceAllHaveDogFunction2.AddParameter("inOffice", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceAllHaveDogFunction2);

            var FullyQualifiedNamespaceGetPeopleWhoHaveDogsFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPeopleWhoHaveDogs", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)), true, null, true);
            FullyQualifiedNamespaceGetPeopleWhoHaveDogsFunction.AddParameter("people", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            model.AddElement(FullyQualifiedNamespaceGetPeopleWhoHaveDogsFunction);

            var FullyQualifiedNamespaceGetPersonWhoHasSmartestDogFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPersonWhoHasSmartestDog", FullyQualifiedNamespacePersonTypeReference, true, null, true);
            FullyQualifiedNamespaceGetPersonWhoHasSmartestDogFunction.AddParameter("people", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            model.AddElement(FullyQualifiedNamespaceGetPersonWhoHasSmartestDogFunction);

            var FullyQualifiedNamespaceAdoptShibaInuAction = new EdmFunction("Fully.Qualified.Namespace", "AdoptShibaInu", EdmCoreModel.Instance.GetBoolean(true), true, null, true);
            FullyQualifiedNamespaceAdoptShibaInuAction.AddParameter("people", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            model.AddElement(FullyQualifiedNamespaceAdoptShibaInuAction);

            var FullyQualifiedNamespaceSummonPuppiesAction = new EdmFunction("Fully.Qualified.Namespace", "SummonPuppies", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)), true, null, true);
            FullyQualifiedNamespaceSummonPuppiesAction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceSummonPuppiesAction);

            var FullyQualifiedNamespaceFireAllAction = new EdmAction("Fully.Qualified.Namespace", "FireAll", EdmCoreModel.Instance.GetBoolean(true), true, null);
            FullyQualifiedNamespaceFireAllAction.AddParameter("employees", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)));
            model.AddElement(FullyQualifiedNamespaceFireAllAction);

            var FullyQualifiedNamespaceHasDogFunction = new EdmFunction("Fully.Qualified.Namespace", "HasDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasDogFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceHasDogFunction);

            var FullyQualifiedNamespaceHasDogFunction2 = new EdmFunction("Fully.Qualified.Namespace", "HasDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasDogFunction2.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceHasDogFunction2.AddParameter("inOffice", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceHasDogFunction2);

            var FullyQualifiedNamespaceHasDogFunction3 = new EdmFunction("Fully.Qualified.Namespace", "HasDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasDogFunction3.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceHasDogFunction3.AddParameter("inOffice", EdmCoreModel.Instance.GetBoolean(true));
            FullyQualifiedNamespaceHasDogFunction3.AddParameter("name", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceHasDogFunction3);

            var FullyQualifiedNamespaceHasDogFunction4 = new EdmFunction("Fully.Qualified.Namespace", "HasDog", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceHasDogFunction4.AddParameter("person", FullyQualifiedNamespaceEmployeeTypeReference);
            FullyQualifiedNamespaceHasDogFunction4.AddParameter("inOffice", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceHasDogFunction4);

            var FullyQualifiedNamespaceGetMyDogFunction = new EdmFunction("Fully.Qualified.Namespace", "GetMyDog", FullyQualifiedNamespaceDogTypeReference, true, new EdmPathExpression("person/MyDog"), true);
            FullyQualifiedNamespaceGetMyDogFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetMyDogFunction);

            var FullyQualifiedNamespaceAllMyFriendsDogsFunction = new EdmFunction("Fully.Qualified.Namespace", "AllMyFriendsDogs", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)), true, new EdmPathExpression("person/MyFriendsDogs"), true);
            FullyQualifiedNamespaceAllMyFriendsDogsFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceAllMyFriendsDogsFunction);

            var FullyQualifiedNamespaceAllMyFriendsDogsNonComposableFunction = new EdmFunction("Fully.Qualified.Namespace", "AllMyFriendsDogsNonComposable", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)), true, new EdmPathExpression("person/MyFriendsDogs"), false);
            FullyQualifiedNamespaceAllMyFriendsDogsNonComposableFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceAllMyFriendsDogsNonComposableFunction);

            var FullyQualifiedNamespaceAllMyFriendsDogsFunction2 = new EdmFunction("Fully.Qualified.Namespace", "AllMyFriendsDogs", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)), true, new EdmPathExpression("person/MyFriendsDogs"), true);
            FullyQualifiedNamespaceAllMyFriendsDogsFunction2.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceAllMyFriendsDogsFunction2.AddParameter("inOffice", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceAllMyFriendsDogsFunction2);

            var FullyQualifiedNamespaceAllMyFriendsDogs_NoSetFunction = new EdmFunction("Fully.Qualified.Namespace", "AllMyFriendsDogs_NoSet", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)), true, null, false);
            FullyQualifiedNamespaceAllMyFriendsDogs_NoSetFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceAllMyFriendsDogs_NoSetFunction);

            var FullyQualifiedNamespaceOwnerOfFastestDogFunction = new EdmFunction("Fully.Qualified.Namespace", "OwnerOfFastestDog", FullyQualifiedNamespacePersonTypeReference, true, new EdmPathExpression("dogs/FastestOwner"), true);
            FullyQualifiedNamespaceOwnerOfFastestDogFunction.AddParameter("dogs", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceDogTypeReference)));
            model.AddElement(FullyQualifiedNamespaceOwnerOfFastestDogFunction);

            var FullyQualifiedNamespaceOwnsTheseDogsFunction = new EdmFunction("Fully.Qualified.Namespace", "OwnsTheseDogs", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceOwnsTheseDogsFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceOwnsTheseDogsFunction.AddParameter("dogNames", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetString(true))));
            model.AddElement(FullyQualifiedNamespaceOwnsTheseDogsFunction);

            var FullyQualifiedNamespaceIsInTheUSFunction = new EdmFunction("Fully.Qualified.Namespace", "IsInTheUS", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceIsInTheUSFunction.AddParameter("address", FullyQualifiedNamespaceAddressTypeReference);
            model.AddElement(FullyQualifiedNamespaceIsInTheUSFunction);

            var FullyQualifiedNamespaceMoveAction = new EdmAction("Fully.Qualified.Namespace", "Move", EdmCoreModel.Instance.GetBoolean(true), true, null);
            FullyQualifiedNamespaceMoveAction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceMoveAction.AddParameter("streetAddress", EdmCoreModel.Instance.GetString(true));

            var FullyQualifiedNamespaceCanMoveToAddressFunction = new EdmFunction("Fully.Qualified.Namespace", "CanMoveToAddress", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceCanMoveToAddressFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceCanMoveToAddressFunction.AddParameter("address", FullyQualifiedNamespaceAddressTypeReference);
            model.AddElement(FullyQualifiedNamespaceCanMoveToAddressFunction);

            var FullyQualifiedNamespaceIsAddressGoodFunction = new EdmFunction("Fully.Qualified.Namespace", "IsAddressGood", EdmCoreModel.Instance.GetBoolean(true), false, null, false);
            FullyQualifiedNamespaceIsAddressGoodFunction.AddParameter("address", FullyQualifiedNamespaceAddressTypeReference);
            model.AddElement(FullyQualifiedNamespaceIsAddressGoodFunction);

            var FullyQualifiedNamespaceCanMoveToAddressesFunction = new EdmFunction("Fully.Qualified.Namespace", "CanMoveToAddresses", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceCanMoveToAddressesFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceCanMoveToAddressesFunction.AddParameter("addresses", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceAddressTypeReference)));
            model.AddElement(FullyQualifiedNamespaceCanMoveToAddressesFunction);

            var FullyQualifiedNamespaceIsOlderThanByteFunction = new EdmFunction("Fully.Qualified.Namespace", "IsOlderThanByte", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceIsOlderThanByteFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceIsOlderThanByteFunction.AddParameter("age", EdmCoreModel.Instance.GetByte(true));
            model.AddElement(FullyQualifiedNamespaceIsOlderThanByteFunction);

            var FullyQualifiedNamespaceIsOlderThanSByteFunction = new EdmFunction("Fully.Qualified.Namespace", "IsOlderThanSByte", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceIsOlderThanSByteFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceIsOlderThanSByteFunction.AddParameter("age", EdmCoreModel.Instance.GetSByte(true));
            model.AddElement(FullyQualifiedNamespaceIsOlderThanSByteFunction);

            var FullyQualifiedNamespaceIsOlderThanShortFunction = new EdmFunction("Fully.Qualified.Namespace", "IsOlderThanShort", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceIsOlderThanShortFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceIsOlderThanShortFunction.AddParameter("age", EdmCoreModel.Instance.GetInt16(true));
            model.AddElement(FullyQualifiedNamespaceIsOlderThanShortFunction);

            var FullyQualifiedNamespaceIsOlderThanSingleFunction = new EdmFunction("Fully.Qualified.Namespace", "IsOlderThanSingle", EdmCoreModel.Instance.GetBoolean(true), true, null, false);
            FullyQualifiedNamespaceIsOlderThanSingleFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceIsOlderThanSingleFunction.AddParameter("age", EdmCoreModel.Instance.GetSingle(true));
            model.AddElement(FullyQualifiedNamespaceIsOlderThanSingleFunction);

            var FullyQualifiedNamespacePaintAction = new EdmAction("Fully.Qualified.Namespace", "Paint", FullyQualifiedNamespacePaintingTypeReference, true, new EdmPathExpression("person/MyPaintings"));
            FullyQualifiedNamespacePaintAction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespacePaintAction);

            var FullyQualifiedNamespaceMoveAction2 = new EdmAction("Fully.Qualified.Namespace", "Move", EdmCoreModel.Instance.GetBoolean(true), true, null);
            FullyQualifiedNamespaceMoveAction2.AddParameter("employee", FullyQualifiedNamespaceEmployeeTypeReference);
            FullyQualifiedNamespaceMoveAction2.AddParameter("building", EdmCoreModel.Instance.GetInt32(true));
            FullyQualifiedNamespaceMoveAction2.AddParameter("room", EdmCoreModel.Instance.GetInt32(true));
            model.AddElement(FullyQualifiedNamespaceMoveAction2);

            var FullyQualifiedNamespaceRestoreAction = new EdmAction("Fully.Qualified.Namespace", "Restore", EdmCoreModel.Instance.GetBoolean(true), true, null);
            FullyQualifiedNamespaceRestoreAction.AddParameter("painting", FullyQualifiedNamespacePaintingTypeReference);
            model.AddElement(FullyQualifiedNamespaceRestoreAction);

            var FullyQualifiedNamespaceChangeStateAction = new EdmAction("Fully.Qualified.Namespace", "ChangeState", EdmCoreModel.Instance.GetBoolean(true), true, null);
            FullyQualifiedNamespaceChangeStateAction.AddParameter("address", FullyQualifiedNamespaceAddressTypeReference);
            FullyQualifiedNamespaceChangeStateAction.AddParameter("newState", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceChangeStateAction);

            var FullyQualifiedNamespaceGetMyPersonFunction = new EdmFunction("Fully.Qualified.Namespace", "GetMyPerson", FullyQualifiedNamespacePersonTypeReference, true, null, false);
            FullyQualifiedNamespaceGetMyPersonFunction.AddParameter("dog", FullyQualifiedNamespaceDogTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetMyPersonFunction);
            model.AddElement(FullyQualifiedNamespaceMoveAction);

            var FullyQualifiedNamespaceGetCoolPeopleAction = new EdmFunction("Fully.Qualified.Namespace", "GetCoolPeople", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)), false, null, true /*isComposable*/);
            FullyQualifiedNamespaceGetCoolPeopleAction.AddParameter("id", EdmCoreModel.Instance.GetInt32(true));
            FullyQualifiedNamespaceGetCoolPeopleAction.AddParameter("limit", EdmCoreModel.Instance.GetInt32(true));
            model.AddElement(FullyQualifiedNamespaceGetCoolPeopleAction);

            var FullyQualifiedNamespaceGetHotPeopleAction = new EdmFunction("Fully.Qualified.Namespace", "GetHotPeople", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespacePersonTypeReference)), true, new EdmPathExpression("person"), true /*isComposable*/);
            FullyQualifiedNamespaceGetHotPeopleAction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceGetHotPeopleAction.AddParameter("limit", EdmCoreModel.Instance.GetInt32(true));
            model.AddElement(FullyQualifiedNamespaceGetHotPeopleAction);

            var FullyQualifiedNamespaceGetCoolestPersonAction = new EdmFunction("Fully.Qualified.Namespace", "GetCoolestPerson", FullyQualifiedNamespacePersonTypeReference, false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetCoolestPersonAction);

            var FullyQualifiedNamespaceGetCoolestPersonWithStyleAction = new EdmFunction("Fully.Qualified.Namespace", "GetCoolestPersonWithStyle", FullyQualifiedNamespacePersonTypeReference, false, null, true /*isComposable*/);
            FullyQualifiedNamespaceGetCoolestPersonWithStyleAction.AddParameter("styleID", EdmCoreModel.Instance.GetInt32(true));
            model.AddElement(FullyQualifiedNamespaceGetCoolestPersonWithStyleAction);

            var FullyQualifiedNamespaceGetBestManagerAction = new EdmFunction("Fully.Qualified.Namespace", "GetBestManager", FullyQualifiedNamespaceManagerTypeReference, false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetBestManagerAction);

            var FullyQualifiedNamespaceGetNothingAction = new EdmAction("Fully.Qualified.Namespace", "GetNothing", null, false, null);
            model.AddElement(FullyQualifiedNamespaceGetNothingAction);

            var FullyQualifiedNamespaceGetSomeNumberAction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeNumber", EdmCoreModel.Instance.GetInt32(true), false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeNumberAction);

            var FullyQualifiedNamespaceGetSomeAddressAction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeAddress", FullyQualifiedNamespaceAddressTypeReference, false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeAddressAction);

            var FullyQualifiedNamespaceGetSomeAddressFromPersonFunction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeAddressFromPerson", FullyQualifiedNamespaceAddressTypeReference, true, null, true /*isComposable*/);
            FullyQualifiedNamespaceGetSomeAddressFromPersonFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetSomeAddressFromPersonFunction);

            var FullyQualifiedNamespaceGetSomeNumbersAction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeNumbers", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetInt32(true))), false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeNumbersAction);

            var FullyQualifiedNamespaceGetSomeColorsFunction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeColors", new EdmCollectionTypeReference(new EdmCollectionType(colorTypeReference)), false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeColorsFunction);

            var FullyQualifiedNamespaceGetSomeColorFunction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeColor", colorTypeReference, false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeColorFunction);

            var FullyQualifiedNamespaceGetSomeAddressesAction = new EdmFunction("Fully.Qualified.Namespace", "GetSomeAddresses", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceAddressTypeReference)), false, null, true /*isComposable*/);
            model.AddElement(FullyQualifiedNamespaceGetSomeAddressesAction);

            var FullyQualifiedNamespaceResetAllDataAction = new EdmAction("Fully.Qualified.Namespace", "ResetAllData", null, false, null);
            model.AddElement(FullyQualifiedNamespaceResetAllDataAction);

            var FullyQualifiedNamespaceGetMostImporantPersonFunction = new EdmFunction("Fully.Qualified.Namespace", "GetMostImporantPerson", FullyQualifiedNamespacePersonTypeReference, false, null, false);
            model.AddElement(FullyQualifiedNamespaceGetMostImporantPersonFunction);

            var FullyQualifiedNamespaceGetMostImporantPersonFunction2 = new EdmFunction("Fully.Qualified.Namespace", "GetMostImporantPerson", FullyQualifiedNamespacePersonTypeReference, false, null, false);
            FullyQualifiedNamespaceGetMostImporantPersonFunction2.AddParameter("city", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceGetMostImporantPersonFunction2);

            var FullyQualifiedNamespaceGetPriorNumbersFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPriorNumbers", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetInt32(true))), true, null, true);
            FullyQualifiedNamespaceGetPriorNumbersFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetPriorNumbersFunction);

            var FullyQualifiedNamespaceGetPriorAddressesFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPriorAddresses", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceAddressTypeReference)), true, null, true);
            FullyQualifiedNamespaceGetPriorAddressesFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetPriorAddressesFunction);

            var FullyQualifiedNamespaceGetPriorAddressFunction = new EdmFunction("Fully.Qualified.Namespace", "GetPriorAddress", FullyQualifiedNamespaceAddressTypeReference, true, null, true);
            FullyQualifiedNamespaceGetPriorAddressFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetPriorAddressFunction);

            var FullyQualifiedNamespaceGetFavoriteColorsFunction = new EdmFunction("Fully.Qualified.Namespace", "GetFavoriteColors", new EdmCollectionTypeReference(new EdmCollectionType(colorTypeReference)), true, null, true);
            FullyQualifiedNamespaceGetFavoriteColorsFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetFavoriteColorsFunction);

            var FullyQualifiedNamespaceGetFavoriteColorFunction = new EdmFunction("Fully.Qualified.Namespace", "GetFavoriteColor", colorTypeReference, true, null, true);
            FullyQualifiedNamespaceGetFavoriteColorFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetFavoriteColorFunction);

            var FullyQualifiedNamespaceGetNearbyPriorAddressesFunction = new EdmFunction("Fully.Qualified.Namespace", "GetNearbyPriorAddresses", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceAddressTypeReference)), true, null, false);
            FullyQualifiedNamespaceGetNearbyPriorAddressesFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceGetNearbyPriorAddressesFunction.AddParameter("currentLocation", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeographyPoint, true));
            FullyQualifiedNamespaceGetNearbyPriorAddressesFunction.AddParameter("limit", EdmCoreModel.Instance.GetInt32(true));
            model.AddElement(FullyQualifiedNamespaceGetNearbyPriorAddressesFunction);

            var FullyQualifiedNamespaceGetColorAtPositionFunction = new EdmFunction("Fully.Qualified.Namespace", "GetColorAtPosition", EdmCoreModel.Instance.GetString(true), true, null, false);
            FullyQualifiedNamespaceGetColorAtPositionFunction.AddParameter("painting", FullyQualifiedNamespacePaintingTypeReference);
            FullyQualifiedNamespaceGetColorAtPositionFunction.AddParameter("position", EdmCoreModel.Instance.GetSpatial(EdmPrimitiveTypeKind.GeometryPoint, true));
            FullyQualifiedNamespaceGetColorAtPositionFunction.AddParameter("includeAlpha", EdmCoreModel.Instance.GetBoolean(true));
            model.AddElement(FullyQualifiedNamespaceGetColorAtPositionFunction);

            var FullyQualifiedNamespaceMoveEveryoneAction = new EdmAction("Fully.Qualified.Namespace", "MoveEveryone", EdmCoreModel.Instance.GetBoolean(true), false, null);
            FullyQualifiedNamespaceMoveEveryoneAction.AddParameter("streetAddress", EdmCoreModel.Instance.GetString(true));
            model.AddElement(FullyQualifiedNamespaceMoveEveryoneAction);

            var FullyQualifiedNamespaceGetFullNameFunction = new EdmFunction("Fully.Qualified.Namespace", "GetFullName", FullyQualifiedNamespaceNameTypeReference, true, null, true);
            FullyQualifiedNamespaceGetNearbyPriorAddressesFunction.AddParameter("person", FullyQualifiedNamespacePersonTypeReference);
            FullyQualifiedNamespaceGetFullNameFunction.AddParameter("nickname", FullyQualifiedNamespaceNameTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetFullNameFunction);

            var FullyQualifiedNamespaceGetRatingFunction = new EdmFunction("Fully.Qualified.Namespace", "GetRating", EdmCoreModel.Instance.GetInt32(true), false, null, true);
            FullyQualifiedNamespaceGetRatingFunction.AddParameter("film", FullyQualifiedNamespaceFilmTypeReference);
            model.AddElement(FullyQualifiedNamespaceGetRatingFunction);

            var FullyQualifiedNamespaceGetRatingsFunction = new EdmFunction("Fully.Qualified.Namespace", "GetRatings", new EdmCollectionTypeReference(new EdmCollectionType(EdmCoreModel.Instance.GetInt32(true))), false, null, true);
            FullyQualifiedNamespaceGetRatingsFunction.AddParameter("films", new EdmCollectionTypeReference(new EdmCollectionType(FullyQualifiedNamespaceFilmTypeReference)));
            model.AddElement(FullyQualifiedNamespaceGetRatingsFunction);

            #endregion

            #region Context Container

            var FullyQualifiedNamespaceContext = new EdmEntityContainer("Fully.Qualified.Namespace", "Context");
            model.AddElement(FullyQualifiedNamespaceContext);

            var FullyQualifiedNamespaceContextPeople = FullyQualifiedNamespaceContext.AddEntitySet("People", FullyQualifiedNamespacePerson);
            var FullyQualifiedNamespaceContextDogs = FullyQualifiedNamespaceContext.AddEntitySet("Dogs", FullyQualifiedNamespaceDog);
            var FullyQualifiedNamespaceContextLions = FullyQualifiedNamespaceContext.AddEntitySet("Lions", FullyQualifiedNamespaceLion);
            var FullyQualifiedNamespaceContextPaintings = FullyQualifiedNamespaceContext.AddEntitySet("Paintings", FullyQualifiedNamespacePainting);
            var FullyQualifiedNamespaceContextUsers = FullyQualifiedNamespaceContext.AddEntitySet("Users", FullyQualifiedNamespaceUserAccount);
            var FullyQualifiedNamespaceContextPet1Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet1Set", FullyQualifiedNamespacePet1);
            var FullyQualifiedNamespaceContextPet2Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet2Set", FullyQualifiedNamespacePet2);
            var FullyQualifiedNamespaceContextPet3Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet3Set", FullyQualifiedNamespacePet3);
            var FullyQualifiedNamespaceContextPet4Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet4Set", FullyQualifiedNamespacePet4);
            var FullyQualifiedNamespaceContextPet5Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet5Set", FullyQualifiedNamespacePet5);
            var FullyQualifiedNamespaceContextPet6Set = FullyQualifiedNamespaceContext.AddEntitySet("Pet6Set", FullyQualifiedNamespacePet6);
            var FullyQualifiedNamespaceContextChimera = FullyQualifiedNamespaceContext.AddEntitySet("Chimeras", FullyQualifiedNamespaceChimera);

            FullyQualifiedNamespaceContext.AddEntitySet("Shapes", fullyQualifiedNamespaceShape);

            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyDog, FullyQualifiedNamespaceContextDogs);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyRelatedDogs, FullyQualifiedNamespaceContextDogs);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyLions, FullyQualifiedNamespaceContextLions);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyPaintings, FullyQualifiedNamespaceContextPaintings);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyFavoritePainting, FullyQualifiedNamespaceContextPaintings);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespaceEmployee_PaintingsInOffice, FullyQualifiedNamespaceContextPaintings);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespaceEmployee_Manager, FullyQualifiedNamespaceContextPeople);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespaceManager_DirectReports, FullyQualifiedNamespaceContextPeople);
            FullyQualifiedNamespaceContextPeople.AddNavigationTarget(FullyQualifiedNamespacePerson_MyPet2Set, FullyQualifiedNamespaceContextPet2Set);
            FullyQualifiedNamespaceContextDogs.AddNavigationTarget(FullyQualifiedNamespaceDog_MyPeople, FullyQualifiedNamespaceContextPeople);
            FullyQualifiedNamespaceContextDogs.AddNavigationTarget(FullyQualifiedNamespaceDog_FastestOwner, FullyQualifiedNamespaceContextPeople);
            FullyQualifiedNamespaceContextDogs.AddNavigationTarget(FullyQualifiedNamespaceDog_LionsISaw, FullyQualifiedNamespaceContextLions);
            FullyQualifiedNamespaceContextLions.AddNavigationTarget(FullyQualifiedNamespaceLion_Friends, FullyQualifiedNamespaceContextLions);
            FullyQualifiedNamespaceContextPaintings.AddNavigationTarget(FullyQualifiedNamespacePainting_Owner, FullyQualifiedNamespaceContextPeople);

            // Add singleton
            var FullQualifiedNamespaceSingletonBoss = FullyQualifiedNamespaceContext.AddSingleton("Boss", FullyQualifiedNamespacePerson);
            FullQualifiedNamespaceSingletonBoss.AddNavigationTarget(FullyQualifiedNamespacePerson_MyDog, FullyQualifiedNamespaceContextDogs);
            FullQualifiedNamespaceSingletonBoss.AddNavigationTarget(FullyQualifiedNamespacePerson_MyPaintings, FullyQualifiedNamespaceContextPaintings);
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPersonByDate", FullyQualifiedNamespaceGetPersonByDateFunction, new EdmPathExpression("People"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPersonByDTO", FullyQualifiedNamespaceGetPersonByDTOFunction, new EdmPathExpression("People"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet1", FullyQualifiedNamespaceGetPet1Function, new EdmPathExpression("Pet1Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet2", FullyQualifiedNamespaceGetPet2Function, new EdmPathExpression("Pet2Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet3", FullyQualifiedNamespaceGetPet3Function, new EdmPathExpression("Pet3Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet4", FullyQualifiedNamespaceGetPet4Function, new EdmPathExpression("Pet4Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet5", FullyQualifiedNamespaceGetPet5Function, new EdmPathExpression("Pet5Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPet6", FullyQualifiedNamespaceGetPet6Function, new EdmPathExpression("Pet6Set"));
            FullyQualifiedNamespaceContext.AddFunctionImport("GetPetCount", FullyQualifiedNamespaceGetPetCountFunction, new EdmPathExpression("Pet5Set"));

            FullyQualifiedNamespaceContext.AddFunctionImport("FindMyOwner", FullyQualifiedNamespaceFindMyOwnerFunction, new EdmPathExpression("People"));

            FullyQualifiedNamespaceContext.AddFunctionImport("IsAddressGood", FullyQualifiedNamespaceIsAddressGoodFunction, null);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetCoolPeople", FullyQualifiedNamespaceGetCoolPeopleAction, new EdmPathExpression("People"));

            FullyQualifiedNamespaceContext.AddFunctionImport("GetCoolestPerson", FullyQualifiedNamespaceGetCoolestPersonAction, new EdmPathExpression("People"));

            FullyQualifiedNamespaceContext.AddFunctionImport("GetCoolestPersonWithStyle", FullyQualifiedNamespaceGetCoolestPersonWithStyleAction, new EdmPathExpression("People"));

            FullyQualifiedNamespaceContext.AddFunctionImport("GetBestManager", FullyQualifiedNamespaceGetBestManagerAction, new EdmPathExpression("People"));

            FullyQualifiedNamespaceContext.AddActionImport("GetNothing", FullyQualifiedNamespaceGetNothingAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetSomeNumber", FullyQualifiedNamespaceGetSomeNumberAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetSomeAddress", FullyQualifiedNamespaceGetSomeAddressAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetSomeNumbers", FullyQualifiedNamespaceGetSomeNumbersAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetSomeAddresses", FullyQualifiedNamespaceGetSomeAddressesAction);

            FullyQualifiedNamespaceContext.AddActionImport("ResetAllData", FullyQualifiedNamespaceResetAllDataAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetMostImporantPerson", FullyQualifiedNamespaceGetMostImporantPersonFunction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetMostImporantPerson", FullyQualifiedNamespaceGetMostImporantPersonFunction2);

            FullyQualifiedNamespaceContext.AddActionImport("MoveEveryone", FullyQualifiedNamespaceMoveEveryoneAction);

            FullyQualifiedNamespaceContext.AddFunctionImport("GetRating", FullyQualifiedNamespaceGetRatingFunction);
            FullyQualifiedNamespaceContext.AddFunctionImport("GetRatings", FullyQualifiedNamespaceGetRatingsFunction);

            #endregion

            try
            {
                // serialize edm
                XDocument document = new XDocument();
                IEnumerable<EdmError> errors;
                using (var writer = document.CreateWriter())
                {
                    var result = CsdlWriter.TryWriteCsdl(model, writer, CsdlTarget.OData, out errors);
                    Debug.Assert(result);
                }

                string doc = document.ToString();

                // deserialize edm xml
                // TODO: remove the above model building codes.
                IEdmModel parsedModel;
                if (CsdlReader.TryParse(XmlReader.Create(new StringReader(HardCodedTestModelXml.MainModelXml)), (Uri uri) =>
                {
                    if (string.Equals(uri.AbsoluteUri, "http://submodel1/", StringComparison.Ordinal))
                    {
                        return XmlReader.Create(new StringReader(HardCodedTestModelXml.SubModelXml1));
                    }
                    else if (string.Equals(uri.AbsoluteUri, "http://submodel2/", StringComparison.Ordinal))
                    {
                        return XmlReader.Create(new StringReader(HardCodedTestModelXml.SubModelXml2));
                    }
                    else if (string.Equals(uri.AbsoluteUri, "http://submodel3/", StringComparison.Ordinal))
                    {
                        return XmlReader.Create(new StringReader(HardCodedTestModelXml.SubModelXml3));
                    }
                    else if (string.Equals(uri.AbsoluteUri, "http://submodel4/", StringComparison.Ordinal))
                    {
                        return XmlReader.Create(new StringReader(HardCodedTestModelXml.SubModelXml4));
                    }

                    throw new Exception("edmx:refernece must have a valid url." + uri.AbsoluteUri);
                }, out parsedModel, out errors))
                {
                    return parsedModel;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }

            return null;
        }

        internal class HardCodedTestModelXml
        {
            #region main model xml
            internal static string MainModelXml = @"
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:Reference Uri=""http://submodel1"">
    <edmx:Include Namespace=""Fully.Qualified.Namespace"" Alias=""RefAlias1"" />
  </edmx:Reference>
  <edmx:Reference Uri=""http://submodel2"">
    <edmx:Include Namespace=""Fully.Qualified.Namespace"" Alias=""RefAlias2"" />
  </edmx:Reference>
  <edmx:Reference Uri=""http://submodel3"">
    <edmx:Include Namespace=""Fully.Qualified.Namespace"" Alias=""RefAlias3"" />
  </edmx:Reference>
  <edmx:Reference Uri=""http://submodel4"">
    <edmx:Include Namespace=""Fully.Qualified.Namespace"" Alias=""RefAlias4"" />
  </edmx:Reference>
  <edmx:DataServices>
    <Schema Namespace=""Fully.Qualified.Namespace"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"" Alias=""MainAlias"">
      <Action Name=""MoveEveryone"">
        <Parameter Name=""streetAddress"" Type=""Edm.String"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <EntityContainer Name=""Context"">
        <EntitySet Name=""People"" EntityType=""Fully.Qualified.Namespace.Person"">
          <NavigationPropertyBinding Path=""MyDog"" Target=""Dogs"" />
          <NavigationPropertyBinding Path=""MyFriendsDogs"" Target=""Dogs"" />
          <NavigationPropertyBinding Path=""MyLions"" Target=""Lions"" />
          <NavigationPropertyBinding Path=""MyPaintings"" Target=""Paintings"" />
          <NavigationPropertyBinding Path=""MyFavoritePainting"" Target=""Paintings"" />
          <NavigationPropertyBinding Path=""Fully.Qualified.Namespace.Employee/PaintingsInOffice"" Target=""Paintings"" />
          <NavigationPropertyBinding Path=""Fully.Qualified.Namespace.Employee/Manager"" Target=""People"" />
          <NavigationPropertyBinding Path=""Fully.Qualified.Namespace.Manager/DirectReports"" Target=""People"" />
          <NavigationPropertyBinding Path=""MyPet2Set"" Target=""Pet2Set"" />
        </EntitySet>
        <EntitySet Name=""Dogs"" EntityType=""Fully.Qualified.Namespace.Dog"">
          <NavigationPropertyBinding Path=""MyPeople"" Target=""People"" />
          <NavigationPropertyBinding Path=""FastestOwner"" Target=""People"" />
          <NavigationPropertyBinding Path=""LionsISaw"" Target=""Lions"" />
        </EntitySet>
        <EntitySet Name=""Shapes"" EntityType=""Fully.Qualified.Namespace.Shape"" />
        <EntitySet Name=""Lions"" EntityType=""Fully.Qualified.Namespace.Lion"">
          <NavigationPropertyBinding Path=""Friends"" Target=""Lions"" />
        </EntitySet>
        <EntitySet Name=""Paintings"" EntityType=""Fully.Qualified.Namespace.Painting"">
          <NavigationPropertyBinding Path=""Owner"" Target=""People"" />
        </EntitySet>
        <EntitySet Name=""PetCategories"" EntityType=""Fully.Qualified.Namespace.PetCategory"" />
        <EntitySet Name=""Users"" EntityType=""Fully.Qualified.Namespace.UserAccount"" />
        <EntitySet Name=""Pet1Set"" EntityType=""Fully.Qualified.Namespace.Pet1"" />
        <EntitySet Name=""Pet2Set"" EntityType=""Fully.Qualified.Namespace.Pet2"" />
        <EntitySet Name=""Pet3Set"" EntityType=""Fully.Qualified.Namespace.Pet3"" />
        <EntitySet Name=""Pet4Set"" EntityType=""Fully.Qualified.Namespace.Pet4"" />
        <EntitySet Name=""Pet5Set"" EntityType=""Fully.Qualified.Namespace.Pet5"" />
        <EntitySet Name=""Pet6Set"" EntityType=""Fully.Qualified.Namespace.Pet6"" />
        <EntitySet Name=""Chimeras"" EntityType=""Fully.Qualified.Namespace.Chimera"" />
        <Singleton Name=""Boss"" Type=""Fully.Qualified.Namespace.Person"">
          <NavigationPropertyBinding Path=""MyDog"" Target=""Dogs"" />
          <NavigationPropertyBinding Path=""MyPaintings"" Target=""Paintings"" />
        </Singleton>
        <FunctionImport Name=""GetPersonByDate"" Function=""Fully.Qualified.Namespace.GetPersonByDate"" EntitySet=""People"" />
        <FunctionImport Name=""GetPersonByDTO"" Function=""Fully.Qualified.Namespace.GetPersonByDTO"" EntitySet=""People"" />
        <FunctionImport Name=""GetPet1"" Function=""Fully.Qualified.Namespace.GetPet1"" EntitySet=""Pet1Set"" />
        <FunctionImport Name=""GetPet2"" Function=""Fully.Qualified.Namespace.GetPet2"" EntitySet=""Pet2Set"" />
        <FunctionImport Name=""GetPet3"" Function=""Fully.Qualified.Namespace.GetPet3"" EntitySet=""Pet3Set"" />
        <FunctionImport Name=""GetPet4"" Function=""Fully.Qualified.Namespace.GetPet4"" EntitySet=""Pet4Set"" />
        <FunctionImport Name=""GetPet5"" Function=""Fully.Qualified.Namespace.GetPet5"" EntitySet=""Pet5Set"" />
        <FunctionImport Name=""GetPet6"" Function=""Fully.Qualified.Namespace.GetPet6"" EntitySet=""Pet6Set"" />
        <FunctionImport Name=""GetPetCountNullable"" Function=""Fully.Qualified.Namespace.GetPetCountNullable"" EntitySet=""Pet5Set"" />
        <FunctionImport Name=""GetPetCount"" Function=""Fully.Qualified.Namespace.GetPetCount"" EntitySet=""Pet5Set"" />
        <FunctionImport Name=""TryGetPetCount"" Function=""Fully.Qualified.Namespace.TryGetPetCount"" EntitySet=""Pet5Set"" />
        <FunctionImport Name=""FindMyOwner"" Function=""Fully.Qualified.Namespace.FindMyOwner"" EntitySet=""People"" />
        <FunctionImport Name=""IsAddressGood"" Function=""Fully.Qualified.Namespace.IsAddressGood"" />
        <FunctionImport Name=""GetCoolPeople"" Function=""Fully.Qualified.Namespace.GetCoolPeople"" EntitySet=""People"" />
        <FunctionImport Name=""GetCoolestPerson"" Function=""Fully.Qualified.Namespace.GetCoolestPerson"" EntitySet=""People"" />
        <FunctionImport Name=""GetCoolestPersonWithStyle"" Function=""Fully.Qualified.Namespace.GetCoolestPersonWithStyle"" EntitySet=""People"" />
        <FunctionImport Name=""GetBestManager"" Function=""Fully.Qualified.Namespace.GetBestManager"" EntitySet=""People"" />
        <ActionImport Name=""GetNothing"" Action=""Fully.Qualified.Namespace.GetNothing"" />
        <FunctionImport Name=""GetSomeNumber"" Function=""Fully.Qualified.Namespace.GetSomeNumber"" />
        <FunctionImport Name=""GetSomeAddress"" Function=""Fully.Qualified.Namespace.GetSomeAddress"" />
        <FunctionImport Name=""GetSomeNumbers"" Function=""Fully.Qualified.Namespace.GetSomeNumbers"" />
        <FunctionImport Name=""GetSomeAddresses"" Function=""Fully.Qualified.Namespace.GetSomeAddresses"" />
        <FunctionImport Name=""GetSomeColors"" Function=""Fully.Qualified.Namespace.GetSomeColors"" />
        <FunctionImport Name=""GetSomeColor"" Function=""Fully.Qualified.Namespace.GetSomeColor"" />
        <ActionImport Name=""ResetAllData"" Action=""Fully.Qualified.Namespace.ResetAllData"" />
        <FunctionImport Name=""GetMostImporantPerson"" Function=""Fully.Qualified.Namespace.GetMostImporantPerson"" />
        <ActionImport Name=""MoveEveryone"" Action=""Fully.Qualified.Namespace.MoveEveryone"" />
        <FunctionImport Name=""GetRating"" Function=""Fully.Qualified.Namespace.GetRating"" />
        <FunctionImport Name=""GetRatings"" Function=""Fully.Qualified.Namespace.GetRatings"" />
      </EntityContainer>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            #endregion

            #region sub model xml1
            internal static string SubModelXml1 = @"
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:DataServices>
    <Schema Namespace=""Fully.Qualified.Namespace"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"" Alias=""SubAlias1"">
      <EnumType Name=""ColorPattern"" UnderlyingType=""Edm.Int64"" IsFlags=""true"">
        <Member Name=""Red"" Value=""1"" />
        <Member Name=""Blue"" Value=""2"" />
        <Member Name=""Yellow"" Value=""4"" />
        <Member Name=""Solid"" Value=""8"" />
        <Member Name=""Striped"" Value=""16"" />
        <Member Name=""SolidRed"" Value=""9"" />
        <Member Name=""SolidBlue"" Value=""10"" />
        <Member Name=""SolidYellow"" Value=""12"" />
        <Member Name=""RedBlueStriped"" Value=""19"" />
        <Member Name=""RedYellowStriped"" Value=""21"" />
        <Member Name=""BlueYellowStriped"" Value=""22"" />
      </EnumType>
      <EnumType Name=""NonFlagShape"" UnderlyingType=""Edm.SByte"">
        <Member Name=""Rectangle"" Value=""1"" />
        <Member Name=""Triangle"" Value=""2"" />
        <Member Name=""foursquare"" Value=""3"" />
      </EnumType>
      <EntityType Name=""Lion"">
        <Key>
          <PropertyRef Name=""ID1"" />
          <PropertyRef Name=""ID2"" />
        </Key>
        <Property Name=""ID1"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""ID2"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""AngerLevel"" Type=""Edm.Double"" />
        <Property Name=""AttackDates"" Type=""Collection(Edm.DateTimeOffset)"" />
        <Property Name=""LionHeartbeat"" Type=""Fully.Qualified.Namespace.Heartbeat"" />
        <NavigationProperty Name=""DogThatIAte"" Type=""Fully.Qualified.Namespace.Dog"" Nullable=""false"" Partner=""LionWhoAteMe"">
          <ReferentialConstraint Property=""ID1"" ReferencedProperty=""ID"" />
        </NavigationProperty>
        <NavigationProperty Name=""DogsSeenMe"" Type=""Collection(Fully.Qualified.Namespace.Dog)"" Nullable=""false"" Partner=""LionsISaw"">
          <ReferentialConstraint Property=""ID1"" ReferencedProperty=""ID"" />
        </NavigationProperty>
        <NavigationProperty Name=""Friends"" Type=""Collection(Fully.Qualified.Namespace.Lion)"" Nullable=""false"">
          <ReferentialConstraint Property=""ID2"" ReferencedProperty=""ID1"" />
        </NavigationProperty>
      </EntityType>
      <EntityType Name=""Person"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""SSN"" Type=""Edm.String"" />
        <Property Name=""Shoe"" Type=""Edm.String"" />
        <Property Name=""Geography"" Type=""Edm.Geography"" SRID=""4326"" />
        <Property Name=""GeographyPoint"" Type=""Edm.GeographyPoint"" SRID=""4326"" />
        <Property Name=""GeographyLineString"" Type=""Edm.GeographyLineString"" SRID=""4326"" />
        <Property Name=""GeographyPolygon"" Type=""Edm.GeographyPolygon"" SRID=""4326"" />
        <Property Name=""GeometryPoint"" Type=""Edm.GeometryPoint"" SRID=""0"" />
        <Property Name=""GeometryLineString"" Type=""Edm.GeometryLineString"" SRID=""0"" />
        <Property Name=""GeometryPolygon"" Type=""Edm.GeometryPolygon"" SRID=""0"" />
        <Property Name=""GeographyCollection"" Type=""Collection(Edm.GeographyPoint)"" SRID=""4326"" />
        <Property Name=""GeographyParentCollection"" Type=""Collection(Edm.Geography)"" SRID=""0"" />
        <Property Name=""GeometryCollection"" Type=""Collection(Edm.GeometryPoint)"" SRID=""0"" />
        <Property Name=""Name"" Type=""Edm.String"" />
        <Property Name=""FirstName"" Type=""Fully.Qualified.Namespace.NameType"" />
        <Property Name=""Prop.With.Periods"" Type=""Edm.String"" />
        <Property Name=""MyDate"" Type=""Edm.Date"" Nullable=""false"" />
        <Property Name=""MyDates"" Type=""Collection(Edm.Date)"" />
        <Property Name=""MyTimeOfDay"" Type=""Edm.TimeOfDay"" Nullable=""false"" />
        <Property Name=""MyTimeOfDays"" Type=""Collection(Edm.TimeOfDay)"" />
        <Property Name=""Birthdate"" Type=""Edm.DateTimeOffset"" Nullable=""false"" />
        <Property Name=""FavoriteDate"" Type=""Edm.DateTimeOffset"" />
        <Property Name=""TimeEmployed"" Type=""Edm.Duration"" />
        <Property Name=""MyAddress"" Type=""Fully.Qualified.Namespace.Address"" />
        <Property Name=""MyOpenAddress"" Type=""Fully.Qualified.Namespace.OpenAddress"" />
        <Property Name=""PreviousAddresses"" Type=""Collection(Fully.Qualified.Namespace.Address)"" />
        <Property Name=""FavoriteColors"" Type=""Collection(Fully.Qualified.Namespace.ColorPattern)"" />
        <Property Name=""FavoriteNumber"" Type=""Fully.Qualified.Namespace.UInt16"" />
        <Property Name=""RelatedIDs"" Type=""Collection(Edm.Int32)"" Nullable=""false"" />
        <Property Name=""RelatedSSNs"" Type=""Collection(Edm.String)"" Nullable=""true"" />
        <Property Name=""StockQuantity"" Type=""Fully.Qualified.Namespace.UInt32"" />
        <Property Name=""LifeTime"" Type=""Fully.Qualified.Namespace.UInt64"" />
        <Property Name=""MyGuid"" Type=""Edm.Guid"" />
        <NavigationProperty Name=""MyDog"" Type=""Fully.Qualified.Namespace.Dog"" />
        <NavigationProperty Name=""MyFriendsDogs"" Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
        <NavigationProperty Name=""MyPaintings"" Type=""Collection(Fully.Qualified.Namespace.Painting)"" />
        <NavigationProperty Name=""MyFavoritePainting"" Type=""Fully.Qualified.Namespace.Painting"" />
        <NavigationProperty Name=""MyLions"" Type=""Collection(Fully.Qualified.Namespace.Lion)"">
          <ReferentialConstraint Property=""ID"" ReferencedProperty=""ID1"" />
        </NavigationProperty>
        <NavigationProperty Name=""MyContainedDog"" Type=""Fully.Qualified.Namespace.Dog"" ContainsTarget=""true"" />
        <NavigationProperty Name=""MyContainedChimeras"" Type=""Collection(Fully.Qualified.Namespace.Chimera)"" ContainsTarget=""true"" />
        <NavigationProperty Name=""MyPet2Set"" Type=""Collection(Fully.Qualified.Namespace.Pet2)"" />
        <Annotation Term=""OData.Community.Keys.V1.AlternateKeys"">
          <Collection>
            <Record Type=""OData.Community.Keys.V1.AlternateKey"">
              <PropertyValue Property=""Key"">
                <Collection>
                  <Record Type=""OData.Community.Keys.V1.PropertyRef"">
                    <PropertyValue Property=""Alias"" String=""SocialSN"" />
                    <PropertyValue Property=""Name"" PropertyPath=""SSN"" />
                  </Record>
                </Collection>
              </PropertyValue>
            </Record>
            <Record Type=""OData.Community.Keys.V1.AlternateKey"">
              <PropertyValue Property=""Key"">
                <Collection>
                  <Record Type=""OData.Community.Keys.V1.PropertyRef"">
                    <PropertyValue Property=""Alias"" String=""NameAlias"" />
                    <PropertyValue Property=""Name"" PropertyPath=""Name"" />
                  </Record>
                  <Record Type=""OData.Community.Keys.V1.PropertyRef"">
                    <PropertyValue Property=""Alias"" String=""FirstNameAlias"" />
                    <PropertyValue Property=""Name"" PropertyPath=""FirstName"" />
                  </Record>
                </Collection>
              </PropertyValue>
            </Record>
          </Collection>
        </Annotation>
      </EntityType>
      <EntityType Name=""Employee"" BaseType=""Fully.Qualified.Namespace.Person"">
        <Property Name=""WorkEmail"" Type=""Edm.String"" />
        <NavigationProperty Name=""PaintingsInOffice"" Type=""Collection(Fully.Qualified.Namespace.Painting)"" />
        <NavigationProperty Name=""Manager"" Type=""Fully.Qualified.Namespace.Manager"" />
        <NavigationProperty Name=""OfficeDog"" Type=""Fully.Qualified.Namespace.Dog"" Nullable=""false"" Partner=""EmployeeOwner"" />
      </EntityType>
      <EntityType Name=""Manager"" BaseType=""Fully.Qualified.Namespace.Employee"">
        <Property Name=""NumberOfReports"" Type=""Edm.Int32"" />
        <NavigationProperty Name=""DirectReports"" Type=""Collection(Fully.Qualified.Namespace.Employee)"" />
      </EntityType>
      <EntityType Name=""OpenEmployee"" BaseType=""Fully.Qualified.Namespace.Employee"" OpenType=""true"" />
      <EntityType Name=""Dog"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
        <Property Name=""Nicknames"" Type=""Collection(Edm.String)"" />
        <Property Name=""Breed"" Type=""Edm.String"" />
        <Property Name=""NamedStream"" Type=""Edm.Stream"" />
        <Property Name=""Weight"" Type=""Edm.Double"" />
        <NavigationProperty Name=""EmployeeOwner"" Type=""Fully.Qualified.Namespace.Employee"" Nullable=""false"" Partner=""OfficeDog"" />
        <NavigationProperty Name=""MyPeople"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <NavigationProperty Name=""FastestOwner"" Type=""Fully.Qualified.Namespace.Person"" />
        <NavigationProperty Name=""LionWhoAteMe"" Type=""Fully.Qualified.Namespace.Lion"" Nullable=""false"" Partner=""DogThatIAte"" />
        <NavigationProperty Name=""LionsISaw"" Type=""Collection(Fully.Qualified.Namespace.Lion)"" Nullable=""false"" Partner=""DogsSeenMe"" />
      </EntityType>
      <EntityType Name=""Shape"">
        <Key>
          <PropertyRef Name=""Color"" />
        </Key>
        <Property Name=""Color"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""false"" />
      </EntityType>
      <ComplexType Name=""Heartbeat"">
        <Property Name=""Frequency"" Type=""Edm.Double"" />
      </ComplexType>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            #endregion

            #region sub model xml2
            internal static string SubModelXml2 = @"
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:DataServices>
    <Schema Namespace=""Fully.Qualified.Namespace"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"" Alias=""SubAlias2"">
      <TypeDefinition Name=""IdType"" UnderlyingType=""Edm.Double"" />
      <TypeDefinition Name=""NameType"" UnderlyingType=""Edm.String"" />
      <TypeDefinition Name=""UInt16"" UnderlyingType=""Edm.Int32"" />
      <TypeDefinition Name=""UInt32"" UnderlyingType=""Edm.Int64"" />
      <TypeDefinition Name=""UInt64"" UnderlyingType=""Edm.Decimal"" />
      <EntityType Name=""Chimera"" OpenType=""true"">
        <Key>
          <PropertyRef Name=""Rid"" />
          <PropertyRef Name=""Gid"" />
          <PropertyRef Name=""Name"" />
          <PropertyRef Name=""Upgraded"" />
        </Key>
        <Property Name=""Rid"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""Gid"" Type=""Edm.Guid"" />
        <Property Name=""Name"" Type=""Edm.String"" />
        <Property Name=""Upgraded"" Type=""Edm.Boolean"" />
        <Property Name=""Level"" Type=""Edm.Int32"" />
      </EntityType>
      <EntityType Name=""Painting"" OpenType=""true"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""Artist"" Type=""Edm.String"" />
        <Property Name=""ArtistAddress"" Type=""Fully.Qualified.Namespace.Address"" />
        <Property Name=""Value"" Type=""Edm.Decimal"" />
        <Property Name=""Colors"" Type=""Collection(Edm.String)"" />
        <NavigationProperty Name=""Owner"" Type=""Fully.Qualified.Namespace.Person"" />
      </EntityType>
      <EntityType Name=""FramedPainting"" BaseType=""Fully.Qualified.Namespace.Painting"" OpenType=""true"">
        <Property Name=""FrameColor"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""UserAccount"">
        <Key>
          <PropertyRef Name=""UserName"" />
        </Key>
        <Property Name=""UserName"" Type=""Edm.String"" />
      </EntityType>
      <ComplexType Name=""Address"">
        <Property Name=""Street"" Type=""Edm.String"" />
        <Property Name=""City"" Type=""Edm.String"" />
        <Property Name=""NextHome"" Type=""Fully.Qualified.Namespace.Address"" />
        <Property Name=""MyNeighbors"" Type=""Collection(Edm.String)"" />
        <NavigationProperty Name=""PostBoxPainting"" Type=""Fully.Qualified.Namespace.Painting"" />
      </ComplexType>
      <ComplexType Name=""HomeAddress"" BaseType=""Fully.Qualified.Namespace.Address"">
        <Property Name=""HomeNO"" Type=""Edm.String"" />
      </ComplexType>
      <ComplexType Name=""OpenAddress"" OpenType=""true"" />
      <EntityType Name=""Pet1"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Int64"" Nullable=""false"" />
        <Property Name=""SingleID"" Type=""Edm.Single"" Nullable=""false"" />
        <Property Name=""DoubleID"" Type=""Edm.Double"" Nullable=""false"" />
        <Property Name=""DecimalID"" Type=""Edm.Decimal"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""Pet2"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Single"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
        <Property Name=""PetColorPattern"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""false"" />
        <Property Name=""Shape"" Type=""Fully.Qualified.Namespace.NonFlagShape"" Nullable=""false"" />
      </EntityType>
      <EntityType Name=""Pet3"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Double"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""Pet4"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Decimal"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""Pet5"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Boolean"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""Pet6"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Fully.Qualified.Namespace.IdType"" Nullable=""false"" />
        <Property Name=""Color"" Type=""Edm.String"" />
      </EntityType>
      <EntityType Name=""PetCategory"">
        <Key>
          <PropertyRef Name=""PetCategorysColorPattern"" />
        </Key>
        <Property Name=""Name"" Type=""Edm.String"" />
        <Property Name=""PetCategorysColorPattern"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""false"" />
      </EntityType>
      <EntityType Name=""Film"">
        <Key>
          <PropertyRef Name=""ID"" />
        </Key>
        <Property Name=""ID"" Type=""Edm.Int32"" Nullable=""false"" />
        <Property Name=""Title"" Type=""Edm.String"" />
      </EntityType>
      <Function Name=""GetPersonByDate"" IsComposable=""true"">
        <Parameter Name=""date"" Type=""Edm.Date"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetPersonByDTO"" IsComposable=""true"">
        <Parameter Name=""dto"" Type=""Edm.DateTimeOffset"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetPet1"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Int64"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet1"" />
      </Function>
      <Function Name=""GetPet2"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Single"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet2"" />
      </Function>
      <Function Name=""GetPet3"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Double"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet3"" />
      </Function>
      <Function Name=""GetPet4"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Decimal"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet4"" />
      </Function>
      <Function Name=""GetPet5"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Boolean"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet5"" />
      </Function>
      <Function Name=""GetPet6"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Fully.Qualified.Namespace.IdType"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet6"" />
      </Function>
      <Function Name=""GetRating"">
        <Parameter Name=""film"" Type=""Fully.Qualified.Namespace.Film"" />
        <ReturnType Type=""Edm.Int32"" Nullable=""false"" />
      </Function>
      <Function Name=""GetRatings"">
        <Parameter Name=""films"" Type=""Collection(Fully.Qualified.Namespace.Film)"" />
        <ReturnType Type=""Collection(Edm.Int32)"" Nullable=""false"" />
      </Function>
      <Term Name=""PrimitiveTerm"" Type=""Edm.String""/>
      <Term Name=""ComplexTerm"" Type=""Fully.Qualified.Namespace.Address""/>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            #endregion

            #region sub model xml3
            internal static string SubModelXml3 = @"
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:DataServices>
    <Schema Namespace=""Fully.Qualified.Namespace"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"" Alias=""SubAlias3"">

      <Function Name=""GetPetCountNullable"" IsComposable=""true"">
        <Parameter Name=""colorPattern"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""true"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet5"" />
      </Function>
      <Function Name=""GetPetCount"" IsComposable=""true"">
        <Parameter Name=""colorPattern"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""false"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet5"" />
      </Function>
      <Function Name=""TryGetPetCount"" IsComposable=""true"">
        <Parameter Name=""colorPattern"" Type=""Fully.Qualified.Namespace.ColorPattern"" Nullable=""true"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Pet5"" />
      </Function>
      <Action Name=""Walk"" IsBound=""true"">
        <Parameter Name=""dog"" Type=""Fully.Qualified.Namespace.Dog"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Address"" />
      </Action>
      <Function Name=""FindMyOwner"">
        <Parameter Name=""dogsName"" Type=""Edm.String"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""HasHat"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""HasHat"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""onCat"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Edm.Int32"" />
      </Function>
      <Function Name=""HasJob"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""AllHaveDog"" IsBound=""true"">
        <Parameter Name=""people"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""AllHaveDog"" IsBound=""true"">
        <Parameter Name=""people"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <Parameter Name=""inOffice"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""GetPeopleWhoHaveDogs"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""people"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Person)"" />
      </Function>
      <Function Name=""GetPersonWhoHasSmartestDog"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""people"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Action Name=""AdoptShibaInu"" IsBound=""true"">
        <Parameter Name=""people"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <Action Name=""SummonPuppies"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
      </Action>
      <Action Name=""FireAll"" IsBound=""true"">
        <Parameter Name=""employees"" Type=""Collection(Fully.Qualified.Namespace.Person)"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <Function Name=""HasDog"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""HasDog"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""inOffice"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""HasDog"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""inOffice"" Type=""Edm.Boolean"" />
        <Parameter Name=""name"" Type=""Edm.String"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""HasDog"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Employee"" />
        <Parameter Name=""inOffice"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""GetMyDog"" IsBound=""true"" EntitySetPath=""person/MyDog"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Dog"" />
      </Function>
      <Function Name=""AllMyFriendsDogs"" IsBound=""true"" EntitySetPath=""person/MyFriendsDogs"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
      </Function>
      <Function Name=""AllMyFriendsDogsNonComposable"" IsBound=""true"" EntitySetPath=""person/MyFriendsDogs"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
      </Function>
      <Function Name=""AllMyFriendsDogs"" IsBound=""true"" EntitySetPath=""person/MyFriendsDogs"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""inOffice"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
      </Function>
      <Function Name=""AllMyFriendsDogs_NoSet"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
      </Function>
      <Function Name=""OwnerOfFastestDog"" IsBound=""true"" EntitySetPath=""dogs/FastestOwner"" IsComposable=""true"">
        <Parameter Name=""dogs"" Type=""Collection(Fully.Qualified.Namespace.Dog)"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""OwnsTheseDogs"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""dogNames"" Type=""Collection(Edm.String)"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsInTheUS"" IsBound=""true"">
        <Parameter Name=""address"" Type=""Fully.Qualified.Namespace.Address"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""CanMoveToAddress"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""address"" Type=""Fully.Qualified.Namespace.Address"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsAddressGood"">
        <Parameter Name=""address"" Type=""Fully.Qualified.Namespace.Address"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""CanMoveToAddresses"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""addresses"" Type=""Collection(Fully.Qualified.Namespace.Address)"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsOlderThanByte"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""age"" Type=""Edm.Byte"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsOlderThanSByte"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""age"" Type=""Edm.SByte"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsOlderThanShort"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""age"" Type=""Edm.Int16"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Function Name=""IsOlderThanSingle"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""age"" Type=""Edm.Single"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Function>
      <Action Name=""Paint"" IsBound=""true"" EntitySetPath=""person/MyPaintings"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Painting"" />
      </Action>
      <Action Name=""Move"" IsBound=""true"">
        <Parameter Name=""employee"" Type=""Fully.Qualified.Namespace.Employee"" />
        <Parameter Name=""building"" Type=""Edm.Int32"" />
        <Parameter Name=""room"" Type=""Edm.Int32"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            #endregion

            #region sub model xml4
            internal static string SubModelXml4 = @"
<edmx:Edmx Version=""4.0"" xmlns:edmx=""http://docs.oasis-open.org/odata/ns/edmx"">
  <edmx:DataServices>
    <Schema Namespace=""Fully.Qualified.Namespace"" xmlns=""http://docs.oasis-open.org/odata/ns/edm"" Alias=""SubAlias4"">

      <Action Name=""Restore"" IsBound=""true"">
        <Parameter Name=""painting"" Type=""Fully.Qualified.Namespace.Painting"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <Action Name=""ChangeState"" IsBound=""true"">
        <Parameter Name=""address"" Type=""Fully.Qualified.Namespace.Address"" />
        <Parameter Name=""newState"" Type=""Edm.String"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <Function Name=""GetMyPerson"" IsBound=""true"">
        <Parameter Name=""dog"" Type=""Fully.Qualified.Namespace.Dog"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Action Name=""Move"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""streetAddress"" Type=""Edm.String"" />
        <ReturnType Type=""Edm.Boolean"" />
      </Action>
      <Function Name=""GetCoolPeople"" IsComposable=""true"">
        <Parameter Name=""id"" Type=""Edm.Int32"" />
        <Parameter Name=""limit"" Type=""Edm.Int32"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Person)"" />
      </Function>
      <Function Name=""GetHotPeople"" IsBound=""true"" EntitySetPath=""person"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""limit"" Type=""Edm.Int32"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Person)"" />
      </Function>
      <Function Name=""GetCoolestPerson"" IsComposable=""true"">
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetCoolestPersonWithStyle"" IsComposable=""true"">
        <Parameter Name=""styleID"" Type=""Edm.Int32"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetBestManager"" IsComposable=""true"">
        <ReturnType Type=""Fully.Qualified.Namespace.Manager"" />
      </Function>
      <Action Name=""GetNothing"" />
      <Function Name=""GetSomeNumber"" IsComposable=""true"">
        <ReturnType Type=""Edm.Int32"" />
      </Function>
      <Function Name=""GetSomeAddress"" IsComposable=""true"">
        <ReturnType Type=""Fully.Qualified.Namespace.Address"" />
      </Function>
      <Function Name=""GetSomeAddressFromPerson"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Address"" />
      </Function>
      <Function Name=""GetSomeNumbers"" IsComposable=""true"">
        <ReturnType Type=""Collection(Edm.Int32)"" />
      </Function>
      <Function Name=""GetSomeColors"" IsComposable=""true"">
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.ColorPattern)"" />
      </Function>
      <Function Name=""GetSomeColor"" IsComposable=""true"">
        <ReturnType Type=""Fully.Qualified.Namespace.ColorPattern"" />
      </Function>
      <Function Name=""GetSomeAddresses"" IsComposable=""true"">
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Address)"" />
      </Function>
      <Action Name=""ResetAllData"" />
      <Function Name=""GetMostImporantPerson"">
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetMostImporantPerson"">
        <Parameter Name=""city"" Type=""Edm.String"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Person"" />
      </Function>
      <Function Name=""GetPriorNumbers"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Edm.Int32)"" />
      </Function>
      <Function Name=""GetPriorAddresses"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Address)"" />
      </Function>
      <Function Name=""GetPriorAddress"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Fully.Qualified.Namespace.Address"" />
      </Function>
      <Function Name=""GetFavoriteColors"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.ColorPattern)"" />
      </Function>
      <Function Name=""GetFavoriteColor"" IsBound=""true"" IsComposable=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <ReturnType Type=""Fully.Qualified.Namespace.ColorPattern"" />
      </Function>
      <Function Name=""GetNearbyPriorAddresses"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""currentLocation"" Type=""Edm.GeographyPoint"" SRID=""4326"" />
        <Parameter Name=""limit"" Type=""Edm.Int32"" />
        <ReturnType Type=""Collection(Fully.Qualified.Namespace.Address)"" />
      </Function>
      <Function Name=""GetColorAtPosition"" IsBound=""true"">
        <Parameter Name=""painting"" Type=""Fully.Qualified.Namespace.Painting"" />
        <Parameter Name=""position"" Type=""Edm.GeometryPoint"" SRID=""0"" />
        <Parameter Name=""includeAlpha"" Type=""Edm.Boolean"" />
        <ReturnType Type=""Edm.String"" />
      </Function>
      <Function Name=""GetFullName"" IsBound=""true"">
        <Parameter Name=""person"" Type=""Fully.Qualified.Namespace.Person"" />
        <Parameter Name=""nickname"" Type=""Fully.Qualified.Namespace.NameType"" />
        <ReturnType Type=""Fully.Qualified.Namespace.NameType"" />
      </Function>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>";
            #endregion
        }

        public static ODataUri ParseUri(string input, IEdmModel model, int? maxDepth = null)
        {
            var serviceBaseUri = new Uri("http://server/service/");
            var queryUri = new Uri(serviceBaseUri, input);
            ODataUriParser parser = new ODataUriParser(model, serviceBaseUri, queryUri);
            if (maxDepth.HasValue)
            {
                parser.Settings.FilterLimit = maxDepth.Value;
                return parser.ParseUri();
            }
            else
            {
                return parser.ParseUri();
            }
        }

        public static IEdmEntityType GetPet1Type()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Pet1") as IEdmEntityType;
        }

        public static IEdmEntityType GetPet2Type()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Pet2") as IEdmEntityType;
        }

        public static IEdmEntityType GetPet3Type()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Pet3") as IEdmEntityType;
        }

        public static IEdmEntityType GetPet4Type()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Pet4") as IEdmEntityType;
        }

        public static IEdmEntityType GetPet5Type()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Pet5") as IEdmEntityType;
        }

        public static IEdmEntitySet GetPet1Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet1Set");
        }

        public static IEdmEntitySet GetPet2Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet2Set");
        }

        public static IEdmEntitySet GetPet3Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet3Set");
        }

        public static IEdmEntitySet GetPet4Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet4Set");
        }

        public static IEdmEntitySet GetPet5Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet5Set");
        }

        public static IEdmEntitySet GetPet6Set()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Pet6Set");
        }

        public static IEdmEntitySet GetPeopleSet()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("People");
        }

        public static IEdmContainedEntitySet GetContainedDogEntitySet()
        {
            IEdmEntitySet peopleSet = GetPeopleSet();
            IEdmNavigationProperty containedDogProp = GetPersonMyContainedDogNavProp();
            return peopleSet.FindNavigationTarget(containedDogProp) as IEdmContainedEntitySet;
        }

        public static IEdmEntitySet GetLionSet()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Lions");
        }

        public static IEdmEntitySet GetDogsSet()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Dogs");
        }

        public static IEdmEntitySet GetPaintingsSet()
        {
            return TestModel.FindEntityContainer("Context").FindEntitySet("Paintings");
        }

        public static IEdmSingleton GetBossSingleton()
        {
            return TestModel.FindEntityContainer("Context").FindSingleton("Boss");
        }

        public static IEdmEntityType GetLionType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Lion") as IEdmEntityType;
        }

        /// <summary>
        /// Gets a type reference to a lion. We use 'false' for nullable because that is the value the product should set
        /// it to when we have to create a reference (like for the item type of the collection you are filtering or something).
        /// </summary>
        public static IEdmEntityTypeReference GetLionTypeReference()
        {
            return new EdmEntityTypeReference(GetLionType(), false);
        }

        public static IEdmEntityType GetPersonType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Person") as IEdmEntityType;
        }

        /// <summary>
        /// Gets a type reference to a person. We use 'false' for nullable because that is the value the product should set
        /// it to when we have to create a reference (like for the item type of the collection you are filtering or something).
        /// </summary>
        public static IEdmEntityTypeReference GetPersonTypeReference()
        {
            return new EdmEntityTypeReference(GetPersonType(), false);
        }

        /// <summary>
        /// Gets a type reference to an employee. We use 'false' for nullable because that is the value the product should set
        /// it to when we have to create a reference (like for the item type of the collection you are filtering or something).
        /// </summary>
        public static IEdmEntityTypeReference GetEmployeeTypeReference()
        {
            return new EdmEntityTypeReference(GetEmployeeType(), false);
        }

        public static IEdmEntityType GetEmployeeType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Employee") as IEdmEntityType;
        }

        public static IEdmEntityType GetOpenEmployeeType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.OpenEmployee") as IEdmEntityType;
        }

        public static IEdmEntityTypeReference GetManagerTypeReference()
        {
            return new EdmEntityTypeReference(GetManagerType(), false);
        }

        public static IEdmEntityType GetManagerType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Manager") as IEdmEntityType;
        }

        public static IEdmEntityType GetDogType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Dog") as IEdmEntityType;
        }

        /// <summary>
        /// Gets a type reference to a dog. We use 'false' for nullable because that is the value the product should set
        /// it to when we have to create a reference (like for the item type of the collection you are filtering or something).
        /// </summary>
        public static IEdmEntityTypeReference GetDogTypeReference()
        {
            return new EdmEntityTypeReference(GetDogType(), false);
        }

        public static IEdmEntityType GetPaintingType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Painting") as IEdmEntityType;
        }

        public static IEdmEntityType GetFramedPaintingType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.FramedPainting") as IEdmEntityType;
        }

        /// <summary>
        /// Gets a type reference to a painting. We use 'false' for nullable because that is the value the product should set
        /// it to when we have to create a reference (like for the item type of the collection you are filtering or something).
        /// </summary>
        public static IEdmEntityTypeReference GetPaintingTypeReference()
        {
            return new EdmEntityTypeReference(GetPaintingType(), false);
        }

        public static IEdmComplexType GetAddressType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Address") as IEdmComplexType;
        }

        public static IEdmComplexTypeReference GetAddressReference()
        {
            return new EdmComplexTypeReference(GetAddressType(), false);
        }

        public static IEdmComplexType GetHomeAddressType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.HomeAddress") as IEdmComplexType;
        }

        public static IEdmComplexTypeReference GetHomeAddressReference()
        {
            return new EdmComplexTypeReference(GetHomeAddressType(), false);
        }

        public static IEdmStructuralProperty GetPersonIdProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("ID");
        }

        public static IEdmNavigationProperty GetPersonMyAddressNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyAddress");
        }

        public static IEdmNavigationProperty GetPersonMyDogNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyDog");
        }

        public static IEdmNavigationProperty GetPersonMyContainedDogNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyContainedDog");
        }

        public static IEdmNavigationProperty GetPersonMyPet2SetNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyPet2Set");
        }

        public static IEdmNavigationProperty GetPersonMyLionsNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyLions");
        }

        public static IEdmNavigationProperty GetPersonMyPaintingsNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyPaintings");
        }

        public static IEdmNavigationProperty GetPersonMyFavoritePaintingNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyFavoritePainting");
        }

        public static IEdmStructuralProperty GetPersonShoeProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("Shoe");
        }

        public static IEdmStructuralProperty GetPersonNameProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("Name");
        }

        public static IEdmStructuralProperty GetPersonFirstNameProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("FirstName");
        }

        public static IEdmStructuralProperty GetPersonFavoriteDateProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("FavoriteDate");
        }

        public static IEdmStructuralProperty GetPersonMyDateProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyDate");
        }

        public static IEdmStructuralProperty GetPersonMyDatesProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyDates");
        }

        public static IEdmStructuralProperty GetPersonMyTimeOfDayProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyTimeOfDay");
        }

        public static IEdmStructuralProperty GetPersonMyTimeOfDaysProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyTimeOfDays");
        }

        public static IEdmStructuralProperty GetPersonBirthdateProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("Birthdate");
        }

        public static IEdmStructuralProperty GetPersonTimeEmployedProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("TimeEmployed");
        }

        public static IEdmStructuralProperty GetPersonPreviousAddressesProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("PreviousAddresses");
        }

        public static IEdmStructuralProperty GetPersonFavoriteColorsProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("FavoriteColors");
        }

        public static IEdmNavigationProperty GetPersonMyFriendsDogsProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyFriendsDogs");
        }

        public static IEdmStructuralProperty GetPersonAddressProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("MyAddress");
        }

        public static IEdmStructuralProperty GetPersonGeographyProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("Geography");
        }

        public static IEdmStructuralProperty GetPersonGeographyPointProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeographyPoint");
        }

        public static IEdmStructuralProperty GetPersonGeographyLineStringProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeographyLineString");
        }

        public static IEdmStructuralProperty GetPersonGeographyPolygonProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeographyPolygon");
        }

        public static IEdmStructuralProperty GetPersonGeometryPointProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeometryPoint");
        }

        public static IEdmStructuralProperty GetPersonGeometryLineStringProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeometryLineString");
        }

        public static IEdmStructuralProperty GetPersonGeometryPolygonProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeometryPolygon");
        }

        public static IEdmStructuralProperty GetPersonGeographyCollectionProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeographyCollection");
        }

        public static IEdmStructuralProperty GetPersonGeographyParentCollectionProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeographyParentCollection");
        }

        public static IEdmStructuralProperty GetEmployeeWorkEmailProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Employee")).FindProperty("WorkEmail");
        }

        public static IEdmNavigationProperty GetEmployeePaintingsInOfficeNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Employee")).FindProperty("PaintingsInOffice");
        }

        public static IEdmNavigationProperty GetEmployeeOfficeDogNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Employee")).FindProperty("OfficeDog");
        }

        public static IEdmStructuralProperty GetManagerNumberOfReportsProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Manager")).FindProperty("NumberOfReports");
        }

        public static IEdmStructuralProperty GetPersonGeometryCollectionProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Person")).FindProperty("GeometryCollection");
        }

        public static IEdmStructuralProperty GetLionAttackDatesProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Lion")).FindProperty("AttackDates");
        }

        public static IEdmStructuralProperty GetLionId1Property()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Lion")).FindProperty("ID1");
        }

        public static IEdmStructuralProperty GetLionId2Property()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Lion")).FindProperty("ID2");
        }

        public static IEdmStructuralProperty GetAddressCityProperty()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Address")).FindProperty("City");
        }

        public static IEdmStructuralProperty GetPet2PetColorPatternProperty()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Pet2")).FindProperty("PetColorPattern");
        }

        public static IEdmStructuralProperty GetAddressMyNeighborsProperty()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Address")).FindProperty("MyNeighbors");
        }

        // ToDo: Don't support NavProps in Complex types yet
        // ToDo: When the work is done to allow Nav props in complex types make sure we can select and expand them
        public static IEdmNavigationProperty GetAddressMyFavoriteNeighborNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Address")).FindProperty("MyFavoriteNeighbor");
        }

        public static IEdmNavigationProperty GetDogFastestOwnerNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("FastestOwner");
        }

        public static IEdmNavigationProperty GetDogMyPeopleNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("MyPeople");
        }

        public static IEdmNavigationProperty GetDogLionWhoAteMeNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("LionWhoAteMe");
        }

        public static IEdmStructuralProperty GetDogNicknamesProperty()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("Nicknames");
        }

        public static IEdmFunction GetHasDogOverloadWithOneParameter()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.Count() == 1) as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForEmployeeHasDogWithTwoParameters()
        {
            return TestModel.EntityContainer.FindOperationImports("HasDog").Single(f => f.Operation.Parameters.Count() == 2 && f.Operation.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmOperation GetFunctionForEmployeeHasDogWithTwoParameters()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.Count() == 2 && f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmFunction GetHasDogOverloadForPeopleWithTwoParameters()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.Count() == 2 && f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person") as IEdmFunction;
        }

        public static IEdmOperationImport GetHasDogOverloadImportForPeopleWithThreeParameters()
        {
            return TestModel.EntityContainer.FindOperationImports("HasDog").Single(f => f.Operation.Parameters.Count() == 3 && f.Operation.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person");
        }

        public static IEdmOperation GetHasDogOverloadForPeopleWithThreeParameters()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.Count() == 3 && f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person");
        }

        public static IEdmOperationImport GetFunctionImportForGetPersonByDate()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPersonByDate").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPersonByDTO()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPersonByDTO").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet1()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet1").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet2()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet2").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet3()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet3").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet4()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet4").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet5()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet5").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPet6()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPet6").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPetCount()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPetCount").Single();
        }

        public static IEdmFunction GetFunctionForHasJob()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasJob").OfType<IEdmFunction>().Single();
        }

        public static IEdmOperationImport GetFunctionImportForAllHaveDogWithOneParameter()
        {
            return TestModel.EntityContainer.FindOperationImports("AllHaveDog").Single(f => f.Operation.Parameters.Count() == 1);
        }

        public static IEdmFunction GetFunctionForAllHaveDogWithOneParameter()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.AllHaveDog").Single(f => f.Parameters.Count() == 1) as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForAllHaveDogWithTwoParameters()
        {
            return TestModel.EntityContainer.FindOperationImports("AllHaveDog").Single(f => f.Operation.Parameters.Count() == 2);
        }

        public static IEdmFunction GetFunctionForAllHaveDogWithTwoParameters()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.AllHaveDog").Single(f => f.Parameters.Count() == 2) as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForGetPeopleWhoHaveDogs()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPeopleWhoHaveDogs").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetPersonWhoHasSmartestDog()
        {
            return TestModel.EntityContainer.FindOperationImports("GetPersonWhoHasSmartestDog").Single();
        }

        public static IEdmOperationImport GetAdoptShibaInuActionImport()
        {
            return TestModel.EntityContainer.FindOperationImports("AdoptShibaInu").Single();
        }

        public static IEdmOperationImport GetSummonPuppiesActionImport()
        {
            return TestModel.EntityContainer.FindOperationImports("SummonPuppies").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetCoolestPerson()
        {
            return TestModel.EntityContainer.FindOperationImports("GetCoolestPerson").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetCoolPeople()
        {
            return TestModel.EntityContainer.FindOperationImports("GetCoolPeople").Single();
        }

        public static IEdmOperation GetFunctionForGetHotPeople()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetHotPeople").Single();
        }

        public static IEdmOperation GetFunctionForGetCoolPeople()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetCoolPeople").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetBestManager()
        {
            return TestModel.EntityContainer.FindOperationImports("GetBestManager").Single();
        }

        public static IEdmOperationImport GetFunctionImportForResetAllData()
        {
            return TestModel.EntityContainer.FindOperationImports("ResetAllData").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetMyDog()
        {
            return TestModel.EntityContainer.FindOperationImports("GetMyDog").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetSomeNumbers()
        {
            return TestModel.EntityContainer.FindOperationImports("GetSomeNumbers").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetSomeAddresses()
        {
            return TestModel.EntityContainer.FindOperationImports("GetSomeAddresses").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetSomeColors()
        {
            return TestModel.EntityContainer.FindOperationImports("GetSomeColors").Single();
        }

        public static IEdmFunction GetFunctionForGetPriorAddresses()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetPriorAddresses").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForGetPriorNumbers()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetPriorNumbers").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForGetFavoriteColors()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetFavoriteColors").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForGetMyDog()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetMyDog").Single() as IEdmFunction;
        }

        public static IEdmFunctionImport GetFunctionImportIsAddressGood()
        {
            return TestModel.EntityContainer.FindOperationImports("IsAddressGood").Single() as IEdmFunctionImport;
        }

        public static IEdmFunction GetFunctionForAllMyFriendsDogs()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.AllMyFriendsDogs").Single(f => f.Parameters.Count() == 1) as IEdmFunction;
        }

        public static IEdmOperationImport[] GetAllFunctionImportsForGetMostImportantPerson()
        {
            return TestModel.EntityContainer.FindOperationImports("GetMostImporantPerson").ToArray();
        }

        public static IEdmFunction GetFunctionForCanMoveToAddress()
        {
            var functions = TestModel.FindOperations("Fully.Qualified.Namespace.CanMoveToAddress").OfType<IEdmFunction>().ToList();
            return functions.First();
        }

        public static IEdmOperationImport GetFunctionImportForCanMoveToAddresses()
        {
            return TestModel.EntityContainer.FindOperationImports("CanMoveToAddresses").Single();
        }

        public static IEdmFunction GetFunctionForCanMoveToAddresses()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.CanMoveToAddresses").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForIsOlderThanByte()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.IsOlderThanByte").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForIsOlderThanSByte()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.IsOlderThanSByte").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForIsOlderThanShort()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.IsOlderThanShort").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForIsOlderThanSingle()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.IsOlderThanSingle").Single() as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForOwnsTheseDogs()
        {
            return TestModel.EntityContainer.FindOperationImports("OwnsTheseDogs").Single();
        }

        public static IEdmFunction GetFunctionForOwnsTheseDogs()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.OwnsTheseDogs").Single() as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForFindMyOwner()
        {
            return TestModel.EntityContainer.FindOperationImports("FindMyOwner").Single();
        }

        public static IEdmFunction GetFunctionForFindMyOwner()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.FindMyOwner").Single() as IEdmFunction;
        }

        public static IEdmOperationImport GetFunctionImportForIsInTheUs()
        {
            return TestModel.EntityContainer.FindOperationImports("IsInTheUS").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetMyPerson()
        {
            return TestModel.EntityContainer.FindOperationImports("GetMyPerson").Single();
        }

        public static IEdmFunction GetFunctionForGetMyPerson()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetMyPerson").Single() as IEdmFunction;
        }

        public static IEdmFunction GetFunctionForGetFullName()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetFullName").Single() as IEdmFunction;
        }

        public static IEdmStructuralProperty GetDogColorProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("Color");
        }

        public static IEdmStructuralProperty GetDogIdProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Dog")).FindProperty("ID");
        }

        public static IEdmStructuralProperty GetPaintingArtistProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Painting")).FindProperty("Artist");
        }

        public static IEdmStructuralProperty GetPaintingColorsProperty()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Painting")).FindProperty("Colors");
        }

        public static IEdmOperation GetDogWalkAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Walk").Single();
        }

        public static IEdmOperationImport GetDogWalkActionImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Walk").Single();
        }

        public static IEdmOperationImport GetFireAllActionImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("FireAll").Single();
        }

        public static IEdmOperation GetFireAllAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.FireAll").Single();
        }

        public static IEdmOperationImport[] GetAllHasDogOverloadImports()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("HasDog").ToArray();
        }

        public static IEdmOperation[] GetAllHasDogOverloads()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").ToArray();
        }

        public static IEdmOperation GetAllMyFriendsDogs_NoSet()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.AllMyFriendsDogs_NoSet").Single();
        }

        public static IEdmOperationImport GetHasDogOverloadForEmployeeImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("HasDog").Single(f => f.Operation.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmOperation GetHasDogOverloadForPeople()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person");
        }

        public static IEdmOperation GetHasDogOverloadForEmployee()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmOperationImport[] GetAllHasDogOverloadsForPeople()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("HasDog").Where(f => f.Operation.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person").ToArray();
        }

        public static IEdmFunction[] GetAllHasDogFunctionOverloadsForPeople()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Where(f => f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person").OfType<IEdmFunction>().ToArray();
        }

        public static IEdmOperationImport[] GetAllMoveOverloadImports()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Move").ToArray();
        }

        public static IEdmOperation[] GetAllMoveOverloads()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Move").ToArray();
        }

        public static IEdmOperationImport[] GetAllHasHatOverloads()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("HasHat").ToArray();
        }

        public static IEdmOperationImport GetMoveOverloadForEmployeeImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Move").Single(f => f.Operation.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmOperation GetMoveOverloadForPerson()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Move").Single(f => f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Person");
        }

        public static IEdmOperation GetMoveOverloadForEmployee()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Move").Single(f => f.Parameters.First().Type.FullName() == "Fully.Qualified.Namespace.Employee");
        }

        public static IEdmFunction GetColorAtPositionFunction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetColorAtPosition").Single() as IEdmFunction;
        }

        public static IEdmFunction GetNearbyPriorAddressesFunction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.GetNearbyPriorAddresses").Single() as IEdmFunction;
        }

        public static IEdmStructuralProperty GetAddressStreetProp()
        {
            return (IEdmStructuralProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Address")).FindProperty("Street");
        }

        public static IEdmOperationImport GetRestoreActionImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Restore").Single();
        }

        public static IEdmOperation GetRestoreAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Restore").Single();
        }

        public static IEdmOperationImport GetPersonPaintActionImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Paint").Single();
        }

        public static IEdmOperation GetPersonPaintAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Paint").Single();
        }

        public static IEdmNavigationProperty GetPaintingOwnerNavProp()
        {
            return (IEdmNavigationProperty)((IEdmStructuredType)TestModel.FindType("Fully.Qualified.Namespace.Painting")).FindProperty("Owner");
        }

        public static IEdmStructuralProperty GetPaintingValueProperty()
        {
            return (IEdmStructuralProperty)GetPaintingType().FindProperty("Value");
        }

        public static IEdmOperationImport GetFunctionImportForPaintingRestoreAction()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("Restore").Single();
        }

        public static IEdmStructuralProperty GetDogNamedStream()
        {
            return (IEdmStructuralProperty)GetDogType().FindProperty("NamedStream");
        }

        public static IEdmOperationImport GetVoidServiceOperation()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("GetNothing").Single();
        }

        public static IEdmOperation GetPersonMoveAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.Move").Where(a => a.Parameters.Count() == 2).Single();
        }

        public static IEdmOperationImport GetChangeStateActionImport()
        {
            return TestModel.FindEntityContainer("Context").FindOperationImports("ChangeState").Single();
        }

        public static IEdmOperation GetChangeStateAction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.ChangeState").Single();
        }

        public static IEdmFunction GetHasJobFunction()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasJob").Single() as IEdmFunction;
        }

        public static IEdmFunction GetHasDogOneParameterOverload()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").Single(f => f.Parameters.Count() == 1) as IEdmFunction;
        }

        public static IEdmFunction[] GetHasDogOverloads()
        {
            return TestModel.FindOperations("Fully.Qualified.Namespace.HasDog").OfType<IEdmFunction>().ToArray();
        }

        public static IEdmStructuralProperty GetPersonPropWithPeriods()
        {
            return (IEdmStructuralProperty)GetPersonType().FindProperty("Prop.With.Periods");
        }

        public static IEdmComplexType GetHeatbeatComplexType()
        {
            return TestModel.FindType("Fully.Qualified.Namespace.Heartbeat") as IEdmComplexType;
        }

        public static IEdmTerm GetPrimitiveAnnotationTerm()
        {
            return TestModel.FindTerm("Fully.Qualified.Namespace.PrimitiveTerm") as IEdmTerm;
        }

        public static IEdmTerm GetComplexAnnotationTerm()
        {
            return TestModel.FindTerm("Fully.Qualified.Namespace.ComplexTerm") as IEdmTerm;
        }

        public static IEdmOperationImport GetFunctionImportForGetRating()
        {
            return TestModel.EntityContainer.FindOperationImports("GetRating").Single();
        }

        public static IEdmOperationImport GetFunctionImportForGetRatings()
        {
            return TestModel.EntityContainer.FindOperationImports("GetRatings").Single();
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 30 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\test\PublicApiTests\PublicApiHelper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.OData.PublicApi.Tests
{
    internal static class PublicApiHelper
    {
        private static bool AlphabeticalGrouping = false;
        private static readonly List<Assembly> Assemblies = new List<Assembly>();

        private static Hashtable _synonms;
        public static Hashtable Synonms
        {
            get
            {
                if (_synonms == null)
                {
                    _synonms = CreateSynonms();
                }

                return _synonms;
            }
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params string[] assemblyNames)
        {
            IList<Assembly> assemblies = new List<Assembly>();
            for (int k = 0; k < assemblyNames.Length; ++k)
            {
                try
                {
                    Assembly assembly;
                    if (File.Exists(assemblyNames[k]))
                    {
                        assembly = Assembly.LoadFrom(assemblyNames[k]);
                    }
                    else
                    {
                        assembly = Assembly.Load(assemblyNames[k]);
                    }

                    assemblies.Add(assembly);
                }
                catch (Exception e)
                {
                    streamWriter.WriteLine(@"Error loading types from assembly '{0}':", assemblyNames[k]);
                    streamWriter.WriteLine(e.ToString());
                    Environment.Exit(1);
                }
            }

            DumpPublicApi(streamWriter, assemblies.ToArray());
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params Assembly[] assemblies)
        {
            Reset();

            if (assemblies.Length <= 0)
            {
                return;
            }

            ArrayList typesList = new ArrayList();
            foreach (var assembly in assemblies)
            {
                Assemblies.Add(assembly);
                typesList.AddRange(assembly.GetTypes());
            }

            typesList.Sort(TypeCompare.Default);
            DumpPublicApiImplementation(streamWriter, typesList);
        }

        private static Hashtable CreateSynonms()
        {
            Hashtable synonms = new Hashtable();

            synonms.Add("System.Void", "void");
            synonms.Add("System.Object", "object");
            synonms.Add("System.String", "string");
            synonms.Add("System.Int16", "short");
            synonms.Add("System.Int32", "int");
            synonms.Add("System.Int64", "long");
            synonms.Add("System.Byte", "byte");
            synonms.Add("System.Boolean", "bool");
            synonms.Add("System.Char", "char");
            synonms.Add("System.Decimal", "decimal");
            synonms.Add("System.Double", "double");
            synonms.Add("System.Single", "float");

            synonms.Add("System.Object[]", "object[]");
            synonms.Add("System.Char[]", "char[]");
            synonms.Add("System.Byte[]", "byte[]");
            synonms.Add("System.Int32[]", "int[]");
            synonms.Add("System.String[]", "string[]");

            return synonms;
        }

        private static void DumpPublicApiImplementation(StreamWriter streamWriter, ArrayList sortedTypeList)
        {
            StringBuilder builder = new StringBuilder();
            string lastNamespace = "";
            foreach (Type type in sortedTypeList)
            {
                builder.Length = 0;

                if (type.IsSpecialName)
                {
                    continue;
                }

                string typeFullName = type.FullName;
                if (typeFullName.StartsWith("<PrivateImplementationDetails>"))
                {
                    continue;
                }

                Type declaringType = type;
                while (null != declaringType)
                {
                    switch (TypeAttributes.VisibilityMask & declaringType.Attributes)
                    {
                        case TypeAttributes.Public:
                        case TypeAttributes.NestedPublic:
                        case TypeAttributes.NestedFamily:
                        case TypeAttributes.NestedFamANDAssem:
                        case TypeAttributes.NestedFamORAssem:
                            declaringType = declaringType.DeclaringType;
                            continue;
                        case TypeAttributes.NotPublic:
                        case TypeAttributes.NestedPrivate:
                        case TypeAttributes.NestedAssembly:
                            Debug.Assert(null != declaringType, "Null declaringType");
                            break;
                        default:
                            Debug.Assert(false, "Unknown type");
                            break;
                    }
                    break;
                }

                if (typeof(TypeConverter).IsAssignableFrom(type))
                {
                    ConstructorInfo ctor = type.GetConstructor(BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, EmptyTypes, EmptyParameterModifiers);
                    if (null != ctor)
                    {
                        streamWriter.WriteLine("{0}", type.FullName);
                    }
                    else
                    {
                        streamWriter.WriteLine("{0} missing public ctor", type.FullName);
                    }
                }

                if (null != declaringType)
                {
                    continue;
                }

                bool abort = AppendCustomAttributes(builder, type.GetCustomAttributes(false), false, type.IsEnum, true);
                if (abort)
                {
                    continue;
                }

                AppendClassDeclarationApi(builder, type);
                builder.Append(" {");
                builder.Append(Environment.NewLine);

                string currentNamespace = type.Namespace;
                if (lastNamespace != currentNamespace)
                {
                    lastNamespace = currentNamespace;
                }

                if (type.Name.Contains("UnmappedRequestRoutingConvention"))
                {
                    int kk = 0;
                    kk += 1;
                }
                AppendClassMemberApi(builder, type);
                if (builder.Length > 0)
                {
                    AssemblyFilter(builder);
                    streamWriter.Write(builder.ToString());
                    builder.Length = 0;
                }
                streamWriter.Write("}");
                streamWriter.Write(Environment.NewLine);
                streamWriter.Write(Environment.NewLine);
            }
        }

        private static void Reset()
        {
            _outputFilter = null;
            Assemblies.Clear();
        }

        private static String[] _outputFilter;
        private static void AssemblyFilter(StringBuilder builder)
        {
            string[] filter = _outputFilter;
            if (null == filter)
            {
                filter = new string[2 + Assemblies.Count];
                filter[0] = ", " + typeof(object).Assembly.ToString();
                filter[1] = ", " + typeof(Uri).Assembly.ToString();
                for (int i = 2; i < filter.Length; i++)
                {
                    filter[i] = ", " + Assemblies[i - 2].ToString();
                }
                _outputFilter = filter;
            }
            for (int i = 0; i < filter.Length; ++i)
            {
                builder.Replace(filter[i], "");
            }
        }

        private static void AppendClassDeclarationApi(StringBuilder builder, Type type)
        {
            if (type.IsPublic | type.IsNestedPublic)
            {
                builder.Append("public ");
            }
            else if (type.IsNestedFamily | type.IsNestedFamORAssem | type.IsNestedFamANDAssem)
            {
                builder.Append("protected ");
            }
            else
            {
                Debug.Assert(false, "non public or protected type");
            }

            if (type.IsInterface)
            {
                builder.Append("interface ");
            }
            else if (type.IsEnum)
            {
                builder.Append("enum ");
            }
            else if (type.IsValueType)
            {
                builder.Append("struct ");
            }
            else if (type.IsClass)
            {
                if (type.IsSealed)
                {
                    builder.Append("sealed ");
                }
                else if (type.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                builder.Append("class ");
            }
            else
            {
                builder.Append("? ");
            }
            builder.Append(type.FullName);

            bool haveColon = false;
            Type baseType = type.BaseType;
            if ((null != baseType) && (typeof(object) != baseType) && (typeof(ValueType) != baseType))
            {
                if (typeof(Enum) == baseType)
                {
                    baseType = Enum.GetUnderlyingType(type);
                }
                haveColon = true;
                builder.Append(" : ");
                AppendParameterType(builder, baseType);
            }

            if (!type.IsEnum)
            {
                Type[] baseInterfaces = type.GetInterfaces();
                Array.Sort(baseInterfaces, TypeCompare.Default);
                foreach (Type baseInterface in baseInterfaces)
                {
                    if (haveColon)
                    {
                        builder.Append(", ");
                    }
                    else
                    {
                        haveColon = true;
                        builder.Append(" : ");
                    }
                    builder.Append(baseInterface.Name);
                }
            }
        }

        private static void AppendClassMemberApi(StringBuilder builder, Type type)
        {
            MemberInfo[] members = type.GetMembers(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
            if (members.Length <= 0)
            {
                return;
            }

            Array.Sort(members, new MemberCompare(type));

            bool lastHadAttributes = false;
            MemberTypes lastMemberType = 0;

            foreach (MemberInfo info in members)
            {
                bool rememberLast = lastHadAttributes;
                MemberTypes rememberType = lastMemberType;
                int startLength = builder.Length;
                if (((lastMemberType != info.MemberType) && (0 != lastMemberType)) || lastHadAttributes)
                {
                    builder.Append(Environment.NewLine);
                    lastHadAttributes = false;
                }
                lastMemberType = info.MemberType;
                int newlineLength = builder.Length;

                bool abort = AppendCustomAttributes(builder, info.GetCustomAttributes(true), true, false, true);
                if (abort)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                    continue;
                }
                lastHadAttributes = (newlineLength != builder.Length);
                builder.Append("    ");
                int attributeLength = builder.Length;

                switch (info.MemberType)
                {
                    case MemberTypes.Constructor:
                        AppendConstructorInfo(builder, type, info as ConstructorInfo);
                        break;
                    case MemberTypes.Event:
                        AppendEventInfo(builder, type, info as EventInfo);
                        break;
                    case MemberTypes.Field:
                        AppendFieldInfo(builder, type, info as FieldInfo);
                        break;
                    case MemberTypes.Method:
                        AppendMethodInfo(builder, type, info as MethodInfo);
                        break;
                    case MemberTypes.Property:
                        AppendPropertyInfo(builder, type, info as PropertyInfo);
                        break;
                    case MemberTypes.NestedType:
                        //DumpClassAPI(builder, info as Type);
                        break;
                    default:
                        builder.Append(" ");
                        builder.Append(info.Name);
                        builder.Append(" ");
                        break;
                }
                if (attributeLength == builder.Length)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                }
            }
        }

        private static bool AppendCustomAttributes(StringBuilder builder, object[] attributes, bool indent, bool isEnum, bool appendNewLine)
        {
            if (attributes.Length > 0)
            {
                int count = 0;
                int startLength = builder.Length;
                Array.Sort(attributes, ObjectTypeCompare.Default);

                if (indent)
                {
                    builder.Append("    ");
                }
                builder.Append("[");
                if (appendNewLine)
                {
                    builder.Append(Environment.NewLine);
                }
                foreach (object attribute in attributes)
                {
                    if (attribute is MarshalAsAttribute)
                    {
                        continue;
                    }
                    if (attribute is StructLayoutAttribute)
                    {
                        continue;
                    }
                    if (attribute is CompilerGeneratedAttribute)
                    {
                        continue;
                    }
                    if (attribute is MethodImplAttribute)
                    {
                        continue;
                    }
                    if (attribute is TargetedPatchingOptOutAttribute)
                    {
                        continue;
                    }
                    if (attribute is SuppressMessageAttribute)
                    {
                        continue;
                    }
                    if (attribute is IteratorStateMachineAttribute)
                    {
                        continue;
                    }
                    if (attribute is DebuggerStepThroughAttribute)
                    {
                        continue;
                    }
                    if (isEnum && (attribute is SerializableAttribute))
                    {
                        continue;
                    }
                    count++;

                    if (indent)
                    {
                        builder.Append("    ");
                    }
                    builder.Append(attribute.GetType().Name);
                    builder.Append("(");

                    builder.Append("),");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                if (0 < count)
                {
                    if (indent)
                    {
                        builder.Append("    ");
                    }
                    builder.Append("]");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                else
                {
                    builder.Length = startLength;
                }
            }

            return false;
        }

        private static void AppendConstructorInfo(StringBuilder builder, Type type, ConstructorInfo info)
        {
            if (info.IsPublic)
            {
                builder.Append("public");
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                builder.Append("protected");
            }
            else return;

            builder.Append(" ");
            builder.Append(type.Name);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendEventInfo(StringBuilder builder, Type type, EventInfo info)
        {
            int propertyStart = builder.Length;

            AppendParameterType(builder, info.EventHandlerType);
            builder.Append(" ");
            builder.Append(info.Name);

            builder.Append(" {");
            bool gettable = AppendPropertyMethod(builder, type, info.GetAddMethod(), "add");
            bool settable = AppendPropertyMethod(builder, type, info.GetRemoveMethod(), "remove");
            if (gettable || settable)
            {
                builder.Append(" }");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static void AppendFieldInfo(StringBuilder builder, Type type, FieldInfo info)
        {
            if (type.IsEnum && info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("public");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("protected");
                }
            }
            else return;

            if (!type.IsEnum)
            {
                if (info.IsStatic)
                {
                    builder.Append(" static");
                }
                else if (info.IsInitOnly)
                {
                    builder.Append(" const");
                }
                if (info.IsInitOnly)
                {
                    builder.Append(" readonly");
                }
            }
            if (!type.IsEnum)
            {
                builder.Append(" ");
                AppendParameterType(builder, info.FieldType);
                builder.Append(" ");
            }

            builder.Append(info.Name);
            builder.Append(" = ");

            if (info.IsLiteral || info.IsStatic)
            {
                object fieldValue = null;
                try
                {
                    fieldValue = info.GetValue(null);
                }
                catch (Exception)
                {
                }

                if (null != fieldValue)
                {
                    if (fieldValue is string)
                    {
                        builder.Append('\"');
                        builder.Append((string)fieldValue);
                        builder.Append('\"');
                    }
                    else if (fieldValue is long)
                    {
                        builder.Append(((long)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is byte)
                    {
                        builder.Append(((byte)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is bool)
                    {
                        builder.Append(((bool)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is double)
                    {
                        builder.Append(((double)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is short)
                    {
                        builder.Append(((short)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is float)
                    {
                        builder.Append(((float)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is Guid)
                    {
                        builder.Append('{');
                        builder.Append((Guid)fieldValue);
                        builder.Append('}');
                    }
                    else if (fieldValue is Enum)
                    {
                        // remove the enumness, without assuming a particular underlying type.
                        builder.Append(Convert.ChangeType(fieldValue, Enum.GetUnderlyingType(type)));
                    }
                    else
                    {
                        string svalue;
                        try
                        {
                            MethodInfo tostring = fieldValue.GetType().GetMethod("ToString", ToStringFormatParameter);
                            if (null != tostring)
                            {
                                svalue = (string)tostring.Invoke(fieldValue, ToSTringFormatValues);
                            }
                            else
                            {
                                svalue = fieldValue.ToString();
                            }
                        }
                        catch (Exception e)
                        {
                            svalue = e.ToString();
                        }
                        builder.Append(svalue);
                    }
                }
            }
            builder.Append(Environment.NewLine);
        }

        private static readonly Type[] EmptyTypes = new Type[0];
        private static readonly ParameterModifier[] EmptyParameterModifiers = new ParameterModifier[0];

        private static readonly Type[] ToStringFormatParameter = new Type[] { typeof(IFormatProvider) };
        private static readonly object[] ToSTringFormatValues = new object[] { CultureInfo.InvariantCulture };

        private static void AppendMethodInfo(StringBuilder builder, Type type, MethodInfo info)
        {
            string infoName = info.Name;
            if ("IsRowOptimized" == infoName)
            {
                return;
            }
            if (info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (!type.IsInterface)
                {
                    builder.Append("public ");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (!type.IsInterface)
                {
                    builder.Append("protected ");
                }
            }
            else if (infoName.StartsWith("Reset") && ("Reset" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("Reset".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (infoName.StartsWith("ShouldSerialize") && ("ShouldSerialize" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("ShouldSerialize".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (!(type.IsClass && type.IsSealed) && info.IsVirtual)
            {
                if (-1 == info.Name.IndexOf("."))
                {
                    builder.Append("internal ");
                }
            }
            else return;

            if (!type.IsInterface)
            {
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual && (-1 == info.Name.IndexOf(".")))
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
            }

            AppendParameterType(builder, info.ReturnType);
            builder.Append(" ");
            builder.Append(infoName);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendPropertyInfo(StringBuilder builder, Type type, PropertyInfo info)
        {
            int propertyStart = builder.Length;

            builder.Append("");
            AppendParameterType(builder, info.PropertyType);
            builder.Append(" ");
            builder.Append(info.Name);
            builder.Append(" ");

            ParameterInfo[] parameters = info.GetIndexParameters();
            if (0 < parameters.Length)
            {
                AppendParameterInfo(builder, parameters, false, true);
            }

            builder.Append(" { ");
            bool gettable = AppendPropertyMethod(builder, type, info.GetGetMethod(true), "get");
            if (gettable)
            {
                builder.Append(' ');
            }
            bool settable = AppendPropertyMethod(builder, type, info.GetSetMethod(true), "set");
            if (settable)
            {
                builder.Append(' ');
            }
            if (gettable || settable)
            {
                builder.Append("}");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static bool AppendPropertyMethod(StringBuilder builder, Type type, MethodInfo info, string method)
        {
            if (null != info)
            {
                int setStart = builder.Length;

                AppendCustomAttributes(builder, info.GetCustomAttributes(true), false, false, false);

                if (info.IsPublic)
                {
                    builder.Append("public ");
                }
                else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
                {
                    builder.Append("protected ");
                }
                else
                {
                    builder.Length = setStart;
                    return false;
                }
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual)
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
                builder.Append(method);
                builder.Append(';');
                return true;
            }

            return false;
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo[] parameters, bool asMethod, bool withNames)
        {
            if (parameters.Length > 0)
            {
                builder.Append(asMethod ? '(' : '[');
                for (int i = 0; i < parameters.Length; ++i)
                {
                    if (0 < i)
                    {
                        builder.Append(", ");
                    }
                    if (withNames)
                    {
                        AppendParameterInfo(builder, parameters[i]);
                    }
                    else
                    {
                        builder.Append(parameters[i].ParameterType.FullName);
                    }
                }

                builder.Append(asMethod ? ')' : ']');
            }
            else
            {
                builder.Append("()");
            }
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo info)
        {
            if (info.IsOut)
            {
                builder.Append("out ");
            }
            else if (info.IsOptional)
            {
                builder.Append("params ");
            }
            AppendParameterType(builder, info.ParameterType);
            builder.Append(" ");
            builder.Append(info.Name);
        }

        private static void AppendParameterType(StringBuilder builder, Type parameterType)
        {
            string name = parameterType.FullName ?? parameterType.Name;
            string synonm = (string)Synonms[name];
            if (null != synonm)
            {
                builder.Append(synonm);
            }
            else if (parameterType.IsGenericType && name.Contains("Version="))
            {
                // If there is generic type with generic parameter (for e.g. IEnumerable<T>),
                // then AppendGenericTypeName produces 'System.IEnumerable[[]]' whereas
                // type.Name is IEnumerable'1. Also, to avoid too any changes with the existing baseline,
                // only going into this method if there is a "Version=" present in the name.
                AppendGenericTypeName(builder, parameterType);
            }
            else if (name.StartsWith("Microsoft.AspNet.OData."))
            {
                builder.Append(parameterType.Name);
            }
            else
            {
                builder.Append(name);
            }
        }

        private static void AppendGenericTypeName(StringBuilder builder, Type type)
        {
            if (type.IsGenericType)
            {
                builder.Append(type.GetGenericTypeDefinition().FullName);
                builder.Append("[");
                bool first = true;
                foreach (var argType in type.GetGenericArguments())
                {
                    if (!first)
                    {
                        builder.Append(",");
                    }
                    builder.Append("[");
                    AppendGenericTypeName(builder, argType);
                    builder.Append("]");
                    first = false;
                }

                builder.Append("]");
            }
            else
            {
                builder.Append(type.FullName);
            }
        }

        public sealed class AssemblyCompare : IComparer
        {
            public int Compare(object x, object y)
            {
                string a = ((Assembly)x).GetName().Name;
                string b = ((Assembly)y).GetName().Name;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, StringComparison.Ordinal);
                }
                return cmp;
            }
        }

        public sealed class TypeCompare : IComparer
        {
            public static readonly TypeCompare Default = new TypeCompare();

            public int Compare(object x, object y)
            {
                Type a = x as Type;
                Type b = y as Type;

                string c = a.FullName ?? a.Name;
                string d = b.FullName ?? b.Name;

                int ac = 0, bc = 0;

                for (int i = 0; i < c.Length; ++i)
                {
                    if ('.' == c[i]) ac++;
                }
                for (int i = 0; i < d.Length; ++i)
                {
                    if ('.' == d[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    if (!AlphabeticalGrouping)
                    {
                        string e = (0 < ac) ? c.Substring(0, c.LastIndexOf('.')) : null;
                        string f = (0 < bc) ? d.Substring(0, d.LastIndexOf('.')) : null;

                        if (0 == String.Compare(e, f, false, CultureInfo.InvariantCulture))
                        {
                            if (a.IsEnum)
                            {
                                if (!b.IsEnum)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (a.IsValueType)
                            {
                                if (b.IsEnum)
                                {
                                    cmp = 1;
                                }
                                else if (!b.IsValueType)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (b.IsEnum || b.IsValueType)
                            {
                                cmp = 1;
                            }
                            if (0 == cmp)
                            {
                                if (a.IsInterface != b.IsInterface)
                                {
                                    cmp = (a.IsInterface ? -1 : 1);
                                }
                                else if (a.IsAbstract != b.IsAbstract)
                                {
                                    cmp = (a.IsAbstract ? -1 : 1);
                                }
                                else if (a.IsSealed != b.IsSealed)
                                {
                                    cmp = (a.IsSealed ? 1 : -1);
                                }
                            }
                        }
                    }
                    if (0 == cmp)
                    {
                        cmp = String.Compare(c, d, false, CultureInfo.InvariantCulture);
                    }
                }
                return cmp;
            }
        }

        public sealed class ObjectTypeCompare : IComparer
        {
            public static readonly ObjectTypeCompare Default = new ObjectTypeCompare();
            public int Compare(object x, object y)
            {
                string a = x.GetType().FullName;
                string b = y.GetType().FullName;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, false, CultureInfo.InvariantCulture);
                }
                return cmp;
            }
        }

        public sealed class MemberCompare : IComparer
        {
            private static readonly Hashtable MemberType;
            static MemberCompare()
            {
                Hashtable memberType = new Hashtable();
                memberType.Add(MemberTypes.Field, 1);
                memberType.Add(MemberTypes.Constructor, 2);
                memberType.Add(MemberTypes.Property, 3);
                memberType.Add(MemberTypes.Event, 4);
                memberType.Add(MemberTypes.Method, 5);
                memberType.Add(MemberTypes.NestedType, 6);
                memberType.Add(MemberTypes.TypeInfo, 7);
                memberType.Add(MemberTypes.Custom, 8);
                MemberType = memberType;
            }

            private readonly Hashtable _hash;

            public MemberCompare(Type type)
            {
                _hash = new Hashtable();
                for (int i = 0; null != type; ++i, type = type.BaseType)
                {
                    _hash.Add(type, i);
                }
            }

            public int Compare(object x, object y)
            {
                return Compare((MemberInfo)x, (MemberInfo)y);
            }

            public int Compare(MemberInfo x, MemberInfo y)
            {
                if (x.MemberType == y.MemberType)
                {
                    Type xt = x.DeclaringType;
                    Type yt = y.DeclaringType;
                    if (xt != yt)
                    {
                        return (int)_hash[yt] - (int)_hash[xt];
                    }

                    int cmp = String.Compare(x.Name, y.Name, false, CultureInfo.InvariantCulture);
                    if (0 == cmp)
                    {
                        MethodInfo xMethodInfo = null, yMethodInfo = null;
                        ParameterInfo[] xParameterInfos, yParameterInfos;
                        switch (x.MemberType)
                        {
                            case MemberTypes.Constructor:
                                xParameterInfos = ((ConstructorInfo)x).GetParameters();
                                yParameterInfos = ((ConstructorInfo)y).GetParameters();
                                break;
                            case MemberTypes.Method:
                                xMethodInfo = (MethodInfo)x;
                                yMethodInfo = (MethodInfo)y;
                                xParameterInfos = xMethodInfo.GetParameters();
                                yParameterInfos = yMethodInfo.GetParameters();
                                break;
                            case MemberTypes.Property:
                                xParameterInfos = ((PropertyInfo)x).GetIndexParameters();
                                yParameterInfos = ((PropertyInfo)y).GetIndexParameters();
                                break;
                            default:
                                xParameterInfos = yParameterInfos = new ParameterInfo[0];
                                break;
                        }
                        cmp = xParameterInfos.Length - yParameterInfos.Length;
                        if (0 == cmp)
                        {
                            int count = xParameterInfos.Length;
                            for (int i = 0; i < count; ++i)
                            {
                                cmp = String.Compare(xParameterInfos[i].ParameterType.FullName, yParameterInfos[i].ParameterType.FullName, false, CultureInfo.InvariantCulture);
                                if (cmp == 0)
                                {
                                    // For generic parameters, FullName is null. Hence comparing the names
                                    cmp = String.Compare(xParameterInfos[i].ParameterType.Name, yParameterInfos[i].ParameterType.Name, false, CultureInfo.InvariantCulture);
                                }
                                if (0 != cmp)
                                {
                                    break;
                                }
                            }

                            if (0 == cmp && xMethodInfo != null)
                            {
                                // Two methods with same name, same parameters. Sort by the # of generic type parameters.
                                cmp = xMethodInfo.GetGenericArguments().Count() - yMethodInfo.GetGenericArguments().Count();
                            }
                        }
                    }

                    return cmp;
                }
                return ((int)MemberType[x.MemberType] - (int)MemberType[y.MemberType]);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.OData.PublicApi.Tests
{
    internal static class PublicApiHelper
    {
        private static bool AlphabeticalGrouping = false;
        private static readonly List<Assembly> Assemblies = new List<Assembly>();

        private static Hashtable _synonms;
        public static Hashtable Synonms
        {
            get
            {
                if (_synonms == null)
                {
                    _synonms = CreateSynonms();
                }

                return _synonms;
            }
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params string[] assemblyNames)
        {
            IList<Assembly> assemblies = new List<Assembly>();
            for (int k = 0; k < assemblyNames.Length; ++k)
            {
                try
                {
                    Assembly assembly;
                    if (File.Exists(assemblyNames[k]))
                    {
                        assembly = Assembly.LoadFrom(assemblyNames[k]);
                    }
                    else
                    {
                        assembly = Assembly.Load(assemblyNames[k]);
                    }

                    assemblies.Add(assembly);
                }
                catch (Exception e)
                {
                    streamWriter.WriteLine(@"Error loading types from assembly '{0}':", assemblyNames[k]);
                    streamWriter.WriteLine(e.ToString());
                    Environment.Exit(1);
                }
            }

            DumpPublicApi(streamWriter, assemblies.ToArray());
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params Assembly[] assemblies)
        {
            Reset();

            if (assemblies.Length <= 0)
            {
                return;
            }

            ArrayList typesList = new ArrayList();
            foreach (var assembly in assemblies)
            {
                Assemblies.Add(assembly);
                typesList.AddRange(assembly.GetTypes());
            }

            typesList.Sort(TypeCompare.Default);
            DumpPublicApiImplementation(streamWriter, typesList);
        }

        private static Hashtable CreateSynonms()
        {
            Hashtable synonms = new Hashtable();

            synonms.Add("System.Void", "void");
            synonms.Add("System.Object", "object");
            synonms.Add("System.String", "string");
            synonms.Add("System.Int16", "short");
            synonms.Add("System.Int32", "int");
            synonms.Add("System.Int64", "long");
            synonms.Add("System.Byte", "byte");
            synonms.Add("System.Boolean", "bool");
            synonms.Add("System.Char", "char");
            synonms.Add("System.Decimal", "decimal");
            synonms.Add("System.Double", "double");
            synonms.Add("System.Single", "float");

            synonms.Add("System.Object[]", "object[]");
            synonms.Add("System.Char[]", "char[]");
            synonms.Add("System.Byte[]", "byte[]");
            synonms.Add("System.Int32[]", "int[]");
            synonms.Add("System.String[]", "string[]");

            return synonms;
        }

        private static void DumpPublicApiImplementation(StreamWriter streamWriter, ArrayList sortedTypeList)
        {
            StringBuilder builder = new StringBuilder();
            string lastNamespace = "";
            foreach (Type type in sortedTypeList)
            {
                builder.Length = 0;

                if (type.IsSpecialName)
                {
                    continue;
                }

                string typeFullName = type.FullName;
                if (typeFullName.StartsWith("<PrivateImplementationDetails>"))
                {
                    continue;
                }

                Type declaringType = type;
                while (null != declaringType)
                {
                    switch (TypeAttributes.VisibilityMask & declaringType.Attributes)
                    {
                        case TypeAttributes.Public:
                        case TypeAttributes.NestedPublic:
                        case TypeAttributes.NestedFamily:
                        case TypeAttributes.NestedFamANDAssem:
                        case TypeAttributes.NestedFamORAssem:
                            declaringType = declaringType.DeclaringType;
                            continue;
                        case TypeAttributes.NotPublic:
                        case TypeAttributes.NestedPrivate:
                        case TypeAttributes.NestedAssembly:
                            Debug.Assert(null != declaringType, "Null declaringType");
                            break;
                        default:
                            Debug.Assert(false, "Unknown type");
                            break;
                    }
                    break;
                }

                if (typeof(TypeConverter).IsAssignableFrom(type))
                {
                    ConstructorInfo ctor = type.GetConstructor(BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, EmptyTypes, EmptyParameterModifiers);
                    if (null != ctor)
                    {
                        streamWriter.WriteLine("{0}", type.FullName);
                    }
                    else
                    {
                        streamWriter.WriteLine("{0} missing public ctor", type.FullName);
                    }
                }

                if (null != declaringType)
                {
                    continue;
                }

                bool abort = AppendCustomAttributes(builder, type.GetCustomAttributes(false), false, type.IsEnum, true);
                if (abort)
                {
                    continue;
                }

                AppendClassDeclarationApi(builder, type);
                builder.Append(" {");
                builder.Append(Environment.NewLine);

                string currentNamespace = type.Namespace;
                if (lastNamespace != currentNamespace)
                {
                    lastNamespace = currentNamespace;
                }

                if (type.Name.Contains("UnmappedRequestRoutingConvention"))
                {
                    int kk = 0;
                    kk += 1;
                }
                AppendClassMemberApi(builder, type);
                if (builder.Length > 0)
                {
                    AssemblyFilter(builder);
                    streamWriter.Write(builder.ToString());
                    builder.Length = 0;
                }
                streamWriter.Write("}");
                streamWriter.Write(Environment.NewLine);
                streamWriter.Write(Environment.NewLine);
            }
        }

        private static void Reset()
        {
            _outputFilter = null;
            Assemblies.Clear();
        }

        private static String[] _outputFilter;
        private static void AssemblyFilter(StringBuilder builder)
        {
            string[] filter = _outputFilter;
            if (null == filter)
            {
                filter = new string[2 + Assemblies.Count];
                filter[0] = ", " + typeof(object).Assembly.ToString();
                filter[1] = ", " + typeof(Uri).Assembly.ToString();
                for (int i = 2; i < filter.Length; i++)
                {
                    filter[i] = ", " + Assemblies[i - 2].ToString();
                }
                _outputFilter = filter;
            }
            for (int i = 0; i < filter.Length; ++i)
            {
                builder.Replace(filter[i], "");
            }
        }

        private static void AppendClassDeclarationApi(StringBuilder builder, Type type)
        {
            if (type.IsPublic | type.IsNestedPublic)
            {
                builder.Append("public ");
            }
            else if (type.IsNestedFamily | type.IsNestedFamORAssem | type.IsNestedFamANDAssem)
            {
                builder.Append("protected ");
            }
            else
            {
                Debug.Assert(false, "non public or protected type");
            }

            if (type.IsInterface)
            {
                builder.Append("interface ");
            }
            else if (type.IsEnum)
            {
                builder.Append("enum ");
            }
            else if (type.IsValueType)
            {
                builder.Append("struct ");
            }
            else if (type.IsClass)
            {
                if (type.IsSealed)
                {
                    builder.Append("sealed ");
                }
                else if (type.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                builder.Append("class ");
            }
            else
            {
                builder.Append("? ");
            }
            builder.Append(type.FullName);

            bool haveColon = false;
            Type baseType = type.BaseType;
            if ((null != baseType) && (typeof(object) != baseType) && (typeof(ValueType) != baseType))
            {
                if (typeof(Enum) == baseType)
                {
                    baseType = Enum.GetUnderlyingType(type);
                }
                haveColon = true;
                builder.Append(" : ");
                AppendParameterType(builder, baseType);
            }

            if (!type.IsEnum)
            {
                Type[] baseInterfaces = type.GetInterfaces();
                Array.Sort(baseInterfaces, TypeCompare.Default);
                foreach (Type baseInterface in baseInterfaces)
                {
                    if (haveColon)
                    {
                        builder.Append(", ");
                    }
                    else
                    {
                        haveColon = true;
                        builder.Append(" : ");
                    }
                    builder.Append(baseInterface.Name);
                }
            }
        }

        private static void AppendClassMemberApi(StringBuilder builder, Type type)
        {
            MemberInfo[] members = type.GetMembers(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
            if (members.Length <= 0)
            {
                return;
            }

            Array.Sort(members, new MemberCompare(type));

            bool lastHadAttributes = false;
            MemberTypes lastMemberType = 0;

            foreach (MemberInfo info in members)
            {
                bool rememberLast = lastHadAttributes;
                MemberTypes rememberType = lastMemberType;
                int startLength = builder.Length;
                if (((lastMemberType != info.MemberType) && (0 != lastMemberType)) || lastHadAttributes)
                {
                    builder.Append(Environment.NewLine);
                    lastHadAttributes = false;
                }
                lastMemberType = info.MemberType;
                int newlineLength = builder.Length;

                bool abort = AppendCustomAttributes(builder, info.GetCustomAttributes(true), true, false, true);
                if (abort)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                    continue;
                }
                lastHadAttributes = (newlineLength != builder.Length);
                builder.Append("    ");
                int attributeLength = builder.Length;

                switch (info.MemberType)
                {
                    case MemberTypes.Constructor:
                        AppendConstructorInfo(builder, type, info as ConstructorInfo);
                        break;
                    case MemberTypes.Event:
                        AppendEventInfo(builder, type, info as EventInfo);
                        break;
                    case MemberTypes.Field:
                        AppendFieldInfo(builder, type, info as FieldInfo);
                        break;
                    case MemberTypes.Method:
                        AppendMethodInfo(builder, type, info as MethodInfo);
                        break;
                    case MemberTypes.Property:
                        AppendPropertyInfo(builder, type, info as PropertyInfo);
                        break;
                    case MemberTypes.NestedType:
                        //DumpClassAPI(builder, info as Type);
                        break;
                    default:
                        builder.Append(" ");
                        builder.Append(info.Name);
                        builder.Append(" ");
                        break;
                }
                if (attributeLength == builder.Length)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                }
            }
        }

        private static bool AppendCustomAttributes(StringBuilder builder, object[] attributes, bool indent, bool isEnum, bool appendNewLine)
        {
            if (attributes.Length > 0)
            {
                int count = 0;
                int startLength = builder.Length;
                Array.Sort(attributes, ObjectTypeCompare.Default);

                if (indent)
                {
                    builder.Append("    ");
                }
                builder.Append("[");
                if (appendNewLine)
                {
                    builder.Append(Environment.NewLine);
                }
                foreach (object attribute in attributes)
                {
                    if (attribute is MarshalAsAttribute)
                    {
                        continue;
                    }
                    if (attribute is StructLayoutAttribute)
                    {
                        continue;
                    }
                    if (attribute is CompilerGeneratedAttribute)
                    {
                        continue;
                    }
                    if (attribute is MethodImplAttribute)
                    {
                        continue;
                    }
                    if (attribute is TargetedPatchingOptOutAttribute)
                    {
                        continue;
                    }
                    if (attribute is SuppressMessageAttribute)
                    {
                        continue;
                    }
                    if (attribute is IteratorStateMachineAttribute)
                    {
                        continue;
                    }
                    if (attribute is DebuggerStepThroughAttribute)
                    {
                        continue;
                    }
                    if (isEnum && (attribute is SerializableAttribute))
                    {
                        continue;
                    }
                    count++;

                    if (indent)
                    {
                        builder.Append("    ");
                    }
                    builder.Append(attribute.GetType().Name);
                    builder.Append("(");

                    builder.Append("),");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                if (0 < count)
                {
                    if (indent)
                    {
                        builder.Append("    ");
                    }
                    builder.Append("]");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                else
                {
                    builder.Length = startLength;
                }
            }

            return false;
        }

        private static void AppendConstructorInfo(StringBuilder builder, Type type, ConstructorInfo info)
        {
            if (info.IsPublic)
            {
                builder.Append("public");
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                builder.Append("protected");
            }
            else return;

            builder.Append(" ");
            builder.Append(type.Name);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendEventInfo(StringBuilder builder, Type type, EventInfo info)
        {
            int propertyStart = builder.Length;

            AppendParameterType(builder, info.EventHandlerType);
            builder.Append(" ");
            builder.Append(info.Name);

            builder.Append(" {");
            bool gettable = AppendPropertyMethod(builder, type, info.GetAddMethod(), "add");
            bool settable = AppendPropertyMethod(builder, type, info.GetRemoveMethod(), "remove");
            if (gettable || settable)
            {
                builder.Append(" }");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static void AppendFieldInfo(StringBuilder builder, Type type, FieldInfo info)
        {
            if (type.IsEnum && info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("public");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("protected");
                }
            }
            else return;

            if (!type.IsEnum)
            {
                if (info.IsStatic)
                {
                    builder.Append(" static");
                }
                else if (info.IsInitOnly)
                {
                    builder.Append(" const");
                }
                if (info.IsInitOnly)
                {
                    builder.Append(" readonly");
                }
            }
            if (!type.IsEnum)
            {
                builder.Append(" ");
                AppendParameterType(builder, info.FieldType);
                builder.Append(" ");
            }

            builder.Append(info.Name);
            builder.Append(" = ");

            if (info.IsLiteral || info.IsStatic)
            {
                object fieldValue = null;
                try
                {
                    fieldValue = info.GetValue(null);
                }
                catch (Exception)
                {
                }

                if (null != fieldValue)
                {
                    if (fieldValue is string s)
                    {
                        builder.Append('\"');
                        builder.Append(s);
                        builder.Append('\"');
                    }
                    else if (fieldValue is long l)
                    {
                        builder.Append(l.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is byte b)
                    {
                        builder.Append(b.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is bool b)
                    {
                        builder.Append(b.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is double d)
                    {
                        builder.Append(d.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is short sh)
                    {
                        builder.Append(sh.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is float f)
                    {
                        builder.Append(f.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is Guid guid)
                    {
                        builder.Append('{');
                        builder.Append(guid);
                        builder.Append('}');
                    }
                    else if (fieldValue is Enum)
                    {
                        // remove the enumness, without assuming a particular underlying type.
                        builder.Append(Convert.ChangeType(fieldValue, Enum.GetUnderlyingType(type)));
                    }
                    else
                    {
                        string svalue;
                        try
                        {
                            MethodInfo tostring = fieldValue.GetType().GetMethod("ToString", ToStringFormatParameter);
                            if (null != tostring)
                            {
                                svalue = (string)tostring.Invoke(fieldValue, ToSTringFormatValues);
                            }
                            else
                            {
                                svalue = fieldValue.ToString();
                            }
                        }
                        catch (Exception e)
                        {
                            svalue = e.ToString();
                        }
                        builder.Append(svalue);
                    }
                }
            }
            builder.Append(Environment.NewLine);
        }

        private static readonly Type[] EmptyTypes = new Type[0];
        private static readonly ParameterModifier[] EmptyParameterModifiers = new ParameterModifier[0];

        private static readonly Type[] ToStringFormatParameter = new Type[] { typeof(IFormatProvider) };
        private static readonly object[] ToSTringFormatValues = new object[] { CultureInfo.InvariantCulture };

        private static void AppendMethodInfo(StringBuilder builder, Type type, MethodInfo info)
        {
            string infoName = info.Name;
            if ("IsRowOptimized" == infoName)
            {
                return;
            }
            if (info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (!type.IsInterface)
                {
                    builder.Append("public ");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (!type.IsInterface)
                {
                    builder.Append("protected ");
                }
            }
            else if (infoName.StartsWith("Reset") && ("Reset" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("Reset".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (infoName.StartsWith("ShouldSerialize") && ("ShouldSerialize" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("ShouldSerialize".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (!(type.IsClass && type.IsSealed) && info.IsVirtual)
            {
                if (-1 == info.Name.IndexOf("."))
                {
                    builder.Append("internal ");
                }
            }
            else return;

            if (!type.IsInterface)
            {
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual && (-1 == info.Name.IndexOf(".")))
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
            }

            AppendParameterType(builder, info.ReturnType);
            builder.Append(" ");
            builder.Append(infoName);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendPropertyInfo(StringBuilder builder, Type type, PropertyInfo info)
        {
            int propertyStart = builder.Length;

            builder.Append("");
            AppendParameterType(builder, info.PropertyType);
            builder.Append(" ");
            builder.Append(info.Name);
            builder.Append(" ");

            ParameterInfo[] parameters = info.GetIndexParameters();
            if (0 < parameters.Length)
            {
                AppendParameterInfo(builder, parameters, false, true);
            }

            builder.Append(" { ");
            bool gettable = AppendPropertyMethod(builder, type, info.GetGetMethod(true), "get");
            if (gettable)
            {
                builder.Append(' ');
            }
            bool settable = AppendPropertyMethod(builder, type, info.GetSetMethod(true), "set");
            if (settable)
            {
                builder.Append(' ');
            }
            if (gettable || settable)
            {
                builder.Append("}");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static bool AppendPropertyMethod(StringBuilder builder, Type type, MethodInfo info, string method)
        {
            if (null != info)
            {
                int setStart = builder.Length;

                AppendCustomAttributes(builder, info.GetCustomAttributes(true), false, false, false);

                if (info.IsPublic)
                {
                    builder.Append("public ");
                }
                else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
                {
                    builder.Append("protected ");
                }
                else
                {
                    builder.Length = setStart;
                    return false;
                }
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual)
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
                builder.Append(method);
                builder.Append(';');
                return true;
            }

            return false;
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo[] parameters, bool asMethod, bool withNames)
        {
            if (parameters.Length > 0)
            {
                builder.Append(asMethod ? '(' : '[');
                for (int i = 0; i < parameters.Length; ++i)
                {
                    if (0 < i)
                    {
                        builder.Append(", ");
                    }
                    if (withNames)
                    {
                        AppendParameterInfo(builder, parameters[i]);
                    }
                    else
                    {
                        builder.Append(parameters[i].ParameterType.FullName);
                    }
                }

                builder.Append(asMethod ? ')' : ']');
            }
            else
            {
                builder.Append("()");
            }
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo info)
        {
            if (info.IsOut)
            {
                builder.Append("out ");
            }
            else if (info.IsOptional)
            {
                builder.Append("params ");
            }
            AppendParameterType(builder, info.ParameterType);
            builder.Append(" ");
            builder.Append(info.Name);
        }

        private static void AppendParameterType(StringBuilder builder, Type parameterType)
        {
            string name = parameterType.FullName ?? parameterType.Name;
            string synonm = (string)Synonms[name];
            if (null != synonm)
            {
                builder.Append(synonm);
            }
            else if (parameterType.IsGenericType && name.Contains("Version="))
            {
                // If there is generic type with generic parameter (for e.g. IEnumerable<T>),
                // then AppendGenericTypeName produces 'System.IEnumerable[[]]' whereas
                // type.Name is IEnumerable'1. Also, to avoid too any changes with the existing baseline,
                // only going into this method if there is a "Version=" present in the name.
                AppendGenericTypeName(builder, parameterType);
            }
            else if (name.StartsWith("Microsoft.AspNet.OData."))
            {
                builder.Append(parameterType.Name);
            }
            else
            {
                builder.Append(name);
            }
        }

        private static void AppendGenericTypeName(StringBuilder builder, Type type)
        {
            if (type.IsGenericType)
            {
                builder.Append(type.GetGenericTypeDefinition().FullName);
                builder.Append("[");
                bool first = true;
                foreach (var argType in type.GetGenericArguments())
                {
                    if (!first)
                    {
                        builder.Append(",");
                    }
                    builder.Append("[");
                    AppendGenericTypeName(builder, argType);
                    builder.Append("]");
                    first = false;
                }

                builder.Append("]");
            }
            else
            {
                builder.Append(type.FullName);
            }
        }

        public sealed class AssemblyCompare : IComparer
        {
            public int Compare(object x, object y)
            {
                string a = ((Assembly)x).GetName().Name;
                string b = ((Assembly)y).GetName().Name;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, StringComparison.Ordinal);
                }
                return cmp;
            }
        }

        public sealed class TypeCompare : IComparer
        {
            public static readonly TypeCompare Default = new TypeCompare();

            public int Compare(object x, object y)
            {
                Type a = x as Type;
                Type b = y as Type;

                string c = a.FullName ?? a.Name;
                string d = b.FullName ?? b.Name;

                int ac = 0, bc = 0;

                for (int i = 0; i < c.Length; ++i)
                {
                    if ('.' == c[i]) ac++;
                }
                for (int i = 0; i < d.Length; ++i)
                {
                    if ('.' == d[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    if (!AlphabeticalGrouping)
                    {
                        string e = (0 < ac) ? c.Substring(0, c.LastIndexOf('.')) : null;
                        string f = (0 < bc) ? d.Substring(0, d.LastIndexOf('.')) : null;

                        if (0 == String.Compare(e, f, false, CultureInfo.InvariantCulture))
                        {
                            if (a.IsEnum)
                            {
                                if (!b.IsEnum)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (a.IsValueType)
                            {
                                if (b.IsEnum)
                                {
                                    cmp = 1;
                                }
                                else if (!b.IsValueType)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (b.IsEnum || b.IsValueType)
                            {
                                cmp = 1;
                            }
                            if (0 == cmp)
                            {
                                if (a.IsInterface != b.IsInterface)
                                {
                                    cmp = (a.IsInterface ? -1 : 1);
                                }
                                else if (a.IsAbstract != b.IsAbstract)
                                {
                                    cmp = (a.IsAbstract ? -1 : 1);
                                }
                                else if (a.IsSealed != b.IsSealed)
                                {
                                    cmp = (a.IsSealed ? 1 : -1);
                                }
                            }
                        }
                    }
                    if (0 == cmp)
                    {
                        cmp = String.Compare(c, d, false, CultureInfo.InvariantCulture);
                    }
                }
                return cmp;
            }
        }

        public sealed class ObjectTypeCompare : IComparer
        {
            public static readonly ObjectTypeCompare Default = new ObjectTypeCompare();
            public int Compare(object x, object y)
            {
                string a = x.GetType().FullName;
                string b = y.GetType().FullName;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, false, CultureInfo.InvariantCulture);
                }
                return cmp;
            }
        }

        public sealed class MemberCompare : IComparer
        {
            private static readonly Hashtable MemberType;
            static MemberCompare()
            {
                Hashtable memberType = new Hashtable();
                memberType.Add(MemberTypes.Field, 1);
                memberType.Add(MemberTypes.Constructor, 2);
                memberType.Add(MemberTypes.Property, 3);
                memberType.Add(MemberTypes.Event, 4);
                memberType.Add(MemberTypes.Method, 5);
                memberType.Add(MemberTypes.NestedType, 6);
                memberType.Add(MemberTypes.TypeInfo, 7);
                memberType.Add(MemberTypes.Custom, 8);
                MemberType = memberType;
            }

            private readonly Hashtable _hash;

            public MemberCompare(Type type)
            {
                _hash = new Hashtable();
                for (int i = 0; null != type; ++i, type = type.BaseType)
                {
                    _hash.Add(type, i);
                }
            }

            public int Compare(object x, object y)
            {
                return Compare((MemberInfo)x, (MemberInfo)y);
            }

            public int Compare(MemberInfo x, MemberInfo y)
            {
                if (x.MemberType == y.MemberType)
                {
                    Type xt = x.DeclaringType;
                    Type yt = y.DeclaringType;
                    if (xt != yt)
                    {
                        return (int)_hash[yt] - (int)_hash[xt];
                    }

                    int cmp = String.Compare(x.Name, y.Name, false, CultureInfo.InvariantCulture);
                    if (0 == cmp)
                    {
                        MethodInfo xMethodInfo = null, yMethodInfo = null;
                        ParameterInfo[] xParameterInfos, yParameterInfos;
                        switch (x.MemberType)
                        {
                            case MemberTypes.Constructor:
                                xParameterInfos = ((ConstructorInfo)x).GetParameters();
                                yParameterInfos = ((ConstructorInfo)y).GetParameters();
                                break;
                            case MemberTypes.Method:
                                xMethodInfo = (MethodInfo)x;
                                yMethodInfo = (MethodInfo)y;
                                xParameterInfos = xMethodInfo.GetParameters();
                                yParameterInfos = yMethodInfo.GetParameters();
                                break;
                            case MemberTypes.Property:
                                xParameterInfos = ((PropertyInfo)x).GetIndexParameters();
                                yParameterInfos = ((PropertyInfo)y).GetIndexParameters();
                                break;
                            default:
                                xParameterInfos = yParameterInfos = new ParameterInfo[0];
                                break;
                        }
                        cmp = xParameterInfos.Length - yParameterInfos.Length;
                        if (0 == cmp)
                        {
                            int count = xParameterInfos.Length;
                            for (int i = 0; i < count; ++i)
                            {
                                cmp = String.Compare(xParameterInfos[i].ParameterType.FullName, yParameterInfos[i].ParameterType.FullName, false, CultureInfo.InvariantCulture);
                                if (cmp == 0)
                                {
                                    // For generic parameters, FullName is null. Hence comparing the names
                                    cmp = String.Compare(xParameterInfos[i].ParameterType.Name, yParameterInfos[i].ParameterType.Name, false, CultureInfo.InvariantCulture);
                                }
                                if (0 != cmp)
                                {
                                    break;
                                }
                            }

                            if (0 == cmp && xMethodInfo != null)
                            {
                                // Two methods with same name, same parameters. Sort by the # of generic type parameters.
                                cmp = xMethodInfo.GetGenericArguments().Count() - yMethodInfo.GetGenericArguments().Count();
                            }
                        }
                    }

                    return cmp;
                }
                return ((int)MemberType[x.MemberType] - (int)MemberType[y.MemberType]);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\PublicApiTests\PublicApiHelper.cs(606,49): error CS0136: A local or parameter named 'b' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


