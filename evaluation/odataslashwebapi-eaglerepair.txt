Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Microsoft.AspNet.OData
    #1 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ContainmentPathBuilder.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ContainmentPathBuilder.cs, Line: 157, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ContainmentPathBuilder.cs, Line: 163, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ContainmentPathBuilder.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\AbstractTypeDiscoveryConvention.cs, Line: 15, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\ActionOnDeleteAttributeConvention.cs, Line: 26, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\AttributeEdmPropertyConvention.cs, Line: 46, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\AttributeEdmTypeConvention.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataContractAttributeEdmTypeConvention.cs, Line: 46, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataContractAttributeEnumTypeConvention.cs, Line: 46, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataContractAttributeEnumTypeConvention.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataMemberAttributeEdmPropertyConvention.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataMemberAttributeEdmPropertyConvention.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DataMemberAttributeEdmPropertyConvention.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\DefaultValueAttributeEdmPropertyConvention.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\KeyAttributeEdmPropertyConvention.cs, Line: 41, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #17 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\RequiredAttributeEdmPropertyConvention.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\RequiredAttributeEdmPropertyConvention.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\TimestampAttributeEdmPropertyConvention.cs, Line: 24, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\ConventionsHelpers.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\EntityTypeConvention.cs, Line: 19, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\ForeignKeyDiscoveryConvention.cs, Line: 31, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\ForeignKeyDiscoveryConvention.cs, Line: 77, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #24 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\SelfLinksGenerationConvention.cs, Line: 23, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 253, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 253, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 657, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmModelHelperMethods.cs, Line: 904, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\NavigationPropertyExtensions.cs, Line: 107, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\NavigationPropertyExtensions.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\NavigationPropertyExtensions.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\NavigationSourceConfiguration.cs, Line: 550, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataConventionModelBuilder.cs, Line: 1008, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #41 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataConventionModelBuilder.cs, Line: 1011, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataConventionModelBuilder.cs, Line: 1035, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #43 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataConventionModelBuilder.cs, Line: 949, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataModelBuilder.cs, Line: 507, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\ODataModelBuilder.cs, Line: 531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 152, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 244, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Common\CollectionExtensions.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\DeltaOfTStructuralType.cs, Line: 396, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #55 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\DeltaOfTStructuralType.cs, Line: 598, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #56 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\EnableQueryAttribute.cs, Line: 710, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #57 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ETagMessageHandler.cs, Line: 163, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ETagMessageHandler.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ExpressionHelperMethods.cs, Line: 433, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #60 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataActionPayloadDeserializer.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataActionPayloadDeserializer.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataActionPayloadDeserializer.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataActionPayloadDeserializer.cs, Line: 296, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #64 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataReaderExtensions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 442, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 475, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 641, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 654, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 666, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 677, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 850, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 857, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 862, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmLibHelpers.cs, Line: 869, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs, Line: 103, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #76 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs, Line: 113, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #77 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #78 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataMessageWrapper.cs, Line: 164, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #79 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataModelBinderConverter.cs, Line: 277, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #80 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataModelBinderConverter.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataModelBinderConverter.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataModelBinderConverter.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 275, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 322, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 329, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 372, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #88 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataOutputFormatterHelper.cs, Line: 378, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #89 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\ODataValueExtensions.cs, Line: 18, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #90 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\QueryStringMediaTypeMapping.cs, Line: 42, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #91 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataCollectionSerializer.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataCollectionSerializer.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataDeltaFeedSerializer.cs, Line: 411, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs, Line: 244, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #95 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 281, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 296, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 316, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #98 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 334, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #99 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 352, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 413, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #101 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSetSerializer.cs, Line: 553, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceValueSerializer.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataSerializerContext.cs, Line: 288, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #104 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\SelectExpandNode.cs, Line: 331, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #105 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\SelectExpandNode.cs, Line: 406, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #106 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ODataNullValueMessageHandler.cs, Line: 50, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #107 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ODataNullValueMessageHandler.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #108 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ODataNullValueMessageHandler.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ODataNullValueMessageHandler.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ODataSwaggerConverter.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\CountQueryOption.cs, Line: 120, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #112 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\DefaultSkipTokenHandler.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\DefaultSkipTokenHandler.cs, Line: 258, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\DefaultSkipTokenHandler.cs, Line: 423, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\AggregationBinder.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\AggregationPropertyContainer.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #117 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\DynamicTypeWrapper.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #118 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\DynamicTypeWrapper.cs, Line: 75, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #119 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\DynamicTypeWrapper.cs, Line: 75, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #120 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\DynamicTypeWrapperConverter.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #121 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\FilterBinder.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\FilterBinder.cs, Line: 196, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\FilterBinder.cs, Line: 913, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\FilterBinder.cs, Line: 916, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandBinder.cs, Line: 471, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #126 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandBinder.cs, Line: 527, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #127 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandIncludedProperty.cs, Line: 185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #128 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandWrapper.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #129 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandWrapperConverter.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\FilterQueryOption.cs, Line: 160, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #131 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\ODataQueryOptions.cs, Line: 584, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #132 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\ODataQueryOptions.cs, Line: 846, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByNode.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByNode.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByNode.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByQueryOption.cs, Line: 220, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #137 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByQueryOption.cs, Line: 245, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByQueryOption.cs, Line: 270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\OrderByQueryOption.cs, Line: 283, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SelectExpandQueryOption.cs, Line: 247, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #141 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SelectExpandQueryOption.cs, Line: 439, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #142 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SelectExpandQueryOption.cs, Line: 546, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #143 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SelectExpandQueryOption.cs, Line: 546, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #144 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SelectExpandQueryOption.cs, Line: 639, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #145 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SkipQueryOption.cs, Line: 153, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #146 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\SkipTokenQueryOption.cs, Line: 118, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #147 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\TopQueryOption.cs, Line: 153, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #148 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\FilterQueryValidator.cs, Line: 646, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\FilterQueryValidator.cs, Line: 650, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #150 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\OrderByQueryValidator.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #151 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\SelectExpandQueryValidator.cs, Line: 195, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\SelectExpandQueryValidator.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #153 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\SelectExpandQueryValidator.cs, Line: 211, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #154 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\SelectExpandQueryValidator.cs, Line: 225, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #155 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Validators\SelectExpandQueryValidator.cs, Line: 318, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #156 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ResourceContext.cs, Line: 220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ResourceContext.cs, Line: 226, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #158 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\ResourceContext.cs, Line: 273, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\ActionRoutingConvention.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\NavigationRoutingConvention.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\NavigationSourceRoutingConvention.cs, Line: 28, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\NavigationSourceRoutingConvention.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #163 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\NavigationSourceRoutingConvention.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #164 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #165 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #166 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 211, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #167 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 335, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #168 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 341, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #169 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 388, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #170 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 391, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #171 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Conventions\RoutingConventionHelpers.cs, Line: 40, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #172 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\DefaultODataPathHandler.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\DefaultODataPathHandler.cs, Line: 274, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataParameterHelper.cs, Line: 185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataParameterHelper.cs, Line: 191, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataParameterHelper.cs, Line: 198, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #179 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 329, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #180 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 335, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 338, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 355, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 358, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 365, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentExtensions.cs, Line: 374, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 163, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 197, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 400, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 406, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 409, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #191 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 431, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 434, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #193 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 441, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 450, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #195 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentHandler.cs, Line: 456, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentTranslator.cs, Line: 225, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #197 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentTranslator.cs, Line: 252, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentTranslator.cs, Line: 291, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #199 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentTranslator.cs, Line: 297, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\ODataPathSegmentTranslator.cs, Line: 304, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\EntitySetSegmentTemplate.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\KeySegmentTemplate.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\KeySegmentTemplate.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #204 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\NavigationPropertyLinkSegmentTemplate.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\NavigationPropertySegmentTemplate.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\PropertySegmentTemplate.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #207 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\SingletonSegmentTemplate.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #208 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Routing\Template\TypeSegmentTemplate.cs, Line: 39, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #209 Path: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\TypeHelper.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #210 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\ChangeSetRequestItem.cs, Line: 104, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #211 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\ChangeSetRequestItem.cs, Line: 116, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #212 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\ChangeSetResponseItem.cs, Line: 89, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #213 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\DefaultODataBatchHandler.cs, Line: 103, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #214 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\ODataBatchContent.cs, Line: 83, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #215 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Batch\UnbufferedODataBatchHandler.cs, Line: 88, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #216 Path: D:\a\1\s\src\Microsoft.AspNet.OData\EnableQueryAttribute.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #217 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Extensions\HttpConfigurationExtensions.cs, Line: 898, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #218 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Extensions\HttpErrorExtensions.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Formatter\ODataModelBinderProvider.cs, Line: 120, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #220 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Formatter\ODataModelBinderProvider.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #221 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Formatter\ODataModelBinderProvider.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #222 Path: D:\a\1\s\src\Microsoft.AspNet.OData\PerRequestActionValueBinder.cs, Line: 54, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #223 Path: D:\a\1\s\src\Microsoft.AspNet.OData\Routing\ODataRoute.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Microsoft.AspNet.OData.Test
    #224 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ActionConfigurationTest.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #225 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ActionConfigurationTest.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #226 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ActionConfigurationTest.cs, Line: 268, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #227 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ActionConfigurationTest.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #228 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ContainmentPathBuilderTest.cs, Line: 276, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #229 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ContainmentPathBuilderTest.cs, Line: 283, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #230 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ContainmentPathBuilderTest.cs, Line: 290, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #231 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ContainmentPathBuilderTest.cs, Line: 297, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 2257, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #233 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 2278, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #234 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 2305, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #235 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 2981, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #236 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 2982, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #237 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 3366, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #238 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 3368, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #239 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\Conventions\ODataConventionModelBuilderTests.cs, Line: 3370, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #240 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EdmModelAsserts.cs, Line: 60, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #241 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EdmModelAsserts.cs, Line: 68, Message: ReSharper: ReplaceWithSingleCallToSingleOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #242 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EdmTypeConfigurationExtensionsTest.cs, Line: 353, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #243 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntitySetLinkConfigurationTest.cs, Line: 26, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #244 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntitySetLinkConfigurationTest.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #245 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntitySetLinkConfigurationTest.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #246 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntitySetTest.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #247 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntitySetTest.cs, Line: 421, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #248 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntityTypeTest.cs, Line: 691, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #249 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\EntityTypeTest.cs, Line: 692, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #250 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\FunctionConfigurationTest.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #251 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\FunctionConfigurationTest.cs, Line: 217, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #252 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\FunctionConfigurationTest.cs, Line: 301, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #253 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\FunctionConfigurationTest.cs, Line: 307, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #254 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\ParameterConfigurationTest.cs, Line: 27, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #255 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\PropertyPairSelectorVisitorTest.cs, Line: 95, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #256 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\PropertySelectorVisitorTest.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #257 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Builder\StructuralTypeConfigurationTest.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #258 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\ExceptionAssert.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #259 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\ExceptionAssert.cs, Line: 529, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #260 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\MemberHelper.cs, Line: 106, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #261 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\MemberHelper.cs, Line: 23, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #262 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\MemberHelper.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\MemberHelper.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\MemberHelper.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #265 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\PreAppStartTestHelper.cs, Line: 15, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #266 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\PreAppStartTestHelper.cs, Line: 18, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #267 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\PreAppStartTestHelper.cs, Line: 22, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #268 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\TestFile.cs, Line: 34, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #269 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\TypeAssert.cs, Line: 100, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #270 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Common\TypeAssert.cs, Line: 161, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #271 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\ContentIdHelpersTest.cs, Line: 58, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #272 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\DollarFormatTest.cs, Line: 27, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #273 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataActionPayloadDeserializerTest.cs, Line: 664, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #274 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataActionPayloadDeserializerTest.cs, Line: 672, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #275 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 435, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #276 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 464, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #277 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 561, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #278 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 590, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #279 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 710, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #280 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Deserialization\ODataResourceDeserializerTests.cs, Line: 739, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #281 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\EdmLibHelpersTests.cs, Line: 106, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #282 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\EdmLibHelpersTests.cs, Line: 191, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #283 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\EdmLibHelpersTests.cs, Line: 91, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #284 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\EdmLibHelpersTests.cs, Line: 98, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #285 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\EdmLibHelpersTests.cs, Line: 99, Message: ReSharper: ReplaceWithSingleCallToSingle. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #286 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataFormatterTests.cs, Line: 1403, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #287 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataFormatterTests.cs, Line: 616, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #288 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataMediaTypeFormatterTests.cs, Line: 684, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #289 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataMediaTypeFormatterTests.cs, Line: 700, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #290 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #291 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 188, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #292 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 207, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #293 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #295 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #296 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 261, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #297 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #298 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 326, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #299 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 355, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #300 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #301 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 412, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #302 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\ODataModelBinderProviderTest.cs, Line: 488, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #303 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataEntityReferenceLinksSerializerTest.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #304 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1061, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #305 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1236, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #306 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1326, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #307 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1415, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #308 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1501, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #309 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 1611, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #310 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Formatter\Serialization\ODataResourceSerializerTests.cs, Line: 991, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #311 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\ODataUriResolverExtensionTest.cs, Line: 253, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #312 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\ODataUriResolverExtensionTest.cs, Line: 302, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #313 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\PublicApi\PublicApiTest.cs, Line: 26, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #314 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1234, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #315 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1234, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #316 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1282, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #317 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1282, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #318 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1357, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #319 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1357, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #320 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1395, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #321 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ApplyQueryOptionTest.cs, Line: 1396, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #322 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\EnableQueryAttributeTest.cs, Line: 273, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #323 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\EnableQueryAttributeTest.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #324 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\AggregationBinderTests.cs, Line: 205, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #325 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\AggregationBinderTests.cs, Line: 247, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\ExpressionStringBuilder.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #327 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1438, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #328 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1472, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #329 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1505, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #330 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1540, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #331 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1574, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #332 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1732, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #333 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1764, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #334 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 1970, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #335 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 2475, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #336 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 3071, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #337 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 3113, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #338 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 842, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #339 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\FilterBinderTests.cs, Line: 866, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #340 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1349, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #341 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1370, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #342 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1395, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #343 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1418, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #344 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1442, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #345 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1473, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #346 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1503, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #347 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Expressions\SelectExpandBinderTest.cs, Line: 1577, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #348 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ODataQueryOptionTest.cs, Line: 483, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #349 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ODataQueryOptionTest.cs, Line: 488, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #350 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\ODataQueryParameterBindingAttributeTests.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #351 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\OrderByPropertyNodeTest.cs, Line: 168, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #352 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\QueryCompositionTests.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #353 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 1017, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #354 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 1091, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #355 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 1366, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #356 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 504, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #357 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 506, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #358 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 516, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #359 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 518, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #360 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 528, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #361 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\FilterQueryValidatorTest.cs, Line: 530, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\OrderByQueryValidatorTest.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #363 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\OrderByQueryValidatorTest.cs, Line: 106, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #364 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\OrderByQueryValidatorTest.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\OrderByQueryValidatorTest.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #366 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Query\Validators\OrderByQueryValidatorTest.cs, Line: 68, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #367 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\QueryableLimitationTest.cs, Line: 254, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #368 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\QueryableLimitationTest.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #369 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\QueryableLimitationTest.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #370 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 297, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #371 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 303, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #372 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 316, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #373 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 317, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #374 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 400, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #375 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 405, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #376 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\AttributeRoutingUnboundTest.cs, Line: 408, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #377 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 1025, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #378 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 1255, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #379 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 1275, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #380 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 1280, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #381 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 2351, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #382 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\DefaultODataPathHandlerTest.cs, Line: 2378, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #383 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\ODataPathRouteConstraintTest.cs, Line: 275, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #384 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\ODataPathRouteConstraintTest.cs, Line: 318, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #385 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\ODataPathRouteConstraintTest.cs, Line: 455, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #386 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\ODataPathRouteConstraintTest.cs, Line: 461, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #387 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\ODataPathRouteConstraintTest.cs, Line: 466, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #388 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\Routing\Template\PathTemplateSegmentTemplateTest.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #389 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\SelectExpandTest.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #390 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\SelectExpandTest.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #391 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\SelectExpandTest.cs, Line: 215, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #392 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\SelectExpandTest.cs, Line: 411, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\TestCommon\EdmTestHelpers.cs, Line: 50, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #394 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\TestCommon\EdmTestHelpers.cs, Line: 69, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #395 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\TestCommon\ODataMediaTypeMapping.cs, Line: 86, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #396 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\TestCommon\TypeInitializer.cs, Line: 15, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #397 Path: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\TestCommon\TypeInitializer.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R8: 185
R9: 119
R4: 49
R7: 25
R2: 14
R5: 3
R3: 1
R6: 1

--- Summary ---
Fixed ReSharper issues: 383
Fixed SonarQube issues: 54
Total fixed issues: 397

Finished in: 35 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\MaxLengthAttributeEdmPropertyConvention.cs
Description: Error: Unable to create valid SyntaxTree for document: MaxLengthAttributeEdmPropertyConvention.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (edmProperty is LengthPropertyConfiguration lengthProperty && attribute is MaxLengthAttribute maxLengthAttribute)
            {
                lengthProperty.MaxLength = maxLengthAttribute.Length;
            }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (edmProperty is LengthPropertyConfiguration lengthProperty && attribute is MaxLengthAttribute maxLengthAttribute)
            {
                lengthProperty.MaxLength = maxLengthAttribute.Length;
            }
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNet.OData.Common;

namespace Microsoft.AspNet.OData.Builder.Conventions.Attributes
{
    /// <summary>
    /// Configures string or binary properties that have the <see cref="MaxLengthAttribute"/>.
    /// </summary>
    internal class MaxLengthAttributeEdmPropertyConvention : AttributeEdmPropertyConvention<StructuralPropertyConfiguration>
    {
        public MaxLengthAttributeEdmPropertyConvention()
            : base(attribute => attribute.GetType() == typeof(MaxLengthAttribute), allowMultiple: false)
        {
        }

        /// <summary>
        /// Configures string or binary propertie's maxLength.
        /// </summary>
        /// <param name="edmProperty">The key property.</param>
        /// <param name="structuralTypeConfiguration">The edm type being configured.</param>
        /// <param name="attribute">The <see cref="Attribute"/> found on the property.</param>
        /// <param name="model">The ODataConventionModelBuilder used to build the model.</param>
        public override void Apply(StructuralPropertyConfiguration edmProperty,
            StructuralTypeConfiguration structuralTypeConfiguration,
            Attribute attribute,
            ODataConventionModelBuilder model)
        {
            if (edmProperty == null)
            {
                throw Error.ArgumentNull("edmProperty");
            }

            MaxLengthAttribute maxLengthAttribute = attribute as MaxLengthAttribute;
            LengthPropertyConfiguration lengthProperty = edmProperty as LengthPropertyConfiguration;
            if (lengthProperty != null && maxLengthAttribute != null)
            {
                lengthProperty.MaxLength = maxLengthAttribute.Length;
            }
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\ColumnAttributeEdmPropertyConvention.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel.DataAnnotations.Schema;
using Microsoft.AspNet.OData.Common;

namespace Microsoft.AspNet.OData.Builder.Conventions.Attributes
{
    /// <summary>
    /// Marks properties that have <see cref="ColumnAttribute"/> as the target EDM type.
    /// </summary>
    internal class ColumnAttributeEdmPropertyConvention : AttributeEdmPropertyConvention<PropertyConfiguration>
    {
        public ColumnAttributeEdmPropertyConvention()
            : base(attribute => attribute.GetType() == typeof(ColumnAttribute), allowMultiple: false)
        {
        }

        /// <summary>
        /// Marks the property with the target EDM type.
        /// </summary>
        /// <param name="edmProperty">The EDM property.</param>
        /// <param name="structuralTypeConfiguration">The EDM type being configured.</param>
        /// <param name="attribute">The <see cref="Attribute"/> found.</param>
        /// <param name="model">The ODataConventionModelBuilder used to build the model.</param>
        public override void Apply(PropertyConfiguration edmProperty, StructuralTypeConfiguration structuralTypeConfiguration,
            Attribute attribute, ODataConventionModelBuilder model)
        {
            if (edmProperty == null)
            {
                throw Error.ArgumentNull("edmProperty");
            }

            if (edmProperty.AddedExplicitly)
            {
                return;
            }

            // Respect order in the column attribute
            var columnAttribute = attribute as ColumnAttribute;
            if (columnAttribute != null && columnAttribute.Order > 0)
            {
                edmProperty.Order = columnAttribute.Order;
            }

            var primitiveProperty = edmProperty as PrimitivePropertyConfiguration;
            if (primitiveProperty == null)
            {
                return; // ignore non-primitive property
            }

            if (columnAttribute == null || columnAttribute.TypeName == null)
            {
                return; // ignore the column type
            }

            string typeName = columnAttribute.TypeName;
            if (String.Compare(typeName, "date", StringComparison.OrdinalIgnoreCase) == 0)
            {
                primitiveProperty.AsDate();
            }
            else if (String.Compare(typeName, "time", StringComparison.OrdinalIgnoreCase) == 0)
            {
                primitiveProperty.AsTimeOfDay();
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.ComponentModel.DataAnnotations.Schema;
using Microsoft.AspNet.OData.Common;

namespace Microsoft.AspNet.OData.Builder.Conventions.Attributes
{
    /// <summary>
    /// Marks properties that have <see cref="ColumnAttribute"/> as the target EDM type.
    /// </summary>
    internal class ColumnAttributeEdmPropertyConvention : AttributeEdmPropertyConvention<PropertyConfiguration>
    {
        public ColumnAttributeEdmPropertyConvention()
            : base(attribute => attribute.GetType() == typeof(ColumnAttribute), allowMultiple: false)
        {
        }

        /// <summary>
        /// Marks the property with the target EDM type.
        /// </summary>
        /// <param name="edmProperty">The EDM property.</param>
        /// <param name="structuralTypeConfiguration">The EDM type being configured.</param>
        /// <param name="attribute">The <see cref="Attribute"/> found.</param>
        /// <param name="model">The ODataConventionModelBuilder used to build the model.</param>
        public override void Apply(PropertyConfiguration edmProperty, StructuralTypeConfiguration structuralTypeConfiguration,
            Attribute attribute, ODataConventionModelBuilder model)
        {
            if (edmProperty == null)
            {
                throw Error.ArgumentNull("edmProperty");
            }

            if (edmProperty.AddedExplicitly)
            {
                return;
            }

            // Respect order in the column attribute
            if (attribute is ColumnAttribute columnAttribute && columnAttribute.Order > 0)
            {
                edmProperty.Order = columnAttribute.Order;
            }

            var primitiveProperty = edmProperty as PrimitivePropertyConfiguration;
            if (primitiveProperty == null)
            {
                return; // ignore non-primitive property
            }

            if (columnAttribute == null || columnAttribute.TypeName == null)
            {
                return; // ignore the column type
            }

            string typeName = columnAttribute.TypeName;
            if (String.Compare(typeName, "date", StringComparison.OrdinalIgnoreCase) == 0)
            {
                primitiveProperty.AsDate();
            }
            else if (String.Compare(typeName, "time", StringComparison.OrdinalIgnoreCase) == 0)
            {
                primitiveProperty.AsTimeOfDay();
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\ColumnAttributeEdmPropertyConvention.cs(52,17): error CS0165: Use of unassigned local variable 'columnAttribute'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\EnableQueryAttribute.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Net;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Interfaces;
using Microsoft.AspNet.OData.Query;
using Microsoft.AspNet.OData.Routing;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData
{
    /// <summary>
    /// Partial implementation of the EnableQueryAttribute.
    /// </summary>
    public partial class EnableQueryAttribute
    {
        private const char CommaSeparator = ',';

        // validation settings
        private ODataValidationSettings _validationSettings;
        private string _allowedOrderByProperties;

        // query settings
        private ODataQuerySettings _querySettings;

        /// <summary>
        /// Enables a controller action to support OData query parameters.
        /// </summary>
        public EnableQueryAttribute()
        {
            _validationSettings = new ODataValidationSettings();
            _querySettings = new ODataQuerySettings();
        }

        /// <summary>
        /// Gets or sets a value indicating whether query composition should
        /// alter the original query when necessary to ensure a stable sort order.
        /// </summary>
        /// <value>A <c>true</c> value indicates the original query should
        /// be modified when necessary to guarantee a stable sort order.
        /// A <c>false</c> value indicates the sort order can be considered
        /// stable without modifying the query.  Query providers that ensure
        /// a stable sort order should set this value to <c>false</c>.
        /// The default value is <c>true</c>.</value>
        public bool EnsureStableOrdering
        {
            get
            {
                return _querySettings.EnsureStableOrdering;
            }
            set
            {
                _querySettings.EnsureStableOrdering = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating how null propagation should
        /// be handled during query composition.
        /// </summary>
        /// <value>
        /// The default is <see cref="HandleNullPropagationOption.Default"/>.
        /// </value>
        public HandleNullPropagationOption HandleNullPropagation
        {
            get
            {
                return _querySettings.HandleNullPropagation;
            }
            set
            {
                _querySettings.HandleNullPropagation = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether constants should be parameterized. Parameterizing constants
        /// would result in better performance with Entity framework.
        /// </summary>
        /// <value>The default value is <c>true</c>.</value>
        public bool EnableConstantParameterization
        {
            get
            {
                return _querySettings.EnableConstantParameterization;
            }
            set
            {
                _querySettings.EnableConstantParameterization = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether queries with expanded navigations should be formulated
        /// to encourage correlated subquery results to be buffered.
        /// Buffering correlated subquery results can reduce the number of queries from N + 1 to 2
        /// by buffering results from the subquery.
        /// </summary>
        /// <value>The default value is <c>false</c>.</value>
        public bool EnableCorrelatedSubqueryBuffering
        {
            get
            {
                return _querySettings.EnableCorrelatedSubqueryBuffering;
            }
            set
            {
                _querySettings.EnableCorrelatedSubqueryBuffering = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth of the Any or All elements nested inside the query. This limit helps prevent
        /// Denial of Service attacks.
        /// </summary>
        /// <value>
        /// The maximum depth of the Any or All elements nested inside the query. The default value is 1.
        /// </value>
        public int MaxAnyAllExpressionDepth
        {
            get
            {
                return _validationSettings.MaxAnyAllExpressionDepth;
            }
            set
            {
                _validationSettings.MaxAnyAllExpressionDepth = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of nodes inside the $filter syntax tree.
        /// </summary>
        /// <value>The default value is 100.</value>
        public int MaxNodeCount
        {
            get
            {
                return _validationSettings.MaxNodeCount;
            }
            set
            {
                _validationSettings.MaxNodeCount = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of query results to send back to clients.
        /// </summary>
        /// <value>
        /// The maximum number of query results to send back to clients.
        /// </value>
        public int PageSize
        {
            get
            {
                return _querySettings.PageSize ?? default(int);
            }
            set
            {
                _querySettings.PageSize = value;
            }
        }

        /// <summary>
        /// Honor $filter inside $expand of non-collection navigation property.
        /// The expanded property is only populated when the filter evaluates to true.
        /// This setting is false by default.
        /// </summary>
        public bool HandleReferenceNavigationPropertyExpandFilter
        {
            get
            {
                return _querySettings.HandleReferenceNavigationPropertyExpandFilter;
            }
            set
            {
                _querySettings.HandleReferenceNavigationPropertyExpandFilter = value;
            }
        }

        /// <summary>
        /// Gets or sets the query parameters that are allowed in queries.
        /// </summary>
        /// <value>The default includes all query options: $filter, $skip, $top, $orderby, $expand, $select, $count,
        /// $format, $skiptoken and $deltatoken.</value>
        public AllowedQueryOptions AllowedQueryOptions
        {
            get
            {
                return _validationSettings.AllowedQueryOptions;
            }
            set
            {
                _validationSettings.AllowedQueryOptions = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed functions used in the $filter query. Supported
        /// functions include the following:
        /// <list type="definition">
        /// <item>
        /// <term>String related:</term>
        /// <description>contains, endswith, startswith, length, indexof, substring, tolower, toupper, trim,
        /// concat e.g. ~/Customers?$filter=length(CompanyName) eq 19</description>
        /// </item>
        /// <item>
        /// <term>DateTime related:</term>
        /// <description>year, month, day, hour, minute, second, fractionalseconds, date, time
        /// e.g. ~/Employees?$filter=year(BirthDate) eq 1971</description>
        /// </item>
        /// <item>
        /// <term>Math related:</term>
        /// <description>round, floor, ceiling</description>
        /// </item>
        /// <item>
        /// <term>Type related:</term>
        /// <description>isof, cast</description>
        /// </item>
        /// <item>
        /// <term>Collection related:</term>
        /// <description>any, all</description>
        /// </item>
        /// </list>
        /// </summary>
        public AllowedFunctions AllowedFunctions
        {
            get
            {
                return _validationSettings.AllowedFunctions;
            }
            set
            {
                _validationSettings.AllowedFunctions = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed arithmetic operators including 'add', 'sub', 'mul',
        /// 'div', 'mod'.
        /// </summary>
        public AllowedArithmeticOperators AllowedArithmeticOperators
        {
            get
            {
                return _validationSettings.AllowedArithmeticOperators;
            }
            set
            {
                _validationSettings.AllowedArithmeticOperators = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed logical Operators such as 'eq', 'ne', 'gt', 'ge',
        /// 'lt', 'le', 'and', 'or', 'not'.
        /// </summary>
        public AllowedLogicalOperators AllowedLogicalOperators
        {
            get
            {
                return _validationSettings.AllowedLogicalOperators;
            }
            set
            {
                _validationSettings.AllowedLogicalOperators = value;
            }
        }

        /// <summary>
        /// <para>Gets or sets a string with comma separated list of property names. The queryable result can only be
        /// ordered by those properties defined in this list.</para>
        ///
        /// <para>Note, by default this string is null, which means it can be ordered by any property.</para>
        ///
        /// <para>For example, setting this value to null or empty string means that we allow ordering the queryable
        /// result by any properties. Setting this value to "Name" means we only allow queryable result to be ordered
        /// by Name property.</para>
        /// </summary>
        public string AllowedOrderByProperties
        {
            get
            {
                return _allowedOrderByProperties;
            }
            set
            {
                _allowedOrderByProperties = value;

                if (String.IsNullOrEmpty(value))
                {
                    _validationSettings.AllowedOrderByProperties.Clear();
                }
                else
                {
                    // now parse the value and set it to validationSettings
                    string[] properties = _allowedOrderByProperties.Split(CommaSeparator);
                    for (int i = 0; i < properties.Length; i++)
                    {
                        _validationSettings.AllowedOrderByProperties.Add(properties[i].Trim());
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the max value of $skip that a client can request.
        /// </summary>
        public int MaxSkip
        {
            get
            {
                return _validationSettings.MaxSkip ?? default(int);
            }
            set
            {
                _validationSettings.MaxSkip = value;
            }
        }

        /// <summary>
        /// Gets or sets the max value of $top that a client can request.
        /// </summary>
        public int MaxTop
        {
            get
            {
                return _validationSettings.MaxTop ?? default(int);
            }
            set
            {
                _validationSettings.MaxTop = value;
            }
        }

        /// <summary>
        /// Gets or sets the max expansion depth for the $expand query option. To disable the maximum expansion depth
        /// check, set this property to 0.
        /// </summary>
        public int MaxExpansionDepth
        {
            get { return _validationSettings.MaxExpansionDepth; }
            set
            {
                _validationSettings.MaxExpansionDepth = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of expressions that can be present in the $orderby.
        /// </summary>
        public int MaxOrderByNodeCount
        {
            get { return _validationSettings.MaxOrderByNodeCount; }
            set
            {
                _validationSettings.MaxOrderByNodeCount = value;
            }
        }

        /// <summary>
        /// Performs the query composition after action is executed. It first tries to retrieve the IQueryable from the
        /// returning response message. It then validates the query from uri based on the validation settings on
        /// <see cref="EnableQueryAttribute"/>. It finally applies the query appropriately, and reset it back on
        /// the response message.
        /// </summary>
        /// <param name="responseValue">The response content value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="request">The internal request.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="createQueryOptionFunction">A function used to create and validate query options.</param>
        /// <param name="createResponseAction">An action used to create a response.</param>
        /// <param name="createErrorAction">A function used to generate error response.</param>
        private object OnActionExecuted(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            IWebApiRequestMessage request,
            Func<Type, IEdmModel> modelFunction,
            Func<ODataQueryContext, ODataQueryOptions> createQueryOptionFunction,
            Action<HttpStatusCode> createResponseAction,
            Action<HttpStatusCode, string, Exception> createErrorAction)
        {
            if (!_querySettings.PageSize.HasValue && responseValue != null)
            {
                GetModelBoundPageSize(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path, createErrorAction);
            }

            // Apply the query if there are any query options, if there is a page size set, in the case of
            // SingleResult or in the case of $count request.
            bool shouldApplyQuery = responseValue != null &&
                request.RequestUri != null &&
                (!String.IsNullOrWhiteSpace(request.RequestUri.Query) ||
                _querySettings.PageSize.HasValue ||
                _querySettings.ModelBoundPageSize.HasValue ||
                singleResultCollection != null ||
                request.IsCountRequest() ||
                ContainsAutoSelectExpandProperty(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path));

            object returnValue = null;
            if (shouldApplyQuery)
            {
                try
                {
                    object queryResult = ExecuteQuery(responseValue, singleResultCollection, actionDescriptor, modelFunction, request, createQueryOptionFunction);
                    if (queryResult == null && (request.Context.Path == null || singleResultCollection != null))
                    {
                        // This is the case in which a regular OData service uses the EnableQuery attribute.
                        // For OData services ODataNullValueMessageHandler should be plugged in for the service
                        // if this behavior is desired.
                        // For non OData services this behavior is equivalent as the one in the v3 version in order
                        // to reduce the friction when they decide to move to use the v4 EnableQueryAttribute.
                        createResponseAction(HttpStatusCode.NotFound);
                    }

                    returnValue = queryResult;
                }
                catch (ArgumentOutOfRangeException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.QueryParameterNotSupported, e.Message),
                        e);
                }
                catch (NotImplementedException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
                catch (NotSupportedException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
                catch (InvalidOperationException e)
                {
                    // Will also catch ODataException here because ODataException derives from InvalidOperationException.
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Applies the query to the given IQueryable based on incoming query from uri and query settings. By default,
        /// the implementation supports $top, $skip, $orderby and $filter. Override this method to perform additional
        /// query composition of the query.
        /// </summary>
        /// <param name="queryable">The original queryable instance from the response message.</param>
        /// <param name="queryOptions">
        /// The <see cref="ODataQueryOptions"/> instance constructed based on the incoming request.
        /// </param>
        public virtual IQueryable ApplyQuery(IQueryable queryable, ODataQueryOptions queryOptions)
        {
            if (queryable == null)
            {
                throw Error.ArgumentNull("queryable");
            }
            if (queryOptions == null)
            {
                throw Error.ArgumentNull("queryOptions");
            }

            return queryOptions.ApplyTo(queryable, _querySettings);
        }

        /// <summary>
        /// Applies the query to the given entity based on incoming query from uri and query settings.
        /// </summary>
        /// <param name="entity">The original entity from the response message.</param>
        /// <param name="queryOptions">
        /// The <see cref="ODataQueryOptions"/> instance constructed based on the incoming request.
        /// </param>
        /// <returns>The new entity after the $select and $expand query has been applied to.</returns>
        public virtual object ApplyQuery(object entity, ODataQueryOptions queryOptions)
        {
            if (entity == null)
            {
                throw Error.ArgumentNull("entity");
            }
            if (queryOptions == null)
            {
                throw Error.ArgumentNull("queryOptions");
            }

            return queryOptions.ApplyTo(entity, _querySettings);
        }

        /// <summary>
        /// Get the ODaya query context.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <returns></returns>
        private static ODataQueryContext GetODataQueryContext(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path)
        {
            Type elementClrType = GetElementType(responseValue, singleResultCollection, actionDescriptor);

            IEdmModel model = modelFunction(elementClrType);
            if (model == null)
            {
                throw Error.InvalidOperation(SRResources.QueryGetModelMustNotReturnNull);
            }

            return new ODataQueryContext(model, elementClrType, path);
        }

        /// <summary>
        /// Get the page size.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <param name="createErrorAction">A function used to generate error response.</param>
        private void GetModelBoundPageSize(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path,
            Action<HttpStatusCode, string, Exception> createErrorAction)
        {
            ODataQueryContext queryContext = null;

            try
            {
                queryContext = GetODataQueryContext(responseValue, singleResultCollection, actionDescriptor, modelFunction, path);
            }
            catch (InvalidOperationException e)
            {
                createErrorAction(
                    HttpStatusCode.BadRequest,
                    Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                    e);
                return;
            }

            ModelBoundQuerySettings querySettings = EdmLibHelpers.GetModelBoundQuerySettings(queryContext.TargetProperty,
                queryContext.TargetStructuredType,
                queryContext.Model);
            if (querySettings != null && querySettings.PageSize.HasValue)
            {
                _querySettings.ModelBoundPageSize = querySettings.PageSize;
            }
        }

        /// <summary>
        /// Execute the query.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="request">The internal request.</param>
        /// <param name="createQueryOptionFunction">A function used to create and validate query options.</param>
        /// <returns></returns>
        private object ExecuteQuery(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            IWebApiRequestMessage request,
            Func<ODataQueryContext, ODataQueryOptions> createQueryOptionFunction)
        {
            ODataQueryContext queryContext = GetODataQueryContext(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path);

            // Create and validate the query options.
            ODataQueryOptions queryOptions = createQueryOptionFunction(queryContext);

            // apply the query
            IEnumerable enumerable = responseValue as IEnumerable;
            if (enumerable == null || responseValue is string || responseValue is byte[])
            {
                // response is not a collection; we only support $select and $expand on single entities.
                ValidateSelectExpandOnly(queryOptions);

                if (singleResultCollection == null)
                {
                    // response is a single entity.
                    return ApplyQuery(entity: responseValue, queryOptions: queryOptions);
                }
                else
                {
                    IQueryable queryable = singleResultCollection as IQueryable;
                    queryable = ApplyQuery(queryable, queryOptions);
                    return SingleOrDefault(queryable, actionDescriptor);
                }
            }
            else
            {
                // response is a collection.
                IQueryable queryable = (enumerable as IQueryable) ?? enumerable.AsQueryable();
                queryable = ApplyQuery(queryable, queryOptions);

                if (request.IsCountRequest())
                {
                    long? count = request.Context.TotalCount;

                    if (count.HasValue)
                    {
                        // Return the count value if it is a $count request.
                        return count.Value;
                    }
                }

                return queryable;
            }
        }

        /// <summary>
        /// Get the element type.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <returns></returns>
        internal static Type GetElementType(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor)
        {
            Contract.Assert(responseValue != null);

            IEnumerable enumerable = responseValue as IEnumerable;
            if (enumerable == null)
            {
                if (singleResultCollection == null)
                {
                    return responseValue.GetType();
                }

                enumerable = singleResultCollection as IEnumerable;
            }

            Type elementClrType = TypeHelper.GetImplementedIEnumerableType(enumerable.GetType());
            if (elementClrType == null)
            {
                // The element type cannot be determined because the type of the content
                // is not IEnumerable<T> or IQueryable<T>.
                throw Error.InvalidOperation(
                    SRResources.FailedToRetrieveTypeToBuildEdmModel,
                    typeof(EnableQueryAttribute).Name,
                    actionDescriptor.ActionName,
                    actionDescriptor.ControllerName,
                    responseValue.GetType().FullName);
            }

            return elementClrType;
        }

        /// <summary>
        /// Get a single or default value from a collection.
        /// </summary>
        /// <param name="queryable">The response value as <see cref="IQueryable"/>.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <returns></returns>
        internal static object SingleOrDefault(
            IQueryable queryable,
            IWebApiActionDescriptor actionDescriptor)
        {
            var enumerator = queryable.GetEnumerator();
            try
            {
                var result = enumerator.MoveNext() ? enumerator.Current : null;

                if (enumerator.MoveNext())
                {
                    throw new InvalidOperationException(Error.Format(
                        SRResources.SingleResultHasMoreThanOneEntity,
                        actionDescriptor.ActionName,
                        actionDescriptor.ControllerName,
                        "SingleResult"));
                }

                return result;
            }
            finally
            {
                // Ensure any active/open database objects that were created
                // iterating over the IQueryable object are properly closed.
                var disposable = enumerator as IDisposable;
                disposable?.Dispose();
            }
        }

        /// <summary>
        /// Validate the select and expand options.
        /// </summary>
        /// <param name="queryOptions">The query options.</param>
        internal static void ValidateSelectExpandOnly(ODataQueryOptions queryOptions)
        {
            if (queryOptions.Filter != null || queryOptions.Count != null || queryOptions.OrderBy != null
                || queryOptions.Skip != null || queryOptions.Top != null)
            {
                throw new ODataException(Error.Format(SRResources.NonSelectExpandOnSingleEntity));
            }
        }

        /// <summary>
        /// Determine if the 
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <returns></returns>
        private static bool ContainsAutoSelectExpandProperty(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path)
        {
            Type elementClrType = GetElementType(responseValue, singleResultCollection, actionDescriptor);

            IEdmModel model = modelFunction(elementClrType);
            if (model == null)
            {
                throw Error.InvalidOperation(SRResources.QueryGetModelMustNotReturnNull);
            }

            IEdmType edmType = model.GetTypeMappingCache().GetEdmType(elementClrType, model)?.Definition;
            IEdmEntityType baseEntityType = edmType as IEdmEntityType;
            IEdmStructuredType structuredType = edmType as IEdmStructuredType;
            IEdmProperty property = null;
            if (path != null)
            {
                string name;
                EdmLibHelpers.GetPropertyAndStructuredTypeFromPath(path.Segments, out property,
                    out structuredType,
                    out name);
            }

            if (baseEntityType != null)
            {
                List<IEdmEntityType> entityTypes = new List<IEdmEntityType>();
                entityTypes.Add(baseEntityType);
                entityTypes.AddRange(EdmLibHelpers.GetAllDerivedEntityTypes(baseEntityType, model));
                foreach (var entityType in entityTypes)
                {
                    IEnumerable<IEdmNavigationProperty> navigationProperties = entityType == baseEntityType
                        ? entityType.NavigationProperties()
                        : entityType.DeclaredNavigationProperties();
                    if (navigationProperties != null)
                    {
                        if (navigationProperties.Any(
                                navigationProperty =>
                                    EdmLibHelpers.IsAutoExpand(navigationProperty, property, entityType, model)))
                        {
                            return true;
                        }
                    }

                    IEnumerable<IEdmStructuralProperty> properties = entityType == baseEntityType
                        ? entityType.StructuralProperties()
                        : entityType.DeclaredStructuralProperties();
                    if (properties != null)
                    {
                        foreach (var edmProperty in properties)
                        {
                            if (EdmLibHelpers.IsAutoSelect(edmProperty, property, entityType, model))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else if (structuredType != null)
            {
                IEnumerable<IEdmStructuralProperty> properties = structuredType.StructuralProperties();
                if (properties != null)
                {
                    foreach (var edmProperty in properties)
                    {
                        if (EdmLibHelpers.IsAutoSelect(edmProperty, property, structuredType, model))
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
   }
}
---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Net;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Interfaces;
using Microsoft.AspNet.OData.Query;
using Microsoft.AspNet.OData.Routing;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData
{
    /// <summary>
    /// Partial implementation of the EnableQueryAttribute.
    /// </summary>
    public partial class EnableQueryAttribute
    {
        private const char CommaSeparator = ',';

        // validation settings
        private ODataValidationSettings _validationSettings;
        private string _allowedOrderByProperties;

        // query settings
        private ODataQuerySettings _querySettings;

        /// <summary>
        /// Enables a controller action to support OData query parameters.
        /// </summary>
        public EnableQueryAttribute()
        {
            _validationSettings = new ODataValidationSettings();
            _querySettings = new ODataQuerySettings();
        }

        /// <summary>
        /// Gets or sets a value indicating whether query composition should
        /// alter the original query when necessary to ensure a stable sort order.
        /// </summary>
        /// <value>A <c>true</c> value indicates the original query should
        /// be modified when necessary to guarantee a stable sort order.
        /// A <c>false</c> value indicates the sort order can be considered
        /// stable without modifying the query.  Query providers that ensure
        /// a stable sort order should set this value to <c>false</c>.
        /// The default value is <c>true</c>.</value>
        public bool EnsureStableOrdering
        {
            get
            {
                return _querySettings.EnsureStableOrdering;
            }
            set
            {
                _querySettings.EnsureStableOrdering = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating how null propagation should
        /// be handled during query composition.
        /// </summary>
        /// <value>
        /// The default is <see cref="HandleNullPropagationOption.Default"/>.
        /// </value>
        public HandleNullPropagationOption HandleNullPropagation
        {
            get
            {
                return _querySettings.HandleNullPropagation;
            }
            set
            {
                _querySettings.HandleNullPropagation = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether constants should be parameterized. Parameterizing constants
        /// would result in better performance with Entity framework.
        /// </summary>
        /// <value>The default value is <c>true</c>.</value>
        public bool EnableConstantParameterization
        {
            get
            {
                return _querySettings.EnableConstantParameterization;
            }
            set
            {
                _querySettings.EnableConstantParameterization = value;
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether queries with expanded navigations should be formulated
        /// to encourage correlated subquery results to be buffered.
        /// Buffering correlated subquery results can reduce the number of queries from N + 1 to 2
        /// by buffering results from the subquery.
        /// </summary>
        /// <value>The default value is <c>false</c>.</value>
        public bool EnableCorrelatedSubqueryBuffering
        {
            get
            {
                return _querySettings.EnableCorrelatedSubqueryBuffering;
            }
            set
            {
                _querySettings.EnableCorrelatedSubqueryBuffering = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth of the Any or All elements nested inside the query. This limit helps prevent
        /// Denial of Service attacks.
        /// </summary>
        /// <value>
        /// The maximum depth of the Any or All elements nested inside the query. The default value is 1.
        /// </value>
        public int MaxAnyAllExpressionDepth
        {
            get
            {
                return _validationSettings.MaxAnyAllExpressionDepth;
            }
            set
            {
                _validationSettings.MaxAnyAllExpressionDepth = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of nodes inside the $filter syntax tree.
        /// </summary>
        /// <value>The default value is 100.</value>
        public int MaxNodeCount
        {
            get
            {
                return _validationSettings.MaxNodeCount;
            }
            set
            {
                _validationSettings.MaxNodeCount = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of query results to send back to clients.
        /// </summary>
        /// <value>
        /// The maximum number of query results to send back to clients.
        /// </value>
        public int PageSize
        {
            get
            {
                return _querySettings.PageSize ?? default(int);
            }
            set
            {
                _querySettings.PageSize = value;
            }
        }

        /// <summary>
        /// Honor $filter inside $expand of non-collection navigation property.
        /// The expanded property is only populated when the filter evaluates to true.
        /// This setting is false by default.
        /// </summary>
        public bool HandleReferenceNavigationPropertyExpandFilter
        {
            get
            {
                return _querySettings.HandleReferenceNavigationPropertyExpandFilter;
            }
            set
            {
                _querySettings.HandleReferenceNavigationPropertyExpandFilter = value;
            }
        }

        /// <summary>
        /// Gets or sets the query parameters that are allowed in queries.
        /// </summary>
        /// <value>The default includes all query options: $filter, $skip, $top, $orderby, $expand, $select, $count,
        /// $format, $skiptoken and $deltatoken.</value>
        public AllowedQueryOptions AllowedQueryOptions
        {
            get
            {
                return _validationSettings.AllowedQueryOptions;
            }
            set
            {
                _validationSettings.AllowedQueryOptions = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed functions used in the $filter query. Supported
        /// functions include the following:
        /// <list type="definition">
        /// <item>
        /// <term>String related:</term>
        /// <description>contains, endswith, startswith, length, indexof, substring, tolower, toupper, trim,
        /// concat e.g. ~/Customers?$filter=length(CompanyName) eq 19</description>
        /// </item>
        /// <item>
        /// <term>DateTime related:</term>
        /// <description>year, month, day, hour, minute, second, fractionalseconds, date, time
        /// e.g. ~/Employees?$filter=year(BirthDate) eq 1971</description>
        /// </item>
        /// <item>
        /// <term>Math related:</term>
        /// <description>round, floor, ceiling</description>
        /// </item>
        /// <item>
        /// <term>Type related:</term>
        /// <description>isof, cast</description>
        /// </item>
        /// <item>
        /// <term>Collection related:</term>
        /// <description>any, all</description>
        /// </item>
        /// </list>
        /// </summary>
        public AllowedFunctions AllowedFunctions
        {
            get
            {
                return _validationSettings.AllowedFunctions;
            }
            set
            {
                _validationSettings.AllowedFunctions = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed arithmetic operators including 'add', 'sub', 'mul',
        /// 'div', 'mod'.
        /// </summary>
        public AllowedArithmeticOperators AllowedArithmeticOperators
        {
            get
            {
                return _validationSettings.AllowedArithmeticOperators;
            }
            set
            {
                _validationSettings.AllowedArithmeticOperators = value;
            }
        }

        /// <summary>
        /// Gets or sets a value that represents a list of allowed logical Operators such as 'eq', 'ne', 'gt', 'ge',
        /// 'lt', 'le', 'and', 'or', 'not'.
        /// </summary>
        public AllowedLogicalOperators AllowedLogicalOperators
        {
            get
            {
                return _validationSettings.AllowedLogicalOperators;
            }
            set
            {
                _validationSettings.AllowedLogicalOperators = value;
            }
        }

        /// <summary>
        /// <para>Gets or sets a string with comma separated list of property names. The queryable result can only be
        /// ordered by those properties defined in this list.</para>
        ///
        /// <para>Note, by default this string is null, which means it can be ordered by any property.</para>
        ///
        /// <para>For example, setting this value to null or empty string means that we allow ordering the queryable
        /// result by any properties. Setting this value to "Name" means we only allow queryable result to be ordered
        /// by Name property.</para>
        /// </summary>
        public string AllowedOrderByProperties
        {
            get
            {
                return _allowedOrderByProperties;
            }
            set
            {
                _allowedOrderByProperties = value;

                if (String.IsNullOrEmpty(value))
                {
                    _validationSettings.AllowedOrderByProperties.Clear();
                }
                else
                {
                    // now parse the value and set it to validationSettings
                    string[] properties = _allowedOrderByProperties.Split(CommaSeparator);
                    for (int i = 0; i < properties.Length; i++)
                    {
                        _validationSettings.AllowedOrderByProperties.Add(properties[i].Trim());
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the max value of $skip that a client can request.
        /// </summary>
        public int MaxSkip
        {
            get
            {
                return _validationSettings.MaxSkip ?? default(int);
            }
            set
            {
                _validationSettings.MaxSkip = value;
            }
        }

        /// <summary>
        /// Gets or sets the max value of $top that a client can request.
        /// </summary>
        public int MaxTop
        {
            get
            {
                return _validationSettings.MaxTop ?? default(int);
            }
            set
            {
                _validationSettings.MaxTop = value;
            }
        }

        /// <summary>
        /// Gets or sets the max expansion depth for the $expand query option. To disable the maximum expansion depth
        /// check, set this property to 0.
        /// </summary>
        public int MaxExpansionDepth
        {
            get { return _validationSettings.MaxExpansionDepth; }
            set
            {
                _validationSettings.MaxExpansionDepth = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum number of expressions that can be present in the $orderby.
        /// </summary>
        public int MaxOrderByNodeCount
        {
            get { return _validationSettings.MaxOrderByNodeCount; }
            set
            {
                _validationSettings.MaxOrderByNodeCount = value;
            }
        }

        /// <summary>
        /// Performs the query composition after action is executed. It first tries to retrieve the IQueryable from the
        /// returning response message. It then validates the query from uri based on the validation settings on
        /// <see cref="EnableQueryAttribute"/>. It finally applies the query appropriately, and reset it back on
        /// the response message.
        /// </summary>
        /// <param name="responseValue">The response content value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="request">The internal request.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="createQueryOptionFunction">A function used to create and validate query options.</param>
        /// <param name="createResponseAction">An action used to create a response.</param>
        /// <param name="createErrorAction">A function used to generate error response.</param>
        private object OnActionExecuted(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            IWebApiRequestMessage request,
            Func<Type, IEdmModel> modelFunction,
            Func<ODataQueryContext, ODataQueryOptions> createQueryOptionFunction,
            Action<HttpStatusCode> createResponseAction,
            Action<HttpStatusCode, string, Exception> createErrorAction)
        {
            if (!_querySettings.PageSize.HasValue && responseValue != null)
            {
                GetModelBoundPageSize(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path, createErrorAction);
            }

            // Apply the query if there are any query options, if there is a page size set, in the case of
            // SingleResult or in the case of $count request.
            bool shouldApplyQuery = responseValue != null &&
                request.RequestUri != null &&
                (!String.IsNullOrWhiteSpace(request.RequestUri.Query) ||
                _querySettings.PageSize.HasValue ||
                _querySettings.ModelBoundPageSize.HasValue ||
                singleResultCollection != null ||
                request.IsCountRequest() ||
                ContainsAutoSelectExpandProperty(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path));

            object returnValue = null;
            if (shouldApplyQuery)
            {
                try
                {
                    object queryResult = ExecuteQuery(responseValue, singleResultCollection, actionDescriptor, modelFunction, request, createQueryOptionFunction);
                    if (queryResult == null && (request.Context.Path == null || singleResultCollection != null))
                    {
                        // This is the case in which a regular OData service uses the EnableQuery attribute.
                        // For OData services ODataNullValueMessageHandler should be plugged in for the service
                        // if this behavior is desired.
                        // For non OData services this behavior is equivalent as the one in the v3 version in order
                        // to reduce the friction when they decide to move to use the v4 EnableQueryAttribute.
                        createResponseAction(HttpStatusCode.NotFound);
                    }

                    returnValue = queryResult;
                }
                catch (ArgumentOutOfRangeException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.QueryParameterNotSupported, e.Message),
                        e);
                }
                catch (NotImplementedException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
                catch (NotSupportedException e)
                {
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
                catch (InvalidOperationException e)
                {
                    // Will also catch ODataException here because ODataException derives from InvalidOperationException.
                    createErrorAction(
                        HttpStatusCode.BadRequest,
                        Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                        e);
                }
            }

            return returnValue;
        }

        /// <summary>
        /// Applies the query to the given IQueryable based on incoming query from uri and query settings. By default,
        /// the implementation supports $top, $skip, $orderby and $filter. Override this method to perform additional
        /// query composition of the query.
        /// </summary>
        /// <param name="queryable">The original queryable instance from the response message.</param>
        /// <param name="queryOptions">
        /// The <see cref="ODataQueryOptions"/> instance constructed based on the incoming request.
        /// </param>
        public virtual IQueryable ApplyQuery(IQueryable queryable, ODataQueryOptions queryOptions)
        {
            if (queryable == null)
            {
                throw Error.ArgumentNull("queryable");
            }
            if (queryOptions == null)
            {
                throw Error.ArgumentNull("queryOptions");
            }

            return queryOptions.ApplyTo(queryable, _querySettings);
        }

        /// <summary>
        /// Applies the query to the given entity based on incoming query from uri and query settings.
        /// </summary>
        /// <param name="entity">The original entity from the response message.</param>
        /// <param name="queryOptions">
        /// The <see cref="ODataQueryOptions"/> instance constructed based on the incoming request.
        /// </param>
        /// <returns>The new entity after the $select and $expand query has been applied to.</returns>
        public virtual object ApplyQuery(object entity, ODataQueryOptions queryOptions)
        {
            if (entity == null)
            {
                throw Error.ArgumentNull("entity");
            }
            if (queryOptions == null)
            {
                throw Error.ArgumentNull("queryOptions");
            }

            return queryOptions.ApplyTo(entity, _querySettings);
        }

        /// <summary>
        /// Get the ODaya query context.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <returns></returns>
        private static ODataQueryContext GetODataQueryContext(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path)
        {
            Type elementClrType = GetElementType(responseValue, singleResultCollection, actionDescriptor);

            IEdmModel model = modelFunction(elementClrType);
            if (model == null)
            {
                throw Error.InvalidOperation(SRResources.QueryGetModelMustNotReturnNull);
            }

            return new ODataQueryContext(model, elementClrType, path);
        }

        /// <summary>
        /// Get the page size.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <param name="createErrorAction">A function used to generate error response.</param>
        private void GetModelBoundPageSize(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path,
            Action<HttpStatusCode, string, Exception> createErrorAction)
        {
            ODataQueryContext queryContext = null;

            try
            {
                queryContext = GetODataQueryContext(responseValue, singleResultCollection, actionDescriptor, modelFunction, path);
            }
            catch (InvalidOperationException e)
            {
                createErrorAction(
                    HttpStatusCode.BadRequest,
                    Error.Format(SRResources.UriQueryStringInvalid, e.Message),
                    e);
                return;
            }

            ModelBoundQuerySettings querySettings = EdmLibHelpers.GetModelBoundQuerySettings(queryContext.TargetProperty,
                queryContext.TargetStructuredType,
                queryContext.Model);
            if (querySettings != null && querySettings.PageSize.HasValue)
            {
                _querySettings.ModelBoundPageSize = querySettings.PageSize;
            }
        }

        /// <summary>
        /// Execute the query.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="request">The internal request.</param>
        /// <param name="createQueryOptionFunction">A function used to create and validate query options.</param>
        /// <returns></returns>
        private object ExecuteQuery(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            IWebApiRequestMessage request,
            Func<ODataQueryContext, ODataQueryOptions> createQueryOptionFunction)
        {
            ODataQueryContext queryContext = GetODataQueryContext(responseValue, singleResultCollection, actionDescriptor, modelFunction, request.Context.Path);

            // Create and validate the query options.
            ODataQueryOptions queryOptions = createQueryOptionFunction(queryContext);

            // apply the query
            IEnumerable enumerable = responseValue as IEnumerable;
            if (enumerable == null || responseValue is string || responseValue is byte[])
            {
                // response is not a collection; we only support $select and $expand on single entities.
                ValidateSelectExpandOnly(queryOptions);

                if (singleResultCollection == null)
                {
                    // response is a single entity.
                    return ApplyQuery(entity: responseValue, queryOptions: queryOptions);
                }
                else
                {
                    IQueryable queryable = singleResultCollection as IQueryable;
                    queryable = ApplyQuery(queryable, queryOptions);
                    return SingleOrDefault(queryable, actionDescriptor);
                }
            }
            else
            {
                // response is a collection.
                IQueryable queryable = (enumerable as IQueryable) ?? enumerable.AsQueryable();
                queryable = ApplyQuery(queryable, queryOptions);

                if (request.IsCountRequest())
                {
                    long? count = request.Context.TotalCount;

                    if (count.HasValue)
                    {
                        // Return the count value if it is a $count request.
                        return count.Value;
                    }
                }

                return queryable;
            }
        }

        /// <summary>
        /// Get the element type.
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <returns></returns>
        internal static Type GetElementType(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor)
        {
            Contract.Assert(responseValue != null);

            IEnumerable enumerable = responseValue as IEnumerable;
            if (enumerable == null)
            {
                if (singleResultCollection == null)
                {
                    return responseValue.GetType();
                }

                enumerable = singleResultCollection as IEnumerable;
            }

            Type elementClrType = TypeHelper.GetImplementedIEnumerableType(enumerable.GetType());
            if (elementClrType == null)
            {
                // The element type cannot be determined because the type of the content
                // is not IEnumerable<T> or IQueryable<T>.
                throw Error.InvalidOperation(
                    SRResources.FailedToRetrieveTypeToBuildEdmModel,
                    typeof(EnableQueryAttribute).Name,
                    actionDescriptor.ActionName,
                    actionDescriptor.ControllerName,
                    responseValue.GetType().FullName);
            }

            return elementClrType;
        }

        /// <summary>
        /// Get a single or default value from a collection.
        /// </summary>
        /// <param name="queryable">The response value as <see cref="IQueryable"/>.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <returns></returns>
        internal static object SingleOrDefault(
            IQueryable queryable,
            IWebApiActionDescriptor actionDescriptor)
        {
            var enumerator = queryable.GetEnumerator();
            try
            {
                var result = enumerator.MoveNext() ? enumerator.Current : null;

                if (enumerator.MoveNext())
                {
                    throw new InvalidOperationException(Error.Format(
                        SRResources.SingleResultHasMoreThanOneEntity,
                        actionDescriptor.ActionName,
                        actionDescriptor.ControllerName,
                        "SingleResult"));
                }

                return result;
            }
            finally
            {
                // Ensure any active/open database objects that were created
                // iterating over the IQueryable object are properly closed.
                var disposable = enumerator as IDisposable;
                disposable?.Dispose();
            }
        }

        /// <summary>
        /// Validate the select and expand options.
        /// </summary>
        /// <param name="queryOptions">The query options.</param>
        internal static void ValidateSelectExpandOnly(ODataQueryOptions queryOptions)
        {
            if (queryOptions.Filter != null || queryOptions.Count != null || queryOptions.OrderBy != null
                || queryOptions.Skip != null || queryOptions.Top != null)
            {
                throw new ODataException(Error.Format(SRResources.NonSelectExpandOnSingleEntity));
            }
        }

        /// <summary>
        /// Determine if the 
        /// </summary>
        /// <param name="responseValue">The response value.</param>
        /// <param name="singleResultCollection">The content as SingleResult.Queryable.</param>
        /// <param name="actionDescriptor">The action context, i.e. action and controller name.</param>
        /// <param name="modelFunction">A function to get the model.</param>
        /// <param name="path">The OData path.</param>
        /// <returns></returns>
        private static bool ContainsAutoSelectExpandProperty(
            object responseValue,
            IQueryable singleResultCollection,
            IWebApiActionDescriptor actionDescriptor,
            Func<Type, IEdmModel> modelFunction,
            ODataPath path)
        {
            Type elementClrType = GetElementType(responseValue, singleResultCollection, actionDescriptor);

            IEdmModel model = modelFunction(elementClrType);
            if (model == null)
            {
                throw Error.InvalidOperation(SRResources.QueryGetModelMustNotReturnNull);
            }

            IEdmType edmType = model.GetTypeMappingCache().GetEdmType(elementClrType, model)?.Definition;
            IEdmProperty property = null;
            if (path != null)
            {
                string name;
                EdmLibHelpers.GetPropertyAndStructuredTypeFromPath(path.Segments, out property,
                    out structuredType,
                    out name);
            }

            if (edmType is IEdmEntityType baseEntityType)
            {
                List<IEdmEntityType> entityTypes = new List<IEdmEntityType>();
                entityTypes.Add(baseEntityType);
                entityTypes.AddRange(EdmLibHelpers.GetAllDerivedEntityTypes(baseEntityType, model));
                foreach (var entityType in entityTypes)
                {
                    IEnumerable<IEdmNavigationProperty> navigationProperties = entityType == baseEntityType
                        ? entityType.NavigationProperties()
                        : entityType.DeclaredNavigationProperties();
                    if (navigationProperties != null)
                    {
                        if (navigationProperties.Any(
                                navigationProperty =>
                                    EdmLibHelpers.IsAutoExpand(navigationProperty, property, entityType, model)))
                        {
                            return true;
                        }
                    }

                    IEnumerable<IEdmStructuralProperty> properties = entityType == baseEntityType
                        ? entityType.StructuralProperties()
                        : entityType.DeclaredStructuralProperties();
                    if (properties != null)
                    {
                        foreach (var edmProperty in properties)
                        {
                            if (EdmLibHelpers.IsAutoSelect(edmProperty, property, entityType, model))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
            else if (edmType is IEdmStructuredType structuredType)
            {
                IEnumerable<IEdmStructuralProperty> properties = structuredType.StructuralProperties();
                if (properties != null)
                {
                    foreach (var edmProperty in properties)
                    {
                        if (EdmLibHelpers.IsAutoSelect(edmProperty, property, structuredType, model))
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }
   }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\EnableQueryAttribute.cs(757,25): error CS0103: The name 'structuredType' does not exist in the current context
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\Conventions\Attributes\ConcurrencyCheckAttributeEdmPropertyConvention.cs
Description: Error: Unable to create valid SyntaxTree for document: ConcurrencyCheckAttributeEdmPropertyConvention.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (structuralTypeConfiguration is EntityTypeConfiguration entityType && edmProperty is PrimitivePropertyConfiguration primitiveProperty)
            {
                primitiveProperty.ConcurrencyToken = true;
            }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 310
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.Accept[TResult](CSharpSyntaxVisitor`1 visitor)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (structuralTypeConfiguration is EntityTypeConfiguration entityType && edmProperty is PrimitivePropertyConfiguration primitiveProperty)
            {
                primitiveProperty.ConcurrencyToken = true;
            }
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNet.OData.Common;

namespace Microsoft.AspNet.OData.Builder.Conventions.Attributes
{
    /// <summary>
    /// Marks properties that have <see cref="ConcurrencyCheckAttribute"/> as non-optional on their EDM type.
    /// </summary>
    internal class ConcurrencyCheckAttributeEdmPropertyConvention : AttributeEdmPropertyConvention<PropertyConfiguration>
    {
        public ConcurrencyCheckAttributeEdmPropertyConvention()
            : base(attribute => attribute.GetType() == typeof(ConcurrencyCheckAttribute), allowMultiple: false)
        {
        }

        /// <summary>
        /// Marks the property with concurrency token on the EDM type.
        /// </summary>
        /// <param name="edmProperty">The EDM property.</param>
        /// <param name="structuralTypeConfiguration">The EDM type being configured.</param>
        /// <param name="attribute">The <see cref="Attribute"/> found.</param>
        /// <param name="model">The ODataConventionModelBuilder used to build the model.</param>
        public override void Apply(PropertyConfiguration edmProperty,
            StructuralTypeConfiguration structuralTypeConfiguration,
            Attribute attribute,
            ODataConventionModelBuilder model)
        {
            if (edmProperty == null)
            {
                throw Error.ArgumentNull("edmProperty");
            }

            EntityTypeConfiguration entityType = structuralTypeConfiguration as EntityTypeConfiguration;
            PrimitivePropertyConfiguration primitiveProperty = edmProperty as PrimitivePropertyConfiguration;
            if (entityType != null && primitiveProperty != null)
            {
                primitiveProperty.ConcurrencyToken = true;
            }
        }
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
using System.Data.Linq;
#endif
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Xml.Linq;
using Microsoft.AspNet.OData.Adapters;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Formatter.Deserialization;
using Microsoft.AspNet.OData.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Query.Expressions
{
    /// <summary>
    /// The base class for all expression binders.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many ODataLib classes.")]
    public abstract class ExpressionBinderBase
    {
        internal static readonly MethodInfo StringCompareMethodInfo = typeof(string).GetMethod("Compare", new[] { typeof(string), typeof(string) });
        internal static readonly MethodInfo GuidCompareMethodInfo = typeof(Guid).GetMethod("CompareTo", new[] { typeof(Guid) });
        internal static readonly string DictionaryStringObjectIndexerName = typeof(Dictionary<string, object>).GetDefaultMembers()[0].Name;

        internal static readonly Expression NullConstant = Expression.Constant(null);
        internal static readonly Expression FalseConstant = Expression.Constant(false);
        internal static readonly Expression TrueConstant = Expression.Constant(true);
        internal static readonly Expression ZeroConstant = Expression.Constant(0);

        internal static readonly MethodInfo EnumTryParseMethod = typeof(Enum).GetMethods()
                        .Single(m => m.Name == "TryParse" && m.GetParameters().Length == 2);

        internal static readonly Dictionary<BinaryOperatorKind, ExpressionType> BinaryOperatorMapping = new Dictionary<BinaryOperatorKind, ExpressionType>
        {
            { BinaryOperatorKind.Add, ExpressionType.Add },
            { BinaryOperatorKind.And, ExpressionType.AndAlso },
            { BinaryOperatorKind.Divide, ExpressionType.Divide },
            { BinaryOperatorKind.Equal, ExpressionType.Equal },
            { BinaryOperatorKind.GreaterThan, ExpressionType.GreaterThan },
            { BinaryOperatorKind.GreaterThanOrEqual, ExpressionType.GreaterThanOrEqual },
            { BinaryOperatorKind.LessThan, ExpressionType.LessThan },
            { BinaryOperatorKind.LessThanOrEqual, ExpressionType.LessThanOrEqual },
            { BinaryOperatorKind.Modulo, ExpressionType.Modulo },
            { BinaryOperatorKind.Multiply, ExpressionType.Multiply },
            { BinaryOperatorKind.NotEqual, ExpressionType.NotEqual },
            { BinaryOperatorKind.Or, ExpressionType.OrElse },
            { BinaryOperatorKind.Subtract, ExpressionType.Subtract },
        };

        internal IEdmModel Model { get; set; }

        internal ODataQuerySettings QuerySettings { get; set; }

        internal IWebApiAssembliesResolver InternalAssembliesResolver { get; set; }

        /// <summary>
        /// Base query used for the binder.
        /// </summary>
        internal IQueryable BaseQuery;

        /// <summary>
        /// Flattened list of properties from base query, for case when binder is applied for aggregated query.
        /// </summary>
        internal IDictionary<string, Expression> FlattenedPropertyContainer;

        internal bool HasInstancePropertyContainer;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpressionBinderBase"/> class.
        /// </summary>
        /// <param name="requestContainer">The request container.</param>
        protected ExpressionBinderBase(IServiceProvider requestContainer)
        {
            Contract.Assert(requestContainer != null);

            QuerySettings = requestContainer.GetRequiredService<ODataQuerySettings>();
            Model = requestContainer.GetRequiredService<IEdmModel>();

            // The IWebApiAssembliesResolver service is internal and can only be injected by WebApi.
            // This code path may be used in the cases when the service container available
            // but may not contain an instance of IWebApiAssembliesResolver.
            IWebApiAssembliesResolver injectedResolver = requestContainer.GetService<IWebApiAssembliesResolver>();
            InternalAssembliesResolver = (injectedResolver != null) ? injectedResolver : WebApiAssembliesResolver.Default;
        }

        internal ExpressionBinderBase(IEdmModel model, IWebApiAssembliesResolver assembliesResolver, ODataQuerySettings querySettings)
            : this(model, querySettings)
        {
            InternalAssembliesResolver = assembliesResolver;
        }

        internal ExpressionBinderBase(IEdmModel model, ODataQuerySettings querySettings)
        {
            Contract.Assert(model != null);
            Contract.Assert(querySettings != null);
            Contract.Assert(querySettings.HandleNullPropagation != HandleNullPropagationOption.Default);

            QuerySettings = querySettings;
            Model = model;
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        internal Expression CreateBinaryExpression(BinaryOperatorKind binaryOperator, Expression left, Expression right, bool liftToNull)
        {
            ExpressionType binaryExpressionType;

            // When comparing an enum to a string, parse the string, convert both to the enum underlying type, and compare the values
            // When comparing an enum to an enum with the same type, convert both to the underlying type, and compare the values
            Type leftUnderlyingType = Nullable.GetUnderlyingType(left.Type) ?? left.Type;
            Type rightUnderlyingType = Nullable.GetUnderlyingType(right.Type) ?? right.Type;

            // Convert to integers unless Enum type is required
            if ((TypeHelper.IsEnum(leftUnderlyingType) || TypeHelper.IsEnum(rightUnderlyingType)) && binaryOperator != BinaryOperatorKind.Has)
            {
                Type enumType = TypeHelper.IsEnum(leftUnderlyingType) ? leftUnderlyingType : rightUnderlyingType;
                Type enumUnderlyingType = Enum.GetUnderlyingType(enumType);
                left = ConvertToEnumUnderlyingType(left, enumType, enumUnderlyingType);
                right = ConvertToEnumUnderlyingType(right, enumType, enumUnderlyingType);
            }

            if (leftUnderlyingType == typeof(DateTime) && rightUnderlyingType == typeof(DateTimeOffset))
            {
                right = DateTimeOffsetToDateTime(right);
            }
            else if (rightUnderlyingType == typeof(DateTime) && leftUnderlyingType == typeof(DateTimeOffset))
            {
                left = DateTimeOffsetToDateTime(left);
            }

            if ((IsDateOrOffset(leftUnderlyingType) && IsDate(rightUnderlyingType)) ||
                (IsDate(leftUnderlyingType) && IsDateOrOffset(rightUnderlyingType)))
            {
                left = CreateDateBinaryExpression(left);
                right = CreateDateBinaryExpression(right);
            }

            if ((IsDateOrOffset(leftUnderlyingType) && IsTimeOfDay(rightUnderlyingType)) ||
                (IsTimeOfDay(leftUnderlyingType) && IsDateOrOffset(rightUnderlyingType)) ||
                (IsTimeSpan(leftUnderlyingType) && IsTimeOfDay(rightUnderlyingType)) ||
                (IsTimeOfDay(leftUnderlyingType) && IsTimeSpan(rightUnderlyingType)))
            {
                left = CreateTimeBinaryExpression(left);
                right = CreateTimeBinaryExpression(right);
            }

            if (left.Type != right.Type)
            {
                // one of them must be nullable and the other is not.
                left = ToNullable(left);
                right = ToNullable(right);
            }

            if (left.Type == typeof(Guid) || right.Type == typeof(Guid))
            {
                switch (binaryOperator)
                {
                    case BinaryOperatorKind.GreaterThan:
                    case BinaryOperatorKind.GreaterThanOrEqual:
                    case BinaryOperatorKind.LessThan:
                    case BinaryOperatorKind.LessThanOrEqual:
                        left = Expression.Call(left, GuidCompareMethodInfo, right);
                        right = ZeroConstant;
                        break;
                    default:
                        break;
                }
            }

            if (left.Type == typeof(string) || right.Type == typeof(string))
            {
                // convert nulls of type object to nulls of type string to make the String.Compare call work
                left = ConvertNull(left, typeof(string));
                right = ConvertNull(right, typeof(string));

                // Use string.Compare instead of comparison for gt, ge, lt, le between two strings since direct comparisons are not supported
                switch (binaryOperator)
                {
                    case BinaryOperatorKind.GreaterThan:
                    case BinaryOperatorKind.GreaterThanOrEqual:
                    case BinaryOperatorKind.LessThan:
                    case BinaryOperatorKind.LessThanOrEqual:
                        left = Expression.Call(StringCompareMethodInfo, left, right);
                        right = ZeroConstant;
                        break;
                    default:
                        break;
                }
            }

            if (BinaryOperatorMapping.TryGetValue(binaryOperator, out binaryExpressionType))
            {
                if (left.Type == typeof(byte[]) || right.Type == typeof(byte[]))
                {
                    left = ConvertNull(left, typeof(byte[]));
                    right = ConvertNull(right, typeof(byte[]));

                    switch (binaryExpressionType)
                    {
                        case ExpressionType.Equal:
                            return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: Linq2ObjectsComparisonMethods.AreByteArraysEqualMethodInfo);
                        case ExpressionType.NotEqual:
                            return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: Linq2ObjectsComparisonMethods.AreByteArraysNotEqualMethodInfo);
                        default:
                            IEdmPrimitiveType binaryType = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(typeof(byte[]));
                            throw new ODataException(Error.Format(SRResources.BinaryOperatorNotSupported, binaryType.FullName(), binaryType.FullName(), binaryOperator));
                    }
                }
                else
                {
                    return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: null);
                }
            }
            else
            {
                // Enum has a "has" operator
                // {(c1, c2) => c1.HasFlag(Convert(c2))}
                if (TypeHelper.IsEnum(left.Type) && TypeHelper.IsEnum(right.Type) && binaryOperator == BinaryOperatorKind.Has)
                {
                    UnaryExpression flag = Expression.Convert(right, typeof(Enum));
                    return BindHas(left, flag);
                }
                else
                {
                    throw Error.NotSupported(SRResources.QueryNodeBindingNotSupported, binaryOperator, typeof(FilterBinder).Name);
                }
            }
        }

        internal Expression CreateConvertExpression(ConvertNode convertNode, Expression source)
        {
            Type conversionType = EdmLibHelpers.GetClrType(convertNode.TypeReference, Model, InternalAssembliesResolver);

            if (conversionType == typeof(bool?) && source.Type == typeof(bool))
            {
                // we handle null propagation ourselves. So, if converting from bool to Nullable<bool> ignore.
                return source;
            }
            else if (conversionType == typeof(Date?) &&
                (source.Type == typeof(DateTimeOffset?) || source.Type == typeof(DateTime?)))
            {
                return source;
            }
            if ((conversionType == typeof(TimeOfDay?) && source.Type == typeof(TimeOfDay)) ||
                ((conversionType == typeof(Date?) && source.Type == typeof(Date))))
            {
                return source;
            }
            else if (conversionType == typeof(TimeOfDay?) &&
                (source.Type == typeof(DateTimeOffset?) || source.Type == typeof(DateTime?) || source.Type == typeof(TimeSpan?)))
            {
                return source;
            }
            else if (IsDateAndTimeRelated(conversionType) && IsDateAndTimeRelated(source.Type))
            {
                return source;
            }
            else if (source == NullConstant)
            {
                return source;
            }
            else
            {
                if (TypeHelper.IsEnum(source.Type))
                {
                    // we handle enum conversions ourselves
                    return source;
                }
                else
                {
                    // if a cast is from Nullable<T> to Non-Nullable<T> we need to check if source is null
                    if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True
                        && IsNullable(source.Type) && !IsNullable(conversionType))
                    {
                        // source == null ? null : source.Value
                        return
                            Expression.Condition(
                            test: CheckForNull(source),
                            ifTrue: Expression.Constant(null, ToNullable(conversionType)),
                            ifFalse: Expression.Convert(ExtractValueFromNullableExpression(source), ToNullable(conversionType)));
                    }
                    else
                    {
                        return Expression.Convert(source, conversionType);
                    }
                }
            }
        }

        // If the expression is of non-standard edm primitive type (like uint), convert the expression to its standard edm type.
        // Also, note that only expressions generated for ushort, uint and ulong can be understood by linq2sql and EF.
        // The rest (char, char[], Binary) would cause issues with linq2sql and EF.
        internal Expression ConvertNonStandardPrimitives(Expression source)
        {
            bool isNonstandardEdmPrimitive;
            Type conversionType = EdmLibHelpers.IsNonstandardEdmPrimitive(source.Type, out isNonstandardEdmPrimitive);

            if (isNonstandardEdmPrimitive)
            {
                Type sourceType = TypeHelper.GetUnderlyingTypeOrSelf(source.Type);

                Contract.Assert(sourceType != conversionType);

                Expression convertedExpression = null;

                if (TypeHelper.IsEnum(sourceType))
                {
                    // we handle enum conversions ourselves
                    convertedExpression = source;
                }
                else
                {
                    switch (Type.GetTypeCode(sourceType))
                    {
                        case TypeCode.UInt16:
                        case TypeCode.UInt32:
                        case TypeCode.UInt64:
                            convertedExpression = Expression.Convert(ExtractValueFromNullableExpression(source), conversionType);
                            break;

                        case TypeCode.Char:
                            convertedExpression = Expression.Call(ExtractValueFromNullableExpression(source), "ToString", typeArguments: null, arguments: null);
                            break;

                        case TypeCode.DateTime:
                            convertedExpression = source;
                            break;

                        case TypeCode.Object:
                            if (sourceType == typeof(char[]))
                            {
                                convertedExpression = Expression.New(typeof(string).GetConstructor(new[] { typeof(char[]) }), source);
                            }
                            else if (sourceType == typeof(XElement))
                            {
                                convertedExpression = Expression.Call(source, "ToString", typeArguments: null, arguments: null);
                            }
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
                            else if (sourceType == typeof(Binary))
                            {
                                convertedExpression = Expression.Call(source, "ToArray", typeArguments: null, arguments: null);
                            }
#endif
                            break;

                        default:
                            Contract.Assert(false, Error.Format("missing non-standard type support for {0}", sourceType.Name));
                            break;
                    }
                }

                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True && IsNullable(source.Type))
                {
                    // source == null ? null : source
                    return Expression.Condition(
                        CheckForNull(source),
                        ifTrue: Expression.Constant(null, ToNullable(convertedExpression.Type)),
                        ifFalse: ToNullable(convertedExpression));
                }
                else
                {
                    return convertedExpression;
                }
            }

            return source;
        }

        internal Expression MakePropertyAccess(PropertyInfo propertyInfo, Expression argument)
        {
            Expression propertyArgument = argument;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // we don't have to check if the argument is null inside the function call as we do it already
                // before calling the function. So remove the redundant null checks.
                propertyArgument = RemoveInnerNullPropagation(argument);
            }

            // if the argument is of type Nullable<T>, then translate the argument to Nullable<T>.Value as none
            // of the canonical functions have overloads for Nullable<> arguments.
            propertyArgument = ExtractValueFromNullableExpression(propertyArgument);

            return Expression.Property(propertyArgument, propertyInfo);
        }

        // creates an expression for the corresponding OData function.
        internal Expression MakeFunctionCall(MemberInfo member, params Expression[] arguments)
        {
            Contract.Assert(member.MemberType == MemberTypes.Property || member.MemberType == MemberTypes.Method);

            IEnumerable<Expression> functionCallArguments = arguments;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // we don't have to check if the argument is null inside the function call as we do it already
                // before calling the function. So remove the redundant null checks.
                functionCallArguments = arguments.Select(a => RemoveInnerNullPropagation(a));
            }

            // if the argument is of type Nullable<T>, then translate the argument to Nullable<T>.Value as none
            // of the canonical functions have overloads for Nullable<> arguments.
            functionCallArguments = ExtractValueFromNullableArguments(functionCallArguments);

            Expression functionCall;
            if (member.MemberType == MemberTypes.Method)
            {
                MethodInfo method = member as MethodInfo;
                if (method.IsStatic)
                {
                    functionCall = Expression.Call(null, method, functionCallArguments);
                }
                else
                {
                    functionCall = Expression.Call(functionCallArguments.First(), method, functionCallArguments.Skip(1));
                }
            }
            else
            {
                // property
                functionCall = Expression.Property(functionCallArguments.First(), member as PropertyInfo);
            }

            return CreateFunctionCallWithNullPropagation(functionCall, arguments);
        }

        internal Expression CreateFunctionCallWithNullPropagation(Expression functionCall, Expression[] arguments)
        {
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                Expression test = CheckIfArgumentsAreNull(arguments);

                if (test == FalseConstant)
                {
                    // none of the arguments are/can be null.
                    // so no need to do any null propagation
                    return functionCall;
                }
                else
                {
                    // if one of the arguments is null, result is null (not defined)
                    return
                        Expression.Condition(
                        test: test,
                        ifTrue: Expression.Constant(null, ToNullable(functionCall.Type)),
                        ifFalse: ToNullable(functionCall));
                }
            }
            else
            {
                return functionCall;
            }
        }

        // we don't have to do null checks inside the function for arguments as we do the null checks before calling
        // the function when null propagation is enabled.
        // this method converts back "arg == null ? null : convert(arg)" to "arg"
        // Also, note that we can do this generically only because none of the odata functions that we support can take null
        // as an argument.
        internal Expression RemoveInnerNullPropagation(Expression expression)
        {
            Contract.Assert(expression != null);

            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // only null propagation generates conditional expressions
                if (expression.NodeType == ExpressionType.Conditional)
                {
                    // make sure to skip the DateTime IFF clause
                    ConditionalExpression conditionalExpr = (ConditionalExpression)expression;
                    if (conditionalExpr.Test.NodeType != ExpressionType.OrElse)
                    {
                        expression = conditionalExpr.IfFalse;
                        Contract.Assert(expression != null);

                        if (expression.NodeType == ExpressionType.Convert)
                        {
                            UnaryExpression unaryExpression = expression as UnaryExpression;
                            Contract.Assert(unaryExpression != null);

                            if (Nullable.GetUnderlyingType(unaryExpression.Type) == unaryExpression.Operand.Type)
                            {
                                // this is a cast from T to Nullable<T> which is redundant.
                                expression = unaryExpression.Operand;
                            }
                        }
                    }
                }
            }

            return expression;
        }

        internal string GetFullPropertyPath(SingleValueNode node)
        {
            string path = null;
            SingleValueNode parent = null;
            switch (node.Kind)
            {
                case QueryNodeKind.SingleComplexNode:
                    var complexNode = (SingleComplexNode)node;
                    path = complexNode.Property.Name;
                    parent = complexNode.Source;
                    break;
                case QueryNodeKind.SingleValuePropertyAccess:
                    var propertyNode = ((SingleValuePropertyAccessNode)node);
                    path = propertyNode.Property.Name;
                    parent = propertyNode.Source;
                    break;
                case QueryNodeKind.SingleNavigationNode:
                    var navNode = ((SingleNavigationNode)node);
                    path = navNode.NavigationProperty.Name;
                    parent = navNode.Source;
                    break;
            }

            if (parent != null)
            {
                var parentPath = GetFullPropertyPath(parent);
                if (parentPath != null)
                {
                    path = parentPath + "\\" + path;
                }
            }

            return path;
        }

        /// <summary>
        /// Gets property for dynamic properties dictionary.
        /// </summary>
        /// <param name="openNode"></param>
        /// <returns>Returns CLR property for dynamic properties container.</returns>
        protected PropertyInfo GetDynamicPropertyContainer(SingleValueOpenPropertyAccessNode openNode)
        {
            IEdmStructuredType edmStructuredType;
            IEdmTypeReference edmTypeReference = openNode.Source.TypeReference;
            if (edmTypeReference.IsEntity())
            {
                edmStructuredType = edmTypeReference.AsEntity().EntityDefinition();
            }
            else if (edmTypeReference.IsComplex())
            {
                edmStructuredType = edmTypeReference.AsComplex().ComplexDefinition();
            }
            else
            {
                throw Error.NotSupported(SRResources.QueryNodeBindingNotSupported, openNode.Kind, typeof(FilterBinder).Name);
            }

            return EdmLibHelpers.GetDynamicPropertyDictionary(edmStructuredType, Model);
        }

        private static Expression CheckIfArgumentsAreNull(Expression[] arguments)
        {
            if (arguments.Any(arg => arg == NullConstant))
            {
                return TrueConstant;
            }

            arguments =
                arguments
                .Select(arg => CheckForNull(arg))
                .Where(arg => arg != null)
                .ToArray();

            if (arguments.Any())
            {
                return arguments
                    .Aggregate((left, right) => Expression.OrElse(left, right));
            }
            else
            {
                return FalseConstant;
            }
        }

        internal static Expression CheckForNull(Expression expression)
        {
            if (IsNullable(expression.Type) && expression.NodeType != ExpressionType.Constant)
            {
                return Expression.Equal(expression, Expression.Constant(null));
            }
            else
            {
                return null;
            }
        }

        private static IEnumerable<Expression> ExtractValueFromNullableArguments(IEnumerable<Expression> arguments)
        {
            return arguments.Select(arg => ExtractValueFromNullableExpression(arg));
        }

        internal static Expression ExtractValueFromNullableExpression(Expression source)
        {
            return Nullable.GetUnderlyingType(source.Type) != null ? Expression.Property(source, "Value") : source;
        }

        internal Expression BindHas(Expression left, Expression flag)
        {
            Contract.Assert(TypeHelper.IsEnum(left.Type));
            Contract.Assert(flag.Type == typeof(Enum));

            Expression[] arguments = new[] { left, flag };
            return MakeFunctionCall(ClrCanonicalFunctions.HasFlag, arguments);
        }

        /// <summary>
        /// Analyze previous query and extract grouped properties.
        /// </summary>
        /// <param name="source"></param>
        protected void EnsureFlattenedPropertyContainer(ParameterExpression source)
        {
            if (this.BaseQuery != null)
            {
                this.HasInstancePropertyContainer = this.BaseQuery.ElementType.IsGenericType
                    && this.BaseQuery.ElementType.GetGenericTypeDefinition() == typeof(ComputeWrapper<>);

                this.FlattenedPropertyContainer = this.FlattenedPropertyContainer ?? this.GetFlattenedProperties(source);
            }
        }

        internal IDictionary<string, Expression> GetFlattenedProperties(ParameterExpression source)
        {
            if (this.BaseQuery == null)
            {
                return null;
            }

            if (!typeof(GroupByWrapper).IsAssignableFrom(BaseQuery.ElementType))
            {
                return null;
            }

            var expression = BaseQuery.Expression as MethodCallExpression;
            if (expression == null)
            {
                return null;
            }

            // After $apply we could have other clauses, like $filter, $orderby etc.
            // Skip of filter expressions
            expression = SkipFilters(expression);

            if (expression == null)
            {
                return null;
            }

            var result = new Dictionary<string, Expression>();
            CollectContainerAssignments(source, expression, result);
            if (this.HasInstancePropertyContainer)
            {
                var instanceProperty = Expression.Property(source, "Instance");
                if (typeof(DynamicTypeWrapper).IsAssignableFrom(instanceProperty.Type))
                {
                    var computeExpression = expression.Arguments.FirstOrDefault() as MethodCallExpression;
                    computeExpression = SkipFilters(computeExpression);
                    if (computeExpression != null)
                    {
                        CollectContainerAssignments(instanceProperty, computeExpression, result);
                    }
                }
            }

            return result;
        }

        private static MethodCallExpression SkipFilters(MethodCallExpression expression)
        {
            while (expression.Method.Name == "Where")
            {
                expression = expression.Arguments.FirstOrDefault() as MethodCallExpression;
            }

            return expression;
        }

        private static void CollectContainerAssignments(Expression source, MethodCallExpression expression, Dictionary<string, Expression> result)
        {
            CollectAssigments(result, Expression.Property(source, "GroupByContainer"), ExtractContainerExpression(expression.Arguments.FirstOrDefault() as MethodCallExpression, "GroupByContainer"));
            CollectAssigments(result, Expression.Property(source, "Container"), ExtractContainerExpression(expression, "Container"));
        }

        private static MemberInitExpression ExtractContainerExpression(MethodCallExpression expression, string containerName)
        {
            if (expression == null || expression.Arguments.Count < 2)
            {
                return null;
            }

            var memberInitExpression = ((expression.Arguments[1] as UnaryExpression).Operand as LambdaExpression).Body as MemberInitExpression;
            if (memberInitExpression != null)
            {
                var containerAssigment = memberInitExpression.Bindings.FirstOrDefault(m => m.Member.Name == containerName) as MemberAssignment;
                if (containerAssigment != null)
                {
                    return containerAssigment.Expression as MemberInitExpression;
                }
            }
            return null;
        }

        private static void CollectAssigments(IDictionary<string, Expression> flattenPropertyContainer, Expression source, MemberInitExpression expression, string prefix = null)
        {
            if (expression == null)
            {
                return;
            }

            string nameToAdd = null;
            Type resultType = null;
            MemberInitExpression nextExpression = null;
            Expression nestedExpression = null;
            foreach (var expr in expression.Bindings.OfType<MemberAssignment>())
            {
                var initExpr = expr.Expression as MemberInitExpression;
                if (initExpr != null && expr.Member.Name == "Next")
                {
                    nextExpression = initExpr;
                }
                else if (expr.Member.Name == "Name")
                {
                    nameToAdd = (expr.Expression as ConstantExpression).Value as string;
                }
                else if (expr.Member.Name == "Value" || expr.Member.Name == "NestedValue")
                {
                    resultType = expr.Expression.Type;
                    if (resultType == typeof(object) && expr.Expression.NodeType == ExpressionType.Convert)
                    {
                        resultType = ((UnaryExpression)expr.Expression).Operand.Type;
                    }

                    if (typeof(GroupByWrapper).IsAssignableFrom(resultType))
                    {
                        nestedExpression = expr.Expression;
                    }
                }
            }

            if (prefix != null)
            {
                nameToAdd = prefix + "\\" + nameToAdd;
            }

            if (typeof(GroupByWrapper).IsAssignableFrom(resultType))
            {
                flattenPropertyContainer.Add(nameToAdd, Expression.Property(source, "NestedValue"));
            }
            else
            {
                flattenPropertyContainer.Add(nameToAdd, Expression.Convert(Expression.Property(source, "Value"), resultType));
            }

            if (nextExpression != null)
            {
                CollectAssigments(flattenPropertyContainer, Expression.Property(source, "Next"), nextExpression, prefix);
            }

            if (nestedExpression != null)
            {
                var nestedAccessor = ((nestedExpression as MemberInitExpression).Bindings.First() as MemberAssignment).Expression as MemberInitExpression;
                var newSource = Expression.Property(Expression.Property(source, "NestedValue"), "GroupByContainer");
                CollectAssigments(flattenPropertyContainer, newSource, nestedAccessor, nameToAdd);
            }
        }

        /// <summary>
        /// Gets expression for property from previously aggregated query
        /// </summary>
        /// <param name="propertyPath"></param>
        /// <returns>Returns null if no aggregations were used so far</returns>
        protected Expression GetFlattenedPropertyExpression(string propertyPath)
        {
            if (FlattenedPropertyContainer == null)
            {
                return null;
            }

            Expression expression;
            if (FlattenedPropertyContainer.TryGetValue(propertyPath, out expression))
            {
                return expression;
            }

            if (this.HasInstancePropertyContainer)
            {
                return null;
            }

            throw new ODataException(Error.Format(SRResources.PropertyOrPathWasRemovedFromContext, propertyPath));
        }

        private Expression GetProperty(Expression source, string propertyName)
        {
            if (IsDateOrOffset(source.Type))
            {
                if (IsDateTime(source.Type))
                {
                    return MakePropertyAccess(ClrCanonicalFunctions.DateTimeProperties[propertyName], source);
                }
                else
                {
                    return MakePropertyAccess(ClrCanonicalFunctions.DateTimeOffsetProperties[propertyName], source);
                }
            }
            else if (IsDate(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.DateProperties[propertyName], source);
            }
            else if (IsTimeOfDay(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.TimeOfDayProperties[propertyName], source);
            }
            else if (IsTimeSpan(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.TimeSpanProperties[propertyName], source);
            }

            return source;
        }

        private Expression CreateDateBinaryExpression(Expression source)
        {
            source = ConvertToDateTimeRelatedConstExpression(source);

            // Year, Month, Day
            Expression year = GetProperty(source, ClrCanonicalFunctions.YearFunctionName);
            Expression month = GetProperty(source, ClrCanonicalFunctions.MonthFunctionName);
            Expression day = GetProperty(source, ClrCanonicalFunctions.DayFunctionName);

            // return (year * 10000 + month * 100 + day)
            Expression result =
                Expression.Add(
                    Expression.Add(Expression.Multiply(year, Expression.Constant(10000)),
                        Expression.Multiply(month, Expression.Constant(100))), day);

            return CreateFunctionCallWithNullPropagation(result, new[] { source });
        }

        private Expression CreateTimeBinaryExpression(Expression source)
        {
            source = ConvertToDateTimeRelatedConstExpression(source);

            // Hour, Minute, Second, Millisecond
            Expression hour = GetProperty(source, ClrCanonicalFunctions.HourFunctionName);
            Expression minute = GetProperty(source, ClrCanonicalFunctions.MinuteFunctionName);
            Expression second = GetProperty(source, ClrCanonicalFunctions.SecondFunctionName);
            Expression milliSecond = GetProperty(source, ClrCanonicalFunctions.MillisecondFunctionName);

            Expression hourTicks = Expression.Multiply(Expression.Convert(hour, typeof(long)), Expression.Constant(TimeOfDay.TicksPerHour));
            Expression minuteTicks = Expression.Multiply(Expression.Convert(minute, typeof(long)), Expression.Constant(TimeOfDay.TicksPerMinute));
            Expression secondTicks = Expression.Multiply(Expression.Convert(second, typeof(long)), Expression.Constant(TimeOfDay.TicksPerSecond));

            // return (hour * TicksPerHour + minute * TicksPerMinute + second * TicksPerSecond + millisecond)
            Expression result = Expression.Add(hourTicks, Expression.Add(minuteTicks, Expression.Add(secondTicks, Expression.Convert(milliSecond, typeof(long)))));

            return CreateFunctionCallWithNullPropagation(result, new[] { source });
        }

        private static Expression ConvertToDateTimeRelatedConstExpression(Expression source)
        {
            var parameterizedConstantValue = ExtractParameterizedConstant(source);
            if (parameterizedConstantValue != null && TypeHelper.IsNullable(source.Type))
            {
                var dateTimeOffset = parameterizedConstantValue as DateTimeOffset?;
                if (dateTimeOffset != null)
                {
                    return Expression.Constant(dateTimeOffset.Value, typeof(DateTimeOffset));
                }

                var dateTime = parameterizedConstantValue as DateTime?;
                if (dateTime != null)
                {
                    return Expression.Constant(dateTime.Value, typeof(DateTime));
                }

                var date = parameterizedConstantValue as Date?;
                if (date != null)
                {
                    return Expression.Constant(date.Value, typeof(Date));
                }

                var timeOfDay = parameterizedConstantValue as TimeOfDay?;
                if (timeOfDay != null)
                {
                    return Expression.Constant(timeOfDay.Value, typeof(TimeOfDay));
                }
            }

            return source;
        }

        internal static Expression ConvertToEnumUnderlyingType(Expression expression, Type enumType, Type enumUnderlyingType)
        {
            object parameterizedConstantValue = ExtractParameterizedConstant(expression);
            if (parameterizedConstantValue != null)
            {
                string enumStringValue = parameterizedConstantValue as string;
                if (enumStringValue != null)
                {
                    return Expression.Constant(
                        Convert.ChangeType(
                            Enum.Parse(enumType, enumStringValue), enumUnderlyingType, CultureInfo.InvariantCulture));
                }
                else
                {
                    // enum member value
                    return Expression.Constant(
                        Convert.ChangeType(
                            parameterizedConstantValue, enumUnderlyingType, CultureInfo.InvariantCulture));
                }
            }
            else if (expression.Type == enumType)
            {
                return Expression.Convert(expression, enumUnderlyingType);
            }
            else if (Nullable.GetUnderlyingType(expression.Type) == enumType)
            {
                return Expression.Convert(expression, typeof(Nullable<>).MakeGenericType(enumUnderlyingType));
            }
            else if (expression.NodeType == ExpressionType.Constant && ((ConstantExpression)expression).Value == null)
            {
                return expression;
            }
            else
            {
                throw Error.NotSupported(SRResources.ConvertToEnumFailed, enumType, expression.Type);
            }
        }

        // Extract the constant that would have been encapsulated into LinqParameterContainer if this
        // expression represents it else return null.
        internal static object ExtractParameterizedConstant(Expression expression)
        {
            if (expression.NodeType == ExpressionType.MemberAccess)
            {
                MemberExpression memberAccess = expression as MemberExpression;
                Contract.Assert(memberAccess != null);

                PropertyInfo propertyInfo = memberAccess.Member as PropertyInfo;
                if (propertyInfo != null && propertyInfo.GetMethod.IsStatic)
                {
                    return propertyInfo.GetValue(new object());
                }

                if (memberAccess.Expression.NodeType == ExpressionType.Constant)
                {
                    ConstantExpression constant = memberAccess.Expression as ConstantExpression;
                    Contract.Assert(constant != null);
                    Contract.Assert(constant.Value != null);
                    LinqParameterContainer value = constant.Value as LinqParameterContainer;
                    Contract.Assert(value != null, "Constants are already embedded into LinqParameterContainer");

                    return value.Property;
                }
            }

            return null;
        }

        internal static Expression DateTimeOffsetToDateTime(Expression expression)
        {
            var unaryExpression = expression as UnaryExpression;
            if (unaryExpression != null)
            {
                if (Nullable.GetUnderlyingType(unaryExpression.Type) == unaryExpression.Operand.Type)
                {
                    // this is a cast from T to Nullable<T> which is redundant.
                    expression = unaryExpression.Operand;
                }
            }
            var parameterizedConstantValue = ExtractParameterizedConstant(expression);
            var dto = parameterizedConstantValue as DateTimeOffset?;
            if (dto != null)
            {
                expression = Expression.Constant(EdmPrimitiveHelpers.ConvertPrimitiveValue(dto.Value, typeof(DateTime)));
            }
            return expression;
        }

        internal static bool IsNullable(Type t)
        {
            if (!TypeHelper.IsValueType(t) || (TypeHelper.IsGenericType(t) && t.GetGenericTypeDefinition() == typeof(Nullable<>)))
            {
                return true;
            }

            return false;
        }

        internal static Type ToNullable(Type t)
        {
            if (IsNullable(t))
            {
                return t;
            }
            else
            {
                return typeof(Nullable<>).MakeGenericType(t);
            }
        }

        internal static Expression ToNullable(Expression expression)
        {
            if (!IsNullable(expression.Type))
            {
                return Expression.Convert(expression, ToNullable(expression.Type));
            }

            return expression;
        }

        internal static bool IsIQueryable(Type type)
        {
            return typeof(IQueryable).IsAssignableFrom(type);
        }

        internal static bool IsDoubleOrDecimal(Type type)
        {
            return IsType<double>(type) || IsType<decimal>(type);
        }

        internal static bool IsDateAndTimeRelated(Type type)
        {
            return IsType<Date>(type) ||
                IsType<DateTime>(type) ||
                IsType<DateTimeOffset>(type) ||
                IsType<TimeOfDay>(type) ||
                IsType<TimeSpan>(type);
        }

        internal static bool IsDateRelated(Type type)
        {
            return IsType<Date>(type) || IsType<DateTime>(type) || IsType<DateTimeOffset>(type);
        }

        internal static bool IsTimeRelated(Type type)
        {
            return IsType<TimeOfDay>(type) || IsType<DateTime>(type) || IsType<DateTimeOffset>(type) || IsType<TimeSpan>(type);
        }

        internal static bool IsDateOrOffset(Type type)
        {
            return IsType<DateTime>(type) || IsType<DateTimeOffset>(type);
        }

        internal static bool IsDateTime(Type type)
        {
            return IsType<DateTime>(type);
        }

        internal static bool IsTimeSpan(Type type)
        {
            return IsType<TimeSpan>(type);
        }

        internal static bool IsTimeOfDay(Type type)
        {
            return IsType<TimeOfDay>(type);
        }

        internal static bool IsDate(Type type)
        {
            return IsType<Date>(type);
        }

        internal static bool IsInteger(Type type)
        {
            return IsType<short>(type) || IsType<int>(type) || IsType<long>(type);
        }

        internal static bool IsType<T>(Type type) where T : struct
        {
            return type == typeof(T) || type == typeof(T?);
        }

        internal static Expression ConvertNull(Expression expression, Type type)
        {
            ConstantExpression constantExpression = expression as ConstantExpression;
            if (constantExpression != null && constantExpression.Value == null)
            {
                return Expression.Constant(null, type);
            }
            else
            {
                return expression;
            }
        }

        /// <summary>
        /// Recognize $it.Source where $it is FlatteningWrapper
        /// Using that do avoid wrapping it redundant into Null propagation 
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        private bool IsFlatteningSource(Expression source)
        {
            var member = source as MemberExpression;
            return member != null
                && this.Parameter.Type.IsGenericType() 
                && this.Parameter.Type.GetGenericTypeDefinition() == typeof(FlatteningWrapper<>)
                && member.Expression == this.Parameter;
        }

        internal Expression CreatePropertyAccessExpression(Expression source, IEdmProperty property, string propertyPath = null)
        {
            string propertyName = EdmLibHelpers.GetClrPropertyName(property, Model);
            propertyPath = propertyPath ?? propertyName;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True && IsNullable(source.Type) &&
                source != this.Parameter &&
                !IsFlatteningSource(source))
            {
                Expression cleanSource = RemoveInnerNullPropagation(source);
                Expression propertyAccessExpression = null;
                propertyAccessExpression = GetFlattenedPropertyExpression(propertyPath) ?? Expression.Property(cleanSource, propertyName);

                // source.property => source == null ? null : [CastToNullable]RemoveInnerNullPropagation(source).property
                // Notice that we are checking if source is null already. so we can safely remove any null checks when doing source.Property

                Expression ifFalse = ToNullable(ConvertNonStandardPrimitives(propertyAccessExpression));
                return
                    Expression.Condition(
                        test: Expression.Equal(source, NullConstant),
                        ifTrue: Expression.Constant(null, ifFalse.Type),
                        ifFalse: ifFalse);
            }
            else
            {
                return GetFlattenedPropertyExpression(propertyPath)
                    ?? ConvertNonStandardPrimitives(ExpressionBinderBase.GetPropertyExpression(source, (this.HasInstancePropertyContainer && !propertyPath.Contains("\\") ? "Instance\\" : String.Empty) + propertyName));
            }
        }

        internal static Expression GetPropertyExpression(Expression source, string propertyPath)
        {
            string[] propertyNameParts = propertyPath.Split('\\');
            Expression propertyValue = source;
            foreach (var propertyName in propertyNameParts)
            {
                propertyValue = Expression.Property(propertyValue, propertyName);
            }
            return propertyValue;
        }

        /// <summary>
        /// Binds a <see cref="QueryNode"/> to create a LINQ <see cref="Expression"/> that represents the semantics
        /// of the <see cref="QueryNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
            Justification = "These are simple conversion function and cannot be split up.")]
        public abstract Expression Bind(QueryNode node);

        /// <summary>
        /// Gets $it parameter
        /// </summary>
        /// <returns></returns>
        protected abstract ParameterExpression Parameter { get; }

        /// <summary>
        /// Binds a <see cref="ConstantNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="ConstantNode"/>.
        /// </summary>
        /// <param name="constantNode">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        public virtual Expression BindConstantNode(ConstantNode constantNode)
        {
            Contract.Assert(constantNode != null);

            // no need to parameterize null's as there cannot be multiple values for null.
            if (constantNode.Value == null)
            {
                return NullConstant;
            }

            object value = constantNode.Value;
            Type constantType = RetrieveClrTypeForConstant(constantNode.TypeReference, ref value);

            if (QuerySettings.EnableConstantParameterization)
            {
                return LinqParameterContainer.Parameterize(constantType, value);
            }
            else
            {
                return Expression.Constant(value, constantType);
            }
        }

        /// <summary>
        /// Binds a <see cref="SingleValueFunctionCallNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="SingleValueFunctionCallNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
                        Justification = "These are simple binding functions and cannot be split up.")]
        public virtual Expression BindSingleValueFunctionCallNode(SingleValueFunctionCallNode node)
        {
            switch (node.Name)
            {
                case ClrCanonicalFunctions.StartswithFunctionName:
                    return BindStartsWith(node);

                case ClrCanonicalFunctions.EndswithFunctionName:
                    return BindEndsWith(node);

                case ClrCanonicalFunctions.ContainsFunctionName:
                    return BindContains(node);

                case ClrCanonicalFunctions.SubstringFunctionName:
                    return BindSubstring(node);

                case ClrCanonicalFunctions.LengthFunctionName:
                    return BindLength(node);

                case ClrCanonicalFunctions.IndexofFunctionName:
                    return BindIndexOf(node);

                case ClrCanonicalFunctions.TolowerFunctionName:
                    return BindToLower(node);

                case ClrCanonicalFunctions.ToupperFunctionName:
                    return BindToUpper(node);

                case ClrCanonicalFunctions.TrimFunctionName:
                    return BindTrim(node);

                case ClrCanonicalFunctions.ConcatFunctionName:
                    return BindConcat(node);

                case ClrCanonicalFunctions.YearFunctionName:
                case ClrCanonicalFunctions.MonthFunctionName:
                case ClrCanonicalFunctions.DayFunctionName:
                    return BindDateRelatedProperty(node); // Date & DateTime & DateTimeOffset

                case ClrCanonicalFunctions.HourFunctionName:
                case ClrCanonicalFunctions.MinuteFunctionName:
                case ClrCanonicalFunctions.SecondFunctionName:
                    return BindTimeRelatedProperty(node); // TimeOfDay & DateTime & DateTimeOffset

                case ClrCanonicalFunctions.FractionalSecondsFunctionName:
                    return BindFractionalSeconds(node);

                case ClrCanonicalFunctions.RoundFunctionName:
                    return BindRound(node);

                case ClrCanonicalFunctions.FloorFunctionName:
                    return BindFloor(node);

                case ClrCanonicalFunctions.CeilingFunctionName:
                    return BindCeiling(node);

                case ClrCanonicalFunctions.CastFunctionName:
                    return BindCastSingleValue(node);

                case ClrCanonicalFunctions.IsofFunctionName:
                    return BindIsOf(node);

                case ClrCanonicalFunctions.DateFunctionName:
                    return BindDate(node);

                case ClrCanonicalFunctions.TimeFunctionName:
                    return BindTime(node);

                case ClrCanonicalFunctions.NowFunctionName:
                    return BindNow(node);

                default:
                    // Get Expression of custom binded method.
                    Expression expression = BindCustomMethodExpressionOrNull(node);
                    if (expression != null)
                    {
                        return expression;
                    }

                    throw new NotImplementedException(Error.Format(SRResources.ODataFunctionNotSupported, node.Name));
            }
        }

        /// <summary>
        /// Binds a <see cref="CollectionConstantNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="CollectionConstantNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        public virtual Expression BindCollectionConstantNode(CollectionConstantNode node)
        {
            // It's fine if the collection is empty; the returned value will be an empty list.
            ConstantNode firstNode = node.Collection.FirstOrDefault();
            object value = null;
            if (firstNode != null)
            {
                value = firstNode.Value;
            }

            Type constantType = RetrieveClrTypeForConstant(node.ItemType, ref value);
            Type nullableConstantType = node.ItemType.IsNullable && constantType.IsValueType && Nullable.GetUnderlyingType(constantType) == null
                ? typeof(Nullable<>).MakeGenericType(constantType)
                : constantType;
            Type listType = typeof(List<>).MakeGenericType(nullableConstantType);
            IList castedList = Activator.CreateInstance(listType) as IList;

            // Getting a LINQ expression to dynamically cast each item in the Collection during runtime is tricky,
            // so using a foreach loop and doing an implicit cast from object to the CLR type of ItemType.
            foreach (ConstantNode item in node.Collection)
            {
                object member;
                if (item.Value == null)
                {
                    member = null;
                }
                else if (constantType.IsEnum)
                {
                    member = EnumDeserializationHelpers.ConvertEnumValue(item.Value, constantType);
                }
                else
                {
                    member = item.Value;
                }

                castedList.Add(member);
            }

            if (QuerySettings.EnableConstantParameterization)
            {
                return LinqParameterContainer.Parameterize(listType, castedList);
            }

            return Expression.Constant(castedList, listType);
        }

        private Expression BindCastSingleValue(SingleValueFunctionCallNode node)
        {
            Contract.Assert(ClrCanonicalFunctions.CastFunctionName == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 || arguments.Length == 2);

            Expression source = arguments.Length == 1 ? this.Parameter : arguments[0];
            string targetTypeName = (string)((ConstantNode)node.Parameters.Last()).Value;
            IEdmType targetEdmType = Model.FindType(targetTypeName);
            Type targetClrType = null;

            if (targetEdmType != null)
            {
                IEdmTypeReference targetEdmTypeReference = targetEdmType.ToEdmTypeReference(false);
                targetClrType = EdmLibHelpers.GetClrType(targetEdmTypeReference, Model);

                if (source != NullConstant)
                {
                    if (source.Type == targetClrType)
                    {
                        return source;
                    }

                    if ((!targetEdmTypeReference.IsPrimitive() && !targetEdmTypeReference.IsEnum()) ||
                        (EdmLibHelpers.GetEdmPrimitiveTypeOrNull(source.Type) == null && !TypeHelper.IsEnum(source.Type)))
                    {
                        // Cast fails and return null.
                        return NullConstant;
                    }
                }
            }

            if (targetClrType == null || source == NullConstant)
            {
                return NullConstant;
            }

            if (targetClrType == typeof(string))
            {
                return BindCastToStringType(source);
            }
            else if (TypeHelper.IsEnum(targetClrType))
            {
                return BindCastToEnumType(source.Type, targetClrType, node.Parameters.First(), arguments.Length);
            }
            else
            {
                if (TypeHelper.IsNullable(source.Type) && !TypeHelper.IsNullable(targetClrType))
                {
                    // Make the target Clr type nullable to avoid failure while casting
                    // nullable source, whose value may be null, to a non-nullable type.
                    // For example: cast(NullableInt32Property,Edm.Int64)
                    // The target Clr type should be Nullable<Int64> rather than Int64.
                    targetClrType = typeof(Nullable<>).MakeGenericType(targetClrType);
                }

                try
                {
                    return Expression.Convert(source, targetClrType);
                }
                catch (InvalidOperationException)
                {
                    // Cast fails and return null.
                    return NullConstant;
                }
            }
        }

        private static Expression BindCastToStringType(Expression source)
        {
            Expression sourceValue;

            if (TypeHelper.IsGenericType(source.Type) && source.Type.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                if (TypeHelper.IsEnum(source.Type))
                {
                    // Entity Framework doesn't have ToString method for enum types.
                    // Convert enum types to their underlying numeric types.
                    sourceValue = Expression.Convert(
                        Expression.Property(source, "Value"),
                        Enum.GetUnderlyingType(TypeHelper.GetUnderlyingTypeOrSelf(source.Type)));
                }
                else
                {
                    // Entity Framework has ToString method for numeric types.
                    sourceValue = Expression.Property(source, "Value");
                }

                // Entity Framework doesn't have ToString method for nullable numeric types.
                // Call ToString method on non-nullable numeric types.
                return Expression.Condition(
                    Expression.Property(source, "HasValue"),
                    Expression.Call(sourceValue, "ToString", typeArguments: null, arguments: null),
                    Expression.Constant(null, typeof(string)));
            }
            else
            {
                sourceValue = TypeHelper.IsEnum(source.Type) ?
                    Expression.Convert(source, Enum.GetUnderlyingType(source.Type)) :
                    source;
                return Expression.Call(sourceValue, "ToString", typeArguments: null, arguments: null);
            }
        }

        private Expression BindCastToEnumType(Type sourceType, Type targetClrType, QueryNode firstParameter, int parameterLength)
        {
            Type enumType = TypeHelper.GetUnderlyingTypeOrSelf(targetClrType);
            ConstantNode sourceNode = firstParameter as ConstantNode;

            if (parameterLength == 1 || sourceNode == null || sourceType != typeof(string))
            {
                // We only support to cast Enumeration type from constant string now,
                // because LINQ to Entities does not recognize the method Enum.TryParse.
                return NullConstant;
            }
            else
            {
                object[] parameters = new[] { sourceNode.Value, Enum.ToObject(enumType, 0) };
                bool isSuccessful = (bool)EnumTryParseMethod.MakeGenericMethod(enumType).Invoke(null, parameters);

                if (isSuccessful)
                {
                    if (QuerySettings.EnableConstantParameterization)
                    {
                        return LinqParameterContainer.Parameterize(targetClrType, parameters[1]);
                    }
                    else
                    {
                        return Expression.Constant(parameters[1], targetClrType);
                    }
                }
                else
                {
                    return NullConstant;
                }
            }
        }

        private Expression BindIsOf(SingleValueFunctionCallNode node)
        {
            Contract.Assert(ClrCanonicalFunctions.IsofFunctionName == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // Edm.Boolean isof(type)  or
            // Edm.Boolean isof(expression,type)
            Contract.Assert(arguments.Length == 1 || arguments.Length == 2);

            Expression source = arguments.Length == 1 ? this.Parameter : arguments[0];
            if (source == NullConstant)
            {
                return FalseConstant;
            }

            string typeName = (string)((ConstantNode)node.Parameters.Last()).Value;

            IEdmType edmType = Model.FindType(typeName);
            Type clrType = null;
            if (edmType != null)
            {
                // bool nullable = source.Type.IsNullable();
                IEdmTypeReference edmTypeReference = edmType.ToEdmTypeReference(false);
                clrType = EdmLibHelpers.GetClrType(edmTypeReference, Model);
            }

            if (clrType == null)
            {
                return FalseConstant;
            }

            bool isSourcePrimitiveOrEnum = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(source.Type) != null ||
                                           TypeHelper.IsEnum(source.Type);

            bool isTargetPrimitiveOrEnum = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(clrType) != null ||
                                           TypeHelper.IsEnum(clrType);

            if (isSourcePrimitiveOrEnum && isTargetPrimitiveOrEnum)
            {
                if (TypeHelper.IsNullable(source.Type))
                {
                    clrType = TypeHelper.ToNullable(clrType);
                }
            }

            // Be caution: Type method of LINQ to Entities only supports entity type.
            return Expression.Condition(Expression.TypeIs(source, clrType), TrueConstant, FalseConstant);
        }

        private Expression BindCeiling(SingleValueFunctionCallNode node)
        {
            Contract.Assert("ceiling" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo ceiling = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.CeilingOfDouble
                : ClrCanonicalFunctions.CeilingOfDecimal;
            return MakeFunctionCall(ceiling, arguments);
        }

        private Expression BindFloor(SingleValueFunctionCallNode node)
        {
            Contract.Assert("floor" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo floor = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.FloorOfDouble
                : ClrCanonicalFunctions.FloorOfDecimal;
            return MakeFunctionCall(floor, arguments);
        }

        private Expression BindRound(SingleValueFunctionCallNode node)
        {
            Contract.Assert("round" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo round = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.RoundOfDouble
                : ClrCanonicalFunctions.RoundOfDecimal;
            return MakeFunctionCall(round, arguments);
        }

        private Expression BindDate(SingleValueFunctionCallNode node)
        {
            Contract.Assert("date" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Contract.Assert(arguments.Length == 1 && IsDateOrOffset(arguments[0].Type));

            // EF doesn't support new Date(int, int, int), also doesn't support other property access, for example DateTime.Date.
            // Therefore, we just return the source (DateTime or DateTimeOffset).
            return arguments[0];
        }

        private Expression BindNow(SingleValueFunctionCallNode node)
        {
            Contract.Assert("now" == node.Name);

            // Function Now() does not take any arguemnts.
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 0);

            return Expression.Property(null, typeof(DateTimeOffset), "UtcNow");
        }

        private Expression BindTime(SingleValueFunctionCallNode node)
        {
            Contract.Assert("time" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Contract.Assert(arguments.Length == 1 && IsDateOrOffset(arguments[0].Type));

            // EF doesn't support new TimeOfDay(int, int, int, int), also doesn't support other property access, for example DateTimeOffset.DateTime.
            // Therefore, we just return the source (DateTime or DateTimeOffset).
            return arguments[0];
        }

        private Expression BindFractionalSeconds(SingleValueFunctionCallNode node)
        {
            Contract.Assert("fractionalseconds" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && (IsTimeRelated(arguments[0].Type)));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsTimeOfDay(parameter.Type))
            {
                property = ClrCanonicalFunctions.TimeOfDayProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else if (IsDateTime(parameter.Type))
            {
                property = ClrCanonicalFunctions.DateTimeProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else if (IsTimeSpan(parameter.Type))
            {
                property = ClrCanonicalFunctions.TimeSpanProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else
            {
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }

            // Millisecond
            Expression milliSecond = MakePropertyAccess(property, parameter);
            Expression decimalMilliSecond = Expression.Convert(milliSecond, typeof(decimal));
            Expression fractionalSeconds = Expression.Divide(decimalMilliSecond, Expression.Constant(1000m, typeof(decimal)));

            return CreateFunctionCallWithNullPropagation(fractionalSeconds, arguments);
        }

        private Expression BindDateRelatedProperty(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && IsDateRelated(arguments[0].Type));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsDate(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateProperties[node.Name];
            }
            else if (IsDateTime(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeProperties[node.Name];
            }
            else
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeOffsetProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[node.Name];
            }

            return MakeFunctionCall(property, parameter);
        }

        private Expression BindTimeRelatedProperty(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && (IsTimeRelated(arguments[0].Type)));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsTimeOfDay(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.TimeOfDayProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.TimeOfDayProperties[node.Name];
            }
            else if (IsDateTime(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeProperties[node.Name];
            }
            else if (IsTimeSpan(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.TimeSpanProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.TimeSpanProperties[node.Name];
            }
            else
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeOffsetProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[node.Name];
            }

            return MakeFunctionCall(property, parameter);
        }

        private Expression BindConcat(SingleValueFunctionCallNode node)
        {
            Contract.Assert("concat" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Concat, arguments);
        }

        private Expression BindTrim(SingleValueFunctionCallNode node)
        {
            Contract.Assert("trim" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Trim, arguments);
        }

        private Expression BindToUpper(SingleValueFunctionCallNode node)
        {
            Contract.Assert("toupper" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.ToUpper, arguments);
        }

        private Expression BindToLower(SingleValueFunctionCallNode node)
        {
            Contract.Assert("tolower" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.ToLower, arguments);
        }

        private Expression BindIndexOf(SingleValueFunctionCallNode node)
        {
            Contract.Assert("indexof" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.IndexOf, arguments);
        }

        private Expression BindSubstring(SingleValueFunctionCallNode node)
        {
            Contract.Assert("substring" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            if (arguments[0].Type != typeof(string))
            {
                throw new ODataException(Error.Format(SRResources.FunctionNotSupportedOnEnum, node.Name));
            }

            Expression functionCall;
            if (arguments.Length == 2)
            {
                Contract.Assert(IsInteger(arguments[1].Type));

                // When null propagation is allowed, we use a safe version of String.Substring(int).
                // But for providers that would not recognize custom expressions like this, we map
                // directly to String.Substring(int)
                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // Safe function is static and takes string "this" as first argument
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartNoThrow, arguments);
                }
                else
                {
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStart, arguments);
                }
            }
            else
            {
                // arguments.Length == 3 implies String.Substring(int, int)
                Contract.Assert(arguments.Length == 3 && IsInteger(arguments[1].Type) && IsInteger(arguments[2].Type));

                // When null propagation is allowed, we use a safe version of String.Substring(int, int).
                // But for providers that would not recognize custom expressions like this, we map
                // directly to String.Substring(int, int)
                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // Safe function is static and takes string "this" as first argument
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartAndLengthNoThrow, arguments);
                }
                else
                {
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartAndLength, arguments);
                }
            }

            return functionCall;
        }

        private Expression BindLength(SingleValueFunctionCallNode node)
        {
            Contract.Assert("length" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Length, arguments);
        }

        private Expression BindContains(SingleValueFunctionCallNode node)
        {
            Contract.Assert("contains" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Contains, arguments[0], arguments[1]);
        }

        private Expression BindStartsWith(SingleValueFunctionCallNode node)
        {
            Contract.Assert("startswith" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.StartsWith, arguments);
        }

        private Expression BindEndsWith(SingleValueFunctionCallNode node)
        {
            Contract.Assert("endswith" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.EndsWith, arguments);
        }

        /// <summary>
        /// Bind function arguments
        /// </summary>
        /// <param name="nodes"></param>
        /// <returns></returns>
        protected Expression[] BindArguments(IEnumerable<QueryNode> nodes)
        {
            return nodes.OfType<SingleValueNode>().Select(n => Bind(n)).ToArray();
        }

        private static void ValidateAllStringArguments(string functionName, Expression[] arguments)
        {
            if (arguments.Any(arg => arg.Type != typeof(string)))
            {
                throw new ODataException(Error.Format(SRResources.FunctionNotSupportedOnEnum, functionName));
            }
        }

        private Expression BindCustomMethodExpressionOrNull(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            IEnumerable<Type> methodArgumentsType = arguments.Select(argument => argument.Type);

            // Search for custom method info that are binded to the node name
            MethodInfo methodInfo;
            if (UriFunctionsBinder.TryGetMethodInfo(node.Name, methodArgumentsType, out methodInfo))
            {
                return MakeFunctionCall(methodInfo, arguments);
            }

            return null;
        }

        private Type RetrieveClrTypeForConstant(IEdmTypeReference edmTypeReference, ref object value)
        {
            Type constantType = EdmLibHelpers.GetClrType(edmTypeReference, Model, InternalAssembliesResolver);

            if (value != null && edmTypeReference != null && edmTypeReference.IsEnum())
            {
                ODataEnumValue odataEnumValue = (ODataEnumValue)value;
                string strValue = odataEnumValue.Value;
                Contract.Assert(strValue != null);

                constantType = Nullable.GetUnderlyingType(constantType) ?? constantType;

                IEdmEnumType enumType = edmTypeReference.AsEnum().EnumDefinition();
                ClrEnumMemberAnnotation memberMapAnnotation = Model.GetClrEnumMemberAnnotation(enumType);
                if (memberMapAnnotation != null)
                {
                    IEdmEnumMember enumMember = enumType.Members.FirstOrDefault(m => m.Name == strValue);
                    if (enumMember == null)
                    {
                        enumMember = enumType.Members.FirstOrDefault(m => m.Value.ToString() == strValue);
                    }

                    if (enumMember != null)
                    {
                        Enum clrMember = memberMapAnnotation.GetClrEnumMember(enumMember);
                        if (clrMember != null)
                        {
                            value = clrMember;
                        }
                        else
                        {
                            throw new ODataException(Error.Format(SRResources.CannotGetEnumClrMember, enumMember.Name));
                        }
                    }
                    else
                    {
                        value = Enum.Parse(constantType, strValue);
                    }
                }
                else
                {
                    value = Enum.Parse(constantType, strValue);
                }
            }

            if (edmTypeReference != null &&
                edmTypeReference.IsNullable &&
                (edmTypeReference.IsDate() || edmTypeReference.IsTimeOfDay()))
            {
                constantType = Nullable.GetUnderlyingType(constantType) ?? constantType;
            }

            return constantType;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
using System.Data.Linq;
#endif
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Xml.Linq;
using Microsoft.AspNet.OData.Adapters;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Formatter.Deserialization;
using Microsoft.AspNet.OData.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Query.Expressions
{
    /// <summary>
    /// The base class for all expression binders.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many ODataLib classes.")]
    public abstract class ExpressionBinderBase
    {
        internal static readonly MethodInfo StringCompareMethodInfo = typeof(string).GetMethod("Compare", new[] { typeof(string), typeof(string) });
        internal static readonly MethodInfo GuidCompareMethodInfo = typeof(Guid).GetMethod("CompareTo", new[] { typeof(Guid) });
        internal static readonly string DictionaryStringObjectIndexerName = typeof(Dictionary<string, object>).GetDefaultMembers()[0].Name;

        internal static readonly Expression NullConstant = Expression.Constant(null);
        internal static readonly Expression FalseConstant = Expression.Constant(false);
        internal static readonly Expression TrueConstant = Expression.Constant(true);
        internal static readonly Expression ZeroConstant = Expression.Constant(0);

        internal static readonly MethodInfo EnumTryParseMethod = typeof(Enum).GetMethods()
                        .Single(m => m.Name == "TryParse" && m.GetParameters().Length == 2);

        internal static readonly Dictionary<BinaryOperatorKind, ExpressionType> BinaryOperatorMapping = new Dictionary<BinaryOperatorKind, ExpressionType>
        {
            { BinaryOperatorKind.Add, ExpressionType.Add },
            { BinaryOperatorKind.And, ExpressionType.AndAlso },
            { BinaryOperatorKind.Divide, ExpressionType.Divide },
            { BinaryOperatorKind.Equal, ExpressionType.Equal },
            { BinaryOperatorKind.GreaterThan, ExpressionType.GreaterThan },
            { BinaryOperatorKind.GreaterThanOrEqual, ExpressionType.GreaterThanOrEqual },
            { BinaryOperatorKind.LessThan, ExpressionType.LessThan },
            { BinaryOperatorKind.LessThanOrEqual, ExpressionType.LessThanOrEqual },
            { BinaryOperatorKind.Modulo, ExpressionType.Modulo },
            { BinaryOperatorKind.Multiply, ExpressionType.Multiply },
            { BinaryOperatorKind.NotEqual, ExpressionType.NotEqual },
            { BinaryOperatorKind.Or, ExpressionType.OrElse },
            { BinaryOperatorKind.Subtract, ExpressionType.Subtract },
        };

        internal IEdmModel Model { get; set; }

        internal ODataQuerySettings QuerySettings { get; set; }

        internal IWebApiAssembliesResolver InternalAssembliesResolver { get; set; }

        /// <summary>
        /// Base query used for the binder.
        /// </summary>
        internal IQueryable BaseQuery;

        /// <summary>
        /// Flattened list of properties from base query, for case when binder is applied for aggregated query.
        /// </summary>
        internal IDictionary<string, Expression> FlattenedPropertyContainer;

        internal bool HasInstancePropertyContainer;

        /// <summary>
        /// Initializes a new instance of the <see cref="ExpressionBinderBase"/> class.
        /// </summary>
        /// <param name="requestContainer">The request container.</param>
        protected ExpressionBinderBase(IServiceProvider requestContainer)
        {
            Contract.Assert(requestContainer != null);

            QuerySettings = requestContainer.GetRequiredService<ODataQuerySettings>();
            Model = requestContainer.GetRequiredService<IEdmModel>();

            // The IWebApiAssembliesResolver service is internal and can only be injected by WebApi.
            // This code path may be used in the cases when the service container available
            // but may not contain an instance of IWebApiAssembliesResolver.
            IWebApiAssembliesResolver injectedResolver = requestContainer.GetService<IWebApiAssembliesResolver>();
            InternalAssembliesResolver = (injectedResolver != null) ? injectedResolver : WebApiAssembliesResolver.Default;
        }

        internal ExpressionBinderBase(IEdmModel model, IWebApiAssembliesResolver assembliesResolver, ODataQuerySettings querySettings)
            : this(model, querySettings)
        {
            InternalAssembliesResolver = assembliesResolver;
        }

        internal ExpressionBinderBase(IEdmModel model, ODataQuerySettings querySettings)
        {
            Contract.Assert(model != null);
            Contract.Assert(querySettings != null);
            Contract.Assert(querySettings.HandleNullPropagation != HandleNullPropagationOption.Default);

            QuerySettings = querySettings;
            Model = model;
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        internal Expression CreateBinaryExpression(BinaryOperatorKind binaryOperator, Expression left, Expression right, bool liftToNull)
        {
            ExpressionType binaryExpressionType;

            // When comparing an enum to a string, parse the string, convert both to the enum underlying type, and compare the values
            // When comparing an enum to an enum with the same type, convert both to the underlying type, and compare the values
            Type leftUnderlyingType = Nullable.GetUnderlyingType(left.Type) ?? left.Type;
            Type rightUnderlyingType = Nullable.GetUnderlyingType(right.Type) ?? right.Type;

            // Convert to integers unless Enum type is required
            if ((TypeHelper.IsEnum(leftUnderlyingType) || TypeHelper.IsEnum(rightUnderlyingType)) && binaryOperator != BinaryOperatorKind.Has)
            {
                Type enumType = TypeHelper.IsEnum(leftUnderlyingType) ? leftUnderlyingType : rightUnderlyingType;
                Type enumUnderlyingType = Enum.GetUnderlyingType(enumType);
                left = ConvertToEnumUnderlyingType(left, enumType, enumUnderlyingType);
                right = ConvertToEnumUnderlyingType(right, enumType, enumUnderlyingType);
            }

            if (leftUnderlyingType == typeof(DateTime) && rightUnderlyingType == typeof(DateTimeOffset))
            {
                right = DateTimeOffsetToDateTime(right);
            }
            else if (rightUnderlyingType == typeof(DateTime) && leftUnderlyingType == typeof(DateTimeOffset))
            {
                left = DateTimeOffsetToDateTime(left);
            }

            if ((IsDateOrOffset(leftUnderlyingType) && IsDate(rightUnderlyingType)) ||
                (IsDate(leftUnderlyingType) && IsDateOrOffset(rightUnderlyingType)))
            {
                left = CreateDateBinaryExpression(left);
                right = CreateDateBinaryExpression(right);
            }

            if ((IsDateOrOffset(leftUnderlyingType) && IsTimeOfDay(rightUnderlyingType)) ||
                (IsTimeOfDay(leftUnderlyingType) && IsDateOrOffset(rightUnderlyingType)) ||
                (IsTimeSpan(leftUnderlyingType) && IsTimeOfDay(rightUnderlyingType)) ||
                (IsTimeOfDay(leftUnderlyingType) && IsTimeSpan(rightUnderlyingType)))
            {
                left = CreateTimeBinaryExpression(left);
                right = CreateTimeBinaryExpression(right);
            }

            if (left.Type != right.Type)
            {
                // one of them must be nullable and the other is not.
                left = ToNullable(left);
                right = ToNullable(right);
            }

            if (left.Type == typeof(Guid) || right.Type == typeof(Guid))
            {
                switch (binaryOperator)
                {
                    case BinaryOperatorKind.GreaterThan:
                    case BinaryOperatorKind.GreaterThanOrEqual:
                    case BinaryOperatorKind.LessThan:
                    case BinaryOperatorKind.LessThanOrEqual:
                        left = Expression.Call(left, GuidCompareMethodInfo, right);
                        right = ZeroConstant;
                        break;
                    default:
                        break;
                }
            }

            if (left.Type == typeof(string) || right.Type == typeof(string))
            {
                // convert nulls of type object to nulls of type string to make the String.Compare call work
                left = ConvertNull(left, typeof(string));
                right = ConvertNull(right, typeof(string));

                // Use string.Compare instead of comparison for gt, ge, lt, le between two strings since direct comparisons are not supported
                switch (binaryOperator)
                {
                    case BinaryOperatorKind.GreaterThan:
                    case BinaryOperatorKind.GreaterThanOrEqual:
                    case BinaryOperatorKind.LessThan:
                    case BinaryOperatorKind.LessThanOrEqual:
                        left = Expression.Call(StringCompareMethodInfo, left, right);
                        right = ZeroConstant;
                        break;
                    default:
                        break;
                }
            }

            if (BinaryOperatorMapping.TryGetValue(binaryOperator, out binaryExpressionType))
            {
                if (left.Type == typeof(byte[]) || right.Type == typeof(byte[]))
                {
                    left = ConvertNull(left, typeof(byte[]));
                    right = ConvertNull(right, typeof(byte[]));

                    switch (binaryExpressionType)
                    {
                        case ExpressionType.Equal:
                            return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: Linq2ObjectsComparisonMethods.AreByteArraysEqualMethodInfo);
                        case ExpressionType.NotEqual:
                            return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: Linq2ObjectsComparisonMethods.AreByteArraysNotEqualMethodInfo);
                        default:
                            IEdmPrimitiveType binaryType = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(typeof(byte[]));
                            throw new ODataException(Error.Format(SRResources.BinaryOperatorNotSupported, binaryType.FullName(), binaryType.FullName(), binaryOperator));
                    }
                }
                else
                {
                    return Expression.MakeBinary(binaryExpressionType, left, right, liftToNull, method: null);
                }
            }
            else
            {
                // Enum has a "has" operator
                // {(c1, c2) => c1.HasFlag(Convert(c2))}
                if (TypeHelper.IsEnum(left.Type) && TypeHelper.IsEnum(right.Type) && binaryOperator == BinaryOperatorKind.Has)
                {
                    UnaryExpression flag = Expression.Convert(right, typeof(Enum));
                    return BindHas(left, flag);
                }
                else
                {
                    throw Error.NotSupported(SRResources.QueryNodeBindingNotSupported, binaryOperator, typeof(FilterBinder).Name);
                }
            }
        }

        internal Expression CreateConvertExpression(ConvertNode convertNode, Expression source)
        {
            Type conversionType = EdmLibHelpers.GetClrType(convertNode.TypeReference, Model, InternalAssembliesResolver);

            if (conversionType == typeof(bool?) && source.Type == typeof(bool))
            {
                // we handle null propagation ourselves. So, if converting from bool to Nullable<bool> ignore.
                return source;
            }
            else if (conversionType == typeof(Date?) &&
                (source.Type == typeof(DateTimeOffset?) || source.Type == typeof(DateTime?)))
            {
                return source;
            }
            if ((conversionType == typeof(TimeOfDay?) && source.Type == typeof(TimeOfDay)) ||
                ((conversionType == typeof(Date?) && source.Type == typeof(Date))))
            {
                return source;
            }
            else if (conversionType == typeof(TimeOfDay?) &&
                (source.Type == typeof(DateTimeOffset?) || source.Type == typeof(DateTime?) || source.Type == typeof(TimeSpan?)))
            {
                return source;
            }
            else if (IsDateAndTimeRelated(conversionType) && IsDateAndTimeRelated(source.Type))
            {
                return source;
            }
            else if (source == NullConstant)
            {
                return source;
            }
            else
            {
                if (TypeHelper.IsEnum(source.Type))
                {
                    // we handle enum conversions ourselves
                    return source;
                }
                else
                {
                    // if a cast is from Nullable<T> to Non-Nullable<T> we need to check if source is null
                    if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True
                        && IsNullable(source.Type) && !IsNullable(conversionType))
                    {
                        // source == null ? null : source.Value
                        return
                            Expression.Condition(
                            test: CheckForNull(source),
                            ifTrue: Expression.Constant(null, ToNullable(conversionType)),
                            ifFalse: Expression.Convert(ExtractValueFromNullableExpression(source), ToNullable(conversionType)));
                    }
                    else
                    {
                        return Expression.Convert(source, conversionType);
                    }
                }
            }
        }

        // If the expression is of non-standard edm primitive type (like uint), convert the expression to its standard edm type.
        // Also, note that only expressions generated for ushort, uint and ulong can be understood by linq2sql and EF.
        // The rest (char, char[], Binary) would cause issues with linq2sql and EF.
        internal Expression ConvertNonStandardPrimitives(Expression source)
        {
            bool isNonstandardEdmPrimitive;
            Type conversionType = EdmLibHelpers.IsNonstandardEdmPrimitive(source.Type, out isNonstandardEdmPrimitive);

            if (isNonstandardEdmPrimitive)
            {
                Type sourceType = TypeHelper.GetUnderlyingTypeOrSelf(source.Type);

                Contract.Assert(sourceType != conversionType);

                Expression convertedExpression = null;

                if (TypeHelper.IsEnum(sourceType))
                {
                    // we handle enum conversions ourselves
                    convertedExpression = source;
                }
                else
                {
                    switch (Type.GetTypeCode(sourceType))
                    {
                        case TypeCode.UInt16:
                        case TypeCode.UInt32:
                        case TypeCode.UInt64:
                            convertedExpression = Expression.Convert(ExtractValueFromNullableExpression(source), conversionType);
                            break;

                        case TypeCode.Char:
                            convertedExpression = Expression.Call(ExtractValueFromNullableExpression(source), "ToString", typeArguments: null, arguments: null);
                            break;

                        case TypeCode.DateTime:
                            convertedExpression = source;
                            break;

                        case TypeCode.Object:
                            if (sourceType == typeof(char[]))
                            {
                                convertedExpression = Expression.New(typeof(string).GetConstructor(new[] { typeof(char[]) }), source);
                            }
                            else if (sourceType == typeof(XElement))
                            {
                                convertedExpression = Expression.Call(source, "ToString", typeArguments: null, arguments: null);
                            }
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
                            else if (sourceType == typeof(Binary))
                            {
                                convertedExpression = Expression.Call(source, "ToArray", typeArguments: null, arguments: null);
                            }
#endif
                            break;

                        default:
                            Contract.Assert(false, Error.Format("missing non-standard type support for {0}", sourceType.Name));
                            break;
                    }
                }

                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True && IsNullable(source.Type))
                {
                    // source == null ? null : source
                    return Expression.Condition(
                        CheckForNull(source),
                        ifTrue: Expression.Constant(null, ToNullable(convertedExpression.Type)),
                        ifFalse: ToNullable(convertedExpression));
                }
                else
                {
                    return convertedExpression;
                }
            }

            return source;
        }

        internal Expression MakePropertyAccess(PropertyInfo propertyInfo, Expression argument)
        {
            Expression propertyArgument = argument;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // we don't have to check if the argument is null inside the function call as we do it already
                // before calling the function. So remove the redundant null checks.
                propertyArgument = RemoveInnerNullPropagation(argument);
            }

            // if the argument is of type Nullable<T>, then translate the argument to Nullable<T>.Value as none
            // of the canonical functions have overloads for Nullable<> arguments.
            propertyArgument = ExtractValueFromNullableExpression(propertyArgument);

            return Expression.Property(propertyArgument, propertyInfo);
        }

        // creates an expression for the corresponding OData function.
        internal Expression MakeFunctionCall(MemberInfo member, params Expression[] arguments)
        {
            Contract.Assert(member.MemberType == MemberTypes.Property || member.MemberType == MemberTypes.Method);

            IEnumerable<Expression> functionCallArguments = arguments;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // we don't have to check if the argument is null inside the function call as we do it already
                // before calling the function. So remove the redundant null checks.
                functionCallArguments = arguments.Select(a => RemoveInnerNullPropagation(a));
            }

            // if the argument is of type Nullable<T>, then translate the argument to Nullable<T>.Value as none
            // of the canonical functions have overloads for Nullable<> arguments.
            functionCallArguments = ExtractValueFromNullableArguments(functionCallArguments);

            Expression functionCall;
            if (member.MemberType == MemberTypes.Method)
            {
                MethodInfo method = member as MethodInfo;
                if (method.IsStatic)
                {
                    functionCall = Expression.Call(null, method, functionCallArguments);
                }
                else
                {
                    functionCall = Expression.Call(functionCallArguments.First(), method, functionCallArguments.Skip(1));
                }
            }
            else
            {
                // property
                functionCall = Expression.Property(functionCallArguments.First(), member as PropertyInfo);
            }

            return CreateFunctionCallWithNullPropagation(functionCall, arguments);
        }

        internal Expression CreateFunctionCallWithNullPropagation(Expression functionCall, Expression[] arguments)
        {
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                Expression test = CheckIfArgumentsAreNull(arguments);

                if (test == FalseConstant)
                {
                    // none of the arguments are/can be null.
                    // so no need to do any null propagation
                    return functionCall;
                }
                else
                {
                    // if one of the arguments is null, result is null (not defined)
                    return
                        Expression.Condition(
                        test: test,
                        ifTrue: Expression.Constant(null, ToNullable(functionCall.Type)),
                        ifFalse: ToNullable(functionCall));
                }
            }
            else
            {
                return functionCall;
            }
        }

        // we don't have to do null checks inside the function for arguments as we do the null checks before calling
        // the function when null propagation is enabled.
        // this method converts back "arg == null ? null : convert(arg)" to "arg"
        // Also, note that we can do this generically only because none of the odata functions that we support can take null
        // as an argument.
        internal Expression RemoveInnerNullPropagation(Expression expression)
        {
            Contract.Assert(expression != null);

            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // only null propagation generates conditional expressions
                if (expression.NodeType == ExpressionType.Conditional)
                {
                    // make sure to skip the DateTime IFF clause
                    ConditionalExpression conditionalExpr = (ConditionalExpression)expression;
                    if (conditionalExpr.Test.NodeType != ExpressionType.OrElse)
                    {
                        expression = conditionalExpr.IfFalse;
                        Contract.Assert(expression != null);

                        if (expression.NodeType == ExpressionType.Convert)
                        {
                            Contract.Assert(expression is UnaryExpression unaryExpression);

                            if (Nullable.GetUnderlyingType(unaryExpression.Type) == unaryExpression.Operand.Type)
                            {
                                // this is a cast from T to Nullable<T> which is redundant.
                                expression = unaryExpression.Operand;
                            }
                        }
                    }
                }
            }

            return expression;
        }

        internal string GetFullPropertyPath(SingleValueNode node)
        {
            string path = null;
            SingleValueNode parent = null;
            switch (node.Kind)
            {
                case QueryNodeKind.SingleComplexNode:
                    var complexNode = (SingleComplexNode)node;
                    path = complexNode.Property.Name;
                    parent = complexNode.Source;
                    break;
                case QueryNodeKind.SingleValuePropertyAccess:
                    var propertyNode = ((SingleValuePropertyAccessNode)node);
                    path = propertyNode.Property.Name;
                    parent = propertyNode.Source;
                    break;
                case QueryNodeKind.SingleNavigationNode:
                    var navNode = ((SingleNavigationNode)node);
                    path = navNode.NavigationProperty.Name;
                    parent = navNode.Source;
                    break;
            }

            if (parent != null)
            {
                var parentPath = GetFullPropertyPath(parent);
                if (parentPath != null)
                {
                    path = parentPath + "\\" + path;
                }
            }

            return path;
        }

        /// <summary>
        /// Gets property for dynamic properties dictionary.
        /// </summary>
        /// <param name="openNode"></param>
        /// <returns>Returns CLR property for dynamic properties container.</returns>
        protected PropertyInfo GetDynamicPropertyContainer(SingleValueOpenPropertyAccessNode openNode)
        {
            IEdmStructuredType edmStructuredType;
            IEdmTypeReference edmTypeReference = openNode.Source.TypeReference;
            if (edmTypeReference.IsEntity())
            {
                edmStructuredType = edmTypeReference.AsEntity().EntityDefinition();
            }
            else if (edmTypeReference.IsComplex())
            {
                edmStructuredType = edmTypeReference.AsComplex().ComplexDefinition();
            }
            else
            {
                throw Error.NotSupported(SRResources.QueryNodeBindingNotSupported, openNode.Kind, typeof(FilterBinder).Name);
            }

            return EdmLibHelpers.GetDynamicPropertyDictionary(edmStructuredType, Model);
        }

        private static Expression CheckIfArgumentsAreNull(Expression[] arguments)
        {
            if (arguments.Any(arg => arg == NullConstant))
            {
                return TrueConstant;
            }

            arguments =
                arguments
                .Select(arg => CheckForNull(arg))
                .Where(arg => arg != null)
                .ToArray();

            if (arguments.Any())
            {
                return arguments
                    .Aggregate((left, right) => Expression.OrElse(left, right));
            }
            else
            {
                return FalseConstant;
            }
        }

        internal static Expression CheckForNull(Expression expression)
        {
            if (IsNullable(expression.Type) && expression.NodeType != ExpressionType.Constant)
            {
                return Expression.Equal(expression, Expression.Constant(null));
            }
            else
            {
                return null;
            }
        }

        private static IEnumerable<Expression> ExtractValueFromNullableArguments(IEnumerable<Expression> arguments)
        {
            return arguments.Select(arg => ExtractValueFromNullableExpression(arg));
        }

        internal static Expression ExtractValueFromNullableExpression(Expression source)
        {
            return Nullable.GetUnderlyingType(source.Type) != null ? Expression.Property(source, "Value") : source;
        }

        internal Expression BindHas(Expression left, Expression flag)
        {
            Contract.Assert(TypeHelper.IsEnum(left.Type));
            Contract.Assert(flag.Type == typeof(Enum));

            Expression[] arguments = new[] { left, flag };
            return MakeFunctionCall(ClrCanonicalFunctions.HasFlag, arguments);
        }

        /// <summary>
        /// Analyze previous query and extract grouped properties.
        /// </summary>
        /// <param name="source"></param>
        protected void EnsureFlattenedPropertyContainer(ParameterExpression source)
        {
            if (this.BaseQuery != null)
            {
                this.HasInstancePropertyContainer = this.BaseQuery.ElementType.IsGenericType
                    && this.BaseQuery.ElementType.GetGenericTypeDefinition() == typeof(ComputeWrapper<>);

                this.FlattenedPropertyContainer = this.FlattenedPropertyContainer ?? this.GetFlattenedProperties(source);
            }
        }

        internal IDictionary<string, Expression> GetFlattenedProperties(ParameterExpression source)
        {
            if (this.BaseQuery == null)
            {
                return null;
            }

            if (!typeof(GroupByWrapper).IsAssignableFrom(BaseQuery.ElementType))
            {
                return null;
            }

            var expression = BaseQuery.Expression as MethodCallExpression;
            if (expression == null)
            {
                return null;
            }

            // After $apply we could have other clauses, like $filter, $orderby etc.
            // Skip of filter expressions
            expression = SkipFilters(expression);

            if (expression == null)
            {
                return null;
            }

            var result = new Dictionary<string, Expression>();
            CollectContainerAssignments(source, expression, result);
            if (this.HasInstancePropertyContainer)
            {
                var instanceProperty = Expression.Property(source, "Instance");
                if (typeof(DynamicTypeWrapper).IsAssignableFrom(instanceProperty.Type))
                {
                    computeExpression = SkipFilters(computeExpression);

                    if (expression.Arguments.FirstOrDefault() is MethodCallExpression computeExpression)
                    {
                        CollectContainerAssignments(instanceProperty, computeExpression, result);
                    }
                }
            }

            return result;
        }

        private static MethodCallExpression SkipFilters(MethodCallExpression expression)
        {
            while (expression.Method.Name == "Where")
            {
                expression = expression.Arguments.FirstOrDefault() as MethodCallExpression;
            }

            return expression;
        }

        private static void CollectContainerAssignments(Expression source, MethodCallExpression expression, Dictionary<string, Expression> result)
        {
            CollectAssigments(result, Expression.Property(source, "GroupByContainer"), ExtractContainerExpression(expression.Arguments.FirstOrDefault() as MethodCallExpression, "GroupByContainer"));
            CollectAssigments(result, Expression.Property(source, "Container"), ExtractContainerExpression(expression, "Container"));
        }

        private static MemberInitExpression ExtractContainerExpression(MethodCallExpression expression, string containerName)
        {
            if (expression == null || expression.Arguments.Count < 2)
            {
                return null;
            }

            if (((expression.Arguments[1] as UnaryExpression).Operand as LambdaExpression).Body is MemberInitExpression memberInitExpression)
            {
                if (memberInitExpression.Bindings.FirstOrDefault(m => m.Member.Name == containerName) is MemberAssignment containerAssigment)
                {
                    return containerAssigment.Expression as MemberInitExpression;
                }
            }
            return null;
        }

        private static void CollectAssigments(IDictionary<string, Expression> flattenPropertyContainer, Expression source, MemberInitExpression expression, string prefix = null)
        {
            if (expression == null)
            {
                return;
            }

            string nameToAdd = null;
            Type resultType = null;
            MemberInitExpression nextExpression = null;
            Expression nestedExpression = null;
            foreach (var expr in expression.Bindings.OfType<MemberAssignment>())
            {
                if (expr.Expression is MemberInitExpression initExpr && expr.Member.Name == "Next")
                {
                    nextExpression = initExpr;
                }
                else if (expr.Member.Name == "Name")
                {
                    nameToAdd = (expr.Expression as ConstantExpression).Value as string;
                }
                else if (expr.Member.Name == "Value" || expr.Member.Name == "NestedValue")
                {
                    resultType = expr.Expression.Type;
                    if (resultType == typeof(object) && expr.Expression.NodeType == ExpressionType.Convert)
                    {
                        resultType = ((UnaryExpression)expr.Expression).Operand.Type;
                    }

                    if (typeof(GroupByWrapper).IsAssignableFrom(resultType))
                    {
                        nestedExpression = expr.Expression;
                    }
                }
            }

            if (prefix != null)
            {
                nameToAdd = prefix + "\\" + nameToAdd;
            }

            if (typeof(GroupByWrapper).IsAssignableFrom(resultType))
            {
                flattenPropertyContainer.Add(nameToAdd, Expression.Property(source, "NestedValue"));
            }
            else
            {
                flattenPropertyContainer.Add(nameToAdd, Expression.Convert(Expression.Property(source, "Value"), resultType));
            }

            if (nextExpression != null)
            {
                CollectAssigments(flattenPropertyContainer, Expression.Property(source, "Next"), nextExpression, prefix);
            }

            if (nestedExpression != null)
            {
                var nestedAccessor = ((nestedExpression as MemberInitExpression).Bindings.First() as MemberAssignment).Expression as MemberInitExpression;
                var newSource = Expression.Property(Expression.Property(source, "NestedValue"), "GroupByContainer");
                CollectAssigments(flattenPropertyContainer, newSource, nestedAccessor, nameToAdd);
            }
        }

        /// <summary>
        /// Gets expression for property from previously aggregated query
        /// </summary>
        /// <param name="propertyPath"></param>
        /// <returns>Returns null if no aggregations were used so far</returns>
        protected Expression GetFlattenedPropertyExpression(string propertyPath)
        {
            if (FlattenedPropertyContainer == null)
            {
                return null;
            }

            Expression expression;
            if (FlattenedPropertyContainer.TryGetValue(propertyPath, out expression))
            {
                return expression;
            }

            if (this.HasInstancePropertyContainer)
            {
                return null;
            }

            throw new ODataException(Error.Format(SRResources.PropertyOrPathWasRemovedFromContext, propertyPath));
        }

        private Expression GetProperty(Expression source, string propertyName)
        {
            if (IsDateOrOffset(source.Type))
            {
                if (IsDateTime(source.Type))
                {
                    return MakePropertyAccess(ClrCanonicalFunctions.DateTimeProperties[propertyName], source);
                }
                else
                {
                    return MakePropertyAccess(ClrCanonicalFunctions.DateTimeOffsetProperties[propertyName], source);
                }
            }
            else if (IsDate(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.DateProperties[propertyName], source);
            }
            else if (IsTimeOfDay(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.TimeOfDayProperties[propertyName], source);
            }
            else if (IsTimeSpan(source.Type))
            {
                return MakePropertyAccess(ClrCanonicalFunctions.TimeSpanProperties[propertyName], source);
            }

            return source;
        }

        private Expression CreateDateBinaryExpression(Expression source)
        {
            source = ConvertToDateTimeRelatedConstExpression(source);

            // Year, Month, Day
            Expression year = GetProperty(source, ClrCanonicalFunctions.YearFunctionName);
            Expression month = GetProperty(source, ClrCanonicalFunctions.MonthFunctionName);
            Expression day = GetProperty(source, ClrCanonicalFunctions.DayFunctionName);

            // return (year * 10000 + month * 100 + day)
            Expression result =
                Expression.Add(
                    Expression.Add(Expression.Multiply(year, Expression.Constant(10000)),
                        Expression.Multiply(month, Expression.Constant(100))), day);

            return CreateFunctionCallWithNullPropagation(result, new[] { source });
        }

        private Expression CreateTimeBinaryExpression(Expression source)
        {
            source = ConvertToDateTimeRelatedConstExpression(source);

            // Hour, Minute, Second, Millisecond
            Expression hour = GetProperty(source, ClrCanonicalFunctions.HourFunctionName);
            Expression minute = GetProperty(source, ClrCanonicalFunctions.MinuteFunctionName);
            Expression second = GetProperty(source, ClrCanonicalFunctions.SecondFunctionName);
            Expression milliSecond = GetProperty(source, ClrCanonicalFunctions.MillisecondFunctionName);

            Expression hourTicks = Expression.Multiply(Expression.Convert(hour, typeof(long)), Expression.Constant(TimeOfDay.TicksPerHour));
            Expression minuteTicks = Expression.Multiply(Expression.Convert(minute, typeof(long)), Expression.Constant(TimeOfDay.TicksPerMinute));
            Expression secondTicks = Expression.Multiply(Expression.Convert(second, typeof(long)), Expression.Constant(TimeOfDay.TicksPerSecond));

            // return (hour * TicksPerHour + minute * TicksPerMinute + second * TicksPerSecond + millisecond)
            Expression result = Expression.Add(hourTicks, Expression.Add(minuteTicks, Expression.Add(secondTicks, Expression.Convert(milliSecond, typeof(long)))));

            return CreateFunctionCallWithNullPropagation(result, new[] { source });
        }

        private static Expression ConvertToDateTimeRelatedConstExpression(Expression source)
        {
            var parameterizedConstantValue = ExtractParameterizedConstant(source);
            if (parameterizedConstantValue != null && TypeHelper.IsNullable(source.Type))
            {
                if (parameterizedConstantValue is DateTimeOffset? dateTimeOffset)
                {
                    return Expression.Constant(dateTimeOffset.Value, typeof(DateTimeOffset));
                }

                if (parameterizedConstantValue is DateTime? dateTime)
                {
                    return Expression.Constant(dateTime.Value, typeof(DateTime));
                }

                if (parameterizedConstantValue is Date? date)
                {
                    return Expression.Constant(date.Value, typeof(Date));
                }

                if (parameterizedConstantValue is TimeOfDay? timeOfDay)
                {
                    return Expression.Constant(timeOfDay.Value, typeof(TimeOfDay));
                }
            }

            return source;
        }

        internal static Expression ConvertToEnumUnderlyingType(Expression expression, Type enumType, Type enumUnderlyingType)
        {
            object parameterizedConstantValue = ExtractParameterizedConstant(expression);
            if (parameterizedConstantValue != null)
            {
                if (parameterizedConstantValue is string enumStringValue)
                {
                    return Expression.Constant(
                        Convert.ChangeType(
                            Enum.Parse(enumType, enumStringValue), enumUnderlyingType, CultureInfo.InvariantCulture));
                }
                else
                {
                    // enum member value
                    return Expression.Constant(
                        Convert.ChangeType(
                            parameterizedConstantValue, enumUnderlyingType, CultureInfo.InvariantCulture));
                }
            }
            else if (expression.Type == enumType)
            {
                return Expression.Convert(expression, enumUnderlyingType);
            }
            else if (Nullable.GetUnderlyingType(expression.Type) == enumType)
            {
                return Expression.Convert(expression, typeof(Nullable<>).MakeGenericType(enumUnderlyingType));
            }
            else if (expression.NodeType == ExpressionType.Constant && ((ConstantExpression)expression).Value == null)
            {
                return expression;
            }
            else
            {
                throw Error.NotSupported(SRResources.ConvertToEnumFailed, enumType, expression.Type);
            }
        }

        // Extract the constant that would have been encapsulated into LinqParameterContainer if this
        // expression represents it else return null.
        internal static object ExtractParameterizedConstant(Expression expression)
        {
            if (expression.NodeType == ExpressionType.MemberAccess)
            {
                Contract.Assert(expression is MemberExpression memberAccess);

                if (memberAccess.Member is PropertyInfo propertyInfo && propertyInfo.GetMethod.IsStatic)
                {
                    return propertyInfo.GetValue(new object());
                }

                if (memberAccess.Expression.NodeType == ExpressionType.Constant)
                {
                    Contract.Assert(memberAccess.Expression is ConstantExpression constant);
                    Contract.Assert(constant.Value != null);
                    Contract.Assert(constant.Value is LinqParameterContainer value, "Constants are already embedded into LinqParameterContainer");

                    return value.Property;
                }
            }

            return null;
        }

        internal static Expression DateTimeOffsetToDateTime(Expression expression)
        {
            if (expression is UnaryExpression unaryExpression)
            {
                if (Nullable.GetUnderlyingType(unaryExpression.Type) == unaryExpression.Operand.Type)
                {
                    // this is a cast from T to Nullable<T> which is redundant.
                    expression = unaryExpression.Operand;
                }
            }
            var parameterizedConstantValue = ExtractParameterizedConstant(expression);

            if (parameterizedConstantValue is DateTimeOffset? dto)
            {
                expression = Expression.Constant(EdmPrimitiveHelpers.ConvertPrimitiveValue(dto.Value, typeof(DateTime)));
            }
            return expression;
        }

        internal static bool IsNullable(Type t)
        {
            if (!TypeHelper.IsValueType(t) || (TypeHelper.IsGenericType(t) && t.GetGenericTypeDefinition() == typeof(Nullable<>)))
            {
                return true;
            }

            return false;
        }

        internal static Type ToNullable(Type t)
        {
            if (IsNullable(t))
            {
                return t;
            }
            else
            {
                return typeof(Nullable<>).MakeGenericType(t);
            }
        }

        internal static Expression ToNullable(Expression expression)
        {
            if (!IsNullable(expression.Type))
            {
                return Expression.Convert(expression, ToNullable(expression.Type));
            }

            return expression;
        }

        internal static bool IsIQueryable(Type type)
        {
            return typeof(IQueryable).IsAssignableFrom(type);
        }

        internal static bool IsDoubleOrDecimal(Type type)
        {
            return IsType<double>(type) || IsType<decimal>(type);
        }

        internal static bool IsDateAndTimeRelated(Type type)
        {
            return IsType<Date>(type) ||
                IsType<DateTime>(type) ||
                IsType<DateTimeOffset>(type) ||
                IsType<TimeOfDay>(type) ||
                IsType<TimeSpan>(type);
        }

        internal static bool IsDateRelated(Type type)
        {
            return IsType<Date>(type) || IsType<DateTime>(type) || IsType<DateTimeOffset>(type);
        }

        internal static bool IsTimeRelated(Type type)
        {
            return IsType<TimeOfDay>(type) || IsType<DateTime>(type) || IsType<DateTimeOffset>(type) || IsType<TimeSpan>(type);
        }

        internal static bool IsDateOrOffset(Type type)
        {
            return IsType<DateTime>(type) || IsType<DateTimeOffset>(type);
        }

        internal static bool IsDateTime(Type type)
        {
            return IsType<DateTime>(type);
        }

        internal static bool IsTimeSpan(Type type)
        {
            return IsType<TimeSpan>(type);
        }

        internal static bool IsTimeOfDay(Type type)
        {
            return IsType<TimeOfDay>(type);
        }

        internal static bool IsDate(Type type)
        {
            return IsType<Date>(type);
        }

        internal static bool IsInteger(Type type)
        {
            return IsType<short>(type) || IsType<int>(type) || IsType<long>(type);
        }

        internal static bool IsType<T>(Type type) where T : struct
        {
            return type == typeof(T) || type == typeof(T?);
        }

        internal static Expression ConvertNull(Expression expression, Type type)
        {
            if (expression is ConstantExpression constantExpression && constantExpression.Value == null)
            {
                return Expression.Constant(null, type);
            }
            else
            {
                return expression;
            }
        }

        /// <summary>
        /// Recognize $it.Source where $it is FlatteningWrapper
        /// Using that do avoid wrapping it redundant into Null propagation 
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        private bool IsFlatteningSource(Expression source)
        {
            return source is MemberExpression member
                && this.Parameter.Type.IsGenericType() 
                && this.Parameter.Type.GetGenericTypeDefinition() == typeof(FlatteningWrapper<>)
                && member.Expression == this.Parameter;
        }

        internal Expression CreatePropertyAccessExpression(Expression source, IEdmProperty property, string propertyPath = null)
        {
            string propertyName = EdmLibHelpers.GetClrPropertyName(property, Model);
            propertyPath = propertyPath ?? propertyName;
            if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True && IsNullable(source.Type) &&
                source != this.Parameter &&
                !IsFlatteningSource(source))
            {
                Expression cleanSource = RemoveInnerNullPropagation(source);
                Expression propertyAccessExpression = null;
                propertyAccessExpression = GetFlattenedPropertyExpression(propertyPath) ?? Expression.Property(cleanSource, propertyName);

                // source.property => source == null ? null : [CastToNullable]RemoveInnerNullPropagation(source).property
                // Notice that we are checking if source is null already. so we can safely remove any null checks when doing source.Property

                Expression ifFalse = ToNullable(ConvertNonStandardPrimitives(propertyAccessExpression));
                return
                    Expression.Condition(
                        test: Expression.Equal(source, NullConstant),
                        ifTrue: Expression.Constant(null, ifFalse.Type),
                        ifFalse: ifFalse);
            }
            else
            {
                return GetFlattenedPropertyExpression(propertyPath)
                    ?? ConvertNonStandardPrimitives(ExpressionBinderBase.GetPropertyExpression(source, (this.HasInstancePropertyContainer && !propertyPath.Contains("\\") ? "Instance\\" : String.Empty) + propertyName));
            }
        }

        internal static Expression GetPropertyExpression(Expression source, string propertyPath)
        {
            string[] propertyNameParts = propertyPath.Split('\\');
            Expression propertyValue = source;
            foreach (var propertyName in propertyNameParts)
            {
                propertyValue = Expression.Property(propertyValue, propertyName);
            }
            return propertyValue;
        }

        /// <summary>
        /// Binds a <see cref="QueryNode"/> to create a LINQ <see cref="Expression"/> that represents the semantics
        /// of the <see cref="QueryNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
            Justification = "These are simple conversion function and cannot be split up.")]
        public abstract Expression Bind(QueryNode node);

        /// <summary>
        /// Gets $it parameter
        /// </summary>
        /// <returns></returns>
        protected abstract ParameterExpression Parameter { get; }

        /// <summary>
        /// Binds a <see cref="ConstantNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="ConstantNode"/>.
        /// </summary>
        /// <param name="constantNode">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        public virtual Expression BindConstantNode(ConstantNode constantNode)
        {
            Contract.Assert(constantNode != null);

            // no need to parameterize null's as there cannot be multiple values for null.
            if (constantNode.Value == null)
            {
                return NullConstant;
            }

            object value = constantNode.Value;
            Type constantType = RetrieveClrTypeForConstant(constantNode.TypeReference, ref value);

            if (QuerySettings.EnableConstantParameterization)
            {
                return LinqParameterContainer.Parameterize(constantType, value);
            }
            else
            {
                return Expression.Constant(value, constantType);
            }
        }

        /// <summary>
        /// Binds a <see cref="SingleValueFunctionCallNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="SingleValueFunctionCallNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity",
                        Justification = "These are simple binding functions and cannot be split up.")]
        public virtual Expression BindSingleValueFunctionCallNode(SingleValueFunctionCallNode node)
        {
            switch (node.Name)
            {
                case ClrCanonicalFunctions.StartswithFunctionName:
                    return BindStartsWith(node);

                case ClrCanonicalFunctions.EndswithFunctionName:
                    return BindEndsWith(node);

                case ClrCanonicalFunctions.ContainsFunctionName:
                    return BindContains(node);

                case ClrCanonicalFunctions.SubstringFunctionName:
                    return BindSubstring(node);

                case ClrCanonicalFunctions.LengthFunctionName:
                    return BindLength(node);

                case ClrCanonicalFunctions.IndexofFunctionName:
                    return BindIndexOf(node);

                case ClrCanonicalFunctions.TolowerFunctionName:
                    return BindToLower(node);

                case ClrCanonicalFunctions.ToupperFunctionName:
                    return BindToUpper(node);

                case ClrCanonicalFunctions.TrimFunctionName:
                    return BindTrim(node);

                case ClrCanonicalFunctions.ConcatFunctionName:
                    return BindConcat(node);

                case ClrCanonicalFunctions.YearFunctionName:
                case ClrCanonicalFunctions.MonthFunctionName:
                case ClrCanonicalFunctions.DayFunctionName:
                    return BindDateRelatedProperty(node); // Date & DateTime & DateTimeOffset

                case ClrCanonicalFunctions.HourFunctionName:
                case ClrCanonicalFunctions.MinuteFunctionName:
                case ClrCanonicalFunctions.SecondFunctionName:
                    return BindTimeRelatedProperty(node); // TimeOfDay & DateTime & DateTimeOffset

                case ClrCanonicalFunctions.FractionalSecondsFunctionName:
                    return BindFractionalSeconds(node);

                case ClrCanonicalFunctions.RoundFunctionName:
                    return BindRound(node);

                case ClrCanonicalFunctions.FloorFunctionName:
                    return BindFloor(node);

                case ClrCanonicalFunctions.CeilingFunctionName:
                    return BindCeiling(node);

                case ClrCanonicalFunctions.CastFunctionName:
                    return BindCastSingleValue(node);

                case ClrCanonicalFunctions.IsofFunctionName:
                    return BindIsOf(node);

                case ClrCanonicalFunctions.DateFunctionName:
                    return BindDate(node);

                case ClrCanonicalFunctions.TimeFunctionName:
                    return BindTime(node);

                case ClrCanonicalFunctions.NowFunctionName:
                    return BindNow(node);

                default:
                    // Get Expression of custom binded method.
                    Expression expression = BindCustomMethodExpressionOrNull(node);
                    if (expression != null)
                    {
                        return expression;
                    }

                    throw new NotImplementedException(Error.Format(SRResources.ODataFunctionNotSupported, node.Name));
            }
        }

        /// <summary>
        /// Binds a <see cref="CollectionConstantNode"/> to create a LINQ <see cref="Expression"/> that
        /// represents the semantics of the <see cref="CollectionConstantNode"/>.
        /// </summary>
        /// <param name="node">The node to bind.</param>
        /// <returns>The LINQ <see cref="Expression"/> created.</returns>
        public virtual Expression BindCollectionConstantNode(CollectionConstantNode node)
        {
            // It's fine if the collection is empty; the returned value will be an empty list.
            ConstantNode firstNode = node.Collection.FirstOrDefault();
            object value = null;
            if (firstNode != null)
            {
                value = firstNode.Value;
            }

            Type constantType = RetrieveClrTypeForConstant(node.ItemType, ref value);
            Type nullableConstantType = node.ItemType.IsNullable && constantType.IsValueType && Nullable.GetUnderlyingType(constantType) == null
                ? typeof(Nullable<>).MakeGenericType(constantType)
                : constantType;
            Type listType = typeof(List<>).MakeGenericType(nullableConstantType);
            IList castedList = Activator.CreateInstance(listType) as IList;

            // Getting a LINQ expression to dynamically cast each item in the Collection during runtime is tricky,
            // so using a foreach loop and doing an implicit cast from object to the CLR type of ItemType.
            foreach (ConstantNode item in node.Collection)
            {
                object member;
                if (item.Value == null)
                {
                    member = null;
                }
                else if (constantType.IsEnum)
                {
                    member = EnumDeserializationHelpers.ConvertEnumValue(item.Value, constantType);
                }
                else
                {
                    member = item.Value;
                }

                castedList.Add(member);
            }

            if (QuerySettings.EnableConstantParameterization)
            {
                return LinqParameterContainer.Parameterize(listType, castedList);
            }

            return Expression.Constant(castedList, listType);
        }

        private Expression BindCastSingleValue(SingleValueFunctionCallNode node)
        {
            Contract.Assert(ClrCanonicalFunctions.CastFunctionName == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 || arguments.Length == 2);

            Expression source = arguments.Length == 1 ? this.Parameter : arguments[0];
            string targetTypeName = (string)((ConstantNode)node.Parameters.Last()).Value;
            IEdmType targetEdmType = Model.FindType(targetTypeName);
            Type targetClrType = null;

            if (targetEdmType != null)
            {
                IEdmTypeReference targetEdmTypeReference = targetEdmType.ToEdmTypeReference(false);
                targetClrType = EdmLibHelpers.GetClrType(targetEdmTypeReference, Model);

                if (source != NullConstant)
                {
                    if (source.Type == targetClrType)
                    {
                        return source;
                    }

                    if ((!targetEdmTypeReference.IsPrimitive() && !targetEdmTypeReference.IsEnum()) ||
                        (EdmLibHelpers.GetEdmPrimitiveTypeOrNull(source.Type) == null && !TypeHelper.IsEnum(source.Type)))
                    {
                        // Cast fails and return null.
                        return NullConstant;
                    }
                }
            }

            if (targetClrType == null || source == NullConstant)
            {
                return NullConstant;
            }

            if (targetClrType == typeof(string))
            {
                return BindCastToStringType(source);
            }
            else if (TypeHelper.IsEnum(targetClrType))
            {
                return BindCastToEnumType(source.Type, targetClrType, node.Parameters.First(), arguments.Length);
            }
            else
            {
                if (TypeHelper.IsNullable(source.Type) && !TypeHelper.IsNullable(targetClrType))
                {
                    // Make the target Clr type nullable to avoid failure while casting
                    // nullable source, whose value may be null, to a non-nullable type.
                    // For example: cast(NullableInt32Property,Edm.Int64)
                    // The target Clr type should be Nullable<Int64> rather than Int64.
                    targetClrType = typeof(Nullable<>).MakeGenericType(targetClrType);
                }

                try
                {
                    return Expression.Convert(source, targetClrType);
                }
                catch (InvalidOperationException)
                {
                    // Cast fails and return null.
                    return NullConstant;
                }
            }
        }

        private static Expression BindCastToStringType(Expression source)
        {
            Expression sourceValue;

            if (TypeHelper.IsGenericType(source.Type) && source.Type.GetGenericTypeDefinition() == typeof(Nullable<>))
            {
                if (TypeHelper.IsEnum(source.Type))
                {
                    // Entity Framework doesn't have ToString method for enum types.
                    // Convert enum types to their underlying numeric types.
                    sourceValue = Expression.Convert(
                        Expression.Property(source, "Value"),
                        Enum.GetUnderlyingType(TypeHelper.GetUnderlyingTypeOrSelf(source.Type)));
                }
                else
                {
                    // Entity Framework has ToString method for numeric types.
                    sourceValue = Expression.Property(source, "Value");
                }

                // Entity Framework doesn't have ToString method for nullable numeric types.
                // Call ToString method on non-nullable numeric types.
                return Expression.Condition(
                    Expression.Property(source, "HasValue"),
                    Expression.Call(sourceValue, "ToString", typeArguments: null, arguments: null),
                    Expression.Constant(null, typeof(string)));
            }
            else
            {
                sourceValue = TypeHelper.IsEnum(source.Type) ?
                    Expression.Convert(source, Enum.GetUnderlyingType(source.Type)) :
                    source;
                return Expression.Call(sourceValue, "ToString", typeArguments: null, arguments: null);
            }
        }

        private Expression BindCastToEnumType(Type sourceType, Type targetClrType, QueryNode firstParameter, int parameterLength)
        {
            Type enumType = TypeHelper.GetUnderlyingTypeOrSelf(targetClrType);
            ConstantNode sourceNode = firstParameter as ConstantNode;

            if (parameterLength == 1 || sourceNode == null || sourceType != typeof(string))
            {
                // We only support to cast Enumeration type from constant string now,
                // because LINQ to Entities does not recognize the method Enum.TryParse.
                return NullConstant;
            }
            else
            {
                object[] parameters = new[] { sourceNode.Value, Enum.ToObject(enumType, 0) };
                bool isSuccessful = (bool)EnumTryParseMethod.MakeGenericMethod(enumType).Invoke(null, parameters);

                if (isSuccessful)
                {
                    if (QuerySettings.EnableConstantParameterization)
                    {
                        return LinqParameterContainer.Parameterize(targetClrType, parameters[1]);
                    }
                    else
                    {
                        return Expression.Constant(parameters[1], targetClrType);
                    }
                }
                else
                {
                    return NullConstant;
                }
            }
        }

        private Expression BindIsOf(SingleValueFunctionCallNode node)
        {
            Contract.Assert(ClrCanonicalFunctions.IsofFunctionName == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // Edm.Boolean isof(type)  or
            // Edm.Boolean isof(expression,type)
            Contract.Assert(arguments.Length == 1 || arguments.Length == 2);

            Expression source = arguments.Length == 1 ? this.Parameter : arguments[0];
            if (source == NullConstant)
            {
                return FalseConstant;
            }

            string typeName = (string)((ConstantNode)node.Parameters.Last()).Value;

            IEdmType edmType = Model.FindType(typeName);
            Type clrType = null;
            if (edmType != null)
            {
                // bool nullable = source.Type.IsNullable();
                IEdmTypeReference edmTypeReference = edmType.ToEdmTypeReference(false);
                clrType = EdmLibHelpers.GetClrType(edmTypeReference, Model);
            }

            if (clrType == null)
            {
                return FalseConstant;
            }

            bool isSourcePrimitiveOrEnum = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(source.Type) != null ||
                                           TypeHelper.IsEnum(source.Type);

            bool isTargetPrimitiveOrEnum = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(clrType) != null ||
                                           TypeHelper.IsEnum(clrType);

            if (isSourcePrimitiveOrEnum && isTargetPrimitiveOrEnum)
            {
                if (TypeHelper.IsNullable(source.Type))
                {
                    clrType = TypeHelper.ToNullable(clrType);
                }
            }

            // Be caution: Type method of LINQ to Entities only supports entity type.
            return Expression.Condition(Expression.TypeIs(source, clrType), TrueConstant, FalseConstant);
        }

        private Expression BindCeiling(SingleValueFunctionCallNode node)
        {
            Contract.Assert("ceiling" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo ceiling = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.CeilingOfDouble
                : ClrCanonicalFunctions.CeilingOfDecimal;
            return MakeFunctionCall(ceiling, arguments);
        }

        private Expression BindFloor(SingleValueFunctionCallNode node)
        {
            Contract.Assert("floor" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo floor = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.FloorOfDouble
                : ClrCanonicalFunctions.FloorOfDecimal;
            return MakeFunctionCall(floor, arguments);
        }

        private Expression BindRound(SingleValueFunctionCallNode node)
        {
            Contract.Assert("round" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            Contract.Assert(arguments.Length == 1 && IsDoubleOrDecimal(arguments[0].Type));

            MethodInfo round = IsType<double>(arguments[0].Type)
                ? ClrCanonicalFunctions.RoundOfDouble
                : ClrCanonicalFunctions.RoundOfDecimal;
            return MakeFunctionCall(round, arguments);
        }

        private Expression BindDate(SingleValueFunctionCallNode node)
        {
            Contract.Assert("date" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Contract.Assert(arguments.Length == 1 && IsDateOrOffset(arguments[0].Type));

            // EF doesn't support new Date(int, int, int), also doesn't support other property access, for example DateTime.Date.
            // Therefore, we just return the source (DateTime or DateTimeOffset).
            return arguments[0];
        }

        private Expression BindNow(SingleValueFunctionCallNode node)
        {
            Contract.Assert("now" == node.Name);

            // Function Now() does not take any arguemnts.
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 0);

            return Expression.Property(null, typeof(DateTimeOffset), "UtcNow");
        }

        private Expression BindTime(SingleValueFunctionCallNode node)
        {
            Contract.Assert("time" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Contract.Assert(arguments.Length == 1 && IsDateOrOffset(arguments[0].Type));

            // EF doesn't support new TimeOfDay(int, int, int, int), also doesn't support other property access, for example DateTimeOffset.DateTime.
            // Therefore, we just return the source (DateTime or DateTimeOffset).
            return arguments[0];
        }

        private Expression BindFractionalSeconds(SingleValueFunctionCallNode node)
        {
            Contract.Assert("fractionalseconds" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && (IsTimeRelated(arguments[0].Type)));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsTimeOfDay(parameter.Type))
            {
                property = ClrCanonicalFunctions.TimeOfDayProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else if (IsDateTime(parameter.Type))
            {
                property = ClrCanonicalFunctions.DateTimeProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else if (IsTimeSpan(parameter.Type))
            {
                property = ClrCanonicalFunctions.TimeSpanProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }
            else
            {
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[ClrCanonicalFunctions.MillisecondFunctionName];
            }

            // Millisecond
            Expression milliSecond = MakePropertyAccess(property, parameter);
            Expression decimalMilliSecond = Expression.Convert(milliSecond, typeof(decimal));
            Expression fractionalSeconds = Expression.Divide(decimalMilliSecond, Expression.Constant(1000m, typeof(decimal)));

            return CreateFunctionCallWithNullPropagation(fractionalSeconds, arguments);
        }

        private Expression BindDateRelatedProperty(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && IsDateRelated(arguments[0].Type));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsDate(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateProperties[node.Name];
            }
            else if (IsDateTime(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeProperties[node.Name];
            }
            else
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeOffsetProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[node.Name];
            }

            return MakeFunctionCall(property, parameter);
        }

        private Expression BindTimeRelatedProperty(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            Contract.Assert(arguments.Length == 1 && (IsTimeRelated(arguments[0].Type)));

            // We should support DateTime & DateTimeOffset even though DateTime is not part of OData v4 Spec.
            Expression parameter = arguments[0];

            PropertyInfo property;
            if (IsTimeOfDay(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.TimeOfDayProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.TimeOfDayProperties[node.Name];
            }
            else if (IsDateTime(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeProperties[node.Name];
            }
            else if (IsTimeSpan(parameter.Type))
            {
                Contract.Assert(ClrCanonicalFunctions.TimeSpanProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.TimeSpanProperties[node.Name];
            }
            else
            {
                Contract.Assert(ClrCanonicalFunctions.DateTimeOffsetProperties.ContainsKey(node.Name));
                property = ClrCanonicalFunctions.DateTimeOffsetProperties[node.Name];
            }

            return MakeFunctionCall(property, parameter);
        }

        private Expression BindConcat(SingleValueFunctionCallNode node)
        {
            Contract.Assert("concat" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Concat, arguments);
        }

        private Expression BindTrim(SingleValueFunctionCallNode node)
        {
            Contract.Assert("trim" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Trim, arguments);
        }

        private Expression BindToUpper(SingleValueFunctionCallNode node)
        {
            Contract.Assert("toupper" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.ToUpper, arguments);
        }

        private Expression BindToLower(SingleValueFunctionCallNode node)
        {
            Contract.Assert("tolower" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.ToLower, arguments);
        }

        private Expression BindIndexOf(SingleValueFunctionCallNode node)
        {
            Contract.Assert("indexof" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.IndexOf, arguments);
        }

        private Expression BindSubstring(SingleValueFunctionCallNode node)
        {
            Contract.Assert("substring" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            if (arguments[0].Type != typeof(string))
            {
                throw new ODataException(Error.Format(SRResources.FunctionNotSupportedOnEnum, node.Name));
            }

            Expression functionCall;
            if (arguments.Length == 2)
            {
                Contract.Assert(IsInteger(arguments[1].Type));

                // When null propagation is allowed, we use a safe version of String.Substring(int).
                // But for providers that would not recognize custom expressions like this, we map
                // directly to String.Substring(int)
                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // Safe function is static and takes string "this" as first argument
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartNoThrow, arguments);
                }
                else
                {
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStart, arguments);
                }
            }
            else
            {
                // arguments.Length == 3 implies String.Substring(int, int)
                Contract.Assert(arguments.Length == 3 && IsInteger(arguments[1].Type) && IsInteger(arguments[2].Type));

                // When null propagation is allowed, we use a safe version of String.Substring(int, int).
                // But for providers that would not recognize custom expressions like this, we map
                // directly to String.Substring(int, int)
                if (QuerySettings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // Safe function is static and takes string "this" as first argument
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartAndLengthNoThrow, arguments);
                }
                else
                {
                    functionCall = MakeFunctionCall(ClrCanonicalFunctions.SubstringStartAndLength, arguments);
                }
            }

            return functionCall;
        }

        private Expression BindLength(SingleValueFunctionCallNode node)
        {
            Contract.Assert("length" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 1 && arguments[0].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Length, arguments);
        }

        private Expression BindContains(SingleValueFunctionCallNode node)
        {
            Contract.Assert("contains" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.Contains, arguments[0], arguments[1]);
        }

        private Expression BindStartsWith(SingleValueFunctionCallNode node)
        {
            Contract.Assert("startswith" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.StartsWith, arguments);
        }

        private Expression BindEndsWith(SingleValueFunctionCallNode node)
        {
            Contract.Assert("endswith" == node.Name);

            Expression[] arguments = BindArguments(node.Parameters);
            ValidateAllStringArguments(node.Name, arguments);

            Contract.Assert(arguments.Length == 2 && arguments[0].Type == typeof(string) && arguments[1].Type == typeof(string));

            return MakeFunctionCall(ClrCanonicalFunctions.EndsWith, arguments);
        }

        /// <summary>
        /// Bind function arguments
        /// </summary>
        /// <param name="nodes"></param>
        /// <returns></returns>
        protected Expression[] BindArguments(IEnumerable<QueryNode> nodes)
        {
            return nodes.OfType<SingleValueNode>().Select(n => Bind(n)).ToArray();
        }

        private static void ValidateAllStringArguments(string functionName, Expression[] arguments)
        {
            if (arguments.Any(arg => arg.Type != typeof(string)))
            {
                throw new ODataException(Error.Format(SRResources.FunctionNotSupportedOnEnum, functionName));
            }
        }

        private Expression BindCustomMethodExpressionOrNull(SingleValueFunctionCallNode node)
        {
            Expression[] arguments = BindArguments(node.Parameters);
            IEnumerable<Type> methodArgumentsType = arguments.Select(argument => argument.Type);

            // Search for custom method info that are binded to the node name
            MethodInfo methodInfo;
            if (UriFunctionsBinder.TryGetMethodInfo(node.Name, methodArgumentsType, out methodInfo))
            {
                return MakeFunctionCall(methodInfo, arguments);
            }

            return null;
        }

        private Type RetrieveClrTypeForConstant(IEdmTypeReference edmTypeReference, ref object value)
        {
            Type constantType = EdmLibHelpers.GetClrType(edmTypeReference, Model, InternalAssembliesResolver);

            if (value != null && edmTypeReference != null && edmTypeReference.IsEnum())
            {
                ODataEnumValue odataEnumValue = (ODataEnumValue)value;
                string strValue = odataEnumValue.Value;
                Contract.Assert(strValue != null);

                constantType = Nullable.GetUnderlyingType(constantType) ?? constantType;

                IEdmEnumType enumType = edmTypeReference.AsEnum().EnumDefinition();
                ClrEnumMemberAnnotation memberMapAnnotation = Model.GetClrEnumMemberAnnotation(enumType);
                if (memberMapAnnotation != null)
                {
                    IEdmEnumMember enumMember = enumType.Members.FirstOrDefault(m => m.Name == strValue);
                    if (enumMember == null)
                    {
                        enumMember = enumType.Members.FirstOrDefault(m => m.Value.ToString() == strValue);
                    }

                    if (enumMember != null)
                    {
                        Enum clrMember = memberMapAnnotation.GetClrEnumMember(enumMember);
                        if (clrMember != null)
                        {
                            value = clrMember;
                        }
                        else
                        {
                            throw new ODataException(Error.Format(SRResources.CannotGetEnumClrMember, enumMember.Name));
                        }
                    }
                    else
                    {
                        value = Enum.Parse(constantType, strValue);
                    }
                }
                else
                {
                    value = Enum.Parse(constantType, strValue);
                }
            }

            if (edmTypeReference != null &&
                edmTypeReference.IsNullable &&
                (edmTypeReference.IsDate() || edmTypeReference.IsTimeOfDay()))
            {
                constantType = Nullable.GetUnderlyingType(constantType) ?? constantType;
            }

            return constantType;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(491,60): error CS0165: Use of unassigned local variable 'unaryExpression',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(668,21): error CS0841: Cannot use local variable 'computeExpression' before it is declared,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(668,53): error CS0841: Cannot use local variable 'computeExpression' before it is declared,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(874,51): error CS8116: It is not legal to use nullable type 'DateTimeOffset?' in a pattern; use the underlying type 'DateTimeOffset' instead.,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(879,51): error CS8116: It is not legal to use nullable type 'DateTime?' in a pattern; use the underlying type 'DateTime' instead.,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(884,51): error CS8116: It is not legal to use nullable type 'Date?' in a pattern; use the underlying type 'Date' instead.,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(889,51): error CS8116: It is not legal to use nullable type 'TimeOfDay?' in a pattern; use the underlying type 'TimeOfDay' instead.,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(943,21): error CS0165: Use of unassigned local variable 'memberAccess',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(951,37): error CS0165: Use of unassigned local variable 'constant',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(954,28): error CS0165: Use of unassigned local variable 'value',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\ExpressionBinderBase.cs(973,47): error CS8116: It is not legal to use nullable type 'DateTimeOffset?' in a pattern; use the underlying type 'DateTimeOffset' instead.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataEnumDeserializer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    /// <summary>
    /// Represents an <see cref="ODataDeserializer"/> that can read OData enum types.
    /// </summary>
    public class ODataEnumDeserializer : ODataEdmTypeDeserializer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ODataEnumDeserializer"/> class.
        /// </summary>
        public ODataEnumDeserializer()
            : base(ODataPayloadKind.Property)
        {
        }

        /// <inheritdoc />
        public override object Read(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }
            if (type == null)
            {
                throw Error.ArgumentNull("type");
            }
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            ODataProperty property = messageReader.ReadProperty(edmType);
            return ReadInline(property, edmType, readContext);
        }

        /// <inheritdoc />
        public override async Task<object> ReadAsync(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }
            if (type == null)
            {
                throw Error.ArgumentNull("type");
            }
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            ODataProperty property = await messageReader.ReadPropertyAsync(edmType);
            return ReadInline(property, edmType, readContext);
        }

        /// <inheritdoc />
        public override object ReadInline(object item, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            if (item == null)
            {
                return null;
            }

            ODataProperty property = item as ODataProperty;
            if (property != null)
            {
                item = property.Value;
            }

            IEdmEnumTypeReference enumTypeReference = edmType.AsEnum();
            ODataEnumValue enumValue = item as ODataEnumValue;
            if (readContext.IsUntyped)
            {
                Contract.Assert(edmType.TypeKind() == EdmTypeKind.Enum);
                return new EdmEnumObject(enumTypeReference, enumValue.Value);
            }

            IEdmEnumType enumType = enumTypeReference.EnumDefinition();

            // Enum member supports model alias case. So, try to use the Edm member name to retrieve the Enum value.
            var memberMapAnnotation = readContext.Model.GetClrEnumMemberAnnotation(enumType);
            if (memberMapAnnotation != null)
            {
                if (enumValue != null)
                {
                    IEdmEnumMember enumMember = enumType.Members.FirstOrDefault(m => m.Name == enumValue.Value);
                    if (enumMember != null)
                    {
                        var clrMember = memberMapAnnotation.GetClrEnumMember(enumMember);
                        if (clrMember != null)
                        {
                            return clrMember;
                        }
                    }
                }
            }

            Type clrType = EdmLibHelpers.GetClrType(edmType, readContext.Model);
            return EnumDeserializationHelpers.ConvertEnumValue(item, clrType);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    /// <summary>
    /// Represents an <see cref="ODataDeserializer"/> that can read OData enum types.
    /// </summary>
    public class ODataEnumDeserializer : ODataEdmTypeDeserializer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ODataEnumDeserializer"/> class.
        /// </summary>
        public ODataEnumDeserializer()
            : base(ODataPayloadKind.Property)
        {
        }

        /// <inheritdoc />
        public override object Read(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }
            if (type == null)
            {
                throw Error.ArgumentNull("type");
            }
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            ODataProperty property = messageReader.ReadProperty(edmType);
            return ReadInline(property, edmType, readContext);
        }

        /// <inheritdoc />
        public override async Task<object> ReadAsync(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }
            if (type == null)
            {
                throw Error.ArgumentNull("type");
            }
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            ODataProperty property = await messageReader.ReadPropertyAsync(edmType);
            return ReadInline(property, edmType, readContext);
        }

        /// <inheritdoc />
        public override object ReadInline(object item, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            if (item == null)
            {
                return null;
            }

            if (item is ODataProperty property)
            {
                item = property.Value;
            }

            IEdmEnumTypeReference enumTypeReference = edmType.AsEnum();
            if (readContext.IsUntyped)
            {
                Contract.Assert(edmType.TypeKind() == EdmTypeKind.Enum);
                return new EdmEnumObject(enumTypeReference, enumValue.Value);
            }

            IEdmEnumType enumType = enumTypeReference.EnumDefinition();

            // Enum member supports model alias case. So, try to use the Edm member name to retrieve the Enum value.
            var memberMapAnnotation = readContext.Model.GetClrEnumMemberAnnotation(enumType);
            if (memberMapAnnotation != null)
            {
                if (item is ODataEnumValue enumValue)
                {
                    IEdmEnumMember enumMember = enumType.Members.FirstOrDefault(m => m.Name == enumValue.Value);
                    if (enumMember != null)
                    {
                        var clrMember = memberMapAnnotation.GetClrEnumMember(enumMember);
                        if (clrMember != null)
                        {
                            return clrMember;
                        }
                    }
                }
            }

            Type clrType = EdmLibHelpers.GetClrType(edmType, readContext.Model);
            return EnumDeserializationHelpers.ConvertEnumValue(item, clrType);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataEnumDeserializer.cs(90,61): error CS0103: The name 'enumValue' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataEnumDeserializer.cs(90,42): error CS1503: Argument 1: cannot convert from 'Microsoft.OData.Edm.IEdmEnumTypeReference' to 'Microsoft.OData.Edm.IEdmEnumType'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\LinkGenerationHelpers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using Microsoft.AspNet.OData.Builder.Conventions;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Formatter.Deserialization;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;
using ODataPath = Microsoft.AspNet.OData.Routing.ODataPath;

namespace Microsoft.AspNet.OData.Builder
{
    /// <summary>
    /// Contains helper methods for generating OData links that follow OData URL conventions.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static class LinkGenerationHelpers
    {
        /// <summary>
        /// Generates a self link following the OData URL conventions for the entity represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the self link needs to be generated.</param>
        /// <param name="includeCast">Represents whether the generated link should have a cast segment representing a type cast.</param>
        /// <returns>The self link following the OData URL conventions.</returns>
        public static Uri GenerateSelfLink(this ResourceContext resourceContext, bool includeCast)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (resourceContext.InternalUrlHelper == null)
            {
                throw Error.Argument("resourceContext", SRResources.UrlHelperNull, typeof(ResourceContext).Name);
            }

            IList<ODataPathSegment> idLinkPathSegments = resourceContext.GenerateBaseODataPathSegments();

            bool isSameType = resourceContext.StructuredType == resourceContext.NavigationSource.EntityType();
            if (includeCast && !isSameType)
            {
                idLinkPathSegments.Add(new TypeSegment(resourceContext.StructuredType, navigationSource: null));
            }

            string idLink = resourceContext.InternalUrlHelper.CreateODataLink(idLinkPathSegments);
            if (idLink == null)
            {
                return null;
            }

            return new Uri(idLink);
        }

        /// <summary>
        /// Generates a navigation link following the OData URL conventions for the entity represented by <paramref name="resourceContext"/> and the given 
        /// navigation property.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the navigation link needs to be generated.</param>
        /// <param name="navigationProperty">The EDM navigation property.</param>
        /// <param name="includeCast">Represents whether the generated link should have a cast segment representing a type cast.</param>
        /// <returns>The navigation link following the OData URL conventions.</returns>
        public static Uri GenerateNavigationPropertyLink(this ResourceContext resourceContext,
            IEdmNavigationProperty navigationProperty, bool includeCast)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (resourceContext.InternalUrlHelper == null)
            {
                throw Error.Argument("resourceContext", SRResources.UrlHelperNull, typeof(ResourceContext).Name);
            }

            IList<ODataPathSegment> navigationPathSegments = resourceContext.GenerateBaseODataPathSegments();

            if (includeCast)
            {
                navigationPathSegments.Add(new TypeSegment(resourceContext.StructuredType, navigationSource: null));
            }

            navigationPathSegments.Add(new NavigationPropertySegment(navigationProperty, navigationSource: null));

            string link = resourceContext.InternalUrlHelper.CreateODataLink(navigationPathSegments);
            if (link == null)
            {
                return null;
            }

            return new Uri(link);
        }

        /// <summary>
        /// Generates an action link following the OData URL conventions for the action <paramref name="action"/> and bound to the
        /// collection of entity represented by <paramref name="resourceSetContext"/>.
        /// </summary>
        /// <param name="resourceSetContext">The <see cref="ResourceSetContext"/> representing the feed for which the action link needs to be generated.</param>
        /// <param name="action">The action for which the action link needs to be generated.</param>
        /// <returns>The generated action link following OData URL conventions.</returns>
        public static Uri GenerateActionLink(this ResourceSetContext resourceSetContext, IEdmOperation action)
        {
            if (resourceSetContext == null)
            {
                throw Error.ArgumentNull("resourceSetContext");
            }

            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
            if (bindingParameter == null ||
                !bindingParameter.Type.IsCollection() ||
                !((IEdmCollectionType)bindingParameter.Type.Definition).ElementType.IsEntity())
            {
                throw Error.Argument("action", SRResources.ActionNotBoundToCollectionOfEntity, action.Name);
            }

            return GenerateActionLink(resourceSetContext, bindingParameter.Type, action);
        }

        internal static Uri GenerateActionLink(this ResourceSetContext feedContext, string bindingParameterType,
            string actionName)
        {
            Contract.Assert(feedContext != null);

            if (feedContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            if (feedContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = feedContext.EdmModel;
            string elementType = DeserializationHelpers.GetCollectionElementTypeName(bindingParameterType,
                isNested: false);
            Contract.Assert(elementType != null);

            IEdmTypeReference typeReference = model.FindDeclaredType(elementType).ToEdmTypeReference(true);
            IEdmTypeReference collection = new EdmCollectionTypeReference(new EdmCollectionType(typeReference));

            IEdmOperation operation = model.FindDeclaredOperations(actionName).First();
            return feedContext.GenerateActionLink(collection, operation);
        }

        internal static Uri GenerateActionLink(this ResourceSetContext resourceSetContext, IEdmTypeReference bindingParameterType,
            IEdmOperation action)
        {
            Contract.Assert(resourceSetContext != null);

            if (resourceSetContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> actionPathSegments = new List<ODataPathSegment>();
            resourceSetContext.GenerateBaseODataPathSegmentsForFeed(actionPathSegments);

            // generate link with cast if the navigation source doesn't match the type the action is bound to.
            if (resourceSetContext.EntitySetBase.Type.FullTypeName() != bindingParameterType.FullName())
            {
                actionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, resourceSetContext.EntitySetBase));
            }

            OperationSegment operationSegment = new OperationSegment(action, entitySet: null);
            actionPathSegments.Add(operationSegment);

            string actionLink = resourceSetContext.InternalUrlHelper.CreateODataLink(actionPathSegments);
            return actionLink == null ? null : new Uri(actionLink);
        }

        /// <summary>
        /// Generates a function link following the OData URL conventions for the function <paramref name="function"/> and bound to the
        /// collection of entity represented by <paramref name="resourceSetContext"/>.
        /// </summary>
        /// <param name="resourceSetContext">The <see cref="ResourceSetContext"/> representing the feed for which the function link needs to be generated.</param>
        /// <param name="function">The function for which the function link needs to be generated.</param>
        /// <returns>The generated function link following OData URL conventions.</returns>
        public static Uri GenerateFunctionLink(this ResourceSetContext resourceSetContext, IEdmOperation function)
        {
            if (resourceSetContext == null)
            {
                throw Error.ArgumentNull("resourceSetContext");
            }

            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
            if (bindingParameter == null ||
                !bindingParameter.Type.IsCollection() ||
                !((IEdmCollectionType)bindingParameter.Type.Definition).ElementType.IsEntity())
            {
                throw Error.Argument("function", SRResources.FunctionNotBoundToCollectionOfEntity, function.Name);
            }

            return GenerateFunctionLink(resourceSetContext, bindingParameter.Type, function,
                function.Parameters.Select(p => p.Name));
        }

        internal static Uri GenerateFunctionLink(this ResourceSetContext resourceSetContext, IEdmTypeReference bindingParameterType,
            IEdmOperation functionImport, IEnumerable<string> parameterNames)
        {
            Contract.Assert(resourceSetContext != null);

            if (resourceSetContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> functionPathSegments = new List<ODataPathSegment>();
            resourceSetContext.GenerateBaseODataPathSegmentsForFeed(functionPathSegments);

            // generate link with cast if the navigation source type doesn't match the entity type the function is bound to.
            if (resourceSetContext.EntitySetBase.Type.FullTypeName() != bindingParameterType.Definition.FullTypeName())
            {
                functionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, null));
            }

            IList<OperationSegmentParameter> parameters = new List<OperationSegmentParameter>();
            // skip the binding parameter
            foreach (string param in parameterNames.Skip(1))
            {
                string value = "@" + param;
                parameters.Add(new OperationSegmentParameter(param, new ConstantNode(value, value)));
            }

            OperationSegment segment = new OperationSegment(new[] { functionImport }, parameters, null);
            functionPathSegments.Add(segment);

            string functionLink = resourceSetContext.InternalUrlHelper.CreateODataLink(functionPathSegments);
            return functionLink == null ? null : new Uri(functionLink);
        }

        internal static Uri GenerateFunctionLink(this ResourceSetContext feedContext, string bindingParameterType,
            string functionName, IEnumerable<string> parameterNames)
        {
            Contract.Assert(feedContext != null);

            if (feedContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            if (feedContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = feedContext.EdmModel;

            string elementType = DeserializationHelpers.GetCollectionElementTypeName(bindingParameterType,
                isNested: false);
            Contract.Assert(elementType != null);

            IEdmTypeReference typeReference = model.FindDeclaredType(elementType).ToEdmTypeReference(true);
            IEdmTypeReference collection = new EdmCollectionTypeReference(new EdmCollectionType(typeReference));
            IEdmOperation operation = model.FindDeclaredOperations(functionName).First();
            return feedContext.GenerateFunctionLink(collection, operation, parameterNames);
        }

        /// <summary>
        /// Generates an action link following the OData URL conventions for the action <paramref name="action"/> and bound to the entity
        /// represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the action link needs to be generated.</param>
        /// <param name="action">The action for which the action link needs to be generated.</param>
        /// <returns>The generated action link following OData URL conventions.</returns>
        public static Uri GenerateActionLink(this ResourceContext resourceContext, IEdmOperation action)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
            if (bindingParameter == null || !bindingParameter.Type.IsEntity())
            {
                throw Error.Argument("action", SRResources.ActionNotBoundToEntity, action.Name);
            }

            return GenerateActionLink(resourceContext, bindingParameter.Type, action);
        }

        internal static Uri GenerateActionLink(this ResourceContext resourceContext,
            IEdmTypeReference bindingParameterType, IEdmOperation action)
        {
            Contract.Assert(resourceContext != null);
            if (resourceContext.NavigationSource is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> actionPathSegments = resourceContext.GenerateBaseODataPathSegments();

            // generate link with cast if the navigation source doesn't match the entity type the action is bound to.
            if (resourceContext.NavigationSource.EntityType() != bindingParameterType.Definition)
            {
                actionPathSegments.Add(new TypeSegment((IEdmEntityType)bindingParameterType.Definition, null));
                // entity set can be null
            }

            OperationSegment operationSegment = new OperationSegment(new[] { action }, null);
            actionPathSegments.Add(operationSegment);

            string actionLink = resourceContext.InternalUrlHelper.CreateODataLink(actionPathSegments);
            return actionLink == null ? null : new Uri(actionLink);
        }

        internal static Uri GenerateActionLink(this ResourceContext resourceContext, string bindingParameterType,
            string actionName)
        {
            Contract.Assert(resourceContext != null);
            if (resourceContext.NavigationSource is IEdmContainedEntitySet)
            {
                return null;
            }

            if (resourceContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = resourceContext.EdmModel;
            IEdmTypeReference typeReference = model.FindDeclaredType(bindingParameterType).ToEdmTypeReference(true);
            IEdmOperation operation = model.FindDeclaredOperations(actionName).First();
            return resourceContext.GenerateActionLink(typeReference, operation);
        }

        /// <summary>
        /// Generates an function link following the OData URL conventions for the function <paramref name="function"/> and bound to the entity
        /// represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the function link needs to be generated.</param>
        /// <param name="function">The function for which the function link needs to be generated.</param>
        /// <returns>The generated function link following OData URL conventions.</returns>
        public static Uri GenerateFunctionLink(this ResourceContext resourceContext, IEdmOperation function)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
            if (bindingParameter == null || !bindingParameter.Type.IsEntity())
            {
                throw Error.Argument("function", SRResources.FunctionNotBoundToEntity, function.Name);
            }

            return GenerateFunctionLink(resourceContext, bindingParameter.Type.FullName(), function.FullName(),
                function.Parameters.Select(p => p.Name));
        }

        internal static Uri GenerateFunctionLink(this ResourceContext resourceContext,
            IEdmTypeReference bindingParameterType, IEdmOperation function,
            IEnumerable<string> parameterNames)
        {
            IList<ODataPathSegment> functionPathSegments = resourceContext.GenerateBaseODataPathSegments();

            // generate link with cast if the navigation source type doesn't match the entity type the function is bound to.
            if (resourceContext.NavigationSource.EntityType() != bindingParameterType.Definition)
            {
                functionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, null));
            }

            IList<OperationSegmentParameter> parameters = new List<OperationSegmentParameter>();
            // skip the binding parameter
            foreach (string param in parameterNames.Skip(1))
            {
                string value = "@" + param;
                parameters.Add(new OperationSegmentParameter(param, new ConstantNode(value, value)));
            }

            OperationSegment segment = new OperationSegment(new[] { function }, parameters, null);
            functionPathSegments.Add(segment);

            string functionLink = resourceContext.InternalUrlHelper.CreateODataLink(functionPathSegments);
            return functionLink == null ? null : new Uri(functionLink);
        }

        internal static Uri GenerateFunctionLink(this ResourceContext resourceContext, string bindingParameterType,
            string functionName, IEnumerable<string> parameterNames)
        {
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = resourceContext.EdmModel;
            IEdmTypeReference typeReference = model.FindDeclaredType(bindingParameterType).ToEdmTypeReference(true);
            IEdmOperation operation = model.FindDeclaredOperations(functionName).First();
            return resourceContext.GenerateFunctionLink(typeReference, operation, parameterNames);
        }

        internal static IList<ODataPathSegment> GenerateBaseODataPathSegments(this ResourceContext resourceContext)
        {
            IList<ODataPathSegment> odataPath = new List<ODataPathSegment>();

            if (resourceContext.NavigationSource.NavigationSourceKind() == EdmNavigationSourceKind.Singleton)
            {
                // Per the OData V4 specification, a singleton is expected to be a child of the entity container, and
                // as a result we can make the assumption that it is the only segment in the generated path.
                odataPath.Add(new SingletonSegment((IEdmSingleton)resourceContext.NavigationSource));
            }
            else
            {
                resourceContext.GenerateBaseODataPathSegmentsForEntity(odataPath);
            }

            return odataPath;
        }

        private static void GenerateBaseODataPathSegmentsForNonSingletons(
            ODataPath path,
            IEdmNavigationSource navigationSource,
            IList<ODataPathSegment> odataPath)
        {
            // If the navigation is not a singleton we need to walk all of the path segments to generate a
            // contextually accurate URI.
            bool segmentFound = false;
            bool containedFound = false;
            if (path != null)
            {
                var segments = path.Segments;
                int length = segments.Count;
                int previousNavigationPathIndex = -1;
                for (int i = 0; i < length; i++)
                {
                    ODataPathSegment pathSegment = segments[i];
                    IEdmNavigationSource currentNavigationSource = null;

                    var entitySetPathSegment = pathSegment as EntitySetSegment;
                    if (entitySetPathSegment != null)
                    {
                        currentNavigationSource = entitySetPathSegment.EntitySet;
                    }

                    var navigationPathSegment = pathSegment as NavigationPropertySegment;
                    if (navigationPathSegment != null)
                    {
                        currentNavigationSource = navigationPathSegment.NavigationSource;
                    }
                    if (containedFound)
                    {
                        odataPath.Add(pathSegment);
                    }
                    else
                    {
                        if (navigationPathSegment != null &&
                            navigationPathSegment.NavigationProperty.ContainsTarget)
                        {
                            containedFound = true;
                            //The path should have the last non-contained navigation property
                            if (previousNavigationPathIndex != -1)
                            {
                                for (int j = previousNavigationPathIndex; j <= i; j++)
                                {
                                    odataPath.Add(segments[j]);
                                }
                            }
                        }
                    }

                    // If we've found our target navigation in the path that means we've correctly populated the
                    // segments up to the navigation and we can ignore the remaining segments.
                    if (currentNavigationSource != null)
                    {
                        previousNavigationPathIndex = i;
                        if (currentNavigationSource == navigationSource)
                        {
                            segmentFound = true;
                            break;
                        }
                    }
                }
            }

            if (!segmentFound || !containedFound)
            {
                // If the target navigation was not found in the current path that means we lack any context that
                // would suggest a scenario other than directly accessing an entity set, so we must assume that's
                // the case.
                odataPath.Clear();

                IEdmContainedEntitySet containmnent = navigationSource as IEdmContainedEntitySet;
                if (containmnent != null)
                {
                    EdmEntityContainer container = new EdmEntityContainer("NS", "Default");
                    IEdmEntitySet entitySet = new EdmEntitySet(container, navigationSource.Name,
                        navigationSource.EntityType());
                    odataPath.Add(new EntitySetSegment(entitySet));
                }
                else
                {
                    odataPath.Add(new EntitySetSegment((IEdmEntitySet)navigationSource));
                }
            }
        }

        private static void GenerateBaseODataPathSegmentsForEntity(
            this ResourceContext resourceContext,
            IList<ODataPathSegment> odataPath)
        {
            // If the navigation is not a singleton we need to walk all of the path segments to generate a
            // contextually accurate URI.
            GenerateBaseODataPathSegmentsForNonSingletons(
                resourceContext.SerializerContext.Path, resourceContext.NavigationSource, odataPath);

            odataPath.Add(new KeySegment(ConventionsHelpers.GetEntityKey(resourceContext), resourceContext.StructuredType as IEdmEntityType,
                null));
        }

        private static void GenerateBaseODataPathSegmentsForFeed(
            this ResourceSetContext feedContext,
            IList<ODataPathSegment> odataPath)
        {
            GenerateBaseODataPathSegmentsForNonSingletons(feedContext.InternalRequest.Context.Path,
                feedContext.EntitySetBase,
                odataPath);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.Contracts;
using System.Linq;
using Microsoft.AspNet.OData.Builder.Conventions;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Formatter.Deserialization;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;
using ODataPath = Microsoft.AspNet.OData.Routing.ODataPath;

namespace Microsoft.AspNet.OData.Builder
{
    /// <summary>
    /// Contains helper methods for generating OData links that follow OData URL conventions.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static class LinkGenerationHelpers
    {
        /// <summary>
        /// Generates a self link following the OData URL conventions for the entity represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the self link needs to be generated.</param>
        /// <param name="includeCast">Represents whether the generated link should have a cast segment representing a type cast.</param>
        /// <returns>The self link following the OData URL conventions.</returns>
        public static Uri GenerateSelfLink(this ResourceContext resourceContext, bool includeCast)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (resourceContext.InternalUrlHelper == null)
            {
                throw Error.Argument("resourceContext", SRResources.UrlHelperNull, typeof(ResourceContext).Name);
            }

            IList<ODataPathSegment> idLinkPathSegments = resourceContext.GenerateBaseODataPathSegments();

            bool isSameType = resourceContext.StructuredType == resourceContext.NavigationSource.EntityType();
            if (includeCast && !isSameType)
            {
                idLinkPathSegments.Add(new TypeSegment(resourceContext.StructuredType, navigationSource: null));
            }

            string idLink = resourceContext.InternalUrlHelper.CreateODataLink(idLinkPathSegments);
            if (idLink == null)
            {
                return null;
            }

            return new Uri(idLink);
        }

        /// <summary>
        /// Generates a navigation link following the OData URL conventions for the entity represented by <paramref name="resourceContext"/> and the given 
        /// navigation property.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the navigation link needs to be generated.</param>
        /// <param name="navigationProperty">The EDM navigation property.</param>
        /// <param name="includeCast">Represents whether the generated link should have a cast segment representing a type cast.</param>
        /// <returns>The navigation link following the OData URL conventions.</returns>
        public static Uri GenerateNavigationPropertyLink(this ResourceContext resourceContext,
            IEdmNavigationProperty navigationProperty, bool includeCast)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (resourceContext.InternalUrlHelper == null)
            {
                throw Error.Argument("resourceContext", SRResources.UrlHelperNull, typeof(ResourceContext).Name);
            }

            IList<ODataPathSegment> navigationPathSegments = resourceContext.GenerateBaseODataPathSegments();

            if (includeCast)
            {
                navigationPathSegments.Add(new TypeSegment(resourceContext.StructuredType, navigationSource: null));
            }

            navigationPathSegments.Add(new NavigationPropertySegment(navigationProperty, navigationSource: null));

            string link = resourceContext.InternalUrlHelper.CreateODataLink(navigationPathSegments);
            if (link == null)
            {
                return null;
            }

            return new Uri(link);
        }

        /// <summary>
        /// Generates an action link following the OData URL conventions for the action <paramref name="action"/> and bound to the
        /// collection of entity represented by <paramref name="resourceSetContext"/>.
        /// </summary>
        /// <param name="resourceSetContext">The <see cref="ResourceSetContext"/> representing the feed for which the action link needs to be generated.</param>
        /// <param name="action">The action for which the action link needs to be generated.</param>
        /// <returns>The generated action link following OData URL conventions.</returns>
        public static Uri GenerateActionLink(this ResourceSetContext resourceSetContext, IEdmOperation action)
        {
            if (resourceSetContext == null)
            {
                throw Error.ArgumentNull("resourceSetContext");
            }

            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
            if (bindingParameter == null ||
                !bindingParameter.Type.IsCollection() ||
                !((IEdmCollectionType)bindingParameter.Type.Definition).ElementType.IsEntity())
            {
                throw Error.Argument("action", SRResources.ActionNotBoundToCollectionOfEntity, action.Name);
            }

            return GenerateActionLink(resourceSetContext, bindingParameter.Type, action);
        }

        internal static Uri GenerateActionLink(this ResourceSetContext feedContext, string bindingParameterType,
            string actionName)
        {
            Contract.Assert(feedContext != null);

            if (feedContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            if (feedContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = feedContext.EdmModel;
            string elementType = DeserializationHelpers.GetCollectionElementTypeName(bindingParameterType,
                isNested: false);
            Contract.Assert(elementType != null);

            IEdmTypeReference typeReference = model.FindDeclaredType(elementType).ToEdmTypeReference(true);
            IEdmTypeReference collection = new EdmCollectionTypeReference(new EdmCollectionType(typeReference));

            IEdmOperation operation = model.FindDeclaredOperations(actionName).First();
            return feedContext.GenerateActionLink(collection, operation);
        }

        internal static Uri GenerateActionLink(this ResourceSetContext resourceSetContext, IEdmTypeReference bindingParameterType,
            IEdmOperation action)
        {
            Contract.Assert(resourceSetContext != null);

            if (resourceSetContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> actionPathSegments = new List<ODataPathSegment>();
            resourceSetContext.GenerateBaseODataPathSegmentsForFeed(actionPathSegments);

            // generate link with cast if the navigation source doesn't match the type the action is bound to.
            if (resourceSetContext.EntitySetBase.Type.FullTypeName() != bindingParameterType.FullName())
            {
                actionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, resourceSetContext.EntitySetBase));
            }

            OperationSegment operationSegment = new OperationSegment(action, entitySet: null);
            actionPathSegments.Add(operationSegment);

            string actionLink = resourceSetContext.InternalUrlHelper.CreateODataLink(actionPathSegments);
            return actionLink == null ? null : new Uri(actionLink);
        }

        /// <summary>
        /// Generates a function link following the OData URL conventions for the function <paramref name="function"/> and bound to the
        /// collection of entity represented by <paramref name="resourceSetContext"/>.
        /// </summary>
        /// <param name="resourceSetContext">The <see cref="ResourceSetContext"/> representing the feed for which the function link needs to be generated.</param>
        /// <param name="function">The function for which the function link needs to be generated.</param>
        /// <returns>The generated function link following OData URL conventions.</returns>
        public static Uri GenerateFunctionLink(this ResourceSetContext resourceSetContext, IEdmOperation function)
        {
            if (resourceSetContext == null)
            {
                throw Error.ArgumentNull("resourceSetContext");
            }

            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
            if (bindingParameter == null ||
                !bindingParameter.Type.IsCollection() ||
                !((IEdmCollectionType)bindingParameter.Type.Definition).ElementType.IsEntity())
            {
                throw Error.Argument("function", SRResources.FunctionNotBoundToCollectionOfEntity, function.Name);
            }

            return GenerateFunctionLink(resourceSetContext, bindingParameter.Type, function,
                function.Parameters.Select(p => p.Name));
        }

        internal static Uri GenerateFunctionLink(this ResourceSetContext resourceSetContext, IEdmTypeReference bindingParameterType,
            IEdmOperation functionImport, IEnumerable<string> parameterNames)
        {
            Contract.Assert(resourceSetContext != null);

            if (resourceSetContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> functionPathSegments = new List<ODataPathSegment>();
            resourceSetContext.GenerateBaseODataPathSegmentsForFeed(functionPathSegments);

            // generate link with cast if the navigation source type doesn't match the entity type the function is bound to.
            if (resourceSetContext.EntitySetBase.Type.FullTypeName() != bindingParameterType.Definition.FullTypeName())
            {
                functionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, null));
            }

            IList<OperationSegmentParameter> parameters = new List<OperationSegmentParameter>();
            // skip the binding parameter
            foreach (string param in parameterNames.Skip(1))
            {
                string value = "@" + param;
                parameters.Add(new OperationSegmentParameter(param, new ConstantNode(value, value)));
            }

            OperationSegment segment = new OperationSegment(new[] { functionImport }, parameters, null);
            functionPathSegments.Add(segment);

            string functionLink = resourceSetContext.InternalUrlHelper.CreateODataLink(functionPathSegments);
            return functionLink == null ? null : new Uri(functionLink);
        }

        internal static Uri GenerateFunctionLink(this ResourceSetContext feedContext, string bindingParameterType,
            string functionName, IEnumerable<string> parameterNames)
        {
            Contract.Assert(feedContext != null);

            if (feedContext.EntitySetBase is IEdmContainedEntitySet)
            {
                return null;
            }

            if (feedContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = feedContext.EdmModel;

            string elementType = DeserializationHelpers.GetCollectionElementTypeName(bindingParameterType,
                isNested: false);
            Contract.Assert(elementType != null);

            IEdmTypeReference typeReference = model.FindDeclaredType(elementType).ToEdmTypeReference(true);
            IEdmTypeReference collection = new EdmCollectionTypeReference(new EdmCollectionType(typeReference));
            IEdmOperation operation = model.FindDeclaredOperations(functionName).First();
            return feedContext.GenerateFunctionLink(collection, operation, parameterNames);
        }

        /// <summary>
        /// Generates an action link following the OData URL conventions for the action <paramref name="action"/> and bound to the entity
        /// represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the action link needs to be generated.</param>
        /// <param name="action">The action for which the action link needs to be generated.</param>
        /// <returns>The generated action link following OData URL conventions.</returns>
        public static Uri GenerateActionLink(this ResourceContext resourceContext, IEdmOperation action)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            IEdmOperationParameter bindingParameter = action.Parameters.FirstOrDefault();
            if (bindingParameter == null || !bindingParameter.Type.IsEntity())
            {
                throw Error.Argument("action", SRResources.ActionNotBoundToEntity, action.Name);
            }

            return GenerateActionLink(resourceContext, bindingParameter.Type, action);
        }

        internal static Uri GenerateActionLink(this ResourceContext resourceContext,
            IEdmTypeReference bindingParameterType, IEdmOperation action)
        {
            Contract.Assert(resourceContext != null);
            if (resourceContext.NavigationSource is IEdmContainedEntitySet)
            {
                return null;
            }

            IList<ODataPathSegment> actionPathSegments = resourceContext.GenerateBaseODataPathSegments();

            // generate link with cast if the navigation source doesn't match the entity type the action is bound to.
            if (resourceContext.NavigationSource.EntityType() != bindingParameterType.Definition)
            {
                actionPathSegments.Add(new TypeSegment((IEdmEntityType)bindingParameterType.Definition, null));
                // entity set can be null
            }

            OperationSegment operationSegment = new OperationSegment(new[] { action }, null);
            actionPathSegments.Add(operationSegment);

            string actionLink = resourceContext.InternalUrlHelper.CreateODataLink(actionPathSegments);
            return actionLink == null ? null : new Uri(actionLink);
        }

        internal static Uri GenerateActionLink(this ResourceContext resourceContext, string bindingParameterType,
            string actionName)
        {
            Contract.Assert(resourceContext != null);
            if (resourceContext.NavigationSource is IEdmContainedEntitySet)
            {
                return null;
            }

            if (resourceContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = resourceContext.EdmModel;
            IEdmTypeReference typeReference = model.FindDeclaredType(bindingParameterType).ToEdmTypeReference(true);
            IEdmOperation operation = model.FindDeclaredOperations(actionName).First();
            return resourceContext.GenerateActionLink(typeReference, operation);
        }

        /// <summary>
        /// Generates an function link following the OData URL conventions for the function <paramref name="function"/> and bound to the entity
        /// represented by <paramref name="resourceContext"/>.
        /// </summary>
        /// <param name="resourceContext">The <see cref="ResourceContext"/> representing the entity for which the function link needs to be generated.</param>
        /// <param name="function">The function for which the function link needs to be generated.</param>
        /// <returns>The generated function link following OData URL conventions.</returns>
        public static Uri GenerateFunctionLink(this ResourceContext resourceContext, IEdmOperation function)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }
            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            IEdmOperationParameter bindingParameter = function.Parameters.FirstOrDefault();
            if (bindingParameter == null || !bindingParameter.Type.IsEntity())
            {
                throw Error.Argument("function", SRResources.FunctionNotBoundToEntity, function.Name);
            }

            return GenerateFunctionLink(resourceContext, bindingParameter.Type.FullName(), function.FullName(),
                function.Parameters.Select(p => p.Name));
        }

        internal static Uri GenerateFunctionLink(this ResourceContext resourceContext,
            IEdmTypeReference bindingParameterType, IEdmOperation function,
            IEnumerable<string> parameterNames)
        {
            IList<ODataPathSegment> functionPathSegments = resourceContext.GenerateBaseODataPathSegments();

            // generate link with cast if the navigation source type doesn't match the entity type the function is bound to.
            if (resourceContext.NavigationSource.EntityType() != bindingParameterType.Definition)
            {
                functionPathSegments.Add(new TypeSegment(bindingParameterType.Definition, null));
            }

            IList<OperationSegmentParameter> parameters = new List<OperationSegmentParameter>();
            // skip the binding parameter
            foreach (string param in parameterNames.Skip(1))
            {
                string value = "@" + param;
                parameters.Add(new OperationSegmentParameter(param, new ConstantNode(value, value)));
            }

            OperationSegment segment = new OperationSegment(new[] { function }, parameters, null);
            functionPathSegments.Add(segment);

            string functionLink = resourceContext.InternalUrlHelper.CreateODataLink(functionPathSegments);
            return functionLink == null ? null : new Uri(functionLink);
        }

        internal static Uri GenerateFunctionLink(this ResourceContext resourceContext, string bindingParameterType,
            string functionName, IEnumerable<string> parameterNames)
        {
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.EdmModel == null)
            {
                return null;
            }

            IEdmModel model = resourceContext.EdmModel;
            IEdmTypeReference typeReference = model.FindDeclaredType(bindingParameterType).ToEdmTypeReference(true);
            IEdmOperation operation = model.FindDeclaredOperations(functionName).First();
            return resourceContext.GenerateFunctionLink(typeReference, operation, parameterNames);
        }

        internal static IList<ODataPathSegment> GenerateBaseODataPathSegments(this ResourceContext resourceContext)
        {
            IList<ODataPathSegment> odataPath = new List<ODataPathSegment>();

            if (resourceContext.NavigationSource.NavigationSourceKind() == EdmNavigationSourceKind.Singleton)
            {
                // Per the OData V4 specification, a singleton is expected to be a child of the entity container, and
                // as a result we can make the assumption that it is the only segment in the generated path.
                odataPath.Add(new SingletonSegment((IEdmSingleton)resourceContext.NavigationSource));
            }
            else
            {
                resourceContext.GenerateBaseODataPathSegmentsForEntity(odataPath);
            }

            return odataPath;
        }

        private static void GenerateBaseODataPathSegmentsForNonSingletons(
            ODataPath path,
            IEdmNavigationSource navigationSource,
            IList<ODataPathSegment> odataPath)
        {
            // If the navigation is not a singleton we need to walk all of the path segments to generate a
            // contextually accurate URI.
            bool segmentFound = false;
            bool containedFound = false;
            if (path != null)
            {
                var segments = path.Segments;
                int length = segments.Count;
                int previousNavigationPathIndex = -1;
                for (int i = 0; i < length; i++)
                {
                    ODataPathSegment pathSegment = segments[i];
                    IEdmNavigationSource currentNavigationSource = null;

                    if (pathSegment is EntitySetSegment entitySetPathSegment)
                    {
                        currentNavigationSource = entitySetPathSegment.EntitySet;
                    }

                    if (pathSegment is NavigationPropertySegment navigationPathSegment)
                    {
                        currentNavigationSource = navigationPathSegment.NavigationSource;
                    }
                    if (containedFound)
                    {
                        odataPath.Add(pathSegment);
                    }
                    else
                    {
                        if (pathSegment is NavigationPropertySegment navigationPathSegment &&
                            navigationPathSegment.NavigationProperty.ContainsTarget)
                        {
                            containedFound = true;
                            //The path should have the last non-contained navigation property
                            if (previousNavigationPathIndex != -1)
                            {
                                for (int j = previousNavigationPathIndex; j <= i; j++)
                                {
                                    odataPath.Add(segments[j]);
                                }
                            }
                        }
                    }

                    // If we've found our target navigation in the path that means we've correctly populated the
                    // segments up to the navigation and we can ignore the remaining segments.
                    if (currentNavigationSource != null)
                    {
                        previousNavigationPathIndex = i;
                        if (currentNavigationSource == navigationSource)
                        {
                            segmentFound = true;
                            break;
                        }
                    }
                }
            }

            if (!segmentFound || !containedFound)
            {
                // If the target navigation was not found in the current path that means we lack any context that
                // would suggest a scenario other than directly accessing an entity set, so we must assume that's
                // the case.
                odataPath.Clear();

                if (navigationSource is IEdmContainedEntitySet containmnent)
                {
                    EdmEntityContainer container = new EdmEntityContainer("NS", "Default");
                    IEdmEntitySet entitySet = new EdmEntitySet(container, navigationSource.Name,
                        navigationSource.EntityType());
                    odataPath.Add(new EntitySetSegment(entitySet));
                }
                else
                {
                    odataPath.Add(new EntitySetSegment((IEdmEntitySet)navigationSource));
                }
            }
        }

        private static void GenerateBaseODataPathSegmentsForEntity(
            this ResourceContext resourceContext,
            IList<ODataPathSegment> odataPath)
        {
            // If the navigation is not a singleton we need to walk all of the path segments to generate a
            // contextually accurate URI.
            GenerateBaseODataPathSegmentsForNonSingletons(
                resourceContext.SerializerContext.Path, resourceContext.NavigationSource, odataPath);

            odataPath.Add(new KeySegment(ConventionsHelpers.GetEntityKey(resourceContext), resourceContext.StructuredType as IEdmEntityType,
                null));
        }

        private static void GenerateBaseODataPathSegmentsForFeed(
            this ResourceSetContext feedContext,
            IList<ODataPathSegment> odataPath)
        {
            GenerateBaseODataPathSegmentsForNonSingletons(feedContext.InternalRequest.Context.Path,
                feedContext.EntitySetBase,
                odataPath);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\LinkGenerationHelpers.cs(468,70): error CS0136: A local or parameter named 'navigationPathSegment' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\DeserializationHelpers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    internal static class DeserializationHelpers
    {
        internal static void ApplyProperty(ODataProperty property, IEdmStructuredTypeReference resourceType, object resource,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            IEdmProperty edmProperty;

            // Extract edmProperty using a Case-Sensitive match
            edmProperty = resourceType.FindProperty(property.Name);

            if (readContext != null && !readContext.DisableCaseInsensitiveRequestPropertyBinding && edmProperty == null)
            {
                // if edmProperty is null, we try a Case-Insensitive match.
                bool propertyMatched = false;

                IEnumerable<IEdmStructuralProperty> structuralProperties = resourceType.StructuralProperties();
                foreach(IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if(structuralProperty.Name.Equals(property.Name, StringComparison.OrdinalIgnoreCase))
                    {
                        // We throw an exception when we have more than 1 case-insensitive matches and no case sensitive matches.
                        if (propertyMatched)
                        {
                            throw new ODataException(Error.Format(SRResources.CannotDeserializeUnknownProperty, property.Name, resourceType.Definition));
                        }
                        propertyMatched = true;
                        edmProperty = resourceType.FindProperty(structuralProperty.Name);
                    }
                }
            }

            bool isDynamicProperty = false;
            string propertyName = property.Name;
            if (edmProperty != null)
            {
                propertyName = EdmLibHelpers.GetClrPropertyName(edmProperty, readContext.Model);
            }
            else
            {
                IEdmStructuredType structuredType = resourceType.StructuredDefinition();
                isDynamicProperty = structuredType != null && structuredType.IsOpen;
            }

            if (!isDynamicProperty && edmProperty == null)
            {
                throw new ODataException(
                    Error.Format(SRResources.CannotDeserializeUnknownProperty, property.Name, resourceType.Definition));
            }

            // dynamic properties have null values
            IEdmTypeReference propertyType = edmProperty != null ? edmProperty.Type : null;

            EdmTypeKind propertyKind;
            object value = ConvertValue(property.Value, ref propertyType, deserializerProvider, readContext,
                out propertyKind);

            if (isDynamicProperty)
            {
                SetDynamicProperty(resource, resourceType, propertyKind, propertyName, value, propertyType,
                    readContext.Model);
            }
            else
            {
                SetDeclaredProperty(resource, propertyKind, propertyName, value, edmProperty, readContext);
            }
        }

        internal static void ApplyInstanceAnnotations(object resource, IEdmStructuredTypeReference structuredType, ODataResource oDataResource,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            PropertyInfo propertyInfo = EdmLibHelpers.GetInstanceAnnotationsContainer(structuredType.StructuredDefinition(), readContext.Model);
            if (propertyInfo == null)
            {
                return;
            }

            IODataInstanceAnnotationContainer instanceAnnotationContainer = GetAnnotationContainer(propertyInfo, resource);

            SetInstanceAnnotations(oDataResource, instanceAnnotationContainer, deserializerProvider, readContext);
        }

        internal static void SetDynamicProperty(object resource, IEdmStructuredTypeReference resourceType,
            EdmTypeKind propertyKind, string propertyName, object propertyValue, IEdmTypeReference propertyType,
            IEdmModel model)
        {
            if (propertyKind == EdmTypeKind.Collection && propertyValue.GetType() != typeof(EdmComplexObjectCollection)
                && propertyValue.GetType() != typeof(EdmEnumObjectCollection))
            {
                SetDynamicCollectionProperty(resource, propertyName, propertyValue, propertyType.AsCollection(),
                    resourceType.StructuredDefinition(), model);
            }
            else
            {
                SetDynamicProperty(resource, propertyName, propertyValue, resourceType.StructuredDefinition(),
                    model);
            }
        }

        internal static void SetDeclaredProperty(object resource, EdmTypeKind propertyKind, string propertyName,
            object propertyValue, IEdmProperty edmProperty, ODataDeserializerContext readContext)
        {
            if (propertyKind == EdmTypeKind.Collection)
            {
                SetCollectionProperty(resource, edmProperty, propertyValue, propertyName);
            }
            else
            {
                if (!readContext.IsUntyped)
                {
                    if (propertyKind == EdmTypeKind.Primitive)
                    {
                        propertyValue = EdmPrimitiveHelpers.ConvertPrimitiveValue(propertyValue,
                            GetPropertyType(resource, propertyName));
                    }
                }

                SetProperty(resource, propertyName, propertyValue);
            }
        }

        internal static void SetCollectionProperty(object resource, IEdmProperty edmProperty, object value, string propertyName)
        {
            Contract.Assert(edmProperty != null);

            SetCollectionProperty(resource, propertyName, edmProperty.Type.AsCollection(), value, clearCollection: false);
        }

        internal static void SetCollectionProperty(object resource, string propertyName,
            IEdmCollectionTypeReference edmPropertyType, object value, bool clearCollection)
        {
            if (value != null)
            {
                IEnumerable collection = value as IEnumerable;
                Contract.Assert(collection != null,
                    "SetCollectionProperty is always passed the result of ODataFeedDeserializer or ODataCollectionDeserializer");

                Type resourceType = resource.GetType();
                Type propertyType = GetPropertyType(resource, propertyName);

                Type elementType;
                if (!TypeHelper.IsCollection(propertyType, out elementType))
                {
                    string message = Error.Format(SRResources.PropertyIsNotCollection, propertyType.FullName, propertyName, resourceType.FullName);
                    throw new SerializationException(message);
                }

                IEnumerable newCollection;
                if (CanSetProperty(resource, propertyName) &&
                    CollectionDeserializationHelpers.TryCreateInstance(propertyType, edmPropertyType, elementType, out newCollection))
                {
                    // settable collections
                    collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                    if (propertyType.IsArray)
                    {
                        newCollection = CollectionDeserializationHelpers.ToArray(newCollection, elementType);
                    }

                    SetProperty(resource, propertyName, newCollection);
                }
                else
                {
                    // get-only collections.
                    newCollection = GetProperty(resource, propertyName) as IEnumerable;
                    if (newCollection == null)
                    {
                        string message = Error.Format(SRResources.CannotAddToNullCollection, propertyName, resourceType.FullName);
                        throw new SerializationException(message);
                    }

                    if (clearCollection)
                    {
                        newCollection.Clear(propertyName, resourceType);
                    }

                    collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                }
            }
        }

        internal static void SetDynamicCollectionProperty(object resource, string propertyName, object value,
            IEdmCollectionTypeReference edmPropertyType, IEdmStructuredType structuredType,
            IEdmModel model)
        {
            Contract.Assert(value != null);
            Contract.Assert(model != null);

            IEnumerable collection = value as IEnumerable;
            Contract.Assert(collection != null);

            Type resourceType = resource.GetType();
            Type elementType = EdmLibHelpers.GetClrType(edmPropertyType.ElementType(), model);
            Type propertyType = typeof(ICollection<>).MakeGenericType(elementType);
            IEnumerable newCollection;
            if (CollectionDeserializationHelpers.TryCreateInstance(propertyType, edmPropertyType, elementType,
                out newCollection))
            {
                collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                SetDynamicProperty(resource, propertyName, newCollection, structuredType, model);
            }
        }

        internal static void SetProperty(object resource, string propertyName, object value)
        {
            IDelta delta = resource as IDelta;
            if (delta == null)
            {
                resource.GetType().GetProperty(propertyName).SetValue(resource, value, index: null);
            }
            else
            {
                delta.TrySetPropertyValue(propertyName, value);
            }
        }

        internal static void SetDynamicProperty(object resource, string propertyName, object value,
            IEdmStructuredType structuredType, IEdmModel model)
        {
            IDelta delta = resource as IDelta;
            if (delta != null)
            {
                delta.TrySetPropertyValue(propertyName, value);
            }
            else
            {
                PropertyInfo propertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType,
                    model);
                if (propertyInfo == null)
                {
                    return;
                }
                
                IDictionary<string, object> dynamicPropertyDictionary;
                object dynamicDictionaryObject = propertyInfo.GetValue(resource);
                if (dynamicDictionaryObject == null)
                {
                    if (!propertyInfo.CanWrite)
                    {
                        throw Error.InvalidOperation(SRResources.CannotSetDynamicPropertyDictionary, propertyName,
                            resource.GetType().FullName);
                    }

                    dynamicPropertyDictionary = new Dictionary<string, object>();
                    propertyInfo.SetValue(resource, dynamicPropertyDictionary);
                }
                else
                {
                    dynamicPropertyDictionary = (IDictionary<string, object>)dynamicDictionaryObject;
                }

                if (dynamicPropertyDictionary.ContainsKey(propertyName))
                {
                    throw Error.InvalidOperation(SRResources.DuplicateDynamicPropertyNameFound,
                        propertyName, structuredType.FullTypeName());
                }

                dynamicPropertyDictionary.Add(propertyName, value);
            }
        }

        internal static void SetInstanceAnnotations(ODataResource oDataResource, IODataInstanceAnnotationContainer instanceAnnotationContainer, 
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            if(oDataResource.InstanceAnnotations != null)
            {
                foreach (ODataInstanceAnnotation annotation in oDataResource.InstanceAnnotations)
                {
                    AddInstanceAnnotationToContainer(instanceAnnotationContainer, deserializerProvider, readContext, annotation,string.Empty);
                }
            }

            foreach(ODataProperty property in oDataResource.Properties)
            {
                if(property.InstanceAnnotations != null)
                {
                    foreach (ODataInstanceAnnotation annotation in property.InstanceAnnotations)
                    {
                        AddInstanceAnnotationToContainer(instanceAnnotationContainer, deserializerProvider, readContext, annotation, property.Name);
                    }
                }
            }
        }

        private static void AddInstanceAnnotationToContainer(IODataInstanceAnnotationContainer instanceAnnotationContainer, ODataDeserializerProvider deserializerProvider, 
            ODataDeserializerContext readContext, ODataInstanceAnnotation annotation, string propertyName)
        {
            IEdmTypeReference propertyType = null;

            object annotationValue = ConvertAnnotationValue(annotation.Value, ref propertyType, deserializerProvider, readContext);

            if (string.IsNullOrEmpty(propertyName))
            {
                instanceAnnotationContainer.AddResourceAnnotation(annotation.Name, annotationValue);
            }
            else
            {
                instanceAnnotationContainer.AddPropertyAnnotation(propertyName,annotation.Name, annotationValue);
            }
        }

        public static IODataInstanceAnnotationContainer GetAnnotationContainer(PropertyInfo propertyInfo, object resource)
        {
            IDelta delta = resource as IDelta;
            object value;
            if (delta != null)
            {
                delta.TryGetPropertyValue(propertyInfo.Name, out value);
            }
            else
            {
                value = propertyInfo.GetValue(resource);
            }

            IODataInstanceAnnotationContainer instanceAnnotationContainer = value as IODataInstanceAnnotationContainer;

            if (instanceAnnotationContainer == null)
            {
                try
                {
                    if (propertyInfo.PropertyType == typeof(ODataInstanceAnnotationContainer) || propertyInfo.PropertyType == typeof(IODataInstanceAnnotationContainer))
                    {
                        instanceAnnotationContainer = new ODataInstanceAnnotationContainer();
                    }
                    else
                    {
                        instanceAnnotationContainer = Activator.CreateInstance(propertyInfo.PropertyType) as IODataInstanceAnnotationContainer;
                    }

                    if(delta != null)
                    {
                        delta.TrySetPropertyValue(propertyInfo.Name, instanceAnnotationContainer);
                    }
                    else
                    {
                        propertyInfo.SetValue(resource, instanceAnnotationContainer);
                    }
                }
                catch(Exception ex)
                {
                    throw new ODataException(Error.Format(SRResources.CannotCreateInstanceForProperty, propertyInfo.Name), ex);
                }
            }

            return instanceAnnotationContainer;
        }

        internal static object ConvertValue(object oDataValue, ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
            ODataDeserializerContext readContext, out EdmTypeKind typeKind)
        {
            if (oDataValue == null)
            {
                typeKind = EdmTypeKind.None;
                return null;
            }

            ODataEnumValue enumValue = oDataValue as ODataEnumValue;
            if (enumValue != null)
            {
                typeKind = EdmTypeKind.Enum;
                return ConvertEnumValue(enumValue, ref propertyType, deserializerProvider, readContext);
            }

            ODataCollectionValue collection = oDataValue as ODataCollectionValue;
            if (collection != null)
            {
                typeKind = EdmTypeKind.Collection;
                return ConvertCollectionValue(collection, ref propertyType, deserializerProvider, readContext);
            }

            ODataUntypedValue untypedValue = oDataValue as ODataUntypedValue;
            if (untypedValue != null)
            {
                Contract.Assert(!String.IsNullOrEmpty(untypedValue.RawValue));

                if (untypedValue.RawValue.StartsWith("[", StringComparison.Ordinal) ||
                    untypedValue.RawValue.StartsWith("{", StringComparison.Ordinal))
                {
                    throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, untypedValue.RawValue));
                }

                oDataValue = ConvertPrimitiveValue(untypedValue.RawValue);
            }

            typeKind = EdmTypeKind.Primitive;
            return oDataValue;
        }

        internal static object ConvertAnnotationValue(object oDataValue, ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
    ODataDeserializerContext readContext)
        {
            if (oDataValue == null)
            {
                return null;
            }

            ODataEnumValue enumValue = oDataValue as ODataEnumValue;
            if (enumValue != null)
            {
                return ConvertEnumValue(enumValue, ref propertyType, deserializerProvider, readContext);
            }

            ODataCollectionValue collection = oDataValue as ODataCollectionValue;
            if (collection != null)
            {
                return ConvertCollectionValue(collection, ref propertyType, deserializerProvider, readContext);
            }

            ODataUntypedValue untypedValue = oDataValue as ODataUntypedValue;
            if (untypedValue != null)
            {
                Contract.Assert(!String.IsNullOrEmpty(untypedValue.RawValue));

                if (untypedValue.RawValue.StartsWith("[", StringComparison.Ordinal) ||
                    untypedValue.RawValue.StartsWith("{", StringComparison.Ordinal))
                {
                    throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, untypedValue.RawValue));
                }

                oDataValue = ConvertPrimitiveValue(untypedValue.RawValue);
            }

            ODataResourceValue annotationVal = oDataValue as ODataResourceValue;
            if (annotationVal != null)
            {
                var annotationType = readContext.Model.FindDeclaredType(annotationVal.TypeName).ToEdmTypeReference(true) as IEdmStructuredTypeReference;

                ODataResourceDeserializer deserializer = new ODataResourceDeserializer(deserializerProvider);

                object resource = deserializer.CreateResourceInstance(annotationType, readContext);

                if (resource != null)
                {
                    foreach (var prop in annotationVal.Properties)
                    {
                        deserializer.ApplyStructuralProperty(resource, prop, annotationType, readContext);
                    }
                }
               
                return resource;
            }

            ODataPrimitiveValue primitiveValue = oDataValue as ODataPrimitiveValue;
            if (primitiveValue != null)
            {
                return EdmPrimitiveHelpers.ConvertPrimitiveValue(primitiveValue.Value, primitiveValue.Value.GetType());
            }

            return oDataValue;
        }

        internal static Type GetPropertyType(object resource, string propertyName)
        {
            Contract.Assert(resource != null);
            Contract.Assert(propertyName != null);

            IDelta delta = resource as IDelta;
            if (delta != null)
            {
                Type type;
                delta.TryGetPropertyType(propertyName, out type);
                return type;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                return property == null ? null : property.PropertyType;
            }
        }

        private static bool CanSetProperty(object resource, string propertyName)
        {
            IDelta delta = resource as IDelta;
            if (delta != null)
            {
                return true;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                return property != null && property.GetSetMethod() != null;
            }
        }

        private static object GetProperty(object resource, string propertyName)
        {
            IDelta delta = resource as IDelta;
            if (delta != null)
            {
                object value;
                delta.TryGetPropertyValue(propertyName, out value);
                return value;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                Contract.Assert(property != null, "ODataLib should have already verified that the property exists on the type.");
                return property.GetValue(resource, index: null);
            }
        }

        private static object ConvertCollectionValue(ODataCollectionValue collection,
            ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
            ODataDeserializerContext readContext)
        {
            IEdmCollectionTypeReference collectionType;
            if (propertyType == null)
            {
                // dynamic collection property
                Contract.Assert(!String.IsNullOrEmpty(collection.TypeName),
                    "ODataLib should have verified that dynamic collection value has a type name " +
                    "since we provided metadata.");

                string elementTypeName = GetCollectionElementTypeName(collection.TypeName, isNested: false);
                IEdmModel model = readContext.Model;
                IEdmSchemaType elementType = model.FindType(elementTypeName);
                Contract.Assert(elementType != null);
                collectionType =
                    new EdmCollectionTypeReference(
                        new EdmCollectionType(elementType.ToEdmTypeReference(isNullable: false)));
                propertyType = collectionType;
            }
            else
            {
                collectionType = propertyType as IEdmCollectionTypeReference;
                Contract.Assert(collectionType != null, "The type for collection must be a IEdmCollectionType.");
            }

            ODataEdmTypeDeserializer deserializer = deserializerProvider.GetEdmTypeDeserializer(collectionType);
            return deserializer.ReadInline(collection, collectionType, readContext);
        }

        private static object ConvertPrimitiveValue(string value)
        {
            double doubleValue;
            int intValue;
            decimal decimalValue;

            if (String.CompareOrdinal(value, "null") == 0)
            {
                return null;
            }

            if (Int32.TryParse(value, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out intValue))
            {
                return intValue;
            }

            // todo: if it is Ieee754Compatible, parse decimal after double
            if (Decimal.TryParse(value, NumberStyles.Number, NumberFormatInfo.InvariantInfo, out decimalValue))
            {
                return decimalValue;
            }

            if (Double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out doubleValue))
            {
                return doubleValue;
            }

            if (!value.StartsWith("\"", StringComparison.Ordinal) || !value.EndsWith("\"", StringComparison.Ordinal))
            {
                throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, value));
            }

            return value.Substring(1, value.Length - 2);
        }

        private static object ConvertEnumValue(ODataEnumValue enumValue, ref IEdmTypeReference propertyType,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            IEdmEnumTypeReference edmEnumType;
            if (propertyType == null)
            {
                // dynamic enum property
                Contract.Assert(!String.IsNullOrEmpty(enumValue.TypeName),
                    "ODataLib should have verified that dynamic enum value has a type name since we provided metadata.");
                IEdmModel model = readContext.Model;
                IEdmType edmType = model.FindType(enumValue.TypeName);
                Contract.Assert(edmType.TypeKind == EdmTypeKind.Enum, "ODataLib should have verified that enum value has a enum resource type.");
                edmEnumType = new EdmEnumTypeReference(edmType as IEdmEnumType, isNullable: true);
                propertyType = edmEnumType;
            }
            else
            {
                edmEnumType = propertyType.AsEnum();
            }

            ODataEdmTypeDeserializer deserializer = deserializerProvider.GetEdmTypeDeserializer(edmEnumType);
            return deserializer.ReadInline(enumValue, propertyType, readContext);
        }

        // The same logic from ODL to get the element type name in a collection.
        internal static string GetCollectionElementTypeName(string typeName, bool isNested)
        {
            const string CollectionTypeQualifier = "Collection";
            int collectionTypeQualifierLength = CollectionTypeQualifier.Length;

            // A collection type name must not be null, it has to start with "Collection(" and end with ")"
            // and must not be "Collection()"
            if (typeName != null &&
                typeName.StartsWith(CollectionTypeQualifier + "(", StringComparison.Ordinal) &&
                typeName[typeName.Length - 1] == ')' &&
                typeName.Length != collectionTypeQualifierLength + 2)
            {
                if (isNested)
                {
                    throw new ODataException(Error.Format(SRResources.NestedCollectionsNotSupported, typeName));
                }

                string innerTypeName = typeName.Substring(collectionTypeQualifierLength + 1,
                    typeName.Length - (collectionTypeQualifierLength + 2));

                // Check if it is not a nested collection and throw if it is
                GetCollectionElementTypeName(innerTypeName, true);

                return innerTypeName;
            }

            return null;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    internal static class DeserializationHelpers
    {
        internal static void ApplyProperty(ODataProperty property, IEdmStructuredTypeReference resourceType, object resource,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            IEdmProperty edmProperty;

            // Extract edmProperty using a Case-Sensitive match
            edmProperty = resourceType.FindProperty(property.Name);

            if (readContext != null && !readContext.DisableCaseInsensitiveRequestPropertyBinding && edmProperty == null)
            {
                // if edmProperty is null, we try a Case-Insensitive match.
                bool propertyMatched = false;

                IEnumerable<IEdmStructuralProperty> structuralProperties = resourceType.StructuralProperties();
                foreach(IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if(structuralProperty.Name.Equals(property.Name, StringComparison.OrdinalIgnoreCase))
                    {
                        // We throw an exception when we have more than 1 case-insensitive matches and no case sensitive matches.
                        if (propertyMatched)
                        {
                            throw new ODataException(Error.Format(SRResources.CannotDeserializeUnknownProperty, property.Name, resourceType.Definition));
                        }
                        propertyMatched = true;
                        edmProperty = resourceType.FindProperty(structuralProperty.Name);
                    }
                }
            }

            bool isDynamicProperty = false;
            string propertyName = property.Name;
            if (edmProperty != null)
            {
                propertyName = EdmLibHelpers.GetClrPropertyName(edmProperty, readContext.Model);
            }
            else
            {
                IEdmStructuredType structuredType = resourceType.StructuredDefinition();
                isDynamicProperty = structuredType != null && structuredType.IsOpen;
            }

            if (!isDynamicProperty && edmProperty == null)
            {
                throw new ODataException(
                    Error.Format(SRResources.CannotDeserializeUnknownProperty, property.Name, resourceType.Definition));
            }

            // dynamic properties have null values
            IEdmTypeReference propertyType = edmProperty != null ? edmProperty.Type : null;

            EdmTypeKind propertyKind;
            object value = ConvertValue(property.Value, ref propertyType, deserializerProvider, readContext,
                out propertyKind);

            if (isDynamicProperty)
            {
                SetDynamicProperty(resource, resourceType, propertyKind, propertyName, value, propertyType,
                    readContext.Model);
            }
            else
            {
                SetDeclaredProperty(resource, propertyKind, propertyName, value, edmProperty, readContext);
            }
        }

        internal static void ApplyInstanceAnnotations(object resource, IEdmStructuredTypeReference structuredType, ODataResource oDataResource,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            PropertyInfo propertyInfo = EdmLibHelpers.GetInstanceAnnotationsContainer(structuredType.StructuredDefinition(), readContext.Model);
            if (propertyInfo == null)
            {
                return;
            }

            IODataInstanceAnnotationContainer instanceAnnotationContainer = GetAnnotationContainer(propertyInfo, resource);

            SetInstanceAnnotations(oDataResource, instanceAnnotationContainer, deserializerProvider, readContext);
        }

        internal static void SetDynamicProperty(object resource, IEdmStructuredTypeReference resourceType,
            EdmTypeKind propertyKind, string propertyName, object propertyValue, IEdmTypeReference propertyType,
            IEdmModel model)
        {
            if (propertyKind == EdmTypeKind.Collection && propertyValue.GetType() != typeof(EdmComplexObjectCollection)
                && propertyValue.GetType() != typeof(EdmEnumObjectCollection))
            {
                SetDynamicCollectionProperty(resource, propertyName, propertyValue, propertyType.AsCollection(),
                    resourceType.StructuredDefinition(), model);
            }
            else
            {
                SetDynamicProperty(resource, propertyName, propertyValue, resourceType.StructuredDefinition(),
                    model);
            }
        }

        internal static void SetDeclaredProperty(object resource, EdmTypeKind propertyKind, string propertyName,
            object propertyValue, IEdmProperty edmProperty, ODataDeserializerContext readContext)
        {
            if (propertyKind == EdmTypeKind.Collection)
            {
                SetCollectionProperty(resource, edmProperty, propertyValue, propertyName);
            }
            else
            {
                if (!readContext.IsUntyped)
                {
                    if (propertyKind == EdmTypeKind.Primitive)
                    {
                        propertyValue = EdmPrimitiveHelpers.ConvertPrimitiveValue(propertyValue,
                            GetPropertyType(resource, propertyName));
                    }
                }

                SetProperty(resource, propertyName, propertyValue);
            }
        }

        internal static void SetCollectionProperty(object resource, IEdmProperty edmProperty, object value, string propertyName)
        {
            Contract.Assert(edmProperty != null);

            SetCollectionProperty(resource, propertyName, edmProperty.Type.AsCollection(), value, clearCollection: false);
        }

        internal static void SetCollectionProperty(object resource, string propertyName,
            IEdmCollectionTypeReference edmPropertyType, object value, bool clearCollection)
        {
            if (value != null)
            {
                Contract.Assert(value is IEnumerable collection,
                    "SetCollectionProperty is always passed the result of ODataFeedDeserializer or ODataCollectionDeserializer");

                Type resourceType = resource.GetType();
                Type propertyType = GetPropertyType(resource, propertyName);

                Type elementType;
                if (!TypeHelper.IsCollection(propertyType, out elementType))
                {
                    string message = Error.Format(SRResources.PropertyIsNotCollection, propertyType.FullName, propertyName, resourceType.FullName);
                    throw new SerializationException(message);
                }

                IEnumerable newCollection;
                if (CanSetProperty(resource, propertyName) &&
                    CollectionDeserializationHelpers.TryCreateInstance(propertyType, edmPropertyType, elementType, out newCollection))
                {
                    // settable collections
                    collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                    if (propertyType.IsArray)
                    {
                        newCollection = CollectionDeserializationHelpers.ToArray(newCollection, elementType);
                    }

                    SetProperty(resource, propertyName, newCollection);
                }
                else
                {
                    // get-only collections.
                    newCollection = GetProperty(resource, propertyName) as IEnumerable;
                    if (newCollection == null)
                    {
                        string message = Error.Format(SRResources.CannotAddToNullCollection, propertyName, resourceType.FullName);
                        throw new SerializationException(message);
                    }

                    if (clearCollection)
                    {
                        newCollection.Clear(propertyName, resourceType);
                    }

                    collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                }
            }
        }

        internal static void SetDynamicCollectionProperty(object resource, string propertyName, object value,
            IEdmCollectionTypeReference edmPropertyType, IEdmStructuredType structuredType,
            IEdmModel model)
        {
            Contract.Assert(value != null);
            Contract.Assert(model != null);

            IEnumerable collection = value as IEnumerable;
            Contract.Assert(collection != null);

            Type resourceType = resource.GetType();
            Type elementType = EdmLibHelpers.GetClrType(edmPropertyType.ElementType(), model);
            Type propertyType = typeof(ICollection<>).MakeGenericType(elementType);
            IEnumerable newCollection;
            if (CollectionDeserializationHelpers.TryCreateInstance(propertyType, edmPropertyType, elementType,
                out newCollection))
            {
                collection.AddToCollection(newCollection, elementType, resourceType, propertyName, propertyType);
                SetDynamicProperty(resource, propertyName, newCollection, structuredType, model);
            }
        }

        internal static void SetProperty(object resource, string propertyName, object value)
        {
            IDelta delta = resource as IDelta;
            if (delta == null)
            {
                resource.GetType().GetProperty(propertyName).SetValue(resource, value, index: null);
            }
            else
            {
                delta.TrySetPropertyValue(propertyName, value);
            }
        }

        internal static void SetDynamicProperty(object resource, string propertyName, object value,
            IEdmStructuredType structuredType, IEdmModel model)
        {
            if (resource is IDelta delta)
            {
                delta.TrySetPropertyValue(propertyName, value);
            }
            else
            {
                PropertyInfo propertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType,
                    model);
                if (propertyInfo == null)
                {
                    return;
                }
                
                IDictionary<string, object> dynamicPropertyDictionary;
                object dynamicDictionaryObject = propertyInfo.GetValue(resource);
                if (dynamicDictionaryObject == null)
                {
                    if (!propertyInfo.CanWrite)
                    {
                        throw Error.InvalidOperation(SRResources.CannotSetDynamicPropertyDictionary, propertyName,
                            resource.GetType().FullName);
                    }

                    dynamicPropertyDictionary = new Dictionary<string, object>();
                    propertyInfo.SetValue(resource, dynamicPropertyDictionary);
                }
                else
                {
                    dynamicPropertyDictionary = (IDictionary<string, object>)dynamicDictionaryObject;
                }

                if (dynamicPropertyDictionary.ContainsKey(propertyName))
                {
                    throw Error.InvalidOperation(SRResources.DuplicateDynamicPropertyNameFound,
                        propertyName, structuredType.FullTypeName());
                }

                dynamicPropertyDictionary.Add(propertyName, value);
            }
        }

        internal static void SetInstanceAnnotations(ODataResource oDataResource, IODataInstanceAnnotationContainer instanceAnnotationContainer, 
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            if(oDataResource.InstanceAnnotations != null)
            {
                foreach (ODataInstanceAnnotation annotation in oDataResource.InstanceAnnotations)
                {
                    AddInstanceAnnotationToContainer(instanceAnnotationContainer, deserializerProvider, readContext, annotation,string.Empty);
                }
            }

            foreach(ODataProperty property in oDataResource.Properties)
            {
                if(property.InstanceAnnotations != null)
                {
                    foreach (ODataInstanceAnnotation annotation in property.InstanceAnnotations)
                    {
                        AddInstanceAnnotationToContainer(instanceAnnotationContainer, deserializerProvider, readContext, annotation, property.Name);
                    }
                }
            }
        }

        private static void AddInstanceAnnotationToContainer(IODataInstanceAnnotationContainer instanceAnnotationContainer, ODataDeserializerProvider deserializerProvider, 
            ODataDeserializerContext readContext, ODataInstanceAnnotation annotation, string propertyName)
        {
            IEdmTypeReference propertyType = null;

            object annotationValue = ConvertAnnotationValue(annotation.Value, ref propertyType, deserializerProvider, readContext);

            if (string.IsNullOrEmpty(propertyName))
            {
                instanceAnnotationContainer.AddResourceAnnotation(annotation.Name, annotationValue);
            }
            else
            {
                instanceAnnotationContainer.AddPropertyAnnotation(propertyName,annotation.Name, annotationValue);
            }
        }

        public static IODataInstanceAnnotationContainer GetAnnotationContainer(PropertyInfo propertyInfo, object resource)
        {
            object value;

            if (resource is IDelta delta)
            {
                delta.TryGetPropertyValue(propertyInfo.Name, out value);
            }
            else
            {
                value = propertyInfo.GetValue(resource);
            }

            IODataInstanceAnnotationContainer instanceAnnotationContainer = value as IODataInstanceAnnotationContainer;

            if (instanceAnnotationContainer == null)
            {
                try
                {
                    if (propertyInfo.PropertyType == typeof(ODataInstanceAnnotationContainer) || propertyInfo.PropertyType == typeof(IODataInstanceAnnotationContainer))
                    {
                        instanceAnnotationContainer = new ODataInstanceAnnotationContainer();
                    }
                    else
                    {
                        instanceAnnotationContainer = Activator.CreateInstance(propertyInfo.PropertyType) as IODataInstanceAnnotationContainer;
                    }

                    if(resource is IDelta delta)
                    {
                        delta.TrySetPropertyValue(propertyInfo.Name, instanceAnnotationContainer);
                    }
                    else
                    {
                        propertyInfo.SetValue(resource, instanceAnnotationContainer);
                    }
                }
                catch(Exception ex)
                {
                    throw new ODataException(Error.Format(SRResources.CannotCreateInstanceForProperty, propertyInfo.Name), ex);
                }
            }

            return instanceAnnotationContainer;
        }

        internal static object ConvertValue(object oDataValue, ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
            ODataDeserializerContext readContext, out EdmTypeKind typeKind)
        {
            if (oDataValue == null)
            {
                typeKind = EdmTypeKind.None;
                return null;
            }

            if (oDataValue is ODataEnumValue enumValue)
            {
                typeKind = EdmTypeKind.Enum;
                return ConvertEnumValue(enumValue, ref propertyType, deserializerProvider, readContext);
            }

            if (oDataValue is ODataCollectionValue collection)
            {
                typeKind = EdmTypeKind.Collection;
                return ConvertCollectionValue(collection, ref propertyType, deserializerProvider, readContext);
            }

            if (oDataValue is ODataUntypedValue untypedValue)
            {
                Contract.Assert(!String.IsNullOrEmpty(untypedValue.RawValue));

                if (untypedValue.RawValue.StartsWith("[", StringComparison.Ordinal) ||
                    untypedValue.RawValue.StartsWith("{", StringComparison.Ordinal))
                {
                    throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, untypedValue.RawValue));
                }

                oDataValue = ConvertPrimitiveValue(untypedValue.RawValue);
            }

            typeKind = EdmTypeKind.Primitive;
            return oDataValue;
        }

        internal static object ConvertAnnotationValue(object oDataValue, ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
    ODataDeserializerContext readContext)
        {
            if (oDataValue == null)
            {
                return null;
            }

            if (oDataValue is ODataEnumValue enumValue)
            {
                return ConvertEnumValue(enumValue, ref propertyType, deserializerProvider, readContext);
            }

            if (oDataValue is ODataCollectionValue collection)
            {
                return ConvertCollectionValue(collection, ref propertyType, deserializerProvider, readContext);
            }

            if (oDataValue is ODataUntypedValue untypedValue)
            {
                Contract.Assert(!String.IsNullOrEmpty(untypedValue.RawValue));

                if (untypedValue.RawValue.StartsWith("[", StringComparison.Ordinal) ||
                    untypedValue.RawValue.StartsWith("{", StringComparison.Ordinal))
                {
                    throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, untypedValue.RawValue));
                }

                oDataValue = ConvertPrimitiveValue(untypedValue.RawValue);
            }

            if (oDataValue is ODataResourceValue annotationVal)
            {
                var annotationType = readContext.Model.FindDeclaredType(annotationVal.TypeName).ToEdmTypeReference(true) as IEdmStructuredTypeReference;

                ODataResourceDeserializer deserializer = new ODataResourceDeserializer(deserializerProvider);

                object resource = deserializer.CreateResourceInstance(annotationType, readContext);

                if (resource != null)
                {
                    foreach (var prop in annotationVal.Properties)
                    {
                        deserializer.ApplyStructuralProperty(resource, prop, annotationType, readContext);
                    }
                }
               
                return resource;
            }

            if (oDataValue is ODataPrimitiveValue primitiveValue)
            {
                return EdmPrimitiveHelpers.ConvertPrimitiveValue(primitiveValue.Value, primitiveValue.Value.GetType());
            }

            return oDataValue;
        }

        internal static Type GetPropertyType(object resource, string propertyName)
        {
            Contract.Assert(resource != null);
            Contract.Assert(propertyName != null);

            if (resource is IDelta delta)
            {
                Type type;
                delta.TryGetPropertyType(propertyName, out type);
                return type;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                return property == null ? null : property.PropertyType;
            }
        }

        private static bool CanSetProperty(object resource, string propertyName)
        {
            if (resource is IDelta delta)
            {
                return true;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                return property != null && property.GetSetMethod() != null;
            }
        }

        private static object GetProperty(object resource, string propertyName)
        {
            if (resource is IDelta delta)
            {
                object value;
                delta.TryGetPropertyValue(propertyName, out value);
                return value;
            }
            else
            {
                PropertyInfo property = resource.GetType().GetProperty(propertyName);
                Contract.Assert(property != null, "ODataLib should have already verified that the property exists on the type.");
                return property.GetValue(resource, index: null);
            }
        }

        private static object ConvertCollectionValue(ODataCollectionValue collection,
            ref IEdmTypeReference propertyType, ODataDeserializerProvider deserializerProvider,
            ODataDeserializerContext readContext)
        {
            IEdmCollectionTypeReference collectionType;
            if (propertyType == null)
            {
                // dynamic collection property
                Contract.Assert(!String.IsNullOrEmpty(collection.TypeName),
                    "ODataLib should have verified that dynamic collection value has a type name " +
                    "since we provided metadata.");

                string elementTypeName = GetCollectionElementTypeName(collection.TypeName, isNested: false);
                IEdmModel model = readContext.Model;
                IEdmSchemaType elementType = model.FindType(elementTypeName);
                Contract.Assert(elementType != null);
                collectionType =
                    new EdmCollectionTypeReference(
                        new EdmCollectionType(elementType.ToEdmTypeReference(isNullable: false)));
                propertyType = collectionType;
            }
            else
            {
                collectionType = propertyType as IEdmCollectionTypeReference;
                Contract.Assert(collectionType != null, "The type for collection must be a IEdmCollectionType.");
            }

            ODataEdmTypeDeserializer deserializer = deserializerProvider.GetEdmTypeDeserializer(collectionType);
            return deserializer.ReadInline(collection, collectionType, readContext);
        }

        private static object ConvertPrimitiveValue(string value)
        {
            double doubleValue;
            int intValue;
            decimal decimalValue;

            if (String.CompareOrdinal(value, "null") == 0)
            {
                return null;
            }

            if (Int32.TryParse(value, NumberStyles.Integer, NumberFormatInfo.InvariantInfo, out intValue))
            {
                return intValue;
            }

            // todo: if it is Ieee754Compatible, parse decimal after double
            if (Decimal.TryParse(value, NumberStyles.Number, NumberFormatInfo.InvariantInfo, out decimalValue))
            {
                return decimalValue;
            }

            if (Double.TryParse(value, NumberStyles.Float, NumberFormatInfo.InvariantInfo, out doubleValue))
            {
                return doubleValue;
            }

            if (!value.StartsWith("\"", StringComparison.Ordinal) || !value.EndsWith("\"", StringComparison.Ordinal))
            {
                throw new ODataException(Error.Format(SRResources.InvalidODataUntypedValue, value));
            }

            return value.Substring(1, value.Length - 2);
        }

        private static object ConvertEnumValue(ODataEnumValue enumValue, ref IEdmTypeReference propertyType,
            ODataDeserializerProvider deserializerProvider, ODataDeserializerContext readContext)
        {
            IEdmEnumTypeReference edmEnumType;
            if (propertyType == null)
            {
                // dynamic enum property
                Contract.Assert(!String.IsNullOrEmpty(enumValue.TypeName),
                    "ODataLib should have verified that dynamic enum value has a type name since we provided metadata.");
                IEdmModel model = readContext.Model;
                IEdmType edmType = model.FindType(enumValue.TypeName);
                Contract.Assert(edmType.TypeKind == EdmTypeKind.Enum, "ODataLib should have verified that enum value has a enum resource type.");
                edmEnumType = new EdmEnumTypeReference(edmType as IEdmEnumType, isNullable: true);
                propertyType = edmEnumType;
            }
            else
            {
                edmEnumType = propertyType.AsEnum();
            }

            ODataEdmTypeDeserializer deserializer = deserializerProvider.GetEdmTypeDeserializer(edmEnumType);
            return deserializer.ReadInline(enumValue, propertyType, readContext);
        }

        // The same logic from ODL to get the element type name in a collection.
        internal static string GetCollectionElementTypeName(string typeName, bool isNested)
        {
            const string CollectionTypeQualifier = "Collection";
            int collectionTypeQualifierLength = CollectionTypeQualifier.Length;

            // A collection type name must not be null, it has to start with "Collection(" and end with ")"
            // and must not be "Collection()"
            if (typeName != null &&
                typeName.StartsWith(CollectionTypeQualifier + "(", StringComparison.Ordinal) &&
                typeName[typeName.Length - 1] == ')' &&
                typeName.Length != collectionTypeQualifierLength + 2)
            {
                if (isNested)
                {
                    throw new ODataException(Error.Format(SRResources.NestedCollectionsNotSupported, typeName));
                }

                string innerTypeName = typeName.Substring(collectionTypeQualifierLength + 1,
                    typeName.Length - (collectionTypeQualifierLength + 2));

                // Check if it is not a nested collection and throw if it is
                GetCollectionElementTypeName(innerTypeName, true);

                return innerTypeName;
            }

            return null;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\DeserializationHelpers.cs(168,21): error CS0165: Use of unassigned local variable 'collection',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\DeserializationHelpers.cs(343,43): error CS0136: A local or parameter named 'delta' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\SelectExpandNode.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Query.Expressions;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Formatter.Serialization
{
    /// <summary>
    /// Describes the set of structural properties and navigation properties and actions to select and navigation properties to expand while
    /// writing an <see cref="ODataResource"/> in the response.
    /// </summary>
    public class SelectExpandNode
    {
        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class.
        /// </summary>
        /// <remarks>The default constructor is for unit testing only.</remarks>
        public SelectExpandNode()
        {
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class by copying the state of another instance. This is
        /// intended for scenarios that wish to modify state without updating the values cached within ODataResourceSerializer.
        /// </summary>
        /// <param name="selectExpandNodeToCopy">The instance from which the state for the new instance will be copied.</param>
        public SelectExpandNode(SelectExpandNode selectExpandNodeToCopy)
        {
            SelectedStructuralProperties = selectExpandNodeToCopy.SelectedStructuralProperties == null ?
                null : new HashSet<IEdmStructuralProperty>(selectExpandNodeToCopy.SelectedStructuralProperties);

            SelectedComplexTypeProperties = selectExpandNodeToCopy.SelectedComplexTypeProperties == null ?
                null : new Dictionary<IEdmStructuralProperty, PathSelectItem>(selectExpandNodeToCopy.SelectedComplexTypeProperties);

            SelectedNavigationProperties = selectExpandNodeToCopy.SelectedNavigationProperties == null ?
                null : new HashSet<IEdmNavigationProperty>(selectExpandNodeToCopy.SelectedNavigationProperties);

            ExpandedProperties = selectExpandNodeToCopy.ExpandedProperties == null ?
                null : new Dictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem>(selectExpandNodeToCopy.ExpandedProperties);

            ReferencedProperties = selectExpandNodeToCopy.ReferencedProperties == null ?
                null : new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();

            SelectAllDynamicProperties = selectExpandNodeToCopy.SelectAllDynamicProperties;

            SelectedDynamicProperties = selectExpandNodeToCopy.SelectedDynamicProperties == null ?
                null : new HashSet<string>(selectExpandNodeToCopy.SelectedDynamicProperties);

            SelectedActions = selectExpandNodeToCopy.SelectedActions == null ?
                null : new HashSet<IEdmAction>(selectExpandNodeToCopy.SelectedActions);

            SelectedFunctions = selectExpandNodeToCopy.SelectedFunctions == null ?
                null : new HashSet<IEdmFunction>(selectExpandNodeToCopy.SelectedFunctions);
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class describing the set of structural properties,
        /// nested properties, navigation properties, and actions to select and expand for the given <paramref name="writeContext"/>.
        /// </summary>
        /// <param name="structuredType">The structural type of the resource that would be written.</param>
        /// <param name="writeContext">The serializer context to be used while creating the collection.</param>
        /// <remarks>The default constructor is for unit testing only.</remarks>
        public SelectExpandNode(IEdmStructuredType structuredType, ODataSerializerContext writeContext)
            : this()
        {
            Initialize(writeContext.SelectExpandClause, structuredType, writeContext.Model, writeContext.ExpandReference);
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class describing the set of structural properties,
        /// nested properties, navigation properties, and actions to select and expand for the given <paramref name="selectExpandClause"/>.
        /// </summary>
        /// <param name="selectExpandClause">The parsed $select and $expand query options.</param>
        /// <param name="structuredType">The structural type of the resource that would be written.</param>
        /// <param name="model">The <see cref="IEdmModel"/> that contains the given structural type.</param>
        public SelectExpandNode(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmModel model)
            : this()
        {
            Initialize(selectExpandClause, structuredType, model, false);
        }

        /// <summary>
        /// Gets the list of EDM navigation properties to be expand referenced in the response.
        /// keeping this is only for non-breaking changes, This should be replaced by "ReferencedProperties" later.
        /// </summary>
        [Obsolete("This property will be removed later, please use ReferencedProperties.")]
        public ISet<IEdmNavigationProperty> ReferencedNavigationProperties
        {
            get
            {
                if (ReferencedProperties == null)
                {
                    return null;
                }

                return new HashSet<IEdmNavigationProperty>(ReferencedProperties.Keys);
            }
        }

        /// <summary>
        /// Gets the list of EDM nested properties (complex or collection of complex) to be included in the response.
        /// keeping this is only for non-breaking changes, This should be replaced by "SelectedComplexes".
        /// </summary>
        [Obsolete("This property will be removed later, please use SelectedComplexTypeProperties.")]
        public ISet<IEdmStructuralProperty> SelectedComplexProperties
        {
            get
            {
                if (SelectedComplexTypeProperties == null)
                {
                    return null;
                }

                return new HashSet<IEdmStructuralProperty>(SelectedComplexTypeProperties.Keys);
            }
        }

        /// <summary>
        /// Gets the list of EDM structural properties (primitive, enum or collection of them) to be included in the response.
        /// It could be null if there's no property selected.
        /// </summary>
        public ISet<IEdmStructuralProperty> SelectedStructuralProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be included as links in the response. It could be null.
        /// </summary>
        public ISet<IEdmNavigationProperty> SelectedNavigationProperties { get; internal set; }

        /// <summary>
        /// Gets the list of Edm structural properties (complex or complex collection) to be included in the response.
        /// The key is the Edm structural property.
        /// The value is the potential sub select item.
        /// </summary>
        public IDictionary<IEdmStructuralProperty, PathSelectItem> SelectedComplexTypeProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be expanded in the response along with the nested query options embedded in the expand.
        /// It could be null if no navigation property to expand.
        /// </summary>
        public IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> ExpandedProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be referenced in the response along with the nested query options embedded in the expand.
        /// It could be null if no navigation property to reference.
        /// </summary>
        public IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> ReferencedProperties { get; internal set; }

        /// <summary>s
        /// Gets the list of dynamic properties to select. It could be null.
        /// </summary>
        public ISet<string> SelectedDynamicProperties { get; internal set; }

        /// <summary>
        /// Gets the flag to indicate the dynamic property to be included in the response or not.
        /// </summary>
        public bool SelectAllDynamicProperties { get; internal set; }

        /// <summary>
        /// Gets the list of OData actions to be included in the response. It could be null.
        /// </summary>
        public ISet<IEdmAction> SelectedActions { get; internal set; }

        /// <summary>
        /// Gets the list of OData functions to be included in the response. It could be null.
        /// </summary>
        public ISet<IEdmFunction> SelectedFunctions { get; internal set; }

        /// <summary>
        /// Initialize the Node from <see cref="SelectExpandClause"/> for the given <see cref="IEdmStructuredType"/>.
        /// </summary>
        /// <param name="selectExpandClause">The input select and expand clause ($select and $expand).</param>
        /// <param name="structuredType">The related structural type to select and expand.</param>
        /// <param name="model">The Edm model.</param>
        /// <param name="expandedReference">Is expanded reference.</param>
        private void Initialize(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmModel model, bool expandedReference)
        {
            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            if (model == null)
            {
                throw Error.ArgumentNull("model");
            }

            IEdmEntityType entityType = structuredType as IEdmEntityType;
            if (expandedReference)
            {
                SelectAllDynamicProperties = false;
                if (entityType != null)
                {
                    // only need to include the key properties.
                    SelectedStructuralProperties = new HashSet<IEdmStructuralProperty>(entityType.Key());
                }
            }
            else
            {
                EdmStructuralTypeInfo structuralTypeInfo = new EdmStructuralTypeInfo(model, structuredType);

                if (selectExpandClause == null)
                {
                    SelectAllDynamicProperties = true;

                    // includes navigation properties
                    SelectedNavigationProperties = structuralTypeInfo.AllNavigationProperties;

                    // includes all bound actions
                    SelectedActions = structuralTypeInfo.AllActions;

                    // includes all bound functions
                    SelectedFunctions = structuralTypeInfo.AllFunctions;

                    // includes all structural properties
                    if (structuralTypeInfo.AllStructuralProperties != null)
                    {
                        foreach (var property in structuralTypeInfo.AllStructuralProperties)
                        {
                            AddStructuralProperty(property, null);
                        }
                    }
                }
                else
                {
                    BuildSelectExpand(selectExpandClause, structuralTypeInfo);
                }

                AdjustSelectNavigationProperties();
            }
        }

        /// <summary>
        /// Build $select and $expand clause
        /// </summary>
        /// <param name="selectExpandClause">The select expand clause</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildSelectExpand(SelectExpandClause selectExpandClause, EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(selectExpandClause != null);
            Contract.Assert(structuralTypeInfo != null);

            var currentLevelPropertiesInclude = new Dictionary<IEdmStructuralProperty, SelectExpandIncludedProperty>();

            // Explicitly set SelectAllDynamicProperties as false,
            // Below will re-set it as true if it meets the select all condition.
            SelectAllDynamicProperties = false;
            foreach (SelectItem selectItem in selectExpandClause.SelectedItems)
            {
                // $expand=...
                ExpandedReferenceSelectItem expandReferenceItem = selectItem as ExpandedReferenceSelectItem;
                if (expandReferenceItem != null)
                {
                    BuildExpandItem(expandReferenceItem, currentLevelPropertiesInclude, structuralTypeInfo);
                    continue;
                }

                PathSelectItem pathSelectItem = selectItem as PathSelectItem;
                if (pathSelectItem != null)
                {
                    // $select=abc/.../xyz
                    BuildSelectItem(pathSelectItem, currentLevelPropertiesInclude, structuralTypeInfo);
                    continue;
                }

                WildcardSelectItem wildCardSelectItem = selectItem as WildcardSelectItem;
                if (wildCardSelectItem != null)
                {
                    // $select=*
                    MergeAllStructuralProperties(structuralTypeInfo.AllStructuralProperties, currentLevelPropertiesInclude);
                    MergeSelectedNavigationProperties(structuralTypeInfo.AllNavigationProperties);
                    SelectAllDynamicProperties = true;
                    continue;
                }

                NamespaceQualifiedWildcardSelectItem wildCardActionSelection = selectItem as NamespaceQualifiedWildcardSelectItem;
                if (wildCardActionSelection != null)
                {
                    // $select=NS.*
                    AddNamespaceWildcardOperation(wildCardActionSelection, structuralTypeInfo.AllActions, structuralTypeInfo.AllFunctions);
                    continue;
                }

                throw new ODataException(Error.Format(SRResources.SelectionTypeNotSupported, selectItem.GetType().Name));
            }

            if (selectExpandClause.AllSelected)
            {
                MergeAllStructuralProperties(structuralTypeInfo.AllStructuralProperties, currentLevelPropertiesInclude);
                MergeSelectedNavigationProperties(structuralTypeInfo.AllNavigationProperties);
                MergeSelectedAction(structuralTypeInfo.AllActions);
                MergeSelectedFunction(structuralTypeInfo.AllFunctions);
                SelectAllDynamicProperties = true;
            }

            // to make sure the structural properties are in the same order defined in the type.
            if (structuralTypeInfo.AllStructuralProperties != null)
            {
                foreach (var structuralProperty in structuralTypeInfo.AllStructuralProperties)
                {
                    SelectExpandIncludedProperty includeProperty;
                    if (!currentLevelPropertiesInclude.TryGetValue(structuralProperty, out includeProperty))
                    {
                        continue;
                    }

                    PathSelectItem pathSelectItem = includeProperty == null ? null : includeProperty.ToPathSelectItem();
                    AddStructuralProperty(structuralProperty, pathSelectItem);
                }
            }
        }

        /// <summary>
        /// Build the $expand item, it maybe $expand=nav, $expand=complex/nav, $expand=nav/$ref, etc.
        /// </summary>
        /// <param name="expandReferenceItem">The expanded reference select item.</param>
        /// <param name="currentLevelPropertiesInclude">The current properties to include at current level.</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildExpandItem(ExpandedReferenceSelectItem expandReferenceItem,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(expandReferenceItem?.PathToNavigationProperty != null);
            Contract.Assert(currentLevelPropertiesInclude != null);
            Contract.Assert(structuralTypeInfo != null);

            // Verify and process the $expand=abc/xyz/nav.
            ODataExpandPath expandPath = expandReferenceItem.PathToNavigationProperty;
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment segment = expandPath.GetFirstNonTypeCastSegment(out remainingSegments);

            PropertySegment firstPropertySegment = segment as PropertySegment;
            if (firstPropertySegment != null)
            {
                // for example: $expand=abc/xyz/nav, the remaining segment can't be null
                // because at least the last navigation property segment is there.
                Contract.Assert(remainingSegments != null);

                if (structuralTypeInfo.IsStructuralPropertyDefined(firstPropertySegment.Property))
                {
                    SelectExpandIncludedProperty newPropertySelectItem;
                    if (!currentLevelPropertiesInclude.TryGetValue(firstPropertySegment.Property, out newPropertySelectItem))
                    {
                        newPropertySelectItem = new SelectExpandIncludedProperty(firstPropertySegment);
                        currentLevelPropertiesInclude[firstPropertySegment.Property] = newPropertySelectItem;
                    }

                    newPropertySelectItem.AddSubExpandItem(remainingSegments, expandReferenceItem);
                }
            }
            else
            {
                // for example: $expand=nav, or $expand=NS.SubType/nav, the navigation property segment should be the last segment.
                // So, the remaining segments should be null.
                Contract.Assert(remainingSegments == null);

                NavigationPropertySegment firstNavigationSegment = segment as NavigationPropertySegment;
                Contract.Assert(firstNavigationSegment != null);

                if (structuralTypeInfo.IsNavigationPropertyDefined(firstNavigationSegment.NavigationProperty))
                {
                    // It's not allowed to have mulitple navigation expanded or referenced.
                    // for example: "$expand=nav($top=2),nav($skip=3)" is not allowed and will be merged (or throw exception) at ODL side.
                    ExpandedNavigationSelectItem expanded = expandReferenceItem as ExpandedNavigationSelectItem;
                    if (expanded != null)
                    {
                        if (ExpandedProperties == null)
                        {
                            ExpandedProperties = new Dictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem>();
                        }

                        ExpandedProperties[firstNavigationSegment.NavigationProperty] = expanded;
                    }
                    else
                    {
                        // $expand=..../nav/$ref
                        if (ReferencedProperties == null)
                        {
                            ReferencedProperties = new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();
                        }

                        ReferencedProperties[firstNavigationSegment.NavigationProperty] = expandReferenceItem;
                    }
                }
            }
        }

        /// <summary>
        /// Build the $select item, it maybe $select=complex/abc, $select=abc, $select=nav, etc.
        /// </summary>
        /// <param name="pathSelectItem">The expanded reference select item.</param>
        /// <param name="currentLevelPropertiesInclude">The current properties to include at current level.</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildSelectItem(PathSelectItem pathSelectItem,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(pathSelectItem?.SelectedPath != null);
            Contract.Assert(currentLevelPropertiesInclude != null);
            Contract.Assert(structuralTypeInfo != null);

            // Verify and process the $select=abc/xyz/....
            ODataSelectPath selectPath = pathSelectItem.SelectedPath;
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment segment = selectPath.GetFirstNonTypeCastSegment(out remainingSegments);

            PropertySegment firstPropertySegment = segment as PropertySegment;
            if (firstPropertySegment != null)
            {
                if (structuralTypeInfo.IsStructuralPropertyDefined(firstPropertySegment.Property))
                {
                    // $select=abc/xyz/...
                    SelectExpandIncludedProperty newPropertySelectItem;
                    if (!currentLevelPropertiesInclude.TryGetValue(firstPropertySegment.Property, out newPropertySelectItem))
                    {
                        newPropertySelectItem = new SelectExpandIncludedProperty(firstPropertySegment);
                        currentLevelPropertiesInclude[firstPropertySegment.Property] = newPropertySelectItem;
                    }

                    newPropertySelectItem.AddSubSelectItem(remainingSegments, pathSelectItem);
                }

                return;
            }

            // If the first segment is not a property segment,
            // that segment must be the last segment, so the remainging segments should be null.
            Contract.Assert(remainingSegments == null);

            NavigationPropertySegment navigationSegment = segment as NavigationPropertySegment;
            if (navigationSegment != null)
            {
                // for example: $select=NavigationProperty or $select=NS.VipCustomer/VipNav
                if (structuralTypeInfo.IsNavigationPropertyDefined(navigationSegment.NavigationProperty))
                {
                    if (SelectedNavigationProperties == null)
                    {
                        SelectedNavigationProperties = new HashSet<IEdmNavigationProperty>();
                    }

                    SelectedNavigationProperties.Add(navigationSegment.NavigationProperty);
                }

                return;
            }

            OperationSegment operationSegment = segment as OperationSegment;
            if (operationSegment != null)
            {
                // for example: $select=NS.Operation, or, $select=NS.VipCustomer/NS.Operation
                AddOperations(operationSegment, structuralTypeInfo.AllActions, structuralTypeInfo.AllFunctions);
                return;
            }

            DynamicPathSegment dynamicPathSegment = segment as DynamicPathSegment;
            if (dynamicPathSegment != null)
            {
                if (SelectedDynamicProperties == null)
                {
                    SelectedDynamicProperties = new HashSet<string>();
                }

                SelectedDynamicProperties.Add(dynamicPathSegment.Identifier);
                return;
            }

            // In fact, we should never be here, because it's verified above
            throw new ODataException(Error.Format(SRResources.SelectionTypeNotSupported, segment.GetType().Name));
        }

        private static void MergeAllStructuralProperties(ISet<IEdmStructuralProperty> allStructuralProperties,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude)
        {
            if (allStructuralProperties == null)
            {
                return;
            }

            Contract.Assert(currentLevelPropertiesInclude != null);

            foreach (var property in allStructuralProperties)
            {
                if (!currentLevelPropertiesInclude.ContainsKey(property))
                {
                    // Set the value as null is safe, because this property should not further process.
                    // Besides, if there's "WildcardSelectItem", there's no other property selection items.
                    currentLevelPropertiesInclude[property] = null;
                }
            }
        }

        private void MergeSelectedNavigationProperties(ISet<IEdmNavigationProperty> allNavigationProperties)
        {
            if (allNavigationProperties == null)
            {
                return;
            }

            if (SelectedNavigationProperties == null)
            {
                SelectedNavigationProperties = allNavigationProperties;
            }
            else
            {
                SelectedNavigationProperties.UnionWith(allNavigationProperties);
            }
        }

        private void MergeSelectedAction(ISet<IEdmAction> allActions)
        {
            if (allActions == null)
            {
                return;
            }

            if (SelectedActions == null)
            {
                SelectedActions = allActions;
            }
            else
            {
                SelectedActions.UnionWith(allActions);
            }
        }

        private void MergeSelectedFunction(ISet<IEdmFunction> allFunctions)
        {
            if (allFunctions == null)
            {
                return;
            }

            if (SelectedFunctions == null)
            {
                SelectedFunctions = allFunctions;
            }
            else
            {
                SelectedFunctions.UnionWith(allFunctions);
            }
        }

        private void AddStructuralProperty(IEdmStructuralProperty structuralProperty, PathSelectItem pathSelectItem)
        {
            bool isComplexOrCollectComplex = IsComplexOrCollectionComplex(structuralProperty);

            if (isComplexOrCollectComplex)
            {
                if (SelectedComplexTypeProperties == null)
                {
                    SelectedComplexTypeProperties = new Dictionary<IEdmStructuralProperty, PathSelectItem>();
                }

                SelectedComplexTypeProperties[structuralProperty] = pathSelectItem;
            }
            else
            {
                if (SelectedStructuralProperties == null)
                {
                    SelectedStructuralProperties = new HashSet<IEdmStructuralProperty>();
                }

                // for primitive, enum and collection them, needn't care about the nested query options now.
                // So, skip the path select item.
                SelectedStructuralProperties.Add(structuralProperty);
            }
        }

        private void AddNamespaceWildcardOperation(NamespaceQualifiedWildcardSelectItem namespaceSelectItem, ISet<IEdmAction> allActions,
            ISet<IEdmFunction> allFunctions)
        {
            if (allActions == null)
            {
                SelectedActions = null;
            }
            else
            {
                SelectedActions = new HashSet<IEdmAction>(allActions.Where(a => a.Namespace == namespaceSelectItem.Namespace));
            }

            if (allFunctions == null)
            {
                SelectedFunctions = null;
            }
            else
            {
                SelectedFunctions = new HashSet<IEdmFunction>(allFunctions.Where(a => a.Namespace == namespaceSelectItem.Namespace));
            }
        }

        private void AddOperations(OperationSegment operationSegment, ISet<IEdmAction> allActions, ISet<IEdmFunction> allFunctions)
        {
            foreach (IEdmOperation operation in operationSegment.Operations)
            {
                IEdmAction action = operation as IEdmAction;
                if (action != null && allActions.Contains(action))
                {
                    if (SelectedActions == null)
                    {
                        SelectedActions = new HashSet<IEdmAction>();
                    }

                    SelectedActions.Add(action);
                }

                IEdmFunction function = operation as IEdmFunction;
                if (function != null && allFunctions.Contains(function))
                {
                    if (SelectedFunctions == null)
                    {
                        SelectedFunctions = new HashSet<IEdmFunction>();
                    }

                    SelectedFunctions.Add(function);
                }
            }
        }

        private void AdjustSelectNavigationProperties()
        {
            if (SelectedNavigationProperties != null)
            {
                // remove expanded navigation properties from the selected navigation properties.
                if (ExpandedProperties != null)
                {
                    SelectedNavigationProperties.ExceptWith(ExpandedProperties.Keys);
                }

                // remove referenced navigation properties from the selected navigation properties.
                if (ReferencedProperties != null)
                {
                    SelectedNavigationProperties.ExceptWith(ReferencedProperties.Keys);
                }
            }

            if (SelectedNavigationProperties != null && !SelectedNavigationProperties.Any())
            {
                SelectedNavigationProperties = null;
            }
        }

        /// <summary>
        /// Test whether the input structural property is complex property or collection of complex property.
        /// </summary>
        /// <param name="structuralProperty">The test structural property.</param>
        /// <returns>True/false.</returns>
        internal static bool IsComplexOrCollectionComplex(IEdmStructuralProperty structuralProperty)
        {
            if (structuralProperty == null)
            {
                return false;
            }

            if (structuralProperty.Type.IsComplex())
            {
                return true;
            }

            if (structuralProperty.Type.IsCollection())
            {
                if (structuralProperty.Type.AsCollection().ElementType().IsComplex())
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Separate the structural properties into two parts:
        /// 1. Complex and collection of complex are nested structural properties.
        /// 2. Others are non-nested structural properties.
        /// </summary>
        /// <param name="structuredType">The structural type of the resource.</param>
        /// <param name="structuralProperties">The non-nested structural properties of the structural type.</param>
        /// <param name="nestedStructuralProperties">The nested structural properties of the structural type.</param>
        [Obsolete("This public method is not used anymore. It will be removed later.")]
        public static void GetStructuralProperties(IEdmStructuredType structuredType, HashSet<IEdmStructuralProperty> structuralProperties,
            HashSet<IEdmStructuralProperty> nestedStructuralProperties)
        {
            // Be noted: this method is not used anymore. Keeping it unremoved is only for non-breaking changes.
            // If any new requirement for such method, it's better to move to "EdmLibHelpers" class.

            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            if (structuralProperties == null)
            {
                throw Error.ArgumentNull("structuralProperties");
            }

            if (nestedStructuralProperties == null)
            {
                throw Error.ArgumentNull("nestedStructuralProperties");
            }

            foreach (var edmStructuralProperty in structuredType.StructuralProperties())
            {
                if (edmStructuralProperty.Type.IsComplex())
                {
                    nestedStructuralProperties.Add(edmStructuralProperty);
                }
                else if (edmStructuralProperty.Type.IsCollection())
                {
                    if (edmStructuralProperty.Type.AsCollection().ElementType().IsComplex())
                    {
                        nestedStructuralProperties.Add(edmStructuralProperty);
                    }
                    else
                    {
                        structuralProperties.Add(edmStructuralProperty);
                    }
                }
                else
                {
                    structuralProperties.Add(edmStructuralProperty);
                }
            }
        }

        /// <summary>
        /// An internal cache class used to provide the propert, operations
        /// and do verification on the given <see cref="IEdmStructuredType"/>.
        /// </summary>
        internal class EdmStructuralTypeInfo
        {
            /// <summary>
            /// Gets all structural properties defined on the structure type.
            /// </summary>
            public ISet<IEdmStructuralProperty> AllStructuralProperties { get; }

            /// <summary>
            /// Gets all navigation properties defined on the structure type.
            /// </summary>
            public ISet<IEdmNavigationProperty> AllNavigationProperties { get; }

            /// <summary>
            /// Gets all actions bonding to the structure type.
            /// </summary>
            public ISet<IEdmAction> AllActions { get; }

            /// <summary>
            /// Gets all function bonding to the structure type.
            /// </summary>
            public ISet<IEdmFunction> AllFunctions { get; }

            /// <summary>
            /// Creates a new instance of the <see cref="EdmStructuralTypeInfo"/> class
            /// </summary>
            /// <param name="model">The Edm model.</param>
            /// <param name="structuredType">The Edm structured Type.</param>
            public EdmStructuralTypeInfo(IEdmModel model, IEdmStructuredType structuredType)
            {
                Contract.Assert(model != null);
                Contract.Assert(structuredType != null);

                foreach (var edmProperty in structuredType.Properties())
                {
                    switch (edmProperty.PropertyKind)
                    {
                        case EdmPropertyKind.Structural:
                            if (AllStructuralProperties == null)
                            {
                                AllStructuralProperties = new HashSet<IEdmStructuralProperty>();
                            }

                            AllStructuralProperties.Add((IEdmStructuralProperty)edmProperty);
                            break;

                        case EdmPropertyKind.Navigation:
                            if (AllNavigationProperties == null)
                            {
                                AllNavigationProperties = new HashSet<IEdmNavigationProperty>();
                            }

                            AllNavigationProperties.Add((IEdmNavigationProperty)edmProperty);
                            break;
                    }
                }

                IEdmEntityType entityType = structuredType as IEdmEntityType;
                if (entityType != null)
                {
                    var actions = model.GetAvailableActions(entityType);
                    AllActions = actions.Any() ? new HashSet<IEdmAction>(actions) : null;

                    var functions = model.GetAvailableFunctions(entityType);
                    AllFunctions = functions.Any() ? new HashSet<IEdmFunction>(functions) : null;
                }
            }

            /// <summary>
            /// Tests whether a <see cref="IEdmStructuralProperty"/> is defined on this type.
            /// </summary>
            /// <param name="property">The test property.</param>
            /// <returns>True/false</returns>
            public bool IsStructuralPropertyDefined(IEdmStructuralProperty property)
            {
                return AllStructuralProperties != null && AllStructuralProperties.Contains(property);
            }

            /// <summary>
            /// Tests whether a <see cref="IEdmNavigationProperty"/> is defined on this type.
            /// </summary>
            /// <param name="property">The test property.</param>
            /// <returns>True/false</returns>
            public bool IsNavigationPropertyDefined(IEdmNavigationProperty property)
            {
                return AllNavigationProperties != null && AllNavigationProperties.Contains(property);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Query.Expressions;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Formatter.Serialization
{
    /// <summary>
    /// Describes the set of structural properties and navigation properties and actions to select and navigation properties to expand while
    /// writing an <see cref="ODataResource"/> in the response.
    /// </summary>
    public class SelectExpandNode
    {
        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class.
        /// </summary>
        /// <remarks>The default constructor is for unit testing only.</remarks>
        public SelectExpandNode()
        {
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class by copying the state of another instance. This is
        /// intended for scenarios that wish to modify state without updating the values cached within ODataResourceSerializer.
        /// </summary>
        /// <param name="selectExpandNodeToCopy">The instance from which the state for the new instance will be copied.</param>
        public SelectExpandNode(SelectExpandNode selectExpandNodeToCopy)
        {
            SelectedStructuralProperties = selectExpandNodeToCopy.SelectedStructuralProperties == null ?
                null : new HashSet<IEdmStructuralProperty>(selectExpandNodeToCopy.SelectedStructuralProperties);

            SelectedComplexTypeProperties = selectExpandNodeToCopy.SelectedComplexTypeProperties == null ?
                null : new Dictionary<IEdmStructuralProperty, PathSelectItem>(selectExpandNodeToCopy.SelectedComplexTypeProperties);

            SelectedNavigationProperties = selectExpandNodeToCopy.SelectedNavigationProperties == null ?
                null : new HashSet<IEdmNavigationProperty>(selectExpandNodeToCopy.SelectedNavigationProperties);

            ExpandedProperties = selectExpandNodeToCopy.ExpandedProperties == null ?
                null : new Dictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem>(selectExpandNodeToCopy.ExpandedProperties);

            ReferencedProperties = selectExpandNodeToCopy.ReferencedProperties == null ?
                null : new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();

            SelectAllDynamicProperties = selectExpandNodeToCopy.SelectAllDynamicProperties;

            SelectedDynamicProperties = selectExpandNodeToCopy.SelectedDynamicProperties == null ?
                null : new HashSet<string>(selectExpandNodeToCopy.SelectedDynamicProperties);

            SelectedActions = selectExpandNodeToCopy.SelectedActions == null ?
                null : new HashSet<IEdmAction>(selectExpandNodeToCopy.SelectedActions);

            SelectedFunctions = selectExpandNodeToCopy.SelectedFunctions == null ?
                null : new HashSet<IEdmFunction>(selectExpandNodeToCopy.SelectedFunctions);
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class describing the set of structural properties,
        /// nested properties, navigation properties, and actions to select and expand for the given <paramref name="writeContext"/>.
        /// </summary>
        /// <param name="structuredType">The structural type of the resource that would be written.</param>
        /// <param name="writeContext">The serializer context to be used while creating the collection.</param>
        /// <remarks>The default constructor is for unit testing only.</remarks>
        public SelectExpandNode(IEdmStructuredType structuredType, ODataSerializerContext writeContext)
            : this()
        {
            Initialize(writeContext.SelectExpandClause, structuredType, writeContext.Model, writeContext.ExpandReference);
        }

        /// <summary>
        /// Creates a new instance of the <see cref="SelectExpandNode"/> class describing the set of structural properties,
        /// nested properties, navigation properties, and actions to select and expand for the given <paramref name="selectExpandClause"/>.
        /// </summary>
        /// <param name="selectExpandClause">The parsed $select and $expand query options.</param>
        /// <param name="structuredType">The structural type of the resource that would be written.</param>
        /// <param name="model">The <see cref="IEdmModel"/> that contains the given structural type.</param>
        public SelectExpandNode(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmModel model)
            : this()
        {
            Initialize(selectExpandClause, structuredType, model, false);
        }

        /// <summary>
        /// Gets the list of EDM navigation properties to be expand referenced in the response.
        /// keeping this is only for non-breaking changes, This should be replaced by "ReferencedProperties" later.
        /// </summary>
        [Obsolete("This property will be removed later, please use ReferencedProperties.")]
        public ISet<IEdmNavigationProperty> ReferencedNavigationProperties
        {
            get
            {
                if (ReferencedProperties == null)
                {
                    return null;
                }

                return new HashSet<IEdmNavigationProperty>(ReferencedProperties.Keys);
            }
        }

        /// <summary>
        /// Gets the list of EDM nested properties (complex or collection of complex) to be included in the response.
        /// keeping this is only for non-breaking changes, This should be replaced by "SelectedComplexes".
        /// </summary>
        [Obsolete("This property will be removed later, please use SelectedComplexTypeProperties.")]
        public ISet<IEdmStructuralProperty> SelectedComplexProperties
        {
            get
            {
                if (SelectedComplexTypeProperties == null)
                {
                    return null;
                }

                return new HashSet<IEdmStructuralProperty>(SelectedComplexTypeProperties.Keys);
            }
        }

        /// <summary>
        /// Gets the list of EDM structural properties (primitive, enum or collection of them) to be included in the response.
        /// It could be null if there's no property selected.
        /// </summary>
        public ISet<IEdmStructuralProperty> SelectedStructuralProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be included as links in the response. It could be null.
        /// </summary>
        public ISet<IEdmNavigationProperty> SelectedNavigationProperties { get; internal set; }

        /// <summary>
        /// Gets the list of Edm structural properties (complex or complex collection) to be included in the response.
        /// The key is the Edm structural property.
        /// The value is the potential sub select item.
        /// </summary>
        public IDictionary<IEdmStructuralProperty, PathSelectItem> SelectedComplexTypeProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be expanded in the response along with the nested query options embedded in the expand.
        /// It could be null if no navigation property to expand.
        /// </summary>
        public IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> ExpandedProperties { get; internal set; }

        /// <summary>
        /// Gets the list of EDM navigation properties to be referenced in the response along with the nested query options embedded in the expand.
        /// It could be null if no navigation property to reference.
        /// </summary>
        public IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> ReferencedProperties { get; internal set; }

        /// <summary>s
        /// Gets the list of dynamic properties to select. It could be null.
        /// </summary>
        public ISet<string> SelectedDynamicProperties { get; internal set; }

        /// <summary>
        /// Gets the flag to indicate the dynamic property to be included in the response or not.
        /// </summary>
        public bool SelectAllDynamicProperties { get; internal set; }

        /// <summary>
        /// Gets the list of OData actions to be included in the response. It could be null.
        /// </summary>
        public ISet<IEdmAction> SelectedActions { get; internal set; }

        /// <summary>
        /// Gets the list of OData functions to be included in the response. It could be null.
        /// </summary>
        public ISet<IEdmFunction> SelectedFunctions { get; internal set; }

        /// <summary>
        /// Initialize the Node from <see cref="SelectExpandClause"/> for the given <see cref="IEdmStructuredType"/>.
        /// </summary>
        /// <param name="selectExpandClause">The input select and expand clause ($select and $expand).</param>
        /// <param name="structuredType">The related structural type to select and expand.</param>
        /// <param name="model">The Edm model.</param>
        /// <param name="expandedReference">Is expanded reference.</param>
        private void Initialize(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmModel model, bool expandedReference)
        {
            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            if (model == null)
            {
                throw Error.ArgumentNull("model");
            }
            if (expandedReference)
            {
                SelectAllDynamicProperties = false;

                if (structuredType is IEdmEntityType entityType)
                {
                    // only need to include the key properties.
                    SelectedStructuralProperties = new HashSet<IEdmStructuralProperty>(entityType.Key());
                }
            }
            else
            {
                EdmStructuralTypeInfo structuralTypeInfo = new EdmStructuralTypeInfo(model, structuredType);

                if (selectExpandClause == null)
                {
                    SelectAllDynamicProperties = true;

                    // includes navigation properties
                    SelectedNavigationProperties = structuralTypeInfo.AllNavigationProperties;

                    // includes all bound actions
                    SelectedActions = structuralTypeInfo.AllActions;

                    // includes all bound functions
                    SelectedFunctions = structuralTypeInfo.AllFunctions;

                    // includes all structural properties
                    if (structuralTypeInfo.AllStructuralProperties != null)
                    {
                        foreach (var property in structuralTypeInfo.AllStructuralProperties)
                        {
                            AddStructuralProperty(property, null);
                        }
                    }
                }
                else
                {
                    BuildSelectExpand(selectExpandClause, structuralTypeInfo);
                }

                AdjustSelectNavigationProperties();
            }
        }

        /// <summary>
        /// Build $select and $expand clause
        /// </summary>
        /// <param name="selectExpandClause">The select expand clause</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildSelectExpand(SelectExpandClause selectExpandClause, EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(selectExpandClause != null);
            Contract.Assert(structuralTypeInfo != null);

            var currentLevelPropertiesInclude = new Dictionary<IEdmStructuralProperty, SelectExpandIncludedProperty>();

            // Explicitly set SelectAllDynamicProperties as false,
            // Below will re-set it as true if it meets the select all condition.
            SelectAllDynamicProperties = false;
            foreach (SelectItem selectItem in selectExpandClause.SelectedItems)
            {
                // $expand=...
                if (selectItem is ExpandedReferenceSelectItem expandReferenceItem)
                {
                    BuildExpandItem(expandReferenceItem, currentLevelPropertiesInclude, structuralTypeInfo);
                    continue;
                }

                if (selectItem is PathSelectItem pathSelectItem)
                {
                    // $select=abc/.../xyz
                    BuildSelectItem(pathSelectItem, currentLevelPropertiesInclude, structuralTypeInfo);
                    continue;
                }

                if (selectItem is WildcardSelectItem wildCardSelectItem)
                {
                    // $select=*
                    MergeAllStructuralProperties(structuralTypeInfo.AllStructuralProperties, currentLevelPropertiesInclude);
                    MergeSelectedNavigationProperties(structuralTypeInfo.AllNavigationProperties);
                    SelectAllDynamicProperties = true;
                    continue;
                }

                if (selectItem is NamespaceQualifiedWildcardSelectItem wildCardActionSelection)
                {
                    // $select=NS.*
                    AddNamespaceWildcardOperation(wildCardActionSelection, structuralTypeInfo.AllActions, structuralTypeInfo.AllFunctions);
                    continue;
                }

                throw new ODataException(Error.Format(SRResources.SelectionTypeNotSupported, selectItem.GetType().Name));
            }

            if (selectExpandClause.AllSelected)
            {
                MergeAllStructuralProperties(structuralTypeInfo.AllStructuralProperties, currentLevelPropertiesInclude);
                MergeSelectedNavigationProperties(structuralTypeInfo.AllNavigationProperties);
                MergeSelectedAction(structuralTypeInfo.AllActions);
                MergeSelectedFunction(structuralTypeInfo.AllFunctions);
                SelectAllDynamicProperties = true;
            }

            // to make sure the structural properties are in the same order defined in the type.
            if (structuralTypeInfo.AllStructuralProperties != null)
            {
                foreach (var structuralProperty in structuralTypeInfo.AllStructuralProperties)
                {
                    SelectExpandIncludedProperty includeProperty;
                    if (!currentLevelPropertiesInclude.TryGetValue(structuralProperty, out includeProperty))
                    {
                        continue;
                    }

                    PathSelectItem pathSelectItem = includeProperty == null ? null : includeProperty.ToPathSelectItem();
                    AddStructuralProperty(structuralProperty, pathSelectItem);
                }
            }
        }

        /// <summary>
        /// Build the $expand item, it maybe $expand=nav, $expand=complex/nav, $expand=nav/$ref, etc.
        /// </summary>
        /// <param name="expandReferenceItem">The expanded reference select item.</param>
        /// <param name="currentLevelPropertiesInclude">The current properties to include at current level.</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildExpandItem(ExpandedReferenceSelectItem expandReferenceItem,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(expandReferenceItem?.PathToNavigationProperty != null);
            Contract.Assert(currentLevelPropertiesInclude != null);
            Contract.Assert(structuralTypeInfo != null);

            // Verify and process the $expand=abc/xyz/nav.
            ODataExpandPath expandPath = expandReferenceItem.PathToNavigationProperty;
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment segment = expandPath.GetFirstNonTypeCastSegment(out remainingSegments);

            if (segment is PropertySegment firstPropertySegment)
            {
                // for example: $expand=abc/xyz/nav, the remaining segment can't be null
                // because at least the last navigation property segment is there.
                Contract.Assert(remainingSegments != null);

                if (structuralTypeInfo.IsStructuralPropertyDefined(firstPropertySegment.Property))
                {
                    SelectExpandIncludedProperty newPropertySelectItem;
                    if (!currentLevelPropertiesInclude.TryGetValue(firstPropertySegment.Property, out newPropertySelectItem))
                    {
                        newPropertySelectItem = new SelectExpandIncludedProperty(firstPropertySegment);
                        currentLevelPropertiesInclude[firstPropertySegment.Property] = newPropertySelectItem;
                    }

                    newPropertySelectItem.AddSubExpandItem(remainingSegments, expandReferenceItem);
                }
            }
            else
            {
                // for example: $expand=nav, or $expand=NS.SubType/nav, the navigation property segment should be the last segment.
                // So, the remaining segments should be null.
                Contract.Assert(remainingSegments == null);
                Contract.Assert(segment is NavigationPropertySegment firstNavigationSegment);

                if (structuralTypeInfo.IsNavigationPropertyDefined(firstNavigationSegment.NavigationProperty))
                {
                    // It's not allowed to have mulitple navigation expanded or referenced.                    // for example: "$expand=nav($top=2),nav($skip=3)" is not allowed and will be merged (or throw exception) at ODL side.
                    if (expandReferenceItem is ExpandedNavigationSelectItem expanded)
                    {
                        if (ExpandedProperties == null)
                        {
                            ExpandedProperties = new Dictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem>();
                        }

                        ExpandedProperties[firstNavigationSegment.NavigationProperty] = expanded;
                    }
                    else
                    {
                        // $expand=..../nav/$ref
                        if (ReferencedProperties == null)
                        {
                            ReferencedProperties = new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();
                        }

                        ReferencedProperties[firstNavigationSegment.NavigationProperty] = expandReferenceItem;
                    }
                }
            }
        }

        /// <summary>
        /// Build the $select item, it maybe $select=complex/abc, $select=abc, $select=nav, etc.
        /// </summary>
        /// <param name="pathSelectItem">The expanded reference select item.</param>
        /// <param name="currentLevelPropertiesInclude">The current properties to include at current level.</param>
        /// <param name="structuralTypeInfo">The structural type properties.</param>
        private void BuildSelectItem(PathSelectItem pathSelectItem,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            EdmStructuralTypeInfo structuralTypeInfo)
        {
            Contract.Assert(pathSelectItem?.SelectedPath != null);
            Contract.Assert(currentLevelPropertiesInclude != null);
            Contract.Assert(structuralTypeInfo != null);

            // Verify and process the $select=abc/xyz/....
            ODataSelectPath selectPath = pathSelectItem.SelectedPath;
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment segment = selectPath.GetFirstNonTypeCastSegment(out remainingSegments);

            if (segment is PropertySegment firstPropertySegment)
            {
                if (structuralTypeInfo.IsStructuralPropertyDefined(firstPropertySegment.Property))
                {
                    // $select=abc/xyz/...
                    SelectExpandIncludedProperty newPropertySelectItem;
                    if (!currentLevelPropertiesInclude.TryGetValue(firstPropertySegment.Property, out newPropertySelectItem))
                    {
                        newPropertySelectItem = new SelectExpandIncludedProperty(firstPropertySegment);
                        currentLevelPropertiesInclude[firstPropertySegment.Property] = newPropertySelectItem;
                    }

                    newPropertySelectItem.AddSubSelectItem(remainingSegments, pathSelectItem);
                }

                return;
            }

            // If the first segment is not a property segment,
            // that segment must be the last segment, so the remainging segments should be null.
            Contract.Assert(remainingSegments == null);

            if (segment is NavigationPropertySegment navigationSegment)
            {
                // for example: $select=NavigationProperty or $select=NS.VipCustomer/VipNav
                if (structuralTypeInfo.IsNavigationPropertyDefined(navigationSegment.NavigationProperty))
                {
                    if (SelectedNavigationProperties == null)
                    {
                        SelectedNavigationProperties = new HashSet<IEdmNavigationProperty>();
                    }

                    SelectedNavigationProperties.Add(navigationSegment.NavigationProperty);
                }

                return;
            }

            if (segment is OperationSegment operationSegment)
            {
                // for example: $select=NS.Operation, or, $select=NS.VipCustomer/NS.Operation
                AddOperations(operationSegment, structuralTypeInfo.AllActions, structuralTypeInfo.AllFunctions);
                return;
            }

            if (segment is DynamicPathSegment dynamicPathSegment)
            {
                if (SelectedDynamicProperties == null)
                {
                    SelectedDynamicProperties = new HashSet<string>();
                }

                SelectedDynamicProperties.Add(dynamicPathSegment.Identifier);
                return;
            }

            // In fact, we should never be here, because it's verified above
            throw new ODataException(Error.Format(SRResources.SelectionTypeNotSupported, segment.GetType().Name));
        }

        private static void MergeAllStructuralProperties(ISet<IEdmStructuralProperty> allStructuralProperties,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude)
        {
            if (allStructuralProperties == null)
            {
                return;
            }

            Contract.Assert(currentLevelPropertiesInclude != null);

            foreach (var property in allStructuralProperties)
            {
                if (!currentLevelPropertiesInclude.ContainsKey(property))
                {
                    // Set the value as null is safe, because this property should not further process.
                    // Besides, if there's "WildcardSelectItem", there's no other property selection items.
                    currentLevelPropertiesInclude[property] = null;
                }
            }
        }

        private void MergeSelectedNavigationProperties(ISet<IEdmNavigationProperty> allNavigationProperties)
        {
            if (allNavigationProperties == null)
            {
                return;
            }

            if (SelectedNavigationProperties == null)
            {
                SelectedNavigationProperties = allNavigationProperties;
            }
            else
            {
                SelectedNavigationProperties.UnionWith(allNavigationProperties);
            }
        }

        private void MergeSelectedAction(ISet<IEdmAction> allActions)
        {
            if (allActions == null)
            {
                return;
            }

            if (SelectedActions == null)
            {
                SelectedActions = allActions;
            }
            else
            {
                SelectedActions.UnionWith(allActions);
            }
        }

        private void MergeSelectedFunction(ISet<IEdmFunction> allFunctions)
        {
            if (allFunctions == null)
            {
                return;
            }

            if (SelectedFunctions == null)
            {
                SelectedFunctions = allFunctions;
            }
            else
            {
                SelectedFunctions.UnionWith(allFunctions);
            }
        }

        private void AddStructuralProperty(IEdmStructuralProperty structuralProperty, PathSelectItem pathSelectItem)
        {
            bool isComplexOrCollectComplex = IsComplexOrCollectionComplex(structuralProperty);

            if (isComplexOrCollectComplex)
            {
                if (SelectedComplexTypeProperties == null)
                {
                    SelectedComplexTypeProperties = new Dictionary<IEdmStructuralProperty, PathSelectItem>();
                }

                SelectedComplexTypeProperties[structuralProperty] = pathSelectItem;
            }
            else
            {
                if (SelectedStructuralProperties == null)
                {
                    SelectedStructuralProperties = new HashSet<IEdmStructuralProperty>();
                }

                // for primitive, enum and collection them, needn't care about the nested query options now.
                // So, skip the path select item.
                SelectedStructuralProperties.Add(structuralProperty);
            }
        }

        private void AddNamespaceWildcardOperation(NamespaceQualifiedWildcardSelectItem namespaceSelectItem, ISet<IEdmAction> allActions,
            ISet<IEdmFunction> allFunctions)
        {
            if (allActions == null)
            {
                SelectedActions = null;
            }
            else
            {
                SelectedActions = new HashSet<IEdmAction>(allActions.Where(a => a.Namespace == namespaceSelectItem.Namespace));
            }

            if (allFunctions == null)
            {
                SelectedFunctions = null;
            }
            else
            {
                SelectedFunctions = new HashSet<IEdmFunction>(allFunctions.Where(a => a.Namespace == namespaceSelectItem.Namespace));
            }
        }

        private void AddOperations(OperationSegment operationSegment, ISet<IEdmAction> allActions, ISet<IEdmFunction> allFunctions)
        {
            foreach (IEdmOperation operation in operationSegment.Operations)
            {
                if (operation is IEdmAction action && allActions.Contains(action))
                {
                    if (SelectedActions == null)
                    {
                        SelectedActions = new HashSet<IEdmAction>();
                    }

                    SelectedActions.Add(action);
                }

                if (operation is IEdmFunction function && allFunctions.Contains(function))
                {
                    if (SelectedFunctions == null)
                    {
                        SelectedFunctions = new HashSet<IEdmFunction>();
                    }

                    SelectedFunctions.Add(function);
                }
            }
        }

        private void AdjustSelectNavigationProperties()
        {
            if (SelectedNavigationProperties != null)
            {
                // remove expanded navigation properties from the selected navigation properties.
                if (ExpandedProperties != null)
                {
                    SelectedNavigationProperties.ExceptWith(ExpandedProperties.Keys);
                }

                // remove referenced navigation properties from the selected navigation properties.
                if (ReferencedProperties != null)
                {
                    SelectedNavigationProperties.ExceptWith(ReferencedProperties.Keys);
                }
            }

            if (SelectedNavigationProperties != null && !SelectedNavigationProperties.Any())
            {
                SelectedNavigationProperties = null;
            }
        }

        /// <summary>
        /// Test whether the input structural property is complex property or collection of complex property.
        /// </summary>
        /// <param name="structuralProperty">The test structural property.</param>
        /// <returns>True/false.</returns>
        internal static bool IsComplexOrCollectionComplex(IEdmStructuralProperty structuralProperty)
        {
            if (structuralProperty == null)
            {
                return false;
            }

            if (structuralProperty.Type.IsComplex())
            {
                return true;
            }

            if (structuralProperty.Type.IsCollection())
            {
                if (structuralProperty.Type.AsCollection().ElementType().IsComplex())
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Separate the structural properties into two parts:
        /// 1. Complex and collection of complex are nested structural properties.
        /// 2. Others are non-nested structural properties.
        /// </summary>
        /// <param name="structuredType">The structural type of the resource.</param>
        /// <param name="structuralProperties">The non-nested structural properties of the structural type.</param>
        /// <param name="nestedStructuralProperties">The nested structural properties of the structural type.</param>
        [Obsolete("This public method is not used anymore. It will be removed later.")]
        public static void GetStructuralProperties(IEdmStructuredType structuredType, HashSet<IEdmStructuralProperty> structuralProperties,
            HashSet<IEdmStructuralProperty> nestedStructuralProperties)
        {
            // Be noted: this method is not used anymore. Keeping it unremoved is only for non-breaking changes.
            // If any new requirement for such method, it's better to move to "EdmLibHelpers" class.

            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            if (structuralProperties == null)
            {
                throw Error.ArgumentNull("structuralProperties");
            }

            if (nestedStructuralProperties == null)
            {
                throw Error.ArgumentNull("nestedStructuralProperties");
            }

            foreach (var edmStructuralProperty in structuredType.StructuralProperties())
            {
                if (edmStructuralProperty.Type.IsComplex())
                {
                    nestedStructuralProperties.Add(edmStructuralProperty);
                }
                else if (edmStructuralProperty.Type.IsCollection())
                {
                    if (edmStructuralProperty.Type.AsCollection().ElementType().IsComplex())
                    {
                        nestedStructuralProperties.Add(edmStructuralProperty);
                    }
                    else
                    {
                        structuralProperties.Add(edmStructuralProperty);
                    }
                }
                else
                {
                    structuralProperties.Add(edmStructuralProperty);
                }
            }
        }

        /// <summary>
        /// An internal cache class used to provide the propert, operations
        /// and do verification on the given <see cref="IEdmStructuredType"/>.
        /// </summary>
        internal class EdmStructuralTypeInfo
        {
            /// <summary>
            /// Gets all structural properties defined on the structure type.
            /// </summary>
            public ISet<IEdmStructuralProperty> AllStructuralProperties { get; }

            /// <summary>
            /// Gets all navigation properties defined on the structure type.
            /// </summary>
            public ISet<IEdmNavigationProperty> AllNavigationProperties { get; }

            /// <summary>
            /// Gets all actions bonding to the structure type.
            /// </summary>
            public ISet<IEdmAction> AllActions { get; }

            /// <summary>
            /// Gets all function bonding to the structure type.
            /// </summary>
            public ISet<IEdmFunction> AllFunctions { get; }

            /// <summary>
            /// Creates a new instance of the <see cref="EdmStructuralTypeInfo"/> class
            /// </summary>
            /// <param name="model">The Edm model.</param>
            /// <param name="structuredType">The Edm structured Type.</param>
            public EdmStructuralTypeInfo(IEdmModel model, IEdmStructuredType structuredType)
            {
                Contract.Assert(model != null);
                Contract.Assert(structuredType != null);

                foreach (var edmProperty in structuredType.Properties())
                {
                    switch (edmProperty.PropertyKind)
                    {
                        case EdmPropertyKind.Structural:
                            if (AllStructuralProperties == null)
                            {
                                AllStructuralProperties = new HashSet<IEdmStructuralProperty>();
                            }

                            AllStructuralProperties.Add((IEdmStructuralProperty)edmProperty);
                            break;

                        case EdmPropertyKind.Navigation:
                            if (AllNavigationProperties == null)
                            {
                                AllNavigationProperties = new HashSet<IEdmNavigationProperty>();
                            }

                            AllNavigationProperties.Add((IEdmNavigationProperty)edmProperty);
                            break;
                    }
                }

                IEdmEntityType entityType = structuredType as IEdmEntityType;
                if (entityType != null)
                {
                    var actions = model.GetAvailableActions(entityType);
                    AllActions = actions.Any() ? new HashSet<IEdmAction>(actions) : null;

                    var functions = model.GetAvailableFunctions(entityType);
                    AllFunctions = functions.Any() ? new HashSet<IEdmFunction>(functions) : null;
                }
            }

            /// <summary>
            /// Tests whether a <see cref="IEdmStructuralProperty"/> is defined on this type.
            /// </summary>
            /// <param name="property">The test property.</param>
            /// <returns>True/false</returns>
            public bool IsStructuralPropertyDefined(IEdmStructuralProperty property)
            {
                return AllStructuralProperties != null && AllStructuralProperties.Contains(property);
            }

            /// <summary>
            /// Tests whether a <see cref="IEdmNavigationProperty"/> is defined on this type.
            /// </summary>
            /// <param name="property">The test property.</param>
            /// <returns>True/false</returns>
            public bool IsNavigationPropertyDefined(IEdmNavigationProperty property)
            {
                return AllNavigationProperties != null && AllNavigationProperties.Contains(property);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\SelectExpandNode.cs(360,68): error CS0165: Use of unassigned local variable 'firstNavigationSegment'
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandBinder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Query.Expressions
{
    /// <summary>
    /// Applies the given <see cref="SelectExpandQueryOption"/> to the given <see cref="IQueryable"/>.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable.")]
    internal class SelectExpandBinder
    {
        private ODataQueryContext _context;
        private IEdmModel _model;
        private ODataQuerySettings _settings;
        private string _modelID;
        private DataSourceProviderKind _dataSourceProviderKind;

        public SelectExpandBinder(ODataQuerySettings settings, ODataQueryContext context)
        {
            Contract.Assert(settings != null);
            Contract.Assert(context != null);
            Contract.Assert(context.Model != null);
            Contract.Assert(settings.HandleNullPropagation != HandleNullPropagationOption.Default);

            _context = context;
            _model = _context.Model;
            _modelID = ModelContainer.GetModelID(_model);
            _settings = settings;
            _dataSourceProviderKind = DataSourceProviderKind.Unknown;
        }

        public static IQueryable Bind(IQueryable queryable, ODataQuerySettings settings, SelectExpandQueryOption selectExpandQuery)
        {
            Contract.Assert(queryable != null);
            Contract.Assert(selectExpandQuery != null);

            SelectExpandBinder binder = new SelectExpandBinder(settings, selectExpandQuery.Context);
            return binder.Bind(queryable, selectExpandQuery);
        }

        public static object Bind(object entity, ODataQuerySettings settings, SelectExpandQueryOption selectExpandQuery)
        {
            Contract.Assert(entity != null);
            Contract.Assert(selectExpandQuery != null);

            SelectExpandBinder binder = new SelectExpandBinder(settings, selectExpandQuery.Context);
            return binder.Bind(entity, selectExpandQuery);
        }

        private object Bind(object entity, SelectExpandQueryOption selectExpandQuery)
        {
            _dataSourceProviderKind = DataSourceProviderKind.InMemory;

            // Needn't to verify the input, that's done at upper level.
            LambdaExpression projectionLambda = GetProjectionLambda(selectExpandQuery);

            // TODO: cache this ?
            return projectionLambda.Compile().DynamicInvoke(entity);
        }

        private IQueryable Bind(IQueryable queryable, SelectExpandQueryOption selectExpandQuery)
        {
            _dataSourceProviderKind = queryable.GetDataSourceProviderKind();

            // Needn't to verify the input, that's done at upper level.
            Type elementType = selectExpandQuery.Context.ElementClrType;

            LambdaExpression projectionLambda = GetProjectionLambda(selectExpandQuery);

            MethodInfo selectMethod = ExpressionHelperMethods.QueryableSelectGeneric.MakeGenericMethod(elementType, projectionLambda.Body.Type);
            return selectMethod.Invoke(null, new object[] { queryable, projectionLambda }) as IQueryable;
        }

        private LambdaExpression GetProjectionLambda(SelectExpandQueryOption selectExpandQuery)
        {
            Type elementType = selectExpandQuery.Context.ElementClrType;
            IEdmNavigationSource navigationSource = selectExpandQuery.Context.NavigationSource;
            ParameterExpression source = Expression.Parameter(elementType, "$it");

            // expression looks like -> new Wrapper { Instance = source , Properties = "...", Container = new PropertyContainer { ... } }
            Expression projectionExpression = ProjectElement(source, selectExpandQuery.SelectExpandClause, _context.ElementType as IEdmStructuredType, navigationSource);

            // expression looks like -> source => new Wrapper { Instance = source .... }
            LambdaExpression projectionLambdaExpression = Expression.Lambda(projectionExpression, source);

            return projectionLambdaExpression;
        }

        internal Expression ProjectAsWrapper(Expression source, SelectExpandClause selectExpandClause,
            IEdmStructuredType structuredType, IEdmNavigationSource navigationSource, OrderByClause orderByClause = null,
            long? topOption = null,
            long? skipOption = null,
            int? modelBoundPageSize = null)
        {
            Type elementType;
            if (TypeHelper.IsCollection(source.Type, out elementType))
            {
                // new CollectionWrapper<ElementType> { Instance = source.Select(s => new Wrapper { ... }) };
                return ProjectCollection(source, elementType, selectExpandClause, structuredType, navigationSource, orderByClause,
                    topOption,
                    skipOption,
                    modelBoundPageSize);
            }
            else
            {
                // new Wrapper { v1 = source.property ... }
                return ProjectElement(source, selectExpandClause, structuredType, navigationSource);
            }
        }

        internal Expression CreatePropertyNameExpression(IEdmStructuredType elementType, IEdmProperty property, Expression source)
        {
            Contract.Assert(elementType != null);
            Contract.Assert(property != null);
            Contract.Assert(source != null);

            IEdmStructuredType declaringType = property.DeclaringType;

            // derived property using cast
            if (elementType != declaringType)
            {
                Type originalType = EdmLibHelpers.GetClrType(elementType, _model);
                Type castType = EdmLibHelpers.GetClrType(declaringType, _model);
                if (castType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, declaringType.FullTypeName()));
                }

                if (!castType.IsAssignableFrom(originalType))
                {
                    // Expression
                    //          source is navigationPropertyDeclaringType ? propertyName : null
                    return Expression.Condition(
                        test: Expression.TypeIs(source, castType),
                        ifTrue: Expression.Constant(property.Name),
                        ifFalse: Expression.Constant(null, typeof(string)));
                }
            }

            // Expression
            //          "propertyName"
            return Expression.Constant(property.Name);
        }

        internal Expression CreatePropertyValueExpression(IEdmStructuredType elementType, IEdmProperty property, Expression source, FilterClause filterClause)
        {
            Contract.Assert(elementType != null);
            Contract.Assert(property != null);
            Contract.Assert(source != null);

            // Expression: source = source as propertyDeclaringType
            if (elementType != property.DeclaringType)
            {
                Type castType = EdmLibHelpers.GetClrType(property.DeclaringType, _model);
                if (castType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, property.DeclaringType.FullTypeName()));
                }

                source = Expression.TypeAs(source, castType);
            }

            // Expression:  source.Property
            string propertyName = EdmLibHelpers.GetClrPropertyName(property, _model);
            PropertyInfo propertyInfo = source.Type.GetProperty(propertyName);
            Expression propertyValue = Expression.Property(source, propertyInfo);
            Type nullablePropertyType = TypeHelper.ToNullable(propertyValue.Type);
            Expression nullablePropertyValue = ExpressionHelpers.ToNullable(propertyValue);

            if (filterClause != null)
            {
                bool isCollection = property.Type.IsCollection();

                IEdmTypeReference edmElementType = (isCollection ? property.Type.AsCollection().ElementType() : property.Type);
                Type clrElementType = EdmLibHelpers.GetClrType(edmElementType, _model);
                if (clrElementType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, edmElementType.FullName()));
                }

                Expression filterResult = nullablePropertyValue;

                ODataQuerySettings querySettings = new ODataQuerySettings()
                {
                    HandleNullPropagation = HandleNullPropagationOption.True,
                };

                if (isCollection)
                {
                    Expression filterSource = nullablePropertyValue;

                    // TODO: Implement proper support for $select/$expand after $apply
                    Expression filterPredicate = FilterBinder.Bind(null, filterClause, clrElementType, _context, querySettings);
                    filterResult = Expression.Call(
                        ExpressionHelperMethods.EnumerableWhereGeneric.MakeGenericMethod(clrElementType),
                        filterSource,
                        filterPredicate);

                    nullablePropertyType = filterResult.Type;
                }
                else if (_settings.HandleReferenceNavigationPropertyExpandFilter)
                {
                    LambdaExpression filterLambdaExpression = FilterBinder.Bind(null, filterClause, clrElementType, _context, querySettings) as LambdaExpression;
                    if (filterLambdaExpression == null)
                    {
                        throw new ODataException(Error.Format(SRResources.ExpandFilterExpressionNotLambdaExpression, property.Name, "LambdaExpression"));
                    }

                    ParameterExpression filterParameter = filterLambdaExpression.Parameters.First();
                    Expression predicateExpression = new ReferenceNavigationPropertyExpandFilterVisitor(filterParameter, nullablePropertyValue).Visit(filterLambdaExpression.Body);

                    // create expression similar to: 'predicateExpression == true ? nullablePropertyValue : null'
                    filterResult = Expression.Condition(
                        test: predicateExpression,
                        ifTrue: nullablePropertyValue,
                        ifFalse: Expression.Constant(value: null, type: nullablePropertyType));
                }

                if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // create expression similar to: 'nullablePropertyValue == null ? null : filterResult'
                    nullablePropertyValue = Expression.Condition(
                        test: Expression.Equal(nullablePropertyValue, Expression.Constant(value: null)),
                        ifTrue: Expression.Constant(value: null, type: nullablePropertyType),
                        ifFalse: filterResult);
                }
                else
                {
                    nullablePropertyValue = filterResult;
                }
            }

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // create expression similar to: 'source == null ? null : propertyValue'
                propertyValue = Expression.Condition(
                    test: Expression.Equal(source, Expression.Constant(value: null)),
                    ifTrue: Expression.Constant(value: null, type: nullablePropertyType),
                    ifFalse: nullablePropertyValue);
            }
            else
            {
                // need to cast this to nullable as EF would fail while materializing if the property is not nullable and source is null.
                propertyValue = nullablePropertyValue;
            }

            return propertyValue;
        }

        // Generates the expression
        //      source => new Wrapper { Instance = source, Container = new PropertyContainer { ..expanded properties.. } }
        internal Expression ProjectElement(Expression source, SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource)
        {
            Contract.Assert(source != null);

            // If it's not a structural type, just return the source.
            if (structuredType == null)
            {
                return source;
            }

            Type elementType = source.Type;
            Type wrapperType = typeof(SelectExpandWrapper<>).MakeGenericType(elementType);
            List<MemberAssignment> wrapperTypeMemberAssignments = new List<MemberAssignment>();

            PropertyInfo wrapperProperty;
            Expression wrapperPropertyValueExpression;
            bool isInstancePropertySet = false;
            bool isTypeNamePropertySet = false;
            bool isContainerPropertySet = false;

            // Initialize property 'ModelID' on the wrapper class.
            // source = new Wrapper { ModelID = 'some-guid-id' }
            wrapperProperty = wrapperType.GetProperty("ModelID");
            wrapperPropertyValueExpression = _settings.EnableConstantParameterization ?
                LinqParameterContainer.Parameterize(typeof(string), _modelID) :
                Expression.Constant(_modelID);
            wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, wrapperPropertyValueExpression));

            if (IsSelectAll(selectExpandClause))
            {
                // Initialize property 'Instance' on the wrapper class
                wrapperProperty = wrapperType.GetProperty("Instance");
                wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, source));

                wrapperProperty = wrapperType.GetProperty("UseInstanceForProperties");
                wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, Expression.Constant(true)));
                isInstancePropertySet = true;
            }
            else
            {
                // Initialize property 'TypeName' on the wrapper class as we don't have the instance.
                Expression typeName = CreateTypeNameExpression(source, structuredType, _model);
                if (typeName != null)
                {
                    isTypeNamePropertySet = true;
                    wrapperProperty = wrapperType.GetProperty("InstanceType");
                    wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, typeName));
                }
            }

            // Initialize the property 'Container' on the wrapper class
            // source => new Wrapper { Container =  new PropertyContainer { .... } }
            if (selectExpandClause != null)
            {
                IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude;
                IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand;
                ISet<IEdmStructuralProperty> autoSelectedProperties;

                bool isContainDynamicPropertySelection = GetSelectExpandProperties(_model, structuredType, navigationSource, selectExpandClause,
                    out propertiesToInclude,
                    out propertiesToExpand,
                    out autoSelectedProperties);

                bool isSelectingOpenTypeSegments = isContainDynamicPropertySelection || IsSelectAllOnOpenType(selectExpandClause, structuredType);

                if (propertiesToExpand != null || propertiesToInclude != null || autoSelectedProperties != null || isSelectingOpenTypeSegments)
                {
                    Expression propertyContainerCreation =
                        BuildPropertyContainer(source, structuredType, propertiesToExpand, propertiesToInclude, autoSelectedProperties, isSelectingOpenTypeSegments);

                    if (propertyContainerCreation != null)
                    {
                        wrapperProperty = wrapperType.GetProperty("Container");
                        Contract.Assert(wrapperProperty != null);

                        wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, propertyContainerCreation));
                        isContainerPropertySet = true;
                    }
                }
            }

            Type wrapperGenericType = GetWrapperGenericType(isInstancePropertySet, isTypeNamePropertySet, isContainerPropertySet);
            wrapperType = wrapperGenericType.MakeGenericType(elementType);
            return Expression.MemberInit(Expression.New(wrapperType), wrapperTypeMemberAssignments);
        }

        /// <summary>
        /// Gets the $select and $expand properties from the given <see cref="SelectExpandClause"/>
        /// </summary>
        /// <param name="model">The Edm model.</param>
        /// <param name="structuredType">The current structural type.</param>
        /// <param name="navigationSource">The current navigation source.</param>
        /// <param name="selectExpandClause">The given select and expand clause.</param>
        /// <param name="propertiesToInclude">The out properties to include at current level, could be null.</param>
        /// <param name="propertiesToExpand">The out properties to expand at current level, could be null.</param>
        /// <param name="autoSelectedProperties">The out auto selected properties to include at current level, could be null.</param>
        /// <returns>true if the select contains dynamic property selection, false if it's not.</returns>
        internal static bool GetSelectExpandProperties(IEdmModel model, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource,
            SelectExpandClause selectExpandClause,
            out IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude,
            out IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand,
            out ISet<IEdmStructuralProperty> autoSelectedProperties)
        {
            Contract.Assert(selectExpandClause != null);

            // Properties to be included includes all the properties selected or in the middle of a $select and $expand path.
            // for example: "$expand=abc/xyz/nav", "abc" and "xyz" are the middle properties that should be included.
            // meanwhile, "nav" is the property that should be expanded.
            // If it's a type cast path, for example: $select=NS.TypeCast/abc, "abc" should be included also.
            propertiesToInclude = null;
            propertiesToExpand = null;
            autoSelectedProperties = null;

            bool isSelectContainsDynamicProperty = false;
            var currentLevelPropertiesInclude = new Dictionary<IEdmStructuralProperty, SelectExpandIncludedProperty>();
            foreach (SelectItem selectItem in selectExpandClause.SelectedItems)
            {
                // $expand=...
                ExpandedReferenceSelectItem expandedItem = selectItem as ExpandedReferenceSelectItem;
                if (expandedItem != null)
                {
                    ProcessExpandedItem(expandedItem, navigationSource, currentLevelPropertiesInclude, ref propertiesToExpand);
                    continue;
                }

                // $select=...
                PathSelectItem pathItem = selectItem as PathSelectItem;
                if (pathItem != null)
                {
                    if (ProcessSelectedItem(pathItem, navigationSource, currentLevelPropertiesInclude))
                    {
                        isSelectContainsDynamicProperty = true;
                    }
                    continue;
                }

                // Skip processing the "WildcardSelectItem and NamespaceQualifiedWildcardSelectItem"
                // ODL now doesn't support "$select=property/*" and "$select=property/NS.*"
            }

            if (!IsSelectAll(selectExpandClause))
            {
                // We should include the keys if it's an entity.
                IEdmEntityType entityType = structuredType as IEdmEntityType;
                if (entityType != null)
                {
                    foreach (IEdmStructuralProperty keyProperty in entityType.Key())
                    {
                        if (!currentLevelPropertiesInclude.Keys.Contains(keyProperty))
                        {
                            if (autoSelectedProperties == null)
                            {
                                autoSelectedProperties = new HashSet<IEdmStructuralProperty>();
                            }

                            autoSelectedProperties.Add(keyProperty);
                        }
                    }
                }

                // We should add concurrency properties, if not added
                if (navigationSource != null && model != null)
                {
                    IEnumerable<IEdmStructuralProperty> concurrencyProperties = model.GetConcurrencyProperties(navigationSource);
                    foreach (IEdmStructuralProperty concurrencyProperty in concurrencyProperties)
                    {
                        if (structuredType.Properties().Any(p => p == concurrencyProperty))
                        {
                            if (!currentLevelPropertiesInclude.Keys.Contains(concurrencyProperty))
                            {
                                if (autoSelectedProperties == null)
                                {
                                    autoSelectedProperties = new HashSet<IEdmStructuralProperty>();
                                }

                                autoSelectedProperties.Add(concurrencyProperty);
                            }
                        }
                    }
                }
            }

            if (currentLevelPropertiesInclude.Any())
            {
                propertiesToInclude = new Dictionary<IEdmStructuralProperty, PathSelectItem>();
                foreach (var propertiesInclude in currentLevelPropertiesInclude)
                {
                    propertiesToInclude[propertiesInclude.Key] = propertiesInclude.Value == null ? null : propertiesInclude.Value.ToPathSelectItem();
                }
            }

            return isSelectContainsDynamicProperty;
        }

        /// <summary>
        /// Process the <see cref="ExpandedReferenceSelectItem"/>.
        /// </summary>
        /// <param name="expandedItem">The expaned item.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="currentLevelPropertiesInclude">The current level properties included.</param>
        /// <param name="propertiesToExpand">out/ref, the property expanded.</param>
        private static void ProcessExpandedItem(ExpandedReferenceSelectItem expandedItem,
            IEdmNavigationSource navigationSource,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            ref IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand)
        {
            Contract.Assert(expandedItem?.PathToNavigationProperty != null);
            Contract.Assert(currentLevelPropertiesInclude != null);

            // Verify and process the $expand=... path.
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment firstNonTypeSegment = expandedItem.PathToNavigationProperty.GetFirstNonTypeCastSegment(out remainingSegments);

            // for $expand=NS.SubType/Nav, we don't care about the leading type segment, because with or without the type segment
            // the "nav" property value expression should be built into the property container.

            PropertySegment firstStructuralPropertySegment = firstNonTypeSegment as PropertySegment;
            if (firstStructuralPropertySegment != null)
            {
                // for example: $expand=abc/nav, the remaining segments should never be null because at least the last navigation segment is there.
                Contract.Assert(remainingSegments != null);

                SelectExpandIncludedProperty newPropertySelectItem;
                if (!currentLevelPropertiesInclude.TryGetValue(firstStructuralPropertySegment.Property, out newPropertySelectItem))
                {
                    newPropertySelectItem = new SelectExpandIncludedProperty(firstStructuralPropertySegment, navigationSource);
                    currentLevelPropertiesInclude[firstStructuralPropertySegment.Property] = newPropertySelectItem;
                }

                newPropertySelectItem.AddSubExpandItem(remainingSegments, expandedItem);
            }
            else
            {
                // for example: $expand=nav, if we couldn't find a structural property in the path, it means we get the last navigation segment.
                // So, the remaing segments should be null and the last segment should be "NavigationPropertySegment".
                Contract.Assert(remainingSegments == null);

                NavigationPropertySegment firstNavigationPropertySegment = firstNonTypeSegment as NavigationPropertySegment;
                Contract.Assert(firstNavigationPropertySegment != null);

                // Needn't add this navigation property into the include property.
                // Because this navigation property will be included separately.
                if (propertiesToExpand == null)
                {
                    propertiesToExpand = new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();
                }

                propertiesToExpand[firstNavigationPropertySegment.NavigationProperty] = expandedItem;
            }
        }

        /// <summary>
        /// Process the <see cref="PathSelectItem"/>.
        /// </summary>
        /// <param name="pathSelectItem">The selected item.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="currentLevelPropertiesInclude">The current level properties included.</param>
        /// <returns>true if it's dynamic property selection, false if it's not.</returns>
        private static bool ProcessSelectedItem(PathSelectItem pathSelectItem,
            IEdmNavigationSource navigationSource,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude)
        {
            Contract.Assert(pathSelectItem?.SelectedPath != null);
            Contract.Assert(currentLevelPropertiesInclude != null);

            // Verify and process the $select path
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment firstNonTypeSegment = pathSelectItem.SelectedPath.GetFirstNonTypeCastSegment(out remainingSegments);

            // for $select=NS.SubType/Property, we don't care about the leading type segment, because with or without the type segment
            // the "Property" property value expression should be built into the property container.

            PropertySegment firstSturucturalPropertySegment = firstNonTypeSegment as PropertySegment;
            if (firstSturucturalPropertySegment != null)
            {
                // $select=abc/..../xyz
                SelectExpandIncludedProperty newPropertySelectItem;
                if (!currentLevelPropertiesInclude.TryGetValue(firstSturucturalPropertySegment.Property, out newPropertySelectItem))
                {
                    newPropertySelectItem = new SelectExpandIncludedProperty(firstSturucturalPropertySegment, navigationSource);
                    currentLevelPropertiesInclude[firstSturucturalPropertySegment.Property] = newPropertySelectItem;
                }

                newPropertySelectItem.AddSubSelectItem(remainingSegments, pathSelectItem);
            }
            else
            {
                // If we can't find a PropertySegment, the $select path maybe selecting an operation, a navigation or dynamic property.
                // And the remaing segments should be null.
                Contract.Assert(remainingSegments == null);

                // For operation (action/function), needn't process it.
                // For navigation property, needn't process it here.

                // For dynamic property, let's test the last segment for this path select item.
                if (firstNonTypeSegment is DynamicPathSegment)
                {
                    return true;
                }
            }

            return false;
        }

        // To test whether the currect selection is SelectAll on an open type
        private static bool IsSelectAllOnOpenType(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType)
        {
            if (structuredType == null || !structuredType.IsOpen)
            {
                return false;
            }

            if (IsSelectAll(selectExpandClause))
            {
                return true;
            }

            return false;
        }

        private Expression CreateTotalCountExpression(Expression source, bool? countOption)
        {
            Expression countExpression = Expression.Constant(null, typeof(long?));
            if (countOption == null || !countOption.Value)
            {
                return countExpression;
            }

            Type elementType;
            if (!TypeHelper.IsCollection(source.Type, out elementType))
            {
                return countExpression;
            }

            MethodInfo countMethod;
            if (typeof(IQueryable).IsAssignableFrom(source.Type))
            {
                countMethod = ExpressionHelperMethods.QueryableCountGeneric.MakeGenericMethod(elementType);
            }
            else
            {
                countMethod = ExpressionHelperMethods.EnumerableCountGeneric.MakeGenericMethod(elementType);
            }

            // call Count() method.
            countExpression = Expression.Call(null, countMethod, new[] { source });

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // source == null ? null : countExpression
                return Expression.Condition(
                       test: Expression.Equal(source, Expression.Constant(null)),
                       ifTrue: Expression.Constant(null, typeof(long?)),
                       ifFalse: ExpressionHelpers.ToNullable(countExpression));
            }
            else
            {
                return countExpression;
            }
        }

        private Expression BuildPropertyContainer(Expression source, IEdmStructuredType structuredType,
            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand,
            IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude,
            ISet<IEdmStructuralProperty> autoSelectedProperties,
            bool isSelectingOpenTypeSegments)
        {
            IList<NamedPropertyExpression> includedProperties = new List<NamedPropertyExpression>();

            if (propertiesToExpand != null)
            {
                foreach (var propertyToExpand in propertiesToExpand)
                {
                    // $expand=abc or $expand=abc/$ref
                    BuildExpandedProperty(source, structuredType, propertyToExpand.Key, propertyToExpand.Value, includedProperties);
                }
            }

            if (propertiesToInclude != null)
            {
                foreach (var propertyToInclude in propertiesToInclude)
                {
                    // $select=abc($select=...,$filter=...,$compute=...)....
                    BuildSelectedProperty(source, structuredType, propertyToInclude.Key, propertyToInclude.Value, includedProperties);
                }
            }

            if (autoSelectedProperties != null)
            {
                foreach (IEdmStructuralProperty propertyToInclude in autoSelectedProperties)
                {
                    Expression propertyName = CreatePropertyNameExpression(structuredType, propertyToInclude, source);
                    Expression propertyValue = CreatePropertyValueExpression(structuredType, propertyToInclude, source, filterClause: null);
                    includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue)
                    {
                        AutoSelected = true
                    });
                }
            }

            if (isSelectingOpenTypeSegments)
            {
                BuildDynamicProperty(source, structuredType, includedProperties);
            }

            // create a property container that holds all these property names and values.
            return PropertyContainer.CreatePropertyContainer(includedProperties);
        }

        /// <summary>
        /// Build the navigation property <see cref="IEdmNavigationProperty"/> into the included properties.
        /// The property name is the navigation property name.
        /// The property value is the navigation property value from the source and applied the nested query options.
        /// </summary>
        /// <param name="source">The source contains the navigation property.</param>
        /// <param name="structuredType">The structured type or its derived type contains the navigation property.</param>
        /// <param name="navigationProperty">The expanded navigation property.</param>
        /// <param name="expandedItem">The expanded navigation select item. It may contain the neste query options.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildExpandedProperty(Expression source, IEdmStructuredType structuredType,
            IEdmNavigationProperty navigationProperty, ExpandedReferenceSelectItem expandedItem,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(navigationProperty != null);
            Contract.Assert(expandedItem != null);
            Contract.Assert(includedProperties != null);

            IEdmEntityType edmEntityType = navigationProperty.ToEntityType();

            ModelBoundQuerySettings querySettings = EdmLibHelpers.GetModelBoundQuerySettings(navigationProperty, edmEntityType, _model);

            // TODO: Process $apply and $compute in the $expand here, will support later.
            // $apply=...; $compute=...

            // Expression:
            //       "navigation property name"
            Expression propertyName = CreatePropertyNameExpression(structuredType, navigationProperty, source);

            // Expression:
            //        source.NavigationProperty
            Expression propertyValue = CreatePropertyValueExpression(structuredType, navigationProperty, source, expandedItem.FilterOption);

            // Sub select and expand could be null if the expanded navigation property is not further projected or expanded.
            SelectExpandClause subSelectExpandClause = GetOrCreateSelectExpandClause(navigationProperty, expandedItem);

            Expression nullCheck = GetNullCheckExpression(navigationProperty, propertyValue, subSelectExpandClause);

            Expression countExpression = CreateTotalCountExpression(propertyValue, expandedItem.CountOption);

            int? modelBoundPageSize = querySettings == null ? null : querySettings.PageSize;
            propertyValue = ProjectAsWrapper(propertyValue, subSelectExpandClause, edmEntityType, expandedItem.NavigationSource,
                expandedItem.OrderByOption, // $orderby=...
                expandedItem.TopOption, // $top=...
                expandedItem.SkipOption, // $skip=...
                modelBoundPageSize);

            NamedPropertyExpression propertyExpression = new NamedPropertyExpression(propertyName, propertyValue);
            if (subSelectExpandClause != null)
            {
                if (!navigationProperty.Type.IsCollection())
                {
                    propertyExpression.NullCheck = nullCheck;
                }
                else if (_settings.PageSize.HasValue)
                {
                    propertyExpression.PageSize = _settings.PageSize.Value;
                }
                else
                {
                    if (querySettings != null && querySettings.PageSize.HasValue)
                    {
                        propertyExpression.PageSize = querySettings.PageSize.Value;
                    }
                }

                propertyExpression.TotalCount = countExpression;
                propertyExpression.CountOption = expandedItem.CountOption;
            }

            includedProperties.Add(propertyExpression);
        }

        /// <summary>
        /// Build the structural property <see cref="IEdmStructuralProperty"/> into the included properties.
        /// The property name is the structural property name.
        /// The property value is the structural property value from the source and applied the nested query options.
        /// </summary>
        /// <param name="source">The source contains the structural property.</param>
        /// <param name="structuredType">The structured type or its derived type contains the structural property.</param>
        /// <param name="structuralProperty">The selected structural property.</param>
        /// <param name="pathSelectItem">The selected item. It may contain the neste query options and could be null.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildSelectedProperty(Expression source, IEdmStructuredType structuredType,
            IEdmStructuralProperty structuralProperty, PathSelectItem pathSelectItem,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(structuralProperty != null);
            Contract.Assert(includedProperties != null);

            // // Expression:
            //       "navigation property name"
            Expression propertyName = CreatePropertyNameExpression(structuredType, structuralProperty, source);

            // Expression:
            //        source.NavigationProperty
            Expression propertyValue;
            if (pathSelectItem == null)
            {
                propertyValue = CreatePropertyValueExpression(structuredType, structuralProperty, source, filterClause: null);
                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
                return;
            }

            SelectExpandClause subSelectExpandClause = pathSelectItem.SelectAndExpand;

            // TODO: Process $compute in the $select ahead.
            // $compute=...

            propertyValue = CreatePropertyValueExpression(structuredType, structuralProperty, source, pathSelectItem.FilterOption);
            Type propertyValueType = propertyValue.Type;
            if (propertyValueType == typeof(char[]) || propertyValueType == typeof(byte[]))
            {
                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
                return;
            }

            // EF5 and EF6 don't support comparing complex objects to null, and will throw an exception similar to following if it is
            // attempted:
            //    "Cannot compare elements of type 'xxxx'. Only primitive types, enumeration types and entity types are supported."
            // EFCore has changed its implementation so the null check executes as expected.
            Expression nullCheck = null;
            if (_dataSourceProviderKind != DataSourceProviderKind.EFClassic)
            {
                nullCheck = GetNullCheckExpression(structuralProperty, propertyValue, subSelectExpandClause);
            }

            Expression countExpression = CreateTotalCountExpression(propertyValue, pathSelectItem.CountOption);

            // be noted: the property structured type could be null, because the property maybe not a complex property.
            IEdmStructuredType propertyStructuredType = structuralProperty.Type.ToStructuredType();
            ModelBoundQuerySettings querySettings = null;
            if (propertyStructuredType != null)
            {
                querySettings = EdmLibHelpers.GetModelBoundQuerySettings(structuralProperty, propertyStructuredType, _context.Model);
            }

            int? modelBoundPageSize = querySettings == null ? null : querySettings.PageSize;
            propertyValue = ProjectAsWrapper(propertyValue, subSelectExpandClause, structuralProperty.Type.ToStructuredType(), pathSelectItem.NavigationSource,
                pathSelectItem.OrderByOption, // $orderby=...
                pathSelectItem.TopOption, // $top=...
                pathSelectItem.SkipOption, // $skip=...
                modelBoundPageSize);

            NamedPropertyExpression propertyExpression = new NamedPropertyExpression(propertyName, propertyValue);
            if (subSelectExpandClause != null)
            {
                if (!structuralProperty.Type.IsCollection())
                {
                    propertyExpression.NullCheck = nullCheck;
                }
                else if (_settings.PageSize.HasValue)
                {
                    propertyExpression.PageSize = _settings.PageSize.Value;
                }
                else
                {
                    if (querySettings != null && querySettings.PageSize.HasValue)
                    {
                        propertyExpression.PageSize = querySettings.PageSize.Value;
                    }
                }

                propertyExpression.TotalCount = countExpression;
                propertyExpression.CountOption = pathSelectItem.CountOption;
            }

            includedProperties.Add(propertyExpression);
        }

        /// <summary>
        /// Build the dynamic properties into the included properties.
        /// </summary>
        /// <param name="source">The source contains the dynamic property.</param>
        /// <param name="structuredType">The structured type contains the dynamic property.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildDynamicProperty(Expression source, IEdmStructuredType structuredType,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(includedProperties != null);

            PropertyInfo dynamicPropertyDictionary = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType, _model);
            if (dynamicPropertyDictionary != null)
            {
                Expression propertyName = Expression.Constant(dynamicPropertyDictionary.Name);
                Expression propertyValue = Expression.Property(source, dynamicPropertyDictionary.Name);
                Expression nullablePropertyValue = ExpressionHelpers.ToNullable(propertyValue);
                if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // source == null ? null : propertyValue
                    propertyValue = Expression.Condition(
                        test: Expression.Equal(source, Expression.Constant(value: null)),
                        ifTrue: Expression.Constant(value: null, type: TypeHelper.ToNullable(propertyValue.Type)),
                        ifFalse: nullablePropertyValue);
                }
                else
                {
                    propertyValue = nullablePropertyValue;
                }

                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
            }
        }

        private static SelectExpandClause GetOrCreateSelectExpandClause(IEdmNavigationProperty navigationProperty, ExpandedReferenceSelectItem expandedItem)
        {
            // for normal $expand=....
            ExpandedNavigationSelectItem expandNavigationSelectItem = expandedItem as ExpandedNavigationSelectItem;
            if (expandNavigationSelectItem != null)
            {
                return expandNavigationSelectItem.SelectAndExpand;
            }

            // for $expand=..../$ref, just includes the keys properties
            IList<SelectItem> selectItems = new List<SelectItem>();
            foreach (IEdmStructuralProperty keyProperty in navigationProperty.ToEntityType().Key())
            {
                selectItems.Add(new PathSelectItem(new ODataSelectPath(new PropertySegment(keyProperty))));
            }

            return new SelectExpandClause(selectItems, false);
        }

        private Expression AddOrderByQueryForSource(Expression source, OrderByClause orderbyClause, Type elementType)
        {
            if (orderbyClause != null)
            {
                // TODO: Implement proper support for $select/$expand after $apply
                ODataQuerySettings querySettings = new ODataQuerySettings()
                {
                    HandleNullPropagation = HandleNullPropagationOption.True,
                };

                LambdaExpression orderByExpression =
                    FilterBinder.Bind(null, orderbyClause, elementType, _context, querySettings);
                source = ExpressionHelpers.OrderBy(source, orderByExpression, elementType, orderbyClause.Direction);
            }

            return source;
        }

        private static Expression GetNullCheckExpression(IEdmStructuralProperty propertyToInclude, Expression propertyValue,
            SelectExpandClause projection)
        {
            if (projection == null || propertyToInclude.Type.IsCollection())
            {
                return null;
            }

            if (IsSelectAll(projection) && propertyToInclude.Type.IsComplex())
            {
                // for Collections (Primitive, Enum, Complex collection), that's check above.	
                return Expression.Equal(propertyValue, Expression.Constant(null));
            }

            return null;
        }

        private Expression GetNullCheckExpression(IEdmNavigationProperty propertyToExpand, Expression propertyValue,
            SelectExpandClause projection)
        {
            if (projection == null || propertyToExpand.Type.IsCollection())
            {
                return null;
            }

            if (IsSelectAll(projection) || !propertyToExpand.ToEntityType().Key().Any())
            {
                return Expression.Equal(propertyValue, Expression.Constant(null));
            }

            Expression keysNullCheckExpression = null;
            foreach (var key in propertyToExpand.ToEntityType().Key())
            {
                var propertyValueExpression = CreatePropertyValueExpression(propertyToExpand.ToEntityType(), key, propertyValue, filterClause: null);
                var keyExpression = Expression.Equal(
                    propertyValueExpression,
                    Expression.Constant(null, propertyValueExpression.Type));

                keysNullCheckExpression = keysNullCheckExpression == null
                    ? keyExpression
                    : Expression.And(keysNullCheckExpression, keyExpression);
            }

            return keysNullCheckExpression;
        }

        // new CollectionWrapper<ElementType> { Instance = source.Select((ElementType element) => new Wrapper { }) }
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        private Expression ProjectCollection(Expression source, Type elementType,
            SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource,
            OrderByClause orderByClause,
            long? topOption,
            long? skipOption,
            int? modelBoundPageSize)
        {
            // structuralType could be null, because it can be primitive collection.

            ParameterExpression element = Expression.Parameter(elementType, "$it");

            Expression projection;
            // expression
            //      new Wrapper { }
            if (structuredType != null)
            {
                projection = ProjectElement(element, selectExpandClause, structuredType, navigationSource);
            }
            else
            {
                projection = element;
            }

            // expression
            //      (ElementType element) => new Wrapper { }
            LambdaExpression selector = Expression.Lambda(projection, element);

            if (orderByClause != null)
            {
                source = AddOrderByQueryForSource(source, orderByClause, elementType);
            }

            bool hasTopValue = topOption != null && topOption.HasValue;
            bool hasSkipvalue = skipOption != null && skipOption.HasValue;

            IEdmEntityType entityType = structuredType as IEdmEntityType;
            if (entityType != null)
            {
                if (_settings.PageSize.HasValue || modelBoundPageSize.HasValue || hasTopValue || hasSkipvalue)
                {
                    // nested paging. Need to apply order by first, and take one more than page size as we need to know
                    // whether the collection was truncated or not while generating next page links.
                    IEnumerable<IEdmStructuralProperty> properties =
                        entityType.Key().Any()
                            ? entityType.Key()
                            : entityType
                                .StructuralProperties()
                                .Where(property => property.Type.IsPrimitive() && !property.Type.IsStream())
                                .OrderBy(property => property.Name);

                    if (orderByClause == null)
                    {
                        bool alreadyOrdered = false;
                        foreach (var prop in properties)
                        {
                            source = ExpressionHelpers.OrderByPropertyExpression(source, prop.Name, elementType,
                                alreadyOrdered);
                            if (!alreadyOrdered)
                            {
                                alreadyOrdered = true;
                            }
                        }
                    }
                }
            }

            if (hasSkipvalue)
            {
                Contract.Assert(skipOption.Value <= Int32.MaxValue);
                source = ExpressionHelpers.Skip(source, (int)skipOption.Value, elementType,
                    _settings.EnableConstantParameterization);
            }

            if (hasTopValue)
            {
                Contract.Assert(topOption.Value <= Int32.MaxValue);
                source = ExpressionHelpers.Take(source, (int)topOption.Value, elementType,
                    _settings.EnableConstantParameterization);
            }

            if (_settings.PageSize.HasValue || modelBoundPageSize.HasValue || hasTopValue || hasSkipvalue)
            {
                // don't page nested collections if EnableCorrelatedSubqueryBuffering is enabled
                if (!_settings.EnableCorrelatedSubqueryBuffering)
                {
                    if (_settings.PageSize.HasValue)
                    {
                        source = ExpressionHelpers.Take(source, _settings.PageSize.Value + 1, elementType,
                            _settings.EnableConstantParameterization);
                    }
                    else if (_settings.ModelBoundPageSize.HasValue)
                    {
                        source = ExpressionHelpers.Take(source, modelBoundPageSize.Value + 1, elementType,
                            _settings.EnableConstantParameterization);
                    }
                }
            }

            // expression
            //      source.Select((ElementType element) => new Wrapper { })
            var selectMethod = GetSelectMethod(elementType, projection.Type);
            Expression selectedExpresion = Expression.Call(selectMethod, source, selector);

            // Append ToList() to collection as a hint to LINQ provider to buffer correlated subqueries in memory and avoid executing N+1 queries
            if (_settings.EnableCorrelatedSubqueryBuffering)
            {
                selectedExpresion = Expression.Call(ExpressionHelperMethods.QueryableToList.MakeGenericMethod(projection.Type), selectedExpresion);
            }

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // source == null ? null : projectedCollection
                return Expression.Condition(
                       test: Expression.Equal(source, Expression.Constant(null)),
                       ifTrue: Expression.Constant(null, selectedExpresion.Type),
                       ifFalse: selectedExpresion);
            }
            else
            {
                return selectedExpresion;
            }
        }

        // OData formatter requires the type name of the entity that is being written if the type has derived types.
        // Expression
        //      source is GrandChild ? "GrandChild" : ( source is Child ? "Child" : "Root" )
        // Notice that the order is important here. The most derived type must be the first to check.
        // If entity framework had a way to figure out the type name without selecting the whole object, we don't have to do this magic.
        internal static Expression CreateTypeNameExpression(Expression source, IEdmStructuredType elementType, IEdmModel model)
        {
            IReadOnlyList<IEdmStructuredType> derivedTypes = GetAllDerivedTypes(elementType, model);
            if (derivedTypes.Count == 0)
            {
                // no inheritance.
                return null;
            }
            else
            {
                Expression expression = Expression.Constant(elementType.FullTypeName());
                for (int i = 0; i < derivedTypes.Count; i++)
                {
                    Type clrType = EdmLibHelpers.GetClrType(derivedTypes[i], model);
                    if (clrType == null)
                    {
                        throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, derivedTypes[0].FullTypeName()));
                    }

                    expression = Expression.Condition(
                        test: Expression.TypeIs(source, clrType),
                        ifTrue: Expression.Constant(derivedTypes[i].FullTypeName()),
                        ifFalse: expression);
                }

                return expression;
            }
        }

        // returns all the derived types (direct and indirect) of baseType ordered according to their depth. The direct children
        // are the first in the list.
        private static IReadOnlyList<IEdmStructuredType> GetAllDerivedTypes(IEdmStructuredType baseType, IEdmModel model)
        {
            IEnumerable<IEdmStructuredType> allStructuredTypes = model.SchemaElements.OfType<IEdmStructuredType>();

            List<Tuple<int, IEdmStructuredType>> derivedTypes = new List<Tuple<int, IEdmStructuredType>>();
            foreach (IEdmStructuredType structuredType in allStructuredTypes)
            {
                int distance = IsDerivedTypeOf(structuredType, baseType);
                if (distance > 0)
                {
                    derivedTypes.Add(Tuple.Create(distance, structuredType));
                }
            }

            return derivedTypes.OrderBy(tuple => tuple.Item1).Select(tuple => tuple.Item2).ToList();
        }

        // returns -1 if type does not derive from baseType and a positive number representing the distance
        // between them if it does.
        private static int IsDerivedTypeOf(IEdmStructuredType type, IEdmStructuredType baseType)
        {
            int distance = 0;
            while (type != null)
            {
                if (baseType == type)
                {
                    return distance;
                }

                type = type.BaseType();
                distance++;
            }

            return -1;
        }

        private static MethodInfo GetSelectMethod(Type elementType, Type resultType)
        {
            return ExpressionHelperMethods.EnumerableSelectGeneric.MakeGenericMethod(elementType, resultType);
        }

        private static bool IsSelectAll(SelectExpandClause selectExpandClause)
        {
            if (selectExpandClause == null)
            {
                return true;
            }

            if (selectExpandClause.AllSelected || selectExpandClause.SelectedItems.OfType<WildcardSelectItem>().Any())
            {
                return true;
            }

            return false;
        }

        private static Type GetWrapperGenericType(bool isInstancePropertySet, bool isTypeNamePropertySet, bool isContainerPropertySet)
        {
            if (isInstancePropertySet)
            {
                // select all
                Contract.Assert(!isTypeNamePropertySet, "we don't set type name if we set instance as it can be figured from instance");

                return isContainerPropertySet ? typeof(SelectAllAndExpand<>) : typeof(SelectAll<>);
            }
            else
            {
                Contract.Assert(isContainerPropertySet, "if it is not select all, container should hold something");

                return isTypeNamePropertySet ? typeof(SelectSomeAndInheritance<>) : typeof(SelectSome<>);
            }
        }

        private class ReferenceNavigationPropertyExpandFilterVisitor : ExpressionVisitor
        {
            private Expression _source;
            private ParameterExpression _parameterExpression;

            public ReferenceNavigationPropertyExpandFilterVisitor(ParameterExpression parameterExpression, Expression source)
            {
                _source = source;
                _parameterExpression = parameterExpression;
            }

            protected override Expression VisitParameter(ParameterExpression node)
            {
                if (node != _parameterExpression)
                {
                    throw new ODataException(Error.Format(SRResources.ReferenceNavigationPropertyExpandFilterVisitorUnexpectedParameter, node.Name));
                }

                return _source;
            }
        }

        /* Entityframework requires that the two different type initializers for a given type in the same query have the
        same set of properties in the same order.

        A ~/People?$select=Name&$expand=Friend results in a select expression that has two SelectExpandWrapper<Person>
        expressions, one for the root level person and the second for the expanded Friend person.
        The first wrapper has the Container property set (contains Name and Friend values) where as the second wrapper
        has the Instance property set as it contains all the properties of the expanded person.

        The below four classes workaround that entity framework limitation by defining a seperate type for each
        property selection combination possible. */

        private class SelectAllAndExpand<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectAll<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectSomeAndInheritance<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectSome<TEntity> : SelectAllAndExpand<TEntity>
        {
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Query.Expressions
{
    /// <summary>
    /// Applies the given <see cref="SelectExpandQueryOption"/> to the given <see cref="IQueryable"/>.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable.")]
    internal class SelectExpandBinder
    {
        private ODataQueryContext _context;
        private IEdmModel _model;
        private ODataQuerySettings _settings;
        private string _modelID;
        private DataSourceProviderKind _dataSourceProviderKind;

        public SelectExpandBinder(ODataQuerySettings settings, ODataQueryContext context)
        {
            Contract.Assert(settings != null);
            Contract.Assert(context != null);
            Contract.Assert(context.Model != null);
            Contract.Assert(settings.HandleNullPropagation != HandleNullPropagationOption.Default);

            _context = context;
            _model = _context.Model;
            _modelID = ModelContainer.GetModelID(_model);
            _settings = settings;
            _dataSourceProviderKind = DataSourceProviderKind.Unknown;
        }

        public static IQueryable Bind(IQueryable queryable, ODataQuerySettings settings, SelectExpandQueryOption selectExpandQuery)
        {
            Contract.Assert(queryable != null);
            Contract.Assert(selectExpandQuery != null);

            SelectExpandBinder binder = new SelectExpandBinder(settings, selectExpandQuery.Context);
            return binder.Bind(queryable, selectExpandQuery);
        }

        public static object Bind(object entity, ODataQuerySettings settings, SelectExpandQueryOption selectExpandQuery)
        {
            Contract.Assert(entity != null);
            Contract.Assert(selectExpandQuery != null);

            SelectExpandBinder binder = new SelectExpandBinder(settings, selectExpandQuery.Context);
            return binder.Bind(entity, selectExpandQuery);
        }

        private object Bind(object entity, SelectExpandQueryOption selectExpandQuery)
        {
            _dataSourceProviderKind = DataSourceProviderKind.InMemory;

            // Needn't to verify the input, that's done at upper level.
            LambdaExpression projectionLambda = GetProjectionLambda(selectExpandQuery);

            // TODO: cache this ?
            return projectionLambda.Compile().DynamicInvoke(entity);
        }

        private IQueryable Bind(IQueryable queryable, SelectExpandQueryOption selectExpandQuery)
        {
            _dataSourceProviderKind = queryable.GetDataSourceProviderKind();

            // Needn't to verify the input, that's done at upper level.
            Type elementType = selectExpandQuery.Context.ElementClrType;

            LambdaExpression projectionLambda = GetProjectionLambda(selectExpandQuery);

            MethodInfo selectMethod = ExpressionHelperMethods.QueryableSelectGeneric.MakeGenericMethod(elementType, projectionLambda.Body.Type);
            return selectMethod.Invoke(null, new object[] { queryable, projectionLambda }) as IQueryable;
        }

        private LambdaExpression GetProjectionLambda(SelectExpandQueryOption selectExpandQuery)
        {
            Type elementType = selectExpandQuery.Context.ElementClrType;
            IEdmNavigationSource navigationSource = selectExpandQuery.Context.NavigationSource;
            ParameterExpression source = Expression.Parameter(elementType, "$it");

            // expression looks like -> new Wrapper { Instance = source , Properties = "...", Container = new PropertyContainer { ... } }
            Expression projectionExpression = ProjectElement(source, selectExpandQuery.SelectExpandClause, _context.ElementType as IEdmStructuredType, navigationSource);

            // expression looks like -> source => new Wrapper { Instance = source .... }
            LambdaExpression projectionLambdaExpression = Expression.Lambda(projectionExpression, source);

            return projectionLambdaExpression;
        }

        internal Expression ProjectAsWrapper(Expression source, SelectExpandClause selectExpandClause,
            IEdmStructuredType structuredType, IEdmNavigationSource navigationSource, OrderByClause orderByClause = null,
            long? topOption = null,
            long? skipOption = null,
            int? modelBoundPageSize = null)
        {
            Type elementType;
            if (TypeHelper.IsCollection(source.Type, out elementType))
            {
                // new CollectionWrapper<ElementType> { Instance = source.Select(s => new Wrapper { ... }) };
                return ProjectCollection(source, elementType, selectExpandClause, structuredType, navigationSource, orderByClause,
                    topOption,
                    skipOption,
                    modelBoundPageSize);
            }
            else
            {
                // new Wrapper { v1 = source.property ... }
                return ProjectElement(source, selectExpandClause, structuredType, navigationSource);
            }
        }

        internal Expression CreatePropertyNameExpression(IEdmStructuredType elementType, IEdmProperty property, Expression source)
        {
            Contract.Assert(elementType != null);
            Contract.Assert(property != null);
            Contract.Assert(source != null);

            IEdmStructuredType declaringType = property.DeclaringType;

            // derived property using cast
            if (elementType != declaringType)
            {
                Type originalType = EdmLibHelpers.GetClrType(elementType, _model);
                Type castType = EdmLibHelpers.GetClrType(declaringType, _model);
                if (castType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, declaringType.FullTypeName()));
                }

                if (!castType.IsAssignableFrom(originalType))
                {
                    // Expression
                    //          source is navigationPropertyDeclaringType ? propertyName : null
                    return Expression.Condition(
                        test: Expression.TypeIs(source, castType),
                        ifTrue: Expression.Constant(property.Name),
                        ifFalse: Expression.Constant(null, typeof(string)));
                }
            }

            // Expression
            //          "propertyName"
            return Expression.Constant(property.Name);
        }

        internal Expression CreatePropertyValueExpression(IEdmStructuredType elementType, IEdmProperty property, Expression source, FilterClause filterClause)
        {
            Contract.Assert(elementType != null);
            Contract.Assert(property != null);
            Contract.Assert(source != null);

            // Expression: source = source as propertyDeclaringType
            if (elementType != property.DeclaringType)
            {
                Type castType = EdmLibHelpers.GetClrType(property.DeclaringType, _model);
                if (castType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, property.DeclaringType.FullTypeName()));
                }

                source = Expression.TypeAs(source, castType);
            }

            // Expression:  source.Property
            string propertyName = EdmLibHelpers.GetClrPropertyName(property, _model);
            PropertyInfo propertyInfo = source.Type.GetProperty(propertyName);
            Expression propertyValue = Expression.Property(source, propertyInfo);
            Type nullablePropertyType = TypeHelper.ToNullable(propertyValue.Type);
            Expression nullablePropertyValue = ExpressionHelpers.ToNullable(propertyValue);

            if (filterClause != null)
            {
                bool isCollection = property.Type.IsCollection();

                IEdmTypeReference edmElementType = (isCollection ? property.Type.AsCollection().ElementType() : property.Type);
                Type clrElementType = EdmLibHelpers.GetClrType(edmElementType, _model);
                if (clrElementType == null)
                {
                    throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, edmElementType.FullName()));
                }

                Expression filterResult = nullablePropertyValue;

                ODataQuerySettings querySettings = new ODataQuerySettings()
                {
                    HandleNullPropagation = HandleNullPropagationOption.True,
                };

                if (isCollection)
                {
                    Expression filterSource = nullablePropertyValue;

                    // TODO: Implement proper support for $select/$expand after $apply
                    Expression filterPredicate = FilterBinder.Bind(null, filterClause, clrElementType, _context, querySettings);
                    filterResult = Expression.Call(
                        ExpressionHelperMethods.EnumerableWhereGeneric.MakeGenericMethod(clrElementType),
                        filterSource,
                        filterPredicate);

                    nullablePropertyType = filterResult.Type;
                }
                else if (_settings.HandleReferenceNavigationPropertyExpandFilter)
                {
                    LambdaExpression filterLambdaExpression = FilterBinder.Bind(null, filterClause, clrElementType, _context, querySettings) as LambdaExpression;
                    if (filterLambdaExpression == null)
                    {
                        throw new ODataException(Error.Format(SRResources.ExpandFilterExpressionNotLambdaExpression, property.Name, "LambdaExpression"));
                    }

                    ParameterExpression filterParameter = filterLambdaExpression.Parameters.First();
                    Expression predicateExpression = new ReferenceNavigationPropertyExpandFilterVisitor(filterParameter, nullablePropertyValue).Visit(filterLambdaExpression.Body);

                    // create expression similar to: 'predicateExpression == true ? nullablePropertyValue : null'
                    filterResult = Expression.Condition(
                        test: predicateExpression,
                        ifTrue: nullablePropertyValue,
                        ifFalse: Expression.Constant(value: null, type: nullablePropertyType));
                }

                if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // create expression similar to: 'nullablePropertyValue == null ? null : filterResult'
                    nullablePropertyValue = Expression.Condition(
                        test: Expression.Equal(nullablePropertyValue, Expression.Constant(value: null)),
                        ifTrue: Expression.Constant(value: null, type: nullablePropertyType),
                        ifFalse: filterResult);
                }
                else
                {
                    nullablePropertyValue = filterResult;
                }
            }

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // create expression similar to: 'source == null ? null : propertyValue'
                propertyValue = Expression.Condition(
                    test: Expression.Equal(source, Expression.Constant(value: null)),
                    ifTrue: Expression.Constant(value: null, type: nullablePropertyType),
                    ifFalse: nullablePropertyValue);
            }
            else
            {
                // need to cast this to nullable as EF would fail while materializing if the property is not nullable and source is null.
                propertyValue = nullablePropertyValue;
            }

            return propertyValue;
        }

        // Generates the expression
        //      source => new Wrapper { Instance = source, Container = new PropertyContainer { ..expanded properties.. } }
        internal Expression ProjectElement(Expression source, SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource)
        {
            Contract.Assert(source != null);

            // If it's not a structural type, just return the source.
            if (structuredType == null)
            {
                return source;
            }

            Type elementType = source.Type;
            Type wrapperType = typeof(SelectExpandWrapper<>).MakeGenericType(elementType);
            List<MemberAssignment> wrapperTypeMemberAssignments = new List<MemberAssignment>();

            PropertyInfo wrapperProperty;
            Expression wrapperPropertyValueExpression;
            bool isInstancePropertySet = false;
            bool isTypeNamePropertySet = false;
            bool isContainerPropertySet = false;

            // Initialize property 'ModelID' on the wrapper class.
            // source = new Wrapper { ModelID = 'some-guid-id' }
            wrapperProperty = wrapperType.GetProperty("ModelID");
            wrapperPropertyValueExpression = _settings.EnableConstantParameterization ?
                LinqParameterContainer.Parameterize(typeof(string), _modelID) :
                Expression.Constant(_modelID);
            wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, wrapperPropertyValueExpression));

            if (IsSelectAll(selectExpandClause))
            {
                // Initialize property 'Instance' on the wrapper class
                wrapperProperty = wrapperType.GetProperty("Instance");
                wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, source));

                wrapperProperty = wrapperType.GetProperty("UseInstanceForProperties");
                wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, Expression.Constant(true)));
                isInstancePropertySet = true;
            }
            else
            {
                // Initialize property 'TypeName' on the wrapper class as we don't have the instance.
                Expression typeName = CreateTypeNameExpression(source, structuredType, _model);
                if (typeName != null)
                {
                    isTypeNamePropertySet = true;
                    wrapperProperty = wrapperType.GetProperty("InstanceType");
                    wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, typeName));
                }
            }

            // Initialize the property 'Container' on the wrapper class
            // source => new Wrapper { Container =  new PropertyContainer { .... } }
            if (selectExpandClause != null)
            {
                IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude;
                IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand;
                ISet<IEdmStructuralProperty> autoSelectedProperties;

                bool isContainDynamicPropertySelection = GetSelectExpandProperties(_model, structuredType, navigationSource, selectExpandClause,
                    out propertiesToInclude,
                    out propertiesToExpand,
                    out autoSelectedProperties);

                bool isSelectingOpenTypeSegments = isContainDynamicPropertySelection || IsSelectAllOnOpenType(selectExpandClause, structuredType);

                if (propertiesToExpand != null || propertiesToInclude != null || autoSelectedProperties != null || isSelectingOpenTypeSegments)
                {
                    Expression propertyContainerCreation =
                        BuildPropertyContainer(source, structuredType, propertiesToExpand, propertiesToInclude, autoSelectedProperties, isSelectingOpenTypeSegments);

                    if (propertyContainerCreation != null)
                    {
                        wrapperProperty = wrapperType.GetProperty("Container");
                        Contract.Assert(wrapperProperty != null);

                        wrapperTypeMemberAssignments.Add(Expression.Bind(wrapperProperty, propertyContainerCreation));
                        isContainerPropertySet = true;
                    }
                }
            }

            Type wrapperGenericType = GetWrapperGenericType(isInstancePropertySet, isTypeNamePropertySet, isContainerPropertySet);
            wrapperType = wrapperGenericType.MakeGenericType(elementType);
            return Expression.MemberInit(Expression.New(wrapperType), wrapperTypeMemberAssignments);
        }

        /// <summary>
        /// Gets the $select and $expand properties from the given <see cref="SelectExpandClause"/>
        /// </summary>
        /// <param name="model">The Edm model.</param>
        /// <param name="structuredType">The current structural type.</param>
        /// <param name="navigationSource">The current navigation source.</param>
        /// <param name="selectExpandClause">The given select and expand clause.</param>
        /// <param name="propertiesToInclude">The out properties to include at current level, could be null.</param>
        /// <param name="propertiesToExpand">The out properties to expand at current level, could be null.</param>
        /// <param name="autoSelectedProperties">The out auto selected properties to include at current level, could be null.</param>
        /// <returns>true if the select contains dynamic property selection, false if it's not.</returns>
        internal static bool GetSelectExpandProperties(IEdmModel model, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource,
            SelectExpandClause selectExpandClause,
            out IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude,
            out IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand,
            out ISet<IEdmStructuralProperty> autoSelectedProperties)
        {
            Contract.Assert(selectExpandClause != null);

            // Properties to be included includes all the properties selected or in the middle of a $select and $expand path.
            // for example: "$expand=abc/xyz/nav", "abc" and "xyz" are the middle properties that should be included.
            // meanwhile, "nav" is the property that should be expanded.
            // If it's a type cast path, for example: $select=NS.TypeCast/abc, "abc" should be included also.
            propertiesToInclude = null;
            propertiesToExpand = null;
            autoSelectedProperties = null;

            bool isSelectContainsDynamicProperty = false;
            var currentLevelPropertiesInclude = new Dictionary<IEdmStructuralProperty, SelectExpandIncludedProperty>();
            foreach (SelectItem selectItem in selectExpandClause.SelectedItems)
            {
                // $expand=...
                if (selectItem is ExpandedReferenceSelectItem expandedItem)
                {
                    ProcessExpandedItem(expandedItem, navigationSource, currentLevelPropertiesInclude, ref propertiesToExpand);
                    continue;
                }

                // $select=...
                if (selectItem is PathSelectItem pathItem)
                {
                    if (ProcessSelectedItem(pathItem, navigationSource, currentLevelPropertiesInclude))
                    {
                        isSelectContainsDynamicProperty = true;
                    }
                    continue;
                }

                // Skip processing the "WildcardSelectItem and NamespaceQualifiedWildcardSelectItem"
                // ODL now doesn't support "$select=property/*" and "$select=property/NS.*"
            }

            if (!IsSelectAll(selectExpandClause))
            {
                // We should include the keys if it's an entity.
                if (structuredType is IEdmEntityType entityType)
                {
                    foreach (IEdmStructuralProperty keyProperty in entityType.Key())
                    {
                        if (!currentLevelPropertiesInclude.Keys.Contains(keyProperty))
                        {
                            if (autoSelectedProperties == null)
                            {
                                autoSelectedProperties = new HashSet<IEdmStructuralProperty>();
                            }

                            autoSelectedProperties.Add(keyProperty);
                        }
                    }
                }

                // We should add concurrency properties, if not added
                if (navigationSource != null && model != null)
                {
                    IEnumerable<IEdmStructuralProperty> concurrencyProperties = model.GetConcurrencyProperties(navigationSource);
                    foreach (IEdmStructuralProperty concurrencyProperty in concurrencyProperties)
                    {
                        if (structuredType.Properties().Any(p => p == concurrencyProperty))
                        {
                            if (!currentLevelPropertiesInclude.Keys.Contains(concurrencyProperty))
                            {
                                if (autoSelectedProperties == null)
                                {
                                    autoSelectedProperties = new HashSet<IEdmStructuralProperty>();
                                }

                                autoSelectedProperties.Add(concurrencyProperty);
                            }
                        }
                    }
                }
            }

            if (currentLevelPropertiesInclude.Any())
            {
                propertiesToInclude = new Dictionary<IEdmStructuralProperty, PathSelectItem>();
                foreach (var propertiesInclude in currentLevelPropertiesInclude)
                {
                    propertiesToInclude[propertiesInclude.Key] = propertiesInclude.Value == null ? null : propertiesInclude.Value.ToPathSelectItem();
                }
            }

            return isSelectContainsDynamicProperty;
        }

        /// <summary>
        /// Process the <see cref="ExpandedReferenceSelectItem"/>.
        /// </summary>
        /// <param name="expandedItem">The expaned item.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="currentLevelPropertiesInclude">The current level properties included.</param>
        /// <param name="propertiesToExpand">out/ref, the property expanded.</param>
        private static void ProcessExpandedItem(ExpandedReferenceSelectItem expandedItem,
            IEdmNavigationSource navigationSource,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude,
            ref IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand)
        {
            Contract.Assert(expandedItem?.PathToNavigationProperty != null);
            Contract.Assert(currentLevelPropertiesInclude != null);

            // Verify and process the $expand=... path.
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment firstNonTypeSegment = expandedItem.PathToNavigationProperty.GetFirstNonTypeCastSegment(out remainingSegments);

            // for $expand=NS.SubType/Nav, we don't care about the leading type segment, because with or without the type segment            // the "nav" property value expression should be built into the property container.
            if (firstNonTypeSegment is PropertySegment firstStructuralPropertySegment)
            {
                // for example: $expand=abc/nav, the remaining segments should never be null because at least the last navigation segment is there.
                Contract.Assert(remainingSegments != null);

                SelectExpandIncludedProperty newPropertySelectItem;
                if (!currentLevelPropertiesInclude.TryGetValue(firstStructuralPropertySegment.Property, out newPropertySelectItem))
                {
                    newPropertySelectItem = new SelectExpandIncludedProperty(firstStructuralPropertySegment, navigationSource);
                    currentLevelPropertiesInclude[firstStructuralPropertySegment.Property] = newPropertySelectItem;
                }

                newPropertySelectItem.AddSubExpandItem(remainingSegments, expandedItem);
            }
            else
            {
                // for example: $expand=nav, if we couldn't find a structural property in the path, it means we get the last navigation segment.
                // So, the remaing segments should be null and the last segment should be "NavigationPropertySegment".
                Contract.Assert(remainingSegments == null);
                Contract.Assert(firstNonTypeSegment is NavigationPropertySegment firstNavigationPropertySegment);

                // Needn't add this navigation property into the include property.
                // Because this navigation property will be included separately.
                if (propertiesToExpand == null)
                {
                    propertiesToExpand = new Dictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem>();
                }

                propertiesToExpand[firstNavigationPropertySegment.NavigationProperty] = expandedItem;
            }
        }

        /// <summary>
        /// Process the <see cref="PathSelectItem"/>.
        /// </summary>
        /// <param name="pathSelectItem">The selected item.</param>
        /// <param name="navigationSource">The navigation source.</param>
        /// <param name="currentLevelPropertiesInclude">The current level properties included.</param>
        /// <returns>true if it's dynamic property selection, false if it's not.</returns>
        private static bool ProcessSelectedItem(PathSelectItem pathSelectItem,
            IEdmNavigationSource navigationSource,
            IDictionary<IEdmStructuralProperty, SelectExpandIncludedProperty> currentLevelPropertiesInclude)
        {
            Contract.Assert(pathSelectItem?.SelectedPath != null);
            Contract.Assert(currentLevelPropertiesInclude != null);

            // Verify and process the $select path
            IList<ODataPathSegment> remainingSegments;
            ODataPathSegment firstNonTypeSegment = pathSelectItem.SelectedPath.GetFirstNonTypeCastSegment(out remainingSegments);

            // for $select=NS.SubType/Property, we don't care about the leading type segment, because with or without the type segment            // the "Property" property value expression should be built into the property container.
            if (firstNonTypeSegment is PropertySegment firstSturucturalPropertySegment)
            {
                // $select=abc/..../xyz
                SelectExpandIncludedProperty newPropertySelectItem;
                if (!currentLevelPropertiesInclude.TryGetValue(firstSturucturalPropertySegment.Property, out newPropertySelectItem))
                {
                    newPropertySelectItem = new SelectExpandIncludedProperty(firstSturucturalPropertySegment, navigationSource);
                    currentLevelPropertiesInclude[firstSturucturalPropertySegment.Property] = newPropertySelectItem;
                }

                newPropertySelectItem.AddSubSelectItem(remainingSegments, pathSelectItem);
            }
            else
            {
                // If we can't find a PropertySegment, the $select path maybe selecting an operation, a navigation or dynamic property.
                // And the remaing segments should be null.
                Contract.Assert(remainingSegments == null);

                // For operation (action/function), needn't process it.
                // For navigation property, needn't process it here.

                // For dynamic property, let's test the last segment for this path select item.
                if (firstNonTypeSegment is DynamicPathSegment)
                {
                    return true;
                }
            }

            return false;
        }

        // To test whether the currect selection is SelectAll on an open type
        private static bool IsSelectAllOnOpenType(SelectExpandClause selectExpandClause, IEdmStructuredType structuredType)
        {
            if (structuredType == null || !structuredType.IsOpen)
            {
                return false;
            }

            if (IsSelectAll(selectExpandClause))
            {
                return true;
            }

            return false;
        }

        private Expression CreateTotalCountExpression(Expression source, bool? countOption)
        {
            Expression countExpression = Expression.Constant(null, typeof(long?));
            if (countOption == null || !countOption.Value)
            {
                return countExpression;
            }

            Type elementType;
            if (!TypeHelper.IsCollection(source.Type, out elementType))
            {
                return countExpression;
            }

            MethodInfo countMethod;
            if (typeof(IQueryable).IsAssignableFrom(source.Type))
            {
                countMethod = ExpressionHelperMethods.QueryableCountGeneric.MakeGenericMethod(elementType);
            }
            else
            {
                countMethod = ExpressionHelperMethods.EnumerableCountGeneric.MakeGenericMethod(elementType);
            }

            // call Count() method.
            countExpression = Expression.Call(null, countMethod, new[] { source });

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // source == null ? null : countExpression
                return Expression.Condition(
                       test: Expression.Equal(source, Expression.Constant(null)),
                       ifTrue: Expression.Constant(null, typeof(long?)),
                       ifFalse: ExpressionHelpers.ToNullable(countExpression));
            }
            else
            {
                return countExpression;
            }
        }

        private Expression BuildPropertyContainer(Expression source, IEdmStructuredType structuredType,
            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> propertiesToExpand,
            IDictionary<IEdmStructuralProperty, PathSelectItem> propertiesToInclude,
            ISet<IEdmStructuralProperty> autoSelectedProperties,
            bool isSelectingOpenTypeSegments)
        {
            IList<NamedPropertyExpression> includedProperties = new List<NamedPropertyExpression>();

            if (propertiesToExpand != null)
            {
                foreach (var propertyToExpand in propertiesToExpand)
                {
                    // $expand=abc or $expand=abc/$ref
                    BuildExpandedProperty(source, structuredType, propertyToExpand.Key, propertyToExpand.Value, includedProperties);
                }
            }

            if (propertiesToInclude != null)
            {
                foreach (var propertyToInclude in propertiesToInclude)
                {
                    // $select=abc($select=...,$filter=...,$compute=...)....
                    BuildSelectedProperty(source, structuredType, propertyToInclude.Key, propertyToInclude.Value, includedProperties);
                }
            }

            if (autoSelectedProperties != null)
            {
                foreach (IEdmStructuralProperty propertyToInclude in autoSelectedProperties)
                {
                    Expression propertyName = CreatePropertyNameExpression(structuredType, propertyToInclude, source);
                    Expression propertyValue = CreatePropertyValueExpression(structuredType, propertyToInclude, source, filterClause: null);
                    includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue)
                    {
                        AutoSelected = true
                    });
                }
            }

            if (isSelectingOpenTypeSegments)
            {
                BuildDynamicProperty(source, structuredType, includedProperties);
            }

            // create a property container that holds all these property names and values.
            return PropertyContainer.CreatePropertyContainer(includedProperties);
        }

        /// <summary>
        /// Build the navigation property <see cref="IEdmNavigationProperty"/> into the included properties.
        /// The property name is the navigation property name.
        /// The property value is the navigation property value from the source and applied the nested query options.
        /// </summary>
        /// <param name="source">The source contains the navigation property.</param>
        /// <param name="structuredType">The structured type or its derived type contains the navigation property.</param>
        /// <param name="navigationProperty">The expanded navigation property.</param>
        /// <param name="expandedItem">The expanded navigation select item. It may contain the neste query options.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildExpandedProperty(Expression source, IEdmStructuredType structuredType,
            IEdmNavigationProperty navigationProperty, ExpandedReferenceSelectItem expandedItem,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(navigationProperty != null);
            Contract.Assert(expandedItem != null);
            Contract.Assert(includedProperties != null);

            IEdmEntityType edmEntityType = navigationProperty.ToEntityType();

            ModelBoundQuerySettings querySettings = EdmLibHelpers.GetModelBoundQuerySettings(navigationProperty, edmEntityType, _model);

            // TODO: Process $apply and $compute in the $expand here, will support later.
            // $apply=...; $compute=...

            // Expression:
            //       "navigation property name"
            Expression propertyName = CreatePropertyNameExpression(structuredType, navigationProperty, source);

            // Expression:
            //        source.NavigationProperty
            Expression propertyValue = CreatePropertyValueExpression(structuredType, navigationProperty, source, expandedItem.FilterOption);

            // Sub select and expand could be null if the expanded navigation property is not further projected or expanded.
            SelectExpandClause subSelectExpandClause = GetOrCreateSelectExpandClause(navigationProperty, expandedItem);

            Expression nullCheck = GetNullCheckExpression(navigationProperty, propertyValue, subSelectExpandClause);

            Expression countExpression = CreateTotalCountExpression(propertyValue, expandedItem.CountOption);

            int? modelBoundPageSize = querySettings == null ? null : querySettings.PageSize;
            propertyValue = ProjectAsWrapper(propertyValue, subSelectExpandClause, edmEntityType, expandedItem.NavigationSource,
                expandedItem.OrderByOption, // $orderby=...
                expandedItem.TopOption, // $top=...
                expandedItem.SkipOption, // $skip=...
                modelBoundPageSize);

            NamedPropertyExpression propertyExpression = new NamedPropertyExpression(propertyName, propertyValue);
            if (subSelectExpandClause != null)
            {
                if (!navigationProperty.Type.IsCollection())
                {
                    propertyExpression.NullCheck = nullCheck;
                }
                else if (_settings.PageSize.HasValue)
                {
                    propertyExpression.PageSize = _settings.PageSize.Value;
                }
                else
                {
                    if (querySettings != null && querySettings.PageSize.HasValue)
                    {
                        propertyExpression.PageSize = querySettings.PageSize.Value;
                    }
                }

                propertyExpression.TotalCount = countExpression;
                propertyExpression.CountOption = expandedItem.CountOption;
            }

            includedProperties.Add(propertyExpression);
        }

        /// <summary>
        /// Build the structural property <see cref="IEdmStructuralProperty"/> into the included properties.
        /// The property name is the structural property name.
        /// The property value is the structural property value from the source and applied the nested query options.
        /// </summary>
        /// <param name="source">The source contains the structural property.</param>
        /// <param name="structuredType">The structured type or its derived type contains the structural property.</param>
        /// <param name="structuralProperty">The selected structural property.</param>
        /// <param name="pathSelectItem">The selected item. It may contain the neste query options and could be null.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildSelectedProperty(Expression source, IEdmStructuredType structuredType,
            IEdmStructuralProperty structuralProperty, PathSelectItem pathSelectItem,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(structuralProperty != null);
            Contract.Assert(includedProperties != null);

            // // Expression:
            //       "navigation property name"
            Expression propertyName = CreatePropertyNameExpression(structuredType, structuralProperty, source);

            // Expression:
            //        source.NavigationProperty
            Expression propertyValue;
            if (pathSelectItem == null)
            {
                propertyValue = CreatePropertyValueExpression(structuredType, structuralProperty, source, filterClause: null);
                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
                return;
            }

            SelectExpandClause subSelectExpandClause = pathSelectItem.SelectAndExpand;

            // TODO: Process $compute in the $select ahead.
            // $compute=...

            propertyValue = CreatePropertyValueExpression(structuredType, structuralProperty, source, pathSelectItem.FilterOption);
            Type propertyValueType = propertyValue.Type;
            if (propertyValueType == typeof(char[]) || propertyValueType == typeof(byte[]))
            {
                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
                return;
            }

            // EF5 and EF6 don't support comparing complex objects to null, and will throw an exception similar to following if it is
            // attempted:
            //    "Cannot compare elements of type 'xxxx'. Only primitive types, enumeration types and entity types are supported."
            // EFCore has changed its implementation so the null check executes as expected.
            Expression nullCheck = null;
            if (_dataSourceProviderKind != DataSourceProviderKind.EFClassic)
            {
                nullCheck = GetNullCheckExpression(structuralProperty, propertyValue, subSelectExpandClause);
            }

            Expression countExpression = CreateTotalCountExpression(propertyValue, pathSelectItem.CountOption);

            // be noted: the property structured type could be null, because the property maybe not a complex property.
            IEdmStructuredType propertyStructuredType = structuralProperty.Type.ToStructuredType();
            ModelBoundQuerySettings querySettings = null;
            if (propertyStructuredType != null)
            {
                querySettings = EdmLibHelpers.GetModelBoundQuerySettings(structuralProperty, propertyStructuredType, _context.Model);
            }

            int? modelBoundPageSize = querySettings == null ? null : querySettings.PageSize;
            propertyValue = ProjectAsWrapper(propertyValue, subSelectExpandClause, structuralProperty.Type.ToStructuredType(), pathSelectItem.NavigationSource,
                pathSelectItem.OrderByOption, // $orderby=...
                pathSelectItem.TopOption, // $top=...
                pathSelectItem.SkipOption, // $skip=...
                modelBoundPageSize);

            NamedPropertyExpression propertyExpression = new NamedPropertyExpression(propertyName, propertyValue);
            if (subSelectExpandClause != null)
            {
                if (!structuralProperty.Type.IsCollection())
                {
                    propertyExpression.NullCheck = nullCheck;
                }
                else if (_settings.PageSize.HasValue)
                {
                    propertyExpression.PageSize = _settings.PageSize.Value;
                }
                else
                {
                    if (querySettings != null && querySettings.PageSize.HasValue)
                    {
                        propertyExpression.PageSize = querySettings.PageSize.Value;
                    }
                }

                propertyExpression.TotalCount = countExpression;
                propertyExpression.CountOption = pathSelectItem.CountOption;
            }

            includedProperties.Add(propertyExpression);
        }

        /// <summary>
        /// Build the dynamic properties into the included properties.
        /// </summary>
        /// <param name="source">The source contains the dynamic property.</param>
        /// <param name="structuredType">The structured type contains the dynamic property.</param>
        /// <param name="includedProperties">The container to hold the created property.</param>
        internal void BuildDynamicProperty(Expression source, IEdmStructuredType structuredType,
            IList<NamedPropertyExpression> includedProperties)
        {
            Contract.Assert(source != null);
            Contract.Assert(structuredType != null);
            Contract.Assert(includedProperties != null);

            PropertyInfo dynamicPropertyDictionary = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType, _model);
            if (dynamicPropertyDictionary != null)
            {
                Expression propertyName = Expression.Constant(dynamicPropertyDictionary.Name);
                Expression propertyValue = Expression.Property(source, dynamicPropertyDictionary.Name);
                Expression nullablePropertyValue = ExpressionHelpers.ToNullable(propertyValue);
                if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
                {
                    // source == null ? null : propertyValue
                    propertyValue = Expression.Condition(
                        test: Expression.Equal(source, Expression.Constant(value: null)),
                        ifTrue: Expression.Constant(value: null, type: TypeHelper.ToNullable(propertyValue.Type)),
                        ifFalse: nullablePropertyValue);
                }
                else
                {
                    propertyValue = nullablePropertyValue;
                }

                includedProperties.Add(new NamedPropertyExpression(propertyName, propertyValue));
            }
        }

        private static SelectExpandClause GetOrCreateSelectExpandClause(IEdmNavigationProperty navigationProperty, ExpandedReferenceSelectItem expandedItem)
        {
            // for normal $expand=....
            if (expandedItem is ExpandedNavigationSelectItem expandNavigationSelectItem)
            {
                return expandNavigationSelectItem.SelectAndExpand;
            }

            // for $expand=..../$ref, just includes the keys properties
            IList<SelectItem> selectItems = new List<SelectItem>();
            foreach (IEdmStructuralProperty keyProperty in navigationProperty.ToEntityType().Key())
            {
                selectItems.Add(new PathSelectItem(new ODataSelectPath(new PropertySegment(keyProperty))));
            }

            return new SelectExpandClause(selectItems, false);
        }

        private Expression AddOrderByQueryForSource(Expression source, OrderByClause orderbyClause, Type elementType)
        {
            if (orderbyClause != null)
            {
                // TODO: Implement proper support for $select/$expand after $apply
                ODataQuerySettings querySettings = new ODataQuerySettings()
                {
                    HandleNullPropagation = HandleNullPropagationOption.True,
                };

                LambdaExpression orderByExpression =
                    FilterBinder.Bind(null, orderbyClause, elementType, _context, querySettings);
                source = ExpressionHelpers.OrderBy(source, orderByExpression, elementType, orderbyClause.Direction);
            }

            return source;
        }

        private static Expression GetNullCheckExpression(IEdmStructuralProperty propertyToInclude, Expression propertyValue,
            SelectExpandClause projection)
        {
            if (projection == null || propertyToInclude.Type.IsCollection())
            {
                return null;
            }

            if (IsSelectAll(projection) && propertyToInclude.Type.IsComplex())
            {
                // for Collections (Primitive, Enum, Complex collection), that's check above.	
                return Expression.Equal(propertyValue, Expression.Constant(null));
            }

            return null;
        }

        private Expression GetNullCheckExpression(IEdmNavigationProperty propertyToExpand, Expression propertyValue,
            SelectExpandClause projection)
        {
            if (projection == null || propertyToExpand.Type.IsCollection())
            {
                return null;
            }

            if (IsSelectAll(projection) || !propertyToExpand.ToEntityType().Key().Any())
            {
                return Expression.Equal(propertyValue, Expression.Constant(null));
            }

            Expression keysNullCheckExpression = null;
            foreach (var key in propertyToExpand.ToEntityType().Key())
            {
                var propertyValueExpression = CreatePropertyValueExpression(propertyToExpand.ToEntityType(), key, propertyValue, filterClause: null);
                var keyExpression = Expression.Equal(
                    propertyValueExpression,
                    Expression.Constant(null, propertyValueExpression.Type));

                keysNullCheckExpression = keysNullCheckExpression == null
                    ? keyExpression
                    : Expression.And(keysNullCheckExpression, keyExpression);
            }

            return keysNullCheckExpression;
        }

        // new CollectionWrapper<ElementType> { Instance = source.Select((ElementType element) => new Wrapper { }) }
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        private Expression ProjectCollection(Expression source, Type elementType,
            SelectExpandClause selectExpandClause, IEdmStructuredType structuredType, IEdmNavigationSource navigationSource,
            OrderByClause orderByClause,
            long? topOption,
            long? skipOption,
            int? modelBoundPageSize)
        {
            // structuralType could be null, because it can be primitive collection.

            ParameterExpression element = Expression.Parameter(elementType, "$it");

            Expression projection;
            // expression
            //      new Wrapper { }
            if (structuredType != null)
            {
                projection = ProjectElement(element, selectExpandClause, structuredType, navigationSource);
            }
            else
            {
                projection = element;
            }

            // expression
            //      (ElementType element) => new Wrapper { }
            LambdaExpression selector = Expression.Lambda(projection, element);

            if (orderByClause != null)
            {
                source = AddOrderByQueryForSource(source, orderByClause, elementType);
            }

            bool hasTopValue = topOption != null && topOption.HasValue;
            bool hasSkipvalue = skipOption != null && skipOption.HasValue;

            if (structuredType is IEdmEntityType entityType)
            {
                if (_settings.PageSize.HasValue || modelBoundPageSize.HasValue || hasTopValue || hasSkipvalue)
                {
                    // nested paging. Need to apply order by first, and take one more than page size as we need to know
                    // whether the collection was truncated or not while generating next page links.
                    IEnumerable<IEdmStructuralProperty> properties =
                        entityType.Key().Any()
                            ? entityType.Key()
                            : entityType
                                .StructuralProperties()
                                .Where(property => property.Type.IsPrimitive() && !property.Type.IsStream())
                                .OrderBy(property => property.Name);

                    if (orderByClause == null)
                    {
                        bool alreadyOrdered = false;
                        foreach (var prop in properties)
                        {
                            source = ExpressionHelpers.OrderByPropertyExpression(source, prop.Name, elementType,
                                alreadyOrdered);
                            if (!alreadyOrdered)
                            {
                                alreadyOrdered = true;
                            }
                        }
                    }
                }
            }

            if (hasSkipvalue)
            {
                Contract.Assert(skipOption.Value <= Int32.MaxValue);
                source = ExpressionHelpers.Skip(source, (int)skipOption.Value, elementType,
                    _settings.EnableConstantParameterization);
            }

            if (hasTopValue)
            {
                Contract.Assert(topOption.Value <= Int32.MaxValue);
                source = ExpressionHelpers.Take(source, (int)topOption.Value, elementType,
                    _settings.EnableConstantParameterization);
            }

            if (_settings.PageSize.HasValue || modelBoundPageSize.HasValue || hasTopValue || hasSkipvalue)
            {
                // don't page nested collections if EnableCorrelatedSubqueryBuffering is enabled
                if (!_settings.EnableCorrelatedSubqueryBuffering)
                {
                    if (_settings.PageSize.HasValue)
                    {
                        source = ExpressionHelpers.Take(source, _settings.PageSize.Value + 1, elementType,
                            _settings.EnableConstantParameterization);
                    }
                    else if (_settings.ModelBoundPageSize.HasValue)
                    {
                        source = ExpressionHelpers.Take(source, modelBoundPageSize.Value + 1, elementType,
                            _settings.EnableConstantParameterization);
                    }
                }
            }

            // expression
            //      source.Select((ElementType element) => new Wrapper { })
            var selectMethod = GetSelectMethod(elementType, projection.Type);
            Expression selectedExpresion = Expression.Call(selectMethod, source, selector);

            // Append ToList() to collection as a hint to LINQ provider to buffer correlated subqueries in memory and avoid executing N+1 queries
            if (_settings.EnableCorrelatedSubqueryBuffering)
            {
                selectedExpresion = Expression.Call(ExpressionHelperMethods.QueryableToList.MakeGenericMethod(projection.Type), selectedExpresion);
            }

            if (_settings.HandleNullPropagation == HandleNullPropagationOption.True)
            {
                // source == null ? null : projectedCollection
                return Expression.Condition(
                       test: Expression.Equal(source, Expression.Constant(null)),
                       ifTrue: Expression.Constant(null, selectedExpresion.Type),
                       ifFalse: selectedExpresion);
            }
            else
            {
                return selectedExpresion;
            }
        }

        // OData formatter requires the type name of the entity that is being written if the type has derived types.
        // Expression
        //      source is GrandChild ? "GrandChild" : ( source is Child ? "Child" : "Root" )
        // Notice that the order is important here. The most derived type must be the first to check.
        // If entity framework had a way to figure out the type name without selecting the whole object, we don't have to do this magic.
        internal static Expression CreateTypeNameExpression(Expression source, IEdmStructuredType elementType, IEdmModel model)
        {
            IReadOnlyList<IEdmStructuredType> derivedTypes = GetAllDerivedTypes(elementType, model);
            if (derivedTypes.Count == 0)
            {
                // no inheritance.
                return null;
            }
            else
            {
                Expression expression = Expression.Constant(elementType.FullTypeName());
                for (int i = 0; i < derivedTypes.Count; i++)
                {
                    Type clrType = EdmLibHelpers.GetClrType(derivedTypes[i], model);
                    if (clrType == null)
                    {
                        throw new ODataException(Error.Format(SRResources.MappingDoesNotContainResourceType, derivedTypes[0].FullTypeName()));
                    }

                    expression = Expression.Condition(
                        test: Expression.TypeIs(source, clrType),
                        ifTrue: Expression.Constant(derivedTypes[i].FullTypeName()),
                        ifFalse: expression);
                }

                return expression;
            }
        }

        // returns all the derived types (direct and indirect) of baseType ordered according to their depth. The direct children
        // are the first in the list.
        private static IReadOnlyList<IEdmStructuredType> GetAllDerivedTypes(IEdmStructuredType baseType, IEdmModel model)
        {
            IEnumerable<IEdmStructuredType> allStructuredTypes = model.SchemaElements.OfType<IEdmStructuredType>();

            List<Tuple<int, IEdmStructuredType>> derivedTypes = new List<Tuple<int, IEdmStructuredType>>();
            foreach (IEdmStructuredType structuredType in allStructuredTypes)
            {
                int distance = IsDerivedTypeOf(structuredType, baseType);
                if (distance > 0)
                {
                    derivedTypes.Add(Tuple.Create(distance, structuredType));
                }
            }

            return derivedTypes.OrderBy(tuple => tuple.Item1).Select(tuple => tuple.Item2).ToList();
        }

        // returns -1 if type does not derive from baseType and a positive number representing the distance
        // between them if it does.
        private static int IsDerivedTypeOf(IEdmStructuredType type, IEdmStructuredType baseType)
        {
            int distance = 0;
            while (type != null)
            {
                if (baseType == type)
                {
                    return distance;
                }

                type = type.BaseType();
                distance++;
            }

            return -1;
        }

        private static MethodInfo GetSelectMethod(Type elementType, Type resultType)
        {
            return ExpressionHelperMethods.EnumerableSelectGeneric.MakeGenericMethod(elementType, resultType);
        }

        private static bool IsSelectAll(SelectExpandClause selectExpandClause)
        {
            if (selectExpandClause == null)
            {
                return true;
            }

            if (selectExpandClause.AllSelected || selectExpandClause.SelectedItems.OfType<WildcardSelectItem>().Any())
            {
                return true;
            }

            return false;
        }

        private static Type GetWrapperGenericType(bool isInstancePropertySet, bool isTypeNamePropertySet, bool isContainerPropertySet)
        {
            if (isInstancePropertySet)
            {
                // select all
                Contract.Assert(!isTypeNamePropertySet, "we don't set type name if we set instance as it can be figured from instance");

                return isContainerPropertySet ? typeof(SelectAllAndExpand<>) : typeof(SelectAll<>);
            }
            else
            {
                Contract.Assert(isContainerPropertySet, "if it is not select all, container should hold something");

                return isTypeNamePropertySet ? typeof(SelectSomeAndInheritance<>) : typeof(SelectSome<>);
            }
        }

        private class ReferenceNavigationPropertyExpandFilterVisitor : ExpressionVisitor
        {
            private Expression _source;
            private ParameterExpression _parameterExpression;

            public ReferenceNavigationPropertyExpandFilterVisitor(ParameterExpression parameterExpression, Expression source)
            {
                _source = source;
                _parameterExpression = parameterExpression;
            }

            protected override Expression VisitParameter(ParameterExpression node)
            {
                if (node != _parameterExpression)
                {
                    throw new ODataException(Error.Format(SRResources.ReferenceNavigationPropertyExpandFilterVisitorUnexpectedParameter, node.Name));
                }

                return _source;
            }
        }

        /* Entityframework requires that the two different type initializers for a given type in the same query have the
        same set of properties in the same order.

        A ~/People?$select=Name&$expand=Friend results in a select expression that has two SelectExpandWrapper<Person>
        expressions, one for the root level person and the second for the expanded Friend person.
        The first wrapper has the Container property set (contains Name and Friend values) where as the second wrapper
        has the Instance property set as it contains all the properties of the expanded person.

        The below four classes workaround that entity framework limitation by defining a seperate type for each
        property selection combination possible. */

        private class SelectAllAndExpand<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectAll<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectSomeAndInheritance<TEntity> : SelectExpandWrapper<TEntity>
        {
        }

        private class SelectSome<TEntity> : SelectAllAndExpand<TEntity>
        {
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Query\Expressions\SelectExpandBinder.cs(504,36): error CS0165: Use of unassigned local variable 'firstNavigationPropertySegment'
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmTypeBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Query;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Builder
{
    /// <summary>
    /// <see cref="EdmTypeBuilder"/> builds <see cref="IEdmType"/>'s from <see cref="StructuralTypeConfiguration"/>'s.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable")]
    internal class EdmTypeBuilder
    {
        private readonly List<IEdmTypeConfiguration> _configurations;
        private readonly Dictionary<Type, IEdmType> _types = new Dictionary<Type, IEdmType>();
        private readonly Dictionary<PropertyInfo, IEdmProperty> _properties = new Dictionary<PropertyInfo, IEdmProperty>();
        private readonly Dictionary<IEdmProperty, QueryableRestrictions> _propertiesRestrictions = new Dictionary<IEdmProperty, QueryableRestrictions>();
        private readonly Dictionary<IEdmProperty, ModelBoundQuerySettings> _propertiesQuerySettings = new Dictionary<IEdmProperty, ModelBoundQuerySettings>();
        private readonly Dictionary<IEdmProperty, PropertyConfiguration> _propertyConfigurations = new Dictionary<IEdmProperty, PropertyConfiguration>();
        private readonly Dictionary<IEdmStructuredType, ModelBoundQuerySettings> _structuredTypeQuerySettings = new Dictionary<IEdmStructuredType, ModelBoundQuerySettings>();
        private readonly Dictionary<Enum, IEdmEnumMember> _members = new Dictionary<Enum, IEdmEnumMember>();
        private readonly Dictionary<IEdmStructuredType, PropertyInfo> _openTypes = new Dictionary<IEdmStructuredType, PropertyInfo>();
        private readonly Dictionary<IEdmStructuredType, PropertyInfo> _instanceAnnotableTypes = new Dictionary<IEdmStructuredType, PropertyInfo>();

        internal EdmTypeBuilder(IEnumerable<IEdmTypeConfiguration> configurations)
        {
            _configurations = configurations.ToList();
        }

        private Dictionary<Type, IEdmType> GetEdmTypes()
        {
            // Reset
            _types.Clear();
            _properties.Clear();
            _members.Clear();
            _openTypes.Clear();
            _propertyConfigurations.Clear();
            _instanceAnnotableTypes.Clear();

            // Create headers to allow CreateEdmTypeBody to blindly references other things.
            foreach (IEdmTypeConfiguration config in _configurations)
            {
                CreateEdmTypeHeader(config);
            }

            foreach (IEdmTypeConfiguration config in _configurations)
            {
                CreateEdmTypeBody(config);
            }

            foreach (StructuralTypeConfiguration structrual in _configurations.OfType<StructuralTypeConfiguration>())
            {
                CreateNavigationProperty(structrual);
            }

            return _types;
        }

        private void CreateEdmTypeHeader(IEdmTypeConfiguration config)
        {
            IEdmType edmType = GetEdmType(config.ClrType);
            if (edmType == null)
            {
                if (config.Kind == EdmTypeKind.Complex)
                {
                    ComplexTypeConfiguration complex = (ComplexTypeConfiguration)config;
                    IEdmComplexType baseType = null;
                    if (complex.BaseType != null)
                    {
                        CreateEdmTypeHeader(complex.BaseType);
                        baseType = GetEdmType(complex.BaseType.ClrType) as IEdmComplexType;

                        Contract.Assert(baseType != null);
                    }

                    EdmComplexType complexType = new EdmComplexType(config.Namespace, config.Name,
                        baseType, complex.IsAbstract ?? false, complex.IsOpen);

                    _types.Add(config.ClrType, complexType);

                    if (complex.IsOpen)
                    {
                        // add a mapping between the open complex type and its dynamic property dictionary.
                        _openTypes.Add(complexType, complex.DynamicPropertyDictionary);
                    }

                    if (complex.SupportsInstanceAnnotations)
                    {
                        // add a mapping between the complex type and its instance annotation dictionary.
                        _instanceAnnotableTypes.Add(complexType, complex.InstanceAnnotationsContainer);
                    }

                    edmType = complexType;
                }
                else if (config.Kind == EdmTypeKind.Entity)
                {
                    EntityTypeConfiguration entity = config as EntityTypeConfiguration;
                    Contract.Assert(entity != null);

                    IEdmEntityType baseType = null;
                    if (entity.BaseType != null)
                    {
                        CreateEdmTypeHeader(entity.BaseType);
                        baseType = GetEdmType(entity.BaseType.ClrType) as IEdmEntityType;

                        Contract.Assert(baseType != null);
                    }

                    EdmEntityType entityType = new EdmEntityType(config.Namespace, config.Name, baseType,
                        entity.IsAbstract ?? false, entity.IsOpen, entity.HasStream);
                    _types.Add(config.ClrType, entityType);

                    if (entity.IsOpen)
                    {
                        // add a mapping between the open entity type and its dynamic property dictionary.
                        _openTypes.Add(entityType, entity.DynamicPropertyDictionary);
                    }

                    if (entity.SupportsInstanceAnnotations)
                    {
                        // add a mapping between the entity type and its instance annotation dictionary.
                        _instanceAnnotableTypes.Add(entityType, entity.InstanceAnnotationsContainer);
                    }

                    edmType = entityType;
                }
                else
                {
                    EnumTypeConfiguration enumTypeConfiguration = config as EnumTypeConfiguration;

                    // The config has to be enum.
                    Contract.Assert(enumTypeConfiguration != null);

                    _types.Add(enumTypeConfiguration.ClrType,
                        new EdmEnumType(enumTypeConfiguration.Namespace, enumTypeConfiguration.Name,
                            GetTypeKind(enumTypeConfiguration.UnderlyingType), enumTypeConfiguration.IsFlags));
                }
            }

            IEdmStructuredType structuredType = edmType as IEdmStructuredType;
            StructuralTypeConfiguration structuralTypeConfiguration = config as StructuralTypeConfiguration;
            if (structuredType != null && structuralTypeConfiguration != null &&
                !_structuredTypeQuerySettings.ContainsKey(structuredType))
            {
                ModelBoundQuerySettings querySettings =
                    structuralTypeConfiguration.QueryConfiguration.ModelBoundQuerySettings;
                if (querySettings != null)
                {
                    _structuredTypeQuerySettings.Add(structuredType,
                        structuralTypeConfiguration.QueryConfiguration.ModelBoundQuerySettings);
                }
            }
        }

        private void CreateEdmTypeBody(IEdmTypeConfiguration config)
        {
            IEdmType edmType = GetEdmType(config.ClrType);

            if (edmType.TypeKind == EdmTypeKind.Complex)
            {
                CreateComplexTypeBody((EdmComplexType)edmType, (ComplexTypeConfiguration)config);
            }
            else if (edmType.TypeKind == EdmTypeKind.Entity)
            {
                CreateEntityTypeBody((EdmEntityType)edmType, (EntityTypeConfiguration)config);
            }
            else
            {
                Contract.Assert(edmType.TypeKind == EdmTypeKind.Enum);
                CreateEnumTypeBody((EdmEnumType)edmType, (EnumTypeConfiguration)config);
            }
        }

        private static IEdmTypeReference AddPrecisionConfigInPrimitiveTypeReference(
            PrecisionPropertyConfiguration precisionProperty,
            IEdmTypeReference primitiveTypeReference)
        {
            if (primitiveTypeReference is EdmTemporalTypeReference && precisionProperty.Precision.HasValue)
            {
                return new EdmTemporalTypeReference(
                    (IEdmPrimitiveType)primitiveTypeReference.Definition,
                    primitiveTypeReference.IsNullable,
                    precisionProperty.Precision);
            }
            return primitiveTypeReference;
        }

        private static IEdmTypeReference AddLengthConfigInPrimitiveTypeReference(
            LengthPropertyConfiguration lengthProperty,
            IEdmTypeReference primitiveTypeReference)
        {
            if (lengthProperty.MaxLength.HasValue)
            {
                if (primitiveTypeReference is EdmStringTypeReference)
                {
                    return new EdmStringTypeReference(
                        (IEdmPrimitiveType)primitiveTypeReference.Definition,
                        primitiveTypeReference.IsNullable,
                        false,
                        lengthProperty.MaxLength,
                        true);
                }
                if (primitiveTypeReference is EdmBinaryTypeReference)
                {
                    return new EdmBinaryTypeReference(
                        (IEdmPrimitiveType)primitiveTypeReference.Definition,
                        primitiveTypeReference.IsNullable,
                        false,
                        lengthProperty.MaxLength);
                }
            }
            return primitiveTypeReference;
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable")]
        private void CreateStructuralTypeBody(EdmStructuredType type, StructuralTypeConfiguration config)
        {
            foreach (PropertyConfiguration property in config.Properties)
            {
                IEdmProperty edmProperty = null;

                switch (property.Kind)
                {
                    case PropertyKind.Primitive:
                        PrimitivePropertyConfiguration primitiveProperty = (PrimitivePropertyConfiguration)property;
                        EdmPrimitiveTypeKind typeKind = primitiveProperty.TargetEdmTypeKind ??
                                                        GetTypeKind(primitiveProperty.PropertyInfo.PropertyType);
                        IEdmTypeReference primitiveTypeReference = EdmCoreModel.Instance.GetPrimitive(
                            typeKind,
                            primitiveProperty.OptionalProperty);

                        if (typeKind == EdmPrimitiveTypeKind.Decimal)
                        {
                            DecimalPropertyConfiguration decimalProperty =
                                primitiveProperty as DecimalPropertyConfiguration;
                            if (decimalProperty.Precision.HasValue || decimalProperty.Scale.HasValue)
                            {
                                primitiveTypeReference = new EdmDecimalTypeReference(
                                    (IEdmPrimitiveType)primitiveTypeReference.Definition,
                                    primitiveTypeReference.IsNullable,
                                    decimalProperty.Precision,
                                    decimalProperty.Scale.HasValue ? decimalProperty.Scale : 0);
                            }
                        }
                        else if (EdmLibHelpers.HasPrecision(typeKind))
                        {
                            PrecisionPropertyConfiguration precisionProperty =
                                primitiveProperty as PrecisionPropertyConfiguration;
                            primitiveTypeReference = AddPrecisionConfigInPrimitiveTypeReference(
                                precisionProperty,
                                primitiveTypeReference);
                        }
                        else if (EdmLibHelpers.HasLength(typeKind))
                        {
                            LengthPropertyConfiguration lengthProperty =
                                primitiveProperty as LengthPropertyConfiguration;
                            primitiveTypeReference = AddLengthConfigInPrimitiveTypeReference(
                                lengthProperty,
                                primitiveTypeReference);
                        }
                        edmProperty = type.AddStructuralProperty(
                            primitiveProperty.Name,
                            primitiveTypeReference,
                            defaultValue: primitiveProperty.DefaultValueString);
                        break;

                    case PropertyKind.Complex:
                        ComplexPropertyConfiguration complexProperty = property as ComplexPropertyConfiguration;
                        IEdmComplexType complexType = GetEdmType(complexProperty.RelatedClrType) as IEdmComplexType;

                        edmProperty = type.AddStructuralProperty(
                            complexProperty.Name,
                            new EdmComplexTypeReference(complexType, complexProperty.OptionalProperty));
                        break;

                    case PropertyKind.Collection:
                        edmProperty = CreateStructuralTypeCollectionPropertyBody(type, (CollectionPropertyConfiguration)property);
                        break;

                    case PropertyKind.Enum:
                        edmProperty = CreateStructuralTypeEnumPropertyBody(type, (EnumPropertyConfiguration)property);
                        break;

                    default:
                        break;
                }

                if (edmProperty != null)
                {
                    if (property.PropertyInfo != null)
                    {
                        _properties[property.PropertyInfo] = edmProperty;
                    }

                    if (property.IsRestricted)
                    {
                        _propertiesRestrictions[edmProperty] = new QueryableRestrictions(property);
                    }

                    if (property.QueryConfiguration.ModelBoundQuerySettings != null)
                    {
                        _propertiesQuerySettings.Add(edmProperty, property.QueryConfiguration.ModelBoundQuerySettings);
                    }

                    _propertyConfigurations[edmProperty] = property;
                }
            }
        }

        private IEdmProperty CreateStructuralTypeCollectionPropertyBody(EdmStructuredType type, CollectionPropertyConfiguration collectionProperty)
        {
            IEdmTypeReference elementTypeReference = null;
            Type clrType = TypeHelper.GetUnderlyingTypeOrSelf(collectionProperty.ElementType);

            if (TypeHelper.IsEnum(clrType))
            {
                IEdmType edmType = GetEdmType(clrType);

                if (edmType == null)
                {
                    throw Error.InvalidOperation(SRResources.EnumTypeDoesNotExist, clrType.Name);
                }

                IEdmEnumType enumElementType = (IEdmEnumType)edmType;
                bool isNullable = collectionProperty.ElementType != clrType;
                elementTypeReference = new EdmEnumTypeReference(enumElementType, isNullable);
            }
            else
            {
                IEdmType edmType = GetEdmType(collectionProperty.ElementType);
                if (edmType != null)
                {
                    IEdmComplexType elementType = edmType as IEdmComplexType;
                    Contract.Assert(elementType != null);
                    elementTypeReference = new EdmComplexTypeReference(elementType, collectionProperty.OptionalProperty);
                }
                else
                {
                    elementTypeReference =
                        EdmLibHelpers.GetEdmPrimitiveTypeReferenceOrNull(collectionProperty.ElementType);
                    Contract.Assert(elementTypeReference != null);
                }
            }

            return type.AddStructuralProperty(
                collectionProperty.Name,
                new EdmCollectionTypeReference(new EdmCollectionType(elementTypeReference)));
        }

        private IEdmProperty CreateStructuralTypeEnumPropertyBody(EdmStructuredType type, EnumPropertyConfiguration enumProperty)
        {
            Type enumPropertyType = TypeHelper.GetUnderlyingTypeOrSelf(enumProperty.RelatedClrType);
            IEdmType edmType = GetEdmType(enumPropertyType);

            if (edmType == null)
            {
                throw Error.InvalidOperation(SRResources.EnumTypeDoesNotExist, enumPropertyType.Name);
            }

            IEdmEnumType enumType = (IEdmEnumType)edmType;
            IEdmTypeReference enumTypeReference = new EdmEnumTypeReference(enumType, enumProperty.OptionalProperty);

            return type.AddStructuralProperty(
                enumProperty.Name,
                enumTypeReference,
                defaultValue: enumProperty.DefaultValueString);
        }

        private void CreateComplexTypeBody(EdmComplexType type, ComplexTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            CreateStructuralTypeBody(type, config);
        }

        private void CreateEntityTypeBody(EdmEntityType type, EntityTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            CreateStructuralTypeBody(type, config);
            var keys = ((IEnumerable<PropertyConfiguration>)config.Keys)
                                     .Concat(config.EnumKeys)
                                     .OrderBy(p => p.Order)
                                     .ThenBy(p => p.Name)
                                     .Select(p => type.DeclaredProperties.OfType<IEdmStructuralProperty>().First(dp => dp.Name == p.Name));
            type.AddKeys(keys);
        }

        private void CreateNavigationProperty(StructuralTypeConfiguration config)
        {
            Contract.Assert(config != null);

            EdmStructuredType type = (EdmStructuredType)(GetEdmType(config.ClrType));

            foreach (NavigationPropertyConfiguration navProp in config.NavigationProperties)
            {
                Func<NavigationPropertyConfiguration, EdmNavigationPropertyInfo> getInfo = nav =>
                {
                    EdmNavigationPropertyInfo info = new EdmNavigationPropertyInfo
                    {
                        Name = nav.Name,
                        TargetMultiplicity = nav.Multiplicity,
                        Target = GetEdmType(nav.RelatedClrType) as IEdmEntityType,
                        ContainsTarget = nav.ContainsTarget,
                        OnDelete = nav.OnDeleteAction
                    };

                    // Principal properties
                    if (nav.PrincipalProperties.Any())
                    {
                        info.PrincipalProperties = GetDeclaringPropertyInfo(nav.PrincipalProperties);
                    }

                    // Dependent properties
                    if (nav.DependentProperties.Any())
                    {
                        info.DependentProperties = GetDeclaringPropertyInfo(nav.DependentProperties);
                    }

                    return info;
                };

                var navInfo = getInfo(navProp);
                var props = new Dictionary<IEdmProperty, NavigationPropertyConfiguration>();
                EdmEntityType entityType = type as EdmEntityType;
                if (entityType != null && navProp.Partner != null)
                {
                    var edmProperty = entityType.AddBidirectionalNavigation(navInfo, getInfo(navProp.Partner));
                    var partnerEdmProperty = (navInfo.Target as EdmEntityType).Properties().Single(p => p.Name == navProp.Partner.Name);
                    props.Add(edmProperty, navProp);
                    props.Add(partnerEdmProperty, navProp.Partner);
                }
                else
                {
                    // Do not add this if we have have a partner relationship configured, as this
                    // property will be added automatically through the AddBidirectionalNavigation
                    var targetConfig = config.ModelBuilder.GetTypeConfigurationOrNull(navProp.RelatedClrType) as StructuralTypeConfiguration;
                    if (!targetConfig.NavigationProperties.Any(p => p.Partner != null && p.Partner.Name == navInfo.Name))
                    {
                        var edmProperty = type.AddUnidirectionalNavigation(navInfo);
                        props.Add(edmProperty, navProp);
                    }
                }

                foreach (var item in props)
                {
                    var edmProperty = item.Key;
                    var prop = item.Value;
                    if (prop.PropertyInfo != null)
                    {
                        _properties[prop.PropertyInfo] = edmProperty;
                    }

                    if (prop.IsRestricted)
                    {
                        _propertiesRestrictions[edmProperty] = new QueryableRestrictions(prop);
                    }

                    if (prop.QueryConfiguration.ModelBoundQuerySettings != null)
                    {
                        _propertiesQuerySettings.Add(edmProperty, prop.QueryConfiguration.ModelBoundQuerySettings);
                    }

                    _propertyConfigurations[edmProperty] = prop;
                }
            }
        }

        private IList<IEdmStructuralProperty> GetDeclaringPropertyInfo(IEnumerable<PropertyInfo> propertyInfos)
        {
            IList<IEdmProperty> edmProperties = new List<IEdmProperty>();
            foreach (PropertyInfo propInfo in propertyInfos)
            {
                IEdmProperty edmProperty;
                if (_properties.TryGetValue(propInfo, out edmProperty))
                {
                    edmProperties.Add(edmProperty);
                }
                else
                {
                    Contract.Assert(TypeHelper.GetReflectedType(propInfo) != null);
                    Type baseType = TypeHelper.GetBaseType(TypeHelper.GetReflectedType(propInfo));
                    while (baseType != null)
                    {
                        PropertyInfo basePropInfo = baseType.GetProperty(propInfo.Name);
                        if (_properties.TryGetValue(basePropInfo, out edmProperty))
                        {
                            edmProperties.Add(edmProperty);
                            break;
                        }

                        baseType = TypeHelper.GetBaseType(baseType);
                    }

                    Contract.Assert(baseType != null);
                }
            }

            return edmProperties.OfType<IEdmStructuralProperty>().ToList();
        }

        private void CreateEnumTypeBody(EdmEnumType type, EnumTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            foreach (EnumMemberConfiguration member in config.Members)
            {
                // EdmIntegerConstant can only support a value of long type.
                long value;
                try
                {
                    value = Convert.ToInt64(member.MemberInfo, CultureInfo.InvariantCulture);
                }
                catch
                {
                    throw Error.Argument("value", SRResources.EnumValueCannotBeLong, Enum.GetName(member.MemberInfo.GetType(), member.MemberInfo));
                }

                EdmEnumMember edmMember = new EdmEnumMember(type, member.Name,
                    new EdmEnumMemberValue(value));
                type.AddMember(edmMember);
                _members[member.MemberInfo] = edmMember;
            }
        }

        private IEdmType GetEdmType(Type clrType)
        {
            Contract.Assert(clrType != null);

            IEdmType edmType;
            _types.TryGetValue(clrType, out edmType);

            return edmType;
        }

        /// <summary>
        /// Builds <see cref="IEdmType"/> and <see cref="IEdmProperty"/>'s from <paramref name="configurations"/>
        /// </summary>
        /// <param name="configurations">A collection of <see cref="IEdmTypeConfiguration"/>'s</param>
        /// <returns>The built dictionary of <see cref="StructuralTypeConfiguration"/>'s indexed by their backing CLR type,
        /// and dictionary of <see cref="StructuralTypeConfiguration"/>'s indexed by their backing CLR property info</returns>
        public static EdmTypeMap GetTypesAndProperties(IEnumerable<IEdmTypeConfiguration> configurations)
        {
            if (configurations == null)
            {
                throw Error.ArgumentNull("configurations");
            }

            EdmTypeBuilder builder = new EdmTypeBuilder(configurations);
            return new EdmTypeMap(builder.GetEdmTypes(),
                builder._properties,
                builder._propertiesRestrictions,
                builder._propertiesQuerySettings,
                builder._structuredTypeQuerySettings,
                builder._members,
                builder._openTypes,
                builder._propertyConfigurations,
                builder._instanceAnnotableTypes);
        }

        /// <summary>
        /// Gets the <see cref="EdmPrimitiveTypeKind"/> that maps to the <see cref="Type"/>
        /// </summary>
        /// <param name="clrType">The clr type</param>
        /// <returns>The corresponding Edm primitive kind.</returns>
        public static EdmPrimitiveTypeKind GetTypeKind(Type clrType)
        {
            IEdmPrimitiveType primitiveType = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(clrType);
            if (primitiveType == null)
            {
                throw Error.Argument("clrType", SRResources.MustBePrimitiveType, clrType.FullName);
            }

            return primitiveType.PrimitiveKind;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter;
using Microsoft.AspNet.OData.Query;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Builder
{
    /// <summary>
    /// <see cref="EdmTypeBuilder"/> builds <see cref="IEdmType"/>'s from <see cref="StructuralTypeConfiguration"/>'s.
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable")]
    internal class EdmTypeBuilder
    {
        private readonly List<IEdmTypeConfiguration> _configurations;
        private readonly Dictionary<Type, IEdmType> _types = new Dictionary<Type, IEdmType>();
        private readonly Dictionary<PropertyInfo, IEdmProperty> _properties = new Dictionary<PropertyInfo, IEdmProperty>();
        private readonly Dictionary<IEdmProperty, QueryableRestrictions> _propertiesRestrictions = new Dictionary<IEdmProperty, QueryableRestrictions>();
        private readonly Dictionary<IEdmProperty, ModelBoundQuerySettings> _propertiesQuerySettings = new Dictionary<IEdmProperty, ModelBoundQuerySettings>();
        private readonly Dictionary<IEdmProperty, PropertyConfiguration> _propertyConfigurations = new Dictionary<IEdmProperty, PropertyConfiguration>();
        private readonly Dictionary<IEdmStructuredType, ModelBoundQuerySettings> _structuredTypeQuerySettings = new Dictionary<IEdmStructuredType, ModelBoundQuerySettings>();
        private readonly Dictionary<Enum, IEdmEnumMember> _members = new Dictionary<Enum, IEdmEnumMember>();
        private readonly Dictionary<IEdmStructuredType, PropertyInfo> _openTypes = new Dictionary<IEdmStructuredType, PropertyInfo>();
        private readonly Dictionary<IEdmStructuredType, PropertyInfo> _instanceAnnotableTypes = new Dictionary<IEdmStructuredType, PropertyInfo>();

        internal EdmTypeBuilder(IEnumerable<IEdmTypeConfiguration> configurations)
        {
            _configurations = configurations.ToList();
        }

        private Dictionary<Type, IEdmType> GetEdmTypes()
        {
            // Reset
            _types.Clear();
            _properties.Clear();
            _members.Clear();
            _openTypes.Clear();
            _propertyConfigurations.Clear();
            _instanceAnnotableTypes.Clear();

            // Create headers to allow CreateEdmTypeBody to blindly references other things.
            foreach (IEdmTypeConfiguration config in _configurations)
            {
                CreateEdmTypeHeader(config);
            }

            foreach (IEdmTypeConfiguration config in _configurations)
            {
                CreateEdmTypeBody(config);
            }

            foreach (StructuralTypeConfiguration structrual in _configurations.OfType<StructuralTypeConfiguration>())
            {
                CreateNavigationProperty(structrual);
            }

            return _types;
        }

        private void CreateEdmTypeHeader(IEdmTypeConfiguration config)
        {
            IEdmType edmType = GetEdmType(config.ClrType);
            if (edmType == null)
            {
                if (config.Kind == EdmTypeKind.Complex)
                {
                    ComplexTypeConfiguration complex = (ComplexTypeConfiguration)config;
                    IEdmComplexType baseType = null;
                    if (complex.BaseType != null)
                    {
                        CreateEdmTypeHeader(complex.BaseType);
                        baseType = GetEdmType(complex.BaseType.ClrType) as IEdmComplexType;

                        Contract.Assert(baseType != null);
                    }

                    EdmComplexType complexType = new EdmComplexType(config.Namespace, config.Name,
                        baseType, complex.IsAbstract ?? false, complex.IsOpen);

                    _types.Add(config.ClrType, complexType);

                    if (complex.IsOpen)
                    {
                        // add a mapping between the open complex type and its dynamic property dictionary.
                        _openTypes.Add(complexType, complex.DynamicPropertyDictionary);
                    }

                    if (complex.SupportsInstanceAnnotations)
                    {
                        // add a mapping between the complex type and its instance annotation dictionary.
                        _instanceAnnotableTypes.Add(complexType, complex.InstanceAnnotationsContainer);
                    }

                    edmType = complexType;
                }
                else if (config.Kind == EdmTypeKind.Entity)
                {
                    Contract.Assert(config is EntityTypeConfiguration entity);

                    IEdmEntityType baseType = null;
                    if (entity.BaseType != null)
                    {
                        CreateEdmTypeHeader(entity.BaseType);
                        baseType = GetEdmType(entity.BaseType.ClrType) as IEdmEntityType;

                        Contract.Assert(baseType != null);
                    }

                    EdmEntityType entityType = new EdmEntityType(config.Namespace, config.Name, baseType,
                        entity.IsAbstract ?? false, entity.IsOpen, entity.HasStream);
                    _types.Add(config.ClrType, entityType);

                    if (entity.IsOpen)
                    {
                        // add a mapping between the open entity type and its dynamic property dictionary.
                        _openTypes.Add(entityType, entity.DynamicPropertyDictionary);
                    }

                    if (entity.SupportsInstanceAnnotations)
                    {
                        // add a mapping between the entity type and its instance annotation dictionary.
                        _instanceAnnotableTypes.Add(entityType, entity.InstanceAnnotationsContainer);
                    }

                    edmType = entityType;
                }
                else
                {

                    // The config has to be enum.
                    Contract.Assert(config is EnumTypeConfiguration enumTypeConfiguration);

                    _types.Add(enumTypeConfiguration.ClrType,
                        new EdmEnumType(enumTypeConfiguration.Namespace, enumTypeConfiguration.Name,
                            GetTypeKind(enumTypeConfiguration.UnderlyingType), enumTypeConfiguration.IsFlags));
                }
            }
            if (edmType is IEdmStructuredType structuredType && config is StructuralTypeConfiguration structuralTypeConfiguration &&
                !_structuredTypeQuerySettings.ContainsKey(structuredType))
            {
                ModelBoundQuerySettings querySettings =
                    structuralTypeConfiguration.QueryConfiguration.ModelBoundQuerySettings;
                if (querySettings != null)
                {
                    _structuredTypeQuerySettings.Add(structuredType,
                        structuralTypeConfiguration.QueryConfiguration.ModelBoundQuerySettings);
                }
            }
        }

        private void CreateEdmTypeBody(IEdmTypeConfiguration config)
        {
            IEdmType edmType = GetEdmType(config.ClrType);

            if (edmType.TypeKind == EdmTypeKind.Complex)
            {
                CreateComplexTypeBody((EdmComplexType)edmType, (ComplexTypeConfiguration)config);
            }
            else if (edmType.TypeKind == EdmTypeKind.Entity)
            {
                CreateEntityTypeBody((EdmEntityType)edmType, (EntityTypeConfiguration)config);
            }
            else
            {
                Contract.Assert(edmType.TypeKind == EdmTypeKind.Enum);
                CreateEnumTypeBody((EdmEnumType)edmType, (EnumTypeConfiguration)config);
            }
        }

        private static IEdmTypeReference AddPrecisionConfigInPrimitiveTypeReference(
            PrecisionPropertyConfiguration precisionProperty,
            IEdmTypeReference primitiveTypeReference)
        {
            if (primitiveTypeReference is EdmTemporalTypeReference && precisionProperty.Precision.HasValue)
            {
                return new EdmTemporalTypeReference(
                    (IEdmPrimitiveType)primitiveTypeReference.Definition,
                    primitiveTypeReference.IsNullable,
                    precisionProperty.Precision);
            }
            return primitiveTypeReference;
        }

        private static IEdmTypeReference AddLengthConfigInPrimitiveTypeReference(
            LengthPropertyConfiguration lengthProperty,
            IEdmTypeReference primitiveTypeReference)
        {
            if (lengthProperty.MaxLength.HasValue)
            {
                if (primitiveTypeReference is EdmStringTypeReference)
                {
                    return new EdmStringTypeReference(
                        (IEdmPrimitiveType)primitiveTypeReference.Definition,
                        primitiveTypeReference.IsNullable,
                        false,
                        lengthProperty.MaxLength,
                        true);
                }
                if (primitiveTypeReference is EdmBinaryTypeReference)
                {
                    return new EdmBinaryTypeReference(
                        (IEdmPrimitiveType)primitiveTypeReference.Definition,
                        primitiveTypeReference.IsNullable,
                        false,
                        lengthProperty.MaxLength);
                }
            }
            return primitiveTypeReference;
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Class coupling acceptable")]
        private void CreateStructuralTypeBody(EdmStructuredType type, StructuralTypeConfiguration config)
        {
            foreach (PropertyConfiguration property in config.Properties)
            {
                IEdmProperty edmProperty = null;

                switch (property.Kind)
                {
                    case PropertyKind.Primitive:
                        PrimitivePropertyConfiguration primitiveProperty = (PrimitivePropertyConfiguration)property;
                        EdmPrimitiveTypeKind typeKind = primitiveProperty.TargetEdmTypeKind ??
                                                        GetTypeKind(primitiveProperty.PropertyInfo.PropertyType);
                        IEdmTypeReference primitiveTypeReference = EdmCoreModel.Instance.GetPrimitive(
                            typeKind,
                            primitiveProperty.OptionalProperty);

                        if (typeKind == EdmPrimitiveTypeKind.Decimal)
                        {
                            DecimalPropertyConfiguration decimalProperty =
                                primitiveProperty as DecimalPropertyConfiguration;
                            if (decimalProperty.Precision.HasValue || decimalProperty.Scale.HasValue)
                            {
                                primitiveTypeReference = new EdmDecimalTypeReference(
                                    (IEdmPrimitiveType)primitiveTypeReference.Definition,
                                    primitiveTypeReference.IsNullable,
                                    decimalProperty.Precision,
                                    decimalProperty.Scale.HasValue ? decimalProperty.Scale : 0);
                            }
                        }
                        else if (EdmLibHelpers.HasPrecision(typeKind))
                        {
                            PrecisionPropertyConfiguration precisionProperty =
                                primitiveProperty as PrecisionPropertyConfiguration;
                            primitiveTypeReference = AddPrecisionConfigInPrimitiveTypeReference(
                                precisionProperty,
                                primitiveTypeReference);
                        }
                        else if (EdmLibHelpers.HasLength(typeKind))
                        {
                            LengthPropertyConfiguration lengthProperty =
                                primitiveProperty as LengthPropertyConfiguration;
                            primitiveTypeReference = AddLengthConfigInPrimitiveTypeReference(
                                lengthProperty,
                                primitiveTypeReference);
                        }
                        edmProperty = type.AddStructuralProperty(
                            primitiveProperty.Name,
                            primitiveTypeReference,
                            defaultValue: primitiveProperty.DefaultValueString);
                        break;

                    case PropertyKind.Complex:
                        ComplexPropertyConfiguration complexProperty = property as ComplexPropertyConfiguration;
                        IEdmComplexType complexType = GetEdmType(complexProperty.RelatedClrType) as IEdmComplexType;

                        edmProperty = type.AddStructuralProperty(
                            complexProperty.Name,
                            new EdmComplexTypeReference(complexType, complexProperty.OptionalProperty));
                        break;

                    case PropertyKind.Collection:
                        edmProperty = CreateStructuralTypeCollectionPropertyBody(type, (CollectionPropertyConfiguration)property);
                        break;

                    case PropertyKind.Enum:
                        edmProperty = CreateStructuralTypeEnumPropertyBody(type, (EnumPropertyConfiguration)property);
                        break;

                    default:
                        break;
                }

                if (edmProperty != null)
                {
                    if (property.PropertyInfo != null)
                    {
                        _properties[property.PropertyInfo] = edmProperty;
                    }

                    if (property.IsRestricted)
                    {
                        _propertiesRestrictions[edmProperty] = new QueryableRestrictions(property);
                    }

                    if (property.QueryConfiguration.ModelBoundQuerySettings != null)
                    {
                        _propertiesQuerySettings.Add(edmProperty, property.QueryConfiguration.ModelBoundQuerySettings);
                    }

                    _propertyConfigurations[edmProperty] = property;
                }
            }
        }

        private IEdmProperty CreateStructuralTypeCollectionPropertyBody(EdmStructuredType type, CollectionPropertyConfiguration collectionProperty)
        {
            IEdmTypeReference elementTypeReference = null;
            Type clrType = TypeHelper.GetUnderlyingTypeOrSelf(collectionProperty.ElementType);

            if (TypeHelper.IsEnum(clrType))
            {
                IEdmType edmType = GetEdmType(clrType);

                if (edmType == null)
                {
                    throw Error.InvalidOperation(SRResources.EnumTypeDoesNotExist, clrType.Name);
                }

                IEdmEnumType enumElementType = (IEdmEnumType)edmType;
                bool isNullable = collectionProperty.ElementType != clrType;
                elementTypeReference = new EdmEnumTypeReference(enumElementType, isNullable);
            }
            else
            {
                IEdmType edmType = GetEdmType(collectionProperty.ElementType);
                if (edmType != null)
                {
                    Contract.Assert(edmType is IEdmComplexType elementType);
                    elementTypeReference = new EdmComplexTypeReference(elementType, collectionProperty.OptionalProperty);
                }
                else
                {
                    elementTypeReference =
                        EdmLibHelpers.GetEdmPrimitiveTypeReferenceOrNull(collectionProperty.ElementType);
                    Contract.Assert(elementTypeReference != null);
                }
            }

            return type.AddStructuralProperty(
                collectionProperty.Name,
                new EdmCollectionTypeReference(new EdmCollectionType(elementTypeReference)));
        }

        private IEdmProperty CreateStructuralTypeEnumPropertyBody(EdmStructuredType type, EnumPropertyConfiguration enumProperty)
        {
            Type enumPropertyType = TypeHelper.GetUnderlyingTypeOrSelf(enumProperty.RelatedClrType);
            IEdmType edmType = GetEdmType(enumPropertyType);

            if (edmType == null)
            {
                throw Error.InvalidOperation(SRResources.EnumTypeDoesNotExist, enumPropertyType.Name);
            }

            IEdmEnumType enumType = (IEdmEnumType)edmType;
            IEdmTypeReference enumTypeReference = new EdmEnumTypeReference(enumType, enumProperty.OptionalProperty);

            return type.AddStructuralProperty(
                enumProperty.Name,
                enumTypeReference,
                defaultValue: enumProperty.DefaultValueString);
        }

        private void CreateComplexTypeBody(EdmComplexType type, ComplexTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            CreateStructuralTypeBody(type, config);
        }

        private void CreateEntityTypeBody(EdmEntityType type, EntityTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            CreateStructuralTypeBody(type, config);
            var keys = ((IEnumerable<PropertyConfiguration>)config.Keys)
                                     .Concat(config.EnumKeys)
                                     .OrderBy(p => p.Order)
                                     .ThenBy(p => p.Name)
                                     .Select(p => type.DeclaredProperties.OfType<IEdmStructuralProperty>().First(dp => dp.Name == p.Name));
            type.AddKeys(keys);
        }

        private void CreateNavigationProperty(StructuralTypeConfiguration config)
        {
            Contract.Assert(config != null);

            EdmStructuredType type = (EdmStructuredType)(GetEdmType(config.ClrType));

            foreach (NavigationPropertyConfiguration navProp in config.NavigationProperties)
            {
                Func<NavigationPropertyConfiguration, EdmNavigationPropertyInfo> getInfo = nav =>
                {
                    EdmNavigationPropertyInfo info = new EdmNavigationPropertyInfo
                    {
                        Name = nav.Name,
                        TargetMultiplicity = nav.Multiplicity,
                        Target = GetEdmType(nav.RelatedClrType) as IEdmEntityType,
                        ContainsTarget = nav.ContainsTarget,
                        OnDelete = nav.OnDeleteAction
                    };

                    // Principal properties
                    if (nav.PrincipalProperties.Any())
                    {
                        info.PrincipalProperties = GetDeclaringPropertyInfo(nav.PrincipalProperties);
                    }

                    // Dependent properties
                    if (nav.DependentProperties.Any())
                    {
                        info.DependentProperties = GetDeclaringPropertyInfo(nav.DependentProperties);
                    }

                    return info;
                };

                var navInfo = getInfo(navProp);
                var props = new Dictionary<IEdmProperty, NavigationPropertyConfiguration>();

                if (type is EdmEntityType entityType && navProp.Partner != null)
                {
                    var edmProperty = entityType.AddBidirectionalNavigation(navInfo, getInfo(navProp.Partner));
                    var partnerEdmProperty = (navInfo.Target as EdmEntityType).Properties().Single(p => p.Name == navProp.Partner.Name);
                    props.Add(edmProperty, navProp);
                    props.Add(partnerEdmProperty, navProp.Partner);
                }
                else
                {
                    // Do not add this if we have have a partner relationship configured, as this
                    // property will be added automatically through the AddBidirectionalNavigation
                    var targetConfig = config.ModelBuilder.GetTypeConfigurationOrNull(navProp.RelatedClrType) as StructuralTypeConfiguration;
                    if (!targetConfig.NavigationProperties.Any(p => p.Partner != null && p.Partner.Name == navInfo.Name))
                    {
                        var edmProperty = type.AddUnidirectionalNavigation(navInfo);
                        props.Add(edmProperty, navProp);
                    }
                }

                foreach (var item in props)
                {
                    var edmProperty = item.Key;
                    var prop = item.Value;
                    if (prop.PropertyInfo != null)
                    {
                        _properties[prop.PropertyInfo] = edmProperty;
                    }

                    if (prop.IsRestricted)
                    {
                        _propertiesRestrictions[edmProperty] = new QueryableRestrictions(prop);
                    }

                    if (prop.QueryConfiguration.ModelBoundQuerySettings != null)
                    {
                        _propertiesQuerySettings.Add(edmProperty, prop.QueryConfiguration.ModelBoundQuerySettings);
                    }

                    _propertyConfigurations[edmProperty] = prop;
                }
            }
        }

        private IList<IEdmStructuralProperty> GetDeclaringPropertyInfo(IEnumerable<PropertyInfo> propertyInfos)
        {
            IList<IEdmProperty> edmProperties = new List<IEdmProperty>();
            foreach (PropertyInfo propInfo in propertyInfos)
            {
                IEdmProperty edmProperty;
                if (_properties.TryGetValue(propInfo, out edmProperty))
                {
                    edmProperties.Add(edmProperty);
                }
                else
                {
                    Contract.Assert(TypeHelper.GetReflectedType(propInfo) != null);
                    Type baseType = TypeHelper.GetBaseType(TypeHelper.GetReflectedType(propInfo));
                    while (baseType != null)
                    {
                        PropertyInfo basePropInfo = baseType.GetProperty(propInfo.Name);
                        if (_properties.TryGetValue(basePropInfo, out edmProperty))
                        {
                            edmProperties.Add(edmProperty);
                            break;
                        }

                        baseType = TypeHelper.GetBaseType(baseType);
                    }

                    Contract.Assert(baseType != null);
                }
            }

            return edmProperties.OfType<IEdmStructuralProperty>().ToList();
        }

        private void CreateEnumTypeBody(EdmEnumType type, EnumTypeConfiguration config)
        {
            Contract.Assert(type != null);
            Contract.Assert(config != null);

            foreach (EnumMemberConfiguration member in config.Members)
            {
                // EdmIntegerConstant can only support a value of long type.
                long value;
                try
                {
                    value = Convert.ToInt64(member.MemberInfo, CultureInfo.InvariantCulture);
                }
                catch
                {
                    throw Error.Argument("value", SRResources.EnumValueCannotBeLong, Enum.GetName(member.MemberInfo.GetType(), member.MemberInfo));
                }

                EdmEnumMember edmMember = new EdmEnumMember(type, member.Name,
                    new EdmEnumMemberValue(value));
                type.AddMember(edmMember);
                _members[member.MemberInfo] = edmMember;
            }
        }

        private IEdmType GetEdmType(Type clrType)
        {
            Contract.Assert(clrType != null);

            IEdmType edmType;
            _types.TryGetValue(clrType, out edmType);

            return edmType;
        }

        /// <summary>
        /// Builds <see cref="IEdmType"/> and <see cref="IEdmProperty"/>'s from <paramref name="configurations"/>
        /// </summary>
        /// <param name="configurations">A collection of <see cref="IEdmTypeConfiguration"/>'s</param>
        /// <returns>The built dictionary of <see cref="StructuralTypeConfiguration"/>'s indexed by their backing CLR type,
        /// and dictionary of <see cref="StructuralTypeConfiguration"/>'s indexed by their backing CLR property info</returns>
        public static EdmTypeMap GetTypesAndProperties(IEnumerable<IEdmTypeConfiguration> configurations)
        {
            if (configurations == null)
            {
                throw Error.ArgumentNull("configurations");
            }

            EdmTypeBuilder builder = new EdmTypeBuilder(configurations);
            return new EdmTypeMap(builder.GetEdmTypes(),
                builder._properties,
                builder._propertiesRestrictions,
                builder._propertiesQuerySettings,
                builder._structuredTypeQuerySettings,
                builder._members,
                builder._openTypes,
                builder._propertyConfigurations,
                builder._instanceAnnotableTypes);
        }

        /// <summary>
        /// Gets the <see cref="EdmPrimitiveTypeKind"/> that maps to the <see cref="Type"/>
        /// </summary>
        /// <param name="clrType">The clr type</param>
        /// <returns>The corresponding Edm primitive kind.</returns>
        public static EdmPrimitiveTypeKind GetTypeKind(Type clrType)
        {
            IEdmPrimitiveType primitiveType = EdmLibHelpers.GetEdmPrimitiveTypeOrNull(clrType);
            if (primitiveType == null)
            {
                throw Error.Argument("clrType", SRResources.MustBePrimitiveType, clrType.FullName);
            }

            return primitiveType.PrimitiveKind;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmTypeBuilder.cs(110,25): error CS0165: Use of unassigned local variable 'entity',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmTypeBuilder.cs(142,32): error CS0165: Use of unassigned local variable 'enumTypeConfiguration',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Builder\EdmTypeBuilder.cs(339,72): error CS0165: Use of unassigned local variable 'elementType'
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel.DataAnnotations;
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
using System.Data.Linq;
#endif
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Xml.Linq;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter
{
    internal static class EdmPrimitiveHelpers
    {
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        public static object ConvertPrimitiveValue(object value, Type type)
        {
            Contract.Assert(value != null);
            Contract.Assert(type != null);

            // if value is of the same type nothing to do here.
            if (value.GetType() == type || value.GetType() == Nullable.GetUnderlyingType(type))
            {
                return value;
            }

            if (type.IsInstanceOfType(value))
            {
                return value;
            }

            string str = value as string;

            if (type == typeof(char))
            {
                if (str == null || str.Length != 1)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeStringLengthOne));
                }

                return str[0];
            }
            else if (type == typeof(char?))
            {
                if (str == null || str.Length > 1)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeStringMaxLengthOne));
                }

                return str.Length > 0 ? str[0] : (char?)null;
            }
            else if (type == typeof(char[]))
            {
                if (str == null)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                }

                return str.ToCharArray();
            }
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
            else if (type == typeof(Binary))
            {
                return new Binary((byte[])value);
            }
#endif
            else if (type == typeof(XElement))
            {
                if (str == null)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                }

                return XElement.Parse(str);
            }
            else
            {
                type = Nullable.GetUnderlyingType(type) ?? type;
                if (TypeHelper.IsEnum(type))
                {
                    if (str == null)
                    {
                        throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                    }

                    return Enum.Parse(type, str);
                }
                else if (type == typeof(DateTime))
                {
                    if (value is DateTimeOffset dateTimeOffsetValue)
                    {
                        TimeZoneInfo timeZone = TimeZoneInfoHelper.TimeZone;
                        dateTimeOffsetValue = TimeZoneInfo.ConvertTime(dateTimeOffsetValue, timeZone);
                        return dateTimeOffsetValue.DateTime;
                    }

                    if (value is Date dt)
                    {
                        return (DateTime)dt;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeDateTimeOffsetOrDate));
                }
                else if (type == typeof(TimeSpan))
                {
                    if (value is TimeOfDay tod)
                    {
                        return (TimeSpan)tod;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeTimeOfDay));
                }
                else if (type == typeof(bool))
                {
                    bool result;
                    if (str != null && Boolean.TryParse(str, out result))
                    {
                        return result;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeBoolean));
                }
                else
                {
                    Contract.Assert(type == typeof(uint) || type == typeof(ushort) || type == typeof(ulong));

                    // Note that we are not casting the return value to nullable<T> as even if we do it
                    // CLR would unbox it back to T.
                    return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.ComponentModel.DataAnnotations;
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
using System.Data.Linq;
#endif
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Globalization;
using System.Xml.Linq;
using Microsoft.AspNet.OData.Common;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter
{
    internal static class EdmPrimitiveHelpers
    {
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        public static object ConvertPrimitiveValue(object value, Type type)
        {
            Contract.Assert(value != null);
            Contract.Assert(type != null);

            // if value is of the same type nothing to do here.
            if (value.GetType() == type || value.GetType() == Nullable.GetUnderlyingType(type))
            {
                return value;
            }

            if (type.IsInstanceOfType(value))
            {
                return value;
            }

            if (type == typeof(char))
            {
                if (str == null || str.Length != 1)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeStringLengthOne));
                }

                return str[0];
            }
            else if (type == typeof(char?))
            {
                if (str == null || str.Length > 1)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeStringMaxLengthOne));
                }

                return str.Length > 0 ? str[0] : (char?)null;
            }
            else if (type == typeof(char[]))
            {
                if (str == null)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                }

                return str.ToCharArray();
            }
#if NETFX // System.Data.Linq.Binary is only supported in the AspNet version.
            else if (type == typeof(Binary))
            {
                return new Binary((byte[])value);
            }
#endif
            else if (type == typeof(XElement))
            {
                if (str == null)
                {
                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                }

                return XElement.Parse(str);
            }
            else
            {
                type = Nullable.GetUnderlyingType(type) ?? type;
                if (TypeHelper.IsEnum(type))
                {
                    if (str == null)
                    {
                        throw new ValidationException(Error.Format(SRResources.PropertyMustBeString));
                    }

                    return Enum.Parse(type, str);
                }
                else if (type == typeof(DateTime))
                {
                    if (value is DateTimeOffset dateTimeOffsetValue)
                    {
                        TimeZoneInfo timeZone = TimeZoneInfoHelper.TimeZone;
                        dateTimeOffsetValue = TimeZoneInfo.ConvertTime(dateTimeOffsetValue, timeZone);
                        return dateTimeOffsetValue.DateTime;
                    }

                    if (value is Date dt)
                    {
                        return (DateTime)dt;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeDateTimeOffsetOrDate));
                }
                else if (type == typeof(TimeSpan))
                {
                    if (value is TimeOfDay tod)
                    {
                        return (TimeSpan)tod;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeTimeOfDay));
                }
                else if (type == typeof(bool))
                {
                    bool result;

                    if (value is string str && Boolean.TryParse(str, out result))
                    {
                        return result;
                    }

                    throw new ValidationException(Error.Format(SRResources.PropertyMustBeBoolean));
                }
                else
                {
                    Contract.Assert(type == typeof(uint) || type == typeof(ushort) || type == typeof(ulong));

                    // Note that we are not casting the return value to nullable<T> as even if we do it
                    // CLR would unbox it back to T.
                    return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(39,21): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(39,36): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(44,24): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(48,21): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(48,36): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(53,24): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(53,41): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(57,21): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(62,24): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(72,21): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(77,39): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(84,25): error CS0103: The name 'str' does not exist in the current context,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\EdmPrimitiveHelpers.cs(89,45): error CS0103: The name 'str' does not exist in the current context
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataResourceDeserializer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter.Serialization;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    /// <summary>
    /// Represents an <see cref="ODataDeserializer"/> for reading OData resource payloads.
    /// </summary>
    public class ODataResourceDeserializer : ODataEdmTypeDeserializer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ODataResourceDeserializer"/> class.
        /// </summary>
        /// <param name="deserializerProvider">The deserializer provider to use to read inner objects.</param>
        public ODataResourceDeserializer(ODataDeserializerProvider deserializerProvider)
            : base(ODataPayloadKind.Resource, deserializerProvider)
        {
        }

        /// <inheritdoc />
        public override object Read(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }

            IEdmStructuredTypeReference structuredType = GetStructuredType(type, readContext);
            IEdmNavigationSource navigationSource = GetNavigationSource(structuredType, readContext);
            ODataReader odataReader = messageReader.CreateODataResourceReader(navigationSource, structuredType.StructuredDefinition());
            ODataResourceWrapper topLevelResource = odataReader.ReadResourceOrResourceSet() as ODataResourceWrapper;
            Contract.Assert(topLevelResource != null);

            return ReadInline(topLevelResource, structuredType, readContext);
        }

        /// <inheritdoc />
        public override async Task<object> ReadAsync(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }

            IEdmStructuredTypeReference structuredType = GetStructuredType(type, readContext);
            IEdmNavigationSource navigationSource = GetNavigationSource(structuredType, readContext);
            ODataReader odataReader = await messageReader.CreateODataResourceReaderAsync(navigationSource, structuredType.StructuredDefinition());
            ODataResourceWrapper topLevelResource = await odataReader.ReadResourceOrResourceSetAsync() as ODataResourceWrapper;
            Contract.Assert(topLevelResource != null);

            return ReadInline(topLevelResource, structuredType, readContext);
        }

        /// <inheritdoc />
        public sealed override object ReadInline(object item, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            if (edmType == null)
            {
                throw Error.ArgumentNull("edmType");
            }

            if (edmType.IsComplex() && item == null)
            {
                return null;
            }

            if (item == null)
            {
                throw Error.ArgumentNull("item");
            }

            if (!edmType.IsStructured())
            {
                throw Error.Argument("edmType", SRResources.ArgumentMustBeOfType, "Entity or Complex");
            }

            ODataResourceWrapper resourceWrapper = item as ODataResourceWrapper;
            if (resourceWrapper == null)
            {
                throw Error.Argument("item", SRResources.ArgumentMustBeOfType, typeof(ODataResource).Name);
            }

            // Recursion guard to avoid stack overflows
            RuntimeHelpers.EnsureSufficientExecutionStack();

            return ReadResource(resourceWrapper, edmType.AsStructured(), readContext);
        }

        /// <summary>
        /// Deserializes the given <paramref name="resourceWrapper"/> under the given <paramref name="readContext"/>.
        /// </summary>
        /// <param name="resourceWrapper">The OData resource to deserialize.</param>
        /// <param name="structuredType">The type of the resource to deserialize.</param>
        /// <param name="readContext">The deserializer context.</param>
        /// <returns>The deserialized resource.</returns>
        public virtual object ReadResource(ODataResourceWrapper resourceWrapper, IEdmStructuredTypeReference structuredType,
            ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            if (!String.IsNullOrEmpty(resourceWrapper.Resource.TypeName) && structuredType.FullName() != resourceWrapper.Resource.TypeName)
            {
                // received a derived type in a base type deserializer. delegate it to the appropriate derived type deserializer.
                IEdmModel model = readContext.Model;

                if (model == null)
                {
                    throw Error.Argument("readContext", SRResources.ModelMissingFromReadContext);
                }

                IEdmStructuredType actualType = model.FindType(resourceWrapper.Resource.TypeName) as IEdmStructuredType;
                if (actualType == null)
                {
                    throw new ODataException(Error.Format(SRResources.ResourceTypeNotInModel, resourceWrapper.Resource.TypeName));
                }

                if (actualType.IsAbstract)
                {
                    string message = Error.Format(SRResources.CannotInstantiateAbstractResourceType, resourceWrapper.Resource.TypeName);
                    throw new ODataException(message);
                }

                IEdmTypeReference actualStructuredType;
                IEdmEntityType actualEntityType = actualType as IEdmEntityType;
                if (actualEntityType != null)
                {
                    actualStructuredType = new EdmEntityTypeReference(actualEntityType, isNullable: false);
                }
                else
                {
                    actualStructuredType = new EdmComplexTypeReference(actualType as IEdmComplexType, isNullable: false);
                }

                ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(actualStructuredType);
                if (deserializer == null)
                {
                    throw new SerializationException(
                        Error.Format(SRResources.TypeCannotBeDeserialized, actualEntityType.FullName()));
                }

                object resource = deserializer.ReadInline(resourceWrapper, actualStructuredType, readContext);

                EdmStructuredObject structuredObject = resource as EdmStructuredObject;
                if (structuredObject != null)
                {
                    structuredObject.ExpectedEdmType = structuredType.StructuredDefinition();
                }

                return resource;
            }
            else
            {
                object resource = CreateResourceInstance(structuredType, readContext);
                ApplyResourceProperties(resource, resourceWrapper, structuredType, readContext);
                return resource;
            }
        }

        /// <summary>
        /// Creates a new instance of the backing CLR object for the given resource type.
        /// </summary>
        /// <param name="structuredType">The EDM type of the resource to create.</param>
        /// <param name="readContext">The deserializer context.</param>
        /// <returns>The created CLR object.</returns>
        public virtual object CreateResourceInstance(IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            IEdmModel model = readContext.Model;
            if (model == null)
            {
                throw Error.Argument("readContext", SRResources.ModelMissingFromReadContext);
            }

            if (readContext.IsUntyped)
            {
                if (structuredType.IsEntity())
                {
                    return new EdmEntityObject(structuredType.AsEntity());
                }

                return new EdmComplexObject(structuredType.AsComplex());
            }
            else
            {
                Type clrType = EdmLibHelpers.GetClrType(structuredType, model);
                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }

                if (readContext.IsDeltaOfT)
                {
                    IEnumerable<string> structuralProperties = structuredType.StructuralProperties()
                        .Select(edmProperty => EdmLibHelpers.GetClrPropertyName(edmProperty, model));

                    if (structuredType.IsOpen())
                    {
                        PropertyInfo dynamicDictionaryPropertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(
                            structuredType.StructuredDefinition(), model);

                        return Activator.CreateInstance(readContext.ResourceType, clrType, structuralProperties,
                            dynamicDictionaryPropertyInfo);
                    }
                    else
                    {
                        return Activator.CreateInstance(readContext.ResourceType, clrType, structuralProperties);
                    }
                }
                else
                {
                    return Activator.CreateInstance(clrType);
                }
            }
        }

        /// <summary>
        /// Deserializes the nested properties from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the nested properties should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the nested properties.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyNestedProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            foreach (ODataNestedResourceInfoWrapper nestedResourceInfo in resourceWrapper.NestedResourceInfos)
            {
                ApplyNestedProperty(resource, nestedResourceInfo, structuredType, readContext);
            }
        }

        /// <summary>
        /// Deserializes the nested property from <paramref name="resourceInfoWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the nested property should be read.</param>
        /// <param name="resourceInfoWrapper">The nested resource info.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyNestedProperty(object resource, ODataNestedResourceInfoWrapper resourceInfoWrapper,
             IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resource == null)
            {
                throw Error.ArgumentNull("resource");
            }

            if (resourceInfoWrapper == null)
            {
                throw Error.ArgumentNull("resourceInfoWrapper");
            }

            IEdmProperty edmProperty = structuredType.FindProperty(resourceInfoWrapper.NestedResourceInfo.Name);
            if (edmProperty == null)
            {
                if (!structuredType.IsOpen())
                {
                    throw new ODataException(
                        Error.Format(SRResources.NestedPropertyNotfound, resourceInfoWrapper.NestedResourceInfo.Name,
                            structuredType.FullName()));
                }
            }

            foreach (ODataItemBase childItem in resourceInfoWrapper.NestedItems)
            {
                // it maybe null.
                if (childItem == null)
                {
                    if (edmProperty == null)
                    {
                        // for the dynamic, OData.net has a bug. see https://github.com/OData/odata.net/issues/977
                        ApplyDynamicResourceInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name, resource,
                            structuredType, null, readContext);
                    }
                    else
                    {
                        ApplyResourceInNestedProperty(edmProperty, resource, null, readContext);
                    }
                }

                ODataEntityReferenceLinkBase entityReferenceLink = childItem as ODataEntityReferenceLinkBase;
                if (entityReferenceLink != null)
                {
                    // ignore entity reference links.
                    continue;
                }

                ODataResourceSetWrapper resourceSetWrapper = childItem as ODataResourceSetWrapper;
                if (resourceSetWrapper != null)
                {
                    if (edmProperty == null)
                    {
                        ApplyDynamicResourceSetInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name,
                            resource, structuredType, resourceSetWrapper, readContext);
                    }
                    else
                    {
                        ApplyResourceSetInNestedProperty(edmProperty, resource, resourceSetWrapper, readContext);
                    }

                    continue;
                }

                // It must be resource by now.
                ODataResourceWrapper resourceWrapper = (ODataResourceWrapper)childItem;
                if (resourceWrapper != null)
                {
                    if (edmProperty == null)
                    {
                        ApplyDynamicResourceInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name, resource,
                            structuredType, resourceWrapper, readContext);
                    }
                    else
                    {
                        ApplyResourceInNestedProperty(edmProperty, resource, resourceWrapper, readContext);
                    }
                }
            }
        }

        /// <summary>
        /// Deserializes the structural properties from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the structural properties should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the structural properties.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyStructuralProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            foreach (ODataProperty property in resourceWrapper.Resource.Properties)
            {
                ApplyStructuralProperty(resource, property, structuredType, readContext);
            }
        }

        /// <summary>
        /// Deserializes the instance annotations from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the annotations should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the annotations.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyInstanceAnnotations(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            DeserializationHelpers.ApplyInstanceAnnotations(resource, structuredType, resourceWrapper.Resource,DeserializerProvider, readContext);
        }

        /// <summary>
        /// Deserializes the given <paramref name="structuralProperty"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the structural property should be read.</param>
        /// <param name="structuralProperty">The structural property.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyStructuralProperty(object resource, ODataProperty structuralProperty,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        { 
            if (resource == null)
            {
                throw Error.ArgumentNull("resource");
            }

            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }

            DeserializationHelpers.ApplyProperty(structuralProperty, structuredType, resource, DeserializerProvider, readContext);
        }

        private void ApplyResourceProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            ApplyStructuralProperties(resource, resourceWrapper, structuredType, readContext);
            ApplyNestedProperties(resource, resourceWrapper, structuredType, readContext);
            ApplyInstanceAnnotations(resource, resourceWrapper, structuredType, readContext);
        }

        private void ApplyResourceInNestedProperty(IEdmProperty nestedProperty, object resource,
            ODataResourceWrapper resourceWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(nestedProperty != null);
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (readContext.IsDeltaOfT)
            {
                IEdmNavigationProperty navigationProperty = nestedProperty as IEdmNavigationProperty;
                if (navigationProperty != null)
                {
                    string message = Error.Format(SRResources.CannotPatchNavigationProperties, navigationProperty.Name,
                        navigationProperty.DeclaringEntityType().FullName());
                    throw new ODataException(message);
                }
            }

            object value = ReadNestedResourceInline(resourceWrapper, nestedProperty.Type, readContext);

            // First resolve Data member alias or annotation, then set the regular
            // or delta resource accordingly.
            string propertyName = EdmLibHelpers.GetClrPropertyName(nestedProperty, readContext.Model);

            DeserializationHelpers.SetProperty(resource, propertyName, value);
        }

        private void ApplyDynamicResourceInNestedProperty(string propertyName, object resource, IEdmStructuredTypeReference resourceStructuredType,
            ODataResourceWrapper resourceWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            object value = null;
            if (resourceWrapper != null)
            {
                IEdmSchemaType elementType = readContext.Model.FindDeclaredType(resourceWrapper.Resource.TypeName);
                IEdmTypeReference edmTypeReference = elementType.ToEdmTypeReference(true);

                value = ReadNestedResourceInline(resourceWrapper, edmTypeReference, readContext);
            }

            DeserializationHelpers.SetDynamicProperty(resource, propertyName, value,
                resourceStructuredType.StructuredDefinition(), readContext.Model);
        }

        private object ReadNestedResourceInline(ODataResourceWrapper resourceWrapper, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            Contract.Assert(edmType != null);
            Contract.Assert(readContext != null);

            if (resourceWrapper == null)
            {
                return null;
            }

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(edmType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, edmType.FullName()));
            }

            IEdmStructuredTypeReference structuredType = edmType.AsStructured();

            var nestedReadContext = new ODataDeserializerContext
            {
                Path = readContext.Path,
                Model = readContext.Model,
            };

            Type clrType = null;
            if (readContext.IsUntyped)
            {
                clrType = structuredType.IsEntity()
                    ? typeof(EdmEntityObject)
                    : typeof(EdmComplexObject);
            }
            else
            {
                clrType = EdmLibHelpers.GetClrType(structuredType, readContext.Model);

                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }
            }

            nestedReadContext.ResourceType = readContext.IsDeltaOfT
                ? typeof(Delta<>).MakeGenericType(clrType)
                : clrType;
            return deserializer.ReadInline(resourceWrapper, edmType, nestedReadContext);
        }

        private void ApplyResourceSetInNestedProperty(IEdmProperty nestedProperty, object resource,
            ODataResourceSetWrapper resourceSetWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(nestedProperty != null);
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (readContext.IsDeltaOfT)
            {
                IEdmNavigationProperty navigationProperty = nestedProperty as IEdmNavigationProperty;
                if (navigationProperty != null)
                {
                    string message = Error.Format(SRResources.CannotPatchNavigationProperties, navigationProperty.Name,
                        navigationProperty.DeclaringEntityType().FullName());
                    throw new ODataException(message);
                }
            }

            object value = ReadNestedResourceSetInline(resourceSetWrapper, nestedProperty.Type, readContext);

            string propertyName = EdmLibHelpers.GetClrPropertyName(nestedProperty, readContext.Model);
            DeserializationHelpers.SetCollectionProperty(resource, nestedProperty, value, propertyName);
        }

        private void ApplyDynamicResourceSetInNestedProperty(string propertyName, object resource, IEdmStructuredTypeReference structuredType,
            ODataResourceSetWrapper resourceSetWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (String.IsNullOrEmpty(resourceSetWrapper.ResourceSet.TypeName))
            {
                string message = Error.Format(SRResources.DynamicResourceSetTypeNameIsRequired, propertyName);
                throw new ODataException(message);
            }

            string elementTypeName =
                DeserializationHelpers.GetCollectionElementTypeName(resourceSetWrapper.ResourceSet.TypeName,
                    isNested: false);
            IEdmSchemaType elementType = readContext.Model.FindDeclaredType(elementTypeName);

            IEdmTypeReference edmTypeReference = elementType.ToEdmTypeReference(true);
            EdmCollectionTypeReference collectionType = new EdmCollectionTypeReference(new EdmCollectionType(edmTypeReference));

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(collectionType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, collectionType.FullName()));
            }

            IEnumerable value = ReadNestedResourceSetInline(resourceSetWrapper, collectionType, readContext) as IEnumerable;
            object result = value;
            if (value != null)
            {
                if (readContext.IsUntyped)
                {
                    result = value.ConvertToEdmObject(collectionType);
                }
            }

            DeserializationHelpers.SetDynamicProperty(resource, structuredType, EdmTypeKind.Collection, propertyName,
                result, collectionType, readContext.Model);
        }

        private object ReadNestedResourceSetInline(ODataResourceSetWrapper resourceSetWrapper, IEdmTypeReference edmType,
            ODataDeserializerContext readContext)
        {
            Contract.Assert(resourceSetWrapper != null);
            Contract.Assert(edmType != null);
            Contract.Assert(readContext != null);

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(edmType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, edmType.FullName()));
            }

            IEdmStructuredTypeReference structuredType = edmType.AsCollection().ElementType().AsStructured();
            var nestedReadContext = new ODataDeserializerContext
            {
                Path = readContext.Path,
                Model = readContext.Model,
            };

            if (readContext.IsUntyped)
            {
                if (structuredType.IsEntity())
                {
                    nestedReadContext.ResourceType = typeof(EdmEntityObjectCollection);
                }
                else
                {
                    nestedReadContext.ResourceType = typeof(EdmComplexObjectCollection);
                }
            }
            else
            {
                Type clrType = EdmLibHelpers.GetClrType(structuredType, readContext.Model);

                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }

                nestedReadContext.ResourceType = typeof(List<>).MakeGenericType(clrType);
            }

            return deserializer.ReadInline(resourceSetWrapper, edmType, nestedReadContext);
        }

        private static IEdmStructuredTypeReference GetStructuredType(Type type, ODataDeserializerContext readContext)
        {
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            if (!edmType.IsStructured())
            {
                throw Error.Argument("type", SRResources.ArgumentMustBeOfType, "Structured");
            }

            return edmType.AsStructured();
        }

        private static IEdmNavigationSource GetNavigationSource(IEdmStructuredTypeReference edmType, ODataDeserializerContext readContext)
        {
            IEdmNavigationSource navigationSource = null;
            if (edmType.IsEntity())
            {
                if (readContext.Path == null)
                {
                    throw Error.Argument("readContext", SRResources.ODataPathMissing);
                }

                navigationSource = readContext.Path.NavigationSource;
                if (navigationSource == null)
                {
                    throw new SerializationException(SRResources.NavigationSourceMissingDuringDeserialization);
                }
            }

            return navigationSource;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Formatter.Serialization;
using Microsoft.OData;
using Microsoft.OData.Edm;

namespace Microsoft.AspNet.OData.Formatter.Deserialization
{
    /// <summary>
    /// Represents an <see cref="ODataDeserializer"/> for reading OData resource payloads.
    /// </summary>
    public class ODataResourceDeserializer : ODataEdmTypeDeserializer
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ODataResourceDeserializer"/> class.
        /// </summary>
        /// <param name="deserializerProvider">The deserializer provider to use to read inner objects.</param>
        public ODataResourceDeserializer(ODataDeserializerProvider deserializerProvider)
            : base(ODataPayloadKind.Resource, deserializerProvider)
        {
        }

        /// <inheritdoc />
        public override object Read(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }

            IEdmStructuredTypeReference structuredType = GetStructuredType(type, readContext);
            IEdmNavigationSource navigationSource = GetNavigationSource(structuredType, readContext);
            ODataReader odataReader = messageReader.CreateODataResourceReader(navigationSource, structuredType.StructuredDefinition());
            ODataResourceWrapper topLevelResource = odataReader.ReadResourceOrResourceSet() as ODataResourceWrapper;
            Contract.Assert(topLevelResource != null);

            return ReadInline(topLevelResource, structuredType, readContext);
        }

        /// <inheritdoc />
        public override async Task<object> ReadAsync(ODataMessageReader messageReader, Type type, ODataDeserializerContext readContext)
        {
            if (messageReader == null)
            {
                throw Error.ArgumentNull("messageReader");
            }

            IEdmStructuredTypeReference structuredType = GetStructuredType(type, readContext);
            IEdmNavigationSource navigationSource = GetNavigationSource(structuredType, readContext);
            ODataReader odataReader = await messageReader.CreateODataResourceReaderAsync(navigationSource, structuredType.StructuredDefinition());
            ODataResourceWrapper topLevelResource = await odataReader.ReadResourceOrResourceSetAsync() as ODataResourceWrapper;
            Contract.Assert(topLevelResource != null);

            return ReadInline(topLevelResource, structuredType, readContext);
        }

        /// <inheritdoc />
        public sealed override object ReadInline(object item, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            if (edmType == null)
            {
                throw Error.ArgumentNull("edmType");
            }

            if (edmType.IsComplex() && item == null)
            {
                return null;
            }

            if (item == null)
            {
                throw Error.ArgumentNull("item");
            }

            if (!edmType.IsStructured())
            {
                throw Error.Argument("edmType", SRResources.ArgumentMustBeOfType, "Entity or Complex");
            }

            ODataResourceWrapper resourceWrapper = item as ODataResourceWrapper;
            if (resourceWrapper == null)
            {
                throw Error.Argument("item", SRResources.ArgumentMustBeOfType, typeof(ODataResource).Name);
            }

            // Recursion guard to avoid stack overflows
            RuntimeHelpers.EnsureSufficientExecutionStack();

            return ReadResource(resourceWrapper, edmType.AsStructured(), readContext);
        }

        /// <summary>
        /// Deserializes the given <paramref name="resourceWrapper"/> under the given <paramref name="readContext"/>.
        /// </summary>
        /// <param name="resourceWrapper">The OData resource to deserialize.</param>
        /// <param name="structuredType">The type of the resource to deserialize.</param>
        /// <param name="readContext">The deserializer context.</param>
        /// <returns>The deserialized resource.</returns>
        public virtual object ReadResource(ODataResourceWrapper resourceWrapper, IEdmStructuredTypeReference structuredType,
            ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            if (!String.IsNullOrEmpty(resourceWrapper.Resource.TypeName) && structuredType.FullName() != resourceWrapper.Resource.TypeName)
            {
                // received a derived type in a base type deserializer. delegate it to the appropriate derived type deserializer.
                IEdmModel model = readContext.Model;

                if (model == null)
                {
                    throw Error.Argument("readContext", SRResources.ModelMissingFromReadContext);
                }

                IEdmStructuredType actualType = model.FindType(resourceWrapper.Resource.TypeName) as IEdmStructuredType;
                if (actualType == null)
                {
                    throw new ODataException(Error.Format(SRResources.ResourceTypeNotInModel, resourceWrapper.Resource.TypeName));
                }

                if (actualType.IsAbstract)
                {
                    string message = Error.Format(SRResources.CannotInstantiateAbstractResourceType, resourceWrapper.Resource.TypeName);
                    throw new ODataException(message);
                }

                IEdmTypeReference actualStructuredType;

                if (actualType is IEdmEntityType actualEntityType)
                {
                    actualStructuredType = new EdmEntityTypeReference(actualEntityType, isNullable: false);
                }
                else
                {
                    actualStructuredType = new EdmComplexTypeReference(actualType as IEdmComplexType, isNullable: false);
                }

                ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(actualStructuredType);
                if (deserializer == null)
                {
                    throw new SerializationException(
                        Error.Format(SRResources.TypeCannotBeDeserialized, actualEntityType.FullName()));
                }

                object resource = deserializer.ReadInline(resourceWrapper, actualStructuredType, readContext);

                if (resource is EdmStructuredObject structuredObject)
                {
                    structuredObject.ExpectedEdmType = structuredType.StructuredDefinition();
                }

                return resource;
            }
            else
            {
                object resource = CreateResourceInstance(structuredType, readContext);
                ApplyResourceProperties(resource, resourceWrapper, structuredType, readContext);
                return resource;
            }
        }

        /// <summary>
        /// Creates a new instance of the backing CLR object for the given resource type.
        /// </summary>
        /// <param name="structuredType">The EDM type of the resource to create.</param>
        /// <param name="readContext">The deserializer context.</param>
        /// <returns>The created CLR object.</returns>
        public virtual object CreateResourceInstance(IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            if (structuredType == null)
            {
                throw Error.ArgumentNull("structuredType");
            }

            IEdmModel model = readContext.Model;
            if (model == null)
            {
                throw Error.Argument("readContext", SRResources.ModelMissingFromReadContext);
            }

            if (readContext.IsUntyped)
            {
                if (structuredType.IsEntity())
                {
                    return new EdmEntityObject(structuredType.AsEntity());
                }

                return new EdmComplexObject(structuredType.AsComplex());
            }
            else
            {
                Type clrType = EdmLibHelpers.GetClrType(structuredType, model);
                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }

                if (readContext.IsDeltaOfT)
                {
                    IEnumerable<string> structuralProperties = structuredType.StructuralProperties()
                        .Select(edmProperty => EdmLibHelpers.GetClrPropertyName(edmProperty, model));

                    if (structuredType.IsOpen())
                    {
                        PropertyInfo dynamicDictionaryPropertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(
                            structuredType.StructuredDefinition(), model);

                        return Activator.CreateInstance(readContext.ResourceType, clrType, structuralProperties,
                            dynamicDictionaryPropertyInfo);
                    }
                    else
                    {
                        return Activator.CreateInstance(readContext.ResourceType, clrType, structuralProperties);
                    }
                }
                else
                {
                    return Activator.CreateInstance(clrType);
                }
            }
        }

        /// <summary>
        /// Deserializes the nested properties from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the nested properties should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the nested properties.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyNestedProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            foreach (ODataNestedResourceInfoWrapper nestedResourceInfo in resourceWrapper.NestedResourceInfos)
            {
                ApplyNestedProperty(resource, nestedResourceInfo, structuredType, readContext);
            }
        }

        /// <summary>
        /// Deserializes the nested property from <paramref name="resourceInfoWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the nested property should be read.</param>
        /// <param name="resourceInfoWrapper">The nested resource info.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyNestedProperty(object resource, ODataNestedResourceInfoWrapper resourceInfoWrapper,
             IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resource == null)
            {
                throw Error.ArgumentNull("resource");
            }

            if (resourceInfoWrapper == null)
            {
                throw Error.ArgumentNull("resourceInfoWrapper");
            }

            IEdmProperty edmProperty = structuredType.FindProperty(resourceInfoWrapper.NestedResourceInfo.Name);
            if (edmProperty == null)
            {
                if (!structuredType.IsOpen())
                {
                    throw new ODataException(
                        Error.Format(SRResources.NestedPropertyNotfound, resourceInfoWrapper.NestedResourceInfo.Name,
                            structuredType.FullName()));
                }
            }

            foreach (ODataItemBase childItem in resourceInfoWrapper.NestedItems)
            {
                // it maybe null.
                if (childItem == null)
                {
                    if (edmProperty == null)
                    {
                        // for the dynamic, OData.net has a bug. see https://github.com/OData/odata.net/issues/977
                        ApplyDynamicResourceInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name, resource,
                            structuredType, null, readContext);
                    }
                    else
                    {
                        ApplyResourceInNestedProperty(edmProperty, resource, null, readContext);
                    }
                }

                if (childItem is ODataEntityReferenceLinkBase entityReferenceLink)
                {
                    // ignore entity reference links.
                    continue;
                }

                if (childItem is ODataResourceSetWrapper resourceSetWrapper)
                {
                    if (edmProperty == null)
                    {
                        ApplyDynamicResourceSetInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name,
                            resource, structuredType, resourceSetWrapper, readContext);
                    }
                    else
                    {
                        ApplyResourceSetInNestedProperty(edmProperty, resource, resourceSetWrapper, readContext);
                    }

                    continue;
                }

                // It must be resource by now.
                ODataResourceWrapper resourceWrapper = (ODataResourceWrapper)childItem;
                if (resourceWrapper != null)
                {
                    if (edmProperty == null)
                    {
                        ApplyDynamicResourceInNestedProperty(resourceInfoWrapper.NestedResourceInfo.Name, resource,
                            structuredType, resourceWrapper, readContext);
                    }
                    else
                    {
                        ApplyResourceInNestedProperty(edmProperty, resource, resourceWrapper, readContext);
                    }
                }
            }
        }

        /// <summary>
        /// Deserializes the structural properties from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the structural properties should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the structural properties.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyStructuralProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            foreach (ODataProperty property in resourceWrapper.Resource.Properties)
            {
                ApplyStructuralProperty(resource, property, structuredType, readContext);
            }
        }

        /// <summary>
        /// Deserializes the instance annotations from <paramref name="resourceWrapper"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the annotations should be read.</param>
        /// <param name="resourceWrapper">The resource object containing the annotations.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyInstanceAnnotations(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            if (resourceWrapper == null)
            {
                throw Error.ArgumentNull("resourceWrapper");
            }

            DeserializationHelpers.ApplyInstanceAnnotations(resource, structuredType, resourceWrapper.Resource,DeserializerProvider, readContext);
        }

        /// <summary>
        /// Deserializes the given <paramref name="structuralProperty"/> into <paramref name="resource"/>.
        /// </summary>
        /// <param name="resource">The object into which the structural property should be read.</param>
        /// <param name="structuralProperty">The structural property.</param>
        /// <param name="structuredType">The type of the resource.</param>
        /// <param name="readContext">The deserializer context.</param>
        public virtual void ApplyStructuralProperty(object resource, ODataProperty structuralProperty,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        { 
            if (resource == null)
            {
                throw Error.ArgumentNull("resource");
            }

            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }

            DeserializationHelpers.ApplyProperty(structuralProperty, structuredType, resource, DeserializerProvider, readContext);
        }

        private void ApplyResourceProperties(object resource, ODataResourceWrapper resourceWrapper,
            IEdmStructuredTypeReference structuredType, ODataDeserializerContext readContext)
        {
            ApplyStructuralProperties(resource, resourceWrapper, structuredType, readContext);
            ApplyNestedProperties(resource, resourceWrapper, structuredType, readContext);
            ApplyInstanceAnnotations(resource, resourceWrapper, structuredType, readContext);
        }

        private void ApplyResourceInNestedProperty(IEdmProperty nestedProperty, object resource,
            ODataResourceWrapper resourceWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(nestedProperty != null);
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (readContext.IsDeltaOfT)
            {
                if (nestedProperty is IEdmNavigationProperty navigationProperty)
                {
                    string message = Error.Format(SRResources.CannotPatchNavigationProperties, navigationProperty.Name,
                        navigationProperty.DeclaringEntityType().FullName());
                    throw new ODataException(message);
                }
            }

            object value = ReadNestedResourceInline(resourceWrapper, nestedProperty.Type, readContext);

            // First resolve Data member alias or annotation, then set the regular
            // or delta resource accordingly.
            string propertyName = EdmLibHelpers.GetClrPropertyName(nestedProperty, readContext.Model);

            DeserializationHelpers.SetProperty(resource, propertyName, value);
        }

        private void ApplyDynamicResourceInNestedProperty(string propertyName, object resource, IEdmStructuredTypeReference resourceStructuredType,
            ODataResourceWrapper resourceWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            object value = null;
            if (resourceWrapper != null)
            {
                IEdmSchemaType elementType = readContext.Model.FindDeclaredType(resourceWrapper.Resource.TypeName);
                IEdmTypeReference edmTypeReference = elementType.ToEdmTypeReference(true);

                value = ReadNestedResourceInline(resourceWrapper, edmTypeReference, readContext);
            }

            DeserializationHelpers.SetDynamicProperty(resource, propertyName, value,
                resourceStructuredType.StructuredDefinition(), readContext.Model);
        }

        private object ReadNestedResourceInline(ODataResourceWrapper resourceWrapper, IEdmTypeReference edmType, ODataDeserializerContext readContext)
        {
            Contract.Assert(edmType != null);
            Contract.Assert(readContext != null);

            if (resourceWrapper == null)
            {
                return null;
            }

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(edmType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, edmType.FullName()));
            }

            IEdmStructuredTypeReference structuredType = edmType.AsStructured();

            var nestedReadContext = new ODataDeserializerContext
            {
                Path = readContext.Path,
                Model = readContext.Model,
            };

            Type clrType = null;
            if (readContext.IsUntyped)
            {
                clrType = structuredType.IsEntity()
                    ? typeof(EdmEntityObject)
                    : typeof(EdmComplexObject);
            }
            else
            {
                clrType = EdmLibHelpers.GetClrType(structuredType, readContext.Model);

                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }
            }

            nestedReadContext.ResourceType = readContext.IsDeltaOfT
                ? typeof(Delta<>).MakeGenericType(clrType)
                : clrType;
            return deserializer.ReadInline(resourceWrapper, edmType, nestedReadContext);
        }

        private void ApplyResourceSetInNestedProperty(IEdmProperty nestedProperty, object resource,
            ODataResourceSetWrapper resourceSetWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(nestedProperty != null);
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (readContext.IsDeltaOfT)
            {
                if (nestedProperty is IEdmNavigationProperty navigationProperty)
                {
                    string message = Error.Format(SRResources.CannotPatchNavigationProperties, navigationProperty.Name,
                        navigationProperty.DeclaringEntityType().FullName());
                    throw new ODataException(message);
                }
            }

            object value = ReadNestedResourceSetInline(resourceSetWrapper, nestedProperty.Type, readContext);

            string propertyName = EdmLibHelpers.GetClrPropertyName(nestedProperty, readContext.Model);
            DeserializationHelpers.SetCollectionProperty(resource, nestedProperty, value, propertyName);
        }

        private void ApplyDynamicResourceSetInNestedProperty(string propertyName, object resource, IEdmStructuredTypeReference structuredType,
            ODataResourceSetWrapper resourceSetWrapper, ODataDeserializerContext readContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(readContext != null);

            if (String.IsNullOrEmpty(resourceSetWrapper.ResourceSet.TypeName))
            {
                string message = Error.Format(SRResources.DynamicResourceSetTypeNameIsRequired, propertyName);
                throw new ODataException(message);
            }

            string elementTypeName =
                DeserializationHelpers.GetCollectionElementTypeName(resourceSetWrapper.ResourceSet.TypeName,
                    isNested: false);
            IEdmSchemaType elementType = readContext.Model.FindDeclaredType(elementTypeName);

            IEdmTypeReference edmTypeReference = elementType.ToEdmTypeReference(true);
            EdmCollectionTypeReference collectionType = new EdmCollectionTypeReference(new EdmCollectionType(edmTypeReference));

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(collectionType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, collectionType.FullName()));
            }

            IEnumerable value = ReadNestedResourceSetInline(resourceSetWrapper, collectionType, readContext) as IEnumerable;
            object result = value;
            if (value != null)
            {
                if (readContext.IsUntyped)
                {
                    result = value.ConvertToEdmObject(collectionType);
                }
            }

            DeserializationHelpers.SetDynamicProperty(resource, structuredType, EdmTypeKind.Collection, propertyName,
                result, collectionType, readContext.Model);
        }

        private object ReadNestedResourceSetInline(ODataResourceSetWrapper resourceSetWrapper, IEdmTypeReference edmType,
            ODataDeserializerContext readContext)
        {
            Contract.Assert(resourceSetWrapper != null);
            Contract.Assert(edmType != null);
            Contract.Assert(readContext != null);

            ODataEdmTypeDeserializer deserializer = DeserializerProvider.GetEdmTypeDeserializer(edmType);
            if (deserializer == null)
            {
                throw new SerializationException(Error.Format(SRResources.TypeCannotBeDeserialized, edmType.FullName()));
            }

            IEdmStructuredTypeReference structuredType = edmType.AsCollection().ElementType().AsStructured();
            var nestedReadContext = new ODataDeserializerContext
            {
                Path = readContext.Path,
                Model = readContext.Model,
            };

            if (readContext.IsUntyped)
            {
                if (structuredType.IsEntity())
                {
                    nestedReadContext.ResourceType = typeof(EdmEntityObjectCollection);
                }
                else
                {
                    nestedReadContext.ResourceType = typeof(EdmComplexObjectCollection);
                }
            }
            else
            {
                Type clrType = EdmLibHelpers.GetClrType(structuredType, readContext.Model);

                if (clrType == null)
                {
                    throw new ODataException(
                        Error.Format(SRResources.MappingDoesNotContainResourceType, structuredType.FullName()));
                }

                nestedReadContext.ResourceType = typeof(List<>).MakeGenericType(clrType);
            }

            return deserializer.ReadInline(resourceSetWrapper, edmType, nestedReadContext);
        }

        private static IEdmStructuredTypeReference GetStructuredType(Type type, ODataDeserializerContext readContext)
        {
            if (readContext == null)
            {
                throw Error.ArgumentNull("readContext");
            }

            IEdmTypeReference edmType = readContext.GetEdmType(type);
            Contract.Assert(edmType != null);

            if (!edmType.IsStructured())
            {
                throw Error.Argument("type", SRResources.ArgumentMustBeOfType, "Structured");
            }

            return edmType.AsStructured();
        }

        private static IEdmNavigationSource GetNavigationSource(IEdmStructuredTypeReference edmType, ODataDeserializerContext readContext)
        {
            IEdmNavigationSource navigationSource = null;
            if (edmType.IsEntity())
            {
                if (readContext.Path == null)
                {
                    throw Error.Argument("readContext", SRResources.ODataPathMissing);
                }

                navigationSource = readContext.Path.NavigationSource;
                if (navigationSource == null)
                {
                    throw new SerializationException(SRResources.NavigationSourceMissingDuringDeserialization);
                }
            }

            return navigationSource;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataResourceDeserializer.cs(14,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataResourceDeserializer.cs(160,76): error CS0165: Use of unassigned local variable 'actualEntityType',D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Deserialization\ODataResourceDeserializer.cs(14,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Query.Expressions;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Formatter.Serialization
{
    /// <summary>
    /// ODataSerializer for serializing instances of <see cref="IEdmEntityType"/> or <see cref="IEdmComplexType"/>
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many ODataLib classes.")]
    public class ODataResourceSerializer : ODataEdmTypeSerializer
    {
        private const string Resource = "Resource";

        /// <inheritdoc />
        public ODataResourceSerializer(ODataSerializerProvider serializerProvider)
            : base(ODataPayloadKind.Resource, serializerProvider)
        {
        }

        /// <inheritdoc />
        public override void WriteObject(object graph, Type type, ODataMessageWriter messageWriter,
            ODataSerializerContext writeContext)
        {
            if (messageWriter == null)
            {
                throw Error.ArgumentNull("messageWriter");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, type);
            Contract.Assert(edmType != null);

            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataWriter writer = messageWriter.CreateODataResourceWriter(navigationSource, edmType.ToStructuredType());
            WriteObjectInline(graph, edmType, writer, writeContext);
        }

        /// <inheritdoc />
        public override async Task WriteObjectAsync(object graph, Type type, ODataMessageWriter messageWriter,
            ODataSerializerContext writeContext)
        {
            if (messageWriter == null)
            {
                throw Error.ArgumentNull("messageWriter");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, type);
            Contract.Assert(edmType != null);

            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataWriter writer = await messageWriter.CreateODataResourceWriterAsync(navigationSource, edmType.ToStructuredType());
            await WriteObjectInlineAsync(graph, edmType, writer, writeContext);
        }

        /// <inheritdoc />
        public override void WriteObjectInline(object graph, IEdmTypeReference expectedType, ODataWriter writer,
            ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null || graph is NullEdmComplexObject)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            else
            {
                WriteResource(graph, writer, writeContext, expectedType);
            }
        }

        /// <inheritdoc />
        public override Task WriteObjectInlineAsync(object graph, IEdmTypeReference expectedType, ODataWriter writer,
            ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null || graph is NullEdmComplexObject)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }

            return WriteResourceAsync(graph, writer, writeContext, expectedType);
        }

        /// <summary>
        /// Writes the given object specified by the parameter graph as a part of an existing OData message using the given
        /// deltaWriter and the writeContext.
        /// </summary>
        /// <param name="graph">The object to be written.</param>
        /// <param name="expectedType">The expected EDM type of the object represented by <paramref name="graph"/>.</param>
        /// <param name="writer">The <see cref="ODataDeltaWriter" /> to be used for writing.</param>
        /// <param name="writeContext">The <see cref="ODataSerializerContext"/>.</param>
        public virtual void WriteDeltaObjectInline(object graph, IEdmTypeReference expectedType, ODataWriter writer,
           ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            else
            {
                WriteDeltaResource(graph, writer, writeContext);
            }
        }

        /// <summary>
        /// Writes the given object specified by the parameter graph as a part of an existing OData message using the given
        /// deltaWriter and the writeContext.
        /// </summary>
        /// <param name="graph">The object to be written.</param>
        /// <param name="expectedType">The expected EDM type of the object represented by <paramref name="graph"/>.</param>
        /// <param name="writer">The <see cref="ODataDeltaWriter" /> to be used for writing.</param>
        /// <param name="writeContext">The <see cref="ODataSerializerContext"/>.</param>
        public virtual Task WriteDeltaObjectInlineAsync(object graph, IEdmTypeReference expectedType, ODataWriter writer,
           ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            
            return WriteDeltaResourceAsync(graph, writer, writeContext);
        }

        private void WriteDeltaResource(object graph, ODataWriter writer, ODataSerializerContext writeContext)
        {
            Contract.Assert(writeContext != null);

            ResourceContext resourceContext = GetResourceContext(graph, writeContext);
            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);

                if (resource != null)
                {
                    writer.WriteStart(resource);
                    WriteDeltaComplexProperties(selectExpandNode, resourceContext, writer);
                    //TODO: Need to add support to write Navigation Links, etc. using Delta Writer
                    //https://github.com/OData/odata.net/issues/155
                    //CLEANUP: merge delta logic with regular logic; requires common base between ODataWriter and ODataDeltaWriter
                    //WriteDynamicComplexProperties(resourceContext, writer);
                    //WriteNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext, writer);
                    //WriteExpandedNavigationProperties(selectExpandNode.ExpandedNavigationProperties, resourceContext, writer);

                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteDeltaResourceAsync(object graph, ODataWriter writer, ODataSerializerContext writeContext)
        {
            ResourceContext resourceContext = GetResourceContext(graph, writeContext);
            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);

                if (resource != null)
                {
                    await writer.WriteStartAsync(resource);
                    await WriteDeltaComplexPropertiesAsync(selectExpandNode, resourceContext, writer);
                    //TODO: Need to add support to write Navigation Links, etc. using Delta Writer
                    //https://github.com/OData/odata.net/issues/155
                    //CLEANUP: merge delta logic with regular logic; requires common base between ODataWriter and ODataDeltaWriter
                    //WriteDynamicComplexProperties(resourceContext, writer);
                    //WriteNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext, writer);
                    //WriteExpandedNavigationProperties(selectExpandNode.ExpandedNavigationProperties, resourceContext, writer);

                    await writer.WriteEndAsync();
                }
            }
        }

        private ResourceContext GetResourceContext(object graph, ODataSerializerContext writeContext)
        {
            Contract.Assert(writeContext != null);

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);
            EdmDeltaEntityObject deltaResource = graph as EdmDeltaEntityObject;
            if (deltaResource?.NavigationSource != null)
            {
                resourceContext.NavigationSource = deltaResource.NavigationSource;
            }

            return resourceContext;
        }

        private void WriteDeltaComplexProperties(SelectExpandNode selectExpandNode,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
            {
                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Key.Type.IsCollection(),
                    Name = complexProperty.Key.Name
                };

                writer.WriteStart(nestedResourceInfo);
                WriteDeltaComplexAndExpandedNavigationProperty(complexProperty.Key, null, resourceContext, writer);
                writer.WriteEnd();
            }
        }

        private async Task WriteDeltaComplexPropertiesAsync(SelectExpandNode selectExpandNode,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
            {
                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Key.Type.IsCollection(),
                    Name = complexProperty.Key.Name
                };

                await writer.WriteStartAsync(nestedResourceInfo);
                await WriteDeltaComplexAndExpandedNavigationPropertyAsync(complexProperty.Key, null, resourceContext, writer);
                await writer.WriteEndAsync();
            }
        }

        private void WriteDeltaComplexAndExpandedNavigationProperty(IEdmProperty edmProperty, SelectExpandClause selectExpandClause,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    writer.WriteStart(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    writer.WriteStart(resource: null);
                }

                writer.WriteEnd();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, selectExpandClause, edmProperty);

                // write object.

                // TODO: enable overriding serializer based on type. Currentlky requires serializer supports WriteDeltaObjectinline, because it takes an ODataDeltaWriter
                // ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                // if (serializer == null)
                // {
                //     throw new SerializationException(
                //         Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                // }
                if (edmProperty.Type.IsCollection())
                {
                    ODataDeltaFeedSerializer serializer = new ODataDeltaFeedSerializer(SerializerProvider);
                    serializer.WriteDeltaFeedInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
                else
                {
                    ODataResourceSerializer serializer = new ODataResourceSerializer(SerializerProvider);
                    serializer.WriteDeltaObjectInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
            }
        }

        private async Task WriteDeltaComplexAndExpandedNavigationPropertyAsync(IEdmProperty edmProperty, SelectExpandClause selectExpandClause,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    await writer.WriteStartAsync(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    await writer.WriteStartAsync(resource: null);
                }

                await writer.WriteEndAsync();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, selectExpandClause, edmProperty);

                // write object.

                // TODO: enable overriding serializer based on type. Currentlky requires serializer supports WriteDeltaObjectinline, because it takes an ODataDeltaWriter
                // ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                // if (serializer == null)
                // {
                //     throw new SerializationException(
                //         Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                // }
                if (edmProperty.Type.IsCollection())
                {
                    ODataDeltaFeedSerializer serializer = new ODataDeltaFeedSerializer(SerializerProvider);
                    await serializer.WriteDeltaFeedInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
                else
                {
                    ODataResourceSerializer serializer = new ODataResourceSerializer(SerializerProvider);
                    await serializer.WriteDeltaObjectInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
            }
        }

        private static IEnumerable<ODataProperty> CreateODataPropertiesFromDynamicType(EdmEntityType entityType, object graph,
            Dictionary<IEdmProperty, object> dynamicTypeProperties)
        {
            Contract.Assert(dynamicTypeProperties != null);

            var properties = new List<ODataProperty>();
            var dynamicObject = graph as DynamicTypeWrapper;
            if (dynamicObject == null)
            {
                var dynamicEnumerable = (graph as IEnumerable<DynamicTypeWrapper>);
                if (dynamicEnumerable != null)
                {
                    dynamicObject = dynamicEnumerable.SingleOrDefault();
                }
            }
            if (dynamicObject != null)
            {
                foreach (var prop in dynamicObject.Values)
                {
                    IEdmProperty edmProperty = entityType?.Properties()
                            .FirstOrDefault(p => p.Name.Equals(prop.Key));
                    if (prop.Value != null
                        && (prop.Value is DynamicTypeWrapper || (prop.Value is IEnumerable<DynamicTypeWrapper>)))
                    {                
                        if (edmProperty != null)
                        {
                            dynamicTypeProperties.Add(edmProperty, prop.Value);
                        }
                    }
                    else
                    {
                        ODataProperty property;
                        if (prop.Value == null)
                        {
                            property = new ODataProperty
                            {
                                Name = prop.Key,
                                Value = new ODataNullValue()
                            };
                        }
                        else 
                        {
                            if (edmProperty != null)
                            {
                                property = new ODataProperty
                                {
                                    Name = prop.Key,
                                    Value = ODataPrimitiveSerializer.ConvertPrimitiveValue(prop.Value, edmProperty.Type.AsPrimitive())
                                };
                            }
                            else
                            {
                                property = new ODataProperty
                                {
                                    Name = prop.Key,
                                    Value = prop.Value
                                };
                            }
                        }

                        properties.Add(property);
                    }
                }
            }
            return properties;
        }

        private void WriteDynamicTypeResource(object graph, ODataWriter writer, IEdmTypeReference expectedType,
            ODataSerializerContext writeContext)
        {
            var dynamicTypeProperties = new Dictionary<IEdmProperty, object>();
            var entityType = expectedType.Definition as EdmEntityType;
            var resource = new ODataResource()
            {
                TypeName = expectedType.FullName(),
                Properties = CreateODataPropertiesFromDynamicType(entityType, graph, dynamicTypeProperties)
            };

            resource.IsTransient = true;
            writer.WriteStart(resource);
            foreach (var property in dynamicTypeProperties.Keys)
            {
                var resourceContext = new ResourceContext(writeContext, expectedType.AsEntity(), graph);
                if (entityType.NavigationProperties().Any(p => p.Type.Equals(property.Type)) && !(property.Type is EdmCollectionTypeReference))
                {
                    var navigationProperty = entityType.NavigationProperties().FirstOrDefault(p => p.Type.Equals(property.Type));
                    var navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                    if (navigationLink != null)
                    {
                        writer.WriteStart(navigationLink);
                        WriteDynamicTypeResource(dynamicTypeProperties[property], writer, property.Type, writeContext);
                        writer.WriteEnd();
                    }
                }
                else
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = property.Type.IsCollection(),
                        Name = property.Name
                    };

                    writer.WriteStart(nestedResourceInfo);
                    WriteDynamicComplexProperty(dynamicTypeProperties[property], property.Type, resourceContext, writer);
                    writer.WriteEnd();
                }
            }

            writer.WriteEnd();
        }

        private async Task WriteDynamicTypeResourceAsync(object graph, ODataWriter writer, IEdmTypeReference expectedType,
            ODataSerializerContext writeContext)
        {
            var dynamicTypeProperties = new Dictionary<IEdmProperty, object>();
            var entityType = expectedType.Definition as EdmEntityType;
            var resource = new ODataResource()
            {
                TypeName = expectedType.FullName(),
                Properties = CreateODataPropertiesFromDynamicType(entityType, graph, dynamicTypeProperties)
            };

            resource.IsTransient = true;
            await writer.WriteStartAsync(resource);
            foreach (var property in dynamicTypeProperties.Keys)
            {
                var resourceContext = new ResourceContext(writeContext, expectedType.AsEntity(), graph);
                if (entityType.NavigationProperties().Any(p => p.Type.Equals(property.Type)) && !(property.Type is EdmCollectionTypeReference))
                {
                    var navigationProperty = entityType.NavigationProperties().FirstOrDefault(p => p.Type.Equals(property.Type));
                    var navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                    if (navigationLink != null)
                    {
                        await writer.WriteStartAsync(navigationLink);
                        await WriteDynamicTypeResourceAsync(dynamicTypeProperties[property], writer, property.Type, writeContext);
                        await writer.WriteEndAsync();
                    }
                }
                else
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = property.Type.IsCollection(),
                        Name = property.Name
                    };

                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteDynamicComplexPropertyAsync(dynamicTypeProperties[property], property.Type, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }

            await writer.WriteEndAsync();
        }

        private void WriteResource(object graph, ODataWriter writer, ODataSerializerContext writeContext,
            IEdmTypeReference expectedType)
        {
            Contract.Assert(writeContext != null);

            if (EdmLibHelpers.IsDynamicTypeWrapper(graph.GetType()))
            {
                WriteDynamicTypeResource(graph, writer, expectedType, writeContext);
                return;
            }

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);

            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);
                if (resource != null)
                {
                    if (resourceContext.SerializerContext.ExpandReference)
                    {
                        writer.WriteEntityReferenceLink(new ODataEntityReferenceLink
                        {
                            Url = resource.Id
                        });
                    }
                    else
                    {
                        writer.WriteStart(resource);
                        WriteStreamProperties(selectExpandNode, resourceContext, writer);
                        WriteComplexProperties(selectExpandNode, resourceContext, writer);
                        WriteDynamicComplexProperties(resourceContext, writer);
                        WriteNavigationLinks(selectExpandNode, resourceContext, writer);
                        WriteExpandedNavigationProperties(selectExpandNode, resourceContext, writer);
                        WriteReferencedNavigationProperties(selectExpandNode, resourceContext, writer);
                        writer.WriteEnd();
                    }
                }
            }
        }

        private async Task WriteResourceAsync(object graph, ODataWriter writer, ODataSerializerContext writeContext,
            IEdmTypeReference expectedType)
        {
            Contract.Assert(writeContext != null);

            if (EdmLibHelpers.IsDynamicTypeWrapper(graph.GetType()))
            {
                await WriteDynamicTypeResourceAsync(graph, writer, expectedType, writeContext);
                return;
            }

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);

            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);
                if (resource != null)
                {
                    if (resourceContext.SerializerContext.ExpandReference)
                    {
                        await writer.WriteEntityReferenceLinkAsync(new ODataEntityReferenceLink
                        {
                            Url = resource.Id
                        });
                    }
                    else
                    {
                        await writer.WriteStartAsync(resource);
                        await WriteStreamPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteComplexPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteDynamicComplexPropertiesAsync(resourceContext, writer);
                        await WriteNavigationLinksAsync(selectExpandNode, resourceContext, writer);
                        await WriteExpandedNavigationPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteReferencedNavigationPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await writer.WriteEndAsync();
                    }
                }
            }
        }

        /// <summary>
        /// Creates the <see cref="SelectExpandNode"/> that describes the set of properties and actions to select and expand while writing this entity.
        /// </summary>
        /// <param name="resourceContext">Contains the entity instance being written and the context.</param>
        /// <returns>
        /// The <see cref="SelectExpandNode"/> that describes the set of properties and actions to select and expand while writing this entity.
        /// </returns>
        public virtual SelectExpandNode CreateSelectExpandNode(ResourceContext resourceContext)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;
            IEdmStructuredType structuredType = resourceContext.StructuredType;

            object selectExpandNode;

            Tuple<SelectExpandClause, IEdmStructuredType> key = Tuple.Create(writeContext.SelectExpandClause, structuredType);
            if (!writeContext.Items.TryGetValue(key, out selectExpandNode))
            {
                // cache the selectExpandNode so that if we are writing a feed we don't have to construct it again.
                selectExpandNode = new SelectExpandNode(structuredType, writeContext);
                writeContext.Items[key] = selectExpandNode;
            }

            return selectExpandNode as SelectExpandNode;
        }

        /// <summary>
        /// Creates the <see cref="ODataResource"/> to be written while writing this resource.
        /// </summary>
        /// <param name="selectExpandNode">The <see cref="SelectExpandNode"/> describing the response graph.</param>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        /// <returns>The created <see cref="ODataResource"/>.</returns>
        public virtual ODataResource CreateResource(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            if (selectExpandNode == null)
            {
                throw Error.ArgumentNull("selectExpandNode");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (resourceContext.SerializerContext.ExpandReference)
            {
                return new ODataResource
                {
                    Id = resourceContext.GenerateSelfLink(false)
                };
            }

            string typeName = resourceContext.StructuredType.FullTypeName();
            ODataResource resource = new ODataResource
            {
                TypeName = typeName,
                Properties = CreateStructuralPropertyBag(selectExpandNode, resourceContext),
            };

            if (resourceContext.EdmObject is EdmDeltaEntityObject && resourceContext.NavigationSource != null)
            {
                ODataResourceSerializationInfo serializationInfo = new ODataResourceSerializationInfo();
                serializationInfo.NavigationSourceName = resourceContext.NavigationSource.Name;
                serializationInfo.NavigationSourceKind = resourceContext.NavigationSource.NavigationSourceKind();
                IEdmEntityType sourceType = resourceContext.NavigationSource.EntityType();
                if (sourceType != null)
                {
                    serializationInfo.NavigationSourceEntityTypeName = sourceType.Name;
                }
                resource.SetSerializationInfo(serializationInfo);
            }

            // Try to add the dynamic properties if the structural type is open.
            AppendDynamicProperties(resource, selectExpandNode, resourceContext);

            // Try to add instance annotations
            AppendInstanceAnnotations(resource, resourceContext);

            if (selectExpandNode.SelectedActions != null)
            {
                IEnumerable<ODataAction> actions = CreateODataActions(selectExpandNode.SelectedActions, resourceContext);
                foreach (ODataAction action in actions)
                {
                    resource.AddAction(action);
                }
            }

            if (selectExpandNode.SelectedFunctions != null)
            {
                IEnumerable<ODataFunction> functions = CreateODataFunctions(selectExpandNode.SelectedFunctions, resourceContext);
                foreach (ODataFunction function in functions)
                {
                    resource.AddFunction(function);
                }
            }

            IEdmStructuredType pathType = GetODataPathType(resourceContext.SerializerContext);
            if (resourceContext.StructuredType.TypeKind == EdmTypeKind.Complex)
            {
                AddTypeNameAnnotationAsNeededForComplex(resource, resourceContext.SerializerContext.MetadataLevel);
            }
            else
            {
                AddTypeNameAnnotationAsNeeded(resource, pathType, resourceContext.SerializerContext.MetadataLevel);
            }

            if (resourceContext.StructuredType.TypeKind == EdmTypeKind.Entity && resourceContext.NavigationSource != null)
            {
                if (!(resourceContext.NavigationSource is IEdmContainedEntitySet))
                {
                    IEdmModel model = resourceContext.SerializerContext.Model;
                    NavigationSourceLinkBuilderAnnotation linkBuilder = model.GetNavigationSourceLinkBuilder(resourceContext.NavigationSource);
                    EntitySelfLinks selfLinks = linkBuilder.BuildEntitySelfLinks(resourceContext, resourceContext.SerializerContext.MetadataLevel);

                    if (selfLinks.IdLink != null)
                    {
                        resource.Id = selfLinks.IdLink;
                    }

                    if (selfLinks.ReadLink != null)
                    {
                        resource.ReadLink = selfLinks.ReadLink;
                    }

                    if (selfLinks.EditLink != null)
                    {
                        resource.EditLink = selfLinks.EditLink;
                    }
                }

                string etag = CreateETag(resourceContext);
                if (etag != null)
                {
                    resource.ETag = etag;
                }
            }

            return resource;
        }

        /// <summary>
        /// Appends the dynamic properties of primitive, enum or the collection of them into the given <see cref="ODataResource"/>.
        /// If the dynamic property is a property of the complex or collection of complex, it will be saved into
        /// the dynamic complex properties dictionary of <paramref name="resourceContext"/> and be written later.
        /// </summary>
        /// <param name="resource">The <see cref="ODataResource"/> describing the resource.</param>
        /// <param name="selectExpandNode">The <see cref="SelectExpandNode"/> describing the response graph.</param>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many classes.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        public virtual void AppendDynamicProperties(ODataResource resource, SelectExpandNode selectExpandNode,
            ResourceContext resourceContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);  

            if (!resourceContext.StructuredType.IsOpen || // non-open type
                (!selectExpandNode.SelectAllDynamicProperties && selectExpandNode.SelectedDynamicProperties == null))
            {
                return;
            }

            bool nullDynamicPropertyEnabled = false;
            if (resourceContext.EdmObject is EdmDeltaComplexObject || resourceContext.EdmObject is EdmDeltaEntityObject)
            {
                nullDynamicPropertyEnabled = true;
            }
            else if (resourceContext.InternalRequest != null)
            {
                nullDynamicPropertyEnabled = resourceContext.InternalRequest.Options.NullDynamicPropertyIsEnabled;
            }

            IEdmStructuredType structuredType = resourceContext.StructuredType;
            IEdmStructuredObject structuredObject = resourceContext.EdmObject;
            object value;
            IDelta delta = structuredObject as IDelta;
            if (delta == null)
            {
                PropertyInfo dynamicPropertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType,
                    resourceContext.EdmModel);
                if (dynamicPropertyInfo == null || structuredObject == null ||
                    !structuredObject.TryGetPropertyValue(dynamicPropertyInfo.Name, out value) || value == null)
                {
                    return;
                }
            }
            else
            {
                value = ((EdmStructuredObject)structuredObject).TryGetDynamicProperties();
            }

            IDictionary<string, object> dynamicPropertyDictionary = (IDictionary<string, object>)value;

            // Build a HashSet to store the declared property names.
            // It is used to make sure the dynamic property name is different from all declared property names.
            HashSet<string> declaredPropertyNameSet = new HashSet<string>(resource.Properties.Select(p => p.Name));
            List<ODataProperty> dynamicProperties = new List<ODataProperty>();

            // To test SelectedDynamicProperties == null is enough to filter the dynamic properties.
            // Because if SelectAllDynamicProperties == true, SelectedDynamicProperties should be null always.
            // So `selectExpandNode.SelectedDynamicProperties == null` covers `SelectAllDynamicProperties == true` scenario.
            // If `selectExpandNode.SelectedDynamicProperties != null`, then we should test whether the property is selected or not using "Contains(...)".
            IEnumerable<KeyValuePair<string, object>> dynamicPropertiesToSelect =
                dynamicPropertyDictionary.Where(x => selectExpandNode.SelectedDynamicProperties == null || selectExpandNode.SelectedDynamicProperties.Contains(x.Key));
            foreach (KeyValuePair<string, object> dynamicProperty in dynamicPropertiesToSelect)
            {
                if (String.IsNullOrEmpty(dynamicProperty.Key))
                {
                    continue;
                }

                if (dynamicProperty.Value == null)
                {
                    if (nullDynamicPropertyEnabled)
                    {
                        dynamicProperties.Add(new ODataProperty
                        {
                            Name = dynamicProperty.Key,
                            Value = new ODataNullValue()
                        });
                    }

                    continue;
                }

                if (declaredPropertyNameSet.Contains(dynamicProperty.Key))
                {
                    throw Error.InvalidOperation(SRResources.DynamicPropertyNameAlreadyUsedAsDeclaredPropertyName,
                        dynamicProperty.Key, structuredType.FullTypeName());
                }

                IEdmTypeReference edmTypeReference = resourceContext.SerializerContext.GetEdmType(dynamicProperty.Value,
                    dynamicProperty.Value.GetType());
                if (edmTypeReference == null)
                {
                    throw Error.NotSupported(SRResources.TypeOfDynamicPropertyNotSupported,
                        dynamicProperty.Value.GetType().FullName, dynamicProperty.Key);
                }

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    if (resourceContext.DynamicComplexProperties == null)
                    {
                        resourceContext.DynamicComplexProperties = new ConcurrentDictionary<string, object>();
                    }

                    resourceContext.DynamicComplexProperties.Add(dynamicProperty);
                }
                else
                {
                    ODataEdmTypeSerializer propertySerializer = SerializerProvider.GetEdmTypeSerializer(edmTypeReference);
                    if (propertySerializer == null)
                    {
                        throw Error.NotSupported(SRResources.DynamicPropertyCannotBeSerialized, dynamicProperty.Key,
                            edmTypeReference.FullName());
                    }

                    dynamicProperties.Add(propertySerializer.CreateProperty(
                        dynamicProperty.Value, edmTypeReference, dynamicProperty.Key, resourceContext.SerializerContext));
                }
            }

            if (dynamicProperties.Any())
            {
                resource.Properties = resource.Properties.Concat(dynamicProperties);
            }
        }

        /// <summary>
        /// Method to append InstanceAnnotations to the ODataResource and Property.
        /// Instance annotations are annotations for a resource or a property and couldb be of contain a primitive, comple , enum or collection type 
        /// These will be saved in to an Instance annotation dictionary
        /// </summary>
        /// <param name="resource">The <see cref="ODataResource"/> describing the resource, which is being annotated.</param>
        /// <param name="resourceContext">The context for the resource instance, which is being annotated.</param>        
        public virtual void AppendInstanceAnnotations(ODataResource resource, ResourceContext resourceContext)
        {
            IEdmStructuredType structuredType = resourceContext.StructuredType;
            IEdmStructuredObject structuredObject = resourceContext.EdmObject;
            PropertyInfo instanceAnnotationInfo = EdmLibHelpers.GetInstanceAnnotationsContainer(structuredType,
                resourceContext.EdmModel);

            object value;
            
            if (instanceAnnotationInfo == null || structuredObject == null ||
                !structuredObject.TryGetPropertyValue(instanceAnnotationInfo.Name, out value) || value == null)
            {
                return;
            }

            IODataInstanceAnnotationContainer instanceAnnotationContainer = value as IODataInstanceAnnotationContainer;

            if (instanceAnnotationContainer != null)
            {
                IDictionary<string, object> clrAnnotations = instanceAnnotationContainer.GetResourceAnnotations();

                if (clrAnnotations != null)
                {
                    foreach (KeyValuePair<string, object> annotation in clrAnnotations)
                    {
                        AddODataAnnotations(resource.InstanceAnnotations, resourceContext, annotation);
                    }
                }
                                
                foreach(ODataProperty property in resource.Properties)
                {
                    string propertyName = property.Name;

                    if (property.InstanceAnnotations == null)
                    {
                        property.InstanceAnnotations = new List<ODataInstanceAnnotation>();
                    }

                    IDictionary<string, object> propertyAnnotations = instanceAnnotationContainer.GetPropertyAnnotations(propertyName);

                    if (propertyAnnotations != null)
                    {
                        foreach (KeyValuePair<string, object> annotation in propertyAnnotations)
                        {
                            AddODataAnnotations(property.InstanceAnnotations, resourceContext, annotation);
                        }
                    }                    
                } 
            }
        }

        private void AddODataAnnotations(ICollection<ODataInstanceAnnotation> InstanceAnnotations, ResourceContext resourceContext, KeyValuePair<string, object> annotation)
        {
            ODataValue annotationValue = null;

            if (annotation.Value != null)
            {
                IEdmTypeReference edmTypeReference = resourceContext.SerializerContext.GetEdmType(annotation.Value,
                                            annotation.Value.GetType());

                ODataEdmTypeSerializer edmTypeSerializer = GetEdmTypeSerializer(edmTypeReference);

                if (edmTypeSerializer != null)
                {
                    annotationValue = edmTypeSerializer.CreateODataValue(annotation.Value, edmTypeReference, resourceContext.SerializerContext);
                }
            }
            else
            {
                annotationValue = new ODataNullValue();
            }

            if (annotationValue != null)
            {
                InstanceAnnotations.Add(new ODataInstanceAnnotation(annotation.Key, annotationValue));               
            }            
        }

        private ODataEdmTypeSerializer GetEdmTypeSerializer(IEdmTypeReference edmTypeReference)
        {
            ODataEdmTypeSerializer edmTypeSerializer;
           
            if (edmTypeReference.IsCollection())
            {
                edmTypeSerializer = new ODataCollectionSerializer(SerializerProvider, true);
            }
            else if (edmTypeReference.IsStructured())
            {
                edmTypeSerializer = new ODataResourceValueSerializer(SerializerProvider);
            }           
            else
            {
                edmTypeSerializer = SerializerProvider.GetEdmTypeSerializer(edmTypeReference);
            }

            return edmTypeSerializer;
        }

        /// <summary>
        /// Creates the ETag for the given entity.
        /// </summary>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        /// <returns>The created ETag.</returns>
        public virtual string CreateETag(ResourceContext resourceContext)
        {
            if (resourceContext.InternalRequest != null)
            {
                IEdmModel model = resourceContext.EdmModel;
                IEdmNavigationSource navigationSource = resourceContext.NavigationSource;

                IEnumerable<IEdmStructuralProperty> concurrencyProperties;
                if (model != null && navigationSource != null)
                {
                    concurrencyProperties = model.GetConcurrencyProperties(navigationSource).OrderBy(c => c.Name);
                }
                else
                {
                    concurrencyProperties = Enumerable.Empty<IEdmStructuralProperty>();
                }

                IDictionary<string, object> properties = new Dictionary<string, object>();
                foreach (IEdmStructuralProperty etagProperty in concurrencyProperties)
                {
                    properties.Add(etagProperty.Name, resourceContext.GetPropertyValue(etagProperty.Name));
                }

                return resourceContext.InternalRequest.CreateETag(properties);
            }

            return null;
        }

        /// <summary>
        /// Write the navigation link for the select navigation properties.
        /// </summary>
        private void WriteNavigationLinks(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            if (selectExpandNode.SelectedNavigationProperties == null)
            {
                return;
            }

            IEnumerable<ODataNestedResourceInfo> navigationLinks = CreateNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext);
            foreach (ODataNestedResourceInfo navigationLink in navigationLinks)
            {
                writer.WriteStart(navigationLink);
                writer.WriteEnd();
            }
        }

        /// <summary>
        /// Asynchronously write the navigation link for the select navigation properties.
        /// </summary>
        private async Task WriteNavigationLinksAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            if (selectExpandNode.SelectedNavigationProperties == null)
            {
                return;
            }

            IEnumerable<ODataNestedResourceInfo> navigationLinks = CreateNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext);
            foreach (ODataNestedResourceInfo navigationLink in navigationLinks)
            {
                await writer.WriteStartAsync(navigationLink);
                await writer.WriteEndAsync();
            }
        }

        private void WriteDynamicComplexProperties(ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.DynamicComplexProperties == null)
            {
                return;
            }

            foreach (KeyValuePair<string, object> dynamicComplexProperty in resourceContext.DynamicComplexProperties)
            {
                // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
                // However, it's safety here to skip the null dynamic property.
                if (String.IsNullOrEmpty(dynamicComplexProperty.Key) || dynamicComplexProperty.Value == null)
                {
                    continue;
                }

                IEdmTypeReference edmTypeReference =
                    resourceContext.SerializerContext.GetEdmType(dynamicComplexProperty.Value,
                        dynamicComplexProperty.Value.GetType());

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = edmTypeReference.IsCollection(),
                        Name = dynamicComplexProperty.Key,
                    };

                    writer.WriteStart(nestedResourceInfo);
                    WriteDynamicComplexProperty(dynamicComplexProperty.Value, edmTypeReference, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteDynamicComplexPropertiesAsync(ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.DynamicComplexProperties == null)
            {
                return;
            }

            foreach (KeyValuePair<string, object> dynamicComplexProperty in resourceContext.DynamicComplexProperties)
            {
                // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
                // However, it's safety here to skip the null dynamic property.
                if (String.IsNullOrEmpty(dynamicComplexProperty.Key) || dynamicComplexProperty.Value == null)
                {
                    continue;
                }

                IEdmTypeReference edmTypeReference =
                    resourceContext.SerializerContext.GetEdmType(dynamicComplexProperty.Value,
                        dynamicComplexProperty.Value.GetType());

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = edmTypeReference.IsCollection(),
                        Name = dynamicComplexProperty.Key,
                    };

                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteDynamicComplexPropertyAsync(dynamicComplexProperty.Value, edmTypeReference, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteDynamicComplexProperty(object propertyValue, IEdmTypeReference edmType, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
            Contract.Assert(propertyValue != null);

            // Create the serializer context for the nested and expanded item.
            ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, null, null);

            // Write object.
            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmType);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, edmType.ToTraceString()));
            }

            serializer.WriteObjectInline(propertyValue, edmType, writer, nestedWriteContext);
        }

        private Task WriteDynamicComplexPropertyAsync(object propertyValue, IEdmTypeReference edmType, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
            Contract.Assert(propertyValue != null);

            // Create the serializer context for the nested and expanded item.
            ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, null, null);

            // Write object.
            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmType);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, edmType.ToTraceString()));
            }

            return serializer.WriteObjectInlineAsync(propertyValue, edmType, writer, nestedWriteContext);
        }

        private void WriteComplexProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> selectedComplex in complexProperties)
            {
                IEdmStructuralProperty complexProperty = selectedComplex.Key;

                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Type.IsCollection(),
                    Name = complexProperty.Name
                };

                writer.WriteStart(nestedResourceInfo);
                WriteComplexAndExpandedNavigationProperty(complexProperty, selectedComplex.Value, resourceContext, writer);
                writer.WriteEnd();
            }
        }

        private async Task WriteComplexPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> selectedComplex in complexProperties)
            {
                IEdmStructuralProperty complexProperty = selectedComplex.Key;

                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Type.IsCollection(),
                    Name = complexProperty.Name
                };

                await writer.WriteStartAsync(nestedResourceInfo);
                await WriteComplexAndExpandedNavigationPropertyAsync(complexProperty, selectedComplex.Value, resourceContext, writer);
                await writer.WriteEndAsync();
            }
        }

        private void WriteStreamProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        ODataStreamPropertyInfo property = CreateStreamProperty(structuralProperty, resourceContext);

                        if (property != null)
                        {
                            writer.WriteStart(property);
                            writer.WriteEnd();
                        }
                    }
                }
            }
        }

        private async Task WriteStreamPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        ODataStreamPropertyInfo property = CreateStreamProperty(structuralProperty, resourceContext);

                        if (property != null)
                        {
                            await writer.WriteStartAsync(property);
                            await writer.WriteEndAsync();
                        }
                    }
                }
            }
        }

        private IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> GetPropertiesToWrite(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            IDictionary<IEdmStructuralProperty, PathSelectItem> complexProperties = selectExpandNode.SelectedComplexTypeProperties;

            if (complexProperties != null)
            {
                IEnumerable<string> changedProperties = null;
                if (null != resourceContext.EdmObject && resourceContext.EdmObject.IsDeltaResource())
                {
                    IDelta deltaObject = resourceContext.EdmObject as IDelta;
                    changedProperties = deltaObject.GetChangedPropertyNames();
                }

                foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
                {
                    if (changedProperties == null || changedProperties.Contains(complexProperty.Key.Name))
                    {
                        yield return complexProperty;
                    }
                }
            }
        }

        private void WriteExpandedNavigationProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> navigationPropertiesToExpand = selectExpandNode.ExpandedProperties;
            if (navigationPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedNavigationSelectItem> navPropertyToExpand in navigationPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = navPropertyToExpand.Key;

                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                if (navigationLink != null)
                {
                    writer.WriteStart(navigationLink);
                    WriteComplexAndExpandedNavigationProperty(navigationProperty, navPropertyToExpand.Value, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteExpandedNavigationPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> navigationPropertiesToExpand = selectExpandNode.ExpandedProperties;
            if (navigationPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedNavigationSelectItem> navPropertyToExpand in navigationPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = navPropertyToExpand.Key;

                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                if (navigationLink != null)
                {
                    await writer.WriteStartAsync(navigationLink);
                    await WriteComplexAndExpandedNavigationPropertyAsync(navigationProperty, navPropertyToExpand.Value, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteReferencedNavigationProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> referencedPropertiesToExpand = selectExpandNode.ReferencedProperties;
            if (referencedPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedReferenceSelectItem> referenced in referencedPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = referenced.Key;

                ODataNestedResourceInfo nestedResourceInfo = CreateNavigationLink(navigationProperty, resourceContext);
                if (nestedResourceInfo != null)
                {
                    writer.WriteStart(nestedResourceInfo);
                    WriteComplexAndExpandedNavigationProperty(navigationProperty, referenced.Value, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteReferencedNavigationPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> referencedPropertiesToExpand = selectExpandNode.ReferencedProperties;
            if (referencedPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedReferenceSelectItem> referenced in referencedPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = referenced.Key;

                ODataNestedResourceInfo nestedResourceInfo = CreateNavigationLink(navigationProperty, resourceContext);
                if (nestedResourceInfo != null)
                {
                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteComplexAndExpandedNavigationPropertyAsync(navigationProperty, referenced.Value, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteComplexAndExpandedNavigationProperty(IEdmProperty edmProperty, SelectItem selectItem, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    writer.WriteStart(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    writer.WriteStart(resource: null);
                }

                writer.WriteEnd();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, edmProperty, resourceContext.SerializerContext.QueryContext, selectItem);

                // write object.
                ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                if (serializer == null)
                {
                    throw new SerializationException(Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                }

                serializer.WriteObjectInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
            }
        }

        private async Task WriteComplexAndExpandedNavigationPropertyAsync(IEdmProperty edmProperty, SelectItem selectItem, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    await writer.WriteStartAsync(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    await writer.WriteStartAsync(resource: null);
                }

                await writer.WriteEndAsync();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, edmProperty, resourceContext.SerializerContext.QueryContext, selectItem);

                // write object.
                ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                if (serializer == null)
                {
                    throw new SerializationException(Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                }

                await serializer.WriteObjectInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
            }
        }

        private IEnumerable<ODataNestedResourceInfo> CreateNavigationLinks(
            IEnumerable<IEdmNavigationProperty> navigationProperties, ResourceContext resourceContext)
        {
            Contract.Assert(navigationProperties != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmNavigationProperty navProperty in navigationProperties)
            {
                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navProperty, resourceContext);
                if (navigationLink != null)
                {
                    yield return navigationLink;
                }
            }
        }

        /// <summary>
        /// Creates the <see cref="ODataNestedResourceInfo"/> to be written while writing this entity.
        /// </summary>
        /// <param name="navigationProperty">The navigation property for which the navigation link is being created.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The navigation link to be written.</returns>
        public virtual ODataNestedResourceInfo CreateNavigationLink(IEdmNavigationProperty navigationProperty, ResourceContext resourceContext)
        {
            if (navigationProperty == null)
            {
                throw Error.ArgumentNull("navigationProperty");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;
            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataNestedResourceInfo navigationLink = null;

            if (navigationSource != null)
            {
                IEdmTypeReference propertyType = navigationProperty.Type;
                IEdmModel model = writeContext.Model;
                NavigationSourceLinkBuilderAnnotation linkBuilder = model.GetNavigationSourceLinkBuilder(navigationSource);
                Uri navigationUrl = linkBuilder.BuildNavigationLink(resourceContext, navigationProperty, writeContext.MetadataLevel);

                navigationLink = new ODataNestedResourceInfo
                {
                    IsCollection = propertyType.IsCollection(),
                    Name = navigationProperty.Name,
                };

                if (navigationUrl != null)
                {
                    navigationLink.Url = navigationUrl;
                }
            }

            return navigationLink;
        }

        private IEnumerable<ODataProperty> CreateStructuralPropertyBag(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            List<ODataProperty> properties = new List<ODataProperty>();
            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                if (null != resourceContext.EdmObject && resourceContext.EdmObject.IsDeltaResource())
                {
                    IDelta deltaObject = resourceContext.EdmObject as IDelta;
                    IEnumerable<string> changedProperties = deltaObject.GetChangedPropertyNames();
                    structuralProperties = structuralProperties.Where(p => changedProperties.Contains(p.Name));
                }

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        // skip the stream property, the stream property is written in its own logic
                        continue;
                    }

                    ODataProperty property = CreateStructuralProperty(structuralProperty, resourceContext);
                    if (property != null)
                    {
                        properties.Add(property);
                    }
                }
            }

            return properties;
        }

        /// <summary>
        /// Creates the <see cref="ODataStreamPropertyInfo"/> to be written for the given stream property.
        /// </summary>
        /// <param name="structuralProperty">The EDM structural property being written.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The <see cref="ODataStreamPropertyInfo"/> to write.</returns>
        internal virtual ODataStreamPropertyInfo CreateStreamProperty(IEdmStructuralProperty structuralProperty, ResourceContext resourceContext)
        {
            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (structuralProperty.Type == null || !structuralProperty.Type.IsStream())
            {
                return null;
            }

            if (resourceContext.SerializerContext.MetadataLevel != ODataMetadataLevel.FullMetadata)
            {
                return null;
            }

            // TODO: we need to return ODataStreamReferenceValue if
            // 1) If we have the EditLink link builder
            // 2) If we have the ReadLink link builder
            // 3) If we have the Core.AcceptableMediaTypes annotation associated with the Stream property

            // We need a way for the user to specify a mediatype for an instance of a stream property.
            // If specified, we should explicitly write the streamreferencevalue and not let ODL fill it in.

            // Although the mediatype is represented as an instance annotation in JSON, it's really control information.
            // So we shouldn't use instance annotations to tell us the media type, but have a separate way to specify the media type.
            // Perhaps we define an interface (and stream wrapper class that derives from stream and implements the interface) that exposes a MediaType property.
            // If the stream property implements this interface, and it specifies a media-type other than application/octet-stream, we explicitly create and write a StreamReferenceValue with that media type.
            // We could also use this type to expose properties for things like ReadLink and WriteLink(and even ETag)
            // that the user could specify to something other than the default convention
            // if they wanted to provide custom routes for reading/writing the stream values or custom ETag values for the stream.

            // So far, let's return null and let OData.lib to calculate the ODataStreamReferenceValue by conventions.
            return null;
        }

        /// <summary>
        /// Creates the <see cref="ODataProperty"/> to be written for the given entity and the structural property.
        /// </summary>
        /// <param name="structuralProperty">The EDM structural property being written.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The <see cref="ODataProperty"/> to write.</returns>
        public virtual ODataProperty CreateStructuralProperty(IEdmStructuralProperty structuralProperty, ResourceContext resourceContext)
        {
            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;

            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(structuralProperty.Type);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, structuralProperty.Type.FullName()));
            }

            object propertyValue = resourceContext.GetPropertyValue(structuralProperty.Name);

            IEdmTypeReference propertyType = structuralProperty.Type;
            if (propertyValue != null)
            {
                if (!propertyType.IsPrimitive() && !propertyType.IsEnum())
                {
                    IEdmTypeReference actualType = writeContext.GetEdmType(propertyValue, propertyValue.GetType());
                    if (propertyType != null && propertyType != actualType)
                    {
                        propertyType = actualType;
                    }
                }
            }

            return serializer.CreateProperty(propertyValue, propertyType, structuralProperty.Name, writeContext);
        }

        private IEnumerable<ODataAction> CreateODataActions(
            IEnumerable<IEdmAction> actions, ResourceContext resourceContext)
        {
            Contract.Assert(actions != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmAction action in actions)
            {
                ODataAction oDataAction = CreateODataAction(action, resourceContext);
                if (oDataAction != null)
                {
                    yield return oDataAction;
                }
            }
        }

        private IEnumerable<ODataFunction> CreateODataFunctions(
            IEnumerable<IEdmFunction> functions, ResourceContext resourceContext)
        {
            Contract.Assert(functions != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmFunction function in functions)
            {
                ODataFunction oDataFunction = CreateODataFunction(function, resourceContext);
                if (oDataFunction != null)
                {
                    yield return oDataFunction;
                }
            }
        }

        /// <summary>
        /// Creates an <see cref="ODataAction" /> to be written for the given action and the entity instance.
        /// </summary>
        /// <param name="action">The OData action.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The created action or null if the action should not be written.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2234: Pass System.Uri objects instead of strings", Justification = "This overload is equally good")]
        public virtual ODataAction CreateODataAction(IEdmAction action, ResourceContext resourceContext)
        {
            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            IEdmModel model = resourceContext.EdmModel;
            OperationLinkBuilder builder = model.GetOperationLinkBuilder(action);

            if (builder == null)
            {
                return null;
            }

            return CreateODataOperation(action, builder, resourceContext) as ODataAction;
        }

        /// <summary>
        /// Creates an <see cref="ODataFunction" /> to be written for the given action and the entity instance.
        /// </summary>
        /// <param name="function">The OData function.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The created function or null if the action should not be written.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2234: Pass System.Uri objects instead of strings",
            Justification = "This overload is equally good")]
        [SuppressMessage("Microsoft.Naming", "CA1716: Use function as parameter name", Justification = "Function")]
        public virtual ODataFunction CreateODataFunction(IEdmFunction function, ResourceContext resourceContext)
        {
            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            IEdmModel model = resourceContext.EdmModel;
            OperationLinkBuilder builder = model.GetOperationLinkBuilder(function);

            if (builder == null)
            {
                return null;
            }

            return CreateODataOperation(function, builder, resourceContext) as ODataFunction;
        }

        private static ODataOperation CreateODataOperation(IEdmOperation operation, OperationLinkBuilder builder, ResourceContext resourceContext)
        {
            Contract.Assert(operation != null);
            Contract.Assert(builder != null);
            Contract.Assert(resourceContext != null);

            ODataMetadataLevel metadataLevel = resourceContext.SerializerContext.MetadataLevel;
            IEdmModel model = resourceContext.EdmModel;

            if (ShouldOmitOperation(operation, builder, metadataLevel))
            {
                return null;
            }

            Uri target = builder.BuildLink(resourceContext);
            if (target == null)
            {
                return null;
            }

            Uri baseUri = new Uri(resourceContext.InternalUrlHelper.CreateODataLink(MetadataSegment.Instance));
            Uri metadata = new Uri(baseUri, "#" + CreateMetadataFragment(operation));

            ODataOperation odataOperation;
            if (operation is IEdmAction)
            {
                odataOperation = new ODataAction();
            }
            else
            {
                odataOperation = new ODataFunction();
            }
            odataOperation.Metadata = metadata;

            // Always omit the title in minimal/no metadata modes.
            if (metadataLevel == ODataMetadataLevel.FullMetadata)
            {
                EmitTitle(model, operation, odataOperation);
            }

            // Omit the target in minimal/no metadata modes unless it doesn't follow conventions.
            if (!builder.FollowsConventions || metadataLevel == ODataMetadataLevel.FullMetadata)
            {
                odataOperation.Target = target;
            }

            return odataOperation;
        }

        internal static void EmitTitle(IEdmModel model, IEdmOperation operation, ODataOperation odataOperation)
        {
            // The title should only be emitted in full metadata.
            OperationTitleAnnotation titleAnnotation = model.GetOperationTitleAnnotation(operation);
            if (titleAnnotation != null)
            {
                odataOperation.Title = titleAnnotation.Title;
            }
            else
            {
                odataOperation.Title = operation.Name;
            }
        }

        internal static string CreateMetadataFragment(IEdmOperation operation)
        {
            // There can only be one entity container in OData V4.
            string actionName = operation.Name;
            string fragment = operation.Namespace + "." + actionName;

            return fragment;
        }

        private static IEdmStructuredType GetODataPathType(ODataSerializerContext serializerContext)
        {
            Contract.Assert(serializerContext != null);
            if (serializerContext.EdmProperty != null)
            {
                // we are in an nested complex or expanded navigation property.
                if (serializerContext.EdmProperty.Type.IsCollection())
                {
                    return serializerContext.EdmProperty.Type.AsCollection().ElementType().ToStructuredType();
                }
                else
                {
                    return serializerContext.EdmProperty.Type.AsStructured().StructuredDefinition();
                }
            }
            else
            {
                if (serializerContext.ExpandedResource != null)
                {
                    // we are in dynamic complex.
                    return null;
                }

                IEdmType edmType = null;

                // figure out the type from the navigation source
                if (serializerContext.NavigationSource != null)
                {
                    edmType = serializerContext.NavigationSource.EntityType();
                    if (edmType.TypeKind == EdmTypeKind.Collection)
                    {
                        edmType = (edmType as IEdmCollectionType).ElementType.Definition;
                    }
                }

                // figure out the type from the path.
                if (serializerContext.Path != null)
                {
                    // Note: The navigation source may be different from the path if the instance has redefined the context
                    // (for example, in a flattended delta response)
                    if (serializerContext.NavigationSource == null || serializerContext.NavigationSource == serializerContext.Path.NavigationSource)
                    {
                        edmType = serializerContext.Path.EdmType;
                        if (edmType != null && edmType.TypeKind == EdmTypeKind.Collection)
                        {
                            edmType = (edmType as IEdmCollectionType).ElementType.Definition;
                        }
                    }
                }

                return edmType as IEdmStructuredType;
            }
        }

        internal static void AddTypeNameAnnotationAsNeeded(ODataResource resource, IEdmStructuredType odataPathType,
            ODataMetadataLevel metadataLevel)
        {
            // ODataLib normally has the caller decide whether or not to serialize properties by leaving properties
            // null when values should not be serialized. The TypeName property is different and should always be
            // provided to ODataLib to enable model validation. A separate annotation is used to decide whether or not
            // to serialize the type name (a null value prevents serialization).

            // Note: In the current version of ODataLib the default behavior likely now matches the requirements for
            // minimal metadata mode. However, there have been behavior changes/bugs there in the past, so the safer
            // option is for this class to take control of type name serialization in minimal metadata mode.

            Contract.Assert(resource != null);

            string typeName = null; // Set null to force the type name not to serialize.

            // Provide the type name to serialize.
            if (!ShouldSuppressTypeNameSerialization(resource, odataPathType, metadataLevel))
            {
                typeName = resource.TypeName;
            }

            resource.TypeAnnotation = new ODataTypeAnnotation(typeName);
        }

        internal static void AddTypeNameAnnotationAsNeededForComplex(ODataResource resource, ODataMetadataLevel metadataLevel)
        {
            // ODataLib normally has the caller decide whether or not to serialize properties by leaving properties
            // null when values should not be serialized. The TypeName property is different and should always be
            // provided to ODataLib to enable model validation. A separate annotation is used to decide whether or not
            // to serialize the type name (a null value prevents serialization).
            Contract.Assert(resource != null);

            // Only add an annotation if we want to override ODataLib's default type name serialization behavior.
            if (ShouldAddTypeNameAnnotationForComplex(metadataLevel))
            {
                string typeName;

                // Provide the type name to serialize (or null to force it not to serialize).
                if (ShouldSuppressTypeNameSerializationForComplex(metadataLevel))
                {
                    typeName = null;
                }
                else
                {
                    typeName = resource.TypeName;
                }

                resource.TypeAnnotation = new ODataTypeAnnotation(typeName);
            }
        }

        internal static bool ShouldAddTypeNameAnnotationForComplex(ODataMetadataLevel metadataLevel)
        {
            switch (metadataLevel)
            {
                // For complex types, the default behavior matches the requirements for minimal metadata mode, so no
                // annotation is necessary.
                case ODataMetadataLevel.MinimalMetadata:
                    return false;
                // In other cases, this class must control the type name serialization behavior.
                case ODataMetadataLevel.FullMetadata:
                case ODataMetadataLevel.NoMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return true;
            }
        }

        internal static bool ShouldSuppressTypeNameSerializationForComplex(ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(metadataLevel != ODataMetadataLevel.MinimalMetadata);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.NoMetadata:
                    return true;
                case ODataMetadataLevel.FullMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return false;
            }
        }

        internal static bool ShouldOmitOperation(IEdmOperation operation, OperationLinkBuilder builder,
            ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(builder != null);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.MinimalMetadata:
                case ODataMetadataLevel.NoMetadata:
                    return operation.IsBound && builder.FollowsConventions;

                case ODataMetadataLevel.FullMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return false;
            }
        }

        internal static bool ShouldSuppressTypeNameSerialization(ODataResource resource, IEdmStructuredType edmType,
            ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(resource != null);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.NoMetadata:
                    return true;
                case ODataMetadataLevel.FullMetadata:
                    return false;
                case ODataMetadataLevel.MinimalMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    string pathTypeName = null;
                    if (edmType != null)
                    {
                        pathTypeName = edmType.FullTypeName();
                    }
                    string resourceTypeName = resource.TypeName;
                    return String.Equals(resourceTypeName, pathTypeName, StringComparison.Ordinal);
            }
        }

        private IEdmStructuredTypeReference GetResourceType(object graph, ODataSerializerContext writeContext)
        {
            Contract.Assert(graph != null);

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, graph.GetType());
            Contract.Assert(edmType != null);

            if (!edmType.IsStructured())
            {
                throw new SerializationException(
                    Error.Format(SRResources.CannotWriteType, GetType().Name, edmType.FullName()));
            }

            return edmType.AsStructured();
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Common;
using Microsoft.AspNet.OData.Query.Expressions;
using Microsoft.OData;
using Microsoft.OData.Edm;
using Microsoft.OData.Edm.Vocabularies;
using Microsoft.OData.UriParser;

namespace Microsoft.AspNet.OData.Formatter.Serialization
{
    /// <summary>
    /// ODataSerializer for serializing instances of <see cref="IEdmEntityType"/> or <see cref="IEdmComplexType"/>
    /// </summary>
    [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many ODataLib classes.")]
    public class ODataResourceSerializer : ODataEdmTypeSerializer
    {
        private const string Resource = "Resource";

        /// <inheritdoc />
        public ODataResourceSerializer(ODataSerializerProvider serializerProvider)
            : base(ODataPayloadKind.Resource, serializerProvider)
        {
        }

        /// <inheritdoc />
        public override void WriteObject(object graph, Type type, ODataMessageWriter messageWriter,
            ODataSerializerContext writeContext)
        {
            if (messageWriter == null)
            {
                throw Error.ArgumentNull("messageWriter");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, type);
            Contract.Assert(edmType != null);

            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataWriter writer = messageWriter.CreateODataResourceWriter(navigationSource, edmType.ToStructuredType());
            WriteObjectInline(graph, edmType, writer, writeContext);
        }

        /// <inheritdoc />
        public override async Task WriteObjectAsync(object graph, Type type, ODataMessageWriter messageWriter,
            ODataSerializerContext writeContext)
        {
            if (messageWriter == null)
            {
                throw Error.ArgumentNull("messageWriter");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, type);
            Contract.Assert(edmType != null);

            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataWriter writer = await messageWriter.CreateODataResourceWriterAsync(navigationSource, edmType.ToStructuredType());
            await WriteObjectInlineAsync(graph, edmType, writer, writeContext);
        }

        /// <inheritdoc />
        public override void WriteObjectInline(object graph, IEdmTypeReference expectedType, ODataWriter writer,
            ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null || graph is NullEdmComplexObject)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            else
            {
                WriteResource(graph, writer, writeContext, expectedType);
            }
        }

        /// <inheritdoc />
        public override Task WriteObjectInlineAsync(object graph, IEdmTypeReference expectedType, ODataWriter writer,
            ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null || graph is NullEdmComplexObject)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }

            return WriteResourceAsync(graph, writer, writeContext, expectedType);
        }

        /// <summary>
        /// Writes the given object specified by the parameter graph as a part of an existing OData message using the given
        /// deltaWriter and the writeContext.
        /// </summary>
        /// <param name="graph">The object to be written.</param>
        /// <param name="expectedType">The expected EDM type of the object represented by <paramref name="graph"/>.</param>
        /// <param name="writer">The <see cref="ODataDeltaWriter" /> to be used for writing.</param>
        /// <param name="writeContext">The <see cref="ODataSerializerContext"/>.</param>
        public virtual void WriteDeltaObjectInline(object graph, IEdmTypeReference expectedType, ODataWriter writer,
           ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            else
            {
                WriteDeltaResource(graph, writer, writeContext);
            }
        }

        /// <summary>
        /// Writes the given object specified by the parameter graph as a part of an existing OData message using the given
        /// deltaWriter and the writeContext.
        /// </summary>
        /// <param name="graph">The object to be written.</param>
        /// <param name="expectedType">The expected EDM type of the object represented by <paramref name="graph"/>.</param>
        /// <param name="writer">The <see cref="ODataDeltaWriter" /> to be used for writing.</param>
        /// <param name="writeContext">The <see cref="ODataSerializerContext"/>.</param>
        public virtual Task WriteDeltaObjectInlineAsync(object graph, IEdmTypeReference expectedType, ODataWriter writer,
           ODataSerializerContext writeContext)
        {
            if (writer == null)
            {
                throw Error.ArgumentNull("writer");
            }

            if (writeContext == null)
            {
                throw Error.ArgumentNull("writeContext");
            }

            if (graph == null)
            {
                throw new SerializationException(Error.Format(SRResources.CannotSerializerNull, Resource));
            }
            
            return WriteDeltaResourceAsync(graph, writer, writeContext);
        }

        private void WriteDeltaResource(object graph, ODataWriter writer, ODataSerializerContext writeContext)
        {
            Contract.Assert(writeContext != null);

            ResourceContext resourceContext = GetResourceContext(graph, writeContext);
            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);

                if (resource != null)
                {
                    writer.WriteStart(resource);
                    WriteDeltaComplexProperties(selectExpandNode, resourceContext, writer);
                    //TODO: Need to add support to write Navigation Links, etc. using Delta Writer
                    //https://github.com/OData/odata.net/issues/155
                    //CLEANUP: merge delta logic with regular logic; requires common base between ODataWriter and ODataDeltaWriter
                    //WriteDynamicComplexProperties(resourceContext, writer);
                    //WriteNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext, writer);
                    //WriteExpandedNavigationProperties(selectExpandNode.ExpandedNavigationProperties, resourceContext, writer);

                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteDeltaResourceAsync(object graph, ODataWriter writer, ODataSerializerContext writeContext)
        {
            ResourceContext resourceContext = GetResourceContext(graph, writeContext);
            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);

                if (resource != null)
                {
                    await writer.WriteStartAsync(resource);
                    await WriteDeltaComplexPropertiesAsync(selectExpandNode, resourceContext, writer);
                    //TODO: Need to add support to write Navigation Links, etc. using Delta Writer
                    //https://github.com/OData/odata.net/issues/155
                    //CLEANUP: merge delta logic with regular logic; requires common base between ODataWriter and ODataDeltaWriter
                    //WriteDynamicComplexProperties(resourceContext, writer);
                    //WriteNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext, writer);
                    //WriteExpandedNavigationProperties(selectExpandNode.ExpandedNavigationProperties, resourceContext, writer);

                    await writer.WriteEndAsync();
                }
            }
        }

        private ResourceContext GetResourceContext(object graph, ODataSerializerContext writeContext)
        {
            Contract.Assert(writeContext != null);

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);
            EdmDeltaEntityObject deltaResource = graph as EdmDeltaEntityObject;
            if (deltaResource?.NavigationSource != null)
            {
                resourceContext.NavigationSource = deltaResource.NavigationSource;
            }

            return resourceContext;
        }

        private void WriteDeltaComplexProperties(SelectExpandNode selectExpandNode,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
            {
                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Key.Type.IsCollection(),
                    Name = complexProperty.Key.Name
                };

                writer.WriteStart(nestedResourceInfo);
                WriteDeltaComplexAndExpandedNavigationProperty(complexProperty.Key, null, resourceContext, writer);
                writer.WriteEnd();
            }
        }

        private async Task WriteDeltaComplexPropertiesAsync(SelectExpandNode selectExpandNode,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
            {
                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Key.Type.IsCollection(),
                    Name = complexProperty.Key.Name
                };

                await writer.WriteStartAsync(nestedResourceInfo);
                await WriteDeltaComplexAndExpandedNavigationPropertyAsync(complexProperty.Key, null, resourceContext, writer);
                await writer.WriteEndAsync();
            }
        }

        private void WriteDeltaComplexAndExpandedNavigationProperty(IEdmProperty edmProperty, SelectExpandClause selectExpandClause,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    writer.WriteStart(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    writer.WriteStart(resource: null);
                }

                writer.WriteEnd();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, selectExpandClause, edmProperty);

                // write object.

                // TODO: enable overriding serializer based on type. Currentlky requires serializer supports WriteDeltaObjectinline, because it takes an ODataDeltaWriter
                // ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                // if (serializer == null)
                // {
                //     throw new SerializationException(
                //         Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                // }
                if (edmProperty.Type.IsCollection())
                {
                    ODataDeltaFeedSerializer serializer = new ODataDeltaFeedSerializer(SerializerProvider);
                    serializer.WriteDeltaFeedInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
                else
                {
                    ODataResourceSerializer serializer = new ODataResourceSerializer(SerializerProvider);
                    serializer.WriteDeltaObjectInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
            }
        }

        private async Task WriteDeltaComplexAndExpandedNavigationPropertyAsync(IEdmProperty edmProperty, SelectExpandClause selectExpandClause,
            ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    await writer.WriteStartAsync(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    await writer.WriteStartAsync(resource: null);
                }

                await writer.WriteEndAsync();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, selectExpandClause, edmProperty);

                // write object.

                // TODO: enable overriding serializer based on type. Currentlky requires serializer supports WriteDeltaObjectinline, because it takes an ODataDeltaWriter
                // ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                // if (serializer == null)
                // {
                //     throw new SerializationException(
                //         Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                // }
                if (edmProperty.Type.IsCollection())
                {
                    ODataDeltaFeedSerializer serializer = new ODataDeltaFeedSerializer(SerializerProvider);
                    await serializer.WriteDeltaFeedInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
                else
                {
                    ODataResourceSerializer serializer = new ODataResourceSerializer(SerializerProvider);
                    await serializer.WriteDeltaObjectInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
                }
            }
        }

        private static IEnumerable<ODataProperty> CreateODataPropertiesFromDynamicType(EdmEntityType entityType, object graph,
            Dictionary<IEdmProperty, object> dynamicTypeProperties)
        {
            Contract.Assert(dynamicTypeProperties != null);

            var properties = new List<ODataProperty>();
            if (dynamicObject == null)
            {
                var dynamicEnumerable = (graph as IEnumerable<DynamicTypeWrapper>);
                if (dynamicEnumerable != null)
                {
                    dynamicObject = dynamicEnumerable.SingleOrDefault();
                }
            }

            if (graph is DynamicTypeWrapper dynamicObject)
            {
                foreach (var prop in dynamicObject.Values)
                {
                    IEdmProperty edmProperty = entityType?.Properties()
                            .FirstOrDefault(p => p.Name.Equals(prop.Key));
                    if (prop.Value != null
                        && (prop.Value is DynamicTypeWrapper || (prop.Value is IEnumerable<DynamicTypeWrapper>)))
                    {                
                        if (edmProperty != null)
                        {
                            dynamicTypeProperties.Add(edmProperty, prop.Value);
                        }
                    }
                    else
                    {
                        ODataProperty property;
                        if (prop.Value == null)
                        {
                            property = new ODataProperty
                            {
                                Name = prop.Key,
                                Value = new ODataNullValue()
                            };
                        }
                        else 
                        {
                            if (edmProperty != null)
                            {
                                property = new ODataProperty
                                {
                                    Name = prop.Key,
                                    Value = ODataPrimitiveSerializer.ConvertPrimitiveValue(prop.Value, edmProperty.Type.AsPrimitive())
                                };
                            }
                            else
                            {
                                property = new ODataProperty
                                {
                                    Name = prop.Key,
                                    Value = prop.Value
                                };
                            }
                        }

                        properties.Add(property);
                    }
                }
            }
            return properties;
        }

        private void WriteDynamicTypeResource(object graph, ODataWriter writer, IEdmTypeReference expectedType,
            ODataSerializerContext writeContext)
        {
            var dynamicTypeProperties = new Dictionary<IEdmProperty, object>();
            var entityType = expectedType.Definition as EdmEntityType;
            var resource = new ODataResource()
            {
                TypeName = expectedType.FullName(),
                Properties = CreateODataPropertiesFromDynamicType(entityType, graph, dynamicTypeProperties)
            };

            resource.IsTransient = true;
            writer.WriteStart(resource);
            foreach (var property in dynamicTypeProperties.Keys)
            {
                var resourceContext = new ResourceContext(writeContext, expectedType.AsEntity(), graph);
                if (entityType.NavigationProperties().Any(p => p.Type.Equals(property.Type)) && !(property.Type is EdmCollectionTypeReference))
                {
                    var navigationProperty = entityType.NavigationProperties().FirstOrDefault(p => p.Type.Equals(property.Type));
                    var navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                    if (navigationLink != null)
                    {
                        writer.WriteStart(navigationLink);
                        WriteDynamicTypeResource(dynamicTypeProperties[property], writer, property.Type, writeContext);
                        writer.WriteEnd();
                    }
                }
                else
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = property.Type.IsCollection(),
                        Name = property.Name
                    };

                    writer.WriteStart(nestedResourceInfo);
                    WriteDynamicComplexProperty(dynamicTypeProperties[property], property.Type, resourceContext, writer);
                    writer.WriteEnd();
                }
            }

            writer.WriteEnd();
        }

        private async Task WriteDynamicTypeResourceAsync(object graph, ODataWriter writer, IEdmTypeReference expectedType,
            ODataSerializerContext writeContext)
        {
            var dynamicTypeProperties = new Dictionary<IEdmProperty, object>();
            var entityType = expectedType.Definition as EdmEntityType;
            var resource = new ODataResource()
            {
                TypeName = expectedType.FullName(),
                Properties = CreateODataPropertiesFromDynamicType(entityType, graph, dynamicTypeProperties)
            };

            resource.IsTransient = true;
            await writer.WriteStartAsync(resource);
            foreach (var property in dynamicTypeProperties.Keys)
            {
                var resourceContext = new ResourceContext(writeContext, expectedType.AsEntity(), graph);
                if (entityType.NavigationProperties().Any(p => p.Type.Equals(property.Type)) && !(property.Type is EdmCollectionTypeReference))
                {
                    var navigationProperty = entityType.NavigationProperties().FirstOrDefault(p => p.Type.Equals(property.Type));
                    var navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                    if (navigationLink != null)
                    {
                        await writer.WriteStartAsync(navigationLink);
                        await WriteDynamicTypeResourceAsync(dynamicTypeProperties[property], writer, property.Type, writeContext);
                        await writer.WriteEndAsync();
                    }
                }
                else
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = property.Type.IsCollection(),
                        Name = property.Name
                    };

                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteDynamicComplexPropertyAsync(dynamicTypeProperties[property], property.Type, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }

            await writer.WriteEndAsync();
        }

        private void WriteResource(object graph, ODataWriter writer, ODataSerializerContext writeContext,
            IEdmTypeReference expectedType)
        {
            Contract.Assert(writeContext != null);

            if (EdmLibHelpers.IsDynamicTypeWrapper(graph.GetType()))
            {
                WriteDynamicTypeResource(graph, writer, expectedType, writeContext);
                return;
            }

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);

            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);
                if (resource != null)
                {
                    if (resourceContext.SerializerContext.ExpandReference)
                    {
                        writer.WriteEntityReferenceLink(new ODataEntityReferenceLink
                        {
                            Url = resource.Id
                        });
                    }
                    else
                    {
                        writer.WriteStart(resource);
                        WriteStreamProperties(selectExpandNode, resourceContext, writer);
                        WriteComplexProperties(selectExpandNode, resourceContext, writer);
                        WriteDynamicComplexProperties(resourceContext, writer);
                        WriteNavigationLinks(selectExpandNode, resourceContext, writer);
                        WriteExpandedNavigationProperties(selectExpandNode, resourceContext, writer);
                        WriteReferencedNavigationProperties(selectExpandNode, resourceContext, writer);
                        writer.WriteEnd();
                    }
                }
            }
        }

        private async Task WriteResourceAsync(object graph, ODataWriter writer, ODataSerializerContext writeContext,
            IEdmTypeReference expectedType)
        {
            Contract.Assert(writeContext != null);

            if (EdmLibHelpers.IsDynamicTypeWrapper(graph.GetType()))
            {
                await WriteDynamicTypeResourceAsync(graph, writer, expectedType, writeContext);
                return;
            }

            IEdmStructuredTypeReference structuredType = GetResourceType(graph, writeContext);
            ResourceContext resourceContext = new ResourceContext(writeContext, structuredType, graph);

            SelectExpandNode selectExpandNode = CreateSelectExpandNode(resourceContext);
            if (selectExpandNode != null)
            {
                ODataResource resource = CreateResource(selectExpandNode, resourceContext);
                if (resource != null)
                {
                    if (resourceContext.SerializerContext.ExpandReference)
                    {
                        await writer.WriteEntityReferenceLinkAsync(new ODataEntityReferenceLink
                        {
                            Url = resource.Id
                        });
                    }
                    else
                    {
                        await writer.WriteStartAsync(resource);
                        await WriteStreamPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteComplexPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteDynamicComplexPropertiesAsync(resourceContext, writer);
                        await WriteNavigationLinksAsync(selectExpandNode, resourceContext, writer);
                        await WriteExpandedNavigationPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await WriteReferencedNavigationPropertiesAsync(selectExpandNode, resourceContext, writer);
                        await writer.WriteEndAsync();
                    }
                }
            }
        }

        /// <summary>
        /// Creates the <see cref="SelectExpandNode"/> that describes the set of properties and actions to select and expand while writing this entity.
        /// </summary>
        /// <param name="resourceContext">Contains the entity instance being written and the context.</param>
        /// <returns>
        /// The <see cref="SelectExpandNode"/> that describes the set of properties and actions to select and expand while writing this entity.
        /// </returns>
        public virtual SelectExpandNode CreateSelectExpandNode(ResourceContext resourceContext)
        {
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;
            IEdmStructuredType structuredType = resourceContext.StructuredType;

            object selectExpandNode;

            Tuple<SelectExpandClause, IEdmStructuredType> key = Tuple.Create(writeContext.SelectExpandClause, structuredType);
            if (!writeContext.Items.TryGetValue(key, out selectExpandNode))
            {
                // cache the selectExpandNode so that if we are writing a feed we don't have to construct it again.
                selectExpandNode = new SelectExpandNode(structuredType, writeContext);
                writeContext.Items[key] = selectExpandNode;
            }

            return selectExpandNode as SelectExpandNode;
        }

        /// <summary>
        /// Creates the <see cref="ODataResource"/> to be written while writing this resource.
        /// </summary>
        /// <param name="selectExpandNode">The <see cref="SelectExpandNode"/> describing the response graph.</param>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        /// <returns>The created <see cref="ODataResource"/>.</returns>
        public virtual ODataResource CreateResource(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            if (selectExpandNode == null)
            {
                throw Error.ArgumentNull("selectExpandNode");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (resourceContext.SerializerContext.ExpandReference)
            {
                return new ODataResource
                {
                    Id = resourceContext.GenerateSelfLink(false)
                };
            }

            string typeName = resourceContext.StructuredType.FullTypeName();
            ODataResource resource = new ODataResource
            {
                TypeName = typeName,
                Properties = CreateStructuralPropertyBag(selectExpandNode, resourceContext),
            };

            if (resourceContext.EdmObject is EdmDeltaEntityObject && resourceContext.NavigationSource != null)
            {
                ODataResourceSerializationInfo serializationInfo = new ODataResourceSerializationInfo();
                serializationInfo.NavigationSourceName = resourceContext.NavigationSource.Name;
                serializationInfo.NavigationSourceKind = resourceContext.NavigationSource.NavigationSourceKind();
                IEdmEntityType sourceType = resourceContext.NavigationSource.EntityType();
                if (sourceType != null)
                {
                    serializationInfo.NavigationSourceEntityTypeName = sourceType.Name;
                }
                resource.SetSerializationInfo(serializationInfo);
            }

            // Try to add the dynamic properties if the structural type is open.
            AppendDynamicProperties(resource, selectExpandNode, resourceContext);

            // Try to add instance annotations
            AppendInstanceAnnotations(resource, resourceContext);

            if (selectExpandNode.SelectedActions != null)
            {
                IEnumerable<ODataAction> actions = CreateODataActions(selectExpandNode.SelectedActions, resourceContext);
                foreach (ODataAction action in actions)
                {
                    resource.AddAction(action);
                }
            }

            if (selectExpandNode.SelectedFunctions != null)
            {
                IEnumerable<ODataFunction> functions = CreateODataFunctions(selectExpandNode.SelectedFunctions, resourceContext);
                foreach (ODataFunction function in functions)
                {
                    resource.AddFunction(function);
                }
            }

            IEdmStructuredType pathType = GetODataPathType(resourceContext.SerializerContext);
            if (resourceContext.StructuredType.TypeKind == EdmTypeKind.Complex)
            {
                AddTypeNameAnnotationAsNeededForComplex(resource, resourceContext.SerializerContext.MetadataLevel);
            }
            else
            {
                AddTypeNameAnnotationAsNeeded(resource, pathType, resourceContext.SerializerContext.MetadataLevel);
            }

            if (resourceContext.StructuredType.TypeKind == EdmTypeKind.Entity && resourceContext.NavigationSource != null)
            {
                if (!(resourceContext.NavigationSource is IEdmContainedEntitySet))
                {
                    IEdmModel model = resourceContext.SerializerContext.Model;
                    NavigationSourceLinkBuilderAnnotation linkBuilder = model.GetNavigationSourceLinkBuilder(resourceContext.NavigationSource);
                    EntitySelfLinks selfLinks = linkBuilder.BuildEntitySelfLinks(resourceContext, resourceContext.SerializerContext.MetadataLevel);

                    if (selfLinks.IdLink != null)
                    {
                        resource.Id = selfLinks.IdLink;
                    }

                    if (selfLinks.ReadLink != null)
                    {
                        resource.ReadLink = selfLinks.ReadLink;
                    }

                    if (selfLinks.EditLink != null)
                    {
                        resource.EditLink = selfLinks.EditLink;
                    }
                }

                string etag = CreateETag(resourceContext);
                if (etag != null)
                {
                    resource.ETag = etag;
                }
            }

            return resource;
        }

        /// <summary>
        /// Appends the dynamic properties of primitive, enum or the collection of them into the given <see cref="ODataResource"/>.
        /// If the dynamic property is a property of the complex or collection of complex, it will be saved into
        /// the dynamic complex properties dictionary of <paramref name="resourceContext"/> and be written later.
        /// </summary>
        /// <param name="resource">The <see cref="ODataResource"/> describing the resource.</param>
        /// <param name="selectExpandNode">The <see cref="SelectExpandNode"/> describing the response graph.</param>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling", Justification = "Relies on many classes.")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification = "These are simple conversion function and cannot be split up.")]
        public virtual void AppendDynamicProperties(ODataResource resource, SelectExpandNode selectExpandNode,
            ResourceContext resourceContext)
        {
            Contract.Assert(resource != null);
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);  

            if (!resourceContext.StructuredType.IsOpen || // non-open type
                (!selectExpandNode.SelectAllDynamicProperties && selectExpandNode.SelectedDynamicProperties == null))
            {
                return;
            }

            bool nullDynamicPropertyEnabled = false;
            if (resourceContext.EdmObject is EdmDeltaComplexObject || resourceContext.EdmObject is EdmDeltaEntityObject)
            {
                nullDynamicPropertyEnabled = true;
            }
            else if (resourceContext.InternalRequest != null)
            {
                nullDynamicPropertyEnabled = resourceContext.InternalRequest.Options.NullDynamicPropertyIsEnabled;
            }

            IEdmStructuredType structuredType = resourceContext.StructuredType;
            IEdmStructuredObject structuredObject = resourceContext.EdmObject;
            object value;
            IDelta delta = structuredObject as IDelta;
            if (delta == null)
            {
                PropertyInfo dynamicPropertyInfo = EdmLibHelpers.GetDynamicPropertyDictionary(structuredType,
                    resourceContext.EdmModel);
                if (dynamicPropertyInfo == null || structuredObject == null ||
                    !structuredObject.TryGetPropertyValue(dynamicPropertyInfo.Name, out value) || value == null)
                {
                    return;
                }
            }
            else
            {
                value = ((EdmStructuredObject)structuredObject).TryGetDynamicProperties();
            }

            IDictionary<string, object> dynamicPropertyDictionary = (IDictionary<string, object>)value;

            // Build a HashSet to store the declared property names.
            // It is used to make sure the dynamic property name is different from all declared property names.
            HashSet<string> declaredPropertyNameSet = new HashSet<string>(resource.Properties.Select(p => p.Name));
            List<ODataProperty> dynamicProperties = new List<ODataProperty>();

            // To test SelectedDynamicProperties == null is enough to filter the dynamic properties.
            // Because if SelectAllDynamicProperties == true, SelectedDynamicProperties should be null always.
            // So `selectExpandNode.SelectedDynamicProperties == null` covers `SelectAllDynamicProperties == true` scenario.
            // If `selectExpandNode.SelectedDynamicProperties != null`, then we should test whether the property is selected or not using "Contains(...)".
            IEnumerable<KeyValuePair<string, object>> dynamicPropertiesToSelect =
                dynamicPropertyDictionary.Where(x => selectExpandNode.SelectedDynamicProperties == null || selectExpandNode.SelectedDynamicProperties.Contains(x.Key));
            foreach (KeyValuePair<string, object> dynamicProperty in dynamicPropertiesToSelect)
            {
                if (String.IsNullOrEmpty(dynamicProperty.Key))
                {
                    continue;
                }

                if (dynamicProperty.Value == null)
                {
                    if (nullDynamicPropertyEnabled)
                    {
                        dynamicProperties.Add(new ODataProperty
                        {
                            Name = dynamicProperty.Key,
                            Value = new ODataNullValue()
                        });
                    }

                    continue;
                }

                if (declaredPropertyNameSet.Contains(dynamicProperty.Key))
                {
                    throw Error.InvalidOperation(SRResources.DynamicPropertyNameAlreadyUsedAsDeclaredPropertyName,
                        dynamicProperty.Key, structuredType.FullTypeName());
                }

                IEdmTypeReference edmTypeReference = resourceContext.SerializerContext.GetEdmType(dynamicProperty.Value,
                    dynamicProperty.Value.GetType());
                if (edmTypeReference == null)
                {
                    throw Error.NotSupported(SRResources.TypeOfDynamicPropertyNotSupported,
                        dynamicProperty.Value.GetType().FullName, dynamicProperty.Key);
                }

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    if (resourceContext.DynamicComplexProperties == null)
                    {
                        resourceContext.DynamicComplexProperties = new ConcurrentDictionary<string, object>();
                    }

                    resourceContext.DynamicComplexProperties.Add(dynamicProperty);
                }
                else
                {
                    ODataEdmTypeSerializer propertySerializer = SerializerProvider.GetEdmTypeSerializer(edmTypeReference);
                    if (propertySerializer == null)
                    {
                        throw Error.NotSupported(SRResources.DynamicPropertyCannotBeSerialized, dynamicProperty.Key,
                            edmTypeReference.FullName());
                    }

                    dynamicProperties.Add(propertySerializer.CreateProperty(
                        dynamicProperty.Value, edmTypeReference, dynamicProperty.Key, resourceContext.SerializerContext));
                }
            }

            if (dynamicProperties.Any())
            {
                resource.Properties = resource.Properties.Concat(dynamicProperties);
            }
        }

        /// <summary>
        /// Method to append InstanceAnnotations to the ODataResource and Property.
        /// Instance annotations are annotations for a resource or a property and couldb be of contain a primitive, comple , enum or collection type 
        /// These will be saved in to an Instance annotation dictionary
        /// </summary>
        /// <param name="resource">The <see cref="ODataResource"/> describing the resource, which is being annotated.</param>
        /// <param name="resourceContext">The context for the resource instance, which is being annotated.</param>        
        public virtual void AppendInstanceAnnotations(ODataResource resource, ResourceContext resourceContext)
        {
            IEdmStructuredType structuredType = resourceContext.StructuredType;
            IEdmStructuredObject structuredObject = resourceContext.EdmObject;
            PropertyInfo instanceAnnotationInfo = EdmLibHelpers.GetInstanceAnnotationsContainer(structuredType,
                resourceContext.EdmModel);

            object value;
            
            if (instanceAnnotationInfo == null || structuredObject == null ||
                !structuredObject.TryGetPropertyValue(instanceAnnotationInfo.Name, out value) || value == null)
            {
                return;
            }

            if (value is IODataInstanceAnnotationContainer instanceAnnotationContainer)
            {
                IDictionary<string, object> clrAnnotations = instanceAnnotationContainer.GetResourceAnnotations();

                if (clrAnnotations != null)
                {
                    foreach (KeyValuePair<string, object> annotation in clrAnnotations)
                    {
                        AddODataAnnotations(resource.InstanceAnnotations, resourceContext, annotation);
                    }
                }
                                
                foreach(ODataProperty property in resource.Properties)
                {
                    string propertyName = property.Name;

                    if (property.InstanceAnnotations == null)
                    {
                        property.InstanceAnnotations = new List<ODataInstanceAnnotation>();
                    }

                    IDictionary<string, object> propertyAnnotations = instanceAnnotationContainer.GetPropertyAnnotations(propertyName);

                    if (propertyAnnotations != null)
                    {
                        foreach (KeyValuePair<string, object> annotation in propertyAnnotations)
                        {
                            AddODataAnnotations(property.InstanceAnnotations, resourceContext, annotation);
                        }
                    }                    
                } 
            }
        }

        private void AddODataAnnotations(ICollection<ODataInstanceAnnotation> InstanceAnnotations, ResourceContext resourceContext, KeyValuePair<string, object> annotation)
        {
            ODataValue annotationValue = null;

            if (annotation.Value != null)
            {
                IEdmTypeReference edmTypeReference = resourceContext.SerializerContext.GetEdmType(annotation.Value,
                                            annotation.Value.GetType());

                ODataEdmTypeSerializer edmTypeSerializer = GetEdmTypeSerializer(edmTypeReference);

                if (edmTypeSerializer != null)
                {
                    annotationValue = edmTypeSerializer.CreateODataValue(annotation.Value, edmTypeReference, resourceContext.SerializerContext);
                }
            }
            else
            {
                annotationValue = new ODataNullValue();
            }

            if (annotationValue != null)
            {
                InstanceAnnotations.Add(new ODataInstanceAnnotation(annotation.Key, annotationValue));               
            }            
        }

        private ODataEdmTypeSerializer GetEdmTypeSerializer(IEdmTypeReference edmTypeReference)
        {
            ODataEdmTypeSerializer edmTypeSerializer;
           
            if (edmTypeReference.IsCollection())
            {
                edmTypeSerializer = new ODataCollectionSerializer(SerializerProvider, true);
            }
            else if (edmTypeReference.IsStructured())
            {
                edmTypeSerializer = new ODataResourceValueSerializer(SerializerProvider);
            }           
            else
            {
                edmTypeSerializer = SerializerProvider.GetEdmTypeSerializer(edmTypeReference);
            }

            return edmTypeSerializer;
        }

        /// <summary>
        /// Creates the ETag for the given entity.
        /// </summary>
        /// <param name="resourceContext">The context for the resource instance being written.</param>
        /// <returns>The created ETag.</returns>
        public virtual string CreateETag(ResourceContext resourceContext)
        {
            if (resourceContext.InternalRequest != null)
            {
                IEdmModel model = resourceContext.EdmModel;
                IEdmNavigationSource navigationSource = resourceContext.NavigationSource;

                IEnumerable<IEdmStructuralProperty> concurrencyProperties;
                if (model != null && navigationSource != null)
                {
                    concurrencyProperties = model.GetConcurrencyProperties(navigationSource).OrderBy(c => c.Name);
                }
                else
                {
                    concurrencyProperties = Enumerable.Empty<IEdmStructuralProperty>();
                }

                IDictionary<string, object> properties = new Dictionary<string, object>();
                foreach (IEdmStructuralProperty etagProperty in concurrencyProperties)
                {
                    properties.Add(etagProperty.Name, resourceContext.GetPropertyValue(etagProperty.Name));
                }

                return resourceContext.InternalRequest.CreateETag(properties);
            }

            return null;
        }

        /// <summary>
        /// Write the navigation link for the select navigation properties.
        /// </summary>
        private void WriteNavigationLinks(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            if (selectExpandNode.SelectedNavigationProperties == null)
            {
                return;
            }

            IEnumerable<ODataNestedResourceInfo> navigationLinks = CreateNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext);
            foreach (ODataNestedResourceInfo navigationLink in navigationLinks)
            {
                writer.WriteStart(navigationLink);
                writer.WriteEnd();
            }
        }

        /// <summary>
        /// Asynchronously write the navigation link for the select navigation properties.
        /// </summary>
        private async Task WriteNavigationLinksAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            if (selectExpandNode.SelectedNavigationProperties == null)
            {
                return;
            }

            IEnumerable<ODataNestedResourceInfo> navigationLinks = CreateNavigationLinks(selectExpandNode.SelectedNavigationProperties, resourceContext);
            foreach (ODataNestedResourceInfo navigationLink in navigationLinks)
            {
                await writer.WriteStartAsync(navigationLink);
                await writer.WriteEndAsync();
            }
        }

        private void WriteDynamicComplexProperties(ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.DynamicComplexProperties == null)
            {
                return;
            }

            foreach (KeyValuePair<string, object> dynamicComplexProperty in resourceContext.DynamicComplexProperties)
            {
                // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
                // However, it's safety here to skip the null dynamic property.
                if (String.IsNullOrEmpty(dynamicComplexProperty.Key) || dynamicComplexProperty.Value == null)
                {
                    continue;
                }

                IEdmTypeReference edmTypeReference =
                    resourceContext.SerializerContext.GetEdmType(dynamicComplexProperty.Value,
                        dynamicComplexProperty.Value.GetType());

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = edmTypeReference.IsCollection(),
                        Name = dynamicComplexProperty.Key,
                    };

                    writer.WriteStart(nestedResourceInfo);
                    WriteDynamicComplexProperty(dynamicComplexProperty.Value, edmTypeReference, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteDynamicComplexPropertiesAsync(ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(resourceContext.EdmModel != null);

            if (resourceContext.DynamicComplexProperties == null)
            {
                return;
            }

            foreach (KeyValuePair<string, object> dynamicComplexProperty in resourceContext.DynamicComplexProperties)
            {
                // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
                // However, it's safety here to skip the null dynamic property.
                if (String.IsNullOrEmpty(dynamicComplexProperty.Key) || dynamicComplexProperty.Value == null)
                {
                    continue;
                }

                IEdmTypeReference edmTypeReference =
                    resourceContext.SerializerContext.GetEdmType(dynamicComplexProperty.Value,
                        dynamicComplexProperty.Value.GetType());

                if (edmTypeReference.IsStructured() ||
                    (edmTypeReference.IsCollection() && edmTypeReference.AsCollection().ElementType().IsStructured()))
                {
                    ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                    {
                        IsCollection = edmTypeReference.IsCollection(),
                        Name = dynamicComplexProperty.Key,
                    };

                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteDynamicComplexPropertyAsync(dynamicComplexProperty.Value, edmTypeReference, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteDynamicComplexProperty(object propertyValue, IEdmTypeReference edmType, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
            Contract.Assert(propertyValue != null);

            // Create the serializer context for the nested and expanded item.
            ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, null, null);

            // Write object.
            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmType);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, edmType.ToTraceString()));
            }

            serializer.WriteObjectInline(propertyValue, edmType, writer, nestedWriteContext);
        }

        private Task WriteDynamicComplexPropertyAsync(object propertyValue, IEdmTypeReference edmType, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            // If the dynamic property is "null", it should be treated ahead by creating an ODataProperty with ODataNullValue.
            Contract.Assert(propertyValue != null);

            // Create the serializer context for the nested and expanded item.
            ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, null, null);

            // Write object.
            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmType);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, edmType.ToTraceString()));
            }

            return serializer.WriteObjectInlineAsync(propertyValue, edmType, writer, nestedWriteContext);
        }

        private void WriteComplexProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> selectedComplex in complexProperties)
            {
                IEdmStructuralProperty complexProperty = selectedComplex.Key;

                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Type.IsCollection(),
                    Name = complexProperty.Name
                };

                writer.WriteStart(nestedResourceInfo);
                WriteComplexAndExpandedNavigationProperty(complexProperty, selectedComplex.Value, resourceContext, writer);
                writer.WriteEnd();
            }
        }

        private async Task WriteComplexPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> complexProperties = GetPropertiesToWrite(selectExpandNode, resourceContext);

            foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> selectedComplex in complexProperties)
            {
                IEdmStructuralProperty complexProperty = selectedComplex.Key;

                ODataNestedResourceInfo nestedResourceInfo = new ODataNestedResourceInfo
                {
                    IsCollection = complexProperty.Type.IsCollection(),
                    Name = complexProperty.Name
                };

                await writer.WriteStartAsync(nestedResourceInfo);
                await WriteComplexAndExpandedNavigationPropertyAsync(complexProperty, selectedComplex.Value, resourceContext, writer);
                await writer.WriteEndAsync();
            }
        }

        private void WriteStreamProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        ODataStreamPropertyInfo property = CreateStreamProperty(structuralProperty, resourceContext);

                        if (property != null)
                        {
                            writer.WriteStart(property);
                            writer.WriteEnd();
                        }
                    }
                }
            }
        }

        private async Task WriteStreamPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        ODataStreamPropertyInfo property = CreateStreamProperty(structuralProperty, resourceContext);

                        if (property != null)
                        {
                            await writer.WriteStartAsync(property);
                            await writer.WriteEndAsync();
                        }
                    }
                }
            }
        }

        private IEnumerable<KeyValuePair<IEdmStructuralProperty, PathSelectItem>> GetPropertiesToWrite(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            IDictionary<IEdmStructuralProperty, PathSelectItem> complexProperties = selectExpandNode.SelectedComplexTypeProperties;

            if (complexProperties != null)
            {
                IEnumerable<string> changedProperties = null;
                if (null != resourceContext.EdmObject && resourceContext.EdmObject.IsDeltaResource())
                {
                    IDelta deltaObject = resourceContext.EdmObject as IDelta;
                    changedProperties = deltaObject.GetChangedPropertyNames();
                }

                foreach (KeyValuePair<IEdmStructuralProperty, PathSelectItem> complexProperty in complexProperties)
                {
                    if (changedProperties == null || changedProperties.Contains(complexProperty.Key.Name))
                    {
                        yield return complexProperty;
                    }
                }
            }
        }

        private void WriteExpandedNavigationProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> navigationPropertiesToExpand = selectExpandNode.ExpandedProperties;
            if (navigationPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedNavigationSelectItem> navPropertyToExpand in navigationPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = navPropertyToExpand.Key;

                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                if (navigationLink != null)
                {
                    writer.WriteStart(navigationLink);
                    WriteComplexAndExpandedNavigationProperty(navigationProperty, navPropertyToExpand.Value, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteExpandedNavigationPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedNavigationSelectItem> navigationPropertiesToExpand = selectExpandNode.ExpandedProperties;
            if (navigationPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedNavigationSelectItem> navPropertyToExpand in navigationPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = navPropertyToExpand.Key;

                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navigationProperty, resourceContext);
                if (navigationLink != null)
                {
                    await writer.WriteStartAsync(navigationLink);
                    await WriteComplexAndExpandedNavigationPropertyAsync(navigationProperty, navPropertyToExpand.Value, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteReferencedNavigationProperties(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> referencedPropertiesToExpand = selectExpandNode.ReferencedProperties;
            if (referencedPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedReferenceSelectItem> referenced in referencedPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = referenced.Key;

                ODataNestedResourceInfo nestedResourceInfo = CreateNavigationLink(navigationProperty, resourceContext);
                if (nestedResourceInfo != null)
                {
                    writer.WriteStart(nestedResourceInfo);
                    WriteComplexAndExpandedNavigationProperty(navigationProperty, referenced.Value, resourceContext, writer);
                    writer.WriteEnd();
                }
            }
        }

        private async Task WriteReferencedNavigationPropertiesAsync(SelectExpandNode selectExpandNode, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            IDictionary<IEdmNavigationProperty, ExpandedReferenceSelectItem> referencedPropertiesToExpand = selectExpandNode.ReferencedProperties;
            if (referencedPropertiesToExpand == null)
            {
                return;
            }

            foreach (KeyValuePair<IEdmNavigationProperty, ExpandedReferenceSelectItem> referenced in referencedPropertiesToExpand)
            {
                IEdmNavigationProperty navigationProperty = referenced.Key;

                ODataNestedResourceInfo nestedResourceInfo = CreateNavigationLink(navigationProperty, resourceContext);
                if (nestedResourceInfo != null)
                {
                    await writer.WriteStartAsync(nestedResourceInfo);
                    await WriteComplexAndExpandedNavigationPropertyAsync(navigationProperty, referenced.Value, resourceContext, writer);
                    await writer.WriteEndAsync();
                }
            }
        }

        private void WriteComplexAndExpandedNavigationProperty(IEdmProperty edmProperty, SelectItem selectItem, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    writer.WriteStart(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    writer.WriteStart(resource: null);
                }

                writer.WriteEnd();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, edmProperty, resourceContext.SerializerContext.QueryContext, selectItem);

                // write object.
                ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                if (serializer == null)
                {
                    throw new SerializationException(Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                }

                serializer.WriteObjectInline(propertyValue, edmProperty.Type, writer, nestedWriteContext);
            }
        }

        private async Task WriteComplexAndExpandedNavigationPropertyAsync(IEdmProperty edmProperty, SelectItem selectItem, ResourceContext resourceContext, ODataWriter writer)
        {
            Contract.Assert(edmProperty != null);
            Contract.Assert(resourceContext != null);
            Contract.Assert(writer != null);

            object propertyValue = resourceContext.GetPropertyValue(edmProperty.Name);

            if (propertyValue == null || propertyValue is NullEdmComplexObject)
            {
                if (edmProperty.Type.IsCollection())
                {
                    // A complex or navigation property whose Type attribute specifies a collection, the collection always exists,
                    // it may just be empty.
                    // If a collection of complex or entities can be related, it is represented as a JSON array. An empty
                    // collection of resources (one that contains no resource) is represented as an empty JSON array.
                    await writer.WriteStartAsync(new ODataResourceSet
                    {
                        TypeName = edmProperty.Type.FullName()
                    });
                }
                else
                {
                    // If at most one resource can be related, the value is null if no resource is currently related.
                    await writer.WriteStartAsync(resource: null);
                }

                await writer.WriteEndAsync();
            }
            else
            {
                // create the serializer context for the complex and expanded item.
                ODataSerializerContext nestedWriteContext = new ODataSerializerContext(resourceContext, edmProperty, resourceContext.SerializerContext.QueryContext, selectItem);

                // write object.
                ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(edmProperty.Type);
                if (serializer == null)
                {
                    throw new SerializationException(Error.Format(SRResources.TypeCannotBeSerialized, edmProperty.Type.ToTraceString()));
                }

                await serializer.WriteObjectInlineAsync(propertyValue, edmProperty.Type, writer, nestedWriteContext);
            }
        }

        private IEnumerable<ODataNestedResourceInfo> CreateNavigationLinks(
            IEnumerable<IEdmNavigationProperty> navigationProperties, ResourceContext resourceContext)
        {
            Contract.Assert(navigationProperties != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmNavigationProperty navProperty in navigationProperties)
            {
                ODataNestedResourceInfo navigationLink = CreateNavigationLink(navProperty, resourceContext);
                if (navigationLink != null)
                {
                    yield return navigationLink;
                }
            }
        }

        /// <summary>
        /// Creates the <see cref="ODataNestedResourceInfo"/> to be written while writing this entity.
        /// </summary>
        /// <param name="navigationProperty">The navigation property for which the navigation link is being created.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The navigation link to be written.</returns>
        public virtual ODataNestedResourceInfo CreateNavigationLink(IEdmNavigationProperty navigationProperty, ResourceContext resourceContext)
        {
            if (navigationProperty == null)
            {
                throw Error.ArgumentNull("navigationProperty");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;
            IEdmNavigationSource navigationSource = writeContext.NavigationSource;
            ODataNestedResourceInfo navigationLink = null;

            if (navigationSource != null)
            {
                IEdmTypeReference propertyType = navigationProperty.Type;
                IEdmModel model = writeContext.Model;
                NavigationSourceLinkBuilderAnnotation linkBuilder = model.GetNavigationSourceLinkBuilder(navigationSource);
                Uri navigationUrl = linkBuilder.BuildNavigationLink(resourceContext, navigationProperty, writeContext.MetadataLevel);

                navigationLink = new ODataNestedResourceInfo
                {
                    IsCollection = propertyType.IsCollection(),
                    Name = navigationProperty.Name,
                };

                if (navigationUrl != null)
                {
                    navigationLink.Url = navigationUrl;
                }
            }

            return navigationLink;
        }

        private IEnumerable<ODataProperty> CreateStructuralPropertyBag(SelectExpandNode selectExpandNode, ResourceContext resourceContext)
        {
            Contract.Assert(selectExpandNode != null);
            Contract.Assert(resourceContext != null);

            List<ODataProperty> properties = new List<ODataProperty>();
            if (selectExpandNode.SelectedStructuralProperties != null)
            {
                IEnumerable<IEdmStructuralProperty> structuralProperties = selectExpandNode.SelectedStructuralProperties;

                if (null != resourceContext.EdmObject && resourceContext.EdmObject.IsDeltaResource())
                {
                    IDelta deltaObject = resourceContext.EdmObject as IDelta;
                    IEnumerable<string> changedProperties = deltaObject.GetChangedPropertyNames();
                    structuralProperties = structuralProperties.Where(p => changedProperties.Contains(p.Name));
                }

                foreach (IEdmStructuralProperty structuralProperty in structuralProperties)
                {
                    if (structuralProperty.Type != null && structuralProperty.Type.IsStream())
                    {
                        // skip the stream property, the stream property is written in its own logic
                        continue;
                    }

                    ODataProperty property = CreateStructuralProperty(structuralProperty, resourceContext);
                    if (property != null)
                    {
                        properties.Add(property);
                    }
                }
            }

            return properties;
        }

        /// <summary>
        /// Creates the <see cref="ODataStreamPropertyInfo"/> to be written for the given stream property.
        /// </summary>
        /// <param name="structuralProperty">The EDM structural property being written.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The <see cref="ODataStreamPropertyInfo"/> to write.</returns>
        internal virtual ODataStreamPropertyInfo CreateStreamProperty(IEdmStructuralProperty structuralProperty, ResourceContext resourceContext)
        {
            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            if (structuralProperty.Type == null || !structuralProperty.Type.IsStream())
            {
                return null;
            }

            if (resourceContext.SerializerContext.MetadataLevel != ODataMetadataLevel.FullMetadata)
            {
                return null;
            }

            // TODO: we need to return ODataStreamReferenceValue if
            // 1) If we have the EditLink link builder
            // 2) If we have the ReadLink link builder
            // 3) If we have the Core.AcceptableMediaTypes annotation associated with the Stream property

            // We need a way for the user to specify a mediatype for an instance of a stream property.
            // If specified, we should explicitly write the streamreferencevalue and not let ODL fill it in.

            // Although the mediatype is represented as an instance annotation in JSON, it's really control information.
            // So we shouldn't use instance annotations to tell us the media type, but have a separate way to specify the media type.
            // Perhaps we define an interface (and stream wrapper class that derives from stream and implements the interface) that exposes a MediaType property.
            // If the stream property implements this interface, and it specifies a media-type other than application/octet-stream, we explicitly create and write a StreamReferenceValue with that media type.
            // We could also use this type to expose properties for things like ReadLink and WriteLink(and even ETag)
            // that the user could specify to something other than the default convention
            // if they wanted to provide custom routes for reading/writing the stream values or custom ETag values for the stream.

            // So far, let's return null and let OData.lib to calculate the ODataStreamReferenceValue by conventions.
            return null;
        }

        /// <summary>
        /// Creates the <see cref="ODataProperty"/> to be written for the given entity and the structural property.
        /// </summary>
        /// <param name="structuralProperty">The EDM structural property being written.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The <see cref="ODataProperty"/> to write.</returns>
        public virtual ODataProperty CreateStructuralProperty(IEdmStructuralProperty structuralProperty, ResourceContext resourceContext)
        {
            if (structuralProperty == null)
            {
                throw Error.ArgumentNull("structuralProperty");
            }
            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            ODataSerializerContext writeContext = resourceContext.SerializerContext;

            ODataEdmTypeSerializer serializer = SerializerProvider.GetEdmTypeSerializer(structuralProperty.Type);
            if (serializer == null)
            {
                throw new SerializationException(
                    Error.Format(SRResources.TypeCannotBeSerialized, structuralProperty.Type.FullName()));
            }

            object propertyValue = resourceContext.GetPropertyValue(structuralProperty.Name);

            IEdmTypeReference propertyType = structuralProperty.Type;
            if (propertyValue != null)
            {
                if (!propertyType.IsPrimitive() && !propertyType.IsEnum())
                {
                    IEdmTypeReference actualType = writeContext.GetEdmType(propertyValue, propertyValue.GetType());
                    if (propertyType != null && propertyType != actualType)
                    {
                        propertyType = actualType;
                    }
                }
            }

            return serializer.CreateProperty(propertyValue, propertyType, structuralProperty.Name, writeContext);
        }

        private IEnumerable<ODataAction> CreateODataActions(
            IEnumerable<IEdmAction> actions, ResourceContext resourceContext)
        {
            Contract.Assert(actions != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmAction action in actions)
            {
                ODataAction oDataAction = CreateODataAction(action, resourceContext);
                if (oDataAction != null)
                {
                    yield return oDataAction;
                }
            }
        }

        private IEnumerable<ODataFunction> CreateODataFunctions(
            IEnumerable<IEdmFunction> functions, ResourceContext resourceContext)
        {
            Contract.Assert(functions != null);
            Contract.Assert(resourceContext != null);

            foreach (IEdmFunction function in functions)
            {
                ODataFunction oDataFunction = CreateODataFunction(function, resourceContext);
                if (oDataFunction != null)
                {
                    yield return oDataFunction;
                }
            }
        }

        /// <summary>
        /// Creates an <see cref="ODataAction" /> to be written for the given action and the entity instance.
        /// </summary>
        /// <param name="action">The OData action.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The created action or null if the action should not be written.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2234: Pass System.Uri objects instead of strings", Justification = "This overload is equally good")]
        public virtual ODataAction CreateODataAction(IEdmAction action, ResourceContext resourceContext)
        {
            if (action == null)
            {
                throw Error.ArgumentNull("action");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            IEdmModel model = resourceContext.EdmModel;
            OperationLinkBuilder builder = model.GetOperationLinkBuilder(action);

            if (builder == null)
            {
                return null;
            }

            return CreateODataOperation(action, builder, resourceContext) as ODataAction;
        }

        /// <summary>
        /// Creates an <see cref="ODataFunction" /> to be written for the given action and the entity instance.
        /// </summary>
        /// <param name="function">The OData function.</param>
        /// <param name="resourceContext">The context for the entity instance being written.</param>
        /// <returns>The created function or null if the action should not be written.</returns>
        [SuppressMessage("Microsoft.Usage", "CA2234: Pass System.Uri objects instead of strings",
            Justification = "This overload is equally good")]
        [SuppressMessage("Microsoft.Naming", "CA1716: Use function as parameter name", Justification = "Function")]
        public virtual ODataFunction CreateODataFunction(IEdmFunction function, ResourceContext resourceContext)
        {
            if (function == null)
            {
                throw Error.ArgumentNull("function");
            }

            if (resourceContext == null)
            {
                throw Error.ArgumentNull("resourceContext");
            }

            IEdmModel model = resourceContext.EdmModel;
            OperationLinkBuilder builder = model.GetOperationLinkBuilder(function);

            if (builder == null)
            {
                return null;
            }

            return CreateODataOperation(function, builder, resourceContext) as ODataFunction;
        }

        private static ODataOperation CreateODataOperation(IEdmOperation operation, OperationLinkBuilder builder, ResourceContext resourceContext)
        {
            Contract.Assert(operation != null);
            Contract.Assert(builder != null);
            Contract.Assert(resourceContext != null);

            ODataMetadataLevel metadataLevel = resourceContext.SerializerContext.MetadataLevel;
            IEdmModel model = resourceContext.EdmModel;

            if (ShouldOmitOperation(operation, builder, metadataLevel))
            {
                return null;
            }

            Uri target = builder.BuildLink(resourceContext);
            if (target == null)
            {
                return null;
            }

            Uri baseUri = new Uri(resourceContext.InternalUrlHelper.CreateODataLink(MetadataSegment.Instance));
            Uri metadata = new Uri(baseUri, "#" + CreateMetadataFragment(operation));

            ODataOperation odataOperation;
            if (operation is IEdmAction)
            {
                odataOperation = new ODataAction();
            }
            else
            {
                odataOperation = new ODataFunction();
            }
            odataOperation.Metadata = metadata;

            // Always omit the title in minimal/no metadata modes.
            if (metadataLevel == ODataMetadataLevel.FullMetadata)
            {
                EmitTitle(model, operation, odataOperation);
            }

            // Omit the target in minimal/no metadata modes unless it doesn't follow conventions.
            if (!builder.FollowsConventions || metadataLevel == ODataMetadataLevel.FullMetadata)
            {
                odataOperation.Target = target;
            }

            return odataOperation;
        }

        internal static void EmitTitle(IEdmModel model, IEdmOperation operation, ODataOperation odataOperation)
        {
            // The title should only be emitted in full metadata.
            OperationTitleAnnotation titleAnnotation = model.GetOperationTitleAnnotation(operation);
            if (titleAnnotation != null)
            {
                odataOperation.Title = titleAnnotation.Title;
            }
            else
            {
                odataOperation.Title = operation.Name;
            }
        }

        internal static string CreateMetadataFragment(IEdmOperation operation)
        {
            // There can only be one entity container in OData V4.
            string actionName = operation.Name;
            string fragment = operation.Namespace + "." + actionName;

            return fragment;
        }

        private static IEdmStructuredType GetODataPathType(ODataSerializerContext serializerContext)
        {
            Contract.Assert(serializerContext != null);
            if (serializerContext.EdmProperty != null)
            {
                // we are in an nested complex or expanded navigation property.
                if (serializerContext.EdmProperty.Type.IsCollection())
                {
                    return serializerContext.EdmProperty.Type.AsCollection().ElementType().ToStructuredType();
                }
                else
                {
                    return serializerContext.EdmProperty.Type.AsStructured().StructuredDefinition();
                }
            }
            else
            {
                if (serializerContext.ExpandedResource != null)
                {
                    // we are in dynamic complex.
                    return null;
                }

                IEdmType edmType = null;

                // figure out the type from the navigation source
                if (serializerContext.NavigationSource != null)
                {
                    edmType = serializerContext.NavigationSource.EntityType();
                    if (edmType.TypeKind == EdmTypeKind.Collection)
                    {
                        edmType = (edmType as IEdmCollectionType).ElementType.Definition;
                    }
                }

                // figure out the type from the path.
                if (serializerContext.Path != null)
                {
                    // Note: The navigation source may be different from the path if the instance has redefined the context
                    // (for example, in a flattended delta response)
                    if (serializerContext.NavigationSource == null || serializerContext.NavigationSource == serializerContext.Path.NavigationSource)
                    {
                        edmType = serializerContext.Path.EdmType;
                        if (edmType != null && edmType.TypeKind == EdmTypeKind.Collection)
                        {
                            edmType = (edmType as IEdmCollectionType).ElementType.Definition;
                        }
                    }
                }

                return edmType as IEdmStructuredType;
            }
        }

        internal static void AddTypeNameAnnotationAsNeeded(ODataResource resource, IEdmStructuredType odataPathType,
            ODataMetadataLevel metadataLevel)
        {
            // ODataLib normally has the caller decide whether or not to serialize properties by leaving properties
            // null when values should not be serialized. The TypeName property is different and should always be
            // provided to ODataLib to enable model validation. A separate annotation is used to decide whether or not
            // to serialize the type name (a null value prevents serialization).

            // Note: In the current version of ODataLib the default behavior likely now matches the requirements for
            // minimal metadata mode. However, there have been behavior changes/bugs there in the past, so the safer
            // option is for this class to take control of type name serialization in minimal metadata mode.

            Contract.Assert(resource != null);

            string typeName = null; // Set null to force the type name not to serialize.

            // Provide the type name to serialize.
            if (!ShouldSuppressTypeNameSerialization(resource, odataPathType, metadataLevel))
            {
                typeName = resource.TypeName;
            }

            resource.TypeAnnotation = new ODataTypeAnnotation(typeName);
        }

        internal static void AddTypeNameAnnotationAsNeededForComplex(ODataResource resource, ODataMetadataLevel metadataLevel)
        {
            // ODataLib normally has the caller decide whether or not to serialize properties by leaving properties
            // null when values should not be serialized. The TypeName property is different and should always be
            // provided to ODataLib to enable model validation. A separate annotation is used to decide whether or not
            // to serialize the type name (a null value prevents serialization).
            Contract.Assert(resource != null);

            // Only add an annotation if we want to override ODataLib's default type name serialization behavior.
            if (ShouldAddTypeNameAnnotationForComplex(metadataLevel))
            {
                string typeName;

                // Provide the type name to serialize (or null to force it not to serialize).
                if (ShouldSuppressTypeNameSerializationForComplex(metadataLevel))
                {
                    typeName = null;
                }
                else
                {
                    typeName = resource.TypeName;
                }

                resource.TypeAnnotation = new ODataTypeAnnotation(typeName);
            }
        }

        internal static bool ShouldAddTypeNameAnnotationForComplex(ODataMetadataLevel metadataLevel)
        {
            switch (metadataLevel)
            {
                // For complex types, the default behavior matches the requirements for minimal metadata mode, so no
                // annotation is necessary.
                case ODataMetadataLevel.MinimalMetadata:
                    return false;
                // In other cases, this class must control the type name serialization behavior.
                case ODataMetadataLevel.FullMetadata:
                case ODataMetadataLevel.NoMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return true;
            }
        }

        internal static bool ShouldSuppressTypeNameSerializationForComplex(ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(metadataLevel != ODataMetadataLevel.MinimalMetadata);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.NoMetadata:
                    return true;
                case ODataMetadataLevel.FullMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return false;
            }
        }

        internal static bool ShouldOmitOperation(IEdmOperation operation, OperationLinkBuilder builder,
            ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(builder != null);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.MinimalMetadata:
                case ODataMetadataLevel.NoMetadata:
                    return operation.IsBound && builder.FollowsConventions;

                case ODataMetadataLevel.FullMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    return false;
            }
        }

        internal static bool ShouldSuppressTypeNameSerialization(ODataResource resource, IEdmStructuredType edmType,
            ODataMetadataLevel metadataLevel)
        {
            Contract.Assert(resource != null);

            switch (metadataLevel)
            {
                case ODataMetadataLevel.NoMetadata:
                    return true;
                case ODataMetadataLevel.FullMetadata:
                    return false;
                case ODataMetadataLevel.MinimalMetadata:
                default: // All values already specified; just keeping the compiler happy.
                    string pathTypeName = null;
                    if (edmType != null)
                    {
                        pathTypeName = edmType.FullTypeName();
                    }
                    string resourceTypeName = resource.TypeName;
                    return String.Equals(resourceTypeName, pathTypeName, StringComparison.Ordinal);
            }
        }

        private IEdmStructuredTypeReference GetResourceType(object graph, ODataSerializerContext writeContext)
        {
            Contract.Assert(graph != null);

            IEdmTypeReference edmType = writeContext.GetEdmType(graph, graph.GetType());
            Contract.Assert(edmType != null);

            if (!edmType.IsStructured())
            {
                throw new SerializationException(
                    Error.Format(SRResources.CannotWriteType, GetType().Name, edmType.FullName()));
            }

            return edmType.AsStructured();
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs(416,17): error CS0841: Cannot use local variable 'dynamicObject' before it is declared,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs(421,21): error CS0841: Cannot use local variable 'dynamicObject' before it is declared,D:\a\1\s\src\Microsoft.AspNet.OData.Shared\Formatter\Serialization\ODataResourceSerializer.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 15 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\PublicApi\PublicApiHelper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.AspNet.OData.Test.PublicApi
{
    internal static class PublicApiHelper
    {
        private static bool AlphabeticalGrouping = false;
        private static readonly List<Assembly> Assemblies = new List<Assembly>();

        private static Hashtable _synonms;
        public static Hashtable Synonms
        {
            get
            {
                if (_synonms == null)
                {
                    _synonms = CreateSynonms();
                }

                return _synonms;
            }
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params string[] assemblyNames)
        {
            IList<Assembly> assemblies = new List<Assembly>();
            for (int k = 0; k < assemblyNames.Length; ++k)
            {
                try
                {
                    Assembly assembly;
                    if (File.Exists(assemblyNames[k]))
                    {
                        assembly = Assembly.LoadFrom(assemblyNames[k]);
                    }
                    else
                    {
                        assembly = Assembly.Load(assemblyNames[k]);
                    }

                    assemblies.Add(assembly);
                }
                catch (Exception e)
                {
                    streamWriter.WriteLine(@"Error loading types from assembly '{0}':", assemblyNames[k]);
                    streamWriter.WriteLine(e.ToString());
                    Environment.Exit(1);
                }
            }

            DumpPublicApi(streamWriter, assemblies.ToArray());
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params Assembly[] assemblies)
        {
            Reset();

            if (assemblies.Length <= 0)
            {
                return;
            }

            ArrayList typesList = new ArrayList();
            foreach (var assembly in assemblies)
            {
                Assemblies.Add(assembly);
                typesList.AddRange(assembly.GetTypes());
            }

            typesList.Sort(TypeCompare.Default);
            DumpPublicApiImplementation(streamWriter, typesList);
        }

        private static Hashtable CreateSynonms()
        {
            Hashtable synonms = new Hashtable();

            synonms.Add("System.Void", "void");
            synonms.Add("System.Object", "object");
            synonms.Add("System.String", "string");
            synonms.Add("System.Int16", "short");
            synonms.Add("System.Int32", "int");
            synonms.Add("System.Int64", "long");
            synonms.Add("System.Byte", "byte");
            synonms.Add("System.Boolean", "bool");
            synonms.Add("System.Char", "char");
            synonms.Add("System.Decimal", "decimal");
            synonms.Add("System.Double", "double");
            synonms.Add("System.Single", "float");

            synonms.Add("System.Object[]", "object[]");
            synonms.Add("System.Char[]", "char[]");
            synonms.Add("System.Byte[]", "byte[]");
            synonms.Add("System.Int32[]", "int[]");
            synonms.Add("System.String[]", "string[]");

            return synonms;
        }

        private static void DumpPublicApiImplementation(StreamWriter streamWriter, ArrayList sortedTypeList)
        {
            StringBuilder builder = new StringBuilder();
            string lastNamespace = "";
            foreach (Type type in sortedTypeList)
            {
                builder.Length = 0;
                
                if (type.IsSpecialName)
                {
                    continue;
                }

                string typeFullName = type.FullName;
                if (typeFullName.StartsWith("<PrivateImplementationDetails>"))
                {
                    continue;
                }

                Type declaringType = type;
                while (null != declaringType)
                {
                    switch (TypeAttributes.VisibilityMask & declaringType.Attributes)
                    {
                        case TypeAttributes.Public:
                        case TypeAttributes.NestedPublic:
                        case TypeAttributes.NestedFamily:
                        case TypeAttributes.NestedFamANDAssem:
                        case TypeAttributes.NestedFamORAssem:
                            declaringType = declaringType.DeclaringType;
                            continue;
                        case TypeAttributes.NotPublic:
                        case TypeAttributes.NestedPrivate:
                        case TypeAttributes.NestedAssembly:
                            Debug.Assert(null != declaringType, "Null declaringType");
                            break;
                        default:
                            Debug.Assert(false, "Unknown type");
                            break;
                    }
                    break;
                }

                if (typeof(TypeConverter).IsAssignableFrom(type))
                {
                    ConstructorInfo ctor = type.GetConstructor(BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, EmptyTypes, EmptyParameterModifiers);
                    if (null != ctor)
                    {
                        streamWriter.WriteLine("{0}", type.FullName);
                    }
                    else
                    {
                        streamWriter.WriteLine("{0} missing public ctor", type.FullName);
                    }
                }

                if (null != declaringType)
                {
                    continue;
                }

                bool abort = AppendCustomAttributes(builder, type.GetCustomAttributes(false), false, type.IsEnum, true);
                if (abort)
                {
                    continue;
                }

                AppendClassDeclarationApi(builder, type);
                builder.Append(" {");
                builder.Append(Environment.NewLine);

                string currentNamespace = type.Namespace;
                if (lastNamespace != currentNamespace)
                {
                    lastNamespace = currentNamespace;
                }

                if (type.Name.Contains("UnmappedRequestRoutingConvention"))
                {
                    int kk = 0;
                    kk += 1;
                }
                AppendClassMemberApi(builder, type);
                if (builder.Length > 0)
                {
                    AssemblyFilter(builder);
                    streamWriter.Write(builder.ToString());
                    builder.Length = 0;
                }
                streamWriter.Write("}");
                streamWriter.Write(Environment.NewLine);
                streamWriter.Write(Environment.NewLine);
            }
        }

        private static void Reset()
        {
            _outputFilter = null;
            Assemblies.Clear();
        }

        private static String[] _outputFilter;
        private static void AssemblyFilter(StringBuilder builder)
        {
            string[] filter = _outputFilter;
            if (null == filter)
            {
                filter = new string[2 + Assemblies.Count];
                filter[0] = ", " + typeof(object).Assembly.ToString();
                filter[1] = ", " + typeof(Uri).Assembly.ToString();
                for (int i = 2; i < filter.Length; i++)
                {
                    filter[i] = ", " + Assemblies[i - 2].ToString();
                }
                _outputFilter = filter;
            }
            for (int i = 0; i < filter.Length; ++i)
            {
                builder.Replace(filter[i], "");
            }
        }

        private static void AppendClassDeclarationApi(StringBuilder builder, Type type)
        {
            if (type.IsPublic | type.IsNestedPublic)
            {
                builder.Append("public ");
            }
            else if (type.IsNestedFamily | type.IsNestedFamORAssem | type.IsNestedFamANDAssem)
            {
                builder.Append("protected ");
            }
            else
            {
                Debug.Assert(false, "non public or protected type");
            }

            if (type.IsInterface)
            {
                builder.Append("interface ");
            }
            else if (type.IsEnum)
            {
                builder.Append("enum ");
            }
            else if (type.IsValueType)
            {
                builder.Append("struct ");
            }
            else if (type.IsClass)
            {
                if (type.IsSealed)
                {
                    builder.Append("sealed ");
                }
                else if (type.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                builder.Append("class ");
            }
            else
            {
                builder.Append("? ");
            }
            builder.Append(type.FullName);

            bool haveColon = false;
            Type baseType = type.BaseType;
            if ((null != baseType) && (typeof(object) != baseType) && (typeof(ValueType) != baseType))
            {
                if (typeof(Enum) == baseType)
                {
                    baseType = Enum.GetUnderlyingType(type);
                }
                haveColon = true;
                builder.Append(" : ");
                AppendParameterType(builder, baseType);
            }

            if (!type.IsEnum)
            {
                Type[] baseInterfaces = type.GetInterfaces();
                Array.Sort(baseInterfaces, TypeCompare.Default);
                foreach (Type baseInterface in baseInterfaces)
                {
                    if (haveColon)
                    {
                        builder.Append(", ");
                    }
                    else
                    {
                        haveColon = true;
                        builder.Append(" : ");
                    }
                    builder.Append(baseInterface.Name);
                }
            }
        }

        private static void AppendClassMemberApi(StringBuilder builder, Type type)
        {
            MemberInfo[] members = type.GetMembers(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
            if (members.Length <= 0)
            {
                return;
            }

            Array.Sort(members, new MemberCompare(type));

            bool lastHadAttributes = false;
            MemberTypes lastMemberType = 0;

            foreach (MemberInfo info in members)
            {
                bool rememberLast = lastHadAttributes;
                MemberTypes rememberType = lastMemberType;
                int startLength = builder.Length;
                if (((lastMemberType != info.MemberType) && (0 != lastMemberType)) || lastHadAttributes)
                {
                    builder.Append(Environment.NewLine);
                    lastHadAttributes = false;
                }
                lastMemberType = info.MemberType;
                int newlineLength = builder.Length;

                bool abort = AppendCustomAttributes(builder, info.GetCustomAttributes(true), true, false, true);
                if (abort)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                    continue;
                }
                lastHadAttributes = (newlineLength != builder.Length);
                builder.Append("\t");
                int attributeLength = builder.Length;

                switch (info.MemberType)
                {
                    case MemberTypes.Constructor:
                        AppendConstructorInfo(builder, type, info as ConstructorInfo);
                        break;
                    case MemberTypes.Event:
                        AppendEventInfo(builder, type, info as EventInfo);
                        break;
                    case MemberTypes.Field:
                        AppendFieldInfo(builder, type, info as FieldInfo);
                        break;
                    case MemberTypes.Method:
                        AppendMethodInfo(builder, type, info as MethodInfo);
                        break;
                    case MemberTypes.Property:
                        AppendPropertyInfo(builder, type, info as PropertyInfo);
                        break;
                    case MemberTypes.NestedType:
                        //DumpClassAPI(builder, info as Type);
                        break;
                    default:
                        builder.Append(" ");
                        builder.Append(info.Name);
                        builder.Append(" ");
                        break;
                }
                if (attributeLength == builder.Length)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                }
            }
        }

        private static bool AppendCustomAttributes(StringBuilder builder, object[] attributes, bool indent, bool isEnum, bool appendNewLine)
        {
            if (attributes.Length > 0)
            {
                int count = 0;
                int startLength = builder.Length;
                Array.Sort(attributes, ObjectTypeCompare.Default);

                if (indent)
                {
                    builder.Append("\t");
                }
                builder.Append("[");
                if (appendNewLine)
                {
                    builder.Append(Environment.NewLine);
                }
                foreach (object attribute in attributes)
                {
                    if (attribute is MarshalAsAttribute)
                    {
                        continue;
                    }
                    if (attribute is StructLayoutAttribute)
                    {
                        continue;
                    }
                    if (attribute is CompilerGeneratedAttribute)
                    {
                        continue;
                    }
                    if (attribute is MethodImplAttribute)
                    {
                        continue;
                    }
                    if (attribute is TargetedPatchingOptOutAttribute)
                    {
                        continue;
                    }
                    if (attribute is SuppressMessageAttribute)
                    {
                        continue;
                    }
                    if (attribute is IteratorStateMachineAttribute)
                    {
                        continue;
                    }
                    if (attribute is DebuggerStepThroughAttribute)
                    {
                        continue;
                    }
                    if (isEnum && (attribute is SerializableAttribute))
                    {
                        continue;
                    }
                    count++;

                    if (indent)
                    {
                        builder.Append("\t");
                    }
                    builder.Append(attribute.GetType().Name);
                    builder.Append("(");

                    builder.Append("),");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                if (0 < count)
                {
                    if (indent)
                    {
                        builder.Append("\t");
                    }
                    builder.Append("]");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                else
                {
                    builder.Length = startLength;
                }
            }

            return false;
        }

        private static void AppendConstructorInfo(StringBuilder builder, Type type, ConstructorInfo info)
        {
            if (info.IsPublic)
            {
                builder.Append("public");
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                builder.Append("protected");
            }
            else return;

            builder.Append(" ");
            builder.Append(type.Name);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendEventInfo(StringBuilder builder, Type type, EventInfo info)
        {
            int propertyStart = builder.Length;

            AppendParameterType(builder, info.EventHandlerType);
            builder.Append(" ");
            builder.Append(info.Name);

            builder.Append(" {");
            bool gettable = AppendPropertyMethod(builder, type, info.GetAddMethod(), "add");
            bool settable = AppendPropertyMethod(builder, type, info.GetRemoveMethod(), "remove");
            if (gettable || settable)
            {
                builder.Append(" }");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static void AppendFieldInfo(StringBuilder builder, Type type, FieldInfo info)
        {
            if (type.IsEnum && info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("public");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("protected");
                }
            }
            else return;

            if (!type.IsEnum)
            {
                if (info.IsStatic)
                {
                    builder.Append(" static");
                }
                else if (info.IsInitOnly)
                {
                    builder.Append(" const");
                }
                if (info.IsInitOnly)
                {
                    builder.Append(" readonly");
                }
            }
            if (!type.IsEnum)
            {
                builder.Append(" ");
                AppendParameterType(builder, info.FieldType);
                builder.Append(" ");
            }

            builder.Append(info.Name);
            builder.Append(" = ");

            if (info.IsLiteral || info.IsStatic)
            {
                object fieldValue = null;
                try
                {
                    fieldValue = info.GetValue(null);
                }
                catch (Exception)
                {
                }

                if (null != fieldValue)
                {
                    if (fieldValue is string)
                    {
                        builder.Append('\"');
                        builder.Append((string)fieldValue);
                        builder.Append('\"');
                    }
                    else if (fieldValue is long)
                    {
                        builder.Append(((long)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is byte)
                    {
                        builder.Append(((byte)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is bool)
                    {
                        builder.Append(((bool)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is double)
                    {
                        builder.Append(((double)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is short)
                    {
                        builder.Append(((short)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is float)
                    {
                        builder.Append(((float)fieldValue).ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is Guid)
                    {
                        builder.Append('{');
                        builder.Append((Guid)fieldValue);
                        builder.Append('}');
                    }
                    else if (fieldValue is Enum)
                    {
                        // remove the enumness, without assuming a particular underlying type.
                        builder.Append(Convert.ChangeType(fieldValue, Enum.GetUnderlyingType(type)));
                    }
                    else
                    {
                        string svalue;
                        try
                        {
                            MethodInfo tostring = fieldValue.GetType().GetMethod("ToString", ToStringFormatParameter);
                            if (null != tostring)
                            {
                                svalue = (string)tostring.Invoke(fieldValue, ToSTringFormatValues);
                            }
                            else
                            {
                                svalue = fieldValue.ToString();
                            }
                        }
                        catch (Exception e)
                        {
                            svalue = e.ToString();
                        }
                        builder.Append(svalue);
                    }
                }
            }
            builder.Append(Environment.NewLine);
        }

        private static readonly Type[] EmptyTypes = new Type[0];
        private static readonly ParameterModifier[] EmptyParameterModifiers = new ParameterModifier[0];

        private static readonly Type[] ToStringFormatParameter = new Type[] { typeof(IFormatProvider) };
        private static readonly object[] ToSTringFormatValues = new object[] { CultureInfo.InvariantCulture };

        private static void AppendMethodInfo(StringBuilder builder, Type type, MethodInfo info)
        {
            string infoName = info.Name;
            if ("IsRowOptimized" == infoName)
            {
                return;
            }
            if (info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (!type.IsInterface)
                {
                    builder.Append("public ");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (!type.IsInterface)
                {
                    builder.Append("protected ");
                }
            }
            else if (infoName.StartsWith("Reset") && ("Reset" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("Reset".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (infoName.StartsWith("ShouldSerialize") && ("ShouldSerialize" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("ShouldSerialize".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (!(type.IsClass && type.IsSealed) && info.IsVirtual)
            {
                if (-1 == info.Name.IndexOf("."))
                {
                    builder.Append("internal ");
                }
            }
            else return;

            if (!type.IsInterface)
            {
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual && (-1 == info.Name.IndexOf(".")))
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
            }

            AppendParameterType(builder, info.ReturnType);
            builder.Append(" ");
            builder.Append(infoName);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendPropertyInfo(StringBuilder builder, Type type, PropertyInfo info)
        {
            int propertyStart = builder.Length;

            builder.Append("");
            AppendParameterType(builder, info.PropertyType);
            builder.Append(" ");
            builder.Append(info.Name);
            builder.Append(" ");

            ParameterInfo[] parameters = info.GetIndexParameters();
            if (0 < parameters.Length)
            {
                AppendParameterInfo(builder, parameters, false, true);
            }

            builder.Append(" { ");
            bool gettable = AppendPropertyMethod(builder, type, info.GetGetMethod(true), "get");
            if (gettable)
            {
                builder.Append(' ');
            }
            bool settable = AppendPropertyMethod(builder, type, info.GetSetMethod(true), "set");
            if (settable)
            {
                builder.Append(' ');
            }
            if (gettable || settable)
            {
                builder.Append("}");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static bool AppendPropertyMethod(StringBuilder builder, Type type, MethodInfo info, string method)
        {
            if (null != info)
            {
                int setStart = builder.Length;

                AppendCustomAttributes(builder, info.GetCustomAttributes(true), false, false, false);

                if (info.IsPublic)
                {
                    builder.Append("public ");
                }
                else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
                {
                    builder.Append("protected ");
                }
                else
                {
                    builder.Length = setStart;
                    return false;
                }
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual)
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
                builder.Append(method);
                builder.Append(';');
                return true;
            }

            return false;
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo[] parameters, bool asMethod, bool withNames)
        {
            if (parameters.Length > 0)
            {
                builder.Append(asMethod ? '(' : '[');
                for (int i = 0; i < parameters.Length; ++i)
                {
                    if (0 < i)
                    {
                        builder.Append(", ");
                    }
                    if (withNames)
                    {
                        AppendParameterInfo(builder, parameters[i]);
                    }
                    else
                    {
                        builder.Append(parameters[i].ParameterType.FullName);
                    }
                }

                builder.Append(asMethod ? ')' : ']');
            }
            else
            {
                builder.Append("()");
            }
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo info)
        {
            if (info.IsOut)
            {
                builder.Append("out ");
            }
            else if (info.IsOptional)
            {
                builder.Append("params ");
            }
            AppendParameterType(builder, info.ParameterType);
            builder.Append(" ");
            builder.Append(info.Name);
        }

        private static void AppendParameterType(StringBuilder builder, Type parameterType)
        {
            string name = parameterType.FullName ?? parameterType.Name;
            string synonm = (string)Synonms[name];
            if (null != synonm)
            {
                builder.Append(synonm);
            }
            else if (parameterType.IsGenericType && name.Contains("Version="))
            {
                // If there is generic type with generic parameter (for e.g. IEnumerable<T>),
                // then AppendGenericTypeName produces 'System.IEnumerable[[]]' whereas
                // type.Name is IEnumerable'1. Also, to avoid too any changes with the existing baseline,
                // only going into this method if there is a "Version=" present in the name.
                AppendGenericTypeName(builder, parameterType);
            }
            else if (name.StartsWith("Microsoft.AspNet.OData."))
            {
                builder.Append(parameterType.Name);
            }
            else
            {
                builder.Append(name);
            }
        }

        private static void AppendGenericTypeName(StringBuilder builder, Type type)
        {
            if (type.IsGenericType)
            {
                builder.Append(type.GetGenericTypeDefinition().FullName);
                builder.Append("[");
                bool first = true;
                foreach (var argType in type.GetGenericArguments())
                {
                    if (!first)
                    {
                        builder.Append(",");
                    }
                    builder.Append("[");
                    AppendGenericTypeName(builder, argType);
                    builder.Append("]");
                    first = false;
                }

                builder.Append("]");
            }
            else
            {
                builder.Append(type.FullName);
            }
        }

        public sealed class AssemblyCompare : IComparer
        {
            public int Compare(object x, object y)
            {
                string a = ((Assembly)x).GetName().Name;
                string b = ((Assembly)y).GetName().Name;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, StringComparison.Ordinal);
                }
                return cmp;
            }
        }

        public sealed class TypeCompare : IComparer
        {
            public static readonly TypeCompare Default = new TypeCompare();

            public int Compare(object x, object y)
            {
                Type a = x as Type;
                Type b = y as Type;

                string c = a.FullName ?? a.Name;
                string d = b.FullName ?? b.Name;

                int ac = 0, bc = 0;

                for (int i = 0; i < c.Length; ++i)
                {
                    if ('.' == c[i]) ac++;
                }
                for (int i = 0; i < d.Length; ++i)
                {
                    if ('.' == d[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    if (!AlphabeticalGrouping)
                    {
                        string e = (0 < ac) ? c.Substring(0, c.LastIndexOf('.')) : null;
                        string f = (0 < bc) ? d.Substring(0, d.LastIndexOf('.')) : null;

                        if (0 == String.Compare(e, f, false, CultureInfo.InvariantCulture))
                        {
                            if (a.IsEnum)
                            {
                                if (!b.IsEnum)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (a.IsValueType)
                            {
                                if (b.IsEnum)
                                {
                                    cmp = 1;
                                }
                                else if (!b.IsValueType)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (b.IsEnum || b.IsValueType)
                            {
                                cmp = 1;
                            }
                            if (0 == cmp)
                            {
                                if (a.IsInterface != b.IsInterface)
                                {
                                    cmp = (a.IsInterface ? -1 : 1);
                                }
                                else if (a.IsAbstract != b.IsAbstract)
                                {
                                    cmp = (a.IsAbstract ? -1 : 1);
                                }
                                else if (a.IsSealed != b.IsSealed)
                                {
                                    cmp = (a.IsSealed ? 1 : -1);
                                }
                            }
                        }
                    }
                    if (0 == cmp)
                    {
                        cmp = String.Compare(c, d, false, CultureInfo.InvariantCulture);
                    }
                }
                return cmp;
            }
        }

        public sealed class ObjectTypeCompare : IComparer
        {
            public static readonly ObjectTypeCompare Default = new ObjectTypeCompare();
            public int Compare(object x, object y)
            {
                string a = x.GetType().FullName;
                string b = y.GetType().FullName;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, false, CultureInfo.InvariantCulture);
                }
                return cmp;
            }
        }

        public sealed class MemberCompare : IComparer
        {
            private static readonly Hashtable MemberType;
            static MemberCompare()
            {
                Hashtable memberType = new Hashtable();
                memberType.Add(MemberTypes.Field, 1);
                memberType.Add(MemberTypes.Constructor, 2);
                memberType.Add(MemberTypes.Property, 3);
                memberType.Add(MemberTypes.Event, 4);
                memberType.Add(MemberTypes.Method, 5);
                memberType.Add(MemberTypes.NestedType, 6);
                memberType.Add(MemberTypes.TypeInfo, 7);
                memberType.Add(MemberTypes.Custom, 8);
                MemberType = memberType;
            }

            private readonly Hashtable _hash;

            public MemberCompare(Type type)
            {
                _hash = new Hashtable();
                for (int i = 0; null != type; ++i, type = type.BaseType)
                {
                    _hash.Add(type, i);
                }
            }

            public int Compare(object x, object y)
            {
                return Compare((MemberInfo)x, (MemberInfo)y);
            }

            public int Compare(MemberInfo x, MemberInfo y)
            {
                if (x.MemberType == y.MemberType)
                {
                    Type xt = x.DeclaringType;
                    Type yt = y.DeclaringType;
                    if (xt != yt)
                    {
                        return (int)_hash[yt] - (int)_hash[xt];
                    }

                    int cmp = String.Compare(x.Name, y.Name, false, CultureInfo.InvariantCulture);
                    if (0 == cmp)
                    {
                        MethodInfo xMethodInfo = null, yMethodInfo = null;
                        ParameterInfo[] xParameterInfos, yParameterInfos;
                        switch (x.MemberType)
                        {
                            case MemberTypes.Constructor:
                                xParameterInfos = ((ConstructorInfo)x).GetParameters();
                                yParameterInfos = ((ConstructorInfo)y).GetParameters();
                                break;
                            case MemberTypes.Method:
                                xMethodInfo = (MethodInfo)x;
                                yMethodInfo = (MethodInfo)y;
                                xParameterInfos = xMethodInfo.GetParameters();
                                yParameterInfos = yMethodInfo.GetParameters();
                                break;
                            case MemberTypes.Property:
                                xParameterInfos = ((PropertyInfo)x).GetIndexParameters();
                                yParameterInfos = ((PropertyInfo)y).GetIndexParameters();
                                break;
                            default:
                                xParameterInfos = yParameterInfos = new ParameterInfo[0];
                                break;
                        }
                        cmp = xParameterInfos.Length - yParameterInfos.Length;
                        if (0 == cmp)
                        {
                            int count = xParameterInfos.Length;
                            for (int i = 0; i < count; ++i)
                            {
                                cmp = String.Compare(xParameterInfos[i].ParameterType.FullName, yParameterInfos[i].ParameterType.FullName, false, CultureInfo.InvariantCulture);
                                if (cmp == 0)
                                {
                                    // For generic parameters, FullName is null. Hence comparing the names
                                    cmp = String.Compare(xParameterInfos[i].ParameterType.Name, yParameterInfos[i].ParameterType.Name, false, CultureInfo.InvariantCulture);
                                }
                                if (0 != cmp)
                                {
                                    break;
                                }
                            }

                            if (0 == cmp && xMethodInfo != null)
                            {
                                // Two methods with same name, same parameters. Sort by the # of generic type parameters.
                                cmp = xMethodInfo.GetGenericArguments().Count() - yMethodInfo.GetGenericArguments().Count();
                            }
                        }
                    }

                    return cmp;
                }
                return ((int)MemberType[x.MemberType] - (int)MemberType[y.MemberType]);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.AspNet.OData.Test.PublicApi
{
    internal static class PublicApiHelper
    {
        private static bool AlphabeticalGrouping = false;
        private static readonly List<Assembly> Assemblies = new List<Assembly>();

        private static Hashtable _synonms;
        public static Hashtable Synonms
        {
            get
            {
                if (_synonms == null)
                {
                    _synonms = CreateSynonms();
                }

                return _synonms;
            }
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params string[] assemblyNames)
        {
            IList<Assembly> assemblies = new List<Assembly>();
            for (int k = 0; k < assemblyNames.Length; ++k)
            {
                try
                {
                    Assembly assembly;
                    if (File.Exists(assemblyNames[k]))
                    {
                        assembly = Assembly.LoadFrom(assemblyNames[k]);
                    }
                    else
                    {
                        assembly = Assembly.Load(assemblyNames[k]);
                    }

                    assemblies.Add(assembly);
                }
                catch (Exception e)
                {
                    streamWriter.WriteLine(@"Error loading types from assembly '{0}':", assemblyNames[k]);
                    streamWriter.WriteLine(e.ToString());
                    Environment.Exit(1);
                }
            }

            DumpPublicApi(streamWriter, assemblies.ToArray());
        }

        public static void DumpPublicApi(StreamWriter streamWriter, params Assembly[] assemblies)
        {
            Reset();

            if (assemblies.Length <= 0)
            {
                return;
            }

            ArrayList typesList = new ArrayList();
            foreach (var assembly in assemblies)
            {
                Assemblies.Add(assembly);
                typesList.AddRange(assembly.GetTypes());
            }

            typesList.Sort(TypeCompare.Default);
            DumpPublicApiImplementation(streamWriter, typesList);
        }

        private static Hashtable CreateSynonms()
        {
            Hashtable synonms = new Hashtable();

            synonms.Add("System.Void", "void");
            synonms.Add("System.Object", "object");
            synonms.Add("System.String", "string");
            synonms.Add("System.Int16", "short");
            synonms.Add("System.Int32", "int");
            synonms.Add("System.Int64", "long");
            synonms.Add("System.Byte", "byte");
            synonms.Add("System.Boolean", "bool");
            synonms.Add("System.Char", "char");
            synonms.Add("System.Decimal", "decimal");
            synonms.Add("System.Double", "double");
            synonms.Add("System.Single", "float");

            synonms.Add("System.Object[]", "object[]");
            synonms.Add("System.Char[]", "char[]");
            synonms.Add("System.Byte[]", "byte[]");
            synonms.Add("System.Int32[]", "int[]");
            synonms.Add("System.String[]", "string[]");

            return synonms;
        }

        private static void DumpPublicApiImplementation(StreamWriter streamWriter, ArrayList sortedTypeList)
        {
            StringBuilder builder = new StringBuilder();
            string lastNamespace = "";
            foreach (Type type in sortedTypeList)
            {
                builder.Length = 0;
                
                if (type.IsSpecialName)
                {
                    continue;
                }

                string typeFullName = type.FullName;
                if (typeFullName.StartsWith("<PrivateImplementationDetails>"))
                {
                    continue;
                }

                Type declaringType = type;
                while (null != declaringType)
                {
                    switch (TypeAttributes.VisibilityMask & declaringType.Attributes)
                    {
                        case TypeAttributes.Public:
                        case TypeAttributes.NestedPublic:
                        case TypeAttributes.NestedFamily:
                        case TypeAttributes.NestedFamANDAssem:
                        case TypeAttributes.NestedFamORAssem:
                            declaringType = declaringType.DeclaringType;
                            continue;
                        case TypeAttributes.NotPublic:
                        case TypeAttributes.NestedPrivate:
                        case TypeAttributes.NestedAssembly:
                            Debug.Assert(null != declaringType, "Null declaringType");
                            break;
                        default:
                            Debug.Assert(false, "Unknown type");
                            break;
                    }
                    break;
                }

                if (typeof(TypeConverter).IsAssignableFrom(type))
                {
                    ConstructorInfo ctor = type.GetConstructor(BindingFlags.Public | BindingFlags.CreateInstance | BindingFlags.Instance, null, EmptyTypes, EmptyParameterModifiers);
                    if (null != ctor)
                    {
                        streamWriter.WriteLine("{0}", type.FullName);
                    }
                    else
                    {
                        streamWriter.WriteLine("{0} missing public ctor", type.FullName);
                    }
                }

                if (null != declaringType)
                {
                    continue;
                }

                bool abort = AppendCustomAttributes(builder, type.GetCustomAttributes(false), false, type.IsEnum, true);
                if (abort)
                {
                    continue;
                }

                AppendClassDeclarationApi(builder, type);
                builder.Append(" {");
                builder.Append(Environment.NewLine);

                string currentNamespace = type.Namespace;
                if (lastNamespace != currentNamespace)
                {
                    lastNamespace = currentNamespace;
                }

                if (type.Name.Contains("UnmappedRequestRoutingConvention"))
                {
                    int kk = 0;
                    kk += 1;
                }
                AppendClassMemberApi(builder, type);
                if (builder.Length > 0)
                {
                    AssemblyFilter(builder);
                    streamWriter.Write(builder.ToString());
                    builder.Length = 0;
                }
                streamWriter.Write("}");
                streamWriter.Write(Environment.NewLine);
                streamWriter.Write(Environment.NewLine);
            }
        }

        private static void Reset()
        {
            _outputFilter = null;
            Assemblies.Clear();
        }

        private static String[] _outputFilter;
        private static void AssemblyFilter(StringBuilder builder)
        {
            string[] filter = _outputFilter;
            if (null == filter)
            {
                filter = new string[2 + Assemblies.Count];
                filter[0] = ", " + typeof(object).Assembly.ToString();
                filter[1] = ", " + typeof(Uri).Assembly.ToString();
                for (int i = 2; i < filter.Length; i++)
                {
                    filter[i] = ", " + Assemblies[i - 2].ToString();
                }
                _outputFilter = filter;
            }
            for (int i = 0; i < filter.Length; ++i)
            {
                builder.Replace(filter[i], "");
            }
        }

        private static void AppendClassDeclarationApi(StringBuilder builder, Type type)
        {
            if (type.IsPublic | type.IsNestedPublic)
            {
                builder.Append("public ");
            }
            else if (type.IsNestedFamily | type.IsNestedFamORAssem | type.IsNestedFamANDAssem)
            {
                builder.Append("protected ");
            }
            else
            {
                Debug.Assert(false, "non public or protected type");
            }

            if (type.IsInterface)
            {
                builder.Append("interface ");
            }
            else if (type.IsEnum)
            {
                builder.Append("enum ");
            }
            else if (type.IsValueType)
            {
                builder.Append("struct ");
            }
            else if (type.IsClass)
            {
                if (type.IsSealed)
                {
                    builder.Append("sealed ");
                }
                else if (type.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                builder.Append("class ");
            }
            else
            {
                builder.Append("? ");
            }
            builder.Append(type.FullName);

            bool haveColon = false;
            Type baseType = type.BaseType;
            if ((null != baseType) && (typeof(object) != baseType) && (typeof(ValueType) != baseType))
            {
                if (typeof(Enum) == baseType)
                {
                    baseType = Enum.GetUnderlyingType(type);
                }
                haveColon = true;
                builder.Append(" : ");
                AppendParameterType(builder, baseType);
            }

            if (!type.IsEnum)
            {
                Type[] baseInterfaces = type.GetInterfaces();
                Array.Sort(baseInterfaces, TypeCompare.Default);
                foreach (Type baseInterface in baseInterfaces)
                {
                    if (haveColon)
                    {
                        builder.Append(", ");
                    }
                    else
                    {
                        haveColon = true;
                        builder.Append(" : ");
                    }
                    builder.Append(baseInterface.Name);
                }
            }
        }

        private static void AppendClassMemberApi(StringBuilder builder, Type type)
        {
            MemberInfo[] members = type.GetMembers(BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
            if (members.Length <= 0)
            {
                return;
            }

            Array.Sort(members, new MemberCompare(type));

            bool lastHadAttributes = false;
            MemberTypes lastMemberType = 0;

            foreach (MemberInfo info in members)
            {
                bool rememberLast = lastHadAttributes;
                MemberTypes rememberType = lastMemberType;
                int startLength = builder.Length;
                if (((lastMemberType != info.MemberType) && (0 != lastMemberType)) || lastHadAttributes)
                {
                    builder.Append(Environment.NewLine);
                    lastHadAttributes = false;
                }
                lastMemberType = info.MemberType;
                int newlineLength = builder.Length;

                bool abort = AppendCustomAttributes(builder, info.GetCustomAttributes(true), true, false, true);
                if (abort)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                    continue;
                }
                lastHadAttributes = (newlineLength != builder.Length);
                builder.Append("\t");
                int attributeLength = builder.Length;

                switch (info.MemberType)
                {
                    case MemberTypes.Constructor:
                        AppendConstructorInfo(builder, type, info as ConstructorInfo);
                        break;
                    case MemberTypes.Event:
                        AppendEventInfo(builder, type, info as EventInfo);
                        break;
                    case MemberTypes.Field:
                        AppendFieldInfo(builder, type, info as FieldInfo);
                        break;
                    case MemberTypes.Method:
                        AppendMethodInfo(builder, type, info as MethodInfo);
                        break;
                    case MemberTypes.Property:
                        AppendPropertyInfo(builder, type, info as PropertyInfo);
                        break;
                    case MemberTypes.NestedType:
                        //DumpClassAPI(builder, info as Type);
                        break;
                    default:
                        builder.Append(" ");
                        builder.Append(info.Name);
                        builder.Append(" ");
                        break;
                }
                if (attributeLength == builder.Length)
                {
                    builder.Length = startLength;
                    lastHadAttributes = rememberLast;
                    lastMemberType = rememberType;
                }
            }
        }

        private static bool AppendCustomAttributes(StringBuilder builder, object[] attributes, bool indent, bool isEnum, bool appendNewLine)
        {
            if (attributes.Length > 0)
            {
                int count = 0;
                int startLength = builder.Length;
                Array.Sort(attributes, ObjectTypeCompare.Default);

                if (indent)
                {
                    builder.Append("\t");
                }
                builder.Append("[");
                if (appendNewLine)
                {
                    builder.Append(Environment.NewLine);
                }
                foreach (object attribute in attributes)
                {
                    if (attribute is MarshalAsAttribute)
                    {
                        continue;
                    }
                    if (attribute is StructLayoutAttribute)
                    {
                        continue;
                    }
                    if (attribute is CompilerGeneratedAttribute)
                    {
                        continue;
                    }
                    if (attribute is MethodImplAttribute)
                    {
                        continue;
                    }
                    if (attribute is TargetedPatchingOptOutAttribute)
                    {
                        continue;
                    }
                    if (attribute is SuppressMessageAttribute)
                    {
                        continue;
                    }
                    if (attribute is IteratorStateMachineAttribute)
                    {
                        continue;
                    }
                    if (attribute is DebuggerStepThroughAttribute)
                    {
                        continue;
                    }
                    if (isEnum && (attribute is SerializableAttribute))
                    {
                        continue;
                    }
                    count++;

                    if (indent)
                    {
                        builder.Append("\t");
                    }
                    builder.Append(attribute.GetType().Name);
                    builder.Append("(");

                    builder.Append("),");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                if (0 < count)
                {
                    if (indent)
                    {
                        builder.Append("\t");
                    }
                    builder.Append("]");
                    if (appendNewLine)
                    {
                        builder.Append(Environment.NewLine);
                    }
                }
                else
                {
                    builder.Length = startLength;
                }
            }

            return false;
        }

        private static void AppendConstructorInfo(StringBuilder builder, Type type, ConstructorInfo info)
        {
            if (info.IsPublic)
            {
                builder.Append("public");
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                builder.Append("protected");
            }
            else return;

            builder.Append(" ");
            builder.Append(type.Name);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendEventInfo(StringBuilder builder, Type type, EventInfo info)
        {
            int propertyStart = builder.Length;

            AppendParameterType(builder, info.EventHandlerType);
            builder.Append(" ");
            builder.Append(info.Name);

            builder.Append(" {");
            bool gettable = AppendPropertyMethod(builder, type, info.GetAddMethod(), "add");
            bool settable = AppendPropertyMethod(builder, type, info.GetRemoveMethod(), "remove");
            if (gettable || settable)
            {
                builder.Append(" }");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static void AppendFieldInfo(StringBuilder builder, Type type, FieldInfo info)
        {
            if (type.IsEnum && info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("public");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (type.IsEnum)
                {
                    builder.Append("");
                }
                else
                {
                    builder.Append("protected");
                }
            }
            else return;

            if (!type.IsEnum)
            {
                if (info.IsStatic)
                {
                    builder.Append(" static");
                }
                else if (info.IsInitOnly)
                {
                    builder.Append(" const");
                }
                if (info.IsInitOnly)
                {
                    builder.Append(" readonly");
                }
            }
            if (!type.IsEnum)
            {
                builder.Append(" ");
                AppendParameterType(builder, info.FieldType);
                builder.Append(" ");
            }

            builder.Append(info.Name);
            builder.Append(" = ");

            if (info.IsLiteral || info.IsStatic)
            {
                object fieldValue = null;
                try
                {
                    fieldValue = info.GetValue(null);
                }
                catch (Exception)
                {
                }

                if (null != fieldValue)
                {
                    if (fieldValue is string s)
                    {
                        builder.Append('\"');
                        builder.Append(s);
                        builder.Append('\"');
                    }
                    else if (fieldValue is long l)
                    {
                        builder.Append(l.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is byte b)
                    {
                        builder.Append(b.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is bool b)
                    {
                        builder.Append(b.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is double d)
                    {
                        builder.Append(d.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is short sh)
                    {
                        builder.Append(sh.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is float f)
                    {
                        builder.Append(f.ToString(CultureInfo.InvariantCulture));
                    }
                    else if (fieldValue is Guid guid)
                    {
                        builder.Append('{');
                        builder.Append(guid);
                        builder.Append('}');
                    }
                    else if (fieldValue is Enum)
                    {
                        // remove the enumness, without assuming a particular underlying type.
                        builder.Append(Convert.ChangeType(fieldValue, Enum.GetUnderlyingType(type)));
                    }
                    else
                    {
                        string svalue;
                        try
                        {
                            MethodInfo tostring = fieldValue.GetType().GetMethod("ToString", ToStringFormatParameter);
                            if (null != tostring)
                            {
                                svalue = (string)tostring.Invoke(fieldValue, ToSTringFormatValues);
                            }
                            else
                            {
                                svalue = fieldValue.ToString();
                            }
                        }
                        catch (Exception e)
                        {
                            svalue = e.ToString();
                        }
                        builder.Append(svalue);
                    }
                }
            }
            builder.Append(Environment.NewLine);
        }

        private static readonly Type[] EmptyTypes = new Type[0];
        private static readonly ParameterModifier[] EmptyParameterModifiers = new ParameterModifier[0];

        private static readonly Type[] ToStringFormatParameter = new Type[] { typeof(IFormatProvider) };
        private static readonly object[] ToSTringFormatValues = new object[] { CultureInfo.InvariantCulture };

        private static void AppendMethodInfo(StringBuilder builder, Type type, MethodInfo info)
        {
            string infoName = info.Name;
            if ("IsRowOptimized" == infoName)
            {
                return;
            }
            if (info.IsSpecialName)
            {
                return;
            }
            if (info.IsPublic)
            {
                if (!type.IsInterface)
                {
                    builder.Append("public ");
                }
            }
            else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
            {
                if (!type.IsInterface)
                {
                    builder.Append("protected ");
                }
            }
            else if (infoName.StartsWith("Reset") && ("Reset" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("Reset".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (infoName.StartsWith("ShouldSerialize") && ("ShouldSerialize" != infoName))
            {
                PropertyInfo propInfo = type.GetProperty(infoName.Substring("ShouldSerialize".Length), BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.SetProperty);
                if (null != propInfo && (0 == info.GetParameters().Length))
                {
                    builder.Append("private ");
                }
                else return;
            }
            else if (!(type.IsClass && type.IsSealed) && info.IsVirtual)
            {
                if (-1 == info.Name.IndexOf("."))
                {
                    builder.Append("internal ");
                }
            }
            else return;

            if (!type.IsInterface)
            {
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual && (-1 == info.Name.IndexOf(".")))
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
            }

            AppendParameterType(builder, info.ReturnType);
            builder.Append(" ");
            builder.Append(infoName);
            builder.Append(" ");
            AppendParameterInfo(builder, info.GetParameters(), true, true);
            builder.Append(Environment.NewLine);
        }

        private static void AppendPropertyInfo(StringBuilder builder, Type type, PropertyInfo info)
        {
            int propertyStart = builder.Length;

            builder.Append("");
            AppendParameterType(builder, info.PropertyType);
            builder.Append(" ");
            builder.Append(info.Name);
            builder.Append(" ");

            ParameterInfo[] parameters = info.GetIndexParameters();
            if (0 < parameters.Length)
            {
                AppendParameterInfo(builder, parameters, false, true);
            }

            builder.Append(" { ");
            bool gettable = AppendPropertyMethod(builder, type, info.GetGetMethod(true), "get");
            if (gettable)
            {
                builder.Append(' ');
            }
            bool settable = AppendPropertyMethod(builder, type, info.GetSetMethod(true), "set");
            if (settable)
            {
                builder.Append(' ');
            }
            if (gettable || settable)
            {
                builder.Append("}");
                builder.Append(Environment.NewLine);
            }
            else
            {
                builder.Length = propertyStart;
            }
        }

        private static bool AppendPropertyMethod(StringBuilder builder, Type type, MethodInfo info, string method)
        {
            if (null != info)
            {
                int setStart = builder.Length;

                AppendCustomAttributes(builder, info.GetCustomAttributes(true), false, false, false);

                if (info.IsPublic)
                {
                    builder.Append("public ");
                }
                else if (!(type.IsClass && type.IsSealed) && (info.IsFamily || info.IsFamilyAndAssembly || info.IsFamilyOrAssembly))
                {
                    builder.Append("protected ");
                }
                else
                {
                    builder.Length = setStart;
                    return false;
                }
                if (info.IsAbstract)
                {
                    builder.Append("abstract ");
                }
                else if (info.IsVirtual)
                {
                    builder.Append("virtual ");
                }
                else if (info.IsStatic)
                {
                    builder.Append("static ");
                }
                builder.Append(method);
                builder.Append(';');
                return true;
            }

            return false;
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo[] parameters, bool asMethod, bool withNames)
        {
            if (parameters.Length > 0)
            {
                builder.Append(asMethod ? '(' : '[');
                for (int i = 0; i < parameters.Length; ++i)
                {
                    if (0 < i)
                    {
                        builder.Append(", ");
                    }
                    if (withNames)
                    {
                        AppendParameterInfo(builder, parameters[i]);
                    }
                    else
                    {
                        builder.Append(parameters[i].ParameterType.FullName);
                    }
                }

                builder.Append(asMethod ? ')' : ']');
            }
            else
            {
                builder.Append("()");
            }
        }

        private static void AppendParameterInfo(StringBuilder builder, ParameterInfo info)
        {
            if (info.IsOut)
            {
                builder.Append("out ");
            }
            else if (info.IsOptional)
            {
                builder.Append("params ");
            }
            AppendParameterType(builder, info.ParameterType);
            builder.Append(" ");
            builder.Append(info.Name);
        }

        private static void AppendParameterType(StringBuilder builder, Type parameterType)
        {
            string name = parameterType.FullName ?? parameterType.Name;
            string synonm = (string)Synonms[name];
            if (null != synonm)
            {
                builder.Append(synonm);
            }
            else if (parameterType.IsGenericType && name.Contains("Version="))
            {
                // If there is generic type with generic parameter (for e.g. IEnumerable<T>),
                // then AppendGenericTypeName produces 'System.IEnumerable[[]]' whereas
                // type.Name is IEnumerable'1. Also, to avoid too any changes with the existing baseline,
                // only going into this method if there is a "Version=" present in the name.
                AppendGenericTypeName(builder, parameterType);
            }
            else if (name.StartsWith("Microsoft.AspNet.OData."))
            {
                builder.Append(parameterType.Name);
            }
            else
            {
                builder.Append(name);
            }
        }

        private static void AppendGenericTypeName(StringBuilder builder, Type type)
        {
            if (type.IsGenericType)
            {
                builder.Append(type.GetGenericTypeDefinition().FullName);
                builder.Append("[");
                bool first = true;
                foreach (var argType in type.GetGenericArguments())
                {
                    if (!first)
                    {
                        builder.Append(",");
                    }
                    builder.Append("[");
                    AppendGenericTypeName(builder, argType);
                    builder.Append("]");
                    first = false;
                }

                builder.Append("]");
            }
            else
            {
                builder.Append(type.FullName);
            }
        }

        public sealed class AssemblyCompare : IComparer
        {
            public int Compare(object x, object y)
            {
                string a = ((Assembly)x).GetName().Name;
                string b = ((Assembly)y).GetName().Name;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, StringComparison.Ordinal);
                }
                return cmp;
            }
        }

        public sealed class TypeCompare : IComparer
        {
            public static readonly TypeCompare Default = new TypeCompare();

            public int Compare(object x, object y)
            {
                Type a = x as Type;
                Type b = y as Type;

                string c = a.FullName ?? a.Name;
                string d = b.FullName ?? b.Name;

                int ac = 0, bc = 0;

                for (int i = 0; i < c.Length; ++i)
                {
                    if ('.' == c[i]) ac++;
                }
                for (int i = 0; i < d.Length; ++i)
                {
                    if ('.' == d[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    if (!AlphabeticalGrouping)
                    {
                        string e = (0 < ac) ? c.Substring(0, c.LastIndexOf('.')) : null;
                        string f = (0 < bc) ? d.Substring(0, d.LastIndexOf('.')) : null;

                        if (0 == String.Compare(e, f, false, CultureInfo.InvariantCulture))
                        {
                            if (a.IsEnum)
                            {
                                if (!b.IsEnum)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (a.IsValueType)
                            {
                                if (b.IsEnum)
                                {
                                    cmp = 1;
                                }
                                else if (!b.IsValueType)
                                {
                                    cmp = -1;
                                }
                            }
                            else if (b.IsEnum || b.IsValueType)
                            {
                                cmp = 1;
                            }
                            if (0 == cmp)
                            {
                                if (a.IsInterface != b.IsInterface)
                                {
                                    cmp = (a.IsInterface ? -1 : 1);
                                }
                                else if (a.IsAbstract != b.IsAbstract)
                                {
                                    cmp = (a.IsAbstract ? -1 : 1);
                                }
                                else if (a.IsSealed != b.IsSealed)
                                {
                                    cmp = (a.IsSealed ? 1 : -1);
                                }
                            }
                        }
                    }
                    if (0 == cmp)
                    {
                        cmp = String.Compare(c, d, false, CultureInfo.InvariantCulture);
                    }
                }
                return cmp;
            }
        }

        public sealed class ObjectTypeCompare : IComparer
        {
            public static readonly ObjectTypeCompare Default = new ObjectTypeCompare();
            public int Compare(object x, object y)
            {
                string a = x.GetType().FullName;
                string b = y.GetType().FullName;
                int ac = 0, bc = 0;

                for (int i = 0; i < a.Length; ++i)
                {
                    if ('.' == a[i]) ac++;
                }
                for (int i = 0; i < b.Length; ++i)
                {
                    if ('.' == b[i]) bc++;
                }
                int cmp = ac - bc;
                if (0 == cmp)
                {
                    cmp = String.Compare(a, b, false, CultureInfo.InvariantCulture);
                }
                return cmp;
            }
        }

        public sealed class MemberCompare : IComparer
        {
            private static readonly Hashtable MemberType;
            static MemberCompare()
            {
                Hashtable memberType = new Hashtable();
                memberType.Add(MemberTypes.Field, 1);
                memberType.Add(MemberTypes.Constructor, 2);
                memberType.Add(MemberTypes.Property, 3);
                memberType.Add(MemberTypes.Event, 4);
                memberType.Add(MemberTypes.Method, 5);
                memberType.Add(MemberTypes.NestedType, 6);
                memberType.Add(MemberTypes.TypeInfo, 7);
                memberType.Add(MemberTypes.Custom, 8);
                MemberType = memberType;
            }

            private readonly Hashtable _hash;

            public MemberCompare(Type type)
            {
                _hash = new Hashtable();
                for (int i = 0; null != type; ++i, type = type.BaseType)
                {
                    _hash.Add(type, i);
                }
            }

            public int Compare(object x, object y)
            {
                return Compare((MemberInfo)x, (MemberInfo)y);
            }

            public int Compare(MemberInfo x, MemberInfo y)
            {
                if (x.MemberType == y.MemberType)
                {
                    Type xt = x.DeclaringType;
                    Type yt = y.DeclaringType;
                    if (xt != yt)
                    {
                        return (int)_hash[yt] - (int)_hash[xt];
                    }

                    int cmp = String.Compare(x.Name, y.Name, false, CultureInfo.InvariantCulture);
                    if (0 == cmp)
                    {
                        MethodInfo xMethodInfo = null, yMethodInfo = null;
                        ParameterInfo[] xParameterInfos, yParameterInfos;
                        switch (x.MemberType)
                        {
                            case MemberTypes.Constructor:
                                xParameterInfos = ((ConstructorInfo)x).GetParameters();
                                yParameterInfos = ((ConstructorInfo)y).GetParameters();
                                break;
                            case MemberTypes.Method:
                                xMethodInfo = (MethodInfo)x;
                                yMethodInfo = (MethodInfo)y;
                                xParameterInfos = xMethodInfo.GetParameters();
                                yParameterInfos = yMethodInfo.GetParameters();
                                break;
                            case MemberTypes.Property:
                                xParameterInfos = ((PropertyInfo)x).GetIndexParameters();
                                yParameterInfos = ((PropertyInfo)y).GetIndexParameters();
                                break;
                            default:
                                xParameterInfos = yParameterInfos = new ParameterInfo[0];
                                break;
                        }
                        cmp = xParameterInfos.Length - yParameterInfos.Length;
                        if (0 == cmp)
                        {
                            int count = xParameterInfos.Length;
                            for (int i = 0; i < count; ++i)
                            {
                                cmp = String.Compare(xParameterInfos[i].ParameterType.FullName, yParameterInfos[i].ParameterType.FullName, false, CultureInfo.InvariantCulture);
                                if (cmp == 0)
                                {
                                    // For generic parameters, FullName is null. Hence comparing the names
                                    cmp = String.Compare(xParameterInfos[i].ParameterType.Name, yParameterInfos[i].ParameterType.Name, false, CultureInfo.InvariantCulture);
                                }
                                if (0 != cmp)
                                {
                                    break;
                                }
                            }

                            if (0 == cmp && xMethodInfo != null)
                            {
                                // Two methods with same name, same parameters. Sort by the # of generic type parameters.
                                cmp = xMethodInfo.GetGenericArguments().Count() - yMethodInfo.GetGenericArguments().Count();
                            }
                        }
                    }

                    return cmp;
                }
                return ((int)MemberType[x.MemberType] - (int)MemberType[y.MemberType]);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\PublicApi\PublicApiHelper.cs(603,49): error CS0136: A local or parameter named 'b' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 16 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\ODataStreamPropertyTest.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using System.Web.Http;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Extensions;
using Microsoft.AspNet.OData.Test.Abstraction;
using Microsoft.OData.Edm;
using Newtonsoft.Json.Linq;
using Xunit;
#endif

namespace Microsoft.AspNet.OData.Test
{
    public class ODataStreamPropertyTest
    {
        [Fact]
        public async Task GetMetadata_WithStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/$metadata";

            var controllers = new[] { typeof(MetadataController) };
            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpResponseMessage response = await client.GetAsync(RequestUri);

            // Assert
            var payload = await response.Content.ReadAsStringAsync();
            Assert.Contains("<Property Name=\"Photo\" Type=\"Edm.Stream\" />", payload);
        }

        [Fact]
        public async Task Get_EntityWithStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/StreamCustomers(1)";

            var controllers = new[] { typeof(StreamCustomersController) };

            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, RequestUri);
            request.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json;odata.metadata=full"));
            HttpResponseMessage response = await client.SendAsync(request);

            // Assert
            Assert.True(response.IsSuccessStatusCode);
            JObject result = JObject.Parse(await response.Content.ReadAsStringAsync());

            Assert.Equal("http://localhost/odata/$metadata#StreamCustomers/$entity", result["@odata.context"]);
            Assert.Equal("#Microsoft.AspNet.OData.Test.StreamCustomer", result["@odata.type"]);
            Assert.Equal("\u0002\u0003\u0004\u0005", result["PhotoText"]);
            Assert.Equal("http://localhost/odata/StreamCustomers(1)/Photo", result["Photo@odata.mediaEditLink"]);
            Assert.Equal("http://localhost/odata/StreamCustomers(1)/Photo", result["Photo@odata.mediaReadLink"]);
        }

        [Fact]
        public async Task Get_SingleStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/StreamCustomers(2)/Photo";

            var controllers = new[] { typeof(StreamCustomersController) };

            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, RequestUri);
            HttpResponseMessage response = await client.SendAsync(request);

            // Assert
            Assert.True(response.IsSuccessStatusCode);

            Assert.Equal("application/octet-stream", response.Content.Headers.ContentType.MediaType);
            var stream = await response.Content.ReadAsStreamAsync();

            StreamReader reader = new StreamReader(stream);
            string text = reader.ReadToEnd();
            Assert.Equal("\u0003\u0004\u0005\u0006", text);

            byte[] byteArray = stream.ReadAllBytes();
            Assert.Equal(new byte[] { 3, 4, 5, 6 }, byteArray);
        }

        private static IEdmModel GetEdmModel()
        {
            ODataModelBuilder builder = ODataConventionModelBuilderFactory.Create();
            builder.EntitySet<StreamCustomer>("StreamCustomers");
            return builder.GetEdmModel();
        }
    }

    public static class StreamExtensions
    {
        public static byte[] ReadAllBytes(this Stream instream)
        {
            if (instream is MemoryStream)
                return ((MemoryStream)instream).ToArray();

            using (var memoryStream = new MemoryStream())
            {
                instream.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }
        }
    }

    // Controller
    public class StreamCustomersController : TestODataController
    {
        [EnableQuery]
        public IQueryable<StreamCustomer> Get()
        {
            return CreateCustomers().AsQueryable();
        }

        public ITestActionResult Get(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer);
        }

        [HttpGet]
        public ITestActionResult GetName(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer.Name);
        }

        [HttpGet]
        public ITestActionResult GetPhoto(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer.Photo);
        }
        private static IList<StreamCustomer> CreateCustomers()
        {
            byte[] byteArray = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            IList<StreamCustomer> customers = Enumerable.Range(0, 5).Select(i =>
                new StreamCustomer
                {
                    Id = i,
                    Name = "FirstName " + i,
                    Photo = new MemoryStream(byteArray, i, 4),
                }).ToList();

            foreach (var c in customers)
            {
                c.PhotoText = new StreamReader(c.Photo).ReadToEnd();
                c.Photo.Seek(0, SeekOrigin.Begin);
            }

            return customers;
        }
    }

    public class StreamCustomer
    {
        public int Id { get; set; }

        public string Name { get; set; }

        // this property saves the string of the Photo
        public string PhotoText { get; set; }

        public Stream Photo { get; set; }
    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using System.Web.Http;
using Microsoft.AspNet.OData.Builder;
using Microsoft.AspNet.OData.Extensions;
using Microsoft.AspNet.OData.Test.Abstraction;
using Microsoft.OData.Edm;
using Newtonsoft.Json.Linq;
using Xunit;
#endif

namespace Microsoft.AspNet.OData.Test
{
    public class ODataStreamPropertyTest
    {
        [Fact]
        public async Task GetMetadata_WithStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/$metadata";

            var controllers = new[] { typeof(MetadataController) };
            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpResponseMessage response = await client.GetAsync(RequestUri);

            // Assert
            var payload = await response.Content.ReadAsStringAsync();
            Assert.Contains("<Property Name=\"Photo\" Type=\"Edm.Stream\" />", payload);
        }

        [Fact]
        public async Task Get_EntityWithStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/StreamCustomers(1)";

            var controllers = new[] { typeof(StreamCustomersController) };

            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, RequestUri);
            request.Headers.Accept.Add(MediaTypeWithQualityHeaderValue.Parse("application/json;odata.metadata=full"));
            HttpResponseMessage response = await client.SendAsync(request);

            // Assert
            Assert.True(response.IsSuccessStatusCode);
            JObject result = JObject.Parse(await response.Content.ReadAsStringAsync());

            Assert.Equal("http://localhost/odata/$metadata#StreamCustomers/$entity", result["@odata.context"]);
            Assert.Equal("#Microsoft.AspNet.OData.Test.StreamCustomer", result["@odata.type"]);
            Assert.Equal("\u0002\u0003\u0004\u0005", result["PhotoText"]);
            Assert.Equal("http://localhost/odata/StreamCustomers(1)/Photo", result["Photo@odata.mediaEditLink"]);
            Assert.Equal("http://localhost/odata/StreamCustomers(1)/Photo", result["Photo@odata.mediaReadLink"]);
        }

        [Fact]
        public async Task Get_SingleStreamProperty()
        {
            // Arrange
            const string RequestUri = "http://localhost/odata/StreamCustomers(2)/Photo";

            var controllers = new[] { typeof(StreamCustomersController) };

            var server = TestServerFactory.Create(controllers, (config) =>
            {
                config.MapODataServiceRoute("odata", "odata", GetEdmModel());
            });
            var client = TestServerFactory.CreateClient(server);

            // Act
            HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, RequestUri);
            HttpResponseMessage response = await client.SendAsync(request);

            // Assert
            Assert.True(response.IsSuccessStatusCode);

            Assert.Equal("application/octet-stream", response.Content.Headers.ContentType.MediaType);
            var stream = await response.Content.ReadAsStreamAsync();

            StreamReader reader = new StreamReader(stream);
            string text = reader.ReadToEnd();
            Assert.Equal("\u0003\u0004\u0005\u0006", text);

            byte[] byteArray = stream.ReadAllBytes();
            Assert.Equal(new byte[] { 3, 4, 5, 6 }, byteArray);
        }

        private static IEdmModel GetEdmModel()
        {
            ODataModelBuilder builder = ODataConventionModelBuilderFactory.Create();
            builder.EntitySet<StreamCustomer>("StreamCustomers");
            return builder.GetEdmModel();
        }
    }

    public static class StreamExtensions
    {
        public static byte[] ReadAllBytes(this Stream instream)
        {
            if (instream is MemoryStream memoryStream)
                return memoryStream.ToArray();

            using (var memoryStream = new MemoryStream())
            {
                instream.CopyTo(memoryStream);
                return memoryStream.ToArray();
            }
        }
    }

    // Controller
    public class StreamCustomersController : TestODataController
    {
        [EnableQuery]
        public IQueryable<StreamCustomer> Get()
        {
            return CreateCustomers().AsQueryable();
        }

        public ITestActionResult Get(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer);
        }

        [HttpGet]
        public ITestActionResult GetName(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer.Name);
        }

        [HttpGet]
        public ITestActionResult GetPhoto(int key)
        {
            IList<StreamCustomer> customers = CreateCustomers();
            StreamCustomer customer = customers.FirstOrDefault(c => c.Id == key);
            if (customer == null)
            {
                return NotFound();
            }

            return Ok(customer.Photo);
        }
        private static IList<StreamCustomer> CreateCustomers()
        {
            byte[] byteArray = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            IList<StreamCustomer> customers = Enumerable.Range(0, 5).Select(i =>
                new StreamCustomer
                {
                    Id = i,
                    Name = "FirstName " + i,
                    Photo = new MemoryStream(byteArray, i, 4),
                }).ToList();

            foreach (var c in customers)
            {
                c.PhotoText = new StreamReader(c.Photo).ReadToEnd();
                c.Photo.Seek(0, SeekOrigin.Begin);
            }

            return customers;
        }
    }

    public class StreamCustomer
    {
        public int Id { get; set; }

        public string Name { get; set; }

        // this property saves the string of the Photo
        public string PhotoText { get; set; }

        public Stream Photo { get; set; }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\UnitTest\Microsoft.AspNet.OData.Test.Shared\ODataStreamPropertyTest.cs(136,24): error CS0136: A local or parameter named 'memoryStream' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


