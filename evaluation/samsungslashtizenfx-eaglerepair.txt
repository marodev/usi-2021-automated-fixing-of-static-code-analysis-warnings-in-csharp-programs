Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: ElmSharp
    #1 Path: /home/vsts/work/1/s/src/ElmSharp/ElmSharp/Color.cs, Line: 169, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #2 Path: /home/vsts/work/1/s/src/ElmSharp/ElmSharp/Color.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: /home/vsts/work/1/s/src/ElmSharp/ElmSharp/Color.cs, Line: 236, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: /home/vsts/work/1/s/src/ElmSharp/ElmSharp/Color.cs, Line: 239, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.Common
    #5 Path: /home/vsts/work/1/s/src/Tizen.Applications.Common/Tizen.Applications.CoreBackend/EventType.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: /home/vsts/work/1/s/src/Tizen.Applications.Common/Tizen.Applications/Application.cs, Line: 148, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #7 Path: /home/vsts/work/1/s/src/Tizen.Applications.Common/Tizen.Applications/ApplicationManager.cs, Line: 670, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #8 Path: /home/vsts/work/1/s/src/Tizen.Applications.Common/Tizen.Applications/ApplicationManager.cs, Line: 746, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #9 Path: /home/vsts/work/1/s/src/Tizen.Applications.Common/Tizen.Applications/ApplicationManager.cs, Line: 797, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.ComponentBased.ComponentManager
    #10 Path: /home/vsts/work/1/s/src/Tizen.Applications.ComponentBased.ComponentManager/Tizen.Applications/ComponentManager.cs, Line: 173, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.ComponentBased.Port
    #11 Path: /home/vsts/work/1/s/src/Tizen.Applications.ComponentBased.Port/Tizen.Applications.ComponentBased.Port/ComponentPort.cs, Line: 367, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #12 Path: /home/vsts/work/1/s/src/Tizen.Applications.ComponentBased.Port/Tizen.Applications.ComponentBased.Port/ComponentPort.cs, Line: 371, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: /home/vsts/work/1/s/src/Tizen.Applications.ComponentBased.Port/Tizen.Applications.ComponentBased.Port/ComponentPort.cs, Line: 381, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: /home/vsts/work/1/s/src/Tizen.Applications.ComponentBased.Port/Tizen.Applications.ComponentBased.Port/Parcel.cs, Line: 112, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.DataControl
    #15 Path: /home/vsts/work/1/s/src/Tizen.Applications.DataControl/Tizen.Applications.DataControl/MatrixCursor.cs, Line: 625, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.Applications.NotificationEventListener
    #16 Path: /home/vsts/work/1/s/src/Tizen.Applications.NotificationEventListener/Tizen.Applications.NotificationEventListener/NotificationButtonActionArgsBinder.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: /home/vsts/work/1/s/src/Tizen.Applications.NotificationEventListener/Tizen.Applications.NotificationEventListener/NotificationReplyActionArgsBinder.cs, Line: 98, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Tizen.Applications.PackageManager
    #18 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 193, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #20 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 205, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #21 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 388, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #22 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 396, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #23 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 424, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 456, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/Package.cs, Line: 473, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageArchive.cs, Line: 167, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageArchive.cs, Line: 175, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageArchive.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageCertificate.cs, Line: 73, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1006, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1016, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #32 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1033, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1043, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1251, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1275, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1278, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1298, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #39 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 1365, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 210, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 265, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 305, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #44 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 325, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #45 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 350, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 381, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 385, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #48 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 392, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 409, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 416, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #51 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 664, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #52 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 675, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 686, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #54 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 715, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #55 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 741, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 765, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 784, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #58 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 876, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #59 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 885, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #60 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 902, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #61 Path: /home/vsts/work/1/s/src/Tizen.Applications.PackageManager/Tizen.Applications/PackageManager.cs, Line: 912, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.Preference
    #62 Path: /home/vsts/work/1/s/src/Tizen.Applications.Preference/Tizen.Applications/Preference.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #63 Path: /home/vsts/work/1/s/src/Tizen.Applications.Preference/Tizen.Applications/Preference.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #64 Path: /home/vsts/work/1/s/src/Tizen.Applications.Preference/Tizen.Applications/Preference.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #65 Path: /home/vsts/work/1/s/src/Tizen.Applications.Preference/Tizen.Applications/Preference.cs, Line: 187, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Tizen.Applications.ThemeManager
    #66 Path: /home/vsts/work/1/s/src/Tizen.Applications.ThemeManager/Interop/Interop.ThemeManager.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Applications.WatchfaceComplication
    #67 Path: /home/vsts/work/1/s/src/Tizen.Applications.WatchfaceComplication/Tizen.Applications/Complication.cs, Line: 162, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Tizen.Content.MediaContent
    #68 Path: /home/vsts/work/1/s/src/Tizen.Content.MediaContent/Tizen.Content.MediaContent/MediaInfoCommand.cs, Line: 586, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #69 Path: /home/vsts/work/1/s/src/Tizen.Content.MediaContent/Tizen.Content.MediaContent/PlaylistCommand.cs, Line: 662, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #70 Path: /home/vsts/work/1/s/src/Tizen.Content.MediaContent/Tizen.Content.MediaContent/PlaylistCommand.cs, Line: 765, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #71 Path: /home/vsts/work/1/s/src/Tizen.Content.MediaContent/Tizen.Content.MediaContent/PlaylistCommand.cs, Line: 859, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #72 Path: /home/vsts/work/1/s/src/Tizen.Content.MediaContent/Tizen.Content.MediaContent/TagCommand.cs, Line: 356, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Tizen.MachineLearning.Inference
    #73 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 695, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #74 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 714, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #75 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 733, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #76 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 752, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 771, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 790, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #79 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 809, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 832, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 839, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #82 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 846, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #83 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 853, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #84 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 860, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #85 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 867, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #86 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 874, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #87 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 897, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #88 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 914, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #89 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 931, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #90 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 948, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #91 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 965, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #92 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 982, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: /home/vsts/work/1/s/src/Tizen.MachineLearning.Inference/Tizen.MachineLearning.Inference/Pipeline.cs, Line: 999, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Maps
    #94 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #95 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 335, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #96 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 358, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #97 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 381, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #98 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 403, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #99 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 425, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #100 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 447, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #101 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 469, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 491, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #103 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 520, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/MapView.cs, Line: 543, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/Polygon.cs, Line: 91, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #106 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/Polyline.cs, Line: 45, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #107 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/Polyline.cs, Line: 92, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #108 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 105, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 166, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #112 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #114 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 217, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #115 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 234, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #116 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #117 Path: /home/vsts/work/1/s/src/Tizen.Maps/Tizen.Maps/SearchPreference.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Multimedia.Camera
    #118 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Camera/Camera/Camera.cs, Line: 994, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.Multimedia.MediaPlayer
    #119 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.MediaPlayer/Player/Player.cs, Line: 559, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #120 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.MediaPlayer/Player/Player.cs, Line: 564, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.Multimedia.Radio
    #121 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Radio/Radio/Radio.cs, Line: 413, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.Multimedia.Recorder
    #122 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Recorder/Recorder/Recorder.cs, Line: 91, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.Multimedia.Util
    #123 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Util/ImageUtil/ImageDecoder.cs, Line: 265, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #124 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Util/ImageUtil/ImageEncoder.cs, Line: 229, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #125 Path: /home/vsts/work/1/s/src/Tizen.Multimedia.Util/ImageUtil/ImageEncoder.cs, Line: 456, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Tizen.Multimedia
    #126 Path: /home/vsts/work/1/s/src/Tizen.Multimedia/AudioManager/AudioDucking.cs, Line: 161, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #127 Path: /home/vsts/work/1/s/src/Tizen.Multimedia/AudioManager/AudioStreamPolicy.cs, Line: 448, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.NUI.Components
    #128 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/FlexibleView/FlexibleView.cs, Line: 684, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #129 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/FlexibleView/FlexibleView.Helper.cs, Line: 224, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/FlexibleView/FlexibleViewLayoutManager.cs, Line: 246, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #131 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/FlexibleView/FlexibleViewLayoutManager.cs, Line: 280, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #132 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/FlexibleView/FlexibleViewRecycler.cs, Line: 133, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #133 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Navigation/AppBar.cs, Line: 377, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Navigation/AppBar.cs, Line: 380, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #135 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/Item/DefaultGridItem.cs, Line: 263, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #136 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/Item/DefaultLinearItem.cs, Line: 290, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #137 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/Item/DefaultTitleItem.cs, Line: 216, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #138 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 120, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #139 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 134, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #140 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 149, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #141 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 164, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #142 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 179, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #143 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 194, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #144 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs, Line: 208, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #145 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/SelectGroup.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1498, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #147 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1502, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #148 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1506, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #149 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1510, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #150 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1517, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #151 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1521, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #152 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1525, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #153 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1529, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #154 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1536, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #155 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1540, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #156 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1544, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #157 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.cs, Line: 1548, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #158 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.Internal.cs, Line: 111, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #159 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.Internal.cs, Line: 130, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #160 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.Internal.cs, Line: 159, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #161 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.Internal.cs, Line: 244, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #162 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Slider.Internal.cs, Line: 288, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #163 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/Tab.cs, Line: 634, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #164 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/TabView.cs, Line: 115, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #165 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/TabView.cs, Line: 120, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #166 Path: /home/vsts/work/1/s/src/Tizen.NUI.Components/Utils/Utility.cs, Line: 30, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.NUI
    #167 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Application/NUIComponentCoreBackend.cs, Line: 106, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #168 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Application/NUIComponentCoreBackend.cs, Line: 95, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #169 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Application/NUICoreBackend.cs, Line: 105, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #170 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Application/NUICoreBackend.cs, Line: 109, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #171 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Application/NUICoreBackend.cs, Line: 120, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #172 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #173 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #174 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #175 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 117, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #177 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/BackKeyManager.cs, Line: 88, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Common/DisposeQueue.cs, Line: 66, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #179 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/FrameBroker/DefaultFrameBroker.cs, Line: 162, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #180 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Layouting/LayoutController.cs, Line: 196, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #181 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Layouting/LayoutController.cs, Line: 339, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #182 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Layouting/LayoutController.cs, Line: 540, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #183 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Layouting/LayoutController.cs, Line: 81, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Widget/WidgetApplication.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs, Line: 127, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #186 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs, Line: 255, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #187 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs, Line: 343, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #188 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs, Line: 386, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #189 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ExpandMarkupsVisitor.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ExpandMarkupsVisitor.cs, Line: 167, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #191 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ExpandMarkupsVisitor.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ExpandMarkupsVisitor.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #193 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/MarkupExtensionParser.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/MarkupExtensionParser.cs, Line: 49, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #195 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/MarkupExtensionParser.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #196 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/MarkupExtensionParser.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #197 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/NamescopingVisitor.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/NamescopingVisitor.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #199 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/RegisterXNamesVisitor.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/RegisterXNamesVisitor.cs, Line: 79, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #202 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 326, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #203 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 328, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #204 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 334, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #205 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 344, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #206 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #207 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 470, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #208 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 472, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #209 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 518, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #210 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 520, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #211 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 526, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #212 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 528, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #213 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 535, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #214 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlLoader.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #215 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlNode.cs, Line: 179, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #216 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/BindingExpression.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #217 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/BindingExpression.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #218 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/BindingExpression.cs, Line: 520, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/BindingExpression.cs, Line: 532, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/BindingExpression.cs, Line: 625, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #221 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/EnumerableExtensions.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #222 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/FlowDirection.cs, Line: 46, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #223 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/RectangleTypeConverter.cs, Line: 40, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #224 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/ResourcesExtensions.cs, Line: 31, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #225 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/ResourcesExtensions.cs, Line: 48, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #226 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/ResourcesExtensions.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #227 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/XamlBinding/ResourcesExtensions.cs, Line: 75, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #228 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Animation/Animation.cs, Line: 1108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #229 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Animation/Animation.cs, Line: 1113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #230 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Animation/TransitionOptions.cs, Line: 231, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #231 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Animation/TransitionOptions.cs, Line: 236, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #232 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Application/NUIFrameComponent.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #233 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/BaseComponents/LottieAnimationView.cs, Line: 847, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/BaseComponents/ViewAccessibilityEvent.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #235 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/CustomView/CustomViewRegistry.cs, Line: 373, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #236 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/CustomView/CustomViewRegistry.cs, Line: 402, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #237 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Layouting/LayoutGroup.cs, Line: 161, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #238 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Layouting/LayoutGroup.cs, Line: 165, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #239 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Layouting/LayoutItem.cs, Line: 348, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Layouting/LayoutItem.cs, Line: 579, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #241 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Layouting/LayoutLength.cs, Line: 111, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #242 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Window/GLWindowEvent.cs, Line: 393, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #243 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Window/Window.cs, Line: 1402, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #244 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Window/Window.cs, Line: 1411, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #245 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Window/WindowEvent.cs, Line: 1028, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #246 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/MarkupExtensions/DynamicResourceExtension.cs, Line: 46, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #247 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/MarkupExtensions/ReferenceExtension.cs, Line: 45, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #248 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/StaticResourceExtension.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #249 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/XamlParseException.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #250 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/XamlServiceProvider.cs, Line: 280, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/XamlServiceProvider.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #252 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/Xaml/XamlServiceProvider.cs, Line: 38, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #253 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 258, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #254 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 310, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #255 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 385, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #256 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 697, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #257 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 699, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 715, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #259 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableObject.cs, Line: 810, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #260 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableProperty.cs, Line: 517, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindableProperty.cs, Line: 566, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindablePropertyConverter.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindablePropertyConverter.cs, Line: 86, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Element.cs, Line: 501, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Internals/NameScope.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #266 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Setter.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Setter.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #268 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Setter.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Transition.cs, Line: 197, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #270 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Transition.cs, Line: 231, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #271 Path: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/TypedBinding.cs, Line: 222, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Tizen.Network.Bluetooth
    #272 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 113, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #273 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #274 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 215, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #275 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #276 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 369, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #277 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 374, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #278 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 402, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #279 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 411, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #280 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 522, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #281 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #282 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 538, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #283 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 578, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #284 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 794, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #285 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #286 Path: /home/vsts/work/1/s/src/Tizen.Network.Bluetooth/Tizen.Network.Bluetooth/BluetoothGattImpl.cs, Line: 802, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Network.IoTConnectivity
    #287 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/Attributes.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #288 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/Attributes.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #289 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/Attributes.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #290 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/Attributes.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #291 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/Attributes.cs, Line: 216, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #292 Path: /home/vsts/work/1/s/src/Tizen.Network.IoTConnectivity/Tizen.Network.IoTConnectivity/ResourceOptions.cs, Line: 471, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: Tizen.Security.SecureRepository
    #293 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Interop/Interop.CkmcErrors.cs, Line: 41, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Interop/Interop.CkmcErrors.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #295 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Tizen.Security.SecureRepository/Crypto/AesCtrCipherParameters.cs, Line: 52, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #296 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Tizen.Security.SecureRepository/Crypto/AesGcmCipherParameters.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #297 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Tizen.Security.SecureRepository/KeyManager.cs, Line: 162, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #298 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Tizen.Security.SecureRepository/KeyManager.cs, Line: 209, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #299 Path: /home/vsts/work/1/s/src/Tizen.Security.SecureRepository/Tizen.Security.SecureRepository/KeyManager.cs, Line: 289, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.Security.TEEC
    #300 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Interop/Interop.Errors.cs, Line: 31, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #301 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Interop/Interop.Errors.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #302 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Interop/Interop.Errors.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #303 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Tizen.Security.TEEC/Libteec.cs, Line: 620, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #304 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Tizen.Security.TEEC/Libteec.cs, Line: 653, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #305 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Tizen.Security.TEEC/Libteec.cs, Line: 731, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #306 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Tizen.Security.TEEC/Libteec.cs, Line: 797, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #307 Path: /home/vsts/work/1/s/src/Tizen.Security.TEEC/Tizen.Security.TEEC/Libteec.cs, Line: 805, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.System.Feedback
    #308 Path: /home/vsts/work/1/s/src/Tizen.System.Feedback/Feedback/Feedback.cs, Line: 146, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #309 Path: /home/vsts/work/1/s/src/Tizen.System.Feedback/Feedback/Feedback.cs, Line: 165, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #310 Path: /home/vsts/work/1/s/src/Tizen.System.Feedback/Feedback/Feedback.cs, Line: 217, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #311 Path: /home/vsts/work/1/s/src/Tizen.System.Feedback/Feedback/Feedback.cs, Line: 275, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #312 Path: /home/vsts/work/1/s/src/Tizen.System.Feedback/Feedback/Feedback.cs, Line: 321, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.System.Information
    #313 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #314 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 195, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 230, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #316 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 265, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #317 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 40, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #318 Path: /home/vsts/work/1/s/src/Tizen.System.Information/SystemInfo/SystemInfo.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.System.Storage
    #319 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #320 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #321 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 212, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #322 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 309, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #323 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 329, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #324 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 371, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #325 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 49, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 78, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #327 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/Storage.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #328 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/StorageManager.cs, Line: 48, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #329 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/StorageManager.cs, Line: 71, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #330 Path: /home/vsts/work/1/s/src/Tizen.System.Storage/Storage/StorageManager.cs, Line: 89, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Tizen.System.Usb
    #331 Path: /home/vsts/work/1/s/src/Tizen.System.Usb/Usb/UsbManager.cs, Line: 109, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #332 Path: /home/vsts/work/1/s/src/Tizen.System.Usb/Usb/UsbManager.cs, Line: 96, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Tizen.System
    #333 Path: /home/vsts/work/1/s/src/Tizen.System/Device/IR.cs, Line: 87, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #334 Path: /home/vsts/work/1/s/src/Tizen.System/Device/PerformanceControlType.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Tizen
    #335 Path: /home/vsts/work/1/s/src/Tizen/Tizen.Common/Color.cs, Line: 358, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #336 Path: /home/vsts/work/1/s/src/Tizen/Tizen.Common/Color.cs, Line: 372, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R9: 179
R7: 62
R8: 55
R5: 17
R2: 8
R6: 6
R4: 5
R3: 4

--- Summary ---
Fixed ReSharper issues: 328
Fixed SonarQube issues: 32
Total fixed issues: 336

Finished in: 37 s

######################################################################
Nr: 1 - TypeCheckAndCastRewriterR5
Filepath: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Binding;

namespace Tizen.NUI.Components
{
    /// <summary>
    /// [Draft] This class provides a View that can layouting items in list and grid with high performance.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public abstract class RecyclerView : ScrollableBase, ICollectionChangedNotifier
    {
        /// <summary>
        /// Base Constructor
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public RecyclerView() : base()
        {
            Scrolling += OnScrolling;
        }

        /// <summary>
        /// Item's source data.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual IEnumerable ItemsSource { get; set; }

        /// <summary>
        /// DataTemplate for items.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual DataTemplate ItemTemplate { get; set; }

        /// <summary>
        /// Internal encapsulated items data source.
        /// </summary>
        internal IItemSource InternalItemSource { get; set; }

        /// <summary>
        /// RecycleCache of ViewItem.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected List<RecyclerViewItem> RecycleCache { get; } = new List<RecyclerViewItem>();

        /// <summary>
        /// Internal Items Layouter.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected ItemsLayouter InternalItemsLayouter { get; set; }

        /// <summary>
        /// Max size of RecycleCache. Default is 50.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected int CacheMax { get; set; } = 50;

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override void OnRelayout(Vector2 size, RelayoutContainer container)
        {
            //Console.WriteLine("[NUI] On ReLayout [{0} {0}]", size.X, size.Y);
            base.OnRelayout(size, container);
            if (InternalItemsLayouter != null && ItemsSource != null && ItemTemplate != null)
            {
                InternalItemsLayouter.Initialize(this);
                InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y, true);
            }
        }

        /// <summary>
        /// Notify Dataset is Changed.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyDataSetChanged()
        {
            //Need to update view.
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyDataSetChanged();
                if (ScrollingDirection == Direction.Horizontal)
                {
                    ContentContainer.SizeWidth =
                        InternalItemsLayouter.CalculateLayoutOrientationSize();
                }
                else
                {
                    ContentContainer.SizeHeight =
                        InternalItemsLayouter.CalculateLayoutOrientationSize();
                }
            }
        }

        /// <summary>
        /// Notify observable item is changed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Changed item index.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemChanged(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemChanged(source, startIndex);
            }
        }

        /// <summary>
        /// Notify observable item is inserted in dataset.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Inserted item index.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemInserted(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemInserted(source, startIndex);
            }
        }

        /// <summary>
        /// Notify observable item is moved from fromPosition to ToPosition.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="fromPosition">Previous item position.</param>
        /// <param name="toPosition">Moved item position.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemMoved(IItemSource source, int fromPosition, int toPosition)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemMoved(source, fromPosition, toPosition);
            }
        }

        /// <summary>
        /// Notify range of observable items from start to end are changed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="start">Start index of changed items range.</param>
        /// <param name="end">End index of changed items range.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeChanged(IItemSource source, int start, int end)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeChanged(source, start, end);
            }
        }

        /// <summary>
        /// Notify count range of observable count items are inserted in startIndex.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Start index of inserted items range.</param>
        /// <param name="count">The number of inserted items.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeInserted(IItemSource source, int startIndex, int count)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeInserted(source, startIndex, count);
            }
        }

        /// <summary>
        /// Notify the count range of observable items from the startIndex are removed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Start index of removed items range.</param>
        /// <param name="count">The number of removed items</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeRemoved(IItemSource source, int startIndex, int count)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeRemoved(source, startIndex, count);
            }
        }

        /// <summary>
        /// Notify the observable item in startIndex is removed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Index of removed item.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRemoved(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRemoved(source, startIndex);
            }
        }

        /// <summary>
        /// Realize indexed item.
        /// </summary>
        /// <param name="index"> Index position of realizing item </param>
        internal virtual RecyclerViewItem RealizeItem(int index)
        {
            object context = InternalItemSource.GetItem(index);
            // Check DataTemplate is Same!
            if (ItemTemplate is DataTemplateSelector)
            {
                // Need to implements for caching of selector!
            }
            else
            {
                // pop item
                RecyclerViewItem item = PopRecycleCache(ItemTemplate);
                if (item != null)
                {
                    DecorateItem(item, index, context);
                    return item;
                }
            }

            object content = DataTemplateExtensions.CreateContent(ItemTemplate, context, (BindableObject)this) ?? throw new Exception("Template return null object.");
            if (content is RecyclerViewItem)
            {
                RecyclerViewItem item = (RecyclerViewItem)content;
                ContentContainer.Add(item);
                DecorateItem(item, index, context);
                return item;
            }
            else
            {
                throw new Exception("Template content must be type of ViewItem");
            }

        }

        /// <summary>
        /// Unrealize indexed item.
        /// </summary>
        /// <param name="item"> Target item for unrealizing </param>
        /// <param name="recycle"> Allow recycle. default is true </param>
        internal virtual void UnrealizeItem(RecyclerViewItem item, bool recycle = true)
        {
            item.Index = -1;
            item.ParentItemsView = null;
            // Remove BindingContext null set for performance improving.
            //item.BindingContext = null; 
            item.IsPressed = false;
            item.IsSelected = false;
            item.IsEnabled = true;
            // Remove Update Style on default for performance improving.
            //item.UpdateState();
            item.Relayout -= OnItemRelayout;

            if (!recycle || !PushRecycleCache(item))
            {
                //ContentContainer.Remove(item);
                Utility.Dispose(item);
            }
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// Override this function when developer wants to change destination of flicking.(e.g. always snap to center of item)
        /// </summary>
        /// <param name="position">Scroll position which is calculated by ScrollableBase.</param>
        /// <returns>Adjusted scroll destination</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override float AdjustTargetPositionOfScrollAnimation(float position)
        {
            // Destination is depending on implementation of layout manager.
            // Get destination from layout manager.
            return InternalItemsLayouter.CalculateCandidateScrollPosition(position);
        }

        /// <summary>
        /// Push the item into the recycle cache. this item will be reused in view update.
        /// </summary>
        /// <param name="item"> Target item to push into recycle cache. </param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual bool PushRecycleCache(RecyclerViewItem item)
        {
            if (item == null) throw new ArgumentNullException(nameof(item));
            if (RecycleCache.Count >= CacheMax) return false;
            if (item.Template == null) return false;
            item.Hide();
            item.Index = -1;
            RecycleCache.Add(item);
            return true;
        }

        /// <summary>
        /// Pop the item from the recycle cache.
        /// </summary>
        /// <param name="Template"> Template of wanted item. </param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual RecyclerViewItem PopRecycleCache(DataTemplate Template)
        {
            for (int i = 0; i < RecycleCache.Count; i++)
            {
                RecyclerViewItem item = RecycleCache[i];
                if (item.Template == Template)
                {
                    RecycleCache.Remove(item);
                    item.Show();
                    return item;
                }
            }
            return null;
        }

        /// <summary>
        /// On scroll event callback.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void OnScrolling(object source, ScrollEventArgs args)
        {
            if (args == null) throw new ArgumentNullException(nameof(args));
            if (!disposed && InternalItemsLayouter != null && ItemsSource != null && ItemTemplate != null)
            {
                //Console.WriteLine("[NUI] On Scrolling! {0} => {1}", ScrollPosition.Y, args.Position.Y);
                InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? args.Position.X : args.Position.Y);
            }
        }

        /// <summary>
        /// Dispose ItemsView and all children on it.
        /// </summary>
        /// <param name="type">Dispose type.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override void Dispose(DisposeTypes type)
        {
            if (disposed)
            {
                return;
            }

            if (type == DisposeTypes.Explicit)
            {
                disposed = true;
                // call the clear!
                if (RecycleCache != null)
                {
                    foreach (RecyclerViewItem item in RecycleCache)
                    {
                        //ContentContainer.Remove(item);
                        Utility.Dispose(item);
                    }
                    RecycleCache.Clear();
                }
                InternalItemsLayouter.Clear();
                InternalItemsLayouter = null;
                ItemsSource = null;
                ItemTemplate = null;
                if (InternalItemSource != null) InternalItemSource.Dispose();
                //
            }

            base.Dispose(type);
        }

        private void OnItemRelayout(object sender, EventArgs e)
        {
            //FIXME: we need to skip the first relayout and only call size changed when real size change happen.
            //InternalItemsLayouter.NotifyItemSizeChanged((sender as ViewItem));
            //InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
        }

        private void DecorateItem(RecyclerViewItem item, int index, object context)
        {
            item.Index = index;
            item.ParentItemsView = this;
            item.Template = (ItemTemplate as DataTemplateSelector)?.SelectDataTemplate(InternalItemSource.GetItem(index), this) ?? ItemTemplate;
            item.BindingContext = context;
            item.Relayout += OnItemRelayout;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Binding;

namespace Tizen.NUI.Components
{
    /// <summary>
    /// [Draft] This class provides a View that can layouting items in list and grid with high performance.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public abstract class RecyclerView : ScrollableBase, ICollectionChangedNotifier
    {
        /// <summary>
        /// Base Constructor
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public RecyclerView() : base()
        {
            Scrolling += OnScrolling;
        }

        /// <summary>
        /// Item's source data.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual IEnumerable ItemsSource { get; set; }

        /// <summary>
        /// DataTemplate for items.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public virtual DataTemplate ItemTemplate { get; set; }

        /// <summary>
        /// Internal encapsulated items data source.
        /// </summary>
        internal IItemSource InternalItemSource { get; set; }

        /// <summary>
        /// RecycleCache of ViewItem.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected List<RecyclerViewItem> RecycleCache { get; } = new List<RecyclerViewItem>();

        /// <summary>
        /// Internal Items Layouter.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected ItemsLayouter InternalItemsLayouter { get; set; }

        /// <summary>
        /// Max size of RecycleCache. Default is 50.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected int CacheMax { get; set; } = 50;

        /// <inheritdoc/>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override void OnRelayout(Vector2 size, RelayoutContainer container)
        {
            //Console.WriteLine("[NUI] On ReLayout [{0} {0}]", size.X, size.Y);
            base.OnRelayout(size, container);
            if (InternalItemsLayouter != null && ItemsSource != null && ItemTemplate != null)
            {
                InternalItemsLayouter.Initialize(this);
                InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y, true);
            }
        }

        /// <summary>
        /// Notify Dataset is Changed.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyDataSetChanged()
        {
            //Need to update view.
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyDataSetChanged();
                if (ScrollingDirection == Direction.Horizontal)
                {
                    ContentContainer.SizeWidth =
                        InternalItemsLayouter.CalculateLayoutOrientationSize();
                }
                else
                {
                    ContentContainer.SizeHeight =
                        InternalItemsLayouter.CalculateLayoutOrientationSize();
                }
            }
        }

        /// <summary>
        /// Notify observable item is changed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Changed item index.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemChanged(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemChanged(source, startIndex);
            }
        }

        /// <summary>
        /// Notify observable item is inserted in dataset.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Inserted item index.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemInserted(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemInserted(source, startIndex);
            }
        }

        /// <summary>
        /// Notify observable item is moved from fromPosition to ToPosition.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="fromPosition">Previous item position.</param>
        /// <param name="toPosition">Moved item position.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemMoved(IItemSource source, int fromPosition, int toPosition)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemMoved(source, fromPosition, toPosition);
            }
        }

        /// <summary>
        /// Notify range of observable items from start to end are changed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="start">Start index of changed items range.</param>
        /// <param name="end">End index of changed items range.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeChanged(IItemSource source, int start, int end)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeChanged(source, start, end);
            }
        }

        /// <summary>
        /// Notify count range of observable count items are inserted in startIndex.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Start index of inserted items range.</param>
        /// <param name="count">The number of inserted items.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeInserted(IItemSource source, int startIndex, int count)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeInserted(source, startIndex, count);
            }
        }

        /// <summary>
        /// Notify the count range of observable items from the startIndex are removed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Start index of removed items range.</param>
        /// <param name="count">The number of removed items</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRangeRemoved(IItemSource source, int startIndex, int count)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRangeRemoved(source, startIndex, count);
            }
        }

        /// <summary>
        /// Notify the observable item in startIndex is removed.
        /// </summary>
        /// <param name="source">Dataset source.</param>
        /// <param name="startIndex">Index of removed item.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void NotifyItemRemoved(IItemSource source, int startIndex)
        {
            if (InternalItemsLayouter != null)
            {
                InternalItemsLayouter.NotifyItemRemoved(source, startIndex);
            }
        }

        /// <summary>
        /// Realize indexed item.
        /// </summary>
        /// <param name="index"> Index position of realizing item </param>
        internal virtual RecyclerViewItem RealizeItem(int index)
        {
            object context = InternalItemSource.GetItem(index);
            // Check DataTemplate is Same!
            if (ItemTemplate is DataTemplateSelector)
            {
                // Need to implements for caching of selector!
            }
            else
            {
                // pop item
                RecyclerViewItem item = PopRecycleCache(ItemTemplate);
                if (item != null)
                {
                    DecorateItem(item, index, context);
                    return item;
                }
            }

            object content = DataTemplateExtensions.CreateContent(ItemTemplate, context, (BindableObject)this) ?? throw new Exception("Template return null object.");
            if (content is RecyclerViewItem item)
            {
                ContentContainer.Add(item);
                DecorateItem(item, index, context);
                return item;
            }
            else
            {
                throw new Exception("Template content must be type of ViewItem");
            }

        }

        /// <summary>
        /// Unrealize indexed item.
        /// </summary>
        /// <param name="item"> Target item for unrealizing </param>
        /// <param name="recycle"> Allow recycle. default is true </param>
        internal virtual void UnrealizeItem(RecyclerViewItem item, bool recycle = true)
        {
            item.Index = -1;
            item.ParentItemsView = null;
            // Remove BindingContext null set for performance improving.
            //item.BindingContext = null; 
            item.IsPressed = false;
            item.IsSelected = false;
            item.IsEnabled = true;
            // Remove Update Style on default for performance improving.
            //item.UpdateState();
            item.Relayout -= OnItemRelayout;

            if (!recycle || !PushRecycleCache(item))
            {
                //ContentContainer.Remove(item);
                Utility.Dispose(item);
            }
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// Override this function when developer wants to change destination of flicking.(e.g. always snap to center of item)
        /// </summary>
        /// <param name="position">Scroll position which is calculated by ScrollableBase.</param>
        /// <returns>Adjusted scroll destination</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override float AdjustTargetPositionOfScrollAnimation(float position)
        {
            // Destination is depending on implementation of layout manager.
            // Get destination from layout manager.
            return InternalItemsLayouter.CalculateCandidateScrollPosition(position);
        }

        /// <summary>
        /// Push the item into the recycle cache. this item will be reused in view update.
        /// </summary>
        /// <param name="item"> Target item to push into recycle cache. </param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual bool PushRecycleCache(RecyclerViewItem item)
        {
            if (item == null) throw new ArgumentNullException(nameof(item));
            if (RecycleCache.Count >= CacheMax) return false;
            if (item.Template == null) return false;
            item.Hide();
            item.Index = -1;
            RecycleCache.Add(item);
            return true;
        }

        /// <summary>
        /// Pop the item from the recycle cache.
        /// </summary>
        /// <param name="Template"> Template of wanted item. </param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual RecyclerViewItem PopRecycleCache(DataTemplate Template)
        {
            for (int i = 0; i < RecycleCache.Count; i++)
            {
                RecyclerViewItem item = RecycleCache[i];
                if (item.Template == Template)
                {
                    RecycleCache.Remove(item);
                    item.Show();
                    return item;
                }
            }
            return null;
        }

        /// <summary>
        /// On scroll event callback.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void OnScrolling(object source, ScrollEventArgs args)
        {
            if (args == null) throw new ArgumentNullException(nameof(args));
            if (!disposed && InternalItemsLayouter != null && ItemsSource != null && ItemTemplate != null)
            {
                //Console.WriteLine("[NUI] On Scrolling! {0} => {1}", ScrollPosition.Y, args.Position.Y);
                InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? args.Position.X : args.Position.Y);
            }
        }

        /// <summary>
        /// Dispose ItemsView and all children on it.
        /// </summary>
        /// <param name="type">Dispose type.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override void Dispose(DisposeTypes type)
        {
            if (disposed)
            {
                return;
            }

            if (type == DisposeTypes.Explicit)
            {
                disposed = true;
                // call the clear!
                if (RecycleCache != null)
                {
                    foreach (RecyclerViewItem item in RecycleCache)
                    {
                        //ContentContainer.Remove(item);
                        Utility.Dispose(item);
                    }
                    RecycleCache.Clear();
                }
                InternalItemsLayouter.Clear();
                InternalItemsLayouter = null;
                ItemsSource = null;
                ItemTemplate = null;
                if (InternalItemSource != null) InternalItemSource.Dispose();
                //
            }

            base.Dispose(type);
        }

        private void OnItemRelayout(object sender, EventArgs e)
        {
            //FIXME: we need to skip the first relayout and only call size changed when real size change happen.
            //InternalItemsLayouter.NotifyItemSizeChanged((sender as ViewItem));
            //InternalItemsLayouter.RequestLayout(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
        }

        private void DecorateItem(RecyclerViewItem item, int index, object context)
        {
            item.Index = index;
            item.ParentItemsView = this;
            item.Template = (ItemTemplate as DataTemplateSelector)?.SelectDataTemplate(InternalItemSource.GetItem(index), this) ?? ItemTemplate;
            item.BindingContext = context;
            item.Relayout += OnItemRelayout;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs(21,1): hidden CS8019: Unnecessary using directive.,/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs(17,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs(229,34): error CS0136: A local or parameter named 'item' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs(17,1): hidden CS8019: Unnecessary using directive.,/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/RecyclerView/RecyclerView.cs(21,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/ScrollableBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Tizen.NUI;
using Tizen.NUI.BaseComponents;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Tizen.NUI.Accessibility;

namespace Tizen.NUI.Components
{
    /// <summary>
    /// ScrollEventArgs is a class to record scroll event arguments which will sent to user.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    public class ScrollEventArgs : EventArgs
    {
        private Position position;

        /// <summary>
        /// Default constructor.
        /// </summary>
        /// <param name="position">Current scroll position</param>
        /// <since_tizen> 8 </since_tizen>
        public ScrollEventArgs(Position position)
        {
            this.position = position;
        }

        /// <summary>
        /// Current position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position Position
        {
            get
            {
                return position;
            }
        }
    }

    /// <summary>
    /// ScrollOutofBoundEventArgs is to record scroll out-of-bound event arguments which will be sent to user.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class ScrollOutOfBoundEventArgs : EventArgs
    {
        /// <summary>
        /// The direction to be touched.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public enum Direction
        {
            /// <summary>
            /// Upwards.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Up,

            /// <summary>
            /// Downwards.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Down,

            /// <summary>
            /// Left bound.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Left,

            /// <summary>
            /// Right bound.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Right,
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="direction">Current pan direction</param>
        /// <param name="displacement">Current total displacement</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ScrollOutOfBoundEventArgs(Direction direction, float displacement)
        {
            PanDirection = direction;
            Displacement = displacement;
        }

        /// <summary>
        /// Current pan direction of ContentContainer.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Direction PanDirection
        {
            get;
        }

        /// <summary>
        /// Current total displacement of ContentContainer.
        /// if its value is greater than 0, it is at the top/left;
        /// if less than 0, it is at the bottom/right.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float Displacement
        {
            get;
        }
    }

    /// <summary>
    /// This class provides a View that can scroll a single View with a layout. This View can be a nest of Views.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    public class ScrollableBase : Control
    {
        static bool LayoutDebugScrollableBase = false; // Debug flag
        private Direction mScrollingDirection = Direction.Vertical;
        private bool mScrollEnabled = true;
        private int mScrollDuration = 125;
        private int mPageWidth = 0;
        private float mPageFlickThreshold = 0.4f;
        private float mScrollingEventThreshold = 0.001f;

        private class ScrollableBaseCustomLayout : AbsoluteLayout
        {
            protected override void OnMeasure(MeasureSpecification widthMeasureSpec, MeasureSpecification heightMeasureSpec)
            {
                MeasuredSize.StateType childWidthState = MeasuredSize.StateType.MeasuredSizeOK;
                MeasuredSize.StateType childHeightState = MeasuredSize.StateType.MeasuredSizeOK;

                Direction scrollingDirection = Direction.Vertical;
                ScrollableBase scrollableBase = this.Owner as ScrollableBase;
                if (scrollableBase != null)
                {
                    scrollingDirection = scrollableBase.ScrollingDirection;
                }

                float totalWidth = 0.0f;
                float totalHeight = 0.0f;

                // measure child, should be a single scrolling child
                foreach (LayoutItem childLayout in LayoutChildren)
                {
                    if (childLayout != null && childLayout.Owner.Name == "ContentContainer")
                    {
                        // Get size of child
                        // Use an Unspecified MeasureSpecification mode so scrolling child is not restricted to it's parents size in Height (for vertical scrolling)
                        // or Width for horizontal scrolling
                        if (scrollingDirection == Direction.Vertical)
                        {
                            MeasureSpecification unrestrictedMeasureSpec = new MeasureSpecification(heightMeasureSpec.Size, MeasureSpecification.ModeType.Unspecified);
                            MeasureChildWithMargins(childLayout, widthMeasureSpec, new LayoutLength(0), unrestrictedMeasureSpec, new LayoutLength(0)); // Height unrestricted by parent
                        }
                        else
                        {
                            MeasureSpecification unrestrictedMeasureSpec = new MeasureSpecification(widthMeasureSpec.Size, MeasureSpecification.ModeType.Unspecified);
                            MeasureChildWithMargins(childLayout, unrestrictedMeasureSpec, new LayoutLength(0), heightMeasureSpec, new LayoutLength(0)); // Width unrestricted by parent
                        }

                        totalWidth = (childLayout.MeasuredWidth.Size + (childLayout.Padding.Start + childLayout.Padding.End)).AsDecimal();
                        totalHeight = (childLayout.MeasuredHeight.Size + (childLayout.Padding.Top + childLayout.Padding.Bottom)).AsDecimal();

                        if (childLayout.MeasuredWidth.State == MeasuredSize.StateType.MeasuredSizeTooSmall)
                        {
                            childWidthState = MeasuredSize.StateType.MeasuredSizeTooSmall;
                        }
                        if (childLayout.MeasuredHeight.State == MeasuredSize.StateType.MeasuredSizeTooSmall)
                        {
                            childHeightState = MeasuredSize.StateType.MeasuredSizeTooSmall;
                        }
                    }
                }

                MeasuredSize widthSizeAndState = ResolveSizeAndState(new LayoutLength(totalWidth), widthMeasureSpec, MeasuredSize.StateType.MeasuredSizeOK);
                MeasuredSize heightSizeAndState = ResolveSizeAndState(new LayoutLength(totalHeight), heightMeasureSpec, MeasuredSize.StateType.MeasuredSizeOK);
                totalWidth = widthSizeAndState.Size.AsDecimal();
                totalHeight = heightSizeAndState.Size.AsDecimal();

                // Ensure layout respects it's given minimum size
                totalWidth = Math.Max(totalWidth, SuggestedMinimumWidth.AsDecimal());
                totalHeight = Math.Max(totalHeight, SuggestedMinimumHeight.AsDecimal());

                widthSizeAndState.State = childWidthState;
                heightSizeAndState.State = childHeightState;

                SetMeasuredDimensions(ResolveSizeAndState(new LayoutLength(totalWidth), widthMeasureSpec, childWidthState),
                    ResolveSizeAndState(new LayoutLength(totalHeight), heightMeasureSpec, childHeightState));

                // Size of ScrollableBase is changed. Change Page width too.
                if (scrollableBase != null)
                {
                    scrollableBase.mPageWidth = (int)MeasuredWidth.Size.AsRoundedValue();
                    scrollableBase.OnScrollingChildRelayout(null, null);
                }
            }
        } //  ScrollableBaseCustomLayout

        /// <summary>
        /// The direction axis to scroll.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public enum Direction
        {
            /// <summary>
            /// Horizontal axis.
            /// </summary>
            /// <since_tizen> 8 </since_tizen>
            Horizontal,

            /// <summary>
            /// Vertical axis.
            /// </summary>
            /// <since_tizen> 8 </since_tizen>
            Vertical
        }

        /// <summary>
        /// Scrolling direction mode.
        /// Default is Vertical scrolling.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Direction ScrollingDirection
        {
            get
            {
                return mScrollingDirection;
            }
            set
            {
                if (value != mScrollingDirection)
                {
                    mScrollingDirection = value;
                    mPanGestureDetector.ClearAngles();
                    mPanGestureDetector.AddDirection(value == Direction.Horizontal ?
                        PanGestureDetector.DirectionHorizontal : PanGestureDetector.DirectionVertical);

                    ContentContainer.WidthSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.MatchParent : LayoutParamPolicies.WrapContent;
                    ContentContainer.HeightSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.WrapContent : LayoutParamPolicies.MatchParent;
                }
            }
        }

        /// <summary>
        /// Enable or disable scrolling.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool ScrollEnabled
        {
            get
            {
                return mScrollEnabled;
            }
            set
            {
                if (value != mScrollEnabled)
                {
                    mScrollEnabled = value;
                    if (mScrollEnabled)
                    {
                        mPanGestureDetector.Detected += OnPanGestureDetected;
                    }
                    else
                    {
                        mPanGestureDetector.Detected -= OnPanGestureDetected;
                    }
                }
            }
        }

        /// <summary>
        /// Gets scrollable status.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override bool AccessibilityIsScrollable()
        {
            return true;
        }

        /// <summary>
        /// Pages mode, enables moving to the next or return to current page depending on pan displacement.
        /// Default is false.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool SnapToPage { set; get; } = false;

        /// <summary>
        /// Get current page.
        /// Working property with SnapToPage property.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public int CurrentPage { get; private set; } = 0;

        /// <summary>
        /// Duration of scroll animation.
        /// Default value is 125ms.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public int ScrollDuration
        {
            set
            {
                mScrollDuration = value >= 0 ? value : mScrollDuration;
            }
            get
            {
                return mScrollDuration;
            }
        }

        /// <summary>
        /// Scroll Available area.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Vector2 ScrollAvailableArea { set; get; }

        /// <summary>
        /// An event emitted when user starts dragging ScrollableBase, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollDragStarted;

        /// <summary>
        /// An event emitted when user stops dragging ScrollableBase, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollDragEnded;

        /// <summary>
        /// An event emitted when the scrolling slide animation starts, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollAnimationStarted;

        /// <summary>
        /// An event emitted when the scrolling slide animation ends, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollAnimationEnded;

        /// <summary>
        /// An event emitted when scrolling, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> Scrolling;

        /// <summary>
        /// An event emitted when scrolling out of bound, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public event EventHandler<ScrollOutOfBoundEventArgs> ScrollOutOfBound;

        /// <summary>
        /// Scrollbar for ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public ScrollbarBase Scrollbar
        {
            get
            {
                return scrollBar;
            }
            set
            {
                if (scrollBar)
                {
                    base.Remove(scrollBar);
                }
                scrollBar = value;

                if (scrollBar != null)
                {
                    scrollBar.Name = "ScrollBar";
                    base.Add(scrollBar);

                    if (hideScrollbar)
                    {
                        scrollBar.Hide();
                    }
                    else
                    {
                        scrollBar.Show();
                    }

                    SetScrollbar();
                }
            }
        }

        /// <summary>
        /// Always hide Scrollbar.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool HideScrollbar
        {
            get
            {
                return hideScrollbar;
            }
            set
            {
                hideScrollbar = value;

                if (scrollBar)
                {
                    if (value)
                    {
                        scrollBar.Hide();
                    }
                    else
                    {
                        scrollBar.Show();
                    }
                }
            }
        }

        /// <summary>
        /// Container which has content of ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public View ContentContainer { get; private set; }

        /// <summary>
        /// Set the layout on this View. Replaces any existing Layout.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public new LayoutItem Layout
        {
            get
            {
                return ContentContainer.Layout;
            }
            set
            {
                ContentContainer.Layout = value;
            }
        }

        /// <summary>
        /// List of children of Container.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public new List<View> Children
        {
            get
            {
                return ContentContainer.Children;
            }
        }

        /// <summary>
        /// Deceleration rate of scrolling by finger.
        /// Rate should be bigger than 0 and smaller than 1.
        /// Default value is 0.998f;
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public float DecelerationRate
        {
            get
            {
                return decelerationRate;
            }
            set
            {
                decelerationRate = (value < 1 && value > 0) ? value : decelerationRate;
                logValueOfDeceleration = (float)Math.Log(value);
            }
        }

        /// <summary>
        /// Threashold not to go infinit at the end of scrolling animation.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float DecelerationThreshold { get; set; } = 0.1f;

        /// <summary>
        /// Scrolling event will be thrown when this amount of scroll position is changed.
        /// If this threshold becomes smaller, the tracking detail increases but the scrolling range that can be tracked becomes smaller.
        /// If large sized ContentContainer is required, please use larger threshold value.
        /// Default ScrollingEventThreshold value is 0.001f.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float ScrollingEventThreshold
        {
            get
            {
                return mScrollingEventThreshold;
            }
            set
            {
                if (mScrollingEventThreshold != value && value > 0)
                {
                    ContentContainer.RemovePropertyNotification(propertyNotification);
                    propertyNotification = ContentContainer.AddPropertyNotification("position", PropertyCondition.Step(value));
                    propertyNotification.Notified += OnPropertyChanged;
                    mScrollingEventThreshold = value;
                }
            }
        }

        /// <summary>
        /// Page will be changed when velocity of panning is over threshold.
        /// The unit of threshold is pixel per milisec.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public float PageFlickThreshold
        {
            get
            {
                return mPageFlickThreshold;
            }
            set
            {
                mPageFlickThreshold = value >= 0f ? value : mPageFlickThreshold;
            }
        }

        /// <summary>
        /// Padding for the ScrollableBase
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public new Extents Padding
        {
            get
            {
                return ContentContainer.Padding;
            }
            set
            {
                ContentContainer.Padding = value;
            }
        }

        /// <summary>
        /// Alphafunction for scroll animation.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public AlphaFunction ScrollAlphaFunction { get; set; } = new AlphaFunction(AlphaFunction.BuiltinFunctions.Linear);

        private bool hideScrollbar = true;
        private float maxScrollDistance;
        private float childTargetPosition = 0.0f;
        private PanGestureDetector mPanGestureDetector;
        private View mInterruptTouchingChild;
        private ScrollbarBase scrollBar;
        private bool scrolling = false;
        private float ratioOfScreenWidthToCompleteScroll = 0.5f;
        private float totalDisplacementForPan = 0.0f;
        private Size previousContainerSize = new Size();
        private Size previousSize = new Size();
        private PropertyNotification propertyNotification;
        private float noticeAnimationEndBeforePosition = 0.0f;
        private bool readyToNotice = false;

        /// <summary>
        /// Notice before animation is finished.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        // Let's consider more whether this needs to be set as protected.
        public float NoticeAnimationEndBeforePosition
        {
            get => noticeAnimationEndBeforePosition;
            set => noticeAnimationEndBeforePosition = value;
        }

        // Let's consider more whether this needs to be set as protected.
        private float finalTargetPosition;

        private Animation scrollAnimation;
        // Declare user alpha function delegate
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate float UserAlphaFunctionDelegate(float progress);
        private UserAlphaFunctionDelegate customScrollAlphaFunction;
        private float velocityOfLastPan = 0.0f;
        private float panAnimationDuration = 0.0f;
        private float panAnimationDelta = 0.0f;
        private float logValueOfDeceleration = 0.0f;
        private float decelerationRate = 0.0f;

        private View topOverShootingShadowView;
        private View bottomOverShootingShadowView;
        private View leftOverShootingShadowView;
        private View rightOverShootingShadowView;
        private const int overShootingShadowScaleHeightLimit = 64 * 3;
        private const int overShootingShadowAnimationDuration = 300;
        private Animation overShootingShadowAnimation;
        private bool isOverShootingShadowShown = false;
        private float startShowShadowDisplacement;

        /// <summary>
        /// Default Constructor
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public ScrollableBase() : base()
        {
            DecelerationRate = 0.998f;

            base.Layout = new ScrollableBaseCustomLayout();
            mPanGestureDetector = new PanGestureDetector();
            mPanGestureDetector.Attach(this);
            mPanGestureDetector.AddDirection(PanGestureDetector.DirectionVertical);
            if (mPanGestureDetector.GetMaximumTouchesRequired() < 2) mPanGestureDetector.SetMaximumTouchesRequired(2);
            mPanGestureDetector.Detected += OnPanGestureDetected;

            ClippingMode = ClippingModeType.ClipToBoundingBox;

            //Default Scrolling child
            ContentContainer = new View()
            {
                Name = "ContentContainer",
                WidthSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.MatchParent : LayoutParamPolicies.WrapContent,
                HeightSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.WrapContent : LayoutParamPolicies.MatchParent,
            };
            ContentContainer.Relayout += OnScrollingChildRelayout;
            propertyNotification = ContentContainer.AddPropertyNotification("position", PropertyCondition.Step(mScrollingEventThreshold));
            propertyNotification.Notified += OnPropertyChanged;
            base.Add(ContentContainer);

            //Interrupt touching when panning is started
            mInterruptTouchingChild = new View()
            {
                Size = new Size(Window.Instance.WindowSize),
                BackgroundColor = Color.Transparent,
            };
            mInterruptTouchingChild.TouchEvent += OnIterruptTouchingChildTouched;
            Scrollbar = new Scrollbar();

            //Show vertical shadow on the top (or bottom) of the scrollable when panning down (or up).
            topOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_top.png",
                Opacity = 1.0f,
                SizeHeight = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.TopCenter,
                PivotPoint = NUI.PivotPoint.TopCenter,
            };
            bottomOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_bottom.png",
                Opacity = 1.0f,
                SizeHeight = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.BottomCenter,
                PivotPoint = NUI.PivotPoint.BottomCenter,
            };
            //Show horizontal shadow on the left (or right) of the scrollable when panning down (or up).
            leftOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_left.png",
                Opacity = 1.0f,
                SizeWidth = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.CenterLeft,
                PivotPoint = NUI.PivotPoint.CenterLeft,
            };
            rightOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_right.png",
                Opacity = 1.0f,
                SizeWidth = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.CenterRight,
                PivotPoint = NUI.PivotPoint.CenterRight,
            };

            AccessibilityManager.Instance.SetAccessibilityAttribute(this, AccessibilityManager.AccessibilityAttribute.Trait, "ScrollableBase");
        }

        private bool OnIterruptTouchingChildTouched(object source, View.TouchEventArgs args)
        {
            if (args.Touch.GetState(0) == PointStateType.Down)
            {
                if (scrolling && !SnapToPage)
                {
                    StopScroll();
                }
            }
            return true;
        }

        private void OnPropertyChanged(object source, PropertyNotification.NotifyEventArgs args)
        {
            OnScroll();
        }

        /// <summary>
        /// Called after a child has been added to the owning view.
        /// </summary>
        /// <param name="view">The child which has been added.</param>
        /// <since_tizen> 8 </since_tizen>
        public override void Add(View view)
        {
            ContentContainer.Add(view);
        }

        /// <summary>
        /// Called after a child has been removed from the owning view.
        /// </summary>
        /// <param name="view">The child which has been removed.</param>
        /// <since_tizen> 8 </since_tizen>
        public override void Remove(View view)
        {
            if (SnapToPage && CurrentPage == Children.IndexOf(view) && CurrentPage == Children.Count - 1)
            {
                // Target View is current page and also last child.
                // CurrentPage should be changed to previous page.
                CurrentPage = Math.Max(0, CurrentPage - 1);
                ScrollToIndex(CurrentPage);
            }

            ContentContainer.Remove(view);
        }

        private void OnScrollingChildRelayout(object source, EventArgs args)
        {
            // Size is changed. Calculate maxScrollDistance.
            bool isSizeChanged = previousContainerSize.Width != ContentContainer.Size.Width || previousContainerSize.Height != ContentContainer.Size.Height ||
                previousSize.Width != Size.Width || previousSize.Height != Size.Height;

            if (isSizeChanged)
            {
                maxScrollDistance = CalculateMaximumScrollDistance();
                SetScrollbar();
            }

            previousContainerSize = ContentContainer.Size;
            previousSize = Size;
        }

        /// <summary>
        /// The composition of a Scrollbar can vary depending on how you use ScrollableBase.
        /// Set the composition that will go into the ScrollableBase according to your ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void SetScrollbar()
        {
            if (Scrollbar)
            {
                bool isHorizontal = ScrollingDirection == Direction.Horizontal;
                float contentLength = isHorizontal ? ContentContainer.Size.Width : ContentContainer.Size.Height;
                float viewportLength = isHorizontal ? Size.Width : Size.Height;
                float currentPosition = isHorizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y;
                Scrollbar.Initialize(contentLength, viewportLength, currentPosition, isHorizontal);
            }
        }

        /// <summary>
        /// Scrolls to the item at the specified index.
        /// </summary>
        /// <param name="index">Index of item.</param>
        /// <since_tizen> 8 </since_tizen>
        public void ScrollToIndex(int index)
        {
            if (ContentContainer.ChildCount - 1 < index || index < 0)
            {
                return;
            }

            if (SnapToPage)
            {
                CurrentPage = index;
            }

            float targetPosition = Math.Min(ScrollingDirection == Direction.Vertical ? Children[index].Position.Y : Children[index].Position.X, maxScrollDistance);
            AnimateChildTo(ScrollDuration, -targetPosition);
        }

        private void OnScrollDragStarted()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollDragStarted?.Invoke(this, eventArgs);
        }

        private void OnScrollDragEnded()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollDragEnded?.Invoke(this, eventArgs);
        }

        private void OnScrollAnimationStarted()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollAnimationStarted?.Invoke(this, eventArgs);
        }

        private void OnScrollAnimationEnded()
        {
            scrolling = false;
            base.Remove(mInterruptTouchingChild);

            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollAnimationEnded?.Invoke(this, eventArgs);
        }

        private void OnScroll()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            Scrolling?.Invoke(this, eventArgs);

            bool isHorizontal = ScrollingDirection == Direction.Horizontal;
            float contentLength = isHorizontal ? ContentContainer.Size.Width : ContentContainer.Size.Height;
            float currentPosition = isHorizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y;

            scrollBar?.Update(contentLength, Math.Abs(currentPosition));
            CheckPreReachedTargetPosition();
        }

        private void CheckPreReachedTargetPosition()
        {
            // Check whether we reached pre-reached target position
            if (readyToNotice &&
                ContentContainer.CurrentPosition.Y <= finalTargetPosition + NoticeAnimationEndBeforePosition &&
                ContentContainer.CurrentPosition.Y >= finalTargetPosition - NoticeAnimationEndBeforePosition)
            {
                //Notice first
                readyToNotice = false;
                OnPreReachedTargetPosition(finalTargetPosition);
            }
        }

        /// <summary>
        /// This helps developer who wants to know before scroll is reaching target position.
        /// </summary>
        /// <param name="targetPosition">Index of item.</param>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void OnPreReachedTargetPosition(float targetPosition)
        {

        }

        private void StopScroll()
        {
            if (scrollAnimation != null)
            {
                if (scrollAnimation.State == Animation.States.Playing)
                {
                    Debug.WriteLineIf(LayoutDebugScrollableBase, "StopScroll Animation Playing");
                    scrollAnimation.Stop(Animation.EndActions.Cancel);
                    OnScrollAnimationEnded();
                }
                scrollAnimation.Clear();
            }
        }

        private void AnimateChildTo(int duration, float axisPosition)
        {
            Debug.WriteLineIf(LayoutDebugScrollableBase, "AnimationTo Animation Duration:" + duration + " Destination:" + axisPosition);
            finalTargetPosition = axisPosition;

            StopScroll(); // Will replace previous animation so will stop existing one.

            if (scrollAnimation == null)
            {
                scrollAnimation = new Animation();
                scrollAnimation.Finished += ScrollAnimationFinished;
            }

            scrollAnimation.Duration = duration;
            scrollAnimation.DefaultAlphaFunction = new AlphaFunction(AlphaFunction.BuiltinFunctions.EaseOutSquare);
            scrollAnimation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", axisPosition, ScrollAlphaFunction);
            scrolling = true;
            OnScrollAnimationStarted();
            scrollAnimation.Play();
        }

        /// <summary>
        /// Scroll to specific position with or without animation.
        /// </summary>
        /// <param name="position">Destination.</param>
        /// <param name="animate">Scroll with or without animation</param>
        /// <since_tizen> 8 </since_tizen>
        public void ScrollTo(float position, bool animate)
        {
            float currentPositionX = ContentContainer.CurrentPosition.X != 0 ? ContentContainer.CurrentPosition.X : ContentContainer.Position.X;
            float currentPositionY = ContentContainer.CurrentPosition.Y != 0 ? ContentContainer.CurrentPosition.Y : ContentContainer.Position.Y;
            float delta = ScrollingDirection == Direction.Horizontal ? currentPositionX : currentPositionY;
            // The argument position is the new pan position. So the new position of ScrollableBase becomes (-position).
            // To move ScrollableBase's position to (-position), it moves by (-position - currentPosition).
            delta = -position - delta;

            ScrollBy(delta, animate);
        }

        private float BoundScrollPosition(float targetPosition)
        {
            if (ScrollAvailableArea != null)
            {
                float minScrollPosition = ScrollAvailableArea.X;
                float maxScrollPosition = ScrollAvailableArea.Y;

                targetPosition = Math.Min(-minScrollPosition, targetPosition);
                targetPosition = Math.Max(-maxScrollPosition, targetPosition);
            }
            else
            {
                targetPosition = Math.Min(0, targetPosition);
                targetPosition = Math.Max(-maxScrollDistance, targetPosition);
            }

            return targetPosition;
        }

        private void ScrollBy(float displacement, bool animate)
        {
            if (GetChildCount() == 0 || maxScrollDistance < 0)
            {
                return;
            }

            float childCurrentPosition = (ScrollingDirection == Direction.Horizontal) ? ContentContainer.PositionX : ContentContainer.PositionY;

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy childCurrentPosition:" + childCurrentPosition +
                " displacement:" + displacement,
                " maxScrollDistance:" + maxScrollDistance);

            childTargetPosition = childCurrentPosition + displacement; // child current position + gesture displacement

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy currentAxisPosition:" + childCurrentPosition + "childTargetPosition:" + childTargetPosition);

            if (animate)
            {
                // Calculate scroll animaton duration
                float scrollDistance = Math.Abs(displacement);
                readyToNotice = true;

                AnimateChildTo(ScrollDuration, BoundScrollPosition(AdjustTargetPositionOfScrollAnimation(BoundScrollPosition(childTargetPosition))));
            }
            else
            {
                finalTargetPosition = BoundScrollPosition(childTargetPosition);

                // Set position of scrolling child without an animation
                if (ScrollingDirection == Direction.Horizontal)
                {
                    ContentContainer.PositionX = finalTargetPosition;
                }
                else
                {
                    ContentContainer.PositionY = finalTargetPosition;
                }
            }
        }

        /// <summary>
        /// you can override it to clean-up your own resources.
        /// </summary>
        /// <param name="type">DisposeTypes</param>
        /// This will be public opened in tizen_5.5 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override void Dispose(DisposeTypes type)
        {
            if (disposed)
            {
                return;
            }

            if (type == DisposeTypes.Explicit)
            {
                StopOverShootingShadowAnimation();
                StopScroll();

                if (mPanGestureDetector != null)
                {
                    mPanGestureDetector.Detected -= OnPanGestureDetected;
                    mPanGestureDetector.Dispose();
                    mPanGestureDetector = null;
                }

                propertyNotification.Dispose();
            }
            base.Dispose(type);
        }

        private float CalculateMaximumScrollDistance()
        {
            float scrollingChildLength = 0;
            float scrollerLength = 0;
            if (ScrollingDirection == Direction.Horizontal)
            {
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Horizontal");

                scrollingChildLength = ContentContainer.Size.Width;
                scrollerLength = Size.Width;
            }
            else
            {
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Vertical");
                scrollingChildLength = ContentContainer.Size.Height;
                scrollerLength = Size.Height;
            }

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy maxScrollDistance:" + (scrollingChildLength - scrollerLength) +
                " parent length:" + scrollerLength +
                " scrolling child length:" + scrollingChildLength);

            return Math.Max(scrollingChildLength - scrollerLength, 0);
        }

        private void PageSnap(float velocity)
        {
            float destination;

            Debug.WriteLineIf(LayoutDebugScrollableBase, "PageSnap with pan candidate totalDisplacement:" + totalDisplacementForPan +
                " currentPage[" + CurrentPage + "]");

            //Increment current page if total displacement enough to warrant a page change.
            if (Math.Abs(totalDisplacementForPan) > (mPageWidth * ratioOfScreenWidthToCompleteScroll))
            {
                if (totalDisplacementForPan < 0)
                {
                    CurrentPage = Math.Min(Math.Max(Children.Count - 1, 0), ++CurrentPage);
                }
                else
                {
                    CurrentPage = Math.Max(0, --CurrentPage);
                }
            }
            else if (Math.Abs(velocity) > PageFlickThreshold)
            {
                if (velocity < 0)
                {
                    CurrentPage = Math.Min(Math.Max(Children.Count - 1, 0), ++CurrentPage);
                }
                else
                {
                    CurrentPage = Math.Max(0, --CurrentPage);
                }
            }

            // Animate to new page or reposition to current page
            if (ScrollingDirection == Direction.Horizontal)
                destination = -(Children[CurrentPage].Position.X + Children[CurrentPage].CurrentSize.Width / 2 - CurrentSize.Width / 2); // set to middle of current page
            else
                destination = -(Children[CurrentPage].Position.Y + Children[CurrentPage].CurrentSize.Height / 2 - CurrentSize.Height / 2);

            AnimateChildTo(ScrollDuration, destination);
        }

        /// <summary>
        /// Enable/Disable overshooting effect. default is disabled.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool EnableOverShootingEffect { get; set; } = false;

        private void AttachOverShootingShadowView()
        {
            if (!EnableOverShootingEffect)
                return;

            // stop animation if necessary.
            StopOverShootingShadowAnimation();

            if (ScrollingDirection == Direction.Horizontal)
            {
                base.Add(leftOverShootingShadowView);
                base.Add(rightOverShootingShadowView);

                leftOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                leftOverShootingShadowView.Opacity = 1.0f;
                leftOverShootingShadowView.RaiseToTop();

                rightOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                rightOverShootingShadowView.Opacity = 1.0f;
                rightOverShootingShadowView.RaiseToTop();
            }
            else
            {
                base.Add(topOverShootingShadowView);
                base.Add(bottomOverShootingShadowView);

                topOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                topOverShootingShadowView.Opacity = 1.0f;
                topOverShootingShadowView.RaiseToTop();

                bottomOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                bottomOverShootingShadowView.Opacity = 1.0f;
                bottomOverShootingShadowView.RaiseToTop();
            }

            // at the beginning, height or width of overshooting shadow is 0, so it is invisible.
            isOverShootingShadowShown = false;
        }

        private void DragOverShootingShadow(float totalPanDisplacement, float panDisplacement)
        {
            if (!EnableOverShootingEffect)
                return;

            if (totalPanDisplacement > 0) // downwards
            {
                // check if reaching at the top / left.
                if ((int)finalTargetPosition != 0)
                {
                    isOverShootingShadowShown = false;
                    return;
                }

                // save start displacement, and re-calculate displacement.
                if (!isOverShootingShadowShown)
                {
                    startShowShadowDisplacement = totalPanDisplacement;
                }
                isOverShootingShadowShown = true;

                float newDisplacement = (int)totalPanDisplacement < (int)startShowShadowDisplacement ? 0 : totalPanDisplacement - startShowShadowDisplacement;

                if (ScrollingDirection == Direction.Horizontal)
                {
                    // scale limit of height is 60%.
                    float heightScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    leftOverShootingShadowView.SizeHeight = heightScale > 0.6f ? SizeHeight * 0.4f : SizeHeight * (1.0f - heightScale);

                    // scale limit of width is 300%.
                    leftOverShootingShadowView.SizeWidth = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Right : ScrollOutOfBoundEventArgs.Direction.Left;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
                else
                {
                    // scale limit of width is 60%.
                    float widthScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    topOverShootingShadowView.SizeWidth = widthScale > 0.6f ? SizeWidth * 0.4f : SizeWidth * (1.0f - widthScale);

                    // scale limit of height is 300%.
                    topOverShootingShadowView.SizeHeight = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Down : ScrollOutOfBoundEventArgs.Direction.Up;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
            }
            else if (totalPanDisplacement < 0) // upwards
            {
                // check if reaching at the bottom.
                if (-(int)finalTargetPosition != (int)maxScrollDistance)
                {
                    isOverShootingShadowShown = false;
                    return;
                }

                // save start displacement, and re-calculate displacement.
                if (!isOverShootingShadowShown)
                {
                    startShowShadowDisplacement = totalPanDisplacement;
                }
                isOverShootingShadowShown = true;

                float newDisplacement = (int)startShowShadowDisplacement < (int)totalPanDisplacement ? 0 : startShowShadowDisplacement - totalPanDisplacement;

                if (ScrollingDirection == Direction.Horizontal)
                {
                    // scale limit of height is 60%.
                    float heightScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    rightOverShootingShadowView.SizeHeight = heightScale > 0.6f ? SizeHeight * 0.4f : SizeHeight * (1.0f - heightScale);

                    // scale limit of width is 300%.
                    rightOverShootingShadowView.SizeWidth = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Right : ScrollOutOfBoundEventArgs.Direction.Left;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
                else
                {
                    // scale limit of width is 60%.
                    float widthScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    bottomOverShootingShadowView.SizeWidth = widthScale > 0.6f ? SizeWidth * 0.4f : SizeWidth * (1.0f - widthScale);

                    // scale limit of height is 300%.
                    bottomOverShootingShadowView.SizeHeight = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Down : ScrollOutOfBoundEventArgs.Direction.Up;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
            }
            else
            {
                // if total displacement is 0, shadow would become invisible.
                isOverShootingShadowShown = false;
            }
        }

        private void PlayOverShootingShadowAnimation()
        {
            if (!EnableOverShootingEffect)
                return;

            // stop animation if necessary.
            StopOverShootingShadowAnimation();

            if (overShootingShadowAnimation == null)
            {
                overShootingShadowAnimation = new Animation(overShootingShadowAnimationDuration);
                overShootingShadowAnimation.Finished += OnOverShootingShadowAnimationFinished;
            }

            if (ScrollingDirection == Direction.Horizontal)
            {
                View targetView = totalDisplacementForPan < 0 ? rightOverShootingShadowView : leftOverShootingShadowView;
                overShootingShadowAnimation.AnimateTo(targetView, "SizeHeight", SizeHeight);
                overShootingShadowAnimation.AnimateTo(targetView, "SizeWidth", 0.0f);
                overShootingShadowAnimation.AnimateTo(targetView, "Opacity", 0.0f);
            }
            else
            {
                View targetView = totalDisplacementForPan < 0 ? bottomOverShootingShadowView : topOverShootingShadowView;
                overShootingShadowAnimation.AnimateTo(targetView, "SizeWidth", SizeWidth);
                overShootingShadowAnimation.AnimateTo(targetView, "SizeHeight", 0.0f);
                overShootingShadowAnimation.AnimateTo(targetView, "Opacity", 0.0f);
            }
            overShootingShadowAnimation.Play();
        }

        private void StopOverShootingShadowAnimation()
        {
            if (overShootingShadowAnimation == null || overShootingShadowAnimation.State != Animation.States.Playing)
                return;

            overShootingShadowAnimation.Stop(Animation.EndActions.Cancel);
            OnOverShootingShadowAnimationFinished(null, null);
            overShootingShadowAnimation.Clear();
        }

        private void OnOverShootingShadowAnimationFinished(object sender, EventArgs e)
        {
            if (ScrollingDirection == Direction.Horizontal)
            {
                base.Remove(leftOverShootingShadowView);
                base.Remove(rightOverShootingShadowView);

                leftOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                rightOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
            }
            else
            {
                base.Remove(topOverShootingShadowView);
                base.Remove(bottomOverShootingShadowView);

                topOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                bottomOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
            }

            // after animation finished, height/width & opacity of vertical shadow both are 0, so it is invisible.
            isOverShootingShadowShown = false;
        }

        private void OnScrollOutOfBound(ScrollOutOfBoundEventArgs.Direction direction, float displacement)
        {
            ScrollOutOfBoundEventArgs args = new ScrollOutOfBoundEventArgs(direction, displacement);
            ScrollOutOfBound?.Invoke(this, args);
        }

        private void OnPanGestureDetected(object source, PanGestureDetector.DetectedEventArgs e)
        {
            OnPanGesture(e.PanGesture);
        }

        private void OnPanGesture(PanGesture panGesture)
        {
            if (SnapToPage && scrollAnimation != null && scrollAnimation.State == Animation.States.Playing)
            {
                return;
            }

            if (panGesture.State == Gesture.StateType.Started)
            {
                readyToNotice = false;
                base.Add(mInterruptTouchingChild);
                AttachOverShootingShadowView();
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Gesture Start");
                if (scrolling && !SnapToPage)
                {
                    StopScroll();
                }
                totalDisplacementForPan = 0.0f;
                OnScrollDragStarted();
            }
            else if (panGesture.State == Gesture.StateType.Continuing)
            {
                if (ScrollingDirection == Direction.Horizontal)
                {
                    // if vertical shadow is shown, does not scroll.
                    if (!isOverShootingShadowShown)
                    {
                        ScrollBy(panGesture.Displacement.X, false);
                    }
                    totalDisplacementForPan += panGesture.Displacement.X;
                    DragOverShootingShadow(totalDisplacementForPan, panGesture.Displacement.X);
                }
                else
                {
                    // if vertical shadow is shown, does not scroll.
                    if (!isOverShootingShadowShown)
                    {
                        ScrollBy(panGesture.Displacement.Y, false);
                    }
                    totalDisplacementForPan += panGesture.Displacement.Y;
                    DragOverShootingShadow(totalDisplacementForPan, panGesture.Displacement.Y);
                }
                Debug.WriteLineIf(LayoutDebugScrollableBase, "OnPanGestureDetected Continue totalDisplacementForPan:" + totalDisplacementForPan);
            }
            else if (panGesture.State == Gesture.StateType.Finished || panGesture.State == Gesture.StateType.Cancelled)
            {
                PlayOverShootingShadowAnimation();
                OnScrollDragEnded();
                StopScroll(); // Will replace previous animation so will stop existing one.

                if (scrollAnimation == null)
                {
                    scrollAnimation = new Animation();
                    scrollAnimation.Finished += ScrollAnimationFinished;
                }

                float panVelocity = (ScrollingDirection == Direction.Horizontal) ? panGesture.Velocity.X : panGesture.Velocity.Y;

                if (SnapToPage)
                {
                    PageSnap(panVelocity);
                }
                else
                {
                    if (panVelocity == 0)
                    {
                        float currentScrollPosition = (ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
                        scrollAnimation.DefaultAlphaFunction = new AlphaFunction(AlphaFunction.BuiltinFunctions.Linear);
                        scrollAnimation.Duration = 0;
                        scrollAnimation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", currentScrollPosition);
                        scrollAnimation.Play();
                    }
                    else
                    {
                        Decelerating(panVelocity, scrollAnimation);
                    }
                }

                totalDisplacementForPan = 0;
                scrolling = true;
                readyToNotice = true;
                OnScrollAnimationStarted();
            }
        }

        internal void BaseRemove(View view)
        {
            base.Remove(view);
        }

        internal override bool OnAccessibilityPan(PanGesture gestures)
        {
            if (SnapToPage && scrollAnimation != null && scrollAnimation.State == Animation.States.Playing)
            {
                return false;
            }

            OnPanGesture(gestures);
            return true;
        }

        private float CustomScrollAlphaFunction(float progress)
        {
            if (panAnimationDelta == 0)
            {
                return 1.0f;
            }
            else
            {
                // Parameter "progress" is normalized value. We need to multiply target duration to calculate distance.
                // Can get real distance using equation of deceleration (check Decelerating function)
                // After get real distance, normalize it
                float realDuration = progress * panAnimationDuration;
                float realDistance = velocityOfLastPan * ((float)Math.Pow(decelerationRate, realDuration) - 1) / logValueOfDeceleration;
                float result = Math.Min(realDistance / Math.Abs(panAnimationDelta), 1.0f);
                return result;
            }
        }

        /// <summary>
        /// you can override it to custom your decelerating
        /// </summary>
        /// <param name="velocity">Velocity of current pan.</param>
        /// <param name="animation">Scroll animation.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void Decelerating(float velocity, Animation animation)
        {
            // Decelerating using deceleration equation ===========
            //
            // V   : velocity (pixel per milisecond)
            // V0  : initial velocity
            // d   : deceleration rate,
            // t   : time
            // X   : final position after decelerating
            // log : natural logarithm
            //
            // V(t) = V0 * d pow t;
            // X(t) = V0 * (d pow t - 1) / log d;  <-- Integrate the velocity function
            // X(∞) = V0 * d / (1 - d); <-- Result using inifit T can be final position because T is tending to infinity.
            //
            // Because of final T is tending to inifity, we should use threshold value to finish.
            // Final T = log(-threshold * log d / |V0| ) / log d;

            velocityOfLastPan = Math.Abs(velocity);

            float currentScrollPosition = -(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
            panAnimationDelta = (velocityOfLastPan * decelerationRate) / (1 - decelerationRate);
            panAnimationDelta = velocity > 0 ? -panAnimationDelta : panAnimationDelta;

            float destination = -(panAnimationDelta + currentScrollPosition);
            float adjustDestination = AdjustTargetPositionOfScrollAnimation(destination);
            float maxPosition = ScrollAvailableArea != null ? ScrollAvailableArea.Y : maxScrollDistance;
            float minPosition = ScrollAvailableArea != null ? ScrollAvailableArea.X : 0;

            if (destination < -maxPosition || destination > minPosition)
            {
                panAnimationDelta = velocity > 0 ? (currentScrollPosition - minPosition) : (maxPosition - currentScrollPosition);
                destination = velocity > 0 ? minPosition : -maxPosition;

                if (panAnimationDelta == 0)
                {
                    panAnimationDuration = 0.0f;
                }
                else
                {
                    panAnimationDuration = (float)Math.Log((panAnimationDelta * logValueOfDeceleration / velocityOfLastPan + 1), decelerationRate);
                }

                Debug.WriteLineIf(LayoutDebugScrollableBase, "\n" +
                    "OverRange======================= \n" +
                    "[decelerationRate] " + decelerationRate + "\n" +
                    "[logValueOfDeceleration] " + logValueOfDeceleration + "\n" +
                    "[Velocity] " + velocityOfLastPan + "\n" +
                    "[CurrentPosition] " + currentScrollPosition + "\n" +
                    "[CandidateDelta] " + panAnimationDelta + "\n" +
                    "[Destination] " + destination + "\n" +
                    "[Duration] " + panAnimationDuration + "\n" +
                    "================================ \n"
                );
            }
            else
            {
                panAnimationDuration = (float)Math.Log(-DecelerationThreshold * logValueOfDeceleration / velocityOfLastPan) / logValueOfDeceleration;

                if (adjustDestination != destination)
                {
                    destination = adjustDestination;
                    panAnimationDelta = destination + currentScrollPosition;
                    velocityOfLastPan = Math.Abs(panAnimationDelta * logValueOfDeceleration / ((float)Math.Pow(decelerationRate, panAnimationDuration) - 1));
                    panAnimationDuration = (float)Math.Log(-DecelerationThreshold * logValueOfDeceleration / velocityOfLastPan) / logValueOfDeceleration;
                }

                Debug.WriteLineIf(LayoutDebugScrollableBase, "\n" +
                    "================================ \n" +
                    "[decelerationRate] " + decelerationRate + "\n" +
                    "[logValueOfDeceleration] " + logValueOfDeceleration + "\n" +
                    "[Velocity] " + velocityOfLastPan + "\n" +
                    "[CurrentPosition] " + currentScrollPosition + "\n" +
                    "[CandidateDelta] " + panAnimationDelta + "\n" +
                    "[Destination] " + destination + "\n" +
                    "[Duration] " + panAnimationDuration + "\n" +
                    "================================ \n"
                );
            }

            finalTargetPosition = destination;

            customScrollAlphaFunction = new UserAlphaFunctionDelegate(CustomScrollAlphaFunction);
            animation.DefaultAlphaFunction = new AlphaFunction(customScrollAlphaFunction);
            GC.KeepAlive(customScrollAlphaFunction);
            animation.Duration = (int)panAnimationDuration;
            animation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", destination);
            animation.Play();
        }

        private void ScrollAnimationFinished(object sender, EventArgs e)
        {
            OnScrollAnimationEnded();
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// Override this function when developer wants to change destination of flicking.(e.g. always snap to center of item)
        /// </summary>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual float AdjustTargetPositionOfScrollAnimation(float position)
        {
            return position;
        }

        /// <summary>
        /// Scroll position given to ScrollTo.
        /// This is the position in the opposite direction to the position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position ScrollPosition
        {
            get
            {
                return new Position(-ContentContainer.Position);
            }
        }

        /// <summary>
        /// Current scroll position in the middle of ScrollTo animation.
        /// This is the position in the opposite direction to the current position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position ScrollCurrentPosition
        {
            get
            {
                return new Position(-ContentContainer.CurrentPosition);
            }
        }

        /// <summary>
        /// Remove all children in ContentContainer.
        /// </summary>
        /// <param name="dispose">If true, removed child is disposed.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void RemoveAllChildren(bool dispose = false)
        {
            RecursiveRemoveChildren(ContentContainer, dispose);
        }

        private void RecursiveRemoveChildren(View parent, bool dispose)
        {
            if (parent == null)
            {
                return;
            }
            int maxChild = (int)parent.GetChildCount();
            for (int i = maxChild - 1; i >= 0; --i)
            {
                View child = parent.GetChildAt((uint)i);
                if (child == null)
                {
                    continue;
                }
                RecursiveRemoveChildren(child, dispose);
                parent.Remove(child);
                if (dispose)
                {
                    child.Dispose();
                }
            }
        }

    }

} // namespace

---- Transformed Tree ----
using System;
using Tizen.NUI;
using Tizen.NUI.BaseComponents;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Tizen.NUI.Accessibility;

namespace Tizen.NUI.Components
{
    /// <summary>
    /// ScrollEventArgs is a class to record scroll event arguments which will sent to user.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    public class ScrollEventArgs : EventArgs
    {
        private Position position;

        /// <summary>
        /// Default constructor.
        /// </summary>
        /// <param name="position">Current scroll position</param>
        /// <since_tizen> 8 </since_tizen>
        public ScrollEventArgs(Position position)
        {
            this.position = position;
        }

        /// <summary>
        /// Current position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position Position
        {
            get
            {
                return position;
            }
        }
    }

    /// <summary>
    /// ScrollOutofBoundEventArgs is to record scroll out-of-bound event arguments which will be sent to user.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class ScrollOutOfBoundEventArgs : EventArgs
    {
        /// <summary>
        /// The direction to be touched.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public enum Direction
        {
            /// <summary>
            /// Upwards.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Up,

            /// <summary>
            /// Downwards.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Down,

            /// <summary>
            /// Left bound.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Left,

            /// <summary>
            /// Right bound.
            /// </summary>
            [EditorBrowsable(EditorBrowsableState.Never)]
            Right,
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="direction">Current pan direction</param>
        /// <param name="displacement">Current total displacement</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ScrollOutOfBoundEventArgs(Direction direction, float displacement)
        {
            PanDirection = direction;
            Displacement = displacement;
        }

        /// <summary>
        /// Current pan direction of ContentContainer.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Direction PanDirection
        {
            get;
        }

        /// <summary>
        /// Current total displacement of ContentContainer.
        /// if its value is greater than 0, it is at the top/left;
        /// if less than 0, it is at the bottom/right.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float Displacement
        {
            get;
        }
    }

    /// <summary>
    /// This class provides a View that can scroll a single View with a layout. This View can be a nest of Views.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    public class ScrollableBase : Control
    {
        static bool LayoutDebugScrollableBase = false; // Debug flag
        private Direction mScrollingDirection = Direction.Vertical;
        private bool mScrollEnabled = true;
        private int mScrollDuration = 125;
        private int mPageWidth = 0;
        private float mPageFlickThreshold = 0.4f;
        private float mScrollingEventThreshold = 0.001f;

        private class ScrollableBaseCustomLayout : AbsoluteLayout
        {
            protected override void OnMeasure(MeasureSpecification widthMeasureSpec, MeasureSpecification heightMeasureSpec)
            {
                MeasuredSize.StateType childWidthState = MeasuredSize.StateType.MeasuredSizeOK;
                MeasuredSize.StateType childHeightState = MeasuredSize.StateType.MeasuredSizeOK;

                Direction scrollingDirection = Direction.Vertical;

                if (this.Owner is ScrollableBase scrollableBase)
                {
                    scrollingDirection = scrollableBase.ScrollingDirection;
                }

                float totalWidth = 0.0f;
                float totalHeight = 0.0f;

                // measure child, should be a single scrolling child
                foreach (LayoutItem childLayout in LayoutChildren)
                {
                    if (childLayout != null && childLayout.Owner.Name == "ContentContainer")
                    {
                        // Get size of child
                        // Use an Unspecified MeasureSpecification mode so scrolling child is not restricted to it's parents size in Height (for vertical scrolling)
                        // or Width for horizontal scrolling
                        if (scrollingDirection == Direction.Vertical)
                        {
                            MeasureSpecification unrestrictedMeasureSpec = new MeasureSpecification(heightMeasureSpec.Size, MeasureSpecification.ModeType.Unspecified);
                            MeasureChildWithMargins(childLayout, widthMeasureSpec, new LayoutLength(0), unrestrictedMeasureSpec, new LayoutLength(0)); // Height unrestricted by parent
                        }
                        else
                        {
                            MeasureSpecification unrestrictedMeasureSpec = new MeasureSpecification(widthMeasureSpec.Size, MeasureSpecification.ModeType.Unspecified);
                            MeasureChildWithMargins(childLayout, unrestrictedMeasureSpec, new LayoutLength(0), heightMeasureSpec, new LayoutLength(0)); // Width unrestricted by parent
                        }

                        totalWidth = (childLayout.MeasuredWidth.Size + (childLayout.Padding.Start + childLayout.Padding.End)).AsDecimal();
                        totalHeight = (childLayout.MeasuredHeight.Size + (childLayout.Padding.Top + childLayout.Padding.Bottom)).AsDecimal();

                        if (childLayout.MeasuredWidth.State == MeasuredSize.StateType.MeasuredSizeTooSmall)
                        {
                            childWidthState = MeasuredSize.StateType.MeasuredSizeTooSmall;
                        }
                        if (childLayout.MeasuredHeight.State == MeasuredSize.StateType.MeasuredSizeTooSmall)
                        {
                            childHeightState = MeasuredSize.StateType.MeasuredSizeTooSmall;
                        }
                    }
                }

                MeasuredSize widthSizeAndState = ResolveSizeAndState(new LayoutLength(totalWidth), widthMeasureSpec, MeasuredSize.StateType.MeasuredSizeOK);
                MeasuredSize heightSizeAndState = ResolveSizeAndState(new LayoutLength(totalHeight), heightMeasureSpec, MeasuredSize.StateType.MeasuredSizeOK);
                totalWidth = widthSizeAndState.Size.AsDecimal();
                totalHeight = heightSizeAndState.Size.AsDecimal();

                // Ensure layout respects it's given minimum size
                totalWidth = Math.Max(totalWidth, SuggestedMinimumWidth.AsDecimal());
                totalHeight = Math.Max(totalHeight, SuggestedMinimumHeight.AsDecimal());

                widthSizeAndState.State = childWidthState;
                heightSizeAndState.State = childHeightState;

                SetMeasuredDimensions(ResolveSizeAndState(new LayoutLength(totalWidth), widthMeasureSpec, childWidthState),
                    ResolveSizeAndState(new LayoutLength(totalHeight), heightMeasureSpec, childHeightState));

                // Size of ScrollableBase is changed. Change Page width too.
                if (this.Owner is ScrollableBase scrollableBase)
                {
                    scrollableBase.mPageWidth = (int)MeasuredWidth.Size.AsRoundedValue();
                    scrollableBase.OnScrollingChildRelayout(null, null);
                }
            }
        } //  ScrollableBaseCustomLayout

        /// <summary>
        /// The direction axis to scroll.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public enum Direction
        {
            /// <summary>
            /// Horizontal axis.
            /// </summary>
            /// <since_tizen> 8 </since_tizen>
            Horizontal,

            /// <summary>
            /// Vertical axis.
            /// </summary>
            /// <since_tizen> 8 </since_tizen>
            Vertical
        }

        /// <summary>
        /// Scrolling direction mode.
        /// Default is Vertical scrolling.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Direction ScrollingDirection
        {
            get
            {
                return mScrollingDirection;
            }
            set
            {
                if (value != mScrollingDirection)
                {
                    mScrollingDirection = value;
                    mPanGestureDetector.ClearAngles();
                    mPanGestureDetector.AddDirection(value == Direction.Horizontal ?
                        PanGestureDetector.DirectionHorizontal : PanGestureDetector.DirectionVertical);

                    ContentContainer.WidthSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.MatchParent : LayoutParamPolicies.WrapContent;
                    ContentContainer.HeightSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.WrapContent : LayoutParamPolicies.MatchParent;
                }
            }
        }

        /// <summary>
        /// Enable or disable scrolling.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool ScrollEnabled
        {
            get
            {
                return mScrollEnabled;
            }
            set
            {
                if (value != mScrollEnabled)
                {
                    mScrollEnabled = value;
                    if (mScrollEnabled)
                    {
                        mPanGestureDetector.Detected += OnPanGestureDetected;
                    }
                    else
                    {
                        mPanGestureDetector.Detected -= OnPanGestureDetected;
                    }
                }
            }
        }

        /// <summary>
        /// Gets scrollable status.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override bool AccessibilityIsScrollable()
        {
            return true;
        }

        /// <summary>
        /// Pages mode, enables moving to the next or return to current page depending on pan displacement.
        /// Default is false.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool SnapToPage { set; get; } = false;

        /// <summary>
        /// Get current page.
        /// Working property with SnapToPage property.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public int CurrentPage { get; private set; } = 0;

        /// <summary>
        /// Duration of scroll animation.
        /// Default value is 125ms.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public int ScrollDuration
        {
            set
            {
                mScrollDuration = value >= 0 ? value : mScrollDuration;
            }
            get
            {
                return mScrollDuration;
            }
        }

        /// <summary>
        /// Scroll Available area.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Vector2 ScrollAvailableArea { set; get; }

        /// <summary>
        /// An event emitted when user starts dragging ScrollableBase, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollDragStarted;

        /// <summary>
        /// An event emitted when user stops dragging ScrollableBase, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollDragEnded;

        /// <summary>
        /// An event emitted when the scrolling slide animation starts, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollAnimationStarted;

        /// <summary>
        /// An event emitted when the scrolling slide animation ends, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> ScrollAnimationEnded;

        /// <summary>
        /// An event emitted when scrolling, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public event EventHandler<ScrollEventArgs> Scrolling;

        /// <summary>
        /// An event emitted when scrolling out of bound, user can subscribe or unsubscribe to this event handler.<br />
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public event EventHandler<ScrollOutOfBoundEventArgs> ScrollOutOfBound;

        /// <summary>
        /// Scrollbar for ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public ScrollbarBase Scrollbar
        {
            get
            {
                return scrollBar;
            }
            set
            {
                if (scrollBar)
                {
                    base.Remove(scrollBar);
                }
                scrollBar = value;

                if (scrollBar != null)
                {
                    scrollBar.Name = "ScrollBar";
                    base.Add(scrollBar);

                    if (hideScrollbar)
                    {
                        scrollBar.Hide();
                    }
                    else
                    {
                        scrollBar.Show();
                    }

                    SetScrollbar();
                }
            }
        }

        /// <summary>
        /// Always hide Scrollbar.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public bool HideScrollbar
        {
            get
            {
                return hideScrollbar;
            }
            set
            {
                hideScrollbar = value;

                if (scrollBar)
                {
                    if (value)
                    {
                        scrollBar.Hide();
                    }
                    else
                    {
                        scrollBar.Show();
                    }
                }
            }
        }

        /// <summary>
        /// Container which has content of ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public View ContentContainer { get; private set; }

        /// <summary>
        /// Set the layout on this View. Replaces any existing Layout.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public new LayoutItem Layout
        {
            get
            {
                return ContentContainer.Layout;
            }
            set
            {
                ContentContainer.Layout = value;
            }
        }

        /// <summary>
        /// List of children of Container.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public new List<View> Children
        {
            get
            {
                return ContentContainer.Children;
            }
        }

        /// <summary>
        /// Deceleration rate of scrolling by finger.
        /// Rate should be bigger than 0 and smaller than 1.
        /// Default value is 0.998f;
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public float DecelerationRate
        {
            get
            {
                return decelerationRate;
            }
            set
            {
                decelerationRate = (value < 1 && value > 0) ? value : decelerationRate;
                logValueOfDeceleration = (float)Math.Log(value);
            }
        }

        /// <summary>
        /// Threashold not to go infinit at the end of scrolling animation.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float DecelerationThreshold { get; set; } = 0.1f;

        /// <summary>
        /// Scrolling event will be thrown when this amount of scroll position is changed.
        /// If this threshold becomes smaller, the tracking detail increases but the scrolling range that can be tracked becomes smaller.
        /// If large sized ContentContainer is required, please use larger threshold value.
        /// Default ScrollingEventThreshold value is 0.001f.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public float ScrollingEventThreshold
        {
            get
            {
                return mScrollingEventThreshold;
            }
            set
            {
                if (mScrollingEventThreshold != value && value > 0)
                {
                    ContentContainer.RemovePropertyNotification(propertyNotification);
                    propertyNotification = ContentContainer.AddPropertyNotification("position", PropertyCondition.Step(value));
                    propertyNotification.Notified += OnPropertyChanged;
                    mScrollingEventThreshold = value;
                }
            }
        }

        /// <summary>
        /// Page will be changed when velocity of panning is over threshold.
        /// The unit of threshold is pixel per milisec.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public float PageFlickThreshold
        {
            get
            {
                return mPageFlickThreshold;
            }
            set
            {
                mPageFlickThreshold = value >= 0f ? value : mPageFlickThreshold;
            }
        }

        /// <summary>
        /// Padding for the ScrollableBase
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public new Extents Padding
        {
            get
            {
                return ContentContainer.Padding;
            }
            set
            {
                ContentContainer.Padding = value;
            }
        }

        /// <summary>
        /// Alphafunction for scroll animation.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public AlphaFunction ScrollAlphaFunction { get; set; } = new AlphaFunction(AlphaFunction.BuiltinFunctions.Linear);

        private bool hideScrollbar = true;
        private float maxScrollDistance;
        private float childTargetPosition = 0.0f;
        private PanGestureDetector mPanGestureDetector;
        private View mInterruptTouchingChild;
        private ScrollbarBase scrollBar;
        private bool scrolling = false;
        private float ratioOfScreenWidthToCompleteScroll = 0.5f;
        private float totalDisplacementForPan = 0.0f;
        private Size previousContainerSize = new Size();
        private Size previousSize = new Size();
        private PropertyNotification propertyNotification;
        private float noticeAnimationEndBeforePosition = 0.0f;
        private bool readyToNotice = false;

        /// <summary>
        /// Notice before animation is finished.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        // Let's consider more whether this needs to be set as protected.
        public float NoticeAnimationEndBeforePosition
        {
            get => noticeAnimationEndBeforePosition;
            set => noticeAnimationEndBeforePosition = value;
        }

        // Let's consider more whether this needs to be set as protected.
        private float finalTargetPosition;

        private Animation scrollAnimation;
        // Declare user alpha function delegate
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate float UserAlphaFunctionDelegate(float progress);
        private UserAlphaFunctionDelegate customScrollAlphaFunction;
        private float velocityOfLastPan = 0.0f;
        private float panAnimationDuration = 0.0f;
        private float panAnimationDelta = 0.0f;
        private float logValueOfDeceleration = 0.0f;
        private float decelerationRate = 0.0f;

        private View topOverShootingShadowView;
        private View bottomOverShootingShadowView;
        private View leftOverShootingShadowView;
        private View rightOverShootingShadowView;
        private const int overShootingShadowScaleHeightLimit = 64 * 3;
        private const int overShootingShadowAnimationDuration = 300;
        private Animation overShootingShadowAnimation;
        private bool isOverShootingShadowShown = false;
        private float startShowShadowDisplacement;

        /// <summary>
        /// Default Constructor
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public ScrollableBase() : base()
        {
            DecelerationRate = 0.998f;

            base.Layout = new ScrollableBaseCustomLayout();
            mPanGestureDetector = new PanGestureDetector();
            mPanGestureDetector.Attach(this);
            mPanGestureDetector.AddDirection(PanGestureDetector.DirectionVertical);
            if (mPanGestureDetector.GetMaximumTouchesRequired() < 2) mPanGestureDetector.SetMaximumTouchesRequired(2);
            mPanGestureDetector.Detected += OnPanGestureDetected;

            ClippingMode = ClippingModeType.ClipToBoundingBox;

            //Default Scrolling child
            ContentContainer = new View()
            {
                Name = "ContentContainer",
                WidthSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.MatchParent : LayoutParamPolicies.WrapContent,
                HeightSpecification = ScrollingDirection == Direction.Vertical ? LayoutParamPolicies.WrapContent : LayoutParamPolicies.MatchParent,
            };
            ContentContainer.Relayout += OnScrollingChildRelayout;
            propertyNotification = ContentContainer.AddPropertyNotification("position", PropertyCondition.Step(mScrollingEventThreshold));
            propertyNotification.Notified += OnPropertyChanged;
            base.Add(ContentContainer);

            //Interrupt touching when panning is started
            mInterruptTouchingChild = new View()
            {
                Size = new Size(Window.Instance.WindowSize),
                BackgroundColor = Color.Transparent,
            };
            mInterruptTouchingChild.TouchEvent += OnIterruptTouchingChildTouched;
            Scrollbar = new Scrollbar();

            //Show vertical shadow on the top (or bottom) of the scrollable when panning down (or up).
            topOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_top.png",
                Opacity = 1.0f,
                SizeHeight = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.TopCenter,
                PivotPoint = NUI.PivotPoint.TopCenter,
            };
            bottomOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_bottom.png",
                Opacity = 1.0f,
                SizeHeight = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.BottomCenter,
                PivotPoint = NUI.PivotPoint.BottomCenter,
            };
            //Show horizontal shadow on the left (or right) of the scrollable when panning down (or up).
            leftOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_left.png",
                Opacity = 1.0f,
                SizeWidth = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.CenterLeft,
                PivotPoint = NUI.PivotPoint.CenterLeft,
            };
            rightOverShootingShadowView = new View
            {
                BackgroundImage = FrameworkInformation.ResourcePath + "nui_component_default_scroll_over_shooting_right.png",
                Opacity = 1.0f,
                SizeWidth = 0.0f,
                PositionUsesPivotPoint = true,
                ParentOrigin = NUI.ParentOrigin.CenterRight,
                PivotPoint = NUI.PivotPoint.CenterRight,
            };

            AccessibilityManager.Instance.SetAccessibilityAttribute(this, AccessibilityManager.AccessibilityAttribute.Trait, "ScrollableBase");
        }

        private bool OnIterruptTouchingChildTouched(object source, View.TouchEventArgs args)
        {
            if (args.Touch.GetState(0) == PointStateType.Down)
            {
                if (scrolling && !SnapToPage)
                {
                    StopScroll();
                }
            }
            return true;
        }

        private void OnPropertyChanged(object source, PropertyNotification.NotifyEventArgs args)
        {
            OnScroll();
        }

        /// <summary>
        /// Called after a child has been added to the owning view.
        /// </summary>
        /// <param name="view">The child which has been added.</param>
        /// <since_tizen> 8 </since_tizen>
        public override void Add(View view)
        {
            ContentContainer.Add(view);
        }

        /// <summary>
        /// Called after a child has been removed from the owning view.
        /// </summary>
        /// <param name="view">The child which has been removed.</param>
        /// <since_tizen> 8 </since_tizen>
        public override void Remove(View view)
        {
            if (SnapToPage && CurrentPage == Children.IndexOf(view) && CurrentPage == Children.Count - 1)
            {
                // Target View is current page and also last child.
                // CurrentPage should be changed to previous page.
                CurrentPage = Math.Max(0, CurrentPage - 1);
                ScrollToIndex(CurrentPage);
            }

            ContentContainer.Remove(view);
        }

        private void OnScrollingChildRelayout(object source, EventArgs args)
        {
            // Size is changed. Calculate maxScrollDistance.
            bool isSizeChanged = previousContainerSize.Width != ContentContainer.Size.Width || previousContainerSize.Height != ContentContainer.Size.Height ||
                previousSize.Width != Size.Width || previousSize.Height != Size.Height;

            if (isSizeChanged)
            {
                maxScrollDistance = CalculateMaximumScrollDistance();
                SetScrollbar();
            }

            previousContainerSize = ContentContainer.Size;
            previousSize = Size;
        }

        /// <summary>
        /// The composition of a Scrollbar can vary depending on how you use ScrollableBase.
        /// Set the composition that will go into the ScrollableBase according to your ScrollableBase.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void SetScrollbar()
        {
            if (Scrollbar)
            {
                bool isHorizontal = ScrollingDirection == Direction.Horizontal;
                float contentLength = isHorizontal ? ContentContainer.Size.Width : ContentContainer.Size.Height;
                float viewportLength = isHorizontal ? Size.Width : Size.Height;
                float currentPosition = isHorizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y;
                Scrollbar.Initialize(contentLength, viewportLength, currentPosition, isHorizontal);
            }
        }

        /// <summary>
        /// Scrolls to the item at the specified index.
        /// </summary>
        /// <param name="index">Index of item.</param>
        /// <since_tizen> 8 </since_tizen>
        public void ScrollToIndex(int index)
        {
            if (ContentContainer.ChildCount - 1 < index || index < 0)
            {
                return;
            }

            if (SnapToPage)
            {
                CurrentPage = index;
            }

            float targetPosition = Math.Min(ScrollingDirection == Direction.Vertical ? Children[index].Position.Y : Children[index].Position.X, maxScrollDistance);
            AnimateChildTo(ScrollDuration, -targetPosition);
        }

        private void OnScrollDragStarted()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollDragStarted?.Invoke(this, eventArgs);
        }

        private void OnScrollDragEnded()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollDragEnded?.Invoke(this, eventArgs);
        }

        private void OnScrollAnimationStarted()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollAnimationStarted?.Invoke(this, eventArgs);
        }

        private void OnScrollAnimationEnded()
        {
            scrolling = false;
            base.Remove(mInterruptTouchingChild);

            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            ScrollAnimationEnded?.Invoke(this, eventArgs);
        }

        private void OnScroll()
        {
            ScrollEventArgs eventArgs = new ScrollEventArgs(ContentContainer.CurrentPosition);
            Scrolling?.Invoke(this, eventArgs);

            bool isHorizontal = ScrollingDirection == Direction.Horizontal;
            float contentLength = isHorizontal ? ContentContainer.Size.Width : ContentContainer.Size.Height;
            float currentPosition = isHorizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y;

            scrollBar?.Update(contentLength, Math.Abs(currentPosition));
            CheckPreReachedTargetPosition();
        }

        private void CheckPreReachedTargetPosition()
        {
            // Check whether we reached pre-reached target position
            if (readyToNotice &&
                ContentContainer.CurrentPosition.Y <= finalTargetPosition + NoticeAnimationEndBeforePosition &&
                ContentContainer.CurrentPosition.Y >= finalTargetPosition - NoticeAnimationEndBeforePosition)
            {
                //Notice first
                readyToNotice = false;
                OnPreReachedTargetPosition(finalTargetPosition);
            }
        }

        /// <summary>
        /// This helps developer who wants to know before scroll is reaching target position.
        /// </summary>
        /// <param name="targetPosition">Index of item.</param>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void OnPreReachedTargetPosition(float targetPosition)
        {

        }

        private void StopScroll()
        {
            if (scrollAnimation != null)
            {
                if (scrollAnimation.State == Animation.States.Playing)
                {
                    Debug.WriteLineIf(LayoutDebugScrollableBase, "StopScroll Animation Playing");
                    scrollAnimation.Stop(Animation.EndActions.Cancel);
                    OnScrollAnimationEnded();
                }
                scrollAnimation.Clear();
            }
        }

        private void AnimateChildTo(int duration, float axisPosition)
        {
            Debug.WriteLineIf(LayoutDebugScrollableBase, "AnimationTo Animation Duration:" + duration + " Destination:" + axisPosition);
            finalTargetPosition = axisPosition;

            StopScroll(); // Will replace previous animation so will stop existing one.

            if (scrollAnimation == null)
            {
                scrollAnimation = new Animation();
                scrollAnimation.Finished += ScrollAnimationFinished;
            }

            scrollAnimation.Duration = duration;
            scrollAnimation.DefaultAlphaFunction = new AlphaFunction(AlphaFunction.BuiltinFunctions.EaseOutSquare);
            scrollAnimation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", axisPosition, ScrollAlphaFunction);
            scrolling = true;
            OnScrollAnimationStarted();
            scrollAnimation.Play();
        }

        /// <summary>
        /// Scroll to specific position with or without animation.
        /// </summary>
        /// <param name="position">Destination.</param>
        /// <param name="animate">Scroll with or without animation</param>
        /// <since_tizen> 8 </since_tizen>
        public void ScrollTo(float position, bool animate)
        {
            float currentPositionX = ContentContainer.CurrentPosition.X != 0 ? ContentContainer.CurrentPosition.X : ContentContainer.Position.X;
            float currentPositionY = ContentContainer.CurrentPosition.Y != 0 ? ContentContainer.CurrentPosition.Y : ContentContainer.Position.Y;
            float delta = ScrollingDirection == Direction.Horizontal ? currentPositionX : currentPositionY;
            // The argument position is the new pan position. So the new position of ScrollableBase becomes (-position).
            // To move ScrollableBase's position to (-position), it moves by (-position - currentPosition).
            delta = -position - delta;

            ScrollBy(delta, animate);
        }

        private float BoundScrollPosition(float targetPosition)
        {
            if (ScrollAvailableArea != null)
            {
                float minScrollPosition = ScrollAvailableArea.X;
                float maxScrollPosition = ScrollAvailableArea.Y;

                targetPosition = Math.Min(-minScrollPosition, targetPosition);
                targetPosition = Math.Max(-maxScrollPosition, targetPosition);
            }
            else
            {
                targetPosition = Math.Min(0, targetPosition);
                targetPosition = Math.Max(-maxScrollDistance, targetPosition);
            }

            return targetPosition;
        }

        private void ScrollBy(float displacement, bool animate)
        {
            if (GetChildCount() == 0 || maxScrollDistance < 0)
            {
                return;
            }

            float childCurrentPosition = (ScrollingDirection == Direction.Horizontal) ? ContentContainer.PositionX : ContentContainer.PositionY;

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy childCurrentPosition:" + childCurrentPosition +
                " displacement:" + displacement,
                " maxScrollDistance:" + maxScrollDistance);

            childTargetPosition = childCurrentPosition + displacement; // child current position + gesture displacement

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy currentAxisPosition:" + childCurrentPosition + "childTargetPosition:" + childTargetPosition);

            if (animate)
            {
                // Calculate scroll animaton duration
                float scrollDistance = Math.Abs(displacement);
                readyToNotice = true;

                AnimateChildTo(ScrollDuration, BoundScrollPosition(AdjustTargetPositionOfScrollAnimation(BoundScrollPosition(childTargetPosition))));
            }
            else
            {
                finalTargetPosition = BoundScrollPosition(childTargetPosition);

                // Set position of scrolling child without an animation
                if (ScrollingDirection == Direction.Horizontal)
                {
                    ContentContainer.PositionX = finalTargetPosition;
                }
                else
                {
                    ContentContainer.PositionY = finalTargetPosition;
                }
            }
        }

        /// <summary>
        /// you can override it to clean-up your own resources.
        /// </summary>
        /// <param name="type">DisposeTypes</param>
        /// This will be public opened in tizen_5.5 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected override void Dispose(DisposeTypes type)
        {
            if (disposed)
            {
                return;
            }

            if (type == DisposeTypes.Explicit)
            {
                StopOverShootingShadowAnimation();
                StopScroll();

                if (mPanGestureDetector != null)
                {
                    mPanGestureDetector.Detected -= OnPanGestureDetected;
                    mPanGestureDetector.Dispose();
                    mPanGestureDetector = null;
                }

                propertyNotification.Dispose();
            }
            base.Dispose(type);
        }

        private float CalculateMaximumScrollDistance()
        {
            float scrollingChildLength = 0;
            float scrollerLength = 0;
            if (ScrollingDirection == Direction.Horizontal)
            {
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Horizontal");

                scrollingChildLength = ContentContainer.Size.Width;
                scrollerLength = Size.Width;
            }
            else
            {
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Vertical");
                scrollingChildLength = ContentContainer.Size.Height;
                scrollerLength = Size.Height;
            }

            Debug.WriteLineIf(LayoutDebugScrollableBase, "ScrollBy maxScrollDistance:" + (scrollingChildLength - scrollerLength) +
                " parent length:" + scrollerLength +
                " scrolling child length:" + scrollingChildLength);

            return Math.Max(scrollingChildLength - scrollerLength, 0);
        }

        private void PageSnap(float velocity)
        {
            float destination;

            Debug.WriteLineIf(LayoutDebugScrollableBase, "PageSnap with pan candidate totalDisplacement:" + totalDisplacementForPan +
                " currentPage[" + CurrentPage + "]");

            //Increment current page if total displacement enough to warrant a page change.
            if (Math.Abs(totalDisplacementForPan) > (mPageWidth * ratioOfScreenWidthToCompleteScroll))
            {
                if (totalDisplacementForPan < 0)
                {
                    CurrentPage = Math.Min(Math.Max(Children.Count - 1, 0), ++CurrentPage);
                }
                else
                {
                    CurrentPage = Math.Max(0, --CurrentPage);
                }
            }
            else if (Math.Abs(velocity) > PageFlickThreshold)
            {
                if (velocity < 0)
                {
                    CurrentPage = Math.Min(Math.Max(Children.Count - 1, 0), ++CurrentPage);
                }
                else
                {
                    CurrentPage = Math.Max(0, --CurrentPage);
                }
            }

            // Animate to new page or reposition to current page
            if (ScrollingDirection == Direction.Horizontal)
                destination = -(Children[CurrentPage].Position.X + Children[CurrentPage].CurrentSize.Width / 2 - CurrentSize.Width / 2); // set to middle of current page
            else
                destination = -(Children[CurrentPage].Position.Y + Children[CurrentPage].CurrentSize.Height / 2 - CurrentSize.Height / 2);

            AnimateChildTo(ScrollDuration, destination);
        }

        /// <summary>
        /// Enable/Disable overshooting effect. default is disabled.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool EnableOverShootingEffect { get; set; } = false;

        private void AttachOverShootingShadowView()
        {
            if (!EnableOverShootingEffect)
                return;

            // stop animation if necessary.
            StopOverShootingShadowAnimation();

            if (ScrollingDirection == Direction.Horizontal)
            {
                base.Add(leftOverShootingShadowView);
                base.Add(rightOverShootingShadowView);

                leftOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                leftOverShootingShadowView.Opacity = 1.0f;
                leftOverShootingShadowView.RaiseToTop();

                rightOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                rightOverShootingShadowView.Opacity = 1.0f;
                rightOverShootingShadowView.RaiseToTop();
            }
            else
            {
                base.Add(topOverShootingShadowView);
                base.Add(bottomOverShootingShadowView);

                topOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                topOverShootingShadowView.Opacity = 1.0f;
                topOverShootingShadowView.RaiseToTop();

                bottomOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                bottomOverShootingShadowView.Opacity = 1.0f;
                bottomOverShootingShadowView.RaiseToTop();
            }

            // at the beginning, height or width of overshooting shadow is 0, so it is invisible.
            isOverShootingShadowShown = false;
        }

        private void DragOverShootingShadow(float totalPanDisplacement, float panDisplacement)
        {
            if (!EnableOverShootingEffect)
                return;

            if (totalPanDisplacement > 0) // downwards
            {
                // check if reaching at the top / left.
                if ((int)finalTargetPosition != 0)
                {
                    isOverShootingShadowShown = false;
                    return;
                }

                // save start displacement, and re-calculate displacement.
                if (!isOverShootingShadowShown)
                {
                    startShowShadowDisplacement = totalPanDisplacement;
                }
                isOverShootingShadowShown = true;

                float newDisplacement = (int)totalPanDisplacement < (int)startShowShadowDisplacement ? 0 : totalPanDisplacement - startShowShadowDisplacement;

                if (ScrollingDirection == Direction.Horizontal)
                {
                    // scale limit of height is 60%.
                    float heightScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    leftOverShootingShadowView.SizeHeight = heightScale > 0.6f ? SizeHeight * 0.4f : SizeHeight * (1.0f - heightScale);

                    // scale limit of width is 300%.
                    leftOverShootingShadowView.SizeWidth = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Right : ScrollOutOfBoundEventArgs.Direction.Left;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
                else
                {
                    // scale limit of width is 60%.
                    float widthScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    topOverShootingShadowView.SizeWidth = widthScale > 0.6f ? SizeWidth * 0.4f : SizeWidth * (1.0f - widthScale);

                    // scale limit of height is 300%.
                    topOverShootingShadowView.SizeHeight = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Down : ScrollOutOfBoundEventArgs.Direction.Up;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
            }
            else if (totalPanDisplacement < 0) // upwards
            {
                // check if reaching at the bottom.
                if (-(int)finalTargetPosition != (int)maxScrollDistance)
                {
                    isOverShootingShadowShown = false;
                    return;
                }

                // save start displacement, and re-calculate displacement.
                if (!isOverShootingShadowShown)
                {
                    startShowShadowDisplacement = totalPanDisplacement;
                }
                isOverShootingShadowShown = true;

                float newDisplacement = (int)startShowShadowDisplacement < (int)totalPanDisplacement ? 0 : startShowShadowDisplacement - totalPanDisplacement;

                if (ScrollingDirection == Direction.Horizontal)
                {
                    // scale limit of height is 60%.
                    float heightScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    rightOverShootingShadowView.SizeHeight = heightScale > 0.6f ? SizeHeight * 0.4f : SizeHeight * (1.0f - heightScale);

                    // scale limit of width is 300%.
                    rightOverShootingShadowView.SizeWidth = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Right : ScrollOutOfBoundEventArgs.Direction.Left;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
                else
                {
                    // scale limit of width is 60%.
                    float widthScale = newDisplacement / overShootingShadowScaleHeightLimit;
                    bottomOverShootingShadowView.SizeWidth = widthScale > 0.6f ? SizeWidth * 0.4f : SizeWidth * (1.0f - widthScale);

                    // scale limit of height is 300%.
                    bottomOverShootingShadowView.SizeHeight = newDisplacement > overShootingShadowScaleHeightLimit ? overShootingShadowScaleHeightLimit : newDisplacement;

                    // trigger event
                    ScrollOutOfBoundEventArgs.Direction scrollDirection = panDisplacement > 0 ?
                       ScrollOutOfBoundEventArgs.Direction.Down : ScrollOutOfBoundEventArgs.Direction.Up;
                    OnScrollOutOfBound(scrollDirection, totalPanDisplacement);
                }
            }
            else
            {
                // if total displacement is 0, shadow would become invisible.
                isOverShootingShadowShown = false;
            }
        }

        private void PlayOverShootingShadowAnimation()
        {
            if (!EnableOverShootingEffect)
                return;

            // stop animation if necessary.
            StopOverShootingShadowAnimation();

            if (overShootingShadowAnimation == null)
            {
                overShootingShadowAnimation = new Animation(overShootingShadowAnimationDuration);
                overShootingShadowAnimation.Finished += OnOverShootingShadowAnimationFinished;
            }

            if (ScrollingDirection == Direction.Horizontal)
            {
                View targetView = totalDisplacementForPan < 0 ? rightOverShootingShadowView : leftOverShootingShadowView;
                overShootingShadowAnimation.AnimateTo(targetView, "SizeHeight", SizeHeight);
                overShootingShadowAnimation.AnimateTo(targetView, "SizeWidth", 0.0f);
                overShootingShadowAnimation.AnimateTo(targetView, "Opacity", 0.0f);
            }
            else
            {
                View targetView = totalDisplacementForPan < 0 ? bottomOverShootingShadowView : topOverShootingShadowView;
                overShootingShadowAnimation.AnimateTo(targetView, "SizeWidth", SizeWidth);
                overShootingShadowAnimation.AnimateTo(targetView, "SizeHeight", 0.0f);
                overShootingShadowAnimation.AnimateTo(targetView, "Opacity", 0.0f);
            }
            overShootingShadowAnimation.Play();
        }

        private void StopOverShootingShadowAnimation()
        {
            if (overShootingShadowAnimation == null || overShootingShadowAnimation.State != Animation.States.Playing)
                return;

            overShootingShadowAnimation.Stop(Animation.EndActions.Cancel);
            OnOverShootingShadowAnimationFinished(null, null);
            overShootingShadowAnimation.Clear();
        }

        private void OnOverShootingShadowAnimationFinished(object sender, EventArgs e)
        {
            if (ScrollingDirection == Direction.Horizontal)
            {
                base.Remove(leftOverShootingShadowView);
                base.Remove(rightOverShootingShadowView);

                leftOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
                rightOverShootingShadowView.Size = new Size(0.0f, SizeHeight);
            }
            else
            {
                base.Remove(topOverShootingShadowView);
                base.Remove(bottomOverShootingShadowView);

                topOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
                bottomOverShootingShadowView.Size = new Size(SizeWidth, 0.0f);
            }

            // after animation finished, height/width & opacity of vertical shadow both are 0, so it is invisible.
            isOverShootingShadowShown = false;
        }

        private void OnScrollOutOfBound(ScrollOutOfBoundEventArgs.Direction direction, float displacement)
        {
            ScrollOutOfBoundEventArgs args = new ScrollOutOfBoundEventArgs(direction, displacement);
            ScrollOutOfBound?.Invoke(this, args);
        }

        private void OnPanGestureDetected(object source, PanGestureDetector.DetectedEventArgs e)
        {
            OnPanGesture(e.PanGesture);
        }

        private void OnPanGesture(PanGesture panGesture)
        {
            if (SnapToPage && scrollAnimation != null && scrollAnimation.State == Animation.States.Playing)
            {
                return;
            }

            if (panGesture.State == Gesture.StateType.Started)
            {
                readyToNotice = false;
                base.Add(mInterruptTouchingChild);
                AttachOverShootingShadowView();
                Debug.WriteLineIf(LayoutDebugScrollableBase, "Gesture Start");
                if (scrolling && !SnapToPage)
                {
                    StopScroll();
                }
                totalDisplacementForPan = 0.0f;
                OnScrollDragStarted();
            }
            else if (panGesture.State == Gesture.StateType.Continuing)
            {
                if (ScrollingDirection == Direction.Horizontal)
                {
                    // if vertical shadow is shown, does not scroll.
                    if (!isOverShootingShadowShown)
                    {
                        ScrollBy(panGesture.Displacement.X, false);
                    }
                    totalDisplacementForPan += panGesture.Displacement.X;
                    DragOverShootingShadow(totalDisplacementForPan, panGesture.Displacement.X);
                }
                else
                {
                    // if vertical shadow is shown, does not scroll.
                    if (!isOverShootingShadowShown)
                    {
                        ScrollBy(panGesture.Displacement.Y, false);
                    }
                    totalDisplacementForPan += panGesture.Displacement.Y;
                    DragOverShootingShadow(totalDisplacementForPan, panGesture.Displacement.Y);
                }
                Debug.WriteLineIf(LayoutDebugScrollableBase, "OnPanGestureDetected Continue totalDisplacementForPan:" + totalDisplacementForPan);
            }
            else if (panGesture.State == Gesture.StateType.Finished || panGesture.State == Gesture.StateType.Cancelled)
            {
                PlayOverShootingShadowAnimation();
                OnScrollDragEnded();
                StopScroll(); // Will replace previous animation so will stop existing one.

                if (scrollAnimation == null)
                {
                    scrollAnimation = new Animation();
                    scrollAnimation.Finished += ScrollAnimationFinished;
                }

                float panVelocity = (ScrollingDirection == Direction.Horizontal) ? panGesture.Velocity.X : panGesture.Velocity.Y;

                if (SnapToPage)
                {
                    PageSnap(panVelocity);
                }
                else
                {
                    if (panVelocity == 0)
                    {
                        float currentScrollPosition = (ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
                        scrollAnimation.DefaultAlphaFunction = new AlphaFunction(AlphaFunction.BuiltinFunctions.Linear);
                        scrollAnimation.Duration = 0;
                        scrollAnimation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", currentScrollPosition);
                        scrollAnimation.Play();
                    }
                    else
                    {
                        Decelerating(panVelocity, scrollAnimation);
                    }
                }

                totalDisplacementForPan = 0;
                scrolling = true;
                readyToNotice = true;
                OnScrollAnimationStarted();
            }
        }

        internal void BaseRemove(View view)
        {
            base.Remove(view);
        }

        internal override bool OnAccessibilityPan(PanGesture gestures)
        {
            if (SnapToPage && scrollAnimation != null && scrollAnimation.State == Animation.States.Playing)
            {
                return false;
            }

            OnPanGesture(gestures);
            return true;
        }

        private float CustomScrollAlphaFunction(float progress)
        {
            if (panAnimationDelta == 0)
            {
                return 1.0f;
            }
            else
            {
                // Parameter "progress" is normalized value. We need to multiply target duration to calculate distance.
                // Can get real distance using equation of deceleration (check Decelerating function)
                // After get real distance, normalize it
                float realDuration = progress * panAnimationDuration;
                float realDistance = velocityOfLastPan * ((float)Math.Pow(decelerationRate, realDuration) - 1) / logValueOfDeceleration;
                float result = Math.Min(realDistance / Math.Abs(panAnimationDelta), 1.0f);
                return result;
            }
        }

        /// <summary>
        /// you can override it to custom your decelerating
        /// </summary>
        /// <param name="velocity">Velocity of current pan.</param>
        /// <param name="animation">Scroll animation.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual void Decelerating(float velocity, Animation animation)
        {
            // Decelerating using deceleration equation ===========
            //
            // V   : velocity (pixel per milisecond)
            // V0  : initial velocity
            // d   : deceleration rate,
            // t   : time
            // X   : final position after decelerating
            // log : natural logarithm
            //
            // V(t) = V0 * d pow t;
            // X(t) = V0 * (d pow t - 1) / log d;  <-- Integrate the velocity function
            // X(∞) = V0 * d / (1 - d); <-- Result using inifit T can be final position because T is tending to infinity.
            //
            // Because of final T is tending to inifity, we should use threshold value to finish.
            // Final T = log(-threshold * log d / |V0| ) / log d;

            velocityOfLastPan = Math.Abs(velocity);

            float currentScrollPosition = -(ScrollingDirection == Direction.Horizontal ? ContentContainer.CurrentPosition.X : ContentContainer.CurrentPosition.Y);
            panAnimationDelta = (velocityOfLastPan * decelerationRate) / (1 - decelerationRate);
            panAnimationDelta = velocity > 0 ? -panAnimationDelta : panAnimationDelta;

            float destination = -(panAnimationDelta + currentScrollPosition);
            float adjustDestination = AdjustTargetPositionOfScrollAnimation(destination);
            float maxPosition = ScrollAvailableArea != null ? ScrollAvailableArea.Y : maxScrollDistance;
            float minPosition = ScrollAvailableArea != null ? ScrollAvailableArea.X : 0;

            if (destination < -maxPosition || destination > minPosition)
            {
                panAnimationDelta = velocity > 0 ? (currentScrollPosition - minPosition) : (maxPosition - currentScrollPosition);
                destination = velocity > 0 ? minPosition : -maxPosition;

                if (panAnimationDelta == 0)
                {
                    panAnimationDuration = 0.0f;
                }
                else
                {
                    panAnimationDuration = (float)Math.Log((panAnimationDelta * logValueOfDeceleration / velocityOfLastPan + 1), decelerationRate);
                }

                Debug.WriteLineIf(LayoutDebugScrollableBase, "\n" +
                    "OverRange======================= \n" +
                    "[decelerationRate] " + decelerationRate + "\n" +
                    "[logValueOfDeceleration] " + logValueOfDeceleration + "\n" +
                    "[Velocity] " + velocityOfLastPan + "\n" +
                    "[CurrentPosition] " + currentScrollPosition + "\n" +
                    "[CandidateDelta] " + panAnimationDelta + "\n" +
                    "[Destination] " + destination + "\n" +
                    "[Duration] " + panAnimationDuration + "\n" +
                    "================================ \n"
                );
            }
            else
            {
                panAnimationDuration = (float)Math.Log(-DecelerationThreshold * logValueOfDeceleration / velocityOfLastPan) / logValueOfDeceleration;

                if (adjustDestination != destination)
                {
                    destination = adjustDestination;
                    panAnimationDelta = destination + currentScrollPosition;
                    velocityOfLastPan = Math.Abs(panAnimationDelta * logValueOfDeceleration / ((float)Math.Pow(decelerationRate, panAnimationDuration) - 1));
                    panAnimationDuration = (float)Math.Log(-DecelerationThreshold * logValueOfDeceleration / velocityOfLastPan) / logValueOfDeceleration;
                }

                Debug.WriteLineIf(LayoutDebugScrollableBase, "\n" +
                    "================================ \n" +
                    "[decelerationRate] " + decelerationRate + "\n" +
                    "[logValueOfDeceleration] " + logValueOfDeceleration + "\n" +
                    "[Velocity] " + velocityOfLastPan + "\n" +
                    "[CurrentPosition] " + currentScrollPosition + "\n" +
                    "[CandidateDelta] " + panAnimationDelta + "\n" +
                    "[Destination] " + destination + "\n" +
                    "[Duration] " + panAnimationDuration + "\n" +
                    "================================ \n"
                );
            }

            finalTargetPosition = destination;

            customScrollAlphaFunction = new UserAlphaFunctionDelegate(CustomScrollAlphaFunction);
            animation.DefaultAlphaFunction = new AlphaFunction(customScrollAlphaFunction);
            GC.KeepAlive(customScrollAlphaFunction);
            animation.Duration = (int)panAnimationDuration;
            animation.AnimateTo(ContentContainer, (ScrollingDirection == Direction.Horizontal) ? "PositionX" : "PositionY", destination);
            animation.Play();
        }

        private void ScrollAnimationFinished(object sender, EventArgs e)
        {
            OnScrollAnimationEnded();
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// Override this function when developer wants to change destination of flicking.(e.g. always snap to center of item)
        /// </summary>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        protected virtual float AdjustTargetPositionOfScrollAnimation(float position)
        {
            return position;
        }

        /// <summary>
        /// Scroll position given to ScrollTo.
        /// This is the position in the opposite direction to the position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position ScrollPosition
        {
            get
            {
                return new Position(-ContentContainer.Position);
            }
        }

        /// <summary>
        /// Current scroll position in the middle of ScrollTo animation.
        /// This is the position in the opposite direction to the current position of ContentContainer.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        public Position ScrollCurrentPosition
        {
            get
            {
                return new Position(-ContentContainer.CurrentPosition);
            }
        }

        /// <summary>
        /// Remove all children in ContentContainer.
        /// </summary>
        /// <param name="dispose">If true, removed child is disposed.</param>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public void RemoveAllChildren(bool dispose = false)
        {
            RecursiveRemoveChildren(ContentContainer, dispose);
        }

        private void RecursiveRemoveChildren(View parent, bool dispose)
        {
            if (parent == null)
            {
                return;
            }
            int maxChild = (int)parent.GetChildCount();
            for (int i = maxChild - 1; i >= 0; --i)
            {
                View child = parent.GetChildAt((uint)i);
                if (child == null)
                {
                    continue;
                }
                RecursiveRemoveChildren(child, dispose);
                parent.Remove(child);
                if (dispose)
                {
                    child.Dispose();
                }
            }
        }

    }

} // namespace

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/ScrollableBase.cs(17,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/ScrollableBase.cs(208,50): error CS0128: A local variable or function named 'scrollableBase' is already defined in this scope,/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/ScrollableBase.cs(210,21): error CS0165: Use of unassigned local variable 'scrollableBase',/home/vsts/work/1/s/src/Tizen.NUI.Components/Controls/ScrollableBase.cs(17,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Tizen.NUI.Components;
using System.Collections.Generic;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a fish eye layout
    /// </summary>
    internal class FishEyeLayoutManager : RecycleLayoutManager
    {
        public int CurrentFocusedIndex { get; set; } = 0;
        public int FocusedIndex { get; set; } = 0;
        public FishEyeLayoutManager()
        {
        }

        private float FindCandidatePosition(float startPosition, float scrollPosition, bool isBack)
        {
            // There are two ellipses which return how much scale needed.
            // We can find candidate position by intersection of ellipse and line.
            // Item size is always determined before calculation, so can get angle of it by height/width when orientation is vertical.
            // Y intercept is on previous item.

            double center = Math.Abs(scrollPosition);
            double result = isBack ? center + 180.0f : center - 180.0f;

            // double newFactor = Math.Pow(180,2) / CalculateXFactor(0);
            double angle = ItemSize.Height / ItemSize.Width;
            double intercept = (startPosition - center);
            double constant = Math.Sqrt(Math.Pow((180 * 333), 2) / (Math.Pow(333, 2) - Math.Pow(153, 2)));

            double semiMajorAxis = 333.0;
            double centerOfEllipse = -153.0;
            double centerOfEllipse2 = 153.0;

            // Find intersection using qurdratic formula.
            // We have two different equations because there are two different ellipse.
            double a = Math.Pow(semiMajorAxis, 2) + Math.Pow(angle * constant, 2);
            double b = -(intercept * Math.Pow(semiMajorAxis, 2) + centerOfEllipse * Math.Pow(angle * constant, 2));
            double c = Math.Pow(intercept * semiMajorAxis, 2) + Math.Pow(angle * constant * centerOfEllipse, 2) - Math.Pow(angle * constant * semiMajorAxis, 2);
            double b2 = -(intercept * Math.Pow(semiMajorAxis, 2) + centerOfEllipse2 * Math.Pow(angle * constant, 2));
            double c2 = Math.Pow(intercept * semiMajorAxis, 2) + Math.Pow(angle * constant * centerOfEllipse2, 2) - Math.Pow(angle * constant * semiMajorAxis, 2);

            double result1 = (-b + Math.Sqrt((Math.Pow(b, 2) - a * c))) / a;
            double result2 = (-b - Math.Sqrt((Math.Pow(b, 2) - a * c))) / a;
            double result3 = (-b2 + Math.Sqrt((Math.Pow(b2, 2) - a * c2))) / a;
            double result4 = (-b2 - Math.Sqrt((Math.Pow(b2, 2) - a * c2))) / a;

            result = isBack ? result1 : result4;
            return (float)(center + result);
        }


        public override float CalculateLayoutOrientationSize()
        {
            return StepSize * (DataCount-1);
        }

        public override void Layout(float scrollPosition)
        {
            RecycleItem centerItem = Container.Children[FocusedIndex] as RecycleItem;
            if (centerItem == null)
            {
                return;
            }

            float centerItemPosition = LayoutOrientation == Orientation.Horizontal ? centerItem.Position.X : centerItem.Position.Y;

            Vector2 stepRange = new Vector2(-scrollPosition - StepSize + 1.0f, -scrollPosition + StepSize - 1.0f);
            Vector2 visibleRange = new Vector2(Math.Abs(scrollPosition) - 180, Math.Abs(scrollPosition) + 180);

            if (StepSize != 0 && centerItemPosition <= stepRange.X)
            {
                FocusedIndex = Math.Min(Container.Children.Count - 1, FocusedIndex + 1);
                centerItem = Container.Children[FocusedIndex] as RecycleItem;
                if (centerItem != null)
                {
                    centerItem.Position = new Position(0.0f, Math.Abs(StepSize * (centerItem.DataIndex)));
                    centerItem.Scale = new Vector3(1.0f, 1.0f, 1.0f);
                }
            }
            else if (StepSize != 0 && centerItemPosition >= stepRange.Y)
            {
                FocusedIndex = Math.Max(0, FocusedIndex - 1);
                centerItem = Container.Children[FocusedIndex] as RecycleItem;
                if (centerItem != null)
                {
                    centerItem.Position = new Position(0.0f, Math.Abs(StepSize * (centerItem.DataIndex)));
                    centerItem.Scale = new Vector3(1.0f, 1.0f, 1.0f);
                }
            }
            else
            {
                float centerItemScale = CalculateScaleFactor(centerItemPosition, scrollPosition);
                centerItem.Scale = new Vector3(centerItemScale, centerItemScale, 1.0f);
            }

            RecycleItem prevItem = centerItem;
            if (prevItem == null)
            {
                return;
            }

            // Front of center item
            for (int i = FocusedIndex - 1; i > -1; i--)
            {
                RecycleItem target = Container.Children[i] as RecycleItem;
                if (target == null)
                {
                    continue;
                }

                float prevItemPosition = LayoutOrientation == Orientation.Horizontal ? prevItem.Position.X : prevItem.Position.Y;
                float prevItemSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.Size.Width : prevItem.Size.Height);
                float prevItemCurrentSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.GetCurrentSizeFloat().Width : prevItem.GetCurrentSizeFloat().Height);
                prevItemSize = prevItemCurrentSize == 0 ? prevItemSize : prevItemCurrentSize;
                prevItemSize = prevItemSize * prevItem.Scale.X;

                float startPosition = prevItemPosition - prevItemSize / 2.0f;

                if (startPosition > visibleRange.X)
                {
                    float candidatePosition = visibleRange.X;
                    candidatePosition = FindCandidatePosition(startPosition, scrollPosition, false);
                    target.Position = LayoutOrientation == Orientation.Horizontal ?
                                new Position(candidatePosition, target.Position.Y) :
                                new Position(target.Position.X, candidatePosition);

                    float scaleFactor = CalculateScaleFactor(candidatePosition, scrollPosition);
                    target.Scale = new Vector3(scaleFactor, scaleFactor, 1.0f);

                    prevItem = target;
                }
                else
                {
                    target.Scale = new Vector3(0.0f, 0.0f, 1.0f);
                }
            }

            prevItem = centerItem;

            // Back of center item
            for (int i = FocusedIndex + 1; i < Container.Children.Count; i++)
            {
                RecycleItem target = Container.Children[i] as RecycleItem;
                if (target == null)
                {
                    continue;
                }

                float prevItemPosition = LayoutOrientation == Orientation.Horizontal ? prevItem.Position.X : prevItem.Position.Y;
                float prevItemSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.Size.Width : prevItem.Size.Height);
                float prevItemCurrentSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.GetCurrentSizeFloat().Width : prevItem.GetCurrentSizeFloat().Height);
                prevItemSize = prevItemCurrentSize == 0 ? prevItemSize : prevItemCurrentSize;
                prevItemSize = prevItemSize * prevItem.Scale.X;

                float startPosition = prevItemPosition + prevItemSize / 2.0f;

                if (startPosition < visibleRange.Y)
                {
                    float candidatePosition = visibleRange.Y;
                    candidatePosition = FindCandidatePosition(startPosition, scrollPosition, true);
                    target.Position = LayoutOrientation == Orientation.Horizontal ?
                                new Position(candidatePosition, target.Position.Y) :
                                new Position(target.Position.X, candidatePosition);

                    float scaleFactor = CalculateScaleFactor(candidatePosition, scrollPosition);
                    target.Scale = new Vector3(scaleFactor, scaleFactor, 1.0f);

                    prevItem = target;
                }
                else
                {
                    target.Scale = new Vector3(0.0f, 0.0f, 1.0f);
                }
            }

            if (StepSize == 0)
            {
                if (LayoutOrientation == Orientation.Horizontal)
                {
                    StepSize = Container.Children[0].Size.Width / 2.0f + Container.Children[1].Size.Width * Container.Children[1].Scale.X / 2.0f;
                }
                else
                {
                    StepSize = Container.Children[0].Size.Height / 2.0f + Container.Children[1].Size.Height * Container.Children[1].Scale.X / 2.0f;
                }

                StepSize = float.IsNaN(StepSize)?0:StepSize;
            }
        }

        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();

            bool isBack = scrollPosition - PrevScrollPosition < 0;

            int previousFocusIndex = FocusedIndex;

            if (!isBack && FocusedIndex < 6)
            {
                RecycleItem target = Container.Children[Container.Children.Count - 1] as RecycleItem;
                if (target != null)
                {
                    int previousSiblingOrder = target.SiblingOrder;
                    target.SiblingOrder = 0;
                    target.DataIndex = target.DataIndex - Container.Children.Count;
                    target.Position = new Position(0, Math.Abs(scrollPosition) - 360);
                    target.Scale = new Vector3(0, 0, 0);

                    result.Add(target);

                    FocusedIndex++;
                }
            }
            else if (isBack && FocusedIndex > 8)
            {
                RecycleItem target = Container.Children[0] as RecycleItem;
                if (target != null)
                {
                    int previousSiblingOrder = target.SiblingOrder;
                    target.SiblingOrder = Container.Children.Count - 1;
                    target.DataIndex = target.DataIndex + Container.Children.Count;
                    target.Position = new Position(0, Math.Abs(scrollPosition) + 360);
                    target.Scale = new Vector3(0, 0, 0);

                    result.Add(target);

                    FocusedIndex--;
                }
            }

            PrevScrollPosition = scrollPosition;

            return result;
        }

        private double CalculateXFactor(double y)
        {
            double factor1 = Math.Pow(180, 2);
            double factor2 = Math.Pow(333, 2);
            double factor3 = Math.Pow((y + 153), 2);

            return Math.Sqrt(factor1 - (factor1 / factor2 * factor3));
        }

        private float CalculateScaleFactor(float position, float scrollPosition)
        {
            float origin = Math.Abs(scrollPosition);
            float diff = position - origin;

            diff = Math.Max(diff, -180);
            diff = Math.Min(diff, 180);
            diff = Math.Abs(diff);

            float result = (float)(CalculateXFactor(diff) / CalculateXFactor(0));
            return result;
        }

        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            int value = (int)(Math.Abs(scrollPosition) / StepSize);
            float remain = Math.Abs(scrollPosition) % StepSize;

            int newValue = remain > StepSize / 2.0f ? value + 1 : value;

            CurrentFocusedIndex = newValue;
            return -newValue * StepSize;
        }
    }
}

---- Transformed Tree ----
using System;
using Tizen.NUI.Components;
using System.Collections.Generic;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a fish eye layout
    /// </summary>
    internal class FishEyeLayoutManager : RecycleLayoutManager
    {
        public int CurrentFocusedIndex { get; set; } = 0;
        public int FocusedIndex { get; set; } = 0;
        public FishEyeLayoutManager()
        {
        }

        private float FindCandidatePosition(float startPosition, float scrollPosition, bool isBack)
        {
            // There are two ellipses which return how much scale needed.
            // We can find candidate position by intersection of ellipse and line.
            // Item size is always determined before calculation, so can get angle of it by height/width when orientation is vertical.
            // Y intercept is on previous item.

            double center = Math.Abs(scrollPosition);
            double result = isBack ? center + 180.0f : center - 180.0f;

            // double newFactor = Math.Pow(180,2) / CalculateXFactor(0);
            double angle = ItemSize.Height / ItemSize.Width;
            double intercept = (startPosition - center);
            double constant = Math.Sqrt(Math.Pow((180 * 333), 2) / (Math.Pow(333, 2) - Math.Pow(153, 2)));

            double semiMajorAxis = 333.0;
            double centerOfEllipse = -153.0;
            double centerOfEllipse2 = 153.0;

            // Find intersection using qurdratic formula.
            // We have two different equations because there are two different ellipse.
            double a = Math.Pow(semiMajorAxis, 2) + Math.Pow(angle * constant, 2);
            double b = -(intercept * Math.Pow(semiMajorAxis, 2) + centerOfEllipse * Math.Pow(angle * constant, 2));
            double c = Math.Pow(intercept * semiMajorAxis, 2) + Math.Pow(angle * constant * centerOfEllipse, 2) - Math.Pow(angle * constant * semiMajorAxis, 2);
            double b2 = -(intercept * Math.Pow(semiMajorAxis, 2) + centerOfEllipse2 * Math.Pow(angle * constant, 2));
            double c2 = Math.Pow(intercept * semiMajorAxis, 2) + Math.Pow(angle * constant * centerOfEllipse2, 2) - Math.Pow(angle * constant * semiMajorAxis, 2);

            double result1 = (-b + Math.Sqrt((Math.Pow(b, 2) - a * c))) / a;
            double result2 = (-b - Math.Sqrt((Math.Pow(b, 2) - a * c))) / a;
            double result3 = (-b2 + Math.Sqrt((Math.Pow(b2, 2) - a * c2))) / a;
            double result4 = (-b2 - Math.Sqrt((Math.Pow(b2, 2) - a * c2))) / a;

            result = isBack ? result1 : result4;
            return (float)(center + result);
        }


        public override float CalculateLayoutOrientationSize()
        {
            return StepSize * (DataCount-1);
        }

        public override void Layout(float scrollPosition)
        {
            if (centerItem == null)
            {
                return;
            }

            float centerItemPosition = LayoutOrientation == Orientation.Horizontal ? centerItem.Position.X : centerItem.Position.Y;

            Vector2 stepRange = new Vector2(-scrollPosition - StepSize + 1.0f, -scrollPosition + StepSize - 1.0f);
            Vector2 visibleRange = new Vector2(Math.Abs(scrollPosition) - 180, Math.Abs(scrollPosition) + 180);

            if (StepSize != 0 && centerItemPosition <= stepRange.X)
            {
                FocusedIndex = Math.Min(Container.Children.Count - 1, FocusedIndex + 1);
                centerItem = Container.Children[FocusedIndex] as RecycleItem;

                if (Container.Children[FocusedIndex] is RecycleItem centerItem)
                {
                    centerItem.Position = new Position(0.0f, Math.Abs(StepSize * (centerItem.DataIndex)));
                    centerItem.Scale = new Vector3(1.0f, 1.0f, 1.0f);
                }
            }
            else if (StepSize != 0 && centerItemPosition >= stepRange.Y)
            {
                FocusedIndex = Math.Max(0, FocusedIndex - 1);
                centerItem = Container.Children[FocusedIndex] as RecycleItem;

                if (Container.Children[FocusedIndex] is RecycleItem centerItem)
                {
                    centerItem.Position = new Position(0.0f, Math.Abs(StepSize * (centerItem.DataIndex)));
                    centerItem.Scale = new Vector3(1.0f, 1.0f, 1.0f);
                }
            }
            else
            {
                float centerItemScale = CalculateScaleFactor(centerItemPosition, scrollPosition);
                centerItem.Scale = new Vector3(centerItemScale, centerItemScale, 1.0f);
            }

            RecycleItem prevItem = centerItem;
            if (prevItem == null)
            {
                return;
            }

            // Front of center item
            for (int i = FocusedIndex - 1; i > -1; i--)
            {
                RecycleItem target = Container.Children[i] as RecycleItem;
                if (target == null)
                {
                    continue;
                }

                float prevItemPosition = LayoutOrientation == Orientation.Horizontal ? prevItem.Position.X : prevItem.Position.Y;
                float prevItemSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.Size.Width : prevItem.Size.Height);
                float prevItemCurrentSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.GetCurrentSizeFloat().Width : prevItem.GetCurrentSizeFloat().Height);
                prevItemSize = prevItemCurrentSize == 0 ? prevItemSize : prevItemCurrentSize;
                prevItemSize = prevItemSize * prevItem.Scale.X;

                float startPosition = prevItemPosition - prevItemSize / 2.0f;

                if (startPosition > visibleRange.X)
                {
                    float candidatePosition = visibleRange.X;
                    candidatePosition = FindCandidatePosition(startPosition, scrollPosition, false);
                    target.Position = LayoutOrientation == Orientation.Horizontal ?
                                new Position(candidatePosition, target.Position.Y) :
                                new Position(target.Position.X, candidatePosition);

                    float scaleFactor = CalculateScaleFactor(candidatePosition, scrollPosition);
                    target.Scale = new Vector3(scaleFactor, scaleFactor, 1.0f);

                    prevItem = target;
                }
                else
                {
                    target.Scale = new Vector3(0.0f, 0.0f, 1.0f);
                }
            }

            prevItem = centerItem;

            // Back of center item
            for (int i = FocusedIndex + 1; i < Container.Children.Count; i++)
            {
                RecycleItem target = Container.Children[i] as RecycleItem;
                if (target == null)
                {
                    continue;
                }

                float prevItemPosition = LayoutOrientation == Orientation.Horizontal ? prevItem.Position.X : prevItem.Position.Y;
                float prevItemSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.Size.Width : prevItem.Size.Height);
                float prevItemCurrentSize = (LayoutOrientation == Orientation.Horizontal ? prevItem.GetCurrentSizeFloat().Width : prevItem.GetCurrentSizeFloat().Height);
                prevItemSize = prevItemCurrentSize == 0 ? prevItemSize : prevItemCurrentSize;
                prevItemSize = prevItemSize * prevItem.Scale.X;

                float startPosition = prevItemPosition + prevItemSize / 2.0f;

                if (startPosition < visibleRange.Y)
                {
                    float candidatePosition = visibleRange.Y;
                    candidatePosition = FindCandidatePosition(startPosition, scrollPosition, true);
                    target.Position = LayoutOrientation == Orientation.Horizontal ?
                                new Position(candidatePosition, target.Position.Y) :
                                new Position(target.Position.X, candidatePosition);

                    float scaleFactor = CalculateScaleFactor(candidatePosition, scrollPosition);
                    target.Scale = new Vector3(scaleFactor, scaleFactor, 1.0f);

                    prevItem = target;
                }
                else
                {
                    target.Scale = new Vector3(0.0f, 0.0f, 1.0f);
                }
            }

            if (StepSize == 0)
            {
                if (LayoutOrientation == Orientation.Horizontal)
                {
                    StepSize = Container.Children[0].Size.Width / 2.0f + Container.Children[1].Size.Width * Container.Children[1].Scale.X / 2.0f;
                }
                else
                {
                    StepSize = Container.Children[0].Size.Height / 2.0f + Container.Children[1].Size.Height * Container.Children[1].Scale.X / 2.0f;
                }

                StepSize = float.IsNaN(StepSize)?0:StepSize;
            }
        }

        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();

            bool isBack = scrollPosition - PrevScrollPosition < 0;

            int previousFocusIndex = FocusedIndex;

            if (!isBack && FocusedIndex < 6)
            {
                if (Container.Children[Container.Children.Count - 1] is RecycleItem target)
                {
                    int previousSiblingOrder = target.SiblingOrder;
                    target.SiblingOrder = 0;
                    target.DataIndex = target.DataIndex - Container.Children.Count;
                    target.Position = new Position(0, Math.Abs(scrollPosition) - 360);
                    target.Scale = new Vector3(0, 0, 0);

                    result.Add(target);

                    FocusedIndex++;
                }
            }
            else if (isBack && FocusedIndex > 8)
            {
                if (Container.Children[Container.Children.Count - 1] is RecycleItem target)
                {
                    int previousSiblingOrder = target.SiblingOrder;
                    target.SiblingOrder = Container.Children.Count - 1;
                    target.DataIndex = target.DataIndex + Container.Children.Count;
                    target.Position = new Position(0, Math.Abs(scrollPosition) + 360);
                    target.Scale = new Vector3(0, 0, 0);

                    result.Add(target);

                    FocusedIndex--;
                }
            }

            PrevScrollPosition = scrollPosition;

            return result;
        }

        private double CalculateXFactor(double y)
        {
            double factor1 = Math.Pow(180, 2);
            double factor2 = Math.Pow(333, 2);
            double factor3 = Math.Pow((y + 153), 2);

            return Math.Sqrt(factor1 - (factor1 / factor2 * factor3));
        }

        private float CalculateScaleFactor(float position, float scrollPosition)
        {
            float origin = Math.Abs(scrollPosition);
            float diff = position - origin;

            diff = Math.Max(diff, -180);
            diff = Math.Min(diff, 180);
            diff = Math.Abs(diff);

            float result = (float)(CalculateXFactor(diff) / CalculateXFactor(0));
            return result;
        }

        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            int value = (int)(Math.Abs(scrollPosition) / StepSize);
            float remain = Math.Abs(scrollPosition) % StepSize;

            int newValue = remain > StepSize / 2.0f ? value + 1 : value;

            CurrentFocusedIndex = newValue;
            return -newValue * StepSize;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(17,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(77,17): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(82,86): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(82,110): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(90,17): error CS0841: Cannot use local variable 'centerItem' before it is declared,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(101,17): error CS0841: Cannot use local variable 'centerItem' before it is declared,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(112,17): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(115,36): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(157,24): error CS0103: The name 'centerItem' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/internal/FishEyeLayoutManager.cs(17,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Components;
using System.Collections.Generic;
using System.ComponentModel;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a grid box layout.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class GridRecycleLayoutManager : RecycleLayoutManager
    {
        private int rows = 1;

        /// <summary>
        /// [draft ]Get/Set the number of rows in the grid
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        // This will be public opened after ACR done. (Before ACR, need to be hidden as Inhouse API)
        [EditorBrowsable(EditorBrowsableState.Never)]
        public int Rows
        {
            get
            {
                return rows;
            }
            set
            {
                rows = value;

                if (Container != null)
                {
                    Layout(PrevScrollPosition);
                }
            }
        }

        private int columns = 1;


        /// <summary>
        /// [Draft] Get/Set the number of columns in the grid
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        // This will be public opened after ACR done. (Before ACR, need to be hidden as Inhouse API)
        [EditorBrowsable(EditorBrowsableState.Never)]
        public int Columns
        {
            get
            {
                return columns;
            }
            set
            {
                columns = value;

                if (Container != null)
                {
                    Layout(PrevScrollPosition);
                }
            }
        }

        private int firstVisibleItemIndex = -1;
        private int lastVisibleItemIndex = -1;

        private bool IsItemVisible(float scrollPosition, RecycleItem item)
        {
            bool result = false;
            View list = Container.GetParent() as View;
            if (list == null)
            {
                return result;
            }
            Vector2 visibleArea = new Vector2(Math.Abs(scrollPosition),
                Math.Abs(scrollPosition) + (LayoutOrientation == Orientation.Vertical ?
                                                list.Size.Width : list.Size.Height)
            );

            float firstCheckPoint = LayoutOrientation == Orientation.Vertical ? item.Position.X : item.Position.Y;
            float secondCheckPoint = LayoutOrientation == Orientation.Vertical ?
                                        firstCheckPoint + item.Size.Width :
                                        firstCheckPoint + item.Size.Height;

            result = (firstCheckPoint >= visibleArea.X && firstCheckPoint <= visibleArea.Y) || (secondCheckPoint >= visibleArea.X && secondCheckPoint <= visibleArea.Y);

            return result;
        }

        /// <summary>
        /// This is called to find out how much container size can be.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override float CalculateLayoutOrientationSize()
        {
            float orientationFactor = LayoutOrientation == Orientation.Vertical ? Rows : Columns;
            return StepSize * (int)Math.Ceiling((double)DataCount / (double)orientationFactor);
        }


        /// <summary>
        /// This is called to find out where items are lain out according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override void Layout(float scrollPosition)
        {
            int itemInGroup = LayoutOrientation == Orientation.Vertical ? Rows : Columns;
            firstVisibleItemIndex = -1;
            lastVisibleItemIndex = -1;

            RecycleItem previousItem = null;

            for (int i = 0; i < Container.Children.Count; i++)
            {
                RecycleItem item = Container.Children[i] as RecycleItem;

                if (previousItem != null && item != null)
                {
                    item.Position = LayoutOrientation == Orientation.Vertical ?
                        new Position(
                            (i % itemInGroup == 0 ?
                            previousItem.Position.X + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width) :
                            previousItem.Position.X),
                            (i % itemInGroup == 0 ?
                            0 :
                            previousItem.PositionY + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height))
                        ) :
                        new Position(
                            (i % itemInGroup == 0 ?
                            0 :
                            previousItem.PositionX + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width)),
                            (i % itemInGroup == 0 ?
                            previousItem.Position.Y + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height) :
                            previousItem.Position.Y)
                        );
                }

                bool isVisible = IsItemVisible(scrollPosition, item);

                if (isVisible)
                {
                    firstVisibleItemIndex = firstVisibleItemIndex == -1 ? i : firstVisibleItemIndex;
                    lastVisibleItemIndex = i;
                }

                previousItem = item;
            }

            if (StepSize == 0)
            {
                StepSize = LayoutOrientation == Orientation.Vertical ? ItemSize.Width : ItemSize.Height;
            }
        }


        /// <summary>
        /// This is called to find out which items should be recycled according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <returns>List of RecycleItems which should be recycled.</returns>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();
            bool checkFront = (PrevScrollPosition - scrollPosition) > 0;

            int itemInGroup = LayoutOrientation == Orientation.Vertical ? Rows : Columns;

            if (checkFront)
            {
                int currentGroupNum = (int)(firstVisibleItemIndex / itemInGroup) + 1;

                if (currentGroupNum > 2)
                {
                    // Too many item is in front!!! move first item to back!!!!
                    for (int i = 0; i < itemInGroup; i++)
                    {
                        RecycleItem target = Container.Children[0] as RecycleItem;
                        if (target != null)
                        {
                            target.DataIndex = target.DataIndex + Container.Children.Count;
                            target.SiblingOrder = Container.Children.Count - 1;

                            result.Add(target);
                        }
                    }
                }
            }
            else
            {
                int currentGroupNum = (int)(lastVisibleItemIndex / itemInGroup) + 1;

                if (currentGroupNum < (int)(Container.Children.Count / itemInGroup) - 3)
                {
                    for (int i = 0; i < itemInGroup; i++)
                    {
                        RecycleItem prevFirstItem = Container.Children[itemInGroup] as RecycleItem;
                        RecycleItem target = Container.Children[Container.Children.Count - 1] as RecycleItem;
                        if (prevFirstItem != null && target != null)
                        {
                            target.Position = new Position(
                                LayoutOrientation == Orientation.Vertical ? (prevFirstItem.Position.X - target.Size.Width) : prevFirstItem.Position.X,
                                LayoutOrientation == Orientation.Vertical ? prevFirstItem.Position.Y : (prevFirstItem.Position.Y - target.Size.Height)
                            );
                            target.DataIndex = target.DataIndex - Container.Children.Count;
                            target.SiblingOrder = 0;

                            result.Add(target);
                        }
                    }
                }
            }


            PrevScrollPosition = scrollPosition;

            return result;
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            return scrollPosition;
        }

        public override View RequestNextFocusableView(View currentFocusedView, View.FocusDirection direction, bool loopEnabled)
        {
            View nextFocusedView = null;
            int targetSibling = -1;
            bool isHorizontal = LayoutOrientation == Orientation.Horizontal;

            switch (direction)
            {
                case View.FocusDirection.Left:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - 1 : currentFocusedView.SiblingOrder - Rows;
                        break;
                    }
                case View.FocusDirection.Right:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + 1 : currentFocusedView.SiblingOrder + Rows;
                        break;
                    }
                case View.FocusDirection.Up:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - Columns : currentFocusedView.SiblingOrder - 1;
                        break;
                    }
                case View.FocusDirection.Down:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + Columns : currentFocusedView.SiblingOrder + 1;
                        break;
                    }
            }

            if (targetSibling > -1 && targetSibling < Container.Children.Count)
            {
                RecycleItem candidate = Container.Children[targetSibling] as RecycleItem;
                if (candidate != null && candidate.DataIndex >= 0 && candidate.DataIndex < DataCount)
                {
                    nextFocusedView = candidate;
                }
            }

            return nextFocusedView;
        }
    }
}

---- Transformed Tree ----
using System;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Components;
using System.Collections.Generic;
using System.ComponentModel;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a grid box layout.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class GridRecycleLayoutManager : RecycleLayoutManager
    {
        private int rows = 1;

        /// <summary>
        /// [draft ]Get/Set the number of rows in the grid
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        // This will be public opened after ACR done. (Before ACR, need to be hidden as Inhouse API)
        [EditorBrowsable(EditorBrowsableState.Never)]
        public int Rows
        {
            get
            {
                return rows;
            }
            set
            {
                rows = value;

                if (Container != null)
                {
                    Layout(PrevScrollPosition);
                }
            }
        }

        private int columns = 1;


        /// <summary>
        /// [Draft] Get/Set the number of columns in the grid
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        // This will be public opened after ACR done. (Before ACR, need to be hidden as Inhouse API)
        [EditorBrowsable(EditorBrowsableState.Never)]
        public int Columns
        {
            get
            {
                return columns;
            }
            set
            {
                columns = value;

                if (Container != null)
                {
                    Layout(PrevScrollPosition);
                }
            }
        }

        private int firstVisibleItemIndex = -1;
        private int lastVisibleItemIndex = -1;

        private bool IsItemVisible(float scrollPosition, RecycleItem item)
        {
            bool result = false;
            View list = Container.GetParent() as View;
            if (list == null)
            {
                return result;
            }
            Vector2 visibleArea = new Vector2(Math.Abs(scrollPosition),
                Math.Abs(scrollPosition) + (LayoutOrientation == Orientation.Vertical ?
                                                list.Size.Width : list.Size.Height)
            );

            float firstCheckPoint = LayoutOrientation == Orientation.Vertical ? item.Position.X : item.Position.Y;
            float secondCheckPoint = LayoutOrientation == Orientation.Vertical ?
                                        firstCheckPoint + item.Size.Width :
                                        firstCheckPoint + item.Size.Height;

            result = (firstCheckPoint >= visibleArea.X && firstCheckPoint <= visibleArea.Y) || (secondCheckPoint >= visibleArea.X && secondCheckPoint <= visibleArea.Y);

            return result;
        }

        /// <summary>
        /// This is called to find out how much container size can be.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override float CalculateLayoutOrientationSize()
        {
            float orientationFactor = LayoutOrientation == Orientation.Vertical ? Rows : Columns;
            return StepSize * (int)Math.Ceiling((double)DataCount / (double)orientationFactor);
        }


        /// <summary>
        /// This is called to find out where items are lain out according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override void Layout(float scrollPosition)
        {
            int itemInGroup = LayoutOrientation == Orientation.Vertical ? Rows : Columns;
            firstVisibleItemIndex = -1;
            lastVisibleItemIndex = -1;

            RecycleItem previousItem = null;

            for (int i = 0; i < Container.Children.Count; i++)
            {
                if (previousItem != null && Container.Children[i] is RecycleItem item)
                {
                    item.Position = LayoutOrientation == Orientation.Vertical ?
                        new Position(
                            (i % itemInGroup == 0 ?
                            previousItem.Position.X + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width) :
                            previousItem.Position.X),
                            (i % itemInGroup == 0 ?
                            0 :
                            previousItem.PositionY + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height))
                        ) :
                        new Position(
                            (i % itemInGroup == 0 ?
                            0 :
                            previousItem.PositionX + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width)),
                            (i % itemInGroup == 0 ?
                            previousItem.Position.Y + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height) :
                            previousItem.Position.Y)
                        );
                }

                bool isVisible = IsItemVisible(scrollPosition, item);

                if (isVisible)
                {
                    firstVisibleItemIndex = firstVisibleItemIndex == -1 ? i : firstVisibleItemIndex;
                    lastVisibleItemIndex = i;
                }

                previousItem = item;
            }

            if (StepSize == 0)
            {
                StepSize = LayoutOrientation == Orientation.Vertical ? ItemSize.Width : ItemSize.Height;
            }
        }


        /// <summary>
        /// This is called to find out which items should be recycled according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <returns>List of RecycleItems which should be recycled.</returns>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();
            bool checkFront = (PrevScrollPosition - scrollPosition) > 0;

            int itemInGroup = LayoutOrientation == Orientation.Vertical ? Rows : Columns;

            if (checkFront)
            {
                int currentGroupNum = (int)(firstVisibleItemIndex / itemInGroup) + 1;

                if (currentGroupNum > 2)
                {
                    // Too many item is in front!!! move first item to back!!!!
                    for (int i = 0; i < itemInGroup; i++)
                    {
                        if (Container.Children[0] is RecycleItem target)
                        {
                            target.DataIndex = target.DataIndex + Container.Children.Count;
                            target.SiblingOrder = Container.Children.Count - 1;

                            result.Add(target);
                        }
                    }
                }
            }
            else
            {
                int currentGroupNum = (int)(lastVisibleItemIndex / itemInGroup) + 1;

                if (currentGroupNum < (int)(Container.Children.Count / itemInGroup) - 3)
                {
                    for (int i = 0; i < itemInGroup; i++)
                    {
                        if (Container.Children[itemInGroup] is RecycleItem prevFirstItem && Container.Children[0] is RecycleItem target)
                        {
                            target.Position = new Position(
                                LayoutOrientation == Orientation.Vertical ? (prevFirstItem.Position.X - target.Size.Width) : prevFirstItem.Position.X,
                                LayoutOrientation == Orientation.Vertical ? prevFirstItem.Position.Y : (prevFirstItem.Position.Y - target.Size.Height)
                            );
                            target.DataIndex = target.DataIndex - Container.Children.Count;
                            target.SiblingOrder = 0;

                            result.Add(target);
                        }
                    }
                }
            }


            PrevScrollPosition = scrollPosition;

            return result;
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            return scrollPosition;
        }

        public override View RequestNextFocusableView(View currentFocusedView, View.FocusDirection direction, bool loopEnabled)
        {
            View nextFocusedView = null;
            int targetSibling = -1;
            bool isHorizontal = LayoutOrientation == Orientation.Horizontal;

            switch (direction)
            {
                case View.FocusDirection.Left:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - 1 : currentFocusedView.SiblingOrder - Rows;
                        break;
                    }
                case View.FocusDirection.Right:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + 1 : currentFocusedView.SiblingOrder + Rows;
                        break;
                    }
                case View.FocusDirection.Up:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - Columns : currentFocusedView.SiblingOrder - 1;
                        break;
                    }
                case View.FocusDirection.Down:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + Columns : currentFocusedView.SiblingOrder + 1;
                        break;
                    }
            }

            if (targetSibling > -1 && targetSibling < Container.Children.Count)
            {
                if (Container.Children[targetSibling] is RecycleItem candidate && candidate.DataIndex >= 0 && candidate.DataIndex < DataCount)
                {
                    nextFocusedView = candidate;
                }
            }

            return nextFocusedView;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs(263,30): warning CS1591: Missing XML comment for publicly visible type or member 'GridRecycleLayoutManager.RequestNextFocusableView(View, View.FocusDirection, bool)',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs(167,64): error CS0165: Use of unassigned local variable 'item',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs(258,30): warning CS1591: Missing XML comment for publicly visible type or member 'GridRecycleLayoutManager.RequestNextFocusableView(View, View.FocusDirection, bool)',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/GridRecycleLayoutManager.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Components;
using System.Collections.Generic;
using System.ComponentModel;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a linear box layout.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class LinearRecycleLayoutManager : RecycleLayoutManager
    {
        private int firstVisibleItemIndex = -1;
        private int lastVisibleItemIndex = -1;

        private bool IsItemVisible(float scrollPosition, RecycleItem item)
        {
            bool result = false;
            View list = Container.GetParent() as View;
            if (list == null)
            {
                return result;
            }

            Vector2 visibleArea = new Vector2(Math.Abs(scrollPosition),
                Math.Abs(scrollPosition) + (LayoutOrientation == Orientation.Horizontal ?
                                                list.Size.Width : list.Size.Height)
            );

            float firstCheckPoint = LayoutOrientation == Orientation.Horizontal ? item.Position.X : item.Position.Y;
            float secondCheckPoint = LayoutOrientation == Orientation.Horizontal ?
                                        firstCheckPoint + item.Size.Width :
                                        firstCheckPoint + item.Size.Height;

            // Tizen.Log.Error("NUI", "[1p] "+visibleArea.X+ " =< "+firstCheckPoint+" =< "+visibleArea.Y+" ==== \n");
            // Tizen.Log.Error("NUI", "[2p] "+visibleArea.X+ " =< "+secondCheckPoint+" =< "+visibleArea.Y+" ==== \n");

            result = (firstCheckPoint >= visibleArea.X && firstCheckPoint <= visibleArea.Y) || (secondCheckPoint >= visibleArea.X && secondCheckPoint <= visibleArea.Y);

            return result;
        }

        /// <summary>
        /// This is called to find out where items are lain out according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override void Layout(float scrollPosition)
        {
            firstVisibleItemIndex = -1;
            lastVisibleItemIndex = -1;

            RecycleItem previousItem = null;

            for (int i = 0; i < Container.Children.Count; i++)
            {
                RecycleItem item = Container.Children[i] as RecycleItem;

                if (previousItem != null && item != null)
                {
                    item.Position = LayoutOrientation == Orientation.Horizontal ?
                        new Position(
                            previousItem.Position.X + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width),
                            item.PositionY
                        ) :
                        new Position(
                            item.PositionX,
                            previousItem.Position.Y + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height)
                        );
                }

                bool isVisible = IsItemVisible(scrollPosition, item);

                if (isVisible)
                {
                    firstVisibleItemIndex = firstVisibleItemIndex == -1 ? i : firstVisibleItemIndex;
                    lastVisibleItemIndex = i;
                }

                previousItem = item;

                // Tizen.Log.Error("NUI","["+item.DataIndex+"] "+item.Position.Y+" ==== \n");
            }

            if (StepSize == 0)
            {
                StepSize = LayoutOrientation == Orientation.Horizontal ? ItemSize.Width : ItemSize.Height;
            }
        }

        /// <summary>
        /// This is called to find out how much container size can be.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override float CalculateLayoutOrientationSize()
        {
            return StepSize * DataCount;
        }

        /// <summary>
        /// This is called to find out which items should be recycled according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <returns>List of RecycleItems which should be recycled.</returns>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();

            bool checkFront = (PrevScrollPosition - scrollPosition) > 0;

            if (checkFront)
            {
                if (firstVisibleItemIndex > 3)
                {
                    // Too many item is in front!!! move first item to back!!!!
                    RecycleItem target = Container.Children[0] as RecycleItem;
                    if (target != null)
                    {
                        target.DataIndex = target.DataIndex + Container.Children.Count;
                        target.SiblingOrder = Container.Children.Count - 1;

                        result.Add(target);
                    }
                }
            }
            else
            {
                if (lastVisibleItemIndex < Container.Children.Count - 3)
                {
                    RecycleItem prevFirstItem = Container.Children[0] as RecycleItem;
                    RecycleItem target = Container.Children[Container.Children.Count - 1] as RecycleItem;
                    if (prevFirstItem != null && target != null)
                    {
                        target.Position = new Position(
                            LayoutOrientation == Orientation.Horizontal ? (prevFirstItem.Position.X - target.Size.Width) : prevFirstItem.Position.X,
                            LayoutOrientation == Orientation.Horizontal ? prevFirstItem.Position.Y : (prevFirstItem.Position.Y - target.Size.Height)
                        );
                        target.DataIndex = target.DataIndex - Container.Children.Count;
                        target.SiblingOrder = 0;

                        result.Add(target);
                    }
                }
            }

            PrevScrollPosition = scrollPosition;

            return result;
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            return scrollPosition;
        }

        public override View RequestNextFocusableView(View currentFocusedView, View.FocusDirection direction, bool loopEnabled)
        {
            View nextFocusedView = null;
            int targetSibling = -1;
            bool isHorizontal = LayoutOrientation == Orientation.Horizontal;

            switch (direction)
            {
                case View.FocusDirection.Left:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - 1 : targetSibling;
                        break;
                    }
                case View.FocusDirection.Right:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + 1 : targetSibling;
                        break;
                    }
                case View.FocusDirection.Up:
                    {
                        targetSibling = isHorizontal ? targetSibling : currentFocusedView.SiblingOrder - 1;
                        break;
                    }
                case View.FocusDirection.Down:
                    {
                        targetSibling = isHorizontal ? targetSibling : currentFocusedView.SiblingOrder + 1;
                        break;
                    }
            }

            if (targetSibling > -1 && targetSibling < Container.Children.Count)
            {
                RecycleItem candidate = Container.Children[targetSibling] as RecycleItem;
                if (candidate != null && candidate.DataIndex >= 0 && candidate.DataIndex < DataCount)
                {
                    nextFocusedView = candidate;
                }
            }

            return nextFocusedView;
        }
    }
}

---- Transformed Tree ----
using System;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Components;
using System.Collections.Generic;
using System.ComponentModel;

namespace Tizen.NUI.Wearable
{
    /// <summary>
    /// [Draft] This class implements a linear box layout.
    /// </summary>
    /// <since_tizen> 8 </since_tizen>
    /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
    [EditorBrowsable(EditorBrowsableState.Never)]
    public class LinearRecycleLayoutManager : RecycleLayoutManager
    {
        private int firstVisibleItemIndex = -1;
        private int lastVisibleItemIndex = -1;

        private bool IsItemVisible(float scrollPosition, RecycleItem item)
        {
            bool result = false;
            View list = Container.GetParent() as View;
            if (list == null)
            {
                return result;
            }

            Vector2 visibleArea = new Vector2(Math.Abs(scrollPosition),
                Math.Abs(scrollPosition) + (LayoutOrientation == Orientation.Horizontal ?
                                                list.Size.Width : list.Size.Height)
            );

            float firstCheckPoint = LayoutOrientation == Orientation.Horizontal ? item.Position.X : item.Position.Y;
            float secondCheckPoint = LayoutOrientation == Orientation.Horizontal ?
                                        firstCheckPoint + item.Size.Width :
                                        firstCheckPoint + item.Size.Height;

            // Tizen.Log.Error("NUI", "[1p] "+visibleArea.X+ " =< "+firstCheckPoint+" =< "+visibleArea.Y+" ==== \n");
            // Tizen.Log.Error("NUI", "[2p] "+visibleArea.X+ " =< "+secondCheckPoint+" =< "+visibleArea.Y+" ==== \n");

            result = (firstCheckPoint >= visibleArea.X && firstCheckPoint <= visibleArea.Y) || (secondCheckPoint >= visibleArea.X && secondCheckPoint <= visibleArea.Y);

            return result;
        }

        /// <summary>
        /// This is called to find out where items are lain out according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override void Layout(float scrollPosition)
        {
            firstVisibleItemIndex = -1;
            lastVisibleItemIndex = -1;

            RecycleItem previousItem = null;

            for (int i = 0; i < Container.Children.Count; i++)
            {
                if (previousItem != null && Container.Children[i] is RecycleItem item)
                {
                    item.Position = LayoutOrientation == Orientation.Horizontal ?
                        new Position(
                            previousItem.Position.X + (previousItem.CurrentSize.Width != 0 ?
                                                            previousItem.CurrentSize.Width :
                                                            previousItem.Size.Width),
                            item.PositionY
                        ) :
                        new Position(
                            item.PositionX,
                            previousItem.Position.Y + (previousItem.CurrentSize.Height != 0 ?
                                                            previousItem.CurrentSize.Height :
                                                            previousItem.Size.Height)
                        );
                }

                bool isVisible = IsItemVisible(scrollPosition, item);

                if (isVisible)
                {
                    firstVisibleItemIndex = firstVisibleItemIndex == -1 ? i : firstVisibleItemIndex;
                    lastVisibleItemIndex = i;
                }

                previousItem = item;

                // Tizen.Log.Error("NUI","["+item.DataIndex+"] "+item.Position.Y+" ==== \n");
            }

            if (StepSize == 0)
            {
                StepSize = LayoutOrientation == Orientation.Horizontal ? ItemSize.Width : ItemSize.Height;
            }
        }

        /// <summary>
        /// This is called to find out how much container size can be.
        /// </summary>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override float CalculateLayoutOrientationSize()
        {
            return StepSize * DataCount;
        }

        /// <summary>
        /// This is called to find out which items should be recycled according to current scroll position.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <returns>List of RecycleItems which should be recycled.</returns>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override List<RecycleItem> Recycle(float scrollPosition)
        {
            List<RecycleItem> result = new List<RecycleItem>();

            bool checkFront = (PrevScrollPosition - scrollPosition) > 0;

            if (checkFront)
            {
                if (firstVisibleItemIndex > 3)
                {
                    // Too many item is in front!!! move first item to back!!!!
                    if (Container.Children[0] is RecycleItem target)
                    {
                        target.DataIndex = target.DataIndex + Container.Children.Count;
                        target.SiblingOrder = Container.Children.Count - 1;

                        result.Add(target);
                    }
                }
            }
            else
            {
                if (lastVisibleItemIndex < Container.Children.Count - 3)
                {
                    if (Container.Children[0] is RecycleItem prevFirstItem && Container.Children[0] is RecycleItem target)
                    {
                        target.Position = new Position(
                            LayoutOrientation == Orientation.Horizontal ? (prevFirstItem.Position.X - target.Size.Width) : prevFirstItem.Position.X,
                            LayoutOrientation == Orientation.Horizontal ? prevFirstItem.Position.Y : (prevFirstItem.Position.Y - target.Size.Height)
                        );
                        target.DataIndex = target.DataIndex - Container.Children.Count;
                        target.SiblingOrder = 0;

                        result.Add(target);
                    }
                }
            }

            PrevScrollPosition = scrollPosition;

            return result;
        }

        /// <summary>
        /// Adjust scrolling position by own scrolling rules.
        /// </summary>
        /// <param name="scrollPosition">Scroll position which is calculated by ScrollableBase</param>
        /// <since_tizen> 8 </since_tizen>
        /// This may be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API
        public override float CalculateCandidateScrollPosition(float scrollPosition)
        {
            return scrollPosition;
        }

        public override View RequestNextFocusableView(View currentFocusedView, View.FocusDirection direction, bool loopEnabled)
        {
            View nextFocusedView = null;
            int targetSibling = -1;
            bool isHorizontal = LayoutOrientation == Orientation.Horizontal;

            switch (direction)
            {
                case View.FocusDirection.Left:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder - 1 : targetSibling;
                        break;
                    }
                case View.FocusDirection.Right:
                    {
                        targetSibling = isHorizontal ? currentFocusedView.SiblingOrder + 1 : targetSibling;
                        break;
                    }
                case View.FocusDirection.Up:
                    {
                        targetSibling = isHorizontal ? targetSibling : currentFocusedView.SiblingOrder - 1;
                        break;
                    }
                case View.FocusDirection.Down:
                    {
                        targetSibling = isHorizontal ? targetSibling : currentFocusedView.SiblingOrder + 1;
                        break;
                    }
            }

            if (targetSibling > -1 && targetSibling < Container.Children.Count)
            {
                if (Container.Children[targetSibling] is RecycleItem candidate && candidate.DataIndex >= 0 && candidate.DataIndex < DataCount)
                {
                    nextFocusedView = candidate;
                }
            }

            return nextFocusedView;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs(190,30): warning CS1591: Missing XML comment for publicly visible type or member 'LinearRecycleLayoutManager.RequestNextFocusableView(View, View.FocusDirection, bool)',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs(94,64): error CS0165: Use of unassigned local variable 'item',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs(185,30): warning CS1591: Missing XML comment for publicly visible type or member 'LinearRecycleLayoutManager.RequestNextFocusableView(View, View.FocusDirection, bool)',/home/vsts/work/1/s/src/Tizen.NUI.Wearable/src/public/RecyclerView/LinearRecycleLayoutManager.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 6 - MergeSequentialChecksRewriterR2
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            var pList = parentNode as ListNode;
            if (pList != null && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {
            var markupExtension = value as IMarkupExtension;
            var valueProvider = value as IValueProvider;

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider != null && serviceProvider.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (markupExtension != null)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (valueProvider != null)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;
            var bindable = element as BindableObject;

            if (binding == null)
                return false;

            if (bindable != null && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (bindable != null)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary)
                resourceDictionary.Add((ResourceDictionary)value);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            var pList = parentNode as ListNode;
            if (pList != null && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {
            var markupExtension = value as IMarkupExtension;
            var valueProvider = value as IValueProvider;

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider?.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (markupExtension != null)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (valueProvider != null)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;
            var bindable = element as BindableObject;

            if (binding == null)
                return false;

            if (bindable != null && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (serviceProvider?.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (bindable != null)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider?.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider?.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary)
                resourceDictionary.Add((ResourceDictionary)value);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(259,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(176,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(678,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(259,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(176,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(283,57): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(678,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            var pList = parentNode as ListNode;
            if (pList != null && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {
            var markupExtension = value as IMarkupExtension;
            var valueProvider = value as IValueProvider;

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider != null && serviceProvider.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (markupExtension != null)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (valueProvider != null)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;
            var bindable = element as BindableObject;

            if (binding == null)
                return false;

            if (bindable != null && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (bindable != null)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary)
                resourceDictionary.Add((ResourceDictionary)value);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            var pList = parentNode as ListNode;
            if (pList != null && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {
            var markupExtension = value as IMarkupExtension;
            var valueProvider = value as IValueProvider;

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider != null && serviceProvider.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (markupExtension != null)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (valueProvider != null)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;
            var bindable = element as BindableObject;

            if (binding == null)
                return false;

            if (bindable != null && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (bindable != null)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary resourceDictionary)
                resourceDictionary.Add(resourceDictionary);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(259,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(176,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(678,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(259,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(176,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(678,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(731,50): error CS0136: A local or parameter named 'resourceDictionary' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            var pList = parentNode as ListNode;
            if (pList != null && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {
            var markupExtension = value as IMarkupExtension;
            var valueProvider = value as IValueProvider;

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider != null && serviceProvider.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (markupExtension != null)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (valueProvider != null)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;
            var bindable = element as BindableObject;

            if (binding == null)
                return false;

            if (bindable != null && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (bindable != null)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary)
                resourceDictionary.Add((ResourceDictionary)value);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;

using static System.String;

namespace Tizen.NUI.Xaml
{
    internal class ApplyPropertiesVisitor : IXamlNodeVisitor
    {
        public static readonly IList<XmlName> Skips = new List<XmlName> {
            XmlName.xKey,
            XmlName.xTypeArguments,
            XmlName.xArguments,
            XmlName.xFactoryMethod,
            XmlName.xName,
            XmlName.xDataType
        };

        public ApplyPropertiesVisitor(HydrationContext context, bool stopOnResourceDictionary = false)
        {
            Context = context;
            StopOnResourceDictionary = stopOnResourceDictionary;
        }

        Dictionary<INode, object> Values => Context.Values;
        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary { get; }
        public bool VisitNodeOnDataTemplate => true;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            var parentElement = parentNode as IElementNode;
            var value = Values[node];
            var source = Values[parentNode];
            XmlName propertyName;

            if (TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (TrySetRuntimeName(propertyName, source, value, node))
                    return;
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;
                if (propertyName.Equals(XamlParser.McUri, "Ignorable"))
                    return;
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                // Collection element, implicit content, or implicit collection element.
                var contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo());
                if (contentProperty != null)
                {
                    var name = new XmlName(((ElementNode)parentNode).NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;
                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                }
            }
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            XmlName propertyName;
            if (TryGetPropertyName(node, parentNode, out propertyName) && propertyName == XmlName._CreateContent)
            {
                var s0 = Values[parentNode];
                if (s0 is ElementTemplate)
                {
                    SetTemplate(s0 as ElementTemplate, node);
                    return;
                }
            }

            var parentElement = parentNode as IElementNode;
            propertyName = XmlName.Empty;

            //Simplify ListNodes with single elements
            if (parentNode is ListNode pList && pList.CollectionItems.Count == 1)
            {
                propertyName = pList.XmlName;
                parentNode = parentNode.Parent;
                parentElement = parentNode as IElementNode;
            }

            var value = Values[node];

            if (propertyName != XmlName.Empty || TryGetPropertyName(node, parentNode, out propertyName))
            {
                if (Skips.Contains(propertyName))
                    return;
                if (parentElement == null)
                    return;
                if (parentElement.SkipProperties.Contains(propertyName))
                    return;

                var source = Values[parentNode];
                ProvideValue(ref value, node, source, propertyName);
                SetPropertyValue(source, propertyName, value, Context.RootElement, node, Context, node);
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is IElementNode)
            {
                var source = Values[parentNode];
                ProvideValue(ref value, node, source, XmlName.Empty);
                string contentProperty;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                //ResourceDictionary
                if (xpe == null && TryAddToResourceDictionary(source as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                // Dictionary with string key
                if (xpe == null && xKey != null)
                {
                    var indexer = GetIndexer(source, typeof(string), value.GetType());
                    if (indexer != null)
                    {
                        indexer.SetValue(source, value, new[] { xKey });
                        return;
                    }
                }

                // Collection element, implicit content, or implicit collection element.
                if (xpe == null && typeof(IEnumerable).IsAssignableFrom(Context.Types[parentElement]) && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    var addMethod =
                        Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);

                    addMethod?.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && Context.Types[parentElement].GetRuntimeMethods().Any(mi => mi.Name == "Add" && mi.GetParameters().Length == 1))
                {
                    //if there are similar parameters in the function, this will exist issue.
                    var addMethod = Context.Types[parentElement].GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
                    if (addMethod != null) addMethod.Invoke(source, new[] { value });
                    return;
                }
                if (xpe == null && (contentProperty = GetContentPropertyName(Context.Types[parentElement].GetTypeInfo())) != null)
                {
                    var name = new XmlName(node.NamespaceURI, contentProperty);
                    if (Skips.Contains(name))
                        return;
                    if (parentElement.SkipProperties.Contains(propertyName))
                        return;

                    SetPropertyValue(source, name, value, Context.RootElement, node, Context, node);
                    return;
                }

                xpe = xpe ?? new XamlParseException($"Can not set the content of {((IElementNode)parentNode).XmlType.Name} as it doesn't have a ContentPropertyAttribute", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                throw xpe;
            }
            else if (IsCollectionItem(node, parentNode) && parentNode is ListNode)
            {
                var source = Values[parentNode.Parent];
                ProvideValue(ref value, node, source, XmlName.Empty);
                var parentList = (ListNode)parentNode;
                if (Skips.Contains(parentList.XmlName))
                    return;
                Exception xpe = null;
                var xKey = node.Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)node.Properties[XmlName.xKey]).Value as string : null;

                object _;
                var collection = GetPropertyValue(source, parentList.XmlName, Context, parentList, out _) as IEnumerable;
                if (collection == null)
                    xpe = new XamlParseException($"Property {parentList.XmlName.LocalName} is null or is not IEnumerable", node);

                if (xpe == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, node, out xpe))
                    return;

                MethodInfo addMethod;
                if (xpe == null && (addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1)) != null)
                {
                    addMethod.Invoke(collection, new[] { Values[node] });
                    return;
                }
                xpe = xpe ?? new XamlParseException($"Value of {parentList.XmlName.LocalName} does not have a Add() method", node);
                if (Context.ExceptionHandler != null)
                    Context.ExceptionHandler(xpe);
                else
                    throw xpe;
            }
        }



        public void Visit(RootNode node, INode parentNode)
        {
        }

        public void Visit(ListNode node, INode parentNode)
        {
        }

        public static bool TryGetPropertyName(INode node, INode parentNode, out XmlName name)
        {
            name = default(XmlName);
            var parentElement = parentNode as IElementNode;
            if (parentElement == null)
                return false;
            foreach (var kvp in parentElement.Properties)
            {
                if (kvp.Value != node)
                    continue;
                name = kvp.Key;
                return true;
            }
            return false;
        }

        internal static bool IsCollectionItem(INode node, INode parentNode)
        {
            var parentList = parentNode as IListNode;
            if (parentList == null)
                return false;
            return parentList.CollectionItems.Contains(node);
        }

        internal static string GetContentPropertyName(System.Reflection.TypeInfo typeInfo)
        {
            while (typeInfo != null)
            {
                var propName = GetContentPropertyName(typeInfo.CustomAttributes);
                if (propName != null)
                    return propName;
                typeInfo = typeInfo?.BaseType?.GetTypeInfo();
            }
            return null;
        }

        void ProvideValue(ref object value, ElementNode node, object source, XmlName propertyName)
        {

            if (markupExtension == null && valueProvider == null)
                return;

            XamlServiceProvider serviceProvider = null;
            if (value.GetType().GetTypeInfo().GetCustomAttribute<AcceptEmptyServiceProviderAttribute>() == null)
                serviceProvider = new XamlServiceProvider(node, Context);

            if (serviceProvider != null && serviceProvider.IProvideValueTarget is XamlValueTargetProvider && propertyName != XmlName.Empty)
            {
                (serviceProvider.IProvideValueTarget as XamlValueTargetProvider).TargetProperty = GetTargetProperty(source, propertyName, Context, node);
            }

            if (value is IMarkupExtension markupExtension)
                value = markupExtension.ProvideValue(serviceProvider);
            else if (value is IValueProvider valueProvider)
                value = valueProvider.ProvideValue(serviceProvider);
        }

        static string GetContentPropertyName(IEnumerable<CustomAttributeData> attributes)
        {
            var contentAttribute =
                attributes.FirstOrDefault(cad => ContentPropertyAttribute.ContentPropertyTypes.Contains(cad.AttributeType.FullName));
            if (contentAttribute == null || contentAttribute.ConstructorArguments.Count != 1)
                return null;
            if (contentAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)contentAttribute.ConstructorArguments[0].Value;
            return null;
        }

        static bool GetRealNameAndType(ref Type elementType, string namespaceURI, ref string localname,
            HydrationContext context, IXmlLineInfo lineInfo)
        {
            var dotIdx = localname.IndexOf('.');
            if (dotIdx > 0)
            {
                var typename = localname.Substring(0, dotIdx);
                localname = localname.Substring(dotIdx + 1);
                XamlParseException xpe;
                elementType = XamlParser.GetElementType(new XmlType(namespaceURI, typename, null), lineInfo,
                    context.RootElement.GetType().GetTypeInfo().Assembly, out xpe);

                if (xpe != null)
                    throw xpe;
                return true;
            }
            return false;
        }

        static BindableProperty GetBindableProperty(Type elementType, string localName, IXmlLineInfo lineInfo,
            bool throwOnError = false)
        {
#if NETSTANDARD1_0
            var bindableFieldInfo = elementType.GetFields().FirstOrDefault(fi => fi.Name == localName + "Property");
#else
            var bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");

            if (null == bindableFieldInfo)
            {
                bindableFieldInfo = elementType.GetFields(BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy).FirstOrDefault(fi => fi.Name == localName + "Property");
            }
#endif
            Exception exception = null;
            if (exception == null && bindableFieldInfo == null)
            {
                exception =
                    new XamlParseException(
                        Format("BindableProperty {0} not found on {1}", localName + "Property", elementType.Name), lineInfo);
            }

            if (exception == null)
                return bindableFieldInfo.GetValue(null) as BindableProperty;
            if (throwOnError)
                throw exception;
            return null;
        }

        static object GetTargetProperty(object xamlelement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            if (property != null)
                return property;

            var elementType = xamlelement.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            return propertyInfo;
        }

        public static void SetPropertyValue(object xamlelement, XmlName propertyName, object value, object rootElement, INode node, HydrationContext context, IXmlLineInfo lineInfo)
        {
            var localName = propertyName.LocalName;
            var serviceProvider = new XamlServiceProvider(node, context);
            Exception xpe = null;
            var xKey = node is IElementNode && ((IElementNode)node).Properties.ContainsKey(XmlName.xKey) ? ((ValueNode)((IElementNode)node).Properties[XmlName.xKey]).Value as string : null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlelement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);

            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If the target is an event, connect
            if (xpe == null && TryConnectEvent(xamlelement, localName, attached, value, rootElement, lineInfo, out xpe))
                return;

            //If Value is DynamicResource and it's a BP, SetDynamicResource
            if (xpe == null && TrySetDynamicResource(xamlelement, property, value, lineInfo, out xpe))
                return;

            //If value is BindingBase, SetBinding
            if (xpe == null && TrySetBinding(xamlelement, property, value, lineInfo, out xpe))
                return;

            //Call TrySetProperty first and then TrySetValue to keep the code logic consistent whether it is through xaml or code.
            //If we can assign that value to a normal property, let's do it
            if (xpe == null && TrySetProperty(xamlelement, property, localName, value, serviceProvider, context, out xpe))
                return;

            //If it's a BindableProberty, SetValue
            if (xpe == null && TrySetValue(xamlelement, property, attached, value, lineInfo, serviceProvider, out xpe))
                return;

            //If it's an already initialized property, add to it
            if (xpe == null && TryAddToProperty(xamlelement, propertyName, value, xKey, lineInfo, serviceProvider, context, out xpe))
                return;

            xpe = xpe ?? new XamlParseException($"Cannot assign property \"{localName}\": Property does not exist, or is not assignable, or mismatching type between value and property", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;
        }

        public static object GetPropertyValue(object xamlElement, XmlName propertyName, HydrationContext context, IXmlLineInfo lineInfo, out object targetProperty)
        {
            var localName = propertyName.LocalName;
            Exception xpe = null;
            object value;
            targetProperty = null;

            //If it's an attached BP, update elementType and propertyName
            var bpOwnerType = xamlElement.GetType();
            var attached = GetRealNameAndType(ref bpOwnerType, propertyName.NamespaceURI, ref localName, context, lineInfo);
            var property = GetBindableProperty(bpOwnerType, localName, lineInfo, false);

            //If it's a BindableProberty, GetValue
            if (xpe == null && TryGetValue(xamlElement, property, out value, out xpe, out targetProperty))
                return value;

            //If it's a normal property, get it
            if (xpe == null && TryGetProperty(xamlElement, localName, out value, context, out xpe, out targetProperty))
                return value;

            xpe = xpe ?? new XamlParseException($"Property {localName} is not found or does not have an accessible getter", lineInfo);
            if (context.ExceptionHandler != null)
                context.ExceptionHandler(xpe);
            else
                throw xpe;

            return null;
        }

        static bool TryConnectEvent(object element, string localName, bool attached, object value, object rootElement, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (attached)
                return false;

            var elementType = element.GetType();
            var eventInfo = elementType.GetRuntimeEvent(localName);
            var stringValue = value as string;

            if (eventInfo == null || IsNullOrEmpty(stringValue))
                return false;

            var methodInfo = rootElement.GetType().GetRuntimeMethods().FirstOrDefault(mi => mi.Name == (string)value);
            if (methodInfo == null)
            {
                exception = new XamlParseException($"No method {value} found on type {rootElement.GetType()}", lineInfo);
                return false;
            }

            try
            {
                eventInfo.AddEventHandler(element, methodInfo.CreateDelegate(eventInfo.EventHandlerType, rootElement));
                return true;
            }
            catch (ArgumentException ae)
            {
                exception = new XamlParseException($"Method {stringValue} does not have the correct signature", lineInfo, ae);
            }
            return false;
        }

        static bool TrySetDynamicResource(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var dynamicResource = value as DynamicResource;
            var bindable = element as BindableObject;

            if (dynamicResource == null || property == null)
                return false;

            if (bindable == null)
            {
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject", lineInfo);
                return false;
            }

            bindable.SetDynamicResource(property, dynamicResource.Key);
            return true;
        }

        static bool TrySetBinding(object element, BindableProperty property, object value, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var binding = value.ConvertTo(typeof(BindingBase), pinfoRetriever: null, serviceProvider: null) as BindingBase;

            if (binding == null)
                return false;

            if (element is BindableObject bindable && property != null)
            {
                bindable.SetBinding(property, binding);
                return true;
            }

            if (property != null)
                exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support native bindings", lineInfo);

            return false;
        }

        static bool TrySetValue(object element, BindableProperty property, bool attached, object value, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();

            if (property == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = property;

            Func<MemberInfo> minforetriever;
            if (attached)
                minforetriever = () => property.DeclaringType.GetRuntimeMethod("Get" + property.PropertyName, new[] { typeof(BindableObject) });
            else
            {
                minforetriever = () => property.DeclaringType.GetRuntimeProperties().LastOrDefault(p => p.Name == property.PropertyName);
            }
            //minforetriever = () => property.DeclaringType.GetRuntimeProperty(property.PropertyName);
            var convertedValue = value.ConvertTo(property.ReturnType, minforetriever, serviceProvider);

            if (element is BindableObject bindable)
            {
                //SetValue doesn't throw on mismatching type, so check before to get a chance to try the property setting or the collection adding
                var nullable = property.ReturnTypeInfo.IsGenericType &&
                               property.ReturnTypeInfo.GetGenericTypeDefinition() == typeof(Nullable<>);
                if ((convertedValue == null && (!property.ReturnTypeInfo.IsValueType || nullable)) ||
                    (property.ReturnType.IsInstanceOfType(convertedValue)))
                {
                    bindable.SetValue(property, convertedValue);
                    return true;
                }

                // This might be a collection; see if we can add to it
                return TryAddValue(bindable, property, value, serviceProvider);
            }

            exception = new XamlParseException($"{elementType.Name} is not a BindableObject or does not support setting native BindableProperties", lineInfo);
            return false;
        }

        static bool TryGetValue(object element, BindableProperty property, out object value, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            targetProperty = property;
            var elementType = element.GetType();
            var bindable = element as BindableObject;

            if (property == null)
                return false;

            if (bindable == null)
                return false;

            value = bindable.GetValue(property);
            return true;
        }

        static bool TrySetProperty(object element, BindableProperty property, string localName, object value, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            var elementType = element.GetType();
            var propertyInfo = elementType.GetRuntimeProperties().FirstOrDefault(p => p.Name == localName);
            MethodInfo setter;
            if (propertyInfo == null || !propertyInfo.CanWrite || (setter = propertyInfo.SetMethod) == null)
                return false;

            if (!IsVisibleFrom(setter, context.RootElement))
                return false;

            if (property != null && propertyInfo.PropertyType != property.ReturnType)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = propertyInfo;

            object convertedValue = GetConvertedValue(propertyInfo.PropertyType, value, () => propertyInfo, serviceProvider);

            if (null == convertedValue)
            {
                var methods = propertyInfo.PropertyType.GetMethods().Where(a => a.Name == "op_Implicit");

                foreach (var method in methods)
                {
                    var paramType = method.GetParameters()[0].ParameterType;
                    convertedValue = GetConvertedValue(paramType, value, () => propertyInfo, serviceProvider);

                    if (null != convertedValue)
                    {
                        var realValue = Activator.CreateInstance(propertyInfo.PropertyType);
                        convertedValue = method.Invoke(realValue, new object[] { convertedValue });

                        if (null != convertedValue)
                        {
                            break;
                        }
                    }
                }
            }

            if (null == convertedValue)
            {
                return false;
            }

            setter.Invoke(element, new object[] { convertedValue });
            return true;
        }

        static private object GetConvertedValue(Type valueType, object value, Func<MemberInfo> minfoRetriever, XamlServiceProvider serviceProvider)
        {
            try
            {
                object convertedValue = value.ConvertTo(valueType, minfoRetriever, serviceProvider);

                if (convertedValue != null && !valueType.IsInstanceOfType(convertedValue))
                {
                    return null;
                }

                return convertedValue;
            }
            catch
            {
                return null;
            }
        }

        static bool TryGetProperty(object element, string localName, out object value, HydrationContext context, out Exception exception, out object targetProperty)
        {
            exception = null;
            value = null;
            var elementType = element.GetType();
            PropertyInfo propertyInfo = null;
            try
            {
                propertyInfo = elementType.GetRuntimeProperty(localName);
            }
            catch (AmbiguousMatchException)
            {
                // Get most derived instance of property
                foreach (var property in elementType.GetRuntimeProperties().Where(prop => prop.Name == localName))
                {
                    if (propertyInfo == null || propertyInfo.DeclaringType.IsAssignableFrom(property.DeclaringType))
                        propertyInfo = property;
                }
            }
            MethodInfo getter;
            targetProperty = propertyInfo;
            if (propertyInfo == null || !propertyInfo.CanRead || (getter = propertyInfo.GetMethod) == null)
                return false;

            if (!IsVisibleFrom(getter, context.RootElement))
                return false;

            value = getter.Invoke(element, System.Array.Empty<object>());
            return true;
        }

        static bool IsVisibleFrom(MethodInfo method, object rootElement)
        {
            if (method.IsPublic)
                return true;
            if (method.IsPrivate && method.DeclaringType == rootElement.GetType())
                return true;
            if ((method.IsAssembly || method.IsFamilyOrAssembly) && method.DeclaringType.AssemblyQualifiedName == rootElement.GetType().AssemblyQualifiedName)
                return true;
            if (method.IsFamily && method.DeclaringType.IsAssignableFrom(rootElement.GetType()))
                return true;
            return false;
        }

        static bool TryAddToProperty(object element, XmlName propertyName, object value, string xKey, IXmlLineInfo lineInfo, XamlServiceProvider serviceProvider, HydrationContext context, out Exception exception)
        {
            exception = null;

            object targetProperty;
            var collection = GetPropertyValue(element, propertyName, context, lineInfo, out targetProperty) as IEnumerable;

            if (collection == null)
                return false;

            if (exception == null && TryAddToResourceDictionary(collection as ResourceDictionary, value, xKey, lineInfo, out exception))
                return true;

            if (exception != null)
                return false;

            var addMethod = collection.GetType().GetRuntimeMethods().First(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            if (serviceProvider != null && serviceProvider.IProvideValueTarget != null)
                ((XamlValueTargetProvider)serviceProvider.IProvideValueTarget).TargetProperty = targetProperty;

            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static bool TryAddToResourceDictionary(ResourceDictionary resourceDictionary, object value, string xKey, IXmlLineInfo lineInfo, out Exception exception)
        {
            exception = null;

            if (resourceDictionary == null)
                return false;

            if (xKey != null)
                resourceDictionary.Add(xKey, value);
            else if (value is ResourceDictionary)
                resourceDictionary.Add((ResourceDictionary)value);
            else
            {
                exception = new XamlParseException("resources in ResourceDictionary require a x:Key attribute", lineInfo);
                return false;
            }
            return true;
        }

        void SetTemplate(ElementTemplate dt, INode node)
        {
#pragma warning disable 0612
            ((IDataTemplate)dt).LoadTemplate = () =>
            {
#pragma warning restore 0612
                var cnode = node.Clone();
                var context = new HydrationContext { ParentContext = Context, RootElement = Context.RootElement };
                cnode.Accept(new XamlNodeVisitor((n, parent) => n.Parent = parent), node.Parent); //set parents for {StaticResource}
                cnode.Accept(new ExpandMarkupsVisitor(context), null);
                cnode.Accept(new NamescopingVisitor(context), null);
                cnode.Accept(new CreateValuesVisitor(context), null);
                cnode.Accept(new RegisterXNamesVisitor(context), null);
                cnode.Accept(new FillResourceDictionariesVisitor(context), null);
                cnode.Accept(new ApplyPropertiesVisitor(context, true), null);
                return context.Values[cnode];
            };
        }

        static bool TryAddValue(BindableObject bindable, BindableProperty property, object value, XamlServiceProvider serviceProvider)
        {
            if (property?.ReturnTypeInfo?.GenericTypeArguments == null)
            {
                return false;
            }

            if (property.ReturnType == null)
            {
                return false;
            }

            if (property.ReturnTypeInfo.GenericTypeArguments.Length != 1 ||
                !property.ReturnTypeInfo.GenericTypeArguments[0].IsInstanceOfType(value))
                return false;

            // This might be a collection we can add to; see if we can find an Add method
            var addMethod = GetAllRuntimeMethods(property.ReturnType)
                .FirstOrDefault(mi => mi.Name == "Add" && mi.GetParameters().Length == 1);
            if (addMethod == null)
                return false;

            // If there's an add method, get the collection
            var collection = bindable.GetValue(property);

            // And add the new value to it
            addMethod.Invoke(collection, new[] { value.ConvertTo(addMethod.GetParameters()[0].ParameterType, (Func<TypeConverter>)null, serviceProvider) });
            return true;
        }

        static IEnumerable<MethodInfo> GetAllRuntimeMethods(Type type)
        {
            return type.GetRuntimeMethods()
                .Concat(type.GetTypeInfo().ImplementedInterfaces.SelectMany(t => t.GetRuntimeMethods()));
        }

        bool TrySetRuntimeName(XmlName propertyName, object source, object value, ValueNode node)
        {
            if (propertyName != XmlName.xName)
                return false;

            var runTimeName = source.GetType().GetTypeInfo().GetCustomAttribute<RuntimeNamePropertyAttribute>();
            if (runTimeName == null)
                return false;

            SetPropertyValue(source, new XmlName("", runTimeName.Name), value, Context.RootElement, node, Context, node);
            return true;
        }

        private PropertyInfo GetIndexer(object source, Type keyType, Type valueType) => source.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).FirstOrDefault(p => p.Name == "Item" && p.PropertyType.IsAssignableFrom(valueType) && p.GetIndexParameters().Length != 0 && p.GetIndexParameters()[0].ParameterType == keyType);
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(259,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(176,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(678,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(258,62): error CS0234: The type or namespace name 'Reflection' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(80,62): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(175,78): error CS1503: Argument 1: cannot convert from 'System.Reflection.TypeInfo' to 'Tizen.System.Reflection.TypeInfo',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(273,17): error CS0841: Cannot use local variable 'markupExtension' before it is declared,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(273,44): error CS0103: The name 'valueProvider' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/ApplyPropertiesVisitor.cs(673,44): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;


namespace Tizen.NUI.Xaml
{
    internal class CreateValuesVisitor : IXamlNodeVisitor
    {
        public CreateValuesVisitor(HydrationContext context)
        {
            Context = context;
        }

        Dictionary<INode, object> Values
        {
            get { return Context.Values; }
        }

        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary => false;
        public bool VisitNodeOnDataTemplate => false;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            Values[node] = node.Value;
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            object value = null;

            XamlParseException xpe;
            var type = XamlParser.GetElementType(node.XmlType, node, Context.RootElement?.GetType().GetTypeInfo().Assembly,
                out xpe);
            if (type == null)
                throw new ArgumentNullException(null, "type should not be null");
            if (xpe != null)
                throw xpe;

            Context.Types[node] = type;
            string ctorargname;
            if (IsXaml2009LanguagePrimitive(node))
                value = CreateLanguagePrimitive(type, node);
            else if (node.Properties.ContainsKey(XmlName.xArguments) || node.Properties.ContainsKey(XmlName.xFactoryMethod))
                value = CreateFromFactory(type, node);
            else if (
                type.GetTypeInfo()
                    .DeclaredConstructors.Any(
                        ci =>
                            ci.IsPublic && ci.GetParameters().Length != 0 &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute)))) &&
                ValidateCtorArguments(type, node, out ctorargname))
                value = CreateFromParameterizedConstructor(type, node);
            else if (!type.GetTypeInfo().DeclaredConstructors.Any(ci => ci.IsPublic && ci.GetParameters().Length == 0) &&
                     !ValidateCtorArguments(type, node, out ctorargname))
            {
                throw new XamlParseException($"The Property {ctorargname} is required to create a {type?.FullName} object.", node);
            }
            else
            {
                //this is a trick as the DataTemplate parameterless ctor is internal, and we can't CreateInstance(..., false) on WP7
                try
                {
                    if (type == typeof(DataTemplate))
                        value = new DataTemplate();
                    if (type == typeof(ControlTemplate))
                        value = new ControlTemplate();
                    if (value == null && node.CollectionItems.Any() && node.CollectionItems.First() is ValueNode)
                    {
                        var serviceProvider = new XamlServiceProvider(node, Context);
                        var converted = ((ValueNode)node.CollectionItems.First()).Value.ConvertTo(type, () => type.GetTypeInfo(),
                            serviceProvider);
                        if (converted != null && converted.GetType() == type)
                            value = converted;
                    }
                    if (value == null)
                    {
                        if (type.GetTypeInfo().DeclaredConstructors.Any(ci => ci.IsPublic && ci.GetParameters().Length == 0))
                        {
                            //default constructor
                            value = Activator.CreateInstance(type);
                        }
                        else
                        {
                            //constructor with all default parameters
                            value = Activator.CreateInstance(type, BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.Instance | BindingFlags.OptionalParamBinding, null, new object[] { Type.Missing }, CultureInfo.CurrentCulture);
                        }
                        if (value is Element)
                        {
                            if (null != Application.Current)
                            {
                                Application.AddResourceChangedCallback(value, (value as Element).OnResourcesChanged);
                            }

                            if (value is BindableObject bindableObject)
                            {
                                bindableObject.IsCreateByXaml = true;
                            }
                        }
                    }
                }
                catch (TargetInvocationException e)
                {
                    if (e.InnerException is XamlParseException || e.InnerException is XmlException)
                        throw e.InnerException;
                    throw;
                }
            }

            Values[node] = value;

            var markup = value as IMarkupExtension;
            if (markup != null && (value is TypeExtension || value is StaticExtension || value is ArrayExtension))
            {
                var serviceProvider = new XamlServiceProvider(node, Context);

                var visitor = new ApplyPropertiesVisitor(Context);
                foreach (var cnode in node.Properties.Values.ToList())
                    cnode.Accept(visitor, node);
                foreach (var cnode in node.CollectionItems)
                    cnode.Accept(visitor, node);

                value = markup.ProvideValue(serviceProvider);

                INode xKey;
                if (!node.Properties.TryGetValue(XmlName.xKey, out xKey))
                    xKey = null;

                node.Properties.Clear();
                node.CollectionItems.Clear();

                if (xKey != null)
                    node.Properties.Add(XmlName.xKey, xKey);

                Values[node] = value;
            }

            if (value is BindableObject)
                NameScope.SetNameScope(value as BindableObject, node.Namescope);
        }

        public void Visit(RootNode node, INode parentNode)
        {
            var rnode = (XamlLoader.RuntimeRootNode)node;
            Values[node] = rnode.Root;
            Context.Types[node] = rnode.Root.GetType();
            var bindableRoot = rnode.Root as BindableObject;
            if (bindableRoot != null)
                NameScope.SetNameScope(bindableRoot, node.Namescope);
        }

        public void Visit(ListNode node, INode parentNode)
        {
            //this is a gross hack to keep ListNode alive. ListNode must go in favor of Properties
            XmlName name;
            if (ApplyPropertiesVisitor.TryGetPropertyName(node, parentNode, out name))
                node.XmlName = name;
        }

        bool ValidateCtorArguments(Type nodeType, IElementNode node, out string missingArgName)
        {
            missingArgName = null;
            var ctorInfo =
                nodeType.GetTypeInfo()
                    .DeclaredConstructors.FirstOrDefault(
                        ci =>
                            ci.GetParameters().Length != 0 && ci.IsPublic &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute))));
            if (ctorInfo == null)
                return true;
            foreach (var parameter in ctorInfo.GetParameters())
            {
                // Modify the namespace
                var propname =
                    parameter.CustomAttributes.First(ca => ca.AttributeType.FullName == "Tizen.NUI.Binding.ParameterAttribute")?
                        .ConstructorArguments.First()
                        .Value as string;
                if (!node.Properties.ContainsKey(new XmlName("", propname)))
                {
                    missingArgName = propname;
                    return false;
                }
            }

            return true;
        }

        public object CreateFromParameterizedConstructor(Type nodeType, IElementNode node)
        {
            var ctorInfo =
                nodeType.GetTypeInfo()
                    .DeclaredConstructors.FirstOrDefault(
                        ci =>
                            ci.GetParameters().Length != 0 && ci.IsPublic &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute))));
            object[] arguments = CreateArgumentsArray(node, ctorInfo);

            if (arguments != null)
            {
                return ctorInfo?.Invoke(arguments);
            }
            else
            {
                return null;
            }
        }

        public object CreateFromFactory(Type nodeType, IElementNode node)
        {
            object[] arguments = CreateArgumentsArray(node);

            if (!node.Properties.ContainsKey(XmlName.xFactoryMethod))
            {
                //non-default ctor
                object ret = Activator.CreateInstance(nodeType, BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.Instance | BindingFlags.OptionalParamBinding, null, arguments, CultureInfo.CurrentCulture);
                if (ret is Element)
                {
                    if (null != Application.Current)
                    {
                        Application.AddResourceChangedCallback(ret, (ret as Element).OnResourcesChanged);
                    }

                    if (ret is BindableObject bindableObject)
                    {
                        bindableObject.IsCreateByXaml = true;
                    }
                }
                return ret;
            }

            var factoryMethod = ((string)((ValueNode)node.Properties[XmlName.xFactoryMethod]).Value);
            Type[] types = arguments == null ? System.Array.Empty<Type>() : arguments.Select(a => a.GetType()).ToArray();
            Func<MethodInfo, bool> isMatch = m =>
            {
                if (m.Name != factoryMethod)
                    return false;
                var p = m.GetParameters();
                if (p.Length != types.Length)
                    return false;
                if (!m.IsStatic)
                    return false;
                for (var i = 0; i < p.Length; i++)
                {
                    if ((p[i].ParameterType.IsAssignableFrom(types[i])))
                        continue;
                    var op_impl = p[i].ParameterType.GetImplicitConversionOperator(fromType: types[i], toType: p[i].ParameterType)
                                ?? types[i].GetImplicitConversionOperator(fromType: types[i], toType: p[i].ParameterType);

                    if (op_impl == null)
                        return false;
                    arguments[i] = op_impl.Invoke(null, new[] { arguments[i] });
                }
                return true;
            };
            var mi = nodeType.GetRuntimeMethods().FirstOrDefault(isMatch);
            if (mi == null)
                throw new MissingMemberException($"No static method found for {nodeType.FullName}::{factoryMethod} ({string.Join(", ", types.Select(t => t.FullName))})");
            return mi.Invoke(null, arguments);
        }

        public object[] CreateArgumentsArray(IElementNode enode)
        {
            if (!enode.Properties.ContainsKey(XmlName.xArguments))
                return null;
            var node = enode.Properties[XmlName.xArguments];
            var elementNode = node as ElementNode;
            if (elementNode != null)
            {
                var array = new object[1];
                array[0] = Values[elementNode];

                if (array[0].GetType().IsClass)
                {
                    elementNode.Accept(new ApplyPropertiesVisitor(Context, true), null);
                }

                return array;
            }

            var listnode = node as ListNode;
            if (listnode != null)
            {
                var array = new object[listnode.CollectionItems.Count];
                for (var i = 0; i < listnode.CollectionItems.Count; i++)
                    array[i] = Values[(ElementNode)listnode.CollectionItems[i]];
                return array;
            }
            return null;
        }

        public object[] CreateArgumentsArray(IElementNode enode, ConstructorInfo ctorInfo)
        {
            if (ctorInfo != null)
            {
                var n = ctorInfo.GetParameters().Length;
                var array = new object[n];
                for (var i = 0; i < n; i++)
                {
                    var parameter = ctorInfo.GetParameters()[i];
                    var propname =
                        parameter?.CustomAttributes?.First(attr => attr.AttributeType == typeof(ParameterAttribute))?
                            .ConstructorArguments.First()
                            .Value as string;
                    var name = new XmlName("", propname);
                    INode node;
                    if (!enode.Properties.TryGetValue(name, out node))
                    {
                        String msg = "";
                        if (propname != null)
                        {
                            msg = String.Format("The Property {0} is required to create a {1} object.", propname, ctorInfo.DeclaringType.FullName);
                        }
                        else
                        {
                            msg = "propname is null.";
                        }
                        throw new XamlParseException(msg, enode as IXmlLineInfo);
                    }
                    if (!enode.SkipProperties.Contains(name))
                        enode.SkipProperties.Add(name);
                    var value = Context.Values[node];
                    var serviceProvider = new XamlServiceProvider(enode, Context);
                    var convertedValue = value?.ConvertTo(parameter?.ParameterType, () => parameter, serviceProvider);
                    array[i] = convertedValue;
                }
                return array;
            }

            return null;
        }

        static bool IsXaml2009LanguagePrimitive(IElementNode node)
        {
            return node.NamespaceURI == XamlParser.X2009Uri;
        }

        static object CreateLanguagePrimitive(Type nodeType, IElementNode node)
        {
            object value = null;
            if (nodeType == typeof(string))
                value = String.Empty;
            else if (nodeType == typeof(Uri))
                value = null;
            else
            {
                value = Activator.CreateInstance(nodeType);
                if (value is Element)
                {
                    if (null != Application.Current)
                    {
                        Application.AddResourceChangedCallback(value, (value as Element).OnResourcesChanged);
                    }

                    if (value is BindableObject bindableObject)
                    {
                        bindableObject.IsCreateByXaml = true;
                    }
                }
            }

            if (node.CollectionItems.Count == 1 && node.CollectionItems[0] is ValueNode &&
                ((ValueNode)node.CollectionItems[0]).Value is string)
            {
                var valuestring = ((ValueNode)node.CollectionItems[0]).Value as string;

                if (nodeType == typeof(SByte))
                {
                    sbyte retval;
                    if (sbyte.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int16))
                {
                    short retval;
                    if (short.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int32))
                {
                    int retval;
                    if (int.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int64))
                {
                    long retval;
                    if (long.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Byte))
                {
                    byte retval;
                    if (byte.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt16))
                {
                    ushort retval;
                    if (ushort.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt32))
                {
                    uint retval;
                    if (uint.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt64))
                {
                    ulong retval;
                    if (ulong.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Single))
                {
                    float retval;
                    if (float.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Double))
                {
                    double retval;
                    if (double.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Boolean))
                {
                    bool outbool;
                    if (bool.TryParse(valuestring, out outbool))
                        return outbool;
                }
                if (nodeType == typeof(TimeSpan))
                {
                    TimeSpan retval;
                    if (TimeSpan.TryParse(valuestring, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(char))
                {
                    char retval;
                    if (char.TryParse(valuestring, out retval))
                        return retval;
                }
                if (nodeType == typeof(string))
                    return valuestring;
                if (nodeType == typeof(decimal))
                {
                    decimal retval;
                    if (decimal.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }

                else if (nodeType == typeof(Uri))
                {
                    Uri retval;
                    if (Uri.TryCreate(valuestring, UriKind.RelativeOrAbsolute, out retval))
                        return retval;
                }
            }
            return value;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Binding;


namespace Tizen.NUI.Xaml
{
    internal class CreateValuesVisitor : IXamlNodeVisitor
    {
        public CreateValuesVisitor(HydrationContext context)
        {
            Context = context;
        }

        Dictionary<INode, object> Values
        {
            get { return Context.Values; }
        }

        HydrationContext Context { get; }

        public TreeVisitingMode VisitingMode => TreeVisitingMode.BottomUp;
        public bool StopOnDataTemplate => true;
        public bool StopOnResourceDictionary => false;
        public bool VisitNodeOnDataTemplate => false;
        public bool SkipChildren(INode node, INode parentNode) => false;
        public bool IsResourceDictionary(ElementNode node) => typeof(ResourceDictionary).IsAssignableFrom(Context.Types[node]);

        public void Visit(ValueNode node, INode parentNode)
        {
            Values[node] = node.Value;
        }

        public void Visit(MarkupNode node, INode parentNode)
        {
        }

        public void Visit(ElementNode node, INode parentNode)
        {
            object value = null;

            XamlParseException xpe;
            var type = XamlParser.GetElementType(node.XmlType, node, Context.RootElement?.GetType().GetTypeInfo().Assembly,
                out xpe);
            if (type == null)
                throw new ArgumentNullException(null, "type should not be null");
            if (xpe != null)
                throw xpe;

            Context.Types[node] = type;
            string ctorargname;
            if (IsXaml2009LanguagePrimitive(node))
                value = CreateLanguagePrimitive(type, node);
            else if (node.Properties.ContainsKey(XmlName.xArguments) || node.Properties.ContainsKey(XmlName.xFactoryMethod))
                value = CreateFromFactory(type, node);
            else if (
                type.GetTypeInfo()
                    .DeclaredConstructors.Any(
                        ci =>
                            ci.IsPublic && ci.GetParameters().Length != 0 &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute)))) &&
                ValidateCtorArguments(type, node, out ctorargname))
                value = CreateFromParameterizedConstructor(type, node);
            else if (!type.GetTypeInfo().DeclaredConstructors.Any(ci => ci.IsPublic && ci.GetParameters().Length == 0) &&
                     !ValidateCtorArguments(type, node, out ctorargname))
            {
                throw new XamlParseException($"The Property {ctorargname} is required to create a {type?.FullName} object.", node);
            }
            else
            {
                //this is a trick as the DataTemplate parameterless ctor is internal, and we can't CreateInstance(..., false) on WP7
                try
                {
                    if (type == typeof(DataTemplate))
                        value = new DataTemplate();
                    if (type == typeof(ControlTemplate))
                        value = new ControlTemplate();
                    if (value == null && node.CollectionItems.Any() && node.CollectionItems.First() is ValueNode)
                    {
                        var serviceProvider = new XamlServiceProvider(node, Context);
                        var converted = ((ValueNode)node.CollectionItems.First()).Value.ConvertTo(type, () => type.GetTypeInfo(),
                            serviceProvider);
                        if (converted != null && converted.GetType() == type)
                            value = converted;
                    }
                    if (value == null)
                    {
                        if (type.GetTypeInfo().DeclaredConstructors.Any(ci => ci.IsPublic && ci.GetParameters().Length == 0))
                        {
                            //default constructor
                            value = Activator.CreateInstance(type);
                        }
                        else
                        {
                            //constructor with all default parameters
                            value = Activator.CreateInstance(type, BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.Instance | BindingFlags.OptionalParamBinding, null, new object[] { Type.Missing }, CultureInfo.CurrentCulture);
                        }
                        if (value is Element)
                        {
                            if (null != Application.Current)
                            {
                                Application.AddResourceChangedCallback(value, (value as Element).OnResourcesChanged);
                            }

                            if (value is BindableObject bindableObject)
                            {
                                bindableObject.IsCreateByXaml = true;
                            }
                        }
                    }
                }
                catch (TargetInvocationException e)
                {
                    if (e.InnerException is XamlParseException || e.InnerException is XmlException)
                        throw e.InnerException;
                    throw;
                }
            }

            Values[node] = value;

            if (value is IMarkupExtension markup && (value is TypeExtension || value is StaticExtension || value is ArrayExtension))
            {
                var serviceProvider = new XamlServiceProvider(node, Context);

                var visitor = new ApplyPropertiesVisitor(Context);
                foreach (var cnode in node.Properties.Values.ToList())
                    cnode.Accept(visitor, node);
                foreach (var cnode in node.CollectionItems)
                    cnode.Accept(visitor, node);

                value = markup.ProvideValue(serviceProvider);

                INode xKey;
                if (!node.Properties.TryGetValue(XmlName.xKey, out xKey))
                    xKey = null;

                node.Properties.Clear();
                node.CollectionItems.Clear();

                if (xKey != null)
                    node.Properties.Add(XmlName.xKey, xKey);

                Values[node] = value;
            }

            if (value is BindableObject)
                NameScope.SetNameScope(value as BindableObject, node.Namescope);
        }

        public void Visit(RootNode node, INode parentNode)
        {
            var rnode = (XamlLoader.RuntimeRootNode)node;
            Values[node] = rnode.Root;
            Context.Types[node] = rnode.Root.GetType();

            if (rnode.Root is BindableObject bindableRoot)
                NameScope.SetNameScope(bindableRoot, node.Namescope);
        }

        public void Visit(ListNode node, INode parentNode)
        {
            //this is a gross hack to keep ListNode alive. ListNode must go in favor of Properties
            XmlName name;
            if (ApplyPropertiesVisitor.TryGetPropertyName(node, parentNode, out name))
                node.XmlName = name;
        }

        bool ValidateCtorArguments(Type nodeType, IElementNode node, out string missingArgName)
        {
            missingArgName = null;
            var ctorInfo =
                nodeType.GetTypeInfo()
                    .DeclaredConstructors.FirstOrDefault(
                        ci =>
                            ci.GetParameters().Length != 0 && ci.IsPublic &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute))));
            if (ctorInfo == null)
                return true;
            foreach (var parameter in ctorInfo.GetParameters())
            {
                // Modify the namespace
                var propname =
                    parameter.CustomAttributes.First(ca => ca.AttributeType.FullName == "Tizen.NUI.Binding.ParameterAttribute")?
                        .ConstructorArguments.First()
                        .Value as string;
                if (!node.Properties.ContainsKey(new XmlName("", propname)))
                {
                    missingArgName = propname;
                    return false;
                }
            }

            return true;
        }

        public object CreateFromParameterizedConstructor(Type nodeType, IElementNode node)
        {
            var ctorInfo =
                nodeType.GetTypeInfo()
                    .DeclaredConstructors.FirstOrDefault(
                        ci =>
                            ci.GetParameters().Length != 0 && ci.IsPublic &&
                            ci.GetParameters().All(pi => pi.CustomAttributes.Any(attr => attr.AttributeType == typeof(ParameterAttribute))));
            object[] arguments = CreateArgumentsArray(node, ctorInfo);

            if (arguments != null)
            {
                return ctorInfo?.Invoke(arguments);
            }
            else
            {
                return null;
            }
        }

        public object CreateFromFactory(Type nodeType, IElementNode node)
        {
            object[] arguments = CreateArgumentsArray(node);

            if (!node.Properties.ContainsKey(XmlName.xFactoryMethod))
            {
                //non-default ctor
                object ret = Activator.CreateInstance(nodeType, BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.Instance | BindingFlags.OptionalParamBinding, null, arguments, CultureInfo.CurrentCulture);
                if (ret is Element)
                {
                    if (null != Application.Current)
                    {
                        Application.AddResourceChangedCallback(ret, (ret as Element).OnResourcesChanged);
                    }

                    if (ret is BindableObject bindableObject)
                    {
                        bindableObject.IsCreateByXaml = true;
                    }
                }
                return ret;
            }

            var factoryMethod = ((string)((ValueNode)node.Properties[XmlName.xFactoryMethod]).Value);
            Type[] types = arguments == null ? System.Array.Empty<Type>() : arguments.Select(a => a.GetType()).ToArray();
            Func<MethodInfo, bool> isMatch = m =>
            {
                if (m.Name != factoryMethod)
                    return false;
                var p = m.GetParameters();
                if (p.Length != types.Length)
                    return false;
                if (!m.IsStatic)
                    return false;
                for (var i = 0; i < p.Length; i++)
                {
                    if ((p[i].ParameterType.IsAssignableFrom(types[i])))
                        continue;
                    var op_impl = p[i].ParameterType.GetImplicitConversionOperator(fromType: types[i], toType: p[i].ParameterType)
                                ?? types[i].GetImplicitConversionOperator(fromType: types[i], toType: p[i].ParameterType);

                    if (op_impl == null)
                        return false;
                    arguments[i] = op_impl.Invoke(null, new[] { arguments[i] });
                }
                return true;
            };
            var mi = nodeType.GetRuntimeMethods().FirstOrDefault(isMatch);
            if (mi == null)
                throw new MissingMemberException($"No static method found for {nodeType.FullName}::{factoryMethod} ({string.Join(", ", types.Select(t => t.FullName))})");
            return mi.Invoke(null, arguments);
        }

        public object[] CreateArgumentsArray(IElementNode enode)
        {
            if (!enode.Properties.ContainsKey(XmlName.xArguments))
                return null;
            var node = enode.Properties[XmlName.xArguments];

            if (node is ElementNode elementNode)
            {
                var array = new object[1];
                array[0] = Values[elementNode];

                if (array[0].GetType().IsClass)
                {
                    elementNode.Accept(new ApplyPropertiesVisitor(Context, true), null);
                }

                return array;
            }

            if (node is ListNode listnode)
            {
                var array = new object[listnode.CollectionItems.Count];
                for (var i = 0; i < listnode.CollectionItems.Count; i++)
                    array[i] = Values[(ElementNode)listnode.CollectionItems[i]];
                return array;
            }
            return null;
        }

        public object[] CreateArgumentsArray(IElementNode enode, ConstructorInfo ctorInfo)
        {
            if (ctorInfo != null)
            {
                var n = ctorInfo.GetParameters().Length;
                var array = new object[n];
                for (var i = 0; i < n; i++)
                {
                    var parameter = ctorInfo.GetParameters()[i];
                    var name = new XmlName("", propname);
                    INode node;
                    if (!enode.Properties.TryGetValue(name, out node))
                    {
                        String msg = "";

                        if (parameter?.CustomAttributes?.First(attr => attr.AttributeType == typeof(ParameterAttribute))?.ConstructorArguments.First().Value is string propname)
                        {
                            msg = String.Format("The Property {0} is required to create a {1} object.", propname, ctorInfo.DeclaringType.FullName);
                        }
                        else
                        {
                            msg = "propname is null.";
                        }
                        throw new XamlParseException(msg, enode as IXmlLineInfo);
                    }
                    if (!enode.SkipProperties.Contains(name))
                        enode.SkipProperties.Add(name);
                    var value = Context.Values[node];
                    var serviceProvider = new XamlServiceProvider(enode, Context);
                    var convertedValue = value?.ConvertTo(parameter?.ParameterType, () => parameter, serviceProvider);
                    array[i] = convertedValue;
                }
                return array;
            }

            return null;
        }

        static bool IsXaml2009LanguagePrimitive(IElementNode node)
        {
            return node.NamespaceURI == XamlParser.X2009Uri;
        }

        static object CreateLanguagePrimitive(Type nodeType, IElementNode node)
        {
            object value = null;
            if (nodeType == typeof(string))
                value = String.Empty;
            else if (nodeType == typeof(Uri))
                value = null;
            else
            {
                value = Activator.CreateInstance(nodeType);
                if (value is Element)
                {
                    if (null != Application.Current)
                    {
                        Application.AddResourceChangedCallback(value, (value as Element).OnResourcesChanged);
                    }

                    if (value is BindableObject bindableObject)
                    {
                        bindableObject.IsCreateByXaml = true;
                    }
                }
            }

            if (node.CollectionItems.Count == 1 && node.CollectionItems[0] is ValueNode &&
                ((ValueNode)node.CollectionItems[0]).Value is string)
            {
                var valuestring = ((ValueNode)node.CollectionItems[0]).Value as string;

                if (nodeType == typeof(SByte))
                {
                    sbyte retval;
                    if (sbyte.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int16))
                {
                    short retval;
                    if (short.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int32))
                {
                    int retval;
                    if (int.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Int64))
                {
                    long retval;
                    if (long.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Byte))
                {
                    byte retval;
                    if (byte.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt16))
                {
                    ushort retval;
                    if (ushort.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt32))
                {
                    uint retval;
                    if (uint.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(UInt64))
                {
                    ulong retval;
                    if (ulong.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Single))
                {
                    float retval;
                    if (float.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Double))
                {
                    double retval;
                    if (double.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(Boolean))
                {
                    bool outbool;
                    if (bool.TryParse(valuestring, out outbool))
                        return outbool;
                }
                if (nodeType == typeof(TimeSpan))
                {
                    TimeSpan retval;
                    if (TimeSpan.TryParse(valuestring, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }
                if (nodeType == typeof(char))
                {
                    char retval;
                    if (char.TryParse(valuestring, out retval))
                        return retval;
                }
                if (nodeType == typeof(string))
                    return valuestring;
                if (nodeType == typeof(decimal))
                {
                    decimal retval;
                    if (decimal.TryParse(valuestring, NumberStyles.Number, CultureInfo.InvariantCulture, out retval))
                        return retval;
                }

                else if (nodeType == typeof(Uri))
                {
                    Uri retval;
                    if (Uri.TryCreate(valuestring, UriKind.RelativeOrAbsolute, out retval))
                        return retval;
                }
            }
            return value;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs(264,48): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?)
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs(263,48): error CS0234: The type or namespace name 'Array' does not exist in the namespace 'Tizen.System' (are you missing an assembly reference?),/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/CreateValuesVisitor.cs(330,48): error CS0103: The name 'propname' does not exist in the current context
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/TypeConversionExtensions.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
// using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Xaml.Internals;
using Tizen.NUI.Binding;

namespace Tizen.NUI.Xaml
{
    internal static class TypeConversionExtensions
    {
        internal static object ConvertTo(this object value, Type toType, Func<ParameterInfo> pinfoRetriever,
            IServiceProvider serviceProvider)
        {
            Func<TypeConverter> getConverter = () =>
            {
                ParameterInfo pInfo;
                if (pinfoRetriever == null || (pInfo = pinfoRetriever()) == null)
                    return null;

                var converterTypeName = pInfo.CustomAttributes.GetTypeConverterTypeName();
                if (converterTypeName == null)
                    return null;
                var convertertype = Type.GetType(converterTypeName);
                return (TypeConverter)Activator.CreateInstance(convertertype);
            };

            return ConvertTo(value, toType, getConverter, serviceProvider);
        }

        internal static object ConvertTo(this object value, Type toType, Func<MemberInfo> minfoRetriever,
            IServiceProvider serviceProvider)
        {
            Func<object> getConverter = () =>
            {
                MemberInfo memberInfo;
                string converterTypeName = null;
                Type realType = toType;

                if (true == realType.IsGenericType && typeof(Nullable<>) == realType.GetGenericTypeDefinition())
                {
                    realType = realType.GetGenericArguments()[0];
                }

                converterTypeName = realType.CustomAttributes.GetTypeConverterTypeName();
                if (minfoRetriever != null && (memberInfo = minfoRetriever()) != null)
                    converterTypeName = memberInfo.CustomAttributes.GetTypeConverterTypeName() ?? converterTypeName;

                if (converterTypeName == null)
                {
                    converterTypeName = toType.FullName + "TypeConverter";
                }

                var convertertype = Type.GetType(converterTypeName);

                if (null == convertertype)
                {
                    return null;
                }
                else
                {
                    return Activator.CreateInstance(convertertype);
                }
            };

            return ConvertTo(value, toType, getConverter, serviceProvider);
        }

        static string GetTypeConverterTypeName(this IEnumerable<CustomAttributeData> attributes)
        {
            var converterAttribute =
                attributes.FirstOrDefault(cad => TypeConverterAttribute.TypeConvertersType.Contains(cad.AttributeType.FullName));
            if (converterAttribute == null)
                return null;
            if (converterAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)converterAttribute.ConstructorArguments[0].Value;
            if (converterAttribute.ConstructorArguments[0].ArgumentType == typeof(Type))
                return ((Type)converterAttribute.ConstructorArguments[0].Value).AssemblyQualifiedName;
            return null;
        }

        //Don't change the name or the signature of this, it's used by XamlC
        public static object ConvertTo(this object value, Type toType, Type convertertype, IServiceProvider serviceProvider)
        {
            if (convertertype == null)
                return value.ConvertTo(toType, (Func<object>)null, serviceProvider);
            Func<object> getConverter = () => Activator.CreateInstance(convertertype);
            ;
            return value.ConvertTo(toType, getConverter, serviceProvider);
        }

        private delegate void ParseValueFunc(string s, IFormatProvider provider);

        static private Dictionary<Type, ParseValueFunc> typeToParseValueFunc = null;

        static private void BuildParseValueFunc()
        {
            if (null == typeToParseValueFunc)
            {
                typeToParseValueFunc = new Dictionary<Type, ParseValueFunc>();

            }
        }

        internal static object ConvertTo(this object value, Type toType, Func<object> getConverter,
            IServiceProvider serviceProvider)
        {
            if (value == null)
                return null;

            var str = value as string;
            if (str != null)
            {
                //If there's a [TypeConverter], use it
                object converter = getConverter?.Invoke();
                if (null != converter)
                {
                    var xfTypeConverter = converter as TypeConverter;
                    var xfExtendedTypeConverter = xfTypeConverter as IExtendedTypeConverter;
                    if (xfExtendedTypeConverter != null)
                        return value = xfExtendedTypeConverter.ConvertFromInvariantString(str, serviceProvider);
                    if (xfTypeConverter != null)
                        return value = xfTypeConverter.ConvertFromInvariantString(str);
                    var converterType = converter?.GetType();
                    if (converterType != null)
                    {
                        var convertFromStringInvariant = converterType.GetRuntimeMethod("ConvertFromInvariantString",
                            new[] { typeof(string) });
                        if (convertFromStringInvariant != null)
                            return value = convertFromStringInvariant.Invoke(converter, new object[] { str });
                    }
                }

                var ignoreCase = (serviceProvider?.GetService(typeof(IConverterOptions)) as IConverterOptions)?.IgnoreCase ?? false;

                //If the type is nullable, as the value is not null, it's safe to assume we want the built-in conversion
                if (toType.GetTypeInfo().IsGenericType && toType.GetGenericTypeDefinition() == typeof(Nullable<>))
                    toType = Nullable.GetUnderlyingType(toType);

                //Obvious Built-in conversions
                if (toType.GetTypeInfo().IsEnum)
                    return Enum.Parse(toType, str, ignoreCase);

                if (toType == typeof(SByte))
                    return SByte.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int16))
                    return Int16.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int32))
                    return Int32.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int64))
                    return Int64.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Byte))
                    return Byte.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt16))
                    return UInt16.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt32))
                    return UInt32.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt64))
                    return UInt64.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Single))
                    return Single.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Double))
                    return Double.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Boolean))
                    return Boolean.Parse(str);
                if (toType == typeof(TimeSpan))
                    return TimeSpan.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(DateTime))
                    return DateTime.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Char))
                {
                    char c = '\0';
                    _ = Char.TryParse(str, out c);
                    return c;
                }
                if (toType == typeof(String) && str.StartsWith("{}", StringComparison.Ordinal))
                    return str.Substring(2);
                if (toType == typeof(String))
                    return value;
                if (toType == typeof(Decimal))
                    return Decimal.Parse(str, CultureInfo.InvariantCulture);
            }

            //if the value is not assignable and there's an implicit conversion, convert
            if (value != null && !toType.IsAssignableFrom(value.GetType()))
            {
                var opImplicit = value.GetType().GetImplicitConversionOperator(fromType: value.GetType(), toType: toType)
                                ?? toType.GetImplicitConversionOperator(fromType: value.GetType(), toType: toType);

                if (opImplicit != null)
                {
                    value = opImplicit.Invoke(null, new[] { value });
                    return value;
                }
            }

            return value;
        }

        internal static MethodInfo GetImplicitConversionOperator(this Type onType, Type fromType, Type toType)
        {
#if NETSTANDARD1_0
            var mi = onType.GetRuntimeMethod("op_Implicit", new[] { fromType });
#else
            var bindingFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy;
            var mi = onType.GetMethod("op_Implicit", bindingFlags, null, new[] { fromType }, null);
#endif
            if (mi == null) return null;
            if (!mi.IsSpecialName) return null;
            if (!mi.IsPublic) return null;
            if (!mi.IsStatic) return null;
            if (!toType.IsAssignableFrom(mi.ReturnType)) return null;

            return mi;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
// using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Xaml.Internals;
using Tizen.NUI.Binding;

namespace Tizen.NUI.Xaml
{
    internal static class TypeConversionExtensions
    {
        internal static object ConvertTo(this object value, Type toType, Func<ParameterInfo> pinfoRetriever,
            IServiceProvider serviceProvider)
        {
            Func<TypeConverter> getConverter = () =>
            {
                ParameterInfo pInfo;
                if (pinfoRetriever == null || (pInfo = pinfoRetriever()) == null)
                    return null;

                var converterTypeName = pInfo.CustomAttributes.GetTypeConverterTypeName();
                if (converterTypeName == null)
                    return null;
                var convertertype = Type.GetType(converterTypeName);
                return (TypeConverter)Activator.CreateInstance(convertertype);
            };

            return ConvertTo(value, toType, getConverter, serviceProvider);
        }

        internal static object ConvertTo(this object value, Type toType, Func<MemberInfo> minfoRetriever,
            IServiceProvider serviceProvider)
        {
            Func<object> getConverter = () =>
            {
                MemberInfo memberInfo;
                string converterTypeName = null;
                Type realType = toType;

                if (true == realType.IsGenericType && typeof(Nullable<>) == realType.GetGenericTypeDefinition())
                {
                    realType = realType.GetGenericArguments()[0];
                }

                converterTypeName = realType.CustomAttributes.GetTypeConverterTypeName();
                if (minfoRetriever != null && (memberInfo = minfoRetriever()) != null)
                    converterTypeName = memberInfo.CustomAttributes.GetTypeConverterTypeName() ?? converterTypeName;

                if (converterTypeName == null)
                {
                    converterTypeName = toType.FullName + "TypeConverter";
                }

                var convertertype = Type.GetType(converterTypeName);

                if (null == convertertype)
                {
                    return null;
                }
                else
                {
                    return Activator.CreateInstance(convertertype);
                }
            };

            return ConvertTo(value, toType, getConverter, serviceProvider);
        }

        static string GetTypeConverterTypeName(this IEnumerable<CustomAttributeData> attributes)
        {
            var converterAttribute =
                attributes.FirstOrDefault(cad => TypeConverterAttribute.TypeConvertersType.Contains(cad.AttributeType.FullName));
            if (converterAttribute == null)
                return null;
            if (converterAttribute.ConstructorArguments[0].ArgumentType == typeof(string))
                return (string)converterAttribute.ConstructorArguments[0].Value;
            if (converterAttribute.ConstructorArguments[0].ArgumentType == typeof(Type))
                return ((Type)converterAttribute.ConstructorArguments[0].Value).AssemblyQualifiedName;
            return null;
        }

        //Don't change the name or the signature of this, it's used by XamlC
        public static object ConvertTo(this object value, Type toType, Type convertertype, IServiceProvider serviceProvider)
        {
            if (convertertype == null)
                return value.ConvertTo(toType, (Func<object>)null, serviceProvider);
            Func<object> getConverter = () => Activator.CreateInstance(convertertype);
            ;
            return value.ConvertTo(toType, getConverter, serviceProvider);
        }

        private delegate void ParseValueFunc(string s, IFormatProvider provider);

        static private Dictionary<Type, ParseValueFunc> typeToParseValueFunc = null;

        static private void BuildParseValueFunc()
        {
            if (null == typeToParseValueFunc)
            {
                typeToParseValueFunc = new Dictionary<Type, ParseValueFunc>();

            }
        }

        internal static object ConvertTo(this object value, Type toType, Func<object> getConverter,
            IServiceProvider serviceProvider)
        {
            if (value == null)
                return null;

            if (value is string str)
            {
                //If there's a [TypeConverter], use it
                object converter = getConverter?.Invoke();
                if (null != converter)
                {
                    if (xfTypeConverter is IExtendedTypeConverter xfExtendedTypeConverter)
                        return value = xfExtendedTypeConverter.ConvertFromInvariantString(str, serviceProvider);
                    if (converter is TypeConverter xfTypeConverter)
                        return value = xfTypeConverter.ConvertFromInvariantString(str);
                    var converterType = converter?.GetType();
                    if (converterType != null)
                    {
                        var convertFromStringInvariant = converterType.GetRuntimeMethod("ConvertFromInvariantString",
                            new[] { typeof(string) });
                        if (convertFromStringInvariant != null)
                            return value = convertFromStringInvariant.Invoke(converter, new object[] { str });
                    }
                }

                var ignoreCase = (serviceProvider?.GetService(typeof(IConverterOptions)) as IConverterOptions)?.IgnoreCase ?? false;

                //If the type is nullable, as the value is not null, it's safe to assume we want the built-in conversion
                if (toType.GetTypeInfo().IsGenericType && toType.GetGenericTypeDefinition() == typeof(Nullable<>))
                    toType = Nullable.GetUnderlyingType(toType);

                //Obvious Built-in conversions
                if (toType.GetTypeInfo().IsEnum)
                    return Enum.Parse(toType, str, ignoreCase);

                if (toType == typeof(SByte))
                    return SByte.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int16))
                    return Int16.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int32))
                    return Int32.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Int64))
                    return Int64.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Byte))
                    return Byte.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt16))
                    return UInt16.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt32))
                    return UInt32.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(UInt64))
                    return UInt64.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Single))
                    return Single.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Double))
                    return Double.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Boolean))
                    return Boolean.Parse(str);
                if (toType == typeof(TimeSpan))
                    return TimeSpan.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(DateTime))
                    return DateTime.Parse(str, CultureInfo.InvariantCulture);
                if (toType == typeof(Char))
                {
                    char c = '\0';
                    _ = Char.TryParse(str, out c);
                    return c;
                }
                if (toType == typeof(String) && str.StartsWith("{}", StringComparison.Ordinal))
                    return str.Substring(2);
                if (toType == typeof(String))
                    return value;
                if (toType == typeof(Decimal))
                    return Decimal.Parse(str, CultureInfo.InvariantCulture);
            }

            //if the value is not assignable and there's an implicit conversion, convert
            if (value != null && !toType.IsAssignableFrom(value.GetType()))
            {
                var opImplicit = value.GetType().GetImplicitConversionOperator(fromType: value.GetType(), toType: toType)
                                ?? toType.GetImplicitConversionOperator(fromType: value.GetType(), toType: toType);

                if (opImplicit != null)
                {
                    value = opImplicit.Invoke(null, new[] { value });
                    return value;
                }
            }

            return value;
        }

        internal static MethodInfo GetImplicitConversionOperator(this Type onType, Type fromType, Type toType)
        {
#if NETSTANDARD1_0
            var mi = onType.GetRuntimeMethod("op_Implicit", new[] { fromType });
#else
            var bindingFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy;
            var mi = onType.GetMethod("op_Implicit", bindingFlags, null, new[] { fromType }, null);
#endif
            if (mi == null) return null;
            if (!mi.IsSpecialName) return null;
            if (!mi.IsPublic) return null;
            if (!mi.IsStatic) return null;
            if (!toType.IsAssignableFrom(mi.ReturnType)) return null;

            return mi;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/TypeConversionExtensions.cs(50,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/TypeConversionExtensions.cs(162,25): error CS0841: Cannot use local variable 'xfTypeConverter' before it is declared,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/TypeConversionExtensions.cs(50,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Binding.Internals;

namespace Tizen.NUI.Xaml
{
    internal static class XamlParser
    {
        public const string XFUri = "http://tizen.org/Tizen.NUI/2018/XAML";
        public const string NUI2018Uri = "http://tizen.org/Tizen.NUI/2018/XAML";
        public const string X2006Uri = "http://schemas.microsoft.com/winfx/2006/xaml";
        public const string X2009Uri = "http://schemas.microsoft.com/winfx/2009/xaml";
        public const string McUri = "http://schemas.openxmlformats.org/markup-compatibility/2006";

        public static void ParseXaml(RootNode rootNode, XmlReader reader)
        {
            IList<KeyValuePair<string, string>> xmlns;
            var attributes = ParseXamlAttributes(reader, out xmlns);
            var prefixes = PrefixesToIgnore(xmlns);
            (rootNode.IgnorablePrefixes ?? (rootNode.IgnorablePrefixes = new List<string>())).AddRange(prefixes);
            rootNode.Properties.AddRange(attributes);
            ParseXamlElementFor(rootNode, reader);
        }

        static void ParseXamlElementFor(IElementNode node, XmlReader reader)
        {
            Debug.Assert(reader.NodeType == XmlNodeType.Element);

            var elementName = reader.Name;
            var isEmpty = reader.IsEmptyElement;

            if (isEmpty)
                return;

            while (reader.Read())
            {
                switch (reader.NodeType)
                {
                    case XmlNodeType.EndElement:
                        Debug.Assert(reader.Name == elementName); //make sure we close the right element
                        return;
                    case XmlNodeType.Element:
                        // 1. Property Element.
                        if (reader.Name.Contains("."))
                        {
                            XmlName name;
                            if (reader.Name.StartsWith(elementName + ".", StringComparison.Ordinal))
                                name = new XmlName(reader.NamespaceURI, reader.Name.Substring(elementName.Length + 1));
                            else //Attached DP
                                name = new XmlName(reader.NamespaceURI, reader.LocalName);

                            var prop = ReadNode(reader);
                            if (prop != null)
                                node.Properties.Add(name, prop);
                        }
                        // 2. Xaml2009 primitives, x:Arguments, ...
                        else if (reader.NamespaceURI == X2009Uri && reader.LocalName == "Arguments")
                        {
                            var prop = ReadNode(reader);
                            if (prop != null)
                                node.Properties.Add(XmlName.xArguments, prop);
                        }
                        // 3. DataTemplate (should be handled by 4.)
                        else if ((node.XmlType.NamespaceUri == XFUri || node.XmlType.NamespaceUri == NUI2018Uri) &&
                                 (node.XmlType.Name == "DataTemplate" || node.XmlType.Name == "ControlTemplate"))
                        {
                            var prop = ReadNode(reader, true);
                            if (prop != null)
                                node.Properties.Add(XmlName._CreateContent, prop);
                        }
                        // 4. Implicit content, implicit collection, or collection syntax. Add to CollectionItems, resolve case later.
                        else
                        {
                            var item = ReadNode(reader, true);
                            if (item != null)
                                node.CollectionItems.Add(item);
                        }
                        break;
                    case XmlNodeType.Whitespace:
                        break;
                    case XmlNodeType.Text:
                    case XmlNodeType.CDATA:
                        if (node.CollectionItems.Count == 1 && node.CollectionItems[0] is ValueNode)
                            ((ValueNode)node.CollectionItems[0]).Value += reader.Value.Trim();
                        else
                            node.CollectionItems.Add(new ValueNode(reader.Value.Trim(), (IXmlNamespaceResolver)reader));
                        break;
                    default:
                        Debug.WriteLine("Unhandled node {0} {1} {2}", reader.NodeType, reader.Name, reader.Value);
                        break;
                }
            }
        }

        static INode ReadNode(XmlReader reader, bool nested = false)
        {
            var skipFirstRead = nested;
            Debug.Assert(reader.NodeType == XmlNodeType.Element);
            var name = reader.Name;
            List<INode> nodes = new List<INode>();
            INode node = null;

            while (skipFirstRead || reader.Read())
            {
                skipFirstRead = false;

                switch (reader.NodeType)
                {
                    case XmlNodeType.EndElement:
                        Debug.Assert(reader.Name == name);
                        if (nodes.Count == 0) //Empty element
                            return null;
                        if (nodes.Count == 1)
                            return nodes[0];
                        return new ListNode(nodes, (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                            ((IXmlLineInfo)reader).LinePosition);
                    case XmlNodeType.Element:
                        var isEmpty = reader.IsEmptyElement && reader.Name == name;
                        var elementName = reader.Name;
                        var elementNsUri = reader.NamespaceURI;
                        var elementXmlInfo = (IXmlLineInfo)reader;
                        IList<KeyValuePair<string, string>> xmlns;

                        var attributes = ParseXamlAttributes(reader, out xmlns);
                        var prefixes = PrefixesToIgnore(xmlns);

                        IList<XmlType> typeArguments = null;
                        if (attributes.Any(kvp => kvp.Key == XmlName.xTypeArguments))
                        {
                            typeArguments =
                                ((ValueNode)attributes.First(kvp => kvp.Key == XmlName.xTypeArguments).Value).Value as IList<XmlType>;
                        }

                        node = new ElementNode(new XmlType(elementNsUri, elementName, typeArguments), elementNsUri,
                            reader as IXmlNamespaceResolver, elementXmlInfo.LineNumber, elementXmlInfo.LinePosition);
                        ((IElementNode)node).Properties.AddRange(attributes);
                        (node.IgnorablePrefixes ?? (node.IgnorablePrefixes = new List<string>()))?.AddRange(prefixes);

                        ParseXamlElementFor((IElementNode)node, reader);
                        nodes.Add(node);
                        if (isEmpty || nested)
                            return node;
                        break;
                    case XmlNodeType.Text:
                        node = new ValueNode(reader.Value.Trim(), (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                            ((IXmlLineInfo)reader).LinePosition);
                        nodes.Add(node);
                        break;
                    case XmlNodeType.Whitespace:
                        break;
                    default:
                        Debug.WriteLine("Unhandled node {0} {1} {2}", reader.NodeType, reader.Name, reader.Value);
                        break;
                }
            }
            throw new XamlParseException("Closing PropertyElement expected", (IXmlLineInfo)reader);
        }

        static IList<KeyValuePair<XmlName, INode>> ParseXamlAttributes(XmlReader reader, out IList<KeyValuePair<string, string>> xmlns)
        {
            Debug.Assert(reader.NodeType == XmlNodeType.Element);
            var attributes = new List<KeyValuePair<XmlName, INode>>();
            xmlns = new List<KeyValuePair<string, string>>();
            for (var i = 0; i < reader.AttributeCount; i++)
            {
                reader.MoveToAttribute(i);

                //skip xmlns
                if (reader.NamespaceURI == "http://www.w3.org/2000/xmlns/")
                {
                    xmlns.Add(new KeyValuePair<string, string>(reader.LocalName, reader.Value));
                    continue;
                }

                var namespaceUri = reader.NamespaceURI;
                if (reader.LocalName.Contains(".") && string.IsNullOrEmpty(namespaceUri))
                    namespaceUri = ((IXmlNamespaceResolver)reader).LookupNamespace("");
                var propertyName = new XmlName(namespaceUri, reader.LocalName);

                object value = reader.Value;

                if (reader.NamespaceURI == X2006Uri)
                {
                    switch (reader.Name)
                    {
                        case "x:Key":
                            propertyName = XmlName.xKey;
                            break;
                        case "x:Name":
                            propertyName = XmlName.xName;
                            break;
                        case "x:Class":
                        case "x:FieldModifier":
                            continue;
                        default:
                            Debug.WriteLine("Unhandled attribute {0}", reader.Name);
                            continue;
                    }
                }

                if (reader.NamespaceURI == X2009Uri)
                {
                    switch (reader.Name)
                    {
                        case "x:Key":
                            propertyName = XmlName.xKey;
                            break;
                        case "x:Name":
                            propertyName = XmlName.xName;
                            break;
                        case "x:TypeArguments":
                            propertyName = XmlName.xTypeArguments;
                            value = TypeArgumentsParser.ParseExpression((string)value, (IXmlNamespaceResolver)reader, (IXmlLineInfo)reader);
                            break;
                        case "x:DataType":
                            propertyName = XmlName.xDataType;
                            break;
                        case "x:Class":
                        case "x:FieldModifier":
                            continue;
                        case "x:FactoryMethod":
                            propertyName = XmlName.xFactoryMethod;
                            break;
                        case "x:Arguments":
                            propertyName = XmlName.xArguments;
                            break;
                        default:
                            Debug.WriteLine("Unhandled attribute {0}", reader.Name);
                            continue;
                    }
                }

                var propertyNode = GetValueNode(value, reader);
                attributes.Add(new KeyValuePair<XmlName, INode>(propertyName, propertyNode));
            }
            reader.MoveToElement();
            return attributes;
        }

        static IList<string> PrefixesToIgnore(IList<KeyValuePair<string, string>> xmlns)
        {
            var prefixes = new List<string>();
            foreach (var kvp in xmlns)
            {
                var prefix = kvp.Key;

                string typeName = null, ns = null, asm = null;
                XmlnsHelper.ParseXmlns(kvp.Value, out typeName, out ns, out asm);
            }
            return prefixes;
        }

        static IValueNode GetValueNode(object value, XmlReader reader)
        {
            var valueString = value as string;
            if (valueString != null && valueString.Trim().StartsWith("{}", StringComparison.Ordinal))
            {
                return new ValueNode(valueString.Substring(2), (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                    ((IXmlLineInfo)reader).LinePosition);
            }
            if (valueString != null && valueString.Trim().StartsWith("{", StringComparison.Ordinal))
            {
                return new MarkupNode(valueString.Trim(), reader as IXmlNamespaceResolver, ((IXmlLineInfo)reader).LineNumber,
                    ((IXmlLineInfo)reader).LinePosition);
            }
            return new ValueNode(value, (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                ((IXmlLineInfo)reader).LinePosition);
        }

        static IList<XmlnsDefinitionAttribute> s_xmlnsDefinitions;
        public static IList<Assembly> s_assemblies = new List<Assembly>();// = new Assembly[]{};

        static void GatherXmlnsDefinitionAttributes()
        {
            //this could be extended to look for [XmlnsDefinition] in all assemblies
            // var assemblies = new [] {
            // 	typeof(View).GetTypeInfo().Assembly,
            // 	//typeof(XamlLoader).GetTypeInfo().Assembly,
            // };
            // s_assemblies = new Assembly[]{typeof(View).GetTypeInfo().Assembly};
            s_assemblies.Add(typeof(View).GetTypeInfo().Assembly);

            s_xmlnsDefinitions = new List<XmlnsDefinitionAttribute>();

            foreach (var assembly in s_assemblies)
                foreach (XmlnsDefinitionAttribute attribute in assembly.GetCustomAttributes(typeof(XmlnsDefinitionAttribute)))
                {
                    s_xmlnsDefinitions.Add(attribute);
                    attribute.AssemblyName = attribute.AssemblyName ?? assembly.FullName;
                }
        }

        public static Type GetElementType(XmlType xmlType, IXmlLineInfo xmlInfo, Assembly currentAssembly,
            out XamlParseException exception)
        {
            if (s_xmlnsDefinitions == null)
                GatherXmlnsDefinitionAttributes();

            var namespaceURI = xmlType.NamespaceUri;
            var elementName = xmlType.Name;
            var typeArguments = xmlType.TypeArguments;
            exception = null;

            var lookupAssemblies = new List<XmlnsDefinitionAttribute>();
            var lookupNames = new List<string>();

            foreach (var xmlnsDef in s_xmlnsDefinitions)
            {
                if (xmlnsDef.XmlNamespace != namespaceURI)
                    continue;
                lookupAssemblies.Add(xmlnsDef);
            }

            if (lookupAssemblies.Count == 0)
            {
                string ns, asmstring, _;
                XmlnsHelper.ParseXmlns(namespaceURI, out _, out ns, out asmstring);
                lookupAssemblies.Add(new XmlnsDefinitionAttribute(namespaceURI, ns)
                {
                    AssemblyName = asmstring ?? currentAssembly.FullName
                });
            }

            lookupNames.Add(elementName);
            lookupNames.Add(elementName + "Extension");

            for (var i = 0; i < lookupNames.Count; i++)
            {
                var name = lookupNames[i];
                if (name.Contains(":"))
                    name = name.Substring(name.LastIndexOf(':') + 1);
                if (typeArguments != null)
                    name += "`" + typeArguments.Count; //this will return an open generic Type
                lookupNames[i] = name;
            }

            Type type = null;
            foreach (var asm in lookupAssemblies)
            {
                foreach (var name in lookupNames)
                {
                    if ((type = Type.GetType($"{asm.ClrNamespace}.{name}, {asm.AssemblyName}")) != null)
                        break;

                    if ('?' == name.Last())
                    {
                        string nameOfNotNull = name.Substring(0, name.Length - 1);
                        Type typeofNotNull = Type.GetType($"{asm.ClrNamespace}.{nameOfNotNull}, {asm.AssemblyName}");

                        if (null != typeofNotNull)
                        {
                            type = typeof(Nullable<>).MakeGenericType(new Type[] { typeofNotNull });
                            break;
                        }
                    }
                }

                if (type != null)
                    break;
            }

            if (type != null && typeArguments != null)
            {
                XamlParseException innerexception = null;
                var args = typeArguments.Select(delegate (XmlType xmltype)
                {
                    XamlParseException xpe;
                    var t = GetElementType(xmltype, xmlInfo, currentAssembly, out xpe);
                    if (xpe != null)
                    {
                        innerexception = xpe;
                        return null;
                    }
                    return t;
                }).ToArray();
                if (innerexception != null)
                {
                    exception = innerexception;
                    return null;
                }
                type = type.MakeGenericType(args);
            }

            if (type == null)
            {
                var message = $"Type {elementName} not found in xmlns {namespaceURI}\n";
                message += "\n  - Make sure the all used assemblies (e.g. Tizen.NUI.Components) are included in the application project.";
                message += "\n  - Make sure the type and namespace are correct.\n";
                exception = new XamlParseException($"message", xmlInfo);
            }

            return type;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding;
using Tizen.NUI.BaseComponents;
using Tizen.NUI.Binding.Internals;

namespace Tizen.NUI.Xaml
{
    internal static class XamlParser
    {
        public const string XFUri = "http://tizen.org/Tizen.NUI/2018/XAML";
        public const string NUI2018Uri = "http://tizen.org/Tizen.NUI/2018/XAML";
        public const string X2006Uri = "http://schemas.microsoft.com/winfx/2006/xaml";
        public const string X2009Uri = "http://schemas.microsoft.com/winfx/2009/xaml";
        public const string McUri = "http://schemas.openxmlformats.org/markup-compatibility/2006";

        public static void ParseXaml(RootNode rootNode, XmlReader reader)
        {
            IList<KeyValuePair<string, string>> xmlns;
            var attributes = ParseXamlAttributes(reader, out xmlns);
            var prefixes = PrefixesToIgnore(xmlns);
            (rootNode.IgnorablePrefixes ?? (rootNode.IgnorablePrefixes = new List<string>())).AddRange(prefixes);
            rootNode.Properties.AddRange(attributes);
            ParseXamlElementFor(rootNode, reader);
        }

        static void ParseXamlElementFor(IElementNode node, XmlReader reader)
        {
            Debug.Assert(reader.NodeType == XmlNodeType.Element);

            var elementName = reader.Name;
            var isEmpty = reader.IsEmptyElement;

            if (isEmpty)
                return;

            while (reader.Read())
            {
                switch (reader.NodeType)
                {
                    case XmlNodeType.EndElement:
                        Debug.Assert(reader.Name == elementName); //make sure we close the right element
                        return;
                    case XmlNodeType.Element:
                        // 1. Property Element.
                        if (reader.Name.Contains("."))
                        {
                            XmlName name;
                            if (reader.Name.StartsWith(elementName + ".", StringComparison.Ordinal))
                                name = new XmlName(reader.NamespaceURI, reader.Name.Substring(elementName.Length + 1));
                            else //Attached DP
                                name = new XmlName(reader.NamespaceURI, reader.LocalName);

                            var prop = ReadNode(reader);
                            if (prop != null)
                                node.Properties.Add(name, prop);
                        }
                        // 2. Xaml2009 primitives, x:Arguments, ...
                        else if (reader.NamespaceURI == X2009Uri && reader.LocalName == "Arguments")
                        {
                            var prop = ReadNode(reader);
                            if (prop != null)
                                node.Properties.Add(XmlName.xArguments, prop);
                        }
                        // 3. DataTemplate (should be handled by 4.)
                        else if ((node.XmlType.NamespaceUri == XFUri || node.XmlType.NamespaceUri == NUI2018Uri) &&
                                 (node.XmlType.Name == "DataTemplate" || node.XmlType.Name == "ControlTemplate"))
                        {
                            var prop = ReadNode(reader, true);
                            if (prop != null)
                                node.Properties.Add(XmlName._CreateContent, prop);
                        }
                        // 4. Implicit content, implicit collection, or collection syntax. Add to CollectionItems, resolve case later.
                        else
                        {
                            var item = ReadNode(reader, true);
                            if (item != null)
                                node.CollectionItems.Add(item);
                        }
                        break;
                    case XmlNodeType.Whitespace:
                        break;
                    case XmlNodeType.Text:
                    case XmlNodeType.CDATA:
                        if (node.CollectionItems.Count == 1 && node.CollectionItems[0] is ValueNode)
                            ((ValueNode)node.CollectionItems[0]).Value += reader.Value.Trim();
                        else
                            node.CollectionItems.Add(new ValueNode(reader.Value.Trim(), (IXmlNamespaceResolver)reader));
                        break;
                    default:
                        Debug.WriteLine("Unhandled node {0} {1} {2}", reader.NodeType, reader.Name, reader.Value);
                        break;
                }
            }
        }

        static INode ReadNode(XmlReader reader, bool nested = false)
        {
            var skipFirstRead = nested;
            Debug.Assert(reader.NodeType == XmlNodeType.Element);
            var name = reader.Name;
            List<INode> nodes = new List<INode>();
            INode node = null;

            while (skipFirstRead || reader.Read())
            {
                skipFirstRead = false;

                switch (reader.NodeType)
                {
                    case XmlNodeType.EndElement:
                        Debug.Assert(reader.Name == name);
                        if (nodes.Count == 0) //Empty element
                            return null;
                        if (nodes.Count == 1)
                            return nodes[0];
                        return new ListNode(nodes, (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                            ((IXmlLineInfo)reader).LinePosition);
                    case XmlNodeType.Element:
                        var isEmpty = reader.IsEmptyElement && reader.Name == name;
                        var elementName = reader.Name;
                        var elementNsUri = reader.NamespaceURI;
                        var elementXmlInfo = (IXmlLineInfo)reader;
                        IList<KeyValuePair<string, string>> xmlns;

                        var attributes = ParseXamlAttributes(reader, out xmlns);
                        var prefixes = PrefixesToIgnore(xmlns);

                        IList<XmlType> typeArguments = null;
                        if (attributes.Any(kvp => kvp.Key == XmlName.xTypeArguments))
                        {
                            typeArguments =
                                ((ValueNode)attributes.First(kvp => kvp.Key == XmlName.xTypeArguments).Value).Value as IList<XmlType>;
                        }

                        node = new ElementNode(new XmlType(elementNsUri, elementName, typeArguments), elementNsUri,
                            reader as IXmlNamespaceResolver, elementXmlInfo.LineNumber, elementXmlInfo.LinePosition);
                        ((IElementNode)node).Properties.AddRange(attributes);
                        (node.IgnorablePrefixes ?? (node.IgnorablePrefixes = new List<string>()))?.AddRange(prefixes);

                        ParseXamlElementFor((IElementNode)node, reader);
                        nodes.Add(node);
                        if (isEmpty || nested)
                            return node;
                        break;
                    case XmlNodeType.Text:
                        node = new ValueNode(reader.Value.Trim(), (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                            ((IXmlLineInfo)reader).LinePosition);
                        nodes.Add(node);
                        break;
                    case XmlNodeType.Whitespace:
                        break;
                    default:
                        Debug.WriteLine("Unhandled node {0} {1} {2}", reader.NodeType, reader.Name, reader.Value);
                        break;
                }
            }
            throw new XamlParseException("Closing PropertyElement expected", (IXmlLineInfo)reader);
        }

        static IList<KeyValuePair<XmlName, INode>> ParseXamlAttributes(XmlReader reader, out IList<KeyValuePair<string, string>> xmlns)
        {
            Debug.Assert(reader.NodeType == XmlNodeType.Element);
            var attributes = new List<KeyValuePair<XmlName, INode>>();
            xmlns = new List<KeyValuePair<string, string>>();
            for (var i = 0; i < reader.AttributeCount; i++)
            {
                reader.MoveToAttribute(i);

                //skip xmlns
                if (reader.NamespaceURI == "http://www.w3.org/2000/xmlns/")
                {
                    xmlns.Add(new KeyValuePair<string, string>(reader.LocalName, reader.Value));
                    continue;
                }

                var namespaceUri = reader.NamespaceURI;
                if (reader.LocalName.Contains(".") && string.IsNullOrEmpty(namespaceUri))
                    namespaceUri = ((IXmlNamespaceResolver)reader).LookupNamespace("");
                var propertyName = new XmlName(namespaceUri, reader.LocalName);

                object value = reader.Value;

                if (reader.NamespaceURI == X2006Uri)
                {
                    switch (reader.Name)
                    {
                        case "x:Key":
                            propertyName = XmlName.xKey;
                            break;
                        case "x:Name":
                            propertyName = XmlName.xName;
                            break;
                        case "x:Class":
                        case "x:FieldModifier":
                            continue;
                        default:
                            Debug.WriteLine("Unhandled attribute {0}", reader.Name);
                            continue;
                    }
                }

                if (reader.NamespaceURI == X2009Uri)
                {
                    switch (reader.Name)
                    {
                        case "x:Key":
                            propertyName = XmlName.xKey;
                            break;
                        case "x:Name":
                            propertyName = XmlName.xName;
                            break;
                        case "x:TypeArguments":
                            propertyName = XmlName.xTypeArguments;
                            value = TypeArgumentsParser.ParseExpression((string)value, (IXmlNamespaceResolver)reader, (IXmlLineInfo)reader);
                            break;
                        case "x:DataType":
                            propertyName = XmlName.xDataType;
                            break;
                        case "x:Class":
                        case "x:FieldModifier":
                            continue;
                        case "x:FactoryMethod":
                            propertyName = XmlName.xFactoryMethod;
                            break;
                        case "x:Arguments":
                            propertyName = XmlName.xArguments;
                            break;
                        default:
                            Debug.WriteLine("Unhandled attribute {0}", reader.Name);
                            continue;
                    }
                }

                var propertyNode = GetValueNode(value, reader);
                attributes.Add(new KeyValuePair<XmlName, INode>(propertyName, propertyNode));
            }
            reader.MoveToElement();
            return attributes;
        }

        static IList<string> PrefixesToIgnore(IList<KeyValuePair<string, string>> xmlns)
        {
            var prefixes = new List<string>();
            foreach (var kvp in xmlns)
            {
                var prefix = kvp.Key;

                string typeName = null, ns = null, asm = null;
                XmlnsHelper.ParseXmlns(kvp.Value, out typeName, out ns, out asm);
            }
            return prefixes;
        }

        static IValueNode GetValueNode(object value, XmlReader reader)
        {
            if (value is string valueString && valueString.Trim().StartsWith("{}", StringComparison.Ordinal))
            {
                return new ValueNode(valueString.Substring(2), (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                    ((IXmlLineInfo)reader).LinePosition);
            }

            if (value is string valueString && valueString.Trim().StartsWith("{", StringComparison.Ordinal))
            {
                return new MarkupNode(valueString.Trim(), reader as IXmlNamespaceResolver, ((IXmlLineInfo)reader).LineNumber,
                    ((IXmlLineInfo)reader).LinePosition);
            }
            return new ValueNode(value, (IXmlNamespaceResolver)reader, ((IXmlLineInfo)reader).LineNumber,
                ((IXmlLineInfo)reader).LinePosition);
        }

        static IList<XmlnsDefinitionAttribute> s_xmlnsDefinitions;
        public static IList<Assembly> s_assemblies = new List<Assembly>();// = new Assembly[]{};

        static void GatherXmlnsDefinitionAttributes()
        {
            //this could be extended to look for [XmlnsDefinition] in all assemblies
            // var assemblies = new [] {
            // 	typeof(View).GetTypeInfo().Assembly,
            // 	//typeof(XamlLoader).GetTypeInfo().Assembly,
            // };
            // s_assemblies = new Assembly[]{typeof(View).GetTypeInfo().Assembly};
            s_assemblies.Add(typeof(View).GetTypeInfo().Assembly);

            s_xmlnsDefinitions = new List<XmlnsDefinitionAttribute>();

            foreach (var assembly in s_assemblies)
                foreach (XmlnsDefinitionAttribute attribute in assembly.GetCustomAttributes(typeof(XmlnsDefinitionAttribute)))
                {
                    s_xmlnsDefinitions.Add(attribute);
                    attribute.AssemblyName = attribute.AssemblyName ?? assembly.FullName;
                }
        }

        public static Type GetElementType(XmlType xmlType, IXmlLineInfo xmlInfo, Assembly currentAssembly,
            out XamlParseException exception)
        {
            if (s_xmlnsDefinitions == null)
                GatherXmlnsDefinitionAttributes();

            var namespaceURI = xmlType.NamespaceUri;
            var elementName = xmlType.Name;
            var typeArguments = xmlType.TypeArguments;
            exception = null;

            var lookupAssemblies = new List<XmlnsDefinitionAttribute>();
            var lookupNames = new List<string>();

            foreach (var xmlnsDef in s_xmlnsDefinitions)
            {
                if (xmlnsDef.XmlNamespace != namespaceURI)
                    continue;
                lookupAssemblies.Add(xmlnsDef);
            }

            if (lookupAssemblies.Count == 0)
            {
                string ns, asmstring, _;
                XmlnsHelper.ParseXmlns(namespaceURI, out _, out ns, out asmstring);
                lookupAssemblies.Add(new XmlnsDefinitionAttribute(namespaceURI, ns)
                {
                    AssemblyName = asmstring ?? currentAssembly.FullName
                });
            }

            lookupNames.Add(elementName);
            lookupNames.Add(elementName + "Extension");

            for (var i = 0; i < lookupNames.Count; i++)
            {
                var name = lookupNames[i];
                if (name.Contains(":"))
                    name = name.Substring(name.LastIndexOf(':') + 1);
                if (typeArguments != null)
                    name += "`" + typeArguments.Count; //this will return an open generic Type
                lookupNames[i] = name;
            }

            Type type = null;
            foreach (var asm in lookupAssemblies)
            {
                foreach (var name in lookupNames)
                {
                    if ((type = Type.GetType($"{asm.ClrNamespace}.{name}, {asm.AssemblyName}")) != null)
                        break;

                    if ('?' == name.Last())
                    {
                        string nameOfNotNull = name.Substring(0, name.Length - 1);
                        Type typeofNotNull = Type.GetType($"{asm.ClrNamespace}.{nameOfNotNull}, {asm.AssemblyName}");

                        if (null != typeofNotNull)
                        {
                            type = typeof(Nullable<>).MakeGenericType(new Type[] { typeofNotNull });
                            break;
                        }
                    }
                }

                if (type != null)
                    break;
            }

            if (type != null && typeArguments != null)
            {
                XamlParseException innerexception = null;
                var args = typeArguments.Select(delegate (XmlType xmltype)
                {
                    XamlParseException xpe;
                    var t = GetElementType(xmltype, xmlInfo, currentAssembly, out xpe);
                    if (xpe != null)
                    {
                        innerexception = xpe;
                        return null;
                    }
                    return t;
                }).ToArray();
                if (innerexception != null)
                {
                    exception = innerexception;
                    return null;
                }
                type = type.MakeGenericType(args);
            }

            if (type == null)
            {
                var message = $"Type {elementName} not found in xmlns {namespaceURI}\n";
                message += "\n  - Make sure the all used assemblies (e.g. Tizen.NUI.Components) are included in the application project.";
                message += "\n  - Make sure the type and namespace are correct.\n";
                exception = new XamlParseException($"message", xmlInfo);
            }

            return type;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(50,1): hidden CS8019: Unnecessary using directive.,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(52,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(310,33): error CS0128: A local variable or function named 'valueString' is already defined in this scope,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(310,48): error CS0165: Use of unassigned local variable 'valueString',/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(50,1): hidden CS8019: Unnecessary using directive.,/home/vsts/work/1/s/src/Tizen.NUI/src/internal/Xaml/XamlParser.cs(52,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindablePropertyConverter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Xaml;

namespace Tizen.NUI.Binding
{
    /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
    [EditorBrowsable(EditorBrowsableState.Never)]
    [ProvideCompiled("Tizen.NUI.Xaml.Core.XamlC.BindablePropertyConverter")]
    [TypeConversion(typeof(BindableProperty))]
    public sealed class BindablePropertyConverter : TypeConverter, IExtendedTypeConverter
    {
        object IExtendedTypeConverter.ConvertFrom(CultureInfo culture, object value, IServiceProvider serviceProvider)
        {
            return ((IExtendedTypeConverter)this).ConvertFromInvariantString(value as string, serviceProvider);
        }

        object IExtendedTypeConverter.ConvertFromInvariantString(string value, IServiceProvider serviceProvider)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;
            if (serviceProvider == null)
                return null;
            var parentValuesProvider = serviceProvider.GetService(typeof(IProvideValueTarget)) as IProvideParentValues;
            var typeResolver = serviceProvider.GetService(typeof(IXamlTypeResolver)) as IXamlTypeResolver;
            if (typeResolver == null)
                return null;
            IXmlLineInfo lineinfo = null;
            var xmlLineInfoProvider = serviceProvider.GetService(typeof(IXmlLineInfoProvider)) as IXmlLineInfoProvider;
            if (xmlLineInfoProvider != null)
                lineinfo = xmlLineInfoProvider.XmlLineInfo;
            string[] parts = value.Split('.');
            Type type = null;
            if (parts.Length == 1)
            {
                if (parentValuesProvider == null)
                {
                    string msg = string.Format("Can't resolve {0}", parts[0]);
                    throw new XamlParseException(msg, lineinfo);
                }
                object parent = parentValuesProvider.ParentObjects.Skip(1).FirstOrDefault();
                if (parentValuesProvider.TargetObject is Setter)
                {
                    var triggerBase = parent as TriggerBase;
                    var visualState = parent as VisualState;
                    if (triggerBase != null)
                        type = triggerBase.TargetType;
                    else if (visualState != null)
                        type = FindTypeForVisualState(parentValuesProvider, lineinfo);
                }
                else if (parentValuesProvider.TargetObject is Trigger)
                    type = (parentValuesProvider.TargetObject as Trigger).TargetType;
                else if (parentValuesProvider.TargetObject is XamlPropertyCondition && (parent as TriggerBase) != null)
                    type = (parent as TriggerBase).TargetType;

                if (type == null)
                    throw new XamlParseException($"Can't resolve {parts[0]}", lineinfo);

                return ConvertFrom(type, parts[0], lineinfo);
            }
            if (parts.Length == 2)
            {
                if (!typeResolver.TryResolve(parts[0], out type))
                {
                    string msg = string.Format("Can't resolve {0}", parts[0]);
                    throw new XamlParseException(msg, lineinfo);
                }
                return ConvertFrom(type, parts[1], lineinfo);
            }
            throw new XamlParseException($"Can't resolve {value}. Syntax is [[prefix:]Type.]PropertyName.", lineinfo);
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override object ConvertFromInvariantString(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;
            if (value.Contains(":"))
            {
                Console.WriteLine(null, "Can't resolve properties with xml namespace prefix.");
                return null;
            }
            string[] parts = value.Split('.');
            if (parts.Length != 2)
            {
                Console.WriteLine(null, $"Can't resolve {value}. Accepted syntax is Type.PropertyName.");
                return null;
            }
            Type type = Type.GetType("Tizen.NUI." + parts[0]);
            return ConvertFrom(type, parts[1], null);
        }

        BindableProperty ConvertFrom(Type type, string propertyName, IXmlLineInfo lineinfo)
        {
            string name = propertyName + "Property";
            FieldInfo bpinfo = type.GetField(fi => fi.Name == name && fi.IsStatic && fi.IsPublic && fi.FieldType == typeof(BindableProperty));
            if (bpinfo == null)
                throw new XamlParseException($"Can't resolve {name} on {type.Name}", lineinfo);
            var bp = bpinfo.GetValue(null) as BindableProperty;
            var isObsolete = bpinfo.GetCustomAttribute<ObsoleteAttribute>() != null;
            if (bp != null && bp.PropertyName != propertyName && !isObsolete)
                throw new XamlParseException($"The PropertyName of {type.Name}.{name} is not {propertyName}", lineinfo);
            return bp;
        }

        Type FindTypeForVisualState(IProvideParentValues parentValueProvider, IXmlLineInfo lineInfo)
        {
            var parents = parentValueProvider.ParentObjects.ToList();

            // Skip 0; we would not be making this check if TargetObject were not a Setter
            // Skip 1; we would not be making this check if the immediate parent were not a VisualState

            // VisualStates must be in a VisualStateGroup
            if (!(parents[2] is VisualStateGroup))
            {
                throw new XamlParseException($"Expected {nameof(VisualStateGroup)} but found {parents[2]}.", lineInfo);
            }

            var vsTarget = parents[3];

            // Are these Visual States directly on a VisualElement?
            if (vsTarget is /*VisualElement*/BaseHandle)
            {
                return vsTarget.GetType();
            }

            if (!(parents[3] is VisualStateGroupList))
            {
                throw new XamlParseException($"Expected {nameof(VisualStateGroupList)} but found {parents[3]}.", lineInfo);
            }

            if (!(parents[4] is Setter))
            {
                throw new XamlParseException($"Expected {nameof(Setter)} but found {parents[4]}.", lineInfo);
            }

            throw new XamlParseException("NUI doesn't support VisualState", lineInfo);

        }
    }
}

---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Xml;
using Tizen.NUI.Binding.Internals;
using Tizen.NUI.Xaml;

namespace Tizen.NUI.Binding
{
    /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
    [EditorBrowsable(EditorBrowsableState.Never)]
    [ProvideCompiled("Tizen.NUI.Xaml.Core.XamlC.BindablePropertyConverter")]
    [TypeConversion(typeof(BindableProperty))]
    public sealed class BindablePropertyConverter : TypeConverter, IExtendedTypeConverter
    {
        object IExtendedTypeConverter.ConvertFrom(CultureInfo culture, object value, IServiceProvider serviceProvider)
        {
            return ((IExtendedTypeConverter)this).ConvertFromInvariantString(value as string, serviceProvider);
        }

        object IExtendedTypeConverter.ConvertFromInvariantString(string value, IServiceProvider serviceProvider)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;
            if (serviceProvider == null)
                return null;
            var parentValuesProvider = serviceProvider.GetService(typeof(IProvideValueTarget)) as IProvideParentValues;
            var typeResolver = serviceProvider.GetService(typeof(IXamlTypeResolver)) as IXamlTypeResolver;
            if (typeResolver == null)
                return null;
            IXmlLineInfo lineinfo = null;

            if (serviceProvider.GetService(typeof(IXmlLineInfoProvider)) is IXmlLineInfoProvider xmlLineInfoProvider)
                lineinfo = xmlLineInfoProvider.XmlLineInfo;
            string[] parts = value.Split('.');
            Type type = null;
            if (parts.Length == 1)
            {
                if (parentValuesProvider == null)
                {
                    string msg = string.Format("Can't resolve {0}", parts[0]);
                    throw new XamlParseException(msg, lineinfo);
                }
                object parent = parentValuesProvider.ParentObjects.Skip(1).FirstOrDefault();
                if (parentValuesProvider.TargetObject is Setter)
                {
                    if (parent is TriggerBase triggerBase)
                        type = triggerBase.TargetType;
                    else if (parent is VisualState visualState)
                        type = FindTypeForVisualState(parentValuesProvider, lineinfo);
                }
                else if (parentValuesProvider.TargetObject is Trigger)
                    type = (parentValuesProvider.TargetObject as Trigger).TargetType;
                else if (parentValuesProvider.TargetObject is XamlPropertyCondition && (parent as TriggerBase) != null)
                    type = (parent as TriggerBase).TargetType;

                if (type == null)
                    throw new XamlParseException($"Can't resolve {parts[0]}", lineinfo);

                return ConvertFrom(type, parts[0], lineinfo);
            }
            if (parts.Length == 2)
            {
                if (!typeResolver.TryResolve(parts[0], out type))
                {
                    string msg = string.Format("Can't resolve {0}", parts[0]);
                    throw new XamlParseException(msg, lineinfo);
                }
                return ConvertFrom(type, parts[1], lineinfo);
            }
            throw new XamlParseException($"Can't resolve {value}. Syntax is [[prefix:]Type.]PropertyName.", lineinfo);
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public override object ConvertFromInvariantString(string value)
        {
            if (string.IsNullOrWhiteSpace(value))
                return null;
            if (value.Contains(":"))
            {
                Console.WriteLine(null, "Can't resolve properties with xml namespace prefix.");
                return null;
            }
            string[] parts = value.Split('.');
            if (parts.Length != 2)
            {
                Console.WriteLine(null, $"Can't resolve {value}. Accepted syntax is Type.PropertyName.");
                return null;
            }
            Type type = Type.GetType("Tizen.NUI." + parts[0]);
            return ConvertFrom(type, parts[1], null);
        }

        BindableProperty ConvertFrom(Type type, string propertyName, IXmlLineInfo lineinfo)
        {
            string name = propertyName + "Property";
            FieldInfo bpinfo = type.GetField(fi => fi.Name == name && fi.IsStatic && fi.IsPublic && fi.FieldType == typeof(BindableProperty));
            if (bpinfo == null)
                throw new XamlParseException($"Can't resolve {name} on {type.Name}", lineinfo);
            var isObsolete = bpinfo.GetCustomAttribute<ObsoleteAttribute>() != null;
            if (bpinfo.GetValue(null) is BindableProperty bp && bp.PropertyName != propertyName && !isObsolete)
                throw new XamlParseException($"The PropertyName of {type.Name}.{name} is not {propertyName}", lineinfo);
            return bp;
        }

        Type FindTypeForVisualState(IProvideParentValues parentValueProvider, IXmlLineInfo lineInfo)
        {
            var parents = parentValueProvider.ParentObjects.ToList();

            // Skip 0; we would not be making this check if TargetObject were not a Setter
            // Skip 1; we would not be making this check if the immediate parent were not a VisualState

            // VisualStates must be in a VisualStateGroup
            if (!(parents[2] is VisualStateGroup))
            {
                throw new XamlParseException($"Expected {nameof(VisualStateGroup)} but found {parents[2]}.", lineInfo);
            }

            var vsTarget = parents[3];

            // Are these Visual States directly on a VisualElement?
            if (vsTarget is /*VisualElement*/BaseHandle)
            {
                return vsTarget.GetType();
            }

            if (!(parents[3] is VisualStateGroupList))
            {
                throw new XamlParseException($"Expected {nameof(VisualStateGroupList)} but found {parents[3]}.", lineInfo);
            }

            if (!(parents[4] is Setter))
            {
                throw new XamlParseException($"Expected {nameof(Setter)} but found {parents[4]}.", lineInfo);
            }

            throw new XamlParseException("NUI doesn't support VisualState", lineInfo);

        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/BindablePropertyConverter.cs(122,20): error CS0165: Use of unassigned local variable 'bp'
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: /home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Binding.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Diagnostics.CodeAnalysis;

namespace Tizen.NUI.Binding
{
    /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
    [SuppressMessage("Microsoft.Design", "CA1724: Type names should not match namespaces")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public sealed class Binding : BindingBase
    {
        internal const string SelfPath = ".";
        IValueConverter converter;
        object converterParameter;

        BindingExpression expression;
        string path;
        object source;
        string updateSourceEventName;

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Binding()
        {
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Binding(string path, BindingMode mode = BindingMode.Default, IValueConverter converter = null, object converterParameter = null, string stringFormat = null, object source = null)
        {
            if (path == null)
                throw new ArgumentNullException(nameof(path));
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("path can not be an empty string", nameof(path));

            Path = path;
            Converter = converter;
            ConverterParameter = converterParameter;
            Mode = mode;
            StringFormat = stringFormat;
            Source = source;
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IValueConverter Converter
        {
            get { return converter; }
            set
            {
                ThrowIfApplied();

                converter = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public object ConverterParameter
        {
            get { return converterParameter; }
            set
            {
                ThrowIfApplied();

                converterParameter = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string Path
        {
            get { return path; }
            set
            {
                ThrowIfApplied();

                path = value;
                expression = new BindingExpression(this, !string.IsNullOrWhiteSpace(value) ? value : SelfPath);
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public object Source
        {
            get { return source; }
            set
            {
                ThrowIfApplied();
                source = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string UpdateSourceEventName
        {
            get { return updateSourceEventName; }
            set
            {
                ThrowIfApplied();
                updateSourceEventName = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        [ObsoleteAttribute(" ", false)]
        public static Binding Create<TSource>(Expression<Func<TSource, object>> propertyGetter, BindingMode mode = BindingMode.Default, IValueConverter converter = null, object converterParameter = null,
                                              string stringFormat = null)
        {
            if (propertyGetter == null)
                throw new ArgumentNullException(nameof(propertyGetter));

            return new Binding(GetBindingPath(propertyGetter), mode, converter, converterParameter, stringFormat);
        }

        internal override void Apply(bool fromTarget)
        {
            base.Apply(fromTarget);

            if (expression == null)
                expression = new BindingExpression(this, SelfPath);

            expression.Apply(fromTarget);
        }

        internal override void Apply(object newContext, BindableObject bindObj, BindableProperty targetProperty, bool fromBindingContextChanged = false)
        {
            object src = source;
            var isApplied = IsApplied;

            base.Apply(src ?? newContext, bindObj, targetProperty, fromBindingContextChanged: fromBindingContextChanged);

            if (src != null && isApplied && fromBindingContextChanged)
                return;

            object bindingContext = src ?? Context ?? newContext;
            if (expression == null && bindingContext != null)
                expression = new BindingExpression(this, SelfPath);

            expression?.Apply(bindingContext, bindObj, targetProperty);
        }

        internal override BindingBase Clone()
        {
            return new Binding(Path, Mode) { Converter = Converter, ConverterParameter = ConverterParameter, StringFormat = StringFormat, Source = Source, UpdateSourceEventName = UpdateSourceEventName };
        }

        internal override object GetSourceValue(object value, Type targetPropertyType)
        {
            if (Converter != null)
                value = Converter.Convert(value, targetPropertyType, ConverterParameter, CultureInfo.CurrentUICulture);

            return base.GetSourceValue(value, targetPropertyType);
        }

        internal override object GetTargetValue(object value, Type sourcePropertyType)
        {
            if (Converter != null)
                value = Converter.ConvertBack(value, sourcePropertyType, ConverterParameter, CultureInfo.CurrentUICulture);

            return base.GetTargetValue(value, sourcePropertyType);
        }

        internal override void Unapply(bool fromBindingContextChanged = false)
        {
            if (Source != null && fromBindingContextChanged && IsApplied)
                return;

            base.Unapply(fromBindingContextChanged: fromBindingContextChanged);

            if (expression != null)
                expression.Unapply();
        }

        [Obsolete]
        static string GetBindingPath<TSource>(Expression<Func<TSource, object>> propertyGetter)
        {
            Expression expr = propertyGetter.Body;

            var unary = expr as UnaryExpression;
            if (unary != null)
                expr = unary.Operand;

            var builder = new StringBuilder();

            var indexed = false;

            var member = expr as MemberExpression;
            if (member == null)
            {
                var methodCall = expr as MethodCallExpression;
                if (methodCall != null)
                {
                    if (methodCall.Arguments.Count == 0)
                        throw new ArgumentException("Method calls are not allowed in binding expression");

                    var arguments = new List<string>(methodCall.Arguments.Count);
                    foreach (Expression arg in methodCall.Arguments)
                    {
                        if (arg.NodeType != ExpressionType.Constant)
                            throw new ArgumentException("Only constants can be used as indexer arguments");

                        object value = ((ConstantExpression)arg).Value;
                        arguments.Add(value != null ? value.ToString() : "null");
                    }

                    Type declarerType = methodCall.Method.DeclaringType;
                    DefaultMemberAttribute defaultMember = declarerType.GetTypeInfo().GetCustomAttributes(typeof(DefaultMemberAttribute), true).OfType<DefaultMemberAttribute>().FirstOrDefault();
                    string indexerName = defaultMember != null ? defaultMember.MemberName : "Item";

                    MethodInfo getterInfo =
                        declarerType.GetProperties().Where(pi => (pi.GetMethod != null) && pi.Name == indexerName && pi.CanRead && pi.GetMethod.IsPublic && !pi.GetMethod.IsStatic).Select(pi => pi.GetMethod).FirstOrDefault();
                    if (getterInfo != null)
                    {
                        if (getterInfo == methodCall.Method)
                        {
                            indexed = true;
                            builder.Append("[");

                            var first = true;
                            foreach (string argument in arguments)
                            {
                                if (!first)
                                    builder.Append(",");

                                builder.Append(argument);
                                first = false;
                            }

                            builder.Append("]");

                            member = methodCall.Object as MemberExpression;
                        }
                        else
                            throw new ArgumentException("Method calls are not allowed in binding expressions");
                    }
                    else
                        throw new ArgumentException("Public indexer not found");
                }
                else
                    throw new ArgumentException("Invalid expression type");
            }

            while (member != null)
            {
                var property = (PropertyInfo)member.Member;
                if (builder.Length != 0)
                {
                    if (!indexed)
                        builder.Insert(0, ".");
                    else
                        indexed = false;
                }

                builder.Insert(0, property.Name);

                //				member = member.Expression as MemberExpression ?? (member.Expression as UnaryExpression)?.Operand as MemberExpression;
                member = member.Expression as MemberExpression ?? (member.Expression is UnaryExpression ? (member.Expression as UnaryExpression).Operand as MemberExpression : null);
            }

            return builder.ToString();
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Diagnostics.CodeAnalysis;

namespace Tizen.NUI.Binding
{
    /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
    [SuppressMessage("Microsoft.Design", "CA1724: Type names should not match namespaces")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public sealed class Binding : BindingBase
    {
        internal const string SelfPath = ".";
        IValueConverter converter;
        object converterParameter;

        BindingExpression expression;
        string path;
        object source;
        string updateSourceEventName;

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Binding()
        {
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public Binding(string path, BindingMode mode = BindingMode.Default, IValueConverter converter = null, object converterParameter = null, string stringFormat = null, object source = null)
        {
            if (path == null)
                throw new ArgumentNullException(nameof(path));
            if (string.IsNullOrWhiteSpace(path))
                throw new ArgumentException("path can not be an empty string", nameof(path));

            Path = path;
            Converter = converter;
            ConverterParameter = converterParameter;
            Mode = mode;
            StringFormat = stringFormat;
            Source = source;
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public IValueConverter Converter
        {
            get { return converter; }
            set
            {
                ThrowIfApplied();

                converter = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public object ConverterParameter
        {
            get { return converterParameter; }
            set
            {
                ThrowIfApplied();

                converterParameter = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string Path
        {
            get { return path; }
            set
            {
                ThrowIfApplied();

                path = value;
                expression = new BindingExpression(this, !string.IsNullOrWhiteSpace(value) ? value : SelfPath);
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public object Source
        {
            get { return source; }
            set
            {
                ThrowIfApplied();
                source = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string UpdateSourceEventName
        {
            get { return updateSourceEventName; }
            set
            {
                ThrowIfApplied();
                updateSourceEventName = value;
            }
        }

        /// This will be public opened in tizen_6.0 after ACR done. Before ACR, need to be hidden as inhouse API.
        [EditorBrowsable(EditorBrowsableState.Never)]
        [ObsoleteAttribute(" ", false)]
        public static Binding Create<TSource>(Expression<Func<TSource, object>> propertyGetter, BindingMode mode = BindingMode.Default, IValueConverter converter = null, object converterParameter = null,
                                              string stringFormat = null)
        {
            if (propertyGetter == null)
                throw new ArgumentNullException(nameof(propertyGetter));

            return new Binding(GetBindingPath(propertyGetter), mode, converter, converterParameter, stringFormat);
        }

        internal override void Apply(bool fromTarget)
        {
            base.Apply(fromTarget);

            if (expression == null)
                expression = new BindingExpression(this, SelfPath);

            expression.Apply(fromTarget);
        }

        internal override void Apply(object newContext, BindableObject bindObj, BindableProperty targetProperty, bool fromBindingContextChanged = false)
        {
            object src = source;
            var isApplied = IsApplied;

            base.Apply(src ?? newContext, bindObj, targetProperty, fromBindingContextChanged: fromBindingContextChanged);

            if (src != null && isApplied && fromBindingContextChanged)
                return;

            object bindingContext = src ?? Context ?? newContext;
            if (expression == null && bindingContext != null)
                expression = new BindingExpression(this, SelfPath);

            expression?.Apply(bindingContext, bindObj, targetProperty);
        }

        internal override BindingBase Clone()
        {
            return new Binding(Path, Mode) { Converter = Converter, ConverterParameter = ConverterParameter, StringFormat = StringFormat, Source = Source, UpdateSourceEventName = UpdateSourceEventName };
        }

        internal override object GetSourceValue(object value, Type targetPropertyType)
        {
            if (Converter != null)
                value = Converter.Convert(value, targetPropertyType, ConverterParameter, CultureInfo.CurrentUICulture);

            return base.GetSourceValue(value, targetPropertyType);
        }

        internal override object GetTargetValue(object value, Type sourcePropertyType)
        {
            if (Converter != null)
                value = Converter.ConvertBack(value, sourcePropertyType, ConverterParameter, CultureInfo.CurrentUICulture);

            return base.GetTargetValue(value, sourcePropertyType);
        }

        internal override void Unapply(bool fromBindingContextChanged = false)
        {
            if (Source != null && fromBindingContextChanged && IsApplied)
                return;

            base.Unapply(fromBindingContextChanged: fromBindingContextChanged);

            if (expression != null)
                expression.Unapply();
        }

        [Obsolete]
        static string GetBindingPath<TSource>(Expression<Func<TSource, object>> propertyGetter)
        {
            Expression expr = propertyGetter.Body;

            if (expr is UnaryExpression unary)
                expr = unary.Operand;

            var builder = new StringBuilder();

            var indexed = false;
            if (member == null)
            {
                if (expr is MethodCallExpression methodCall)
                {
                    if (methodCall.Arguments.Count == 0)
                        throw new ArgumentException("Method calls are not allowed in binding expression");

                    var arguments = new List<string>(methodCall.Arguments.Count);
                    foreach (Expression arg in methodCall.Arguments)
                    {
                        if (arg.NodeType != ExpressionType.Constant)
                            throw new ArgumentException("Only constants can be used as indexer arguments");

                        object value = ((ConstantExpression)arg).Value;
                        arguments.Add(value != null ? value.ToString() : "null");
                    }

                    Type declarerType = methodCall.Method.DeclaringType;
                    DefaultMemberAttribute defaultMember = declarerType.GetTypeInfo().GetCustomAttributes(typeof(DefaultMemberAttribute), true).OfType<DefaultMemberAttribute>().FirstOrDefault();
                    string indexerName = defaultMember != null ? defaultMember.MemberName : "Item";

                    MethodInfo getterInfo =
                        declarerType.GetProperties().Where(pi => (pi.GetMethod != null) && pi.Name == indexerName && pi.CanRead && pi.GetMethod.IsPublic && !pi.GetMethod.IsStatic).Select(pi => pi.GetMethod).FirstOrDefault();
                    if (getterInfo != null)
                    {
                        if (getterInfo == methodCall.Method)
                        {
                            indexed = true;
                            builder.Append("[");

                            var first = true;
                            foreach (string argument in arguments)
                            {
                                if (!first)
                                    builder.Append(",");

                                builder.Append(argument);
                                first = false;
                            }

                            builder.Append("]");

                            member = methodCall.Object as MemberExpression;
                        }
                        else
                            throw new ArgumentException("Method calls are not allowed in binding expressions");
                    }
                    else
                        throw new ArgumentException("Public indexer not found");
                }
                else
                    throw new ArgumentException("Invalid expression type");
            }

            while (expr is MemberExpression member)
            {
                var property = (PropertyInfo)member.Member;
                if (builder.Length != 0)
                {
                    if (!indexed)
                        builder.Insert(0, ".");
                    else
                        indexed = false;
                }

                builder.Insert(0, property.Name);

                //				member = member.Expression as MemberExpression ?? (member.Expression as UnaryExpression)?.Operand as MemberExpression;
                member = member.Expression as MemberExpression ?? (member.Expression is UnaryExpression ? (member.Expression as UnaryExpression).Operand as MemberExpression : null);
            }

            return builder.ToString();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
/home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Binding.cs(213,17): error CS0103: The name 'member' does not exist in the current context,/home/vsts/work/1/s/src/Tizen.NUI/src/public/XamlBinding/Binding.cs(255,29): error CS0103: The name 'member' does not exist in the current context
######################################################################


