diff --git a/src/Compiler/Dynamic/Binding.cs b/src/Compiler/Dynamic/Binding.cs
index 3b8a2c4..f324b5c 100644
--- a/src/Compiler/Dynamic/Binding.cs
+++ b/src/Compiler/Dynamic/Binding.cs
@@ -435,7 +435,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
         {
             if (formals.Length != actuals.Length)
             {
-                errors.Add(new ArgumentException(String.Format("formals.Length = {0}, actuals.Length = {1}", formals.Length, actuals.Length)));
+                errors.Add(new ArgumentException($"formals.Length = {formals.Length}, actuals.Length = {actuals.Length}"));
                 yield break;
             }
             if (start >= formals.Length)
diff --git a/src/Compiler/Dynamic/Conversion.cs b/src/Compiler/Dynamic/Conversion.cs
index 6bbefcd..95ac6a3 100644
--- a/src/Compiler/Dynamic/Conversion.cs
+++ b/src/Compiler/Dynamic/Conversion.cs
@@ -438,7 +438,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
                     info.Converter = delegate(object dg)
                         {
                             Delegate result = ((CanGetDelegate) dg).GetDelegate(toType);
-                            if (result == null) throw new ArgumentException(String.Format("The {0} has no match for the signature of {1}", fromType.ToString(), toType.ToString()));
+                            if (result == null) throw new ArgumentException($"The {fromType.ToString()} has no match for the signature of {toType.ToString()}");
                             return result;
                         };
                     return true;
diff --git a/src/Compiler/Dynamic/DelegateGroup.cs b/src/Compiler/Dynamic/DelegateGroup.cs
index d0e0765..d57dc26 100644
--- a/src/Compiler/Dynamic/DelegateGroup.cs
+++ b/src/Compiler/Dynamic/DelegateGroup.cs
@@ -59,8 +59,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
             List<MethodBase> newmethods = new List<MethodBase>();
             foreach (MethodBase method in methods)
             {
-                MethodInfo info = method as MethodInfo;
-                if (info != null && info.IsGenericMethodDefinition)
+                if (method is MethodInfo info && info.IsGenericMethodDefinition)
                 {
                     try
                     {
diff --git a/src/Compiler/Dynamic/Invoker.cs b/src/Compiler/Dynamic/Invoker.cs
index 5558c33..9b9ab4c 100644
--- a/src/Compiler/Dynamic/Invoker.cs
+++ b/src/Compiler/Dynamic/Invoker.cs
@@ -93,19 +93,19 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
         public static object GetValue(object target, params object[] args)
         {
             if (args == null) return target;
-            Delegate d = target as Delegate;
-            if (d != null)
+
+            if (target is Delegate d)
             {
                 return InvokeMember(d.GetType(), "Invoke", BindingFlags.Public | BindingFlags.Instance | BindingFlags.InvokeMethod, d, args);
             }
-            DelegateGroup dg = target as DelegateGroup;
-            if (dg != null)
+
+            if (target is DelegateGroup dg)
             {
                 return dg.DynamicInvoke(args);
             }
             if (args.Length == 0) return target;
-            Array array = target as Array;
-            if (array != null)
+
+            if (target is Array array)
             {
                 int[] index = Array.ConvertAll<object, int>(args, delegate(object o) { return Convert.ToInt32(o); });
                 return array.GetValue(index);
@@ -123,8 +123,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
         /// <param name="args">Indices followed by the value to set.  Length > 0.</param>
         public static void SetValue(object target, params object[] args)
         {
-            Array array = target as Array;
-            if (array != null)
+            if (target is Array array)
             {
                 object value = args[args.Length - 1];
                 Conversion conv;
@@ -655,10 +654,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Reflection
                 }
                 else throw new NotImplementedException("Cannot clone an array of rank > 1");
             }
-            else if (o is ICloneable)
+            else if (o is ICloneable iCloneable)
             {
                 // if it has a Clone() method, use it
-                return ((ICloneable) o).Clone();
+                return iCloneable.Clone();
             }
             else
             {
diff --git a/src/Compiler/Graphs/Edge.cs b/src/Compiler/Graphs/Edge.cs
index ad5579e..8e900b2 100644
--- a/src/Compiler/Graphs/Edge.cs
+++ b/src/Compiler/Graphs/Edge.cs
@@ -47,7 +47,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
 
         public override string ToString()
         {
-            return String.Format("({0},{1})", Source, Target);
+            return $"({Source},{Target})";
         }
 
         public override bool Equals(object obj)
diff --git a/src/Compiler/Graphs/Graph.cs b/src/Compiler/Graphs/Graph.cs
index 5e0e7d7..d13ecd3 100644
--- a/src/Compiler/Graphs/Graph.cs
+++ b/src/Compiler/Graphs/Graph.cs
@@ -100,8 +100,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         public void AddEdge(NodeType source, NodeType target)
         {
             source.Targets.Add(target);
-            HasSources<NodeType> intoNode = target as HasSources<NodeType>;
-            if (intoNode != null) intoNode.Sources.Add(source);
+
+            if (target is HasSources<NodeType> intoNode) intoNode.Sources.Add(source);
         }
 
         public bool ContainsEdge(NodeType source, NodeType target)
@@ -117,8 +117,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         /// <remarks>If there are multiple edges from source to target, only one is removed.</remarks>
         public virtual bool RemoveEdge(NodeType source, NodeType target)
         {
-            HasSources<NodeType> intoNode = target as HasSources<NodeType>;
-            if (intoNode != null) intoNode.Sources.Remove(source);
+            if (target is HasSources<NodeType> intoNode) intoNode.Sources.Remove(source);
             return source.Targets.Remove(target);
         }
 
@@ -158,16 +157,14 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         {
             foreach (NodeType target in source.Targets)
             {
-                HasSources<NodeType> intoNode = target as HasSources<NodeType>;
-                if (intoNode != null) intoNode.Sources.Remove(source);
+                if (target is HasSources<NodeType> intoNode) intoNode.Sources.Remove(source);
             }
             source.Targets.Clear();
         }
 
         public virtual void ClearEdgesInto(NodeType target)
         {
-            HasSources<NodeType> inNode = target as HasSources<NodeType>;
-            if (inNode != null)
+            if (target is HasSources<NodeType> inNode)
             {
                 // doubly-linked case
                 foreach (NodeType source in inNode.Sources)
@@ -215,8 +212,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             foreach (NodeType node in nodes)
             {
                 node.Targets.Clear();
-                HasSources<NodeType> inNode = node as HasSources<NodeType>;
-                if (inNode != null) inNode.Sources.Clear();
+
+                if (node is HasSources<NodeType> inNode) inNode.Sources.Clear();
             }
         }
 
@@ -244,8 +241,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
 
         public virtual int SourceCount(NodeType target)
         {
-            HasSources<NodeType> inNode = target as HasSources<NodeType>;
-            if (inNode != null)
+            if (target is HasSources<NodeType> inNode)
             {
                 return inNode.Sources.Count;
             }
@@ -284,8 +280,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
 
         public IEnumerable<NodeType> SourcesOf(NodeType target)
         {
-            HasSources<NodeType> inNode = target as HasSources<NodeType>;
-            if (inNode != null)
+            if (target is HasSources<NodeType> inNode)
             {
                 return inNode.Sources;
             }
@@ -345,14 +340,14 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                 {
                     foreach (NodeType target in node.Targets)
                     {
-                        s.AppendLine(String.Format(" {0} -> {1}", node, target));
+                        s.AppendLine($" {node} -> {target}");
                     }
-                    HasSources<NodeType> intoNode = node as HasSources<NodeType>;
-                    if (intoNode != null)
+
+                    if (node is HasSources<NodeType> intoNode)
                     {
                         foreach (NodeType source in intoNode.Sources)
                         {
-                            s.AppendLine(String.Format(" {0} <- {1}", node, source));
+                            s.AppendLine($" {node} <- {source}");
                         }
                     }
                 }
@@ -471,8 +466,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         public void AddEdge(EdgeType edge)
         {
             edge.Source.OutEdges.Add(edge);
-            HasInEdges<EdgeType> intoTarget = edge.Target as HasInEdges<EdgeType>;
-            if (intoTarget != null) intoTarget.InEdges.Add(edge);
+
+            if (edge.Target is HasInEdges<EdgeType> intoTarget) intoTarget.InEdges.Add(edge);
         }
 
         public NodeType SourceOf(EdgeType edge)
@@ -611,8 +606,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         public virtual bool RemoveEdge(EdgeType edge)
         {
             bool removed = edge.Source.OutEdges.Remove(edge);
-            HasInEdges<EdgeType> target = edge.Target as HasInEdges<EdgeType>;
-            if (target != null) removed = removed && target.InEdges.Remove(edge);
+
+            if (edge.Target is HasInEdges<EdgeType> target) removed = removed && target.InEdges.Remove(edge);
             return removed;
         }
 
@@ -633,16 +628,14 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
         {
             foreach (EdgeType edge in source.OutEdges)
             {
-                HasInEdges<EdgeType> intoNode = edge.Target as HasInEdges<EdgeType>;
-                if (intoNode != null) intoNode.InEdges.Remove(edge);
+                if (edge.Target is HasInEdges<EdgeType> intoNode) intoNode.InEdges.Remove(edge);
             }
             source.OutEdges.Clear();
         }
 
         public override void ClearEdgesInto(NodeType target)
         {
-            HasInEdges<EdgeType> inNode = target as HasInEdges<EdgeType>;
-            if (inNode != null)
+            if (target is HasInEdges<EdgeType> inNode)
             {
                 // doubly-linked case
                 foreach (EdgeType edge in inNode.InEdges)
@@ -671,8 +664,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             foreach (NodeType node in nodes)
             {
                 node.OutEdges.Clear();
-                HasInEdges<EdgeType> inNode = node as HasInEdges<EdgeType>;
-                if (inNode != null) inNode.InEdges.Clear();
+
+                if (node is HasInEdges<EdgeType> inNode) inNode.InEdges.Clear();
             }
         }
 
@@ -693,8 +686,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
 
         public override int SourceCount(NodeType target)
         {
-            HasInEdges<EdgeType> inNode = target as HasInEdges<EdgeType>;
-            if (inNode != null)
+            if (target is HasInEdges<EdgeType> inNode)
             {
                 return inNode.InEdges.Count;
             }
@@ -754,8 +746,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             {
                 CopyEdge(edge, node2, edge.Target);
             }
-            HasInEdges<EdgeType> inNode = node as HasInEdges<EdgeType>;
-            if (inNode != null)
+
+            if (node is HasInEdges<EdgeType> inNode)
             {
                 foreach (EdgeType edge in inNode.InEdges)
                 {
@@ -782,8 +774,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                     // clone the node contents, but not its neighbors
                     NodeType newNode = (NodeType) Invoker.Clone(node);
                     newNode.OutEdges.Clear();
-                    if (newNode is HasInEdges<EdgeType>)
-                        ((HasInEdges<EdgeType>) newNode).InEdges.Clear();
+                    if (newNode is HasInEdges<EdgeType> EdgeTypes)
+                        EdgeTypes.InEdges.Clear();
                     Nodes.WithLabel(label).Add(newNode);
                     newNodes[node] = newNode;
                 }
diff --git a/src/Compiler/Graphs/GraphSearcher.cs b/src/Compiler/Graphs/GraphSearcher.cs
index 1abf081..4206fa4 100644
--- a/src/Compiler/Graphs/GraphSearcher.cs
+++ b/src/Compiler/Graphs/GraphSearcher.cs
@@ -37,9 +37,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
 
         protected void CreateNodeData(IGraph<NodeType> graph)
         {
-            if (graph is CanCreateNodeData<NodeType>)
+            if (graph is CanCreateNodeData<NodeType> NodeTypes)
             {
-                IsVisited = ((CanCreateNodeData<NodeType>) graph).CreateNodeData<VisitState>(VisitState.Unvisited);
+                IsVisited = NodeTypes.CreateNodeData(VisitState.Unvisited);
             }
             else
             {
diff --git a/src/Compiler/Graphs/LabeledCollection.cs b/src/Compiler/Graphs/LabeledCollection.cs
index b745dc8..70c9bf0 100644
--- a/src/Compiler/Graphs/LabeledCollection.cs
+++ b/src/Compiler/Graphs/LabeledCollection.cs
@@ -213,7 +213,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             {
                 if (!label.Equals(DefaultLabel))
                 {
-                    s.Append(String.Format("<{0}>", label));
+                    s.Append($"<{label}>");
                 }
                 int count = 0;
                 foreach (T value in WithLabel(label))
@@ -224,7 +224,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                 }
                 if (!label.Equals(DefaultLabel))
                 {
-                    s.Append(String.Format("</{0}>", label));
+                    s.Append($"</{label}>");
                 }
             }
             return s.ToString();
diff --git a/src/Compiler/Graphs/ParallelScheduler.cs b/src/Compiler/Graphs/ParallelScheduler.cs
index 12276cb..d7782e5 100644
--- a/src/Compiler/Graphs/ParallelScheduler.cs
+++ b/src/Compiler/Graphs/ParallelScheduler.cs
@@ -799,7 +799,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                 {
                     CheckForest(roots);
                     int totalSize = roots.Sum(block => block.Size);
-                    Trace.WriteLine(string.Format("tree has {0} nodes among {1} roots", totalSize, roots.Count));
+                    Trace.WriteLine($"tree has {totalSize} nodes among {roots.Count} roots");
                 }
                 if (roots.Count == 0)
                     break;
@@ -810,7 +810,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                     CheckForest(roots);
                     int totalSize = roots.Sum(block => block.Size);
                     if (debug)
-                        Trace.WriteLine(string.Format("stage has {0} nodes", totalSize));
+                        Trace.WriteLine($"stage has {totalSize} nodes");
                     if (totalSize == 0)
                     {
                         prohibitedHeight = minHeightOfReadyNode;
@@ -837,7 +837,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                 }
                 if (debug)
                 {
-                    Trace.Write(string.Format("stage {0}: ", schedule.Count));
+                    Trace.Write($"stage {schedule.Count}: ");
                     WriteStage(scheduleForStage, true);
                     Trace.WriteLine("");
                 }
@@ -1026,7 +1026,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                             else
                                 activeBlockCount++;
                         }
-                        Trace.WriteLine(string.Format("{0} active, {1} pending", activeBlockCount, pendingBlockCount));
+                        Trace.WriteLine($"{activeBlockCount} active, {pendingBlockCount} pending");
                         if (activeBlockCount == 0)
                             throw new Exception();
                     }
@@ -1619,7 +1619,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             foreach (var block in stage)
             {
                 if (blockCounts)
-                    Trace.Write(string.Format("{0} ", block.Count));
+                    Trace.Write($"{block.Count} ");
                 else
                 {
                     Trace.Write("(");
@@ -1630,7 +1630,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
                             firstTime = false;
                         else
                             Trace.Write(",");
-                        Trace.Write(string.Format("{0}", node));
+                        Trace.Write($"{node}");
                     }
                     Trace.Write(") ");
                 }
@@ -1642,7 +1642,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             int stageIndex = 0;
             foreach (var stage in schedule)
             {
-                Trace.Write(string.Format("stage {0}: ", stageIndex++));
+                Trace.Write($"stage {stageIndex++}: ");
                 WriteStage(stage, blockCounts);
                 Trace.WriteLine("");
             }
@@ -1654,7 +1654,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Graphs
             {
                 if (blocksOfThread[0].Length <= stageIndex)
                     break;
-                Trace.Write(string.Format("stage {0}: ", stageIndex));
+                Trace.Write($"stage {stageIndex}: ");
                 WriteStage(Util.ArrayInit(blocksOfThread.Length, thread => blocksOfThread[thread][stageIndex]));
                 Trace.WriteLine("");
             }
diff --git a/src/Compiler/Infer/CompilerAttributes/Containers.cs b/src/Compiler/Infer/CompilerAttributes/Containers.cs
index 6ec6325..b5d7816 100644
--- a/src/Compiler/Infer/CompilerAttributes/Containers.cs
+++ b/src/Compiler/Infer/CompilerAttributes/Containers.cs
@@ -290,12 +290,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
         {
             if (ReferenceEquals(st1, st2))
                 return true;
-            if (st1 is IForStatement)
+            if (st1 is IForStatement ifs1)
             {
-                IForStatement ifs1 = (IForStatement)st1;
-                if (st2 is IForStatement)
+                if (st2 is IForStatement ifs2)
                 {
-                    IForStatement ifs2 = (IForStatement)st2;
                     if (ignoreLoopDirection && Recognizer.IsForwardLoop(ifs1) != Recognizer.IsForwardLoop(ifs2))
                     {
                         ifs2 = (IForStatement)CreateContainer(ifs2);
@@ -308,22 +306,18 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
                 }
                 else return false;
             }
-            else if (st1 is IConditionStatement)
+            else if (st1 is IConditionStatement ics1)
             {
-                IConditionStatement ics1 = (IConditionStatement)st1;
-                if (st2 is IConditionStatement)
+                if (st2 is IConditionStatement ics2)
                 {
-                    IConditionStatement ics2 = (IConditionStatement)st2;
                     return ics1.Condition.Equals(ics2.Condition);
                 }
                 else return false;
             }
-            else if (st1 is IRepeatStatement)
+            else if (st1 is IRepeatStatement irs1)
             {
-                IRepeatStatement irs1 = (IRepeatStatement)st1;
-                if (st2 is IRepeatStatement)
+                if (st2 is IRepeatStatement irs2)
                 {
-                    IRepeatStatement irs2 = (IRepeatStatement)st2;
                     return irs1.Count.Equals(irs2.Count);
                 }
                 else return false;
@@ -333,14 +327,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
 
         public static int ContainerGetHashCode(IStatement st)
         {
-            if (st is IForStatement)
+            if (st is IForStatement ifs)
             {
-                IForStatement ifs = (IForStatement)st;
                 return ifs.Initializer.GetHashCode();
             }
-            else if (st is IConditionStatement)
+            else if (st is IConditionStatement ics)
             {
-                IConditionStatement ics = (IConditionStatement)st;
                 return ics.Condition.GetHashCode();
             }
             else return st.GetHashCode();
@@ -455,9 +447,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
             // loop ancestors starting from innermost
             foreach (IStatement ist in ancestors)
             {
-                if (ist is IForStatement)
+                if (ist is IForStatement loop)
                 {
-                    IForStatement loop = (IForStatement)ist;
                     IVariableDeclaration loopVar = Recognizer.LoopVariable(loop);
                     try
                     {
@@ -513,9 +504,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
         {
             containedExpressions.Add(expr);
             IVariableDeclaration baseVar = Recognizer.GetVariableDeclaration(expr);
-            if (expr is IArrayIndexerExpression)
+            if (expr is IArrayIndexerExpression iaie)
             {
-                var iaie = (IArrayIndexerExpression)expr;
                 foreach (var ind in iaie.Indices) AddToContainedExpressions(containedExpressions, ind, context);
             }
             if (baseVar == null) return;
@@ -523,9 +513,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
             if (containers == null) throw new Exception("Containers not found for: " + baseVar);
             foreach (IStatement container in containers.inputs)
             {
-                if (container is IForStatement)
+                if (container is IForStatement iForStatement)
                 {
-                    containedExpressions.Add(Builder.VarRefExpr(Recognizer.LoopVariable((IForStatement)container)));
+                    containedExpressions.Add(Builder.VarRefExpr(Recognizer.LoopVariable(iForStatement)));
                 }
             }
         }
@@ -741,9 +731,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
             for (int i = 0; i < containers.inputs.Count; i++)
             {
                 IStatement container = containers.inputs[i];
-                if (container is IConditionStatement)
+                if (container is IConditionStatement ics)
                 {
-                    IConditionStatement ics = (IConditionStatement)container;
                     IExpression condition = ics.Condition;
                     if (condition is IBinaryExpression && ((IBinaryExpression)condition).Operator == BinaryOperator.BooleanAnd)
                     {
@@ -776,9 +765,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
                         if (!ContainsExpression(containers.inputs, context, condition)) continue;
                     }
                 }
-                else if (container is IRepeatStatement)
+                else if (container is IRepeatStatement irs)
                 {
-                    IRepeatStatement irs = (IRepeatStatement)container;
                     if (!ContainsExpression(containers.inputs, context, irs.Count)) continue;
                 }
                 result.inputs.Add(container);
@@ -804,9 +792,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
             for (int i = 0; i < containers.inputs.Count; i++)
             {
                 IStatement container = containers.inputs[i];
-                if (container is IConditionStatement)
+                if (container is IConditionStatement ics)
                 {
-                    IConditionStatement ics = (IConditionStatement)container;
                     if (CodeRecognizer.IsStochastic(context, ics.Condition)) continue;
                 }
                 result.inputs.Add(container);
@@ -822,9 +809,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
             for (int i = 0; i < containers.inputs.Count; i++)
             {
                 IStatement container = containers.inputs[i];
-                if (container is IConditionStatement)
+                if (container is IConditionStatement ics)
                 {
-                    IConditionStatement ics = (IConditionStatement)container;
                     if (CodeRecognizer.IsStochastic(context, ics.Condition))
                     {
                         conditionals.inputs.Add(container);
@@ -923,13 +909,13 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
 
         internal static void SetBodyTo(IStatement container, IBlockStatement block)
         {
-            if (container is IForStatement)
+            if (container is IForStatement iForStatement)
             {
-                ((IForStatement)container).Body = block;
+                iForStatement.Body = block;
             }
-            else if (container is IConditionStatement)
+            else if (container is IConditionStatement iConditionStatement)
             {
-                ((IConditionStatement)container).Then = block;
+                iConditionStatement.Then = block;
             }
             else
             {
@@ -965,9 +951,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
                 else
                     outermostContainer = child;
                 parent = child;
-                if (child is IBrokenForStatement)
+                if (child is IBrokenForStatement ifs)
                 {
-                    IBrokenForStatement ifs = (IBrokenForStatement)child;
                     loopBreakers.Add(Recognizer.LoopBreakStatement(ifs));
                 }
             }
@@ -990,9 +975,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
         /// <returns></returns>
         internal static IStatement CreateContainer(IStatement prototype)
         {
-            if (prototype is IForStatement)
+            if (prototype is IForStatement loop)
             {
-                IForStatement loop = (IForStatement)prototype;
                 IForStatement ifs = Builder.ForStmt(loop);
                 ifs.Initializer = loop.Initializer;
                 ifs.Condition = loop.Condition;
@@ -1000,14 +984,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
                 ifs.Body = Builder.BlockStmt();
                 return ifs;
             }
-            else if (prototype is IConditionStatement)
+            else if (prototype is IConditionStatement cond)
             {
-                IConditionStatement cond = (IConditionStatement)prototype;
                 return Builder.CondStmt(cond.Condition, Builder.BlockStmt());
             }
-            else if (prototype is IRepeatStatement)
+            else if (prototype is IRepeatStatement irs)
             {
-                IRepeatStatement irs = (IRepeatStatement)prototype;
                 return Builder.RepeatStmt(irs.Count);
             }
             else
@@ -1028,17 +1010,17 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
 
         internal static IList<IStatement> Statements(IStatement container)
         {
-            if (container is IForStatement)
+            if (container is IForStatement iForStatement)
             {
-                return ((IForStatement)container).Body.Statements;
+                return iForStatement.Body.Statements;
             }
-            else if (container is IConditionStatement)
+            else if (container is IConditionStatement iConditionStatement)
             {
-                return ((IConditionStatement)container).Then.Statements;
+                return iConditionStatement.Then.Statements;
             }
-            else if (container is IRepeatStatement)
+            else if (container is IRepeatStatement iRepeatStatement)
             {
-                return ((IRepeatStatement)container).Body.Statements;
+                return iRepeatStatement.Body.Statements;
             }
             else
             {
@@ -1079,14 +1061,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
         {
             if (ReferenceEquals(st1, st2))
                 return st1;
-            if (st1 is IForStatement)
+            if (st1 is IForStatement ifs1)
             {
-                IForStatement ifs1 = (IForStatement)st1;
                 bool isForward = Recognizer.IsForwardLoop(ifs1);
                 bool isBroken = ifs1 is IBrokenForStatement;
-                if (st2 is IForStatement)
+                if (st2 is IForStatement ifs2)
                 {
-                    IForStatement ifs2 = (IForStatement)st2;
                     if (ignoreLoopDirection && isForward != Recognizer.IsForwardLoop(ifs2))
                     {
                         ifs2 = (IForStatement)CreateContainer(ifs2);
@@ -1104,23 +1084,19 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
                 }
                 // fall through
             }
-            else if (st1 is IConditionStatement)
+            else if (st1 is IConditionStatement ics1)
             {
-                IConditionStatement ics1 = (IConditionStatement)st1;
-                if (st2 is IConditionStatement)
+                if (st2 is IConditionStatement ics2)
                 {
-                    IConditionStatement ics2 = (IConditionStatement)st2;
                     if (ics1.Condition.Equals(ics2.Condition)) return st1;
                     // fall through
                 }
                 // fall through
             }
-            else if (st1 is IRepeatStatement)
+            else if (st1 is IRepeatStatement irs1)
             {
-                IRepeatStatement irs1 = (IRepeatStatement)st1;
-                if (st2 is IRepeatStatement)
+                if (st2 is IRepeatStatement irs2)
                 {
-                    IRepeatStatement irs2 = (IRepeatStatement)st2;
                     if (irs1.Count.Equals(irs2.Count)) return st1;
                     // fall through
                 }
diff --git a/src/Compiler/Infer/CompilerAttributes/DebugInfo.cs b/src/Compiler/Infer/CompilerAttributes/DebugInfo.cs
index 0343e8f..a87e703 100644
--- a/src/Compiler/Infer/CompilerAttributes/DebugInfo.cs
+++ b/src/Compiler/Infer/CompilerAttributes/DebugInfo.cs
@@ -27,7 +27,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Attributes
 
         public override string ToString()
         {
-            return string.Format("DebugInfo({0},{1})", Transform == null ? "" : Transform.Name, Name);
+            return $"DebugInfo({(Transform == null ? "" : Transform.Name)},{Name})";
         }
     }
 }
diff --git a/src/Compiler/Infer/Models/ConditionBlock.cs b/src/Compiler/Infer/Models/ConditionBlock.cs
index 5495054..6fddcb7 100644
--- a/src/Compiler/Infer/Models/ConditionBlock.cs
+++ b/src/Compiler/Infer/Models/ConditionBlock.cs
@@ -71,7 +71,7 @@ namespace Microsoft.ML.Probabilistic.Models
             List<IStatementBlock> blocks = GetOpenBlocks();
             foreach (IStatementBlock sb in blocks)
             {
-                if (sb is T) list.Add((T) sb);
+                if (sb is T t) list.Add(t);
             }
             return list;
         }
diff --git a/src/Compiler/Infer/Models/MethodInvoke.cs b/src/Compiler/Infer/Models/MethodInvoke.cs
index 492c9fa..81edbdd 100644
--- a/src/Compiler/Infer/Models/MethodInvoke.cs
+++ b/src/Compiler/Infer/Models/MethodInvoke.cs
@@ -66,9 +66,8 @@ namespace Microsoft.ML.Probabilistic.Models
             foreach (IModelExpression arg in args)
             {
                 if (ReferenceEquals(arg, null)) throw new ArgumentNullException();
-                if (arg is Variable)
+                if (arg is Variable v)
                 {
-                    Variable v = (Variable) arg;
                     if (v.IsObserved) continue;
                     foreach (ConditionBlock cb in v.GetContainers<ConditionBlock>())
                     {
@@ -249,9 +248,8 @@ namespace Microsoft.ML.Probabilistic.Models
             foreach (IModelExpression arg in returnValueAndArgs()) ForEachRange(arg, ranges.Add);
             foreach (IStatementBlock b in Containers)
             {
-                if (b is HasRange)
+                if (b is HasRange br)
                 {
-                    HasRange br = (HasRange) b;
                     ranges.Remove(br.Range);
                 }
             }
@@ -271,9 +269,8 @@ namespace Microsoft.ML.Probabilistic.Models
             }
             foreach (IStatementBlock b in Containers)
             {
-                if (b is HasRange)
+                if (b is HasRange br)
                 {
-                    HasRange br = (HasRange) b;
                     ranges.Remove(br.Range);
                 }
             }
@@ -282,14 +279,13 @@ namespace Microsoft.ML.Probabilistic.Models
 
         internal static void ForEachRange(IModelExpression arg, Action<Range> action)
         {
-            if (arg is Range)
+            if (arg is Range range)
             {
-                action((Range) arg);
+                action(range);
                 return;
             }
-            else if (arg is Variable)
+            else if (arg is Variable v)
             {
-                Variable v = (Variable) arg;
                 if (v.IsLoopIndex)
                 {
                     action(v.loopRange);
@@ -330,9 +326,8 @@ namespace Microsoft.ML.Probabilistic.Models
         /// <returns></returns>
         internal static List<List<Range>> GetRangeBrackets(IModelExpression arg, IDictionary<IModelExpression, List<List<Range>>> dict)
         {
-            if (arg is Variable)
+            if (arg is Variable v)
             {
-                Variable v = (Variable) arg;
                 if (v.IsArrayElement)
                 {
                     List<List<Range>> brackets = GetRangeBrackets(v.ArrayVariable, dict);
@@ -340,7 +335,7 @@ namespace Microsoft.ML.Probabilistic.Models
                     // must add item indices after array's indices
                     foreach (IModelExpression expr in v.indices)
                     {
-                        if (expr is Range) indices.Add((Range) expr);
+                        if (expr is Range range) indices.Add(range);
                         else
                         {
                             List<List<Range>> argBrackets = GetRangeBrackets(expr, dict);
diff --git a/src/Compiler/Infer/Models/ModelAttributes.cs b/src/Compiler/Infer/Models/ModelAttributes.cs
index c84d977..505838f 100644
--- a/src/Compiler/Infer/Models/ModelAttributes.cs
+++ b/src/Compiler/Infer/Models/ModelAttributes.cs
@@ -323,7 +323,7 @@ namespace Microsoft.ML.Probabilistic.Models.Attributes
         /// <returns></returns>
         public override string ToString()
         {
-            return string.Format("Algorithm({0})", algorithm);
+            return $"Algorithm({algorithm})";
         }
     }
 
@@ -354,7 +354,7 @@ namespace Microsoft.ML.Probabilistic.Models.Attributes
         /// <returns></returns>
         public override string ToString()
         {
-            return string.Format("FactorAlgorithm({0})", algorithm);
+            return $"FactorAlgorithm({algorithm})";
         }
     }
 
@@ -393,7 +393,7 @@ namespace Microsoft.ML.Probabilistic.Models.Attributes
         public override string ToString()
         {
             string strRoot = (IsRoot) ? " (root)" : "";
-            return String.Format("GroupMember({0}{1})", Group, strRoot);
+            return $"GroupMember({Group}{strRoot})";
         }
     }
 
diff --git a/src/Compiler/Infer/Models/ModelBuilder.cs b/src/Compiler/Infer/Models/ModelBuilder.cs
index 8d18b1d..1fdc0dd 100644
--- a/src/Compiler/Infer/Models/ModelBuilder.cs
+++ b/src/Compiler/Infer/Models/ModelBuilder.cs
@@ -309,7 +309,7 @@ namespace Microsoft.ML.Probabilistic.Models
                 ParameterInfo pi = pis[i];
                 if (pi.IsOut && arg is HasObservedValue && ((HasObservedValue)arg).IsObserved)
                 {
-                    throw new NotImplementedException(string.Format("Out parameter '{0}' of {1} cannot be observed.  Use ConstrainEqual or observe a copy of the variable.", pi.Name, method));
+                    throw new NotImplementedException($"Out parameter '{pi.Name}' of {method} cannot be observed.  Use ConstrainEqual or observe a copy of the variable.");
                 }
             }
             foreach (IStatementBlock b in method.Containers)
diff --git a/src/Compiler/Infer/Models/Variable.cs b/src/Compiler/Infer/Models/Variable.cs
index 303ff5d..f117075 100644
--- a/src/Compiler/Infer/Models/Variable.cs
+++ b/src/Compiler/Infer/Models/Variable.cs
@@ -2486,7 +2486,7 @@ namespace Microsoft.ML.Probabilistic.Models
             Range range = probs.GetValueRange(false);
             if (range != null) v.AddAttribute(new ValueRange(range));
             SparsityAttribute sparsityAttr = probs.GetFirstAttribute<SparsityAttribute>();
-            if (sparsityAttr != null && sparsityAttr.Sparsity != null)
+            if (sparsityAttr?.Sparsity != null)
                 v.SetSparsity(sparsityAttr.Sparsity);
             return v;
         }
@@ -2508,7 +2508,7 @@ namespace Microsoft.ML.Probabilistic.Models
                                             valueRange + "'");
             v.AddAttribute(new ValueRange(valueRange));
             SparsityAttribute sparsityAttr = probs.GetFirstAttribute<SparsityAttribute>();
-            if (sparsityAttr != null && sparsityAttr.Sparsity != null)
+            if (sparsityAttr?.Sparsity != null)
                 v.SetSparsity(sparsityAttr.Sparsity);
             return v;
         }
@@ -2846,7 +2846,7 @@ namespace Microsoft.ML.Probabilistic.Models
             Variable<Vector> v = Variable<Vector>.Factor(Distributions.Dirichlet.SampleFromPseudoCounts, pseudoCount);
 
             SparsityAttribute sparsityAttr = pseudoCount.GetFirstAttribute<SparsityAttribute>();
-            if (sparsityAttr != null && sparsityAttr.Sparsity != null)
+            if (sparsityAttr?.Sparsity != null)
                 v.SetSparsity(sparsityAttr.Sparsity);
             return v;
         }
diff --git a/src/Compiler/Infer/Models/VariableArray.cs b/src/Compiler/Infer/Models/VariableArray.cs
index 7e1580d..d1f1a70 100644
--- a/src/Compiler/Infer/Models/VariableArray.cs
+++ b/src/Compiler/Infer/Models/VariableArray.cs
@@ -155,9 +155,9 @@ namespace Microsoft.ML.Probabilistic.Models
             // must do this replacement first, since it will influence how we replace the itemPrototype
             Range newRange = Range.Replace(rangeReplacements, expressionReplacements);
             TItem itemPrototype = (TItem) ((IVariableJaggedArray) this).ItemPrototype;
-            if (itemPrototype is IVariableArray)
+            if (itemPrototype is IVariableArray iVariableArray)
             {
-                IVariable result = ((IVariableArray)itemPrototype).ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
+                IVariable result = iVariableArray.ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
                 itemPrototype = (TItem)result;
             }
             else
diff --git a/src/Compiler/Infer/Models/VariableArray2D.cs b/src/Compiler/Infer/Models/VariableArray2D.cs
index 432b2da..eba95ea 100644
--- a/src/Compiler/Infer/Models/VariableArray2D.cs
+++ b/src/Compiler/Infer/Models/VariableArray2D.cs
@@ -193,9 +193,9 @@ namespace Microsoft.ML.Probabilistic.Models
             Range newRange0 = Range0.Replace(rangeReplacements, expressionReplacements);
             Range newRange1 = Range1.Replace(rangeReplacements, expressionReplacements);
             TItem itemPrototype = (TItem) ((IVariableJaggedArray) this).ItemPrototype;
-            if (itemPrototype is IVariableArray)
+            if (itemPrototype is IVariableArray iVariableArray)
             {
-                IVariable result = ((IVariableArray) itemPrototype).ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
+                IVariable result = iVariableArray.ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
                 itemPrototype = (TItem) result;
             }
             else if (deepCopy)
diff --git a/src/Compiler/Infer/Models/VariableArray3D.cs b/src/Compiler/Infer/Models/VariableArray3D.cs
index c2d6a72..9cfaeaf 100644
--- a/src/Compiler/Infer/Models/VariableArray3D.cs
+++ b/src/Compiler/Infer/Models/VariableArray3D.cs
@@ -263,9 +263,9 @@ namespace Microsoft.ML.Probabilistic.Models
             Range newRange1 = Range1.Replace(rangeReplacements, expressionReplacements);
             Range newRange2 = Range2.Replace(rangeReplacements, expressionReplacements);
             TItem itemPrototype = (TItem) ((IVariableJaggedArray) this).ItemPrototype;
-            if (itemPrototype is IVariableArray)
+            if (itemPrototype is IVariableArray iVariableArray)
             {
-                IVariable result = ((IVariableArray) itemPrototype).ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
+                IVariable result = iVariableArray.ReplaceRanges(rangeReplacements, expressionReplacements, deepCopy);
                 itemPrototype = (TItem) result;
             }
             else if (deepCopy)
diff --git a/src/Compiler/Infer/Models/VariableArrayBase.cs b/src/Compiler/Infer/Models/VariableArrayBase.cs
index 1d5b9e4..2ac2434 100644
--- a/src/Compiler/Infer/Models/VariableArrayBase.cs
+++ b/src/Compiler/Infer/Models/VariableArrayBase.cs
@@ -93,9 +93,8 @@ namespace Microsoft.ML.Probabilistic.Models
                 if (r == null) throw new ArgumentNullException("range");
                 foreach (IStatementBlock stBlock in containers)
                 {
-                    if (stBlock is ForEachBlock)
+                    if (stBlock is ForEachBlock fb)
                     {
-                        ForEachBlock fb = (ForEachBlock) stBlock;
                         if (r.Equals(fb.Range)) throw new InvalidOperationException("Range '" + r + "' is already open in a ForEach block.  Use a cloned range instead.");
                     }
                 }
@@ -167,7 +166,7 @@ namespace Microsoft.ML.Probabilistic.Models
             Dictionary<IList<IModelExpression>, IVariable> itemVariables = ((HasItemVariables) array).GetItemsUntyped();
             if (itemVariables.TryGetValue(index, out item)) return (TItem) item;
             // the item must be in the same containers as the array (not the currently open containers)
-            if (itemPrototype is IVariableArray)
+            if (itemPrototype is IVariableArray iVariableArray)
             {
                 Dictionary<Range, Range> replacements = new Dictionary<Range, Range>();
                 Dictionary<IModelExpression, IModelExpression> expressionReplacements = new Dictionary<IModelExpression, IModelExpression>();
@@ -175,7 +174,7 @@ namespace Microsoft.ML.Probabilistic.Models
                 {
                     expressionReplacements.Add(ranges[i], index[i]);
                 }
-                IVariable result = ((IVariableArray) itemPrototype).ReplaceRanges(replacements, expressionReplacements, deepCopy: false);
+                IVariable result = iVariableArray.ReplaceRanges(replacements, expressionReplacements, deepCopy: false);
                 TItem v = (TItem) result;
                 v.MakeItem(array, index);
                 return v;
diff --git a/src/Compiler/Infer/Transforms/AccumulationTransform.cs b/src/Compiler/Infer/Transforms/AccumulationTransform.cs
index a53b47c..6efa780 100644
--- a/src/Compiler/Infer/Transforms/AccumulationTransform.cs
+++ b/src/Compiler/Infer/Transforms/AccumulationTransform.cs
@@ -40,10 +40,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         protected override IStatement DoConvertStatement(IStatement ist)
         {
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
                 bool isAccumulator = false;
-                IExpressionStatement ies = (IExpressionStatement) ist;
                 if (ies.Expression is IAssignExpression)
                 {
                     IAssignExpression iae = (IAssignExpression) ies.Expression;
diff --git a/src/Compiler/Infer/Transforms/ArraySizeTracingTransform.cs b/src/Compiler/Infer/Transforms/ArraySizeTracingTransform.cs
index f9ccb0c..c44ab23 100644
--- a/src/Compiler/Infer/Transforms/ArraySizeTracingTransform.cs
+++ b/src/Compiler/Infer/Transforms/ArraySizeTracingTransform.cs
@@ -73,8 +73,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             IExpression formatExpr = Builder.LiteralExpr(format);
             VariableInformation varInfo = VariableInformation.GetVariableInformation(context, decl);
             IExpression varRefExpr;
-            if (decl is IVariableDeclaration)
-                varRefExpr = Builder.VarRefExpr((IVariableDeclaration)decl);
+            if (decl is IVariableDeclaration iVariableDeclaration)
+                varRefExpr = Builder.VarRefExpr(iVariableDeclaration);
             else
                 varRefExpr = Builder.FieldRefExpr((IFieldDeclaration)decl);
             var nameExpr = Builder.LiteralExpr(varRefExpr.ToString());
diff --git a/src/Compiler/Infer/Transforms/Channel2Transform.cs b/src/Compiler/Infer/Transforms/Channel2Transform.cs
index 5dce31f..1702a37 100644
--- a/src/Compiler/Infer/Transforms/Channel2Transform.cs
+++ b/src/Compiler/Infer/Transforms/Channel2Transform.cs
@@ -261,7 +261,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     }
                 }
 
-                if (rhs != null && rhs is IMethodInvokeExpression imie)
+                if (rhs is IMethodInvokeExpression imie)
                 {
                     bool copyPropagation = false;
                     if (Recognizer.IsStaticGenericMethod(imie, new Func<PlaceHolder, PlaceHolder>(Factor.Copy)) && copyPropagation)
diff --git a/src/Compiler/Infer/Transforms/ChannelInfo.cs b/src/Compiler/Infer/Transforms/ChannelInfo.cs
index d55077d..b149cf2 100644
--- a/src/Compiler/Infer/Transforms/ChannelInfo.cs
+++ b/src/Compiler/Infer/Transforms/ChannelInfo.cs
@@ -214,7 +214,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         public override string ToString()
         {
             if (decl == null) return "ChannelInfo(decl=null)";
-            return String.Format("ChannelInfo({0},isUse={1},isMarginal={2})", decl.ToString(), IsUse, IsMarginal);
+            return $"ChannelInfo({decl.ToString()},isUse={IsUse},isMarginal={IsMarginal})";
         }
     }
 }
diff --git a/src/Compiler/Infer/Transforms/ChannelTransform.cs b/src/Compiler/Infer/Transforms/ChannelTransform.cs
index 59de9a9..93fa2e8 100644
--- a/src/Compiler/Infer/Transforms/ChannelTransform.cs
+++ b/src/Compiler/Infer/Transforms/ChannelTransform.cs
@@ -63,15 +63,14 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
             // Check increment is valid
             fs.Increment = ifs.Increment;
-            IExpressionStatement ies = fs.Increment as IExpressionStatement;
             bool validIncrement = false;
-            if (ies != null)
+
+            if (fs.Increment is IExpressionStatement ies)
             {
                 if (ies.Expression is IAssignExpression)
                 {
                     IAssignExpression iae = (IAssignExpression)ies.Expression;
-                    IBinaryExpression ibe = RemoveCast(iae.Expression) as IBinaryExpression;
-                    validIncrement = (ibe != null) && (ibe.Operator == BinaryOperator.Add);
+                    validIncrement = (RemoveCast(iae.Expression) is IBinaryExpression ibe) && (ibe.Operator == BinaryOperator.Add);
                 }
                 else if (ies.Expression is IUnaryExpression)
                 {
@@ -113,7 +112,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         internal static IExpression RemoveCast(IExpression expr)
         {
             // used to remove spurious casts
-            if (expr is ICastExpression) return ((ICastExpression)expr).Expression;
+            if (expr is ICastExpression iCastExpression) return iCastExpression.Expression;
             return expr;
         }
 
@@ -130,9 +129,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         protected override IExpression ConvertAssign(IAssignExpression iae)
         {
             IExpression targ = Recognizer.StripIndexers(iae.Target);
-            if (targ is IArgumentReferenceExpression)
+            if (targ is IArgumentReferenceExpression iare)
             {
-                IArgumentReferenceExpression iare = (IArgumentReferenceExpression)targ;
                 if (!(iae.Expression is IMethodInvokeExpression)) Error("Cannot redefine the value of parameter '" + iare.Parameter.Name + "'.");
             }
             IAssignExpression ae;
diff --git a/src/Compiler/Infer/Transforms/ConditionBinding.cs b/src/Compiler/Infer/Transforms/ConditionBinding.cs
index 01e3a0a..669c26a 100644
--- a/src/Compiler/Infer/Transforms/ConditionBinding.cs
+++ b/src/Compiler/Infer/Transforms/ConditionBinding.cs
@@ -26,18 +26,16 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             lhs = condition;
             rhs = Builder.LiteralExpr(true);
-            if (condition is IBinaryExpression)
+            if (condition is IBinaryExpression ibe)
             {
-                IBinaryExpression ibe = (IBinaryExpression) condition;
                 if ((ibe.Operator == BinaryOperator.IdentityEquality) || (ibe.Operator == BinaryOperator.ValueEquality))
                 {
                     lhs = ibe.Left;
                     rhs = ibe.Right;
                 }
             }
-            else if (condition is IUnaryExpression)
+            else if (condition is IUnaryExpression iue)
             {
-                IUnaryExpression iue = (IUnaryExpression) condition;
                 if (iue.Operator == UnaryOperator.BooleanNot)
                 {
                     lhs = iue.Expression;
diff --git a/src/Compiler/Infer/Transforms/CopyPropagationTransform.cs b/src/Compiler/Infer/Transforms/CopyPropagationTransform.cs
index 8fc49b8..3274ae7 100644
--- a/src/Compiler/Infer/Transforms/CopyPropagationTransform.cs
+++ b/src/Compiler/Infer/Transforms/CopyPropagationTransform.cs
@@ -226,9 +226,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     if (context.InputAttributes.Has<Initializer>(stmt))
                         return iae;
                 }
-                var imie = iae.Expression as IMethodInvokeExpression;
+
                 // Look for assignments where the right hand side is a SetTo call
-                if (imie != null)
+                if (iae.Expression is IMethodInvokeExpression imie)
                 {
                     bool isCopy = Recognizer.IsStaticGenericMethod(imie, new Func<PlaceHolder, PlaceHolder>(Factor.Copy));
                     bool isSetTo = Recognizer.IsStaticGenericMethod(imie, typeof(ArrayHelper), "SetTo");
@@ -332,12 +332,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
             private void RemoveMatchingSuffixes(IExpression expr1, IExpression expr2, List<IConditionStatement> condContext, out IExpression prefix1, out IExpression prefix2)
             {
-                if (expr1 is IArrayIndexerExpression)
+                if (expr1 is IArrayIndexerExpression iaie1)
                 {
-                    IArrayIndexerExpression iaie1 = (IArrayIndexerExpression)expr1;
-                    if (expr2 is IArrayIndexerExpression)
+                    if (expr2 is IArrayIndexerExpression iaie2)
                     {
-                        IArrayIndexerExpression iaie2 = (IArrayIndexerExpression)expr2;
                         if (iaie1.Indices.Count == iaie2.Indices.Count)
                         {
                             bool allIndicesAreEqual = true;
@@ -401,9 +399,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     if (cc.IsValidContext(context))
                         return cc.Expression;
                 }
-                if (expr is IArrayIndexerExpression)
+                if (expr is IArrayIndexerExpression iaie)
                 {
-                    IArrayIndexerExpression iaie = (IArrayIndexerExpression)expr;
                     if (copiedInEveryElementMap.ContainsKey(iaie.Target))
                     {
                         var cc = copiedInEveryElementMap[iaie.Target];
diff --git a/src/Compiler/Infer/Transforms/DependencyAnalysisTransform.cs b/src/Compiler/Infer/Transforms/DependencyAnalysisTransform.cs
index 45c50cc..788e948 100644
--- a/src/Compiler/Infer/Transforms/DependencyAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/DependencyAnalysisTransform.cs
@@ -218,9 +218,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             foreach (var mut2 in mutations)
             {
                 IStatement required = mut2.stmt;
-                if (required is AnyStatement)
+                if (required is AnyStatement requiredAny)
                 {
-                    AnyStatement requiredAny = (AnyStatement)required;
                     foreach (IStatement required2 in requiredAny.Statements)
                     {
                         di.Add(DependencyType.Dependency | DependencyType.Fresh | DependencyType.Trigger | DependencyType.Overwrite, required2);
@@ -403,16 +402,15 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     IStatement innerStmt = ist;
                     while (Containers.IsContainer(innerStmt))
                     {
-                        if (innerStmt is IForStatement)
-                            innerStmt = ((IForStatement)innerStmt).Body.Statements[0];
-                        else if (innerStmt is IConditionStatement)
-                            innerStmt = ((IConditionStatement)innerStmt).Then.Statements[0];
+                        if (innerStmt is IForStatement iForStatement)
+                            innerStmt = iForStatement.Body.Statements[0];
+                        else if (innerStmt is IConditionStatement iConditionStatement)
+                            innerStmt = iConditionStatement.Then.Statements[0];
                         else
                             throw new Exception();
                     }
-                    if (innerStmt is IExpressionStatement)
+                    if (innerStmt is IExpressionStatement ies)
                     {
-                        IExpressionStatement ies = (IExpressionStatement)innerStmt;
                         if (ies.Expression is IAssignExpression)
                         {
                             IAssignExpression iae = (IAssignExpression)ies.Expression;
@@ -708,12 +706,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         private static bool IsAllocationStatement(BasicTransformContext context, IStatement stmt)
         {
-            if (stmt is IConditionStatement)
-                return IsAllocationStatement(context, ((IConditionStatement)stmt).Then);
-            else if (stmt is IForStatement)
-                return IsAllocationStatement(context, ((IForStatement)stmt).Body);
-            else if (stmt is IBlockStatement)
-                return IsAllocationStatement(context, ((IBlockStatement)stmt).Statements[0]);
+            if (stmt is IConditionStatement iConditionStatement)
+                return IsAllocationStatement(context, iConditionStatement.Then);
+            else if (stmt is IForStatement iForStatement)
+                return IsAllocationStatement(context, iForStatement.Body);
+            else if (stmt is IBlockStatement iBlockStatement)
+                return IsAllocationStatement(context, iBlockStatement.Statements[0]);
             else // TODO: should use an attribute for AllocationStatement
                 return !context.InputAttributes.Has<OperatorStatement>(stmt);
         }
@@ -836,9 +834,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         if (parameter.Name == "length")
                         {
                             IExpression arg = ioce.Arguments[argIndex];
-                            if (arg is ILiteralExpression)
+                            if (arg is ILiteralExpression iLiteralExpression)
                             {
-                                object argValue = ((ILiteralExpression)arg).Value;
+                                object argValue = iLiteralExpression.Value;
                                 if (argValue is int && (int)argValue == 0)
                                     dependencyInformation.IsUniform = true;
                             }
@@ -1020,9 +1018,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     if (args.Count > 0)
                     {
                         IExpression arg = args[0];
-                        if (arg is ILiteralExpression)
+                        if (arg is ILiteralExpression iLiteralExpression)
                         {
-                            object value = ((ILiteralExpression)arg).Value;
+                            object value = iLiteralExpression.Value;
                             if (0.Equals(value))
                             {
                                 // result is an empty array
@@ -1254,11 +1252,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             foreach (IStatement ist in stmts)
             {
-                if (ist is ExpressionDependency)
-                    action((ExpressionDependency)ist);
-                else if (ist is AnyStatement)
+                if (ist is ExpressionDependency expressionDependency)
+                    action(expressionDependency);
+                else if (ist is AnyStatement anySt)
                 {
-                    AnyStatement anySt = (AnyStatement)ist;
                     ForEachExpressionDependency(anySt.Statements, action);
                 }
                 else
@@ -1399,9 +1396,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     if (allBlock.Statements.Count == 1)
                     {
                         IStatement ist = allBlock.Statements[0];
-                        if (ist is AnyStatement)
+                        if (ist is AnyStatement group)
                         {
-                            AnyStatement group = (AnyStatement)ist;
                             newSt.Statements.AddRange(group.Statements);
                         }
                         else
diff --git a/src/Compiler/Infer/Transforms/DependencyGraph.cs b/src/Compiler/Infer/Transforms/DependencyGraph.cs
index 1723178..a02d552 100644
--- a/src/Compiler/Infer/Transforms/DependencyGraph.cs
+++ b/src/Compiler/Infer/Transforms/DependencyGraph.cs
@@ -159,26 +159,25 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         internal static IExpression TargetExpression(IStatement ist)
         {
-            if (ist is IForStatement)
-                return TargetExpression(((IForStatement)ist).Body.Statements[0]);
-            else if (ist is IConditionStatement)
-                return TargetExpression(((IConditionStatement)ist).Then.Statements[0]);
-            else if (ist is IBlockStatement)
-                return TargetExpression(((IBlockStatement)ist).Statements[0]);
-            else if (ist is ICommentStatement)
+            if (ist is IForStatement iForStatement)
+                return TargetExpression(iForStatement.Body.Statements[0]);
+            else if (ist is IConditionStatement iConditionStatement)
+                return TargetExpression(iConditionStatement.Then.Statements[0]);
+            else if (ist is IBlockStatement iBlockStatement)
+                return TargetExpression(iBlockStatement.Statements[0]);
+            else if (ist is ICommentStatement ics)
             {
-                ICommentStatement ics = (ICommentStatement)ist;
                 return CodeBuilder.Instance.LiteralExpr(ics.Comment.Text);
             }
-            else if (ist is IExpressionStatement)
+            else if (ist is IExpressionStatement iExpressionStatement)
             {
-                IExpression expr = ((IExpressionStatement)ist).Expression;
-                if (expr is IAssignExpression)
+                IExpression expr = iExpressionStatement.Expression;
+                if (expr is IAssignExpression iAssignExpression)
                 {
-                    expr = ((IAssignExpression)expr).Target;
+                    expr = iAssignExpression.Target;
                 }
-                if (expr is IVariableDeclarationExpression)
-                    return CodeBuilder.Instance.LiteralExpr(((IVariableDeclarationExpression)expr).Variable.Name);
+                if (expr is IVariableDeclarationExpression iVariableDeclarationExpression)
+                    return CodeBuilder.Instance.LiteralExpr(iVariableDeclarationExpression.Variable.Name);
                 else
                     return expr;
             }
@@ -644,7 +643,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 if (debug)
                     ForEachFreshDescendant(node, node2 =>
                     {
-                        if (node2 != node) AddEvent(node2, string.Format("initially stale because of ancestor {0} {1}", node, NodeToShortString(node)));
+                        if (node2 != node) AddEvent(node2, $"initially stale because of ancestor {node} {NodeToShortString(node)}");
                         nodesToAdd.Add(node2);
                     });
                 else
@@ -667,9 +666,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             bool topLevel = (anyCounter == 0);
             foreach (IStatement source in sources)
             {
-                if (source is AnyStatement)
+                if (source is AnyStatement anyBlock)
                 {
-                    AnyStatement anyBlock = (AnyStatement)source;
                     List<IStatement> children = new List<IStatement>();
                     children.AddRange(anyBlock.Statements);
                     if (children.Count == 1)
@@ -1486,13 +1484,13 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         }
                         else if (isRequired[edge])
                         {
-                            messages.Add(string.Format("{0} is missing required input {1}.  Try initializing one of these variables.", NodeToString(node), NodeToShortString(source)));
+                            messages.Add($"{NodeToString(node)} is missing required input {NodeToShortString(source)}.  Try initializing one of these variables.");
                             availableBits |= bitsProvided[edge];
                         }
                     }
                     if (availableBits < requiredBits[node])
                     {
-                        messages.Add(string.Format("{0} is missing required inputs.  Try initializing this variable or one of its inputs.", NodeToString(node)));
+                        messages.Add($"{NodeToString(node)} is missing required inputs.  Try initializing this variable or one of its inputs.");
                     }
                 }
                 available.Add(node);
@@ -1725,7 +1723,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             if (EventHistory.Get != null)
             {
-                EventHistory[node].Add(String.Format("[{0}] {1}", EventCounter++, message));
+                EventHistory[node].Add($"[{EventCounter++}] {message}");
             }
         }
 
diff --git a/src/Compiler/Infer/Transforms/ForwardBackwardTransform.cs b/src/Compiler/Infer/Transforms/ForwardBackwardTransform.cs
index c00db36..71900a5 100644
--- a/src/Compiler/Infer/Transforms/ForwardBackwardTransform.cs
+++ b/src/Compiler/Infer/Transforms/ForwardBackwardTransform.cs
@@ -136,10 +136,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         complement.Remove(loopVar);
                         var transformedStmt2 = dict[complement];
                         DependencyInformation di = context.InputAttributes.Get<DependencyInformation>(transformedStmt);
-                        if (di != null)
-                        {
-                            di.Add(DependencyType.Dependency, transformedStmt2);
-                        }
+                        di?.Add(DependencyType.Dependency, transformedStmt2);
                     }
                 }
             }
@@ -166,10 +163,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             }
             foreach (var stmt in outputBlock)
             {
-                if (stmt is IWhileStatement)
+                if (stmt is IWhileStatement iws)
                 {
                     // recursively collect the child block
-                    IWhileStatement iws = (IWhileStatement)stmt;
                     CollectTransformedStmts(iws.Body.Statements, replacementsInContext);
                     // merge the child replacements into this block's replacements
                     var childReplacements = replacementsInContext[iws.Body.Statements];
@@ -208,9 +204,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             var replacements = replacementsInContext[outputBlock];
             foreach (var stmt in outputBlock)
             {
-                if (stmt is IWhileStatement)
+                if (stmt is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)stmt;
                     // merge this block's replacements into the child's replacements
                     var childReplacements = replacementsInContext[iws.Body.Statements];
                     foreach (var entry in replacements)
@@ -440,9 +435,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     List<IStatement> newContainers = new List<IStatement>();
                     foreach (IStatement container in containersOfSt)
                     {
-                        if (container is IForStatement)
+                        if (container is IForStatement iForStatement)
                         {
-                            IExpression loopVarExpr = Builder.VarRefExpr(Recognizer.LoopVariable((IForStatement)container));
+                            IExpression loopVarExpr = Builder.VarRefExpr(Recognizer.LoopVariable(iForStatement));
                             if (frame.replacements.ContainsKey(loopVarExpr))
                             {
                                 // add all missing containers
@@ -482,11 +477,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             // this copies across the DependencyInformation unchanged
             // PostProcessDependencies later updates the DependencyInformation
             context.InputAttributes.CopyObjectAttributesTo(ist, context.OutputAttributes, newSt);
-            if (loopMergingInfo != null)
-            {
-                // update loopMergingInfo with the new statement
-                loopMergingInfo.AddEquivalentStatement(newSt, loopMergingInfo.GetIndexOf(ist));
-            }
+            loopMergingInfo?.AddEquivalentStatement(newSt, loopMergingInfo.GetIndexOf(ist));
             return newSt;
         }
 
@@ -875,14 +866,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         private IExpression GetContainerDescription(IStatement container)
         {
-            if (container is IForStatement)
+            if (container is IForStatement ifs)
             {
-                IForStatement ifs = (IForStatement)container;
                 return Builder.VarRefExpr(Recognizer.LoopVariable(ifs));
             }
-            else if (container is IConditionStatement)
+            else if (container is IConditionStatement ics)
             {
-                IConditionStatement ics = (IConditionStatement)container;
                 return ics.Condition;
             }
             else throw new NotSupportedException(container.ToString());
@@ -925,7 +914,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                                             if (frame.replacements.ContainsKey(key))
                                             {
                                                 if (!frame.replacements[key].Equals(value))
-                                                    Error(string.Format("conflicting replacements for {0}: {1} and {2}", key, frame.replacements[key], value));
+                                                    Error($"conflicting replacements for {key}: {frame.replacements[key]} and {value}");
                                             }
                                             else if (!key.Equals(value))
                                                 frame.replacements.Add(key, value);
@@ -956,9 +945,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             for (int i = 0; i < containers.Count; i++)
             {
                 var container = containers[i];
-                if (container is IForStatement)
+                if (container is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement)container;
                     if (Recognizer.LoopVariable(ifs) == loopVar)
                         return i;
                 }
diff --git a/src/Compiler/Infer/Transforms/GateAnalysisTransform.cs b/src/Compiler/Infer/Transforms/GateAnalysisTransform.cs
index cc56e89..ecd1414 100644
--- a/src/Compiler/Infer/Transforms/GateAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/GateAnalysisTransform.cs
@@ -510,8 +510,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             for (int i = 0; i < context.InputStack.Count; i++)
             {
-                IStatement st = context.InputStack[i].inputElement as IStatement;
-                if (st != null && context.InputAttributes.Get<GateBlock>(st) == gateBlock) return i;
+                if (context.InputStack[i].inputElement is IStatement st && context.InputAttributes.Get<GateBlock>(st) == gateBlock) return i;
             }
             return -1;
         }
@@ -533,9 +532,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         private IExpression ReplaceLocalIndices(GateBlock gateBlock, IExpression expr)
         {
-            if (expr is IArrayIndexerExpression)
+            if (expr is IArrayIndexerExpression iaie)
             {
-                IArrayIndexerExpression iaie = (IArrayIndexerExpression) expr;
                 IExpression target = ReplaceLocalIndices(gateBlock, iaie.Target);
                 List<IExpression> indices = new List<IExpression>();
                 bool replaced = !ReferenceEquals(target, iaie.Target);
@@ -725,12 +723,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             {
                 IExpression prefix1 = prefixes1[i];
                 IExpression prefix2 = prefixes2[i];
-                if (prefix1 is IArrayIndexerExpression)
+                if (prefix1 is IArrayIndexerExpression iaie1)
                 {
-                    IArrayIndexerExpression iaie1 = (IArrayIndexerExpression) prefix1;
-                    if (prefix2 is IArrayIndexerExpression)
+                    if (prefix2 is IArrayIndexerExpression iaie2)
                     {
-                        IArrayIndexerExpression iaie2 = (IArrayIndexerExpression) prefix2;
                         if (iaie1.Indices.Count != iaie2.Indices.Count) throw new Exception("Array rank mismatch: " + eb1 + "," + eb2);
                         IList<IExpression> indices = Builder.ExprCollection();
                         for (int ind = 0; ind < iaie1.Indices.Count; ind++)
diff --git a/src/Compiler/Infer/Transforms/GateTransform.cs b/src/Compiler/Infer/Transforms/GateTransform.cs
index a9cc4fe..d2e8231 100644
--- a/src/Compiler/Infer/Transforms/GateTransform.cs
+++ b/src/Compiler/Infer/Transforms/GateTransform.cs
@@ -159,9 +159,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             if (caseValue.GetExpressionType().Equals(typeof(bool)))
             {
                 isBinaryCondition = true;
-                if (caseValue is ILiteralExpression)
+                if (caseValue is ILiteralExpression iLiteralExpression)
                 {
-                    bool value = (bool) ((ILiteralExpression) caseValue).Value;
+                    bool value = (bool) iLiteralExpression.Value;
                     caseNumber = value ? Builder.LiteralExpr(0) : Builder.LiteralExpr(1);
                 }
                 else
@@ -951,9 +951,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         public IExpression ReplaceAnyItem(BasicTransformContext context, IExpression expr, List<IList<IExpression>> indices)
         {
-            if (expr is IArrayIndexerExpression)
+            if (expr is IArrayIndexerExpression iaie)
             {
-                IArrayIndexerExpression iaie = (IArrayIndexerExpression) expr;
                 IExpression result = ReplaceAnyItem(context, iaie.Target, indices);
                 IList<IExpression> newIndices = Builder.ExprCollection();
                 IList<IExpression> allIndices = Builder.ExprCollection();
@@ -1267,13 +1266,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         internal string ToString(IExpression expr)
         {
-            if (expr is IVariableReferenceExpression)
+            if (expr is IVariableReferenceExpression iVariableReferenceExpression)
             {
-                return ((IVariableReferenceExpression) expr).Variable.Resolve().Name;
+                return iVariableReferenceExpression.Variable.Resolve().Name;
             }
-            else if (expr is IArrayIndexerExpression)
+            else if (expr is IArrayIndexerExpression iaie)
             {
-                IArrayIndexerExpression iaie = (IArrayIndexerExpression) expr;
                 StringBuilder sb = new StringBuilder(ToString(iaie.Target));
                 foreach (IExpression indExpr in iaie.Indices)
                     sb.Append("_" + ToString(indExpr));
@@ -1352,10 +1350,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             for (int i = 0; i < statements.Count; i++)
             {
                 IStatement s = statements[i];
-                if (s is IForStatement)
+                if (s is IForStatement ifs)
                 {
                     // Recursively wrap the body statements.
-                    IForStatement ifs = (IForStatement) s;
                     IForStatement fs = Builder.ForStmt();
                     fs.Condition = ifs.Condition;
                     fs.Increment = ifs.Increment;
@@ -1366,10 +1363,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     currentConditionStatement = null;
                     continue;
                 }
-                if (s is IRepeatStatement)
+                if (s is IRepeatStatement irs)
                 {
                     // Recursively wrap the body statements.
-                    IRepeatStatement irs = (IRepeatStatement) s;
                     IRepeatStatement rs = Builder.RepeatStmt();
                     rs.Count = irs.Count;
                     rs.Body = WrapBlockWithConditionals(context, irs.Body);
diff --git a/src/Compiler/Infer/Transforms/GroupTransform.cs b/src/Compiler/Infer/Transforms/GroupTransform.cs
index 0da95fb..00fb452 100644
--- a/src/Compiler/Infer/Transforms/GroupTransform.cs
+++ b/src/Compiler/Infer/Transforms/GroupTransform.cs
@@ -1044,7 +1044,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         public override string ToString()
         {
-            return String.Format("Distance {0})", distance);
+            return $"Distance {distance})";
         }
     }
 
@@ -1218,8 +1218,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         public override string ToString()
         {
-            return String.Format("ChannelPath {0}_{1}{2}",
-                                 Path, (Direction == MessageDirection.Backwards) ? "B" : "F", FromDefault ? " (default)" : "");
+            return $"ChannelPath {Path}_{((Direction == MessageDirection.Backwards) ? "B" : "F")}{(FromDefault ? " (default)" : "")}";
         }
 
         /// <summary>
@@ -1345,12 +1344,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             string fromStr = (From == null) ? "Any" : From;
             string toStr = (To == null) ? "Any" : To;
-            string pathStr = String.Format("Path through factor: {0}.{1} to {2}", fromStr, (Path == null) ? "" : Path, toStr);
+            string pathStr = $"Path through factor: {fromStr}.{((Path == null) ? "" : Path)} to {toStr}";
             string rootStr =
                 (FromDistance > ToDistance)
                     ? "towards root"
                     : (FromDistance < ToDistance) ? "away from root" : "";
-            return pathStr + " " + rootStr + String.Format(" ({0},{1})", FromDistance, ToDistance);
+            return pathStr + " " + rootStr + $" ({FromDistance},{ToDistance})";
         }
     }
 
diff --git a/src/Compiler/Infer/Transforms/HoistingTransform.cs b/src/Compiler/Infer/Transforms/HoistingTransform.cs
index d60a60b..bdf168f 100644
--- a/src/Compiler/Infer/Transforms/HoistingTransform.cs
+++ b/src/Compiler/Infer/Transforms/HoistingTransform.cs
@@ -481,9 +481,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 }
                 foreach (var arg in imie.Arguments)
                 {
-                    if (arg is IAddressOutExpression)
+                    if (arg is IAddressOutExpression iaoe)
                     {
-                        IAddressOutExpression iaoe = (IAddressOutExpression)arg;
                         IExpression target;
                         var indices = Recognizer.GetIndices(iaoe.Expression, out target);
                         if (target is IVariableReferenceExpression || target is IVariableDeclarationExpression)
@@ -639,14 +638,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         public static bool IsReducibleArrayCreateExpression(IExpression expr)
         {
-            if (expr is IArrayCreateExpression)
+            if (expr is IArrayCreateExpression iace)
             {
-                IArrayCreateExpression iace = (IArrayCreateExpression)expr;
                 return iace.Initializer == null;
             }
-            else if (expr is IObjectCreateExpression)
+            else if (expr is IObjectCreateExpression ioce)
             {
-                IObjectCreateExpression ioce = (IObjectCreateExpression)expr;
                 Type type = ioce.Type.DotNetType;
                 Type gtd = type.IsGenericType ? type.GetGenericTypeDefinition() : type;
                 bool reducible =
diff --git a/src/Compiler/Infer/Transforms/IfCuttingTransform.cs b/src/Compiler/Infer/Transforms/IfCuttingTransform.cs
index dae40c6..b4a8100 100644
--- a/src/Compiler/Infer/Transforms/IfCuttingTransform.cs
+++ b/src/Compiler/Infer/Transforms/IfCuttingTransform.cs
@@ -55,12 +55,11 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 keepIfStatement = true;
                 if (CodeRecognizer.IsInfer(expr)) keepIfStatement = false;
             }
-            else if (expr is IAssignExpression)
+            else if (expr is IAssignExpression iae)
             {
                 keepIfStatement = false;
-                IAssignExpression iae = (IAssignExpression) expr;
-                IMethodInvokeExpression imie = iae.Expression as IMethodInvokeExpression;
-                if (imie != null)
+
+                if (iae.Expression is IMethodInvokeExpression imie)
                 {
                     keepIfStatement = true;
                     if (imie.Arguments.Count > 0)
@@ -77,9 +76,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     expr = iae.Target;
                 }
             }
-            if (expr is IVariableDeclarationExpression)
+            if (expr is IVariableDeclarationExpression ivde)
             {
-                IVariableDeclarationExpression ivde = (IVariableDeclarationExpression) expr;
                 IVariableDeclaration ivd = ivde.Variable;
                 keepIfStatement = CodeRecognizer.IsStochastic(context, ivd) && !context.InputAttributes.Has<DoNotSendEvidence>(ivd);
             }
diff --git a/src/Compiler/Infer/Transforms/IncrementPruningTransform.cs b/src/Compiler/Infer/Transforms/IncrementPruningTransform.cs
index 18c269b..d303378 100644
--- a/src/Compiler/Infer/Transforms/IncrementPruningTransform.cs
+++ b/src/Compiler/Infer/Transforms/IncrementPruningTransform.cs
@@ -97,8 +97,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         protected override IStatement DoConvertStatement(IStatement ist)
         {
-            if (ist is IWhileStatement)
-                return ConvertWhile((IWhileStatement)ist);
+            if (ist is IWhileStatement iWhileStatement)
+                return ConvertWhile(iWhileStatement);
             if (replacements.ContainsKey(ist))
                 return null;
             bool isIncrement = context.InputAttributes.Has<IncrementStatement>(ist);
diff --git a/src/Compiler/Infer/Transforms/IndexAnalysisTransform.cs b/src/Compiler/Infer/Transforms/IndexAnalysisTransform.cs
index a89aea4..581f9e9 100644
--- a/src/Compiler/Infer/Transforms/IndexAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/IndexAnalysisTransform.cs
@@ -104,9 +104,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             var indices = Recognizer.GetIndices(iaie);
             bool allLoopIndices = indices.All(bracket => bracket.All(indexExpr =>
             {
-                if (indexExpr is IVariableReferenceExpression)
+                if (indexExpr is IVariableReferenceExpression ivre)
                 {
-                    IVariableReferenceExpression ivre = (IVariableReferenceExpression)indexExpr;
                     return (Recognizer.GetLoopForVariable(context, ivre) != null);
                 }
                 else
@@ -131,9 +130,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             List<ConditionBinding> bindings = new List<ConditionBinding>();
             foreach (IStatement st in containers)
             {
-                if (st is IConditionStatement)
+                if (st is IConditionStatement ics)
                 {
-                    IConditionStatement ics = (IConditionStatement) st;
                     if (!CodeRecognizer.IsStochastic(context, ics.Condition))
                     {
                         ConditionBinding binding = new ConditionBinding(ics.Condition);
diff --git a/src/Compiler/Infer/Transforms/IndexingTransform.cs b/src/Compiler/Infer/Transforms/IndexingTransform.cs
index 854b3c8..5fd20d8 100644
--- a/src/Compiler/Infer/Transforms/IndexingTransform.cs
+++ b/src/Compiler/Infer/Transforms/IndexingTransform.cs
@@ -101,9 +101,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         IArrayIndexerExpression parent_iaie = (IArrayIndexerExpression)parent;
                         foreach (IExpression index in parent_iaie.Indices)
                         {
-                            if (index is ILiteralExpression)
+                            if (index is ILiteralExpression iLiteralExpression)
                             {
-                                int value = (int)((ILiteralExpression)index).Value;
+                                int value = (int)iLiteralExpression.Value;
                                 if (value != 0)
                                 {
                                     extraLiteralsAreZero = false;
@@ -531,8 +531,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         protected override IExpression ConvertMethodInvoke(IMethodInvokeExpression imie)
         {
             IExpression result = base.ConvertMethodInvoke(imie);
-            if (result is IMethodInvokeExpression)
-                imie = (IMethodInvokeExpression)result;
+            if (result is IMethodInvokeExpression iMethodInvokeExpression)
+                imie = iMethodInvokeExpression;
             else
                 return result;
             if (UseJaggedSubarray && Recognizer.IsStaticGenericMethod(imie, new Func<IList<PlaceHolder>, IList<int>, IList<PlaceHolder>>(Factor.Subarray)))
@@ -540,9 +540,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 // check for the form Subarray(arrayExpr, indices[i]) where arrayExpr does not depend on i
                 IExpression arrayExpr = imie.Arguments[0];
                 IExpression arg1 = imie.Arguments[1];
-                if (arg1 is IArrayIndexerExpression)
+                if (arg1 is IArrayIndexerExpression index)
                 {
-                    IArrayIndexerExpression index = (IArrayIndexerExpression)arg1;
                     if (index.Indices.Count == 1 && index.Indices[0] is IVariableReferenceExpression)
                     {
                         // index has the form indices[i]
@@ -701,9 +700,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     if (Builder.ContainsExpression(ifs.Condition, expr))
                         continue;
                 }
-                else if (container is IConditionStatement)
+                else if (container is IConditionStatement ics)
                 {
-                    IConditionStatement ics = (IConditionStatement)container;
                     if (Builder.ContainsExpression(ics.Condition, expr))
                         continue;
                 }
diff --git a/src/Compiler/Infer/Transforms/InitializerTransform.cs b/src/Compiler/Infer/Transforms/InitializerTransform.cs
index b57b369..571a977 100644
--- a/src/Compiler/Infer/Transforms/InitializerTransform.cs
+++ b/src/Compiler/Infer/Transforms/InitializerTransform.cs
@@ -60,9 +60,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             for (int i = 0; i < inputs.Count; i++)
             {
                 IStatement ist = inputs[i];
-                if (ist is IWhileStatement)
+                if (ist is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)ist;
                     IWhileStatement ws = Builder.WhileStmt(iws);
                     bool doNotSchedule = context.InputAttributes.Has<DoNotSchedule>(iws);
                     if (doNotSchedule)
@@ -147,9 +146,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             // update all dependencies
             foreach (IStatement ist in outputs)
             {
-                if (ist is IWhileStatement)
+                if (ist is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)ist;
                     foreach (IStatement st in iws.Body.Statements)
                     {
                         DependencyInformation di2 = context.OutputAttributes.Get<DependencyInformation>(st);
diff --git a/src/Compiler/Infer/Transforms/IterationTransform.cs b/src/Compiler/Infer/Transforms/IterationTransform.cs
index fbf0b20..f7a970f 100644
--- a/src/Compiler/Infer/Transforms/IterationTransform.cs
+++ b/src/Compiler/Infer/Transforms/IterationTransform.cs
@@ -223,7 +223,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             IndexedProperty<NodeIndex, bool> isUniform = graph2.CreateNodeData<bool>(true);
             foreach (StatementBlock block in blocks)
             {
-                if (block is Loop)
+                if (block is Loop loop)
                 {
                     foreach (NodeIndex i in block.indices)
                     {
@@ -255,9 +255,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                             // add all statements in sc3 to whileBody, but remove while loops around a single statement.
                             foreach (IStatement ist in sc3)
                             {
-                                if (ist is IWhileStatement)
+                                if (ist is IWhileStatement iws2)
                                 {
-                                    IWhileStatement iws2 = (IWhileStatement)ist;
                                     if (iws2.Body.Statements.Count == 1)
                                     {
                                         whileBody.AddRange(iws2.Body.Statements);
@@ -280,7 +279,6 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         }
                         RegisterUnchangedStatements(whileBody);
                     }
-                    Loop loop = (Loop)block;
                     if (firstIterPostprocessing != null && firstIterPostprocessing.ContainsKey(loop))
                     {
                         var thenBlock = firstIterPostprocessing[loop];
@@ -365,9 +363,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             Dictionary<Loop, IBlockStatement> firstIterPostprocessing = new Dictionary<Loop, IBlockStatement>();
             foreach (StatementBlock block in blocks)
             {
-                if (block is Loop)
+                if (block is Loop loop)
                 {
-                    Loop loop = (Loop)block;
                     // find the set of initialized nodes that are ancestors of the loop (and not ancestors of an ancestor loop)
                     // find all nodes that are ancestors of the loop and descendants of (and including) the init nodes - cannot contain any loops
                     // because we do not clear dfs, all previous stmts in loops are excluded.
diff --git a/src/Compiler/Infer/Transforms/IterativeProcessTransform.cs b/src/Compiler/Infer/Transforms/IterativeProcessTransform.cs
index 293cdb5..6cf83a3 100644
--- a/src/Compiler/Infer/Transforms/IterativeProcessTransform.cs
+++ b/src/Compiler/Infer/Transforms/IterativeProcessTransform.cs
@@ -675,9 +675,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 if (compiler.ReturnCopies)
                 {
                     IStatement ist = nodes[target];
-                    if (ist is IExpressionStatement)
+                    if (ist is IExpressionStatement ies)
                     {
-                        IExpressionStatement ies = (IExpressionStatement)ist;
                         IExpression expr = ies.Expression;
                         if (expr is IAssignExpression)
                         {
@@ -1040,9 +1039,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         // not in the loop
                         initializers.Add(initIndex);
                         IStatement node = nodes[initIndex];
-                        if (node is IWhileStatement)
+                        if (node is IWhileStatement iWhileStatement)
                         {
-                            AddLoopInitializers((IWhileStatement)node, initIndex, initializers, indexOfNode, nodes);
+                            AddLoopInitializers(iWhileStatement, initIndex, initializers, indexOfNode, nodes);
                         }
                     }
                 }
@@ -1210,9 +1209,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <param name="action"></param>
         private void ForEachDeclaration(IStatement ist, Action<IVariableDeclaration> action)
         {
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
-                IExpressionStatement ies = (IExpressionStatement)ist;
                 IExpression expr = ies.Expression;
                 if (expr is IAssignExpression)
                 {
@@ -1226,17 +1224,15 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         action(ivd);
                 }
             }
-            else if (ist is IConditionStatement)
+            else if (ist is IConditionStatement ics)
             {
-                IConditionStatement ics = (IConditionStatement)ist;
                 foreach (IStatement st in ics.Then.Statements)
                 {
                     ForEachDeclaration(st, action);
                 }
             }
-            else if (ist is IForStatement)
+            else if (ist is IForStatement ifs)
             {
-                IForStatement ifs = (IForStatement)ist;
                 foreach (IStatement st in ifs.Body.Statements)
                 {
                     ForEachDeclaration(st, action);
@@ -1612,9 +1608,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             // Catch any quality attributes not handled by the transforms:
             if (qual == null)
             {
-                if (ie is IVariableDeclarationExpression)
+                if (ie is IVariableDeclarationExpression ivde)
                 {
-                    IVariableDeclarationExpression ivde = (IVariableDeclarationExpression)ie;
                     Type ty = ivde.GetExpressionType();
                     if (Distribution.HasDistributionType(ty))
                         // (1) If a distribution type, then get the quality whether unknown or known
@@ -1627,10 +1622,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                             qual = new QualityBandCompilerAttribute(qb);
                     }
                 }
-                else if (ie is IMethodInvokeExpression)
+                else if (ie is IMethodInvokeExpression imie)
                 {
                     // (3) If a method reference, only handle if there is a non-unknown quality
-                    IMethodInvokeExpression imie = (IMethodInvokeExpression)ie;
                     IMethodReference imr = imie.Method.Method;
                     QualityBand qb = Quality.GetQualityBand(imr.MethodInfo);
                     if (qb != QualityBand.Unknown)
@@ -1642,12 +1636,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             {
                 if (qual.QualityBand < compiler.RequiredQuality)
                     Error(
-                        String.Format("{0} has quality band {1} which is less than the required quality band ({2})",
-                                      ie, qual.QualityBand, compiler.RequiredQuality));
+                        $"{ie} has quality band {qual.QualityBand} which is less than the required quality band ({compiler.RequiredQuality})");
                 else if (qual.QualityBand < compiler.RecommendedQuality)
                     Warning(
-                        String.Format("{0} has quality band {1} which is less than the recommended quality band ({2})",
-                                      ie, qual.QualityBand, compiler.RecommendedQuality));
+                        $"{ie} has quality band {qual.QualityBand} which is less than the recommended quality band ({compiler.RecommendedQuality})");
             }
         }
 
diff --git a/src/Compiler/Infer/Transforms/LinqExpressionTransform.cs b/src/Compiler/Infer/Transforms/LinqExpressionTransform.cs
index acc7f51..3a438fd 100644
--- a/src/Compiler/Infer/Transforms/LinqExpressionTransform.cs
+++ b/src/Compiler/Infer/Transforms/LinqExpressionTransform.cs
@@ -26,29 +26,29 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         internal IExpression Convert(System.Linq.Expressions.Expression expression)
         {
-            if (expression is System.Linq.Expressions.LambdaExpression)
+            if (expression is System.Linq.Expressions.LambdaExpression lambdaExpression)
             {
-                return ConvertLambda((System.Linq.Expressions.LambdaExpression) expression);
+                return ConvertLambda(lambdaExpression);
             }
-            if (expression is System.Linq.Expressions.BinaryExpression)
+            if (expression is System.Linq.Expressions.BinaryExpression binaryExpression)
             {
-                return ConvertBinary((System.Linq.Expressions.BinaryExpression) expression);
+                return ConvertBinary(binaryExpression);
             }
-            if (expression is System.Linq.Expressions.MemberExpression)
+            if (expression is System.Linq.Expressions.MemberExpression memberExpression)
             {
-                return ConvertMember((System.Linq.Expressions.MemberExpression) expression);
+                return ConvertMember(memberExpression);
             }
-            if (expression is System.Linq.Expressions.ParameterExpression)
+            if (expression is System.Linq.Expressions.ParameterExpression parameterExpression)
             {
-                return ConvertParameterRef((System.Linq.Expressions.ParameterExpression) expression);
+                return ConvertParameterRef(parameterExpression);
             }
-            if (expression is System.Linq.Expressions.ConstantExpression)
+            if (expression is System.Linq.Expressions.ConstantExpression constantExpression)
             {
-                return ConvertConstant((System.Linq.Expressions.ConstantExpression) expression);
+                return ConvertConstant(constantExpression);
             }
-            if (expression is System.Linq.Expressions.MethodCallExpression)
+            if (expression is System.Linq.Expressions.MethodCallExpression methodCallExpression)
             {
-                return ConvertMethodCall((System.Linq.Expressions.MethodCallExpression) expression);
+                return ConvertMethodCall(methodCallExpression);
             }
 
             throw new NotImplementedException("Could not convert expression of type " + expression.GetType().Name + ": " + expression);
diff --git a/src/Compiler/Infer/Transforms/LocalAllocationTransform.cs b/src/Compiler/Infer/Transforms/LocalAllocationTransform.cs
index cac227f..aa2fd26 100644
--- a/src/Compiler/Infer/Transforms/LocalAllocationTransform.cs
+++ b/src/Compiler/Infer/Transforms/LocalAllocationTransform.cs
@@ -512,7 +512,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     var containers = containersOfNode[node];
                     CloneInfos infos = new CloneInfos();
                     var readAfterWriteEdges = dependencyGraph.EdgesOutOf(node).Where(edge => !g.isWriteAfterRead[edge]);
-                    if (readAfterWriteEdges.Count() == 0)
+                    if (!readAfterWriteEdges.Any())
                     {
                         infos.targetsByReversedLoops.Add(new Set<IVariableDeclaration>(), new CloneInfo() { clone = node });
                     }
@@ -873,9 +873,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             }
             foreach (var container in containersOfNode[node])
             {
-                if (container is IForStatement)
+                if (container is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement)container;
                     var loopVar = Recognizer.LoopVariable(ifs);
                     int conflict = loopMergingInfo.GetConflictingStmt(targets, stmtIndex, loopVar, isForwardLoop: true);
                     return (conflict != -1);
@@ -892,9 +891,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 IAssignExpression iae = (IAssignExpression)ies.Expression;
                 target = iae.Target;
             }
-            if (target is IVariableDeclarationExpression)
+            if (target is IVariableDeclarationExpression ivde)
             {
-                IVariableDeclarationExpression ivde = (IVariableDeclarationExpression)target;
                 IVariableDeclaration ivd = ivde.Variable;
                 return ivd;
             }
@@ -1120,9 +1118,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             Set<IVariableDeclaration> mutatedVariables = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
             ForEachInitializerStatement(stmt, init =>
             {
-                if (init is IExpressionStatement)
+                if (init is IExpressionStatement ies)
                 {
-                    IExpressionStatement ies = (IExpressionStatement)init;
                     IVariableDeclaration ivd = GetVariableDeclaration(ies);
                     if (ivd != null)
                         mutatedVariables.Add(ivd);
@@ -1238,7 +1235,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             }
             else
                 nodeString = nodes[node].ToString();
-            return string.Format("{0} {1}{2}", node, groupString, nodeString);
+            return $"{node} {groupString}{nodeString}";
         }
 
         protected override IStatement DoConvertStatement(IStatement ist)
diff --git a/src/Compiler/Infer/Transforms/LocalAllocationTransform2.cs b/src/Compiler/Infer/Transforms/LocalAllocationTransform2.cs
index 3da3165..2cf1dd0 100644
--- a/src/Compiler/Infer/Transforms/LocalAllocationTransform2.cs
+++ b/src/Compiler/Infer/Transforms/LocalAllocationTransform2.cs
@@ -558,9 +558,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 IAssignExpression iae = (IAssignExpression)ies.Expression;
                 target = iae.Target;
             }
-            if (target is IVariableDeclarationExpression)
+            if (target is IVariableDeclarationExpression ivde)
             {
-                IVariableDeclarationExpression ivde = (IVariableDeclarationExpression)target;
                 IVariableDeclaration ivd = ivde.Variable;
                 return ivd;
             }
@@ -734,9 +733,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             Set<IVariableDeclaration> mutatedVariables = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
             ForEachInitializerStatement(stmt, init =>
             {
-                if (init is IExpressionStatement)
+                if (init is IExpressionStatement ies)
                 {
-                    IExpressionStatement ies = (IExpressionStatement)init;
                     IVariableDeclaration ivd = GetVariableDeclaration(ies);
                     if (ivd != null)
                         mutatedVariables.Add(ivd);
@@ -863,9 +861,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 int mergableContainerCount = 0;
                 foreach (var container in containersOfNode[reader])
                 {
-                    if (container is IForStatement)
+                    if (container is IForStatement ifs)
                     {
-                        IForStatement ifs = (IForStatement)container;
                         var loopVar = Recognizer.LoopVariable(ifs);
                         int conflict = loopMergingInfo.GetConflictingStmt(sources, stmtIndex, loopVar, Recognizer.IsForwardLoop(ifs));
                         if (conflict != -1)
@@ -1269,7 +1266,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             }
             else
                 nodeString = nodes[node].ToString();
-            return string.Format("{0} {1}{2}", node, groupString, nodeString);
+            return $"{node} {groupString}{nodeString}";
         }
 
         protected override IStatement DoConvertStatement(IStatement ist)
diff --git a/src/Compiler/Infer/Transforms/LocalTransform.cs b/src/Compiler/Infer/Transforms/LocalTransform.cs
index 7d462c3..2eabf24 100644
--- a/src/Compiler/Infer/Transforms/LocalTransform.cs
+++ b/src/Compiler/Infer/Transforms/LocalTransform.cs
@@ -137,9 +137,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             foreach (var container in containers.inputs)
             {
-                if (container is IForStatement)
+                if (container is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement)container;
                     IVariableDeclaration loopVar = Recognizer.LoopVariable(ifs);
                     if (context.InputAttributes.Has<Partitioned>(loopVar)) return true;
                 }
@@ -519,9 +518,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 {
                     var loopSize = Recognizer.LoopSizeExpression(closedContainer);
                     bool loopMustExecute = false;
-                    if (loopSize is ILiteralExpression)
+                    if (loopSize is ILiteralExpression iLiteralExpression)
                     {
-                        int loopSizeAsInt = (int)((ILiteralExpression)loopSize).Value;
+                        int loopSizeAsInt = (int)iLiteralExpression.Value;
                         if (loopSizeAsInt > 0)
                         {
                             loopMustExecute = true;
@@ -567,9 +566,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             string containerString = StringUtil.ToString(containers.Select(c =>
             {
-                if (c is IForStatement)
+                if (c is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement)c;
                     if (c is IBrokenForStatement)
                         return ifs.Initializer.ToString() + " // broken";
                     else
@@ -585,9 +583,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         private static IExpression GetContainerExpression(IStatement container)
         {
-            if (container is IForStatement) return Recognizer.LoopSizeExpression((IForStatement)container);
-            else if (container is IConditionStatement) return ((IConditionStatement)container).Condition;
-            else if (container is IRepeatStatement) return ((IRepeatStatement)container).Count;
+            if (container is IForStatement iForStatement) return Recognizer.LoopSizeExpression(iForStatement);
+            else if (container is IConditionStatement iConditionStatement) return iConditionStatement.Condition;
+            else if (container is IRepeatStatement iRepeatStatement) return iRepeatStatement.Count;
             else throw new ArgumentException($"unrecognized container type: {container.GetType()}");
         }
 
diff --git a/src/Compiler/Infer/Transforms/LoopMergingTransform.cs b/src/Compiler/Infer/Transforms/LoopMergingTransform.cs
index 204f015..c4eb3fc 100644
--- a/src/Compiler/Infer/Transforms/LoopMergingTransform.cs
+++ b/src/Compiler/Infer/Transforms/LoopMergingTransform.cs
@@ -162,9 +162,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         private int GetPriority(IStatement container)
         {
-            if (container is IForStatement)
+            if (container is IForStatement ifs)
             {
-                IForStatement ifs = (IForStatement)container;
                 IVariableDeclaration loopVar = Recognizer.LoopVariable(ifs);
                 return GetPriority(context, loopVar);
             }
@@ -239,9 +238,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         // Modifies affectingVariables.
         internal static bool ContainerAffectsVariables(IStatement container, Set<IVariableDeclaration> affectingVariables)
         {
-            if (container is IForStatement)
+            if (container is IForStatement ifs2)
             {
-                IForStatement ifs2 = (IForStatement)container;
                 if (affectingVariables.Contains(Recognizer.LoopVariable(ifs2)))
                 {
                     // all variables in the loop bounds become affecting variables.
@@ -253,9 +251,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 }
                 return false;
             }
-            else if (container is IConditionStatement)
+            else if (container is IConditionStatement ics)
             {
-                IConditionStatement ics = (IConditionStatement)container;
                 // if the condition refers to an affecting variable, then it is a parent.
                 bool isParent = Recognizer.GetVariables(ics.Condition).Any(affectingVariables.Contains);
                 if (isParent)
@@ -410,10 +407,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         internal static IList<IStatement> UnwrapStatement(IStatement ist, List<IStatement> containers)
         {
-            if (ist is IForStatement)
+            if (ist is IForStatement ifs)
             {
                 containers.Add(ist);
-                IForStatement ifs = (IForStatement)ist;
                 if (ifs.Body.Statements.Count == 1)
                 {
                     return UnwrapStatement(ifs.Body.Statements[0], containers);
@@ -423,10 +419,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     return ifs.Body.Statements;
                 }
             }
-            else if (ist is IConditionStatement)
+            else if (ist is IConditionStatement ics)
             {
                 containers.Add(ist);
-                IConditionStatement ics = (IConditionStatement)ist;
                 if (ics.Then.Statements.Count == 1)
                 {
                     return UnwrapStatement(ics.Then.Statements[0], containers);
diff --git a/src/Compiler/Infer/Transforms/LoopOrderingTransform.cs b/src/Compiler/Infer/Transforms/LoopOrderingTransform.cs
index d2ca6ca..74cb988 100644
--- a/src/Compiler/Infer/Transforms/LoopOrderingTransform.cs
+++ b/src/Compiler/Infer/Transforms/LoopOrderingTransform.cs
@@ -30,9 +30,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             if (ics != null && ics.Then.Statements.Count == 1)
             {
                 IStatement st = ics.Then.Statements[0];
-                if (st is IForStatement)
+                if (st is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement) st;
                     IVariableDeclaration loopVar = Recognizer.LoopVariable(ifs);
                     bool isSequential = context.InputAttributes.Has<Sequential>(loopVar);
                     if (isSequential)
diff --git a/src/Compiler/Infer/Transforms/LoopRemovalTransform.cs b/src/Compiler/Infer/Transforms/LoopRemovalTransform.cs
index f3266d6..c8ffd05 100644
--- a/src/Compiler/Infer/Transforms/LoopRemovalTransform.cs
+++ b/src/Compiler/Infer/Transforms/LoopRemovalTransform.cs
@@ -48,9 +48,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             variablesInConditions.AddRange(oldVariablesInConditions);
             if (!bodyContainsLoopVar && !conditionsContainLoopVar)
             {
-                if (loopSize is ILiteralExpression)
+                if (loopSize is ILiteralExpression iLiteralExpression)
                 {
-                    int loopSizeAsInt = (int)((ILiteralExpression)loopSize).Value;
+                    int loopSizeAsInt = (int)iLiteralExpression.Value;
                     if (loopSizeAsInt <= 0) return null;
                     else if (newBody.Statements.Count > 1) throw new InferCompilerException("newBody.Statements.Count > 1");
                     else return newBody.Statements[0];
diff --git a/src/Compiler/Infer/Transforms/LoopReversalTransform.cs b/src/Compiler/Infer/Transforms/LoopReversalTransform.cs
index 4599815..cfa2eed 100644
--- a/src/Compiler/Infer/Transforms/LoopReversalTransform.cs
+++ b/src/Compiler/Infer/Transforms/LoopReversalTransform.cs
@@ -155,11 +155,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             IStatement st = base.ConvertWhile(iws);
             InitializerSet initSet = context.InputAttributes.Get<InitializerSet>(iws);
-            if (initSet != null)
-            {
-                // initializers occur in the loop, so all replacements should already be known.
-                initSet.Replace(replacements);
-            }
+            initSet?.Replace(replacements);
             return st;
         }
 
@@ -405,9 +401,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                             bool isForwardLoop = true;
                             foreach (var container in containers)
                             {
-                                if (container is IForStatement)
+                                if (container is IForStatement ifs)
                                 {
-                                    IForStatement ifs = (IForStatement)container;
                                     if (Recognizer.LoopVariable(ifs) == loopVar)
                                     {
                                         isForwardLoop = Recognizer.IsForwardLoop(ifs);
diff --git a/src/Compiler/Infer/Transforms/LoopUnrollingTransform.cs b/src/Compiler/Infer/Transforms/LoopUnrollingTransform.cs
index dc0cdbb..3349e7f 100644
--- a/src/Compiler/Infer/Transforms/LoopUnrollingTransform.cs
+++ b/src/Compiler/Infer/Transforms/LoopUnrollingTransform.cs
@@ -37,9 +37,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         internal static ConditionBinding GetInitializerBinding(IForStatement ifs)
         {
             IStatement ist = ifs.Initializer;
-            if (ist is IBlockStatement)
+            if (ist is IBlockStatement iBlockStatement)
             {
-                if (((IBlockStatement) ist).Statements.Count != 1) throw new Exception("Unhandled loop initializer: " + ist);
+                if (iBlockStatement.Statements.Count != 1) throw new Exception("Unhandled loop initializer: " + ist);
                 ist = ((IBlockStatement) ist).Statements[0];
             }
             IExpressionStatement init = (IExpressionStatement) ist;
@@ -51,9 +51,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         protected override IStatement ConvertFor(IForStatement ifs)
         {
             IExpression sizeExpr = Recognizer.LoopSizeExpression(ifs);
-            if (sizeExpr is ILiteralExpression)
+            if (sizeExpr is ILiteralExpression iLiteralExpression)
             {
-                int size = (int) ((ILiteralExpression) sizeExpr).Value;
+                int size = (int) iLiteralExpression.Value;
                 if (size < 20)
                 {
                     ConditionBinding binding = GetInitializerBinding(ifs);
diff --git a/src/Compiler/Infer/Transforms/MessageTransform.cs b/src/Compiler/Infer/Transforms/MessageTransform.cs
index 5b1b42b..6175ff6 100644
--- a/src/Compiler/Infer/Transforms/MessageTransform.cs
+++ b/src/Compiler/Infer/Transforms/MessageTransform.cs
@@ -816,11 +816,11 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 string msgText = msg.ToString();
                 // Look for TraceMessages attribute that matches this message
                 var trace = context.InputAttributes.Get<TraceMessages>(mi.channelDecl);
-                if (trace != null && trace.Containing != null && !msgText.Contains(trace.Containing)) trace = null;
+                if (trace?.Containing != null && !msgText.Contains(trace.Containing)) trace = null;
 
                 // Look for ListenToMessages attribute that matches this message
                 var listenTo = context.InputAttributes.Get<ListenToMessages>(mi.channelDecl);
-                if (listenTo != null && listenTo.Containing != null && !msgText.Contains(listenTo.Containing)) listenTo = null;
+                if (listenTo?.Containing != null && !msgText.Contains(listenTo.Containing)) listenTo = null;
 
 
                 if ((listenTo != null) || (trace != null) || compiler.TraceAllMessages)
@@ -1390,7 +1390,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
                 // Flag an error if there are two inconsistent non-default paths
                 if (foundNonDefault && notDefault && cpa.Path != path)
-                    Error(String.Format("Inconsistent message types for {0}. If you have manually specified groups, try changing the root variable.", messageName));
+                    Error($"Inconsistent message types for {messageName}. If you have manually specified groups, try changing the root variable.");
 
                 if (!foundNonDefault)
                 {
diff --git a/src/Compiler/Infer/Transforms/ModelAnalysisTransform.cs b/src/Compiler/Infer/Transforms/ModelAnalysisTransform.cs
index ac7eb33..6686dc5 100644
--- a/src/Compiler/Infer/Transforms/ModelAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/ModelAnalysisTransform.cs
@@ -111,8 +111,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 if (isc is IConditionCase)
                 {
                     IExpression cond = ((IConditionCase) isc).Condition;
-                    ILiteralExpression ile = cond as ILiteralExpression;
-                    if ((ile != null) && (ile.Value is int) && ((int) ile.Value < 0)) continue;
+                    if ((cond is ILiteralExpression ile) && (ile.Value is int) && ((int) ile.Value < 0)) continue;
                 }
                 ConvertSwitchCase(ss.Cases, isc);
             }
diff --git a/src/Compiler/Infer/Transforms/PointMassAnalysisTransform.cs b/src/Compiler/Infer/Transforms/PointMassAnalysisTransform.cs
index dc300c3..643feb3 100644
--- a/src/Compiler/Infer/Transforms/PointMassAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/PointMassAnalysisTransform.cs
@@ -55,8 +55,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         protected void ProcessDefinition(IExpression expr, IVariableDeclaration targetVar, bool isLhs)
         {
             bool targetIsPointMass = false;
-            IMethodInvokeExpression imie = expr as IMethodInvokeExpression;
-            if (imie != null)
+
+            if (expr is IMethodInvokeExpression imie)
             {
                 // TODO: consider using a method attribute for this
                 if (Recognizer.IsStaticGenericMethod(imie, new Models.FuncOut<PlaceHolder, PlaceHolder, PlaceHolder>(Factor.VariablePoint))
diff --git a/src/Compiler/Infer/Transforms/Scheduler.cs b/src/Compiler/Infer/Transforms/Scheduler.cs
index 738a61e..7927a45 100644
--- a/src/Compiler/Infer/Transforms/Scheduler.cs
+++ b/src/Compiler/Infer/Transforms/Scheduler.cs
@@ -362,9 +362,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                         }
                         // To workaround this error, change Any requirements to more specific requirements (on a single operator method argument)
                         // A complete fix would require allowing the scheduler to backtrack to find the right set of edges to force forward during IterationSchedule
-                        Trace.WriteLine(string.Format("Scheduler failed: {0} must not init but required by {1}",
-                            NodeToString(source),
-                            StringUtil.CollectionToString(targets.Select(t => NodeToString(t)), " ")));
+                        Trace.WriteLine($"Scheduler failed: {NodeToString(source)} must not init but required by {StringUtil.CollectionToString(targets.Select(t => NodeToString(t)), " ")}");
                     }
                 }
             }
@@ -715,7 +713,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                                 continue;  // don't force edges within a group
                             direction[edge] = Direction.Backward;
                             if (debug)
-                                Debug.WriteLine("{0} forced backward since {1}{2} is initialized", EdgeToString(edge), source, (node == source) ? "" : String.Format(" (originally {0})", node));
+                                Debug.WriteLine("{0} forced backward since {1}{2} is initialized", EdgeToString(edge), source, (node == source) ? "" : $" (originally {node})");
                             newBackEdges.Push(edge);
                             todo.Push(edge);
                         }
@@ -844,7 +842,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                                 continue;  // don't force edges within a group
                             direction[edge] = Direction.Backward;
                             if (debug)
-                                Debug.WriteLine("{0} forced backward since {1}{2} is initialized", EdgeToString(edge), source, (node == source) ? "" : String.Format(" (originally {0})", node));
+                                Debug.WriteLine("{0} forced backward since {1}{2} is initialized", EdgeToString(edge), source, (node == source) ? "" : $" (originally {node})");
                             newBackEdges.Push(edge);
                             todo.Push(edge);
                         }
@@ -1898,7 +1896,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     Debug.WriteLine("");
                 }
             }
-            if (debug && extraEdges != null && extraEdges.Count() > 0)
+            if (debug && extraEdges != null && extraEdges.Any())
             {
                 Debug.Write("extraEdges: ");
                 foreach (var edge in extraEdges)
diff --git a/src/Compiler/Infer/Transforms/SchedulingTransform.cs b/src/Compiler/Infer/Transforms/SchedulingTransform.cs
index 16815af..1490796 100644
--- a/src/Compiler/Infer/Transforms/SchedulingTransform.cs
+++ b/src/Compiler/Infer/Transforms/SchedulingTransform.cs
@@ -101,8 +101,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         protected override IStatement DoConvertStatement(IStatement ist)
         {
-            if (ist is IWhileStatement)
-                return ConvertWhile((IWhileStatement)ist);
+            if (ist is IWhileStatement iWhileStatement)
+                return ConvertWhile(iWhileStatement);
             else
                 return ist;
         }
@@ -184,9 +184,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             foreach (IStatement ist in stmts)
             {
                 action(ist);
-                if (ist is IWhileStatement)
+                if (ist is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)ist;
                     ForEachStatement(iws.Body.Statements, action);
                 }
             }
@@ -196,9 +195,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             foreach (IStatement ist in stmts)
             {
-                if (ist is IWhileStatement)
+                if (ist is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)ist;
                     ForEachLeafStatement(iws.Body.Statements, action);
                 }
                 else if (!context.InputAttributes.Has<FirstIterationPostProcessingBlock>(ist))
@@ -382,9 +380,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 // if a DependencyInformation refers to an inner statement of a block, make it refer to the block instead
                 foreach (IStatement stmt in inputStmts)
                 {
-                    if (stmt is IWhileStatement)
+                    if (stmt is IWhileStatement iws)
                     {
-                        IWhileStatement iws = (IWhileStatement)stmt;
                         ForEachStatement(iws.Body.Statements, ist => replacements[ist] = iws);
                     }
                 }
@@ -806,9 +803,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         {
             foreach (IStatement ist in stmts)
             {
-                if (ist is IWhileStatement)
+                if (ist is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)ist;
                     NodeIndex newGroup = nextGroupIndex;
                     nextGroupIndex++;
                     if (group >= 0)
@@ -909,12 +905,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 Predicate<EdgeIndex> isNegative = edge =>
                 {
                     IOffsetInfo info;
-                    return g.OffsetIndices.TryGetValue(edge, out info) && (info.Count(offset => offset.offset < 0) > 0);
+                    return g.OffsetIndices.TryGetValue(edge, out info) && (info.Any(offset => offset.offset < 0));
                 };
                 Predicate<EdgeIndex> isPositive = edge =>
                 {
                     IOffsetInfo info;
-                    return g.OffsetIndices.TryGetValue(edge, out info) && (info.Count(offset => offset.offset > 0) > 0);
+                    return g.OffsetIndices.TryGetValue(edge, out info) && (info.Any(offset => offset.offset > 0));
                 };
                 Predicate<EdgeIndex> isNoInit = edge => g.noInit[edge];
                 var edgeStyles = new EdgeStylePredicate[] {
@@ -1039,9 +1035,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     init.Clear();
                 }
                 // flatten nested while loops
-                if (st is IWhileStatement)
+                if (st is IWhileStatement iws)
                 {
-                    IWhileStatement iws = (IWhileStatement)st;
                     if (!allowNestedWhile)
                         throw new Exception("Internal: Serial initializer not allowed");
                     pendingOutput.AddRange(iws.Body.Statements);
diff --git a/src/Compiler/Infer/Transforms/StocAnalysisTransform.cs b/src/Compiler/Infer/Transforms/StocAnalysisTransform.cs
index 7ea3688..1560255 100644
--- a/src/Compiler/Infer/Transforms/StocAnalysisTransform.cs
+++ b/src/Compiler/Infer/Transforms/StocAnalysisTransform.cs
@@ -53,9 +53,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             for (int argIndex = 0; argIndex < imie.Arguments.Count; argIndex++)
             {
                 IExpression arg = imie.Arguments[argIndex];
-                if (arg is IAddressOutExpression)
+                if (arg is IAddressOutExpression iaoe)
                 {
-                    IAddressOutExpression iaoe = (IAddressOutExpression)arg;
                     IExpression target = iaoe.Expression;
                     bool targetHasLiteralIndices = inPartialLoop;
                     object targetDecl = Recognizer.GetDeclaration(target);
@@ -65,8 +64,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     {
                         SetMarginalPrototype(target, targetDecl, mpa, mpa2, targetHasLiteralIndices);
                     }
-                    IVariableDeclaration ivd = targetDecl as IVariableDeclaration;
-                    if (ivd != null)
+
+                    if (targetDecl is IVariableDeclaration ivd)
                     {
                         SetStoch(target, CodeRecognizer.IsStochastic(context, imie) || IsStochContext(ivd));
                     }
@@ -195,9 +194,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         protected void SetStoch(IExpression expr, bool stoch)
         {
             if (expr is IArgumentReferenceExpression) return;
-            if (expr is IArrayIndexerExpression)
+            if (expr is IArrayIndexerExpression iArrayIndexerExpression)
             {
-                SetStoch(((IArrayIndexerExpression)expr).Target, stoch);
+                SetStoch(iArrayIndexerExpression.Target, stoch);
                 return;
             }
             IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(expr);
@@ -703,7 +702,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 IExpression source = CodeRecognizer.RemoveCast(imie.Arguments[0]);
                 IExpression mpe = ReplaceIndices(source, targetDecl);
                 SparsityAttribute sparsity = context.InputAttributes.Get<SparsityAttribute>(targetDecl);
-                if (sparsity != null && sparsity.Sparsity != null)
+                if (sparsity?.Sparsity != null)
                 {
                     var exprType = mpe.GetExpressionType();
                     if (exprType == typeof(Dirichlet))
@@ -1612,14 +1611,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         /// <returns></returns>
         protected IExpression ReplaceIndices(Containers containers, Set<IVariableDeclaration> keepVars, IExpression expr)
         {
-            if (expr is ICastExpression)
+            if (expr is ICastExpression ice)
             {
-                ICastExpression ice = (ICastExpression)expr;
                 return Builder.CastExpr(ReplaceIndices(containers, keepVars, ice.Expression), ice.TargetType);
             }
-            else if (expr is IArrayIndexerExpression)
+            else if (expr is IArrayIndexerExpression iaie)
             {
-                IArrayIndexerExpression iaie = (IArrayIndexerExpression)expr;
                 IExpression[] newIndices = new IExpression[iaie.Indices.Count];
                 for (int i = 0; i < newIndices.Length; i++)
                 {
@@ -1627,9 +1624,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 }
                 return Builder.ArrayIndex(ReplaceIndices(containers, keepVars, iaie.Target), newIndices);
             }
-            else if (expr is IMethodInvokeExpression)
+            else if (expr is IMethodInvokeExpression imie)
             {
-                IMethodInvokeExpression imie = (IMethodInvokeExpression)expr;
                 IMethodInvokeExpression imie2 = Builder.MethodInvkExpr();
                 imie2.Method = imie.Method;
                 if (imie.Method.Method.Name.Equals("get_Item"))
@@ -1648,9 +1644,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 }
                 return imie2;
             }
-            else if (expr is IPropertyReferenceExpression)
+            else if (expr is IPropertyReferenceExpression ipre)
             {
-                IPropertyReferenceExpression ipre = (IPropertyReferenceExpression)expr;
                 return Builder.PropRefExpr(ReplaceIndices(containers, keepVars, ipre.Target), ipre.Property);
             }
             return expr;
@@ -1682,9 +1677,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                     return Builder.LiteralExpr(0);
                 }
             }
-            else if (expr is IArrayIndexerExpression)
+            else if (expr is IArrayIndexerExpression iaie)
             {
-                IArrayIndexerExpression iaie = (IArrayIndexerExpression)expr;
                 IExpression target = ReplaceVarsNotContained(containers, keepVars, iaie.Target);
                 if (target is ILiteralExpression && ((ILiteralExpression)target).Value.Equals(0))
                     return Builder.LiteralExpr(0);
diff --git a/src/Compiler/Infer/Transforms/UniquenessTransform.cs b/src/Compiler/Infer/Transforms/UniquenessTransform.cs
index b837bac..0add087 100644
--- a/src/Compiler/Infer/Transforms/UniquenessTransform.cs
+++ b/src/Compiler/Infer/Transforms/UniquenessTransform.cs
@@ -119,9 +119,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         protected override IStatement DoConvertStatement(IStatement ist)
         {
-            if (ist is IWhileStatement)
+            if (ist is IWhileStatement iws)
             {
-                IWhileStatement iws = (IWhileStatement)ist;
                 if (whileCount == 0)
                 {
                     replacements.Clear();
@@ -132,10 +131,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
                 if (replacements.Count > 0)
                 {
                     InitializerSet initializerSet = context.InputAttributes.Get<InitializerSet>(iws);
-                    if (initializerSet != null)
-                    {
-                        initializerSet.Replace(replacements);
-                    }
+                    initializerSet?.Replace(replacements);
                 }
                 return convertedSt;
             }
diff --git a/src/Compiler/Infer/Transforms/VariableTransform.cs b/src/Compiler/Infer/Transforms/VariableTransform.cs
index 91a4200..8bcac44 100644
--- a/src/Compiler/Infer/Transforms/VariableTransform.cs
+++ b/src/Compiler/Infer/Transforms/VariableTransform.cs
@@ -97,9 +97,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(target);
             if (ivd == null)
                 return;
-            if (rhs is IArrayCreateExpression)
+            if (rhs is IArrayCreateExpression iace)
             {
-                IArrayCreateExpression iace = (IArrayCreateExpression)rhs;
                 bool zeroLength = iace.Dimensions.All(dimExpr =>
                     (dimExpr is ILiteralExpression) && ((ILiteralExpression)dimExpr).Value.Equals(0));
                 if (!zeroLength && iace.Initializer == null)
@@ -183,9 +182,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
             IExpression useExpr = isStochastic ? Builder.ReplaceVariable(lhs, ivd, useOfVariable[ivd]) : marginalExpr;
             InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(ivd);
             Type[] genArgs = new Type[] { defExpr.GetExpressionType() };
-            if (rhs is IMethodInvokeExpression)
+            if (rhs is IMethodInvokeExpression imie)
             {
-                IMethodInvokeExpression imie = (IMethodInvokeExpression)rhs;
                 if (Recognizer.IsStaticGenericMethod(imie, new Func<PlaceHolder, PlaceHolder>(Factor.Copy)) && ancIndex < context.InputStack.Count - 2)
                 {
                     IExpression arg = imie.Arguments[0];
diff --git a/src/Compiler/Infer/Visualizers/Default/GraphViews/ModelView.cs b/src/Compiler/Infer/Visualizers/Default/GraphViews/ModelView.cs
index 826fae1..fa81be8 100644
--- a/src/Compiler/Infer/Visualizers/Default/GraphViews/ModelView.cs
+++ b/src/Compiler/Infer/Visualizers/Default/GraphViews/ModelView.cs
@@ -99,8 +99,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                 ConditionContext context = new ConditionContext();
                 foreach (var block in containers)
                 {
-                    if (block is ConditionBlock)
-                        context.blocks.Add((ConditionBlock)block);
+                    if (block is ConditionBlock conditionBlock)
+                        context.blocks.Add(conditionBlock);
                 }
                 if (context.blocks.Count == 0)
                     return null;
@@ -157,8 +157,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                 return;
             foreach (IModelExpression me in mb.ModelExpressions)
             {
-                if (me is MethodInvoke)
-                    AddFactorEdges(g, (MethodInvoke)me);
+                if (me is MethodInvoke methodInvoke)
+                    AddFactorEdges(g, methodInvoke);
             }
             // connect nodes that represent the same variable with undirected edges
             Dictionary<Variable, List<Node>> nodesOfVariable = new Dictionary<Variable, List<Node>>();
@@ -221,9 +221,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
             nodeOfExpr[expr] = nd;
             nd.Label = expr.ToString();
             nd.FontSize = 9;
-            if (expr is Variable)
+            if (expr is Variable ve)
             {
-                Variable ve = (Variable)expr;
                 if (ve.IsObserved)
                 {
                     nd.Shape = ShapeStyle.None;
@@ -257,9 +256,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                     }
                 }
             }
-            else if (expr is MethodInvoke)
+            else if (expr is MethodInvoke mi)
             {
-                MethodInvoke mi = (MethodInvoke)expr;
                 nd.FillColor = Color.Black;
                 nd.FontColor = Color.White;
                 nd.Shape = ShapeStyle.Box;
@@ -323,19 +321,17 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                 // add edges from condition variables to target (if there are no such edges already)
                 IModelExpression target = (mi.returnValue != null) ? mi.returnValue : mi;
                 Set<IStatementBlock> excluded = new Set<IStatementBlock>();
-                if (target is Variable)
+                if (target is Variable targetVar)
                 {
                     // if target is in the ConditionBlock, then don't connect with the condition variable
-                    Variable targetVar = (Variable)target;
                     excluded.AddRange(targetVar.Containers);
                 }
                 foreach (IStatementBlock block in mi.Containers)
                 {
                     if (excluded.Contains(block))
                         continue;
-                    if (block is ConditionBlock)
+                    if (block is ConditionBlock cb)
                     {
-                        ConditionBlock cb = (ConditionBlock)block;
                         Variable c = cb.ConditionVariableUntyped;
                         List<Variable> condVars;
                         if (!conditionVariables.TryGetValue(target, out condVars))
diff --git a/src/Compiler/Infer/Visualizers/Default/GraphViews/TaskGraphView.cs b/src/Compiler/Infer/Visualizers/Default/GraphViews/TaskGraphView.cs
index 0064707..eb36bdb 100644
--- a/src/Compiler/Infer/Visualizers/Default/GraphViews/TaskGraphView.cs
+++ b/src/Compiler/Infer/Visualizers/Default/GraphViews/TaskGraphView.cs
@@ -43,9 +43,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                 if (!context.InputAttributes.Has<OperatorMethod>(imd)) continue;
                 foreach (IStatement ist in imd.Body.Statements)
                 {
-                    if (ist is IWhileStatement)
+                    if (ist is IWhileStatement iWhileStatement)
                     {
-                        looptasks.AddRange(((IWhileStatement) ist).Body.Statements);
+                        looptasks.AddRange(iWhileStatement.Body.Statements);
                         continue;
                     }
                     if (context.InputAttributes.Has<OperatorStatement>(ist)) pretasks.Add(ist);
@@ -144,11 +144,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
             //if (di.IsOutput) nd.Fillcolor = Color.LightBlue;
             nd.Label = s;
             if (stage == Stage.Initialisation) nd.FillColor = Color.LightGray;
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
-                IExpressionStatement ies = (IExpressionStatement) ist;
-                IAssignExpression iae = ies.Expression as IAssignExpression;
-                if ((iae != null) && (iae.Target is IVariableDeclarationExpression)) nd.BorderWidth = 2;
+                if ((ies.Expression is IAssignExpression iae) && (iae.Target is IVariableDeclarationExpression)) nd.BorderWidth = 2;
             }
             nd.Shape = ShapeStyle.Box;
             nd.FontSize = 9;
@@ -179,9 +177,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
 
         protected string StatementLabel(IStatement ist)
         {
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
-                IExpressionStatement ies = (IExpressionStatement) ist;
                 string s;
                 if (ies.Expression is IAssignExpression)
                 {
@@ -192,18 +189,17 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers.GraphViews
                 //if (s.EndsWith("[0]")) s = s.Substring(0, s.Length - 3);
                 return s;
             }
-            if (ist is IForStatement)
+            if (ist is IForStatement iForStatement)
             {
-                return StatementLabel(((IForStatement) ist).Body.Statements[0]);
+                return StatementLabel(iForStatement.Body.Statements[0]);
             }
-            if (ist is IConditionStatement)
+            if (ist is IConditionStatement iConditionStatement)
             {
-                return String.Format("if ({0}) {1}", ((IConditionStatement) ist).Condition.ToString(),
-                                     StatementLabel(((IConditionStatement) ist).Then));
+                return $"if ({iConditionStatement.Condition.ToString()}) {StatementLabel(((IConditionStatement)ist).Then)}";
             }
-            if (ist is IBlockStatement)
+            if (ist is IBlockStatement iBlockStatement)
             {
-                int blockSize = ((IBlockStatement) ist).Statements.Count;
+                int blockSize = iBlockStatement.Statements.Count;
                 string s;
                 if (blockSize > 0)
                 {
diff --git a/src/Compiler/TransformFramework/AttributeRegistry.cs b/src/Compiler/TransformFramework/AttributeRegistry.cs
index a1da57c..0298184 100644
--- a/src/Compiler/TransformFramework/AttributeRegistry.cs
+++ b/src/Compiler/TransformFramework/AttributeRegistry.cs
@@ -179,8 +179,8 @@ namespace Microsoft.ML.Probabilistic.Compiler
                 return result;
             foreach (TAttribute attr in registry[mi])
             {
-                if (attr is T)
-                    result.Add((T)attr);
+                if (attr is T t)
+                    result.Add(t);
             }
             return result;
         }
@@ -199,7 +199,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
             T result = null;
             foreach (TAttribute attr in registry[obj])
             {
-                if (attr is T)
+                if (attr is T t)
                 {
                     if (found)
                     {
@@ -207,7 +207,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
                     }
                     else
                     {
-                        result = (T)attr;
+                        result = t;
                         found = true;
                     }
                 }
diff --git a/src/Compiler/TransformFramework/CodeBuilder.cs b/src/Compiler/TransformFramework/CodeBuilder.cs
index 1e71bb7..cd8a30d 100644
--- a/src/Compiler/TransformFramework/CodeBuilder.cs
+++ b/src/Compiler/TransformFramework/CodeBuilder.cs
@@ -537,7 +537,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
             if (isByRef) name = name.Substring(0, name.Length - 1);
             //tr.Name = name;
             //tr.Namespace = t.Namespace;
-            if (t != null && t.Assembly != null)
+            if (t?.Assembly != null)
             {
                 // TM: Owner = System.Reflection.Assembly seems to work just as well as IModuleReference.
                 tr.Owner = t.Assembly;
diff --git a/src/Compiler/TransformFramework/CodeModel/Generics.cs b/src/Compiler/TransformFramework/CodeModel/Generics.cs
index fbb3a8a..a470919 100644
--- a/src/Compiler/TransformFramework/CodeModel/Generics.cs
+++ b/src/Compiler/TransformFramework/CodeModel/Generics.cs
@@ -23,8 +23,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
         /// <returns></returns>
         public static IType GetType(IType type, IGenericArgumentProvider declaringType, IGenericArgumentProvider method)
         {
-            ITypeReference itr = type as ITypeReference;
-            if (itr != null)
+            if (type is ITypeReference itr)
             {
                 if (itr.GenericType == null)
                     // The parameter is directly a non-generic type reference
@@ -48,8 +47,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             }
 
             // Check to see if the parameter is an array
-            IArrayType iat = type as IArrayType;
-            if (iat != null)
+            if (type is IArrayType iat)
             {
                 // The parameter is an array type. Build an array type and recurse to get its element type
                 IArrayType iat2 = new XArrayType();
@@ -59,8 +57,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             }
 
             // Check to see if the parameter is a pointer
-            IPointerType ipt = type as IPointerType;
-            if (ipt != null)
+            if (type is IPointerType ipt)
             {
                 // The parameter is a pointer type. Build a pointer type and recurse to set its element type
                 IPointerType ipt2 = new XPointerType();
@@ -69,8 +66,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             }
 
             // Check to see if the parameter is a reference
-            IReferenceType irt = type as IReferenceType;
-            if (irt != null)
+            if (type is IReferenceType irt)
             {
                 // The parameter is a reference type. Build a reference type and recurse
                 // to set its element type
@@ -80,8 +76,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             }
 
             // Check to see if the parameter has an optional modifier
-            IOptionalModifier iom = type as IOptionalModifier;
-            if (iom != null)
+            if (type is IOptionalModifier iom)
             {
                 // The parameter has an optional modifier. Build an optional modifier type and recurse
                 // to set its element type
@@ -92,8 +87,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             }
 
             // Check to see if the parameter has an required modifier
-            IRequiredModifier irm = type as IRequiredModifier;
-            if (irm != null)
+            if (type is IRequiredModifier irm)
             {
                 // The parameter has a required modifier. Build a required modifier type and recurse
                 // to set its element type
@@ -102,11 +96,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
                 irm2.ElementType = GetType(irm.ElementType, declaringType, method);
                 return irm2;
             }
-
             // Deal with generic parameters
-            IGenericParameter igp = type as IGenericParameter;
             IMethodReference imr;
-            if (igp != null)
+
+            if (type is IGenericParameter igp)
             {
                 itr = igp.Owner as ITypeReference;
                 imr = igp.Owner as IMethodReference;
@@ -138,7 +131,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
                 throw new NotSupportedException("Unable to get the parameters type");
 
             IType it = iga.Resolve();
-            if (it == null || !(it is IGenericArgument) || (it is IGenericParameter))
+            if (!(it is IGenericArgument) || (it is IGenericParameter))
             {
                 itr = iga.Owner as ITypeReference;
                 imr = iga.Owner as IMethodReference;
diff --git a/src/Compiler/TransformFramework/CodeModel/MethodInstanceReference.cs b/src/Compiler/TransformFramework/CodeModel/MethodInstanceReference.cs
index 0c9df13..5f875f0 100644
--- a/src/Compiler/TransformFramework/CodeModel/MethodInstanceReference.cs
+++ b/src/Compiler/TransformFramework/CodeModel/MethodInstanceReference.cs
@@ -63,8 +63,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
             IMethodDeclaration instDecl = new XMethodInstanceDeclaration();
             instDecl.GenericMethod = genericDecl;
             instDecl.GenericArguments.AddRange(this.GenericArguments);
-            ITypeReference declaringType = this.DeclaringType as ITypeReference;
-            if (declaringType != null)
+
+            if (this.DeclaringType is ITypeReference declaringType)
                 instDecl.DeclaringType = declaringType.Resolve();
             // Are there other properties of instDecl that we should set?
 
diff --git a/src/Compiler/TransformFramework/CodeModel/TypeInstanceReference.cs b/src/Compiler/TransformFramework/CodeModel/TypeInstanceReference.cs
index 570b81b..6f0e07d 100644
--- a/src/Compiler/TransformFramework/CodeModel/TypeInstanceReference.cs
+++ b/src/Compiler/TransformFramework/CodeModel/TypeInstanceReference.cs
@@ -196,12 +196,11 @@ namespace Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete
 
             ITypeReference reference = obj as ITypeReference;
             IMethodReference owner = obj as IMethodReference;
-            IGenericArgument argument = obj as IGenericArgument;
             if (reference == null)
             {
                 // If this is not a type reference, it might be an argument
                 // of a generic function. 
-                if (argument != null && (owner == null || owner.GenericMethod != null))
+                if (obj is IGenericArgument argument && (owner?.GenericMethod != null))
                 {
                     ITypeReference resolvedRef = argument.Resolve() as ITypeReference;
                     if (resolvedRef == null)
diff --git a/src/Compiler/TransformFramework/CodeRecognizer.cs b/src/Compiler/TransformFramework/CodeRecognizer.cs
index ef67ab4..bb6e396 100644
--- a/src/Compiler/TransformFramework/CodeRecognizer.cs
+++ b/src/Compiler/TransformFramework/CodeRecognizer.cs
@@ -238,8 +238,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
             }
             else if (expr is IBinaryExpression indexBinaryExpr)
             {
-                ILiteralExpression offsetExpr = indexBinaryExpr.Right as ILiteralExpression;
-                if (indexBinaryExpr.Left is IVariableReferenceExpression ivre && offsetExpr != null && offsetExpr.Value is int)
+                if (indexBinaryExpr.Left is IVariableReferenceExpression ivre && indexBinaryExpr.Right is ILiteralExpression offsetExpr && offsetExpr.Value is int)
                 {
                     offset = (int)offsetExpr.Value;
                     if (indexBinaryExpr.Operator == BinaryOperator.Subtract)
@@ -1281,7 +1280,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
 
             public override string ToString()
             {
-                return String.Format("[{0},{1}]", lowerBound, upperBound);
+                return $"[{lowerBound},{upperBound}]";
             }
         }
 
diff --git a/src/Compiler/TransformFramework/ExpressionEvaluator.cs b/src/Compiler/TransformFramework/ExpressionEvaluator.cs
index 4a5bbf3..222eefb 100644
--- a/src/Compiler/TransformFramework/ExpressionEvaluator.cs
+++ b/src/Compiler/TransformFramework/ExpressionEvaluator.cs
@@ -38,34 +38,30 @@ namespace Microsoft.ML.Probabilistic.Compiler
 
         public object Evaluate(IExpression expr)
         {
-            if (expr is IObjectCreateExpression) return Evaluate((IObjectCreateExpression) expr);
-            else if (expr is ILiteralExpression) return ((ILiteralExpression) expr).Value;
-            else if (expr is ICastExpression) return Evaluate(((ICastExpression) expr).Expression);
-            else if (expr is ICheckedExpression) return Evaluate(((ICheckedExpression)expr).Expression);
-            else if (expr is IBinaryExpression)
+            if (expr is IObjectCreateExpression iObjectCreateExpression) return Evaluate(iObjectCreateExpression);
+            else if (expr is ILiteralExpression iLiteralExpression) return iLiteralExpression.Value;
+            else if (expr is ICastExpression iCastExpression) return Evaluate(iCastExpression.Expression);
+            else if (expr is ICheckedExpression iCheckedExpression) return Evaluate(iCheckedExpression.Expression);
+            else if (expr is IBinaryExpression ibe)
             {
-                IBinaryExpression ibe = (IBinaryExpression) expr;
                 object left = Evaluate(ibe.Left);
                 object right = Evaluate(ibe.Right);
                 Type type = left.GetType();
                 return Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, binaryOperatorNames[(int) ibe.Operator], left, right);
             }
-            else if (expr is IUnaryExpression)
+            else if (expr is IUnaryExpression iue)
             {
-                IUnaryExpression iue = (IUnaryExpression) expr;
                 object target = Evaluate(iue.Expression);
                 Type type = target.GetType();
                 return Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, unaryOperatorNames[(int) iue.Operator], target);
             }
-            else if (expr is IMethodInvokeExpression)
+            else if (expr is IMethodInvokeExpression imie)
             {
-                IMethodInvokeExpression imie = (IMethodInvokeExpression) expr;
                 object[] args = EvaluateAll(imie.Arguments);
                 return Invoke(imie.Method, args);
             }
-            else if (expr is IArrayCreateExpression)
+            else if (expr is IArrayCreateExpression iace)
             {
-                IArrayCreateExpression iace = (IArrayCreateExpression) expr;
                 Type t = Builder.ToType(iace.Type);
                 int[] lens = new int[iace.Dimensions.Count];
                 for (int i = 0; i < lens.Length; i++) lens[i] = (int) Evaluate(iace.Dimensions[i]);
@@ -74,9 +70,8 @@ namespace Microsoft.ML.Probabilistic.Compiler
                     throw new NotImplementedException("IArrayCreateExpression has an initializer block");
                 return Array.CreateInstance(t, lens);
             }
-            else if (expr is IFieldReferenceExpression)
+            else if (expr is IFieldReferenceExpression ifre)
             {
-                IFieldReferenceExpression ifre = (IFieldReferenceExpression) expr;
                 if (ifre.Target is ITypeReferenceExpression)
                 {
                     ITypeReferenceExpression itre = (ITypeReferenceExpression) ifre.Target;
@@ -124,8 +119,8 @@ namespace Microsoft.ML.Probabilistic.Compiler
         public static IExpression Quote(object p)
         {
             if (p is string || p.GetType().IsPrimitive || p is Enum) return Builder.LiteralExpr(p);
-            else if (p is Type) return Builder.TypeRefExpr((Type) p);
-            else if (p is Array) return QuoteArray((Array) p);
+            else if (p is Type type) return Builder.TypeRefExpr(type);
+            else if (p is Array array) return QuoteArray(array);
             else return null;
         }
 
diff --git a/src/Compiler/TransformFramework/LanguageWriters/CSharpWriter.cs b/src/Compiler/TransformFramework/LanguageWriters/CSharpWriter.cs
index b5ffe36..4b4d470 100644
--- a/src/Compiler/TransformFramework/LanguageWriters/CSharpWriter.cs
+++ b/src/Compiler/TransformFramework/LanguageWriters/CSharpWriter.cs
@@ -237,7 +237,7 @@ namespace Microsoft.ML.Probabilistic.Compiler
             {
                 AppendArrayRank(sb, iat.Rank);
                 IType elementType = iat.ElementType;
-                if (elementType is IArrayType) iat = (IArrayType) elementType;
+                if (elementType is IArrayType iArrayType) iat = iArrayType;
                 else break;
             }
         }
diff --git a/src/Csoft/DeclarationTreeBuilder.cs b/src/Csoft/DeclarationTreeBuilder.cs
index 82cb5ff..f6601e5 100644
--- a/src/Csoft/DeclarationTreeBuilder.cs
+++ b/src/Csoft/DeclarationTreeBuilder.cs
@@ -47,14 +47,14 @@ namespace Microsoft.ML.Probabilistic.Compiler
 
         private void ConvertMember(ITypeDeclaration declaringType, MemberDeclarationSyntax member)
         {
-            if (member is NamespaceDeclarationSyntax)
+            if (member is NamespaceDeclarationSyntax namespaceDeclarationSyntax)
             {
-                ConvertNamespaceDeclaration(declaringType, (NamespaceDeclarationSyntax)member);
+                ConvertNamespaceDeclaration(declaringType, namespaceDeclarationSyntax);
                 return;
             }
-            if (member is ClassDeclarationSyntax)
+            if (member is ClassDeclarationSyntax classDeclarationSyntax)
             {
-                ConvertClassDeclaration((ClassDeclarationSyntax)member);
+                ConvertClassDeclaration(classDeclarationSyntax);
                 return;
             }
             if (member is DelegateDeclarationSyntax)
diff --git a/src/Csoft/EmbeddedResourceSourceProvider.cs b/src/Csoft/EmbeddedResourceSourceProvider.cs
index 9b045b7..156b7f4 100644
--- a/src/Csoft/EmbeddedResourceSourceProvider.cs
+++ b/src/Csoft/EmbeddedResourceSourceProvider.cs
@@ -22,12 +22,11 @@ namespace Microsoft.ML.Probabilistic.Compiler
                 var root = tree.GetRoot();
                 var typeDecl = root.DescendantNodes()
                                  .OfType<NamespaceDeclarationSyntax>()
-                                 .Where(md => md.Name.ToString().Equals(t.Namespace))
-                                 .FirstOrDefault()
+                                 .FirstOrDefault(md => md.Name.ToString().Equals(t.Namespace))
                                  ?.DescendantNodes()
                                  .OfType<TypeDeclarationSyntax>()
-                                 .Where(md => md.Identifier.ValueText.Equals(t.Name))
-                                 .FirstOrDefault();
+                                 .FirstOrDefault(md => md.Identifier.ValueText.Equals(t.Name))
+;
                 return typeDecl != null;
             }
             var asm = t.Assembly;
diff --git a/src/Csoft/MethodBodySynthesizer.cs b/src/Csoft/MethodBodySynthesizer.cs
index ce501cd..a5b91f2 100644
--- a/src/Csoft/MethodBodySynthesizer.cs
+++ b/src/Csoft/MethodBodySynthesizer.cs
@@ -716,8 +716,8 @@ namespace Microsoft.ML.Probabilistic.Compiler
 
             List<IExpression> paramsParameters = null;
             IArrayTypeSymbol paramsType = null;
-            var methodSymbol = model.GetSymbolInfo(invocationExpression).Symbol as IMethodSymbol;
-            if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
+
+            if (model.GetSymbolInfo(invocationExpression).Symbol is IMethodSymbol methodSymbol && methodSymbol.Parameters.Length > 0)
             {
                 var lastParam = methodSymbol.Parameters.Last();
                 paramsType = lastParam.Type as IArrayTypeSymbol;
diff --git a/src/Csoft/QueryTransform.cs b/src/Csoft/QueryTransform.cs
index 9fb542a..a77d0f3 100644
--- a/src/Csoft/QueryTransform.cs
+++ b/src/Csoft/QueryTransform.cs
@@ -192,13 +192,13 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
         private static IType GetMemberReferenceType(IMemberReference var)
         {
             IType varType;
-            if (var is IPropertyReference)
+            if (var is IPropertyReference iPropertyReference)
             {
-                varType = ((IPropertyReference)var).PropertyType;
+                varType = iPropertyReference.PropertyType;
             }
-            else if (var is IFieldReference)
+            else if (var is IFieldReference iFieldReference)
             {
-                varType = ((IFieldReference)var).FieldType;
+                varType = iFieldReference.FieldType;
             }
             else
             {
@@ -209,8 +209,7 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         public static MethodInfo GetMethodInfo<T>(Expression<Action<T>> expression)
         {
-            var member = expression.Body as MethodCallExpression;
-            if (member != null)
+            if (expression.Body is MethodCallExpression member)
             {
                 return member.Method;
             }
@@ -219,25 +218,21 @@ namespace Microsoft.ML.Probabilistic.Compiler.Transforms
 
         private static IMemberReference ExtractMemberRef(IExpression expr)
         {
-            var propRefExpr = expr as IPropertyReferenceExpression;
-            if (propRefExpr != null)
+            if (expr is IPropertyReferenceExpression propRefExpr)
             {
                 return propRefExpr.Property;
             }
-            var fieldRefExpr = expr as IFieldReferenceExpression;
-            return fieldRefExpr != null ? fieldRefExpr.Field : null;
+            return expr is IFieldReferenceExpression fieldRefExpr ? fieldRefExpr.Field : null;
         }
 
         private static IExpression BuildMemberRefExpr(IMemberReference mr)
         {
-            var propRef = mr as IPropertyReference;
-            if (propRef != null)
+            if (mr is IPropertyReference propRef)
             {
                 return Builder.PropRefExpr(Builder.ThisRefExpr(), propRef);
             }
 
-            var fieldRef = mr as IFieldReference;
-            if (fieldRef != null)
+            if (mr is IFieldReference fieldRef)
             {
                 return Builder.FieldRefExpr(fieldRef);
             }
diff --git a/src/Examples/ClickThroughModel/UserData.cs b/src/Examples/ClickThroughModel/UserData.cs
index 18f2433..a095b83 100644
--- a/src/Examples/ClickThroughModel/UserData.cs
+++ b/src/Examples/ClickThroughModel/UserData.cs
@@ -25,7 +25,7 @@ namespace ClickThroughModel
 
         public override string ToString()
         {
-            return string.Format("nTT ={0}, nTF = {1}, nFT = {2}, nFF ={3}", nClicks[(int)clickType.TT], nClicks[(int)clickType.TF], nClicks[(int)clickType.FT], nClicks[(int)clickType.FF]);
+            return $"nTT ={nClicks[(int)clickType.TT]}, nTF = {nClicks[(int)clickType.TF]}, nFT = {nClicks[(int)clickType.FT]}, nFF ={nClicks[(int)clickType.FF]}";
         }
     }
 }
diff --git a/src/Examples/Crowdsourcing/ActiveLearning.cs b/src/Examples/Crowdsourcing/ActiveLearning.cs
index 0264892..25bf294 100644
--- a/src/Examples/Crowdsourcing/ActiveLearning.cs
+++ b/src/Examples/Crowdsourcing/ActiveLearning.cs
@@ -133,7 +133,7 @@ namespace Crowdsourcing
             //Count elapsed time
             Stopwatch stopWatchTotal = new Stopwatch();
             stopWatchTotal.Start();
-            int totalLabels = data.Count();
+            int totalLabels = data.Count;
 
             // Dictionary keyed by task Id, with randomly order labelings
             var groupedRandomisedData =
@@ -156,7 +156,7 @@ namespace Crowdsourcing
 
             // Keyed by task, value is a HashSet containing all the remaining workers with a label - workers are removed after adding a new datum 
             Dictionary<string, HashSet<string>> remainingWorkersPerTask = groupedRandomisedData.ToDictionary(kvp => kvp.Key, kvp => new HashSet<string>(kvp.Value.Select(dat => dat.WorkerId)));
-            int numTaskIds = totalCounts.Count();
+            int numTaskIds = totalCounts.Count;
             int totalInstances = data.Count - initialNumLabelsPerTask * numTaskIds;
             string[] WorkerIds = data.Select(d => d.WorkerId).Distinct().ToArray();
 
@@ -283,7 +283,7 @@ namespace Crowdsourcing
         public static void DoSnapshot(List<double> accuracy, List<double> nlpd, List<double> avgRecall, List<ActiveLearningResult> taskValue, Results results, string modelName, string suffix, string resultsDir)
         {
             // Snapshot of accuracies, parameters and taskValues.
-            using (StreamWriter writer = new StreamWriter(String.Format("{2}{0}_graph_{1}.csv", modelName, suffix, resultsDir)))
+            using (StreamWriter writer = new StreamWriter($"{modelName}{suffix}_graph_{resultsDir}.csv"))
             {
                 var accArr = accuracy.ToArray();
                 var nlpdArr = nlpd.ToArray();
@@ -296,16 +296,16 @@ namespace Crowdsourcing
                 }
             }
 
-            using (StreamWriter writer = new StreamWriter(String.Format("{2}{0}_parameters_{1}.csv", modelName, suffix, resultsDir)))
+            using (StreamWriter writer = new StreamWriter($"{modelName}{suffix}_parameters_{resultsDir}.csv"))
             {
                 results.WriteResults(writer, true, true, true);
             }
 
-            using (StreamWriter writer = new StreamWriter(String.Format("{2}{0}_taskValue_{1}.csv", modelName, suffix, resultsDir)))
+            using (StreamWriter writer = new StreamWriter($"{modelName}{suffix}_taskValue_{resultsDir}.csv"))
             {
                 for (int i = 0; i < taskValue.Count; i++)
                 {
-                    writer.WriteLine(String.Format("{0}\t{1}\t{2:0.000}", taskValue[i].TaskId, taskValue[i].WorkerId, taskValue[i].TaskValue));
+                    writer.WriteLine($"{taskValue[i].TaskId}\t{taskValue[i].WorkerId}\t{taskValue[i].TaskValue:0.000}");
                 }
             }
         }
diff --git a/src/Examples/Crowdsourcing/Crowdsourcing.cs b/src/Examples/Crowdsourcing/Crowdsourcing.cs
index e693def..3c1c80d 100644
--- a/src/Examples/Crowdsourcing/Crowdsourcing.cs
+++ b/src/Examples/Crowdsourcing/Crowdsourcing.cs
@@ -177,7 +177,7 @@ namespace Crowdsourcing
             // Reset the random seed so results can be duplicated for the paper
             Rand.Restart(12347);
             var data = Datum.LoadData(@".\Data\" + dataSet + ".csv");
-            int totalLabels = data.Count();
+            int totalLabels = data.Count;
 
             string modelName = GetModelName(dataSet, runType, TaskSelectionMethod.EntropyTask, WorkerSelectionMethod.RandomWorker);
             Results results = new Results();
diff --git a/src/Examples/Crowdsourcing/DataMapping.cs b/src/Examples/Crowdsourcing/DataMapping.cs
index 9199e05..3c23c7c 100644
--- a/src/Examples/Crowdsourcing/DataMapping.cs
+++ b/src/Examples/Crowdsourcing/DataMapping.cs
@@ -178,7 +178,7 @@ namespace Crowdsourcing
             // Labels are returned as indexed by task index
             return Data.GroupBy(d => d.TaskId).
               Select(t => t.GroupBy(d => d.GoldLabel).Where(d => d.Key != null)).
-              Where(gold_d => gold_d.Count() > 0).
+              Where(gold_d => gold_d.Any()).
               Select(gold_d =>
               {
                   int count = gold_d.Distinct().Count();
diff --git a/src/Examples/Crowdsourcing/Results.cs b/src/Examples/Crowdsourcing/Results.cs
index 736ec0b..d3c0043 100644
--- a/src/Examples/Crowdsourcing/Results.cs
+++ b/src/Examples/Crowdsourcing/Results.cs
@@ -667,7 +667,7 @@ namespace Crowdsourcing
         private void UpdateAccuracy()
         {
             double nlpdThreshold = -Math.Log(0.001);
-            int labelCount = TrueLabel.Where(kvp => kvp.Value != null).First().Value.Dimension;
+            int labelCount = TrueLabel.First(kvp => kvp.Value != null).Value.Dimension;
             var confusionMatrix = Util.ArrayInit(labelCount, labelCount, (i, j) => 0.0);
             int correct = 0;
             double logProb = 0.0;
@@ -796,7 +796,7 @@ namespace Crowdsourcing
             {
                 foreach (var kvp in this.WorkerCommunity)
                 {
-                    writer.WriteLine(string.Format("{0}:\t{1}", kvp.Key, kvp.Value));
+                    writer.WriteLine($"{kvp.Key}:\t{kvp.Value}");
                 }
             }
 
diff --git a/src/Examples/CrowdsourcingWithWords/CrowdsourcingWithWords.cs b/src/Examples/CrowdsourcingWithWords/CrowdsourcingWithWords.cs
index b0d41f3..752b7b9 100644
--- a/src/Examples/CrowdsourcingWithWords/CrowdsourcingWithWords.cs
+++ b/src/Examples/CrowdsourcingWithWords/CrowdsourcingWithWords.cs
@@ -31,9 +31,8 @@ namespace CrowdsourcingWithWords
 
             BCCWords model = new BCCWords();
             ResultsWords resultsWords = new ResultsWords(data, VocabularyOnSubData);
-            DataMappingWords mapping = resultsWords.Mapping as DataMappingWords;
 
-            if (mapping != null)
+            if (resultsWords.Mapping is DataMappingWords mapping)
             {
                 resultsWords = new ResultsWords(data, VocabularyOnSubData);
                 resultsWords.RunBCCWords("BCCwords", data, data, model, Results.RunMode.ClearResults, true);
diff --git a/src/Examples/CrowdsourcingWithWords/DataMapping.cs b/src/Examples/CrowdsourcingWithWords/DataMapping.cs
index 7363f87..4aaeb61 100644
--- a/src/Examples/CrowdsourcingWithWords/DataMapping.cs
+++ b/src/Examples/CrowdsourcingWithWords/DataMapping.cs
@@ -168,7 +168,7 @@ namespace CrowdsourcingWithWords
             // Labels are returned as indexed by task index
             return Data.GroupBy(d => d.TaskId).
               Select(t => t.GroupBy(d => d.GoldLabel).Where(d => d.Key.HasValue)).
-              Where(gold_d => gold_d.Count() > 0).
+              Where(gold_d => gold_d.Any()).
               Select(gold_d =>
               {
                   int count = gold_d.Distinct().Count();
@@ -213,7 +213,7 @@ namespace CrowdsourcingWithWords
                 datum.GoldLabel = entry.Value;
                 datum.WorkerLabel = (int)entry.Value;
                 datum.WorkerId = firstWorkerId;
-                datum.BodyText = OriginalData.Where(d => d.TaskId == entry.Key).First().BodyText;
+                datum.BodyText = OriginalData.First(d => d.TaskId == entry.Key).BodyText;
 
                 data.Add(datum);
             }
diff --git a/src/Examples/CrowdsourcingWithWords/DataMappingWords.cs b/src/Examples/CrowdsourcingWithWords/DataMappingWords.cs
index a144fa8..87c9309 100644
--- a/src/Examples/CrowdsourcingWithWords/DataMappingWords.cs
+++ b/src/Examples/CrowdsourcingWithWords/DataMappingWords.cs
@@ -22,7 +22,7 @@ namespace CrowdsourcingWithWords
 		{
 			get
 			{
-				return Vocabulary.Count();
+				return Vocabulary.Count;
 			}
 		}
 
diff --git a/src/Examples/CrowdsourcingWithWords/TFIDFClass.cs b/src/Examples/CrowdsourcingWithWords/TFIDFClass.cs
index 89ea3ea..36aa5c7 100644
--- a/src/Examples/CrowdsourcingWithWords/TFIDFClass.cs
+++ b/src/Examples/CrowdsourcingWithWords/TFIDFClass.cs
@@ -89,7 +89,7 @@ namespace CrowdsourcingWithWords
                 foreach (var vocab in vocabularyIDF)
                 {
                     // Term frequency = count how many times the term appears in this document.
-                    double tf = doc.Where(d => d == vocab.Key).Count();
+                    double tf = doc.Count(d => d == vocab.Key);
                     double tfidf = tf * vocab.Value;
 
                     vector.Add(tfidf);
diff --git a/src/Examples/LDA/LDAShared.cs b/src/Examples/LDA/LDAShared.cs
index 14cfb6d..9a1941c 100644
--- a/src/Examples/LDA/LDAShared.cs
+++ b/src/Examples/LDA/LDAShared.cs
@@ -311,9 +311,7 @@ namespace LDAExample
                     Engine.NumberOfIterations = IterationsPerPass[pass];
                     if (showProgress)
                     {
-                        Console.Write(String.Format(
-                        "\nPass {0} ({1} iteration{2} per batch)",
-                        pass, IterationsPerPass[pass], IterationsPerPass[pass] == 1 ? "" : "s"));
+                        Console.Write($"\nPass {pass} ({IterationsPerPass[pass]} iteration{(IterationsPerPass[pass] == 1 ? "" : "s")} per batch)");
                     }
 
                     PhiDefModel.InferShared(EnginePhiDef, 0);
diff --git a/src/Examples/LDA/Program.cs b/src/Examples/LDA/Program.cs
index b0bbe23..1553ddf 100644
--- a/src/Examples/LDA/Program.cs
+++ b/src/Examples/LDA/Program.cs
@@ -146,7 +146,7 @@ namespace LDAExample
             }
 
             Console.WriteLine("\n\n************************************");
-            Console.WriteLine(String.Format("\nTraining {0}LDA model...\n", shared ? "batched " : "non-batched "));
+            Console.WriteLine($"\nTraining {(shared ? "batched " : "non-batched ")}LDA model...\n");
 
             // Train the model - we will also get rough estimates of execution time and memory
             GC.Collect();
@@ -159,13 +159,13 @@ namespace LDAExample
             float postMem = memCounter.NextValue();
             double approxMB = preMem - postMem;
             GC.KeepAlive(model); // Keep the model alive to this point (for the memory counter)
-            Console.WriteLine(String.Format("Approximate memory usage: {0:F2} MB", approxMB));
-            Console.WriteLine(String.Format("Approximate execution time (including model compilation): {0} seconds", stopWatch.ElapsedMilliseconds / 1000));
+            Console.WriteLine($"Approximate memory usage: {approxMB:F2} MB");
+            Console.WriteLine($"Approximate execution time (including model compilation): {stopWatch.ElapsedMilliseconds / 1000} seconds");
 
             // Calculate average log evidence over total training words
             int totalWords = trainWordsInTrainDoc.Sum(doc => doc.Sum(w => w.Value));
             Console.WriteLine("\nTotal number of training words = {0}", totalWords);
-            Console.WriteLine(String.Format("Average log evidence of model: {0:F2}", logEvidence / (double)totalWords));
+            Console.WriteLine($"Average log evidence of model: {logEvidence / (double)totalWords:F2}");
 
             if (vocabulary != null)
             {
@@ -201,7 +201,7 @@ namespace LDAExample
                 predictionModel.Engine.NumberOfIterations = 5;
                 var predDist = predictionModel.Predict(postTheta, postPhi);
                 var perplexity = Utilities.Perplexity(predDist, testWordsInTrainDoc);
-                Console.WriteLine(String.Format("\nPerplexity = {0:F3}", perplexity));
+                Console.WriteLine($"\nPerplexity = {perplexity:F3}");
             }
 
             if (wordsInTestDoc != null)
@@ -229,7 +229,7 @@ namespace LDAExample
                 }
 
                 var correctCount = CountCorrectTopicPredictions(topicPairCounts, numTopics);
-                Console.WriteLine(String.Format("Maximum inferred topic matches maximum true topic {0} times out of {1}", correctCount, inferredTopicDists.Length));
+                Console.WriteLine($"Maximum inferred topic matches maximum true topic {correctCount} times out of {inferredTopicDists.Length}");
                 Console.WriteLine("\nThis uses a greedy algorithm to determine the mapping from inferred topic indices to true topic indices");
                 Console.WriteLine("\n************************************");
             }
diff --git a/src/Examples/MontyHall/Window1.xaml.cs b/src/Examples/MontyHall/Window1.xaml.cs
index 827eaf1..3960238 100644
--- a/src/Examples/MontyHall/Window1.xaml.cs
+++ b/src/Examples/MontyHall/Window1.xaml.cs
@@ -240,11 +240,7 @@ namespace MontyHall
                     doAnimation("opendoor" + (index + 1));
                 }
 
-                percentlbl.Content = String.Format(
-                    "Success: {0} out of {1}\n({2}% correct)",
-                    trueCount,
-                    totalCount,
-                    Math.Round(100.0 * ((double)trueCount / (double)totalCount), 0));
+                percentlbl.Content = $"Success: {trueCount} out of {totalCount}\n({Math.Round(100.0 * ((double)trueCount / (double)totalCount), 0)}% correct)";
                 button3.Visibility = Visibility.Visible;
                 state = 3;
             }
diff --git a/src/Learners/Core/Metrics.cs b/src/Learners/Core/Metrics.cs
index 1e3f683..e24667c 100644
--- a/src/Learners/Core/Metrics.cs
+++ b/src/Learners/Core/Metrics.cs
@@ -431,7 +431,7 @@ namespace Microsoft.ML.Probabilistic.Learners
 
             // Compute the number of instances with positive ground truth labels
             var positiveInstanceSet = new HashSet<TInstance>(positiveInstances);
-            long positivesCount = positiveInstanceSet.Count();
+            long positivesCount = positiveInstanceSet.Count;
 
             if (positivesCount == 0)
             {
@@ -502,7 +502,7 @@ namespace Microsoft.ML.Probabilistic.Learners
 
             // Compute the number of instances with positive and negative ground truth labels
             var positiveInstanceSet = new HashSet<TInstance>(positiveInstances);
-            long positivesCount = positiveInstanceSet.Count();
+            long positivesCount = positiveInstanceSet.Count;
             long negativesCount = instanceScores.Count() - positivesCount;
 
             if (positivesCount == 0)
@@ -586,7 +586,7 @@ namespace Microsoft.ML.Probabilistic.Learners
 
             // Compute the number of instances with positive and negative ground truth labels
             var positiveInstanceSet = new HashSet<TInstance>(positiveInstances);
-            long positivesCount = positiveInstanceSet.Count();
+            long positivesCount = positiveInstanceSet.Count;
             long negativesCount = instanceScores.Count() - positivesCount;
 
             if (positivesCount == 0)
diff --git a/src/Learners/Core/PointEstimator.cs b/src/Learners/Core/PointEstimator.cs
index 27421ea..52cb843 100644
--- a/src/Learners/Core/PointEstimator.cs
+++ b/src/Learners/Core/PointEstimator.cs
@@ -73,7 +73,7 @@ namespace Microsoft.ML.Probabilistic.Learners
             }
 
             // Should never be reached
-            Debug.Fail(string.Format("Loss function {0} not supported", lossFunction));
+            Debug.Fail($"Loss function {lossFunction} not supported");
             return null;
         }
 
@@ -105,7 +105,7 @@ namespace Microsoft.ML.Probabilistic.Learners
             }
 
             // Should never be reached
-            Debug.Fail(string.Format("Loss function {0} not supported", lossFunction));
+            Debug.Fail($"Loss function {lossFunction} not supported");
             return null;
         }
 
@@ -137,7 +137,7 @@ namespace Microsoft.ML.Probabilistic.Learners
             }
 
             // Should never be reached
-            Debug.Fail(string.Format("Loss function {0} not supported", lossFunction));
+            Debug.Fail($"Loss function {lossFunction} not supported");
             return null;
         }
 
diff --git a/src/Learners/Core/Utilities.cs b/src/Learners/Core/Utilities.cs
index 39b2f97..8e576d6 100644
--- a/src/Learners/Core/Utilities.cs
+++ b/src/Learners/Core/Utilities.cs
@@ -273,10 +273,7 @@ namespace Microsoft.ML.Probabilistic.Learners
             if (expectedSerializationVersion != actualSerializationVersion)
             {
                 throw new SerializationException(
-                    string.Format(
-                        "Serialization version mismatch. Expected: {0}, actual: {1}.",
-                        expectedSerializationVersion,
-                        actualSerializationVersion));
+                    $"Serialization version mismatch. Expected: {expectedSerializationVersion}, actual: {actualSerializationVersion}.");
             }
         }
 
@@ -293,9 +290,7 @@ namespace Microsoft.ML.Probabilistic.Learners
             if (serializationVersionAttribute == null)
             {
                 throw new SerializationException(
-                    string.Format(
-                        "The {0} must be applied to the learner for serialization and deserialization.",
-                        typeof(SerializationVersionAttribute).Name));
+                    $"The {typeof(SerializationVersionAttribute).Name} must be applied to the learner for serialization and deserialization.");
             }
 
             return serializationVersionAttribute.SerializationVersion;
diff --git a/src/Learners/Recommender/Mappings/NegativeDataGeneratorMapping.cs b/src/Learners/Recommender/Mappings/NegativeDataGeneratorMapping.cs
index a5eca62..8ebc097 100644
--- a/src/Learners/Recommender/Mappings/NegativeDataGeneratorMapping.cs
+++ b/src/Learners/Recommender/Mappings/NegativeDataGeneratorMapping.cs
@@ -309,10 +309,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Mappings
                 if (ratedItems.Contains(ratedItem))
                 {
                     throw new NotSupportedException(
-                        string.Format(
-                            "Multiple occurances of the same user-item pair are not supported. User: {0}, Item: {1}.",
-                            user,
-                            item));
+                        $"Multiple occurances of the same user-item pair are not supported. User: {user}, Item: {item}.");
                 }
 
                 ratedItems.Add(ratedItem);
diff --git a/src/Learners/Recommender/MatchboxRecommenderInternal/HistogramSampler.cs b/src/Learners/Recommender/MatchboxRecommenderInternal/HistogramSampler.cs
index 52b0289..7f6b7cf 100644
--- a/src/Learners/Recommender/MatchboxRecommenderInternal/HistogramSampler.cs
+++ b/src/Learners/Recommender/MatchboxRecommenderInternal/HistogramSampler.cs
@@ -52,8 +52,7 @@ namespace Microsoft.ML.Probabilistic.Learners.MatchboxRecommenderInternal
                 if (leaf < 0)
                 {
                     throw new ArgumentException(
-                        string.Format(
-                            "All elements of the histogram must have non-negative values. Histogram element: {0}.", leaf),
+                        $"All elements of the histogram must have non-negative values. Histogram element: {leaf}.",
                         nameof(histogram));
                 }
 
@@ -108,10 +107,7 @@ namespace Microsoft.ML.Probabilistic.Learners.MatchboxRecommenderInternal
         {
             if (leaf < 0 || leaf > this.nodes.Count - this.firstLeafIndex)
             {
-                var outOfRangeExceptionMessage = string.Format(
-                    "The specified leaf must be non-negative and less than or equal to {0}. Given: {1}.",
-                    this.nodes.Count - this.firstLeafIndex,
-                    leaf);
+                var outOfRangeExceptionMessage = $"The specified leaf must be non-negative and less than or equal to {this.nodes.Count - this.firstLeafIndex}. Given: {leaf}.";
 
                 throw new ArgumentOutOfRangeException(nameof(leaf), outOfRangeExceptionMessage);
             }
@@ -120,7 +116,7 @@ namespace Microsoft.ML.Probabilistic.Learners.MatchboxRecommenderInternal
 
             if (this.GetValueAtIndex(currentIndex) == 0)
             {
-                throw new InvalidOperationException(string.Format("The value at leaf {0} is 0 and cannot be decreased.", leaf));
+                throw new InvalidOperationException($"The value at leaf {leaf} is 0 and cannot be decreased.");
             }
 
             // Update all parents to the root
diff --git a/src/Learners/Runners/CommandLine/Classifier/BayesPointMachineClassifierModuleUtilities.cs b/src/Learners/Runners/CommandLine/Classifier/BayesPointMachineClassifierModuleUtilities.cs
index 942860e..7c1592e 100644
--- a/src/Learners/Runners/CommandLine/Classifier/BayesPointMachineClassifierModuleUtilities.cs
+++ b/src/Learners/Runners/CommandLine/Classifier/BayesPointMachineClassifierModuleUtilities.cs
@@ -177,8 +177,8 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
         {
             TimeSpan time = TimeSpan.FromMilliseconds(elapsedMilliseconds);
 
-            string formattedTime = time.Hours > 0 ? string.Format("{0}:", time.Hours) : string.Empty;
-            formattedTime += time.Hours > 0 ? string.Format("{0:D2}:", time.Minutes) : time.Minutes > 0 ? string.Format("{0}:", time.Minutes) : string.Empty;
+            string formattedTime = time.Hours > 0 ? $"{time.Hours}:" : string.Empty;
+            formattedTime += time.Hours > 0 ? $"{time.Minutes:D2}:" : time.Minutes > 0 ? $"{time.Minutes}:" : string.Empty;
             formattedTime += time.Hours > 0 || time.Minutes > 0 ? string.Format("{0:D2}.{1:D3}", time.Seconds, time.Milliseconds) : string.Format("{0}.{1:D3} seconds", time.Seconds, time.Milliseconds);
 
             return formattedTime;
diff --git a/src/Learners/Runners/CommandLine/Classifier/BinaryBayesPointMachineClassifierCrossValidationModule.cs b/src/Learners/Runners/CommandLine/Classifier/BinaryBayesPointMachineClassifierCrossValidationModule.cs
index a14e1e4..fa225d1 100644
--- a/src/Learners/Runners/CommandLine/Classifier/BinaryBayesPointMachineClassifierCrossValidationModule.cs
+++ b/src/Learners/Runners/CommandLine/Classifier/BinaryBayesPointMachineClassifierCrossValidationModule.cs
@@ -139,7 +139,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                     accuracy[fold],
                     negativeLogProbability[fold],
                     auc[fold],
-                    computeModelEvidence ? string.Format("   Log evidence = {0,5:0.0000}", evidence[fold]) : string.Empty,
+                    computeModelEvidence ? $"   Log evidence = {evidence[fold]:0.0000}" : string.Empty,
                     iterationCounts[fold],
                     BayesPointMachineClassifierModuleUtilities.FormatElapsedTime(trainingTime[fold]));
 
diff --git a/src/Learners/Runners/CommandLine/Classifier/MulticlassBayesPointMachineClassifierCrossValidationModule.cs b/src/Learners/Runners/CommandLine/Classifier/MulticlassBayesPointMachineClassifierCrossValidationModule.cs
index 8f8d226..71a23a8 100644
--- a/src/Learners/Runners/CommandLine/Classifier/MulticlassBayesPointMachineClassifierCrossValidationModule.cs
+++ b/src/Learners/Runners/CommandLine/Classifier/MulticlassBayesPointMachineClassifierCrossValidationModule.cs
@@ -139,7 +139,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                     accuracy[fold],
                     negativeLogProbability[fold],
                     auc[fold],
-                    computeModelEvidence ? string.Format("   Log evidence = {0,5:0.0000}", evidence[fold]) : string.Empty,
+                    computeModelEvidence ? $"   Log evidence = {evidence[fold]:0.0000}" : string.Empty,
                     iterationCounts[fold],
                     BayesPointMachineClassifierModuleUtilities.FormatElapsedTime(trainingTime[fold]));
 
diff --git a/src/Learners/Runners/Common/CommandLine/CommandLineModuleSelector.cs b/src/Learners/Runners/Common/CommandLine/CommandLineModuleSelector.cs
index ac7e8b2..0868f3f 100644
--- a/src/Learners/Runners/Common/CommandLine/CommandLineModuleSelector.cs
+++ b/src/Learners/Runners/Common/CommandLine/CommandLineModuleSelector.cs
@@ -82,7 +82,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
             }
 
             CommandLineModule invokedSubmodule = this.registeredModulesDictionary[moduleName];
-            return invokedSubmodule.Run(args.Skip(1).ToArray(), string.Format("{0} {1}", usagePrefix, moduleName));
+            return invokedSubmodule.Run(args.Skip(1).ToArray(), $"{usagePrefix} {moduleName}");
         }
 
         /// <summary>
diff --git a/src/Learners/Runners/Common/CommandLine/CommandLineParser.cs b/src/Learners/Runners/Common/CommandLine/CommandLineParser.cs
index c39854f..542998f 100644
--- a/src/Learners/Runners/Common/CommandLine/CommandLineParser.cs
+++ b/src/Learners/Runners/Common/CommandLine/CommandLineParser.cs
@@ -210,7 +210,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
         private static void PrintParameterUsage(string parameterName, ParameterDescription description)
         {
             const int ParameterNameValuePadding = 35;
-            string parameterNameValue = description.IsFlag ? parameterName : string.Format("{0} {1}", parameterName, description.ValueDescriptionString);
+            string parameterNameValue = description.IsFlag ? parameterName : $"{parameterName} {description.ValueDescriptionString}";
             Console.WriteLine("  {0} {1}", parameterNameValue.PadRight(ParameterNameValuePadding), description.DescriptionString);
         }
 
diff --git a/src/Learners/Runners/Common/Configuration/ConfigurationBase.cs b/src/Learners/Runners/Common/Configuration/ConfigurationBase.cs
index 6ad8d27..a17985e 100644
--- a/src/Learners/Runners/Common/Configuration/ConfigurationBase.cs
+++ b/src/Learners/Runners/Common/Configuration/ConfigurationBase.cs
@@ -52,7 +52,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                             if (elementWithId != element)
                             {
                                 throw new InvalidConfigurationException(
-                                    string.Format("Identifier '{0}' was used for more than one object in the configuration file", element.Id));
+                                    $"Identifier '{element.Id}' was used for more than one object in the configuration file");
                             }
                         }
                         else
@@ -91,7 +91,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                 return; // For some reason type definition is considered unknown
             }
 
-            throw new InvalidConfigurationException(string.Format("Unknown element '{0}' found in the configuration file.", e.Name));
+            throw new InvalidConfigurationException($"Unknown element '{e.Name}' found in the configuration file.");
         }
     }
 }
diff --git a/src/Learners/Runners/Common/Configuration/ConfigurationElement.cs b/src/Learners/Runners/Common/Configuration/ConfigurationElement.cs
index 0155dbd..9156d14 100644
--- a/src/Learners/Runners/Common/Configuration/ConfigurationElement.cs
+++ b/src/Learners/Runners/Common/Configuration/ConfigurationElement.cs
@@ -42,7 +42,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                 if (property.GetValue(this, null) == null)
                 {
                     throw new InvalidOperationException(
-                        string.Format("Value of required configuration property {0} wasn't set for configuration element '{1}'.", property.Name, this.Id));
+                        $"Value of required configuration property {property.Name} wasn't set for configuration element '{this.Id}'.");
                 }
             }
         }
@@ -170,17 +170,17 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
             ConfigurationElement parentElement;
             if (!idToElement.TryGetValue(this.Parent, out parentElement))
             {
-                throw new InvalidOperationException(string.Format("Can't find configuration element with id '{0}'", this.Parent));
+                throw new InvalidOperationException($"Can't find configuration element with id '{this.Parent}'");
             }
 
             if (visitedElements.Contains(parentElement))
             {
-                throw new InvalidConfigurationException(string.Format("Circular dependency containing configuration element '{0}' detected.", this.Parent));
+                throw new InvalidConfigurationException($"Circular dependency containing configuration element '{this.Parent}' detected.");
             }
 
             if (parentElement.GetType() != this.GetType())
             {
-                throw new InvalidOperationException(string.Format("Parent configuration element '{0}' is not of the same type as child '{1}'.", this.Parent, this.Id));
+                throw new InvalidOperationException($"Parent configuration element '{this.Parent}' is not of the same type as child '{this.Id}'.");
             }
 
             parentElement.PropagateParentSettings(idToElement, visitedElements);
diff --git a/src/Learners/Runners/Common/DataModel/FileParsingContext.cs b/src/Learners/Runners/Common/DataModel/FileParsingContext.cs
index 462c475..3ba2d50 100644
--- a/src/Learners/Runners/Common/DataModel/FileParsingContext.cs
+++ b/src/Learners/Runners/Common/DataModel/FileParsingContext.cs
@@ -58,8 +58,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
             Debug.Assert(this.lineNumber != 0, "File parsing must have started.");
 
             string errorMessage = string.Format(format, args);
-            string fullErrorMessage = string.Format(
-                "Error parsing line '{0}' at {1}:{2}. {3}", this.line, this.fileName, this.lineNumber, errorMessage);
+            string fullErrorMessage = $"Error parsing line '{this.line}' at {this.fileName}:{this.lineNumber}. {errorMessage}";
             throw new InvalidFileFormatException(fullErrorMessage);
         }
 
@@ -72,7 +71,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
         public void RaiseGlobalError(string format, params object[] args)
         {
             string errorMessage = string.Format(format, args);
-            string fullErrorMessage = string.Format("Error parsing file {0}. {1}", this.fileName, errorMessage);
+            string fullErrorMessage = $"Error parsing file {this.fileName}. {errorMessage}";
             throw new InvalidFileFormatException(fullErrorMessage);
         }
     }
diff --git a/src/Learners/Runners/Common/DataModel/RatedUserItem.cs b/src/Learners/Runners/Common/DataModel/RatedUserItem.cs
index faa6600..c2572fe 100644
--- a/src/Learners/Runners/Common/DataModel/RatedUserItem.cs
+++ b/src/Learners/Runners/Common/DataModel/RatedUserItem.cs
@@ -48,7 +48,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
         /// <returns>A string that represents the current object.</returns>
         public override string ToString()
         {
-            return string.Format("({0}, {1}) -> {2}", this.User, this.Item, this.Rating);
+            return $"({this.User}, {this.Item}) -> {this.Rating}";
         }
     }
 }
\ No newline at end of file
diff --git a/src/Learners/Runners/Common/DataModel/RecommenderPersistenceUtils.cs b/src/Learners/Runners/Common/DataModel/RecommenderPersistenceUtils.cs
index 325eed9..167454b 100644
--- a/src/Learners/Runners/Common/DataModel/RecommenderPersistenceUtils.cs
+++ b/src/Learners/Runners/Common/DataModel/RecommenderPersistenceUtils.cs
@@ -72,7 +72,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                         (itemId = parts[1].Trim()).Length == 0 ||
                         !int.TryParse(parts[2], out rating))
                     {
-                        throw new InvalidFileFormatException(string.Format("Rating prediction file '{0}' has invalid format.", fileName));
+                        throw new InvalidFileFormatException($"Rating prediction file '{fileName}' has invalid format.");
                     }
 
                     var user = new User(userId, null);
@@ -88,7 +88,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                     if (itemToRating.ContainsKey(item))
                     {
                         throw new InvalidFileFormatException(
-                            string.Format("More than one rating for user {0} and item {1} in rating prediction file '{2}'.", userId, itemId, fileName));
+                            $"More than one rating for user {userId} and item {itemId} in rating prediction file '{fileName}'.");
                     }
 
                     itemToRating.Add(item, rating);
@@ -280,14 +280,14 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                         (listString = lineParts[1].Trim()).Length == 0)
                     {
                         throw new InvalidFileFormatException(
-                            string.Format("Each line in the file '{0}' should contain a non-empty identifier and a list of identifiers separated by colon.", fileName));
+                            $"Each line in the file '{fileName}' should contain a non-empty identifier and a list of identifiers separated by colon.");
                     }
 
                     var entity = entityFactory(entityId);
                     if (result.ContainsKey(entity))
                     {
                         throw new InvalidFileFormatException(
-                            string.Format("More than one set of list for {0} in the file '{1}'", entity, fileName));
+                            $"More than one set of list for {entity} in the file '{fileName}'");
                     }
 
                     var entityList = new List<TEntityInList>();
@@ -299,14 +299,14 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                         if (entityInListId.Length == 0)
                         {
                             throw new InvalidFileFormatException(
-                                string.Format("Empty identifier found in one of the lists in the file '{0}'", fileName));
+                                $"Empty identifier found in one of the lists in the file '{fileName}'");
                         }
                         
                         var entityInList = entityInListFactory(entityInListId);
                         if (entityInListSet.Contains(entityInList))
                         {
                             throw new InvalidFileFormatException(
-                                string.Format("{0} occured more than once in the list for {1} in the file '{2}'", entityInListId, entityId, fileName));
+                                $"{entityInListId} occured more than once in the list for {entityId} in the file '{fileName}'");
                         }
 
                         entityList.Add(entityInList);
diff --git a/src/Learners/Runners/Evaluator/Configuration/EvaluatorConfiguration.cs b/src/Learners/Runners/Evaluator/Configuration/EvaluatorConfiguration.cs
index 0aeaa2e..2fad87d 100644
--- a/src/Learners/Runners/Evaluator/Configuration/EvaluatorConfiguration.cs
+++ b/src/Learners/Runners/Evaluator/Configuration/EvaluatorConfiguration.cs
@@ -35,7 +35,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                 if (distinctTestTypes.Count() != runConfiguration.Tests.Length)
                 {
                     throw new InvalidConfigurationException(
-                        string.Format("Two or more tests of the same type are specified for the recommender run '{0}'.", runConfiguration.Name));
+                        $"Two or more tests of the same type are specified for the recommender run '{runConfiguration.Name}'.");
                 }
             }
         }
diff --git a/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/FeatureProcessor.cs b/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/FeatureProcessor.cs
index 9e26067..e82180f 100644
--- a/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/FeatureProcessor.cs
+++ b/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/FeatureProcessor.cs
@@ -84,11 +84,11 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
             if (inputFeatureParts.Length != inputFeatureCount)
             {
                 throw new ArgumentException(
-                    string.Format("There should be {0} features in {1}; given {2}.", inputFeatureCount, inputFeatures, inputFeatureParts.Length));
+                    $"There should be {inputFeatureCount} features in {inputFeatures}; given {inputFeatureParts.Length}.");
             }
             
             string id = inputFeatureParts[0];
-            var result = new StringBuilder(string.Format("{0},{1},", entityPrefix, id));
+            var result = new StringBuilder($"{entityPrefix},{id},");
 
             int offset = 0;
 
diff --git a/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/Features.cs b/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/Features.cs
index f95f080..dd166c1 100644
--- a/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/Features.cs
+++ b/src/Learners/Runners/Evaluator/DatasetGenerators/MovieLens/Features.cs
@@ -118,10 +118,10 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
             }
             else
             {
-                throw new ArgumentException(string.Format("User gender should be either 'M' or 'F'; given {0}", feature));
+                throw new ArgumentException($"User gender should be either 'M' or 'F'; given {feature}");
             }
 
-            return new Tuple<int, string>(UserGenderBucketCount, string.Format("{0}:1", offset + bucket));
+            return new Tuple<int, string>(UserGenderBucketCount, $"{offset + bucket}:1");
         }
 
         /// <summary>
@@ -137,7 +137,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
 
             if (!int.TryParse(feature, out age))
             {
-                throw new ArgumentException(string.Format("Invalid age: {0}.", feature));
+                throw new ArgumentException($"Invalid age: {feature}.");
             }
 
             int i;
@@ -152,10 +152,10 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
 
             if (i == UserAges.Length)
             {
-                throw new ArgumentException(string.Format("Invalid age: {0}.", feature));
+                throw new ArgumentException($"Invalid age: {feature}.");
             }
 
-            return new Tuple<int, string>(UserAgeBucketCount, string.Format("{0}:1", offset + bucket));
+            return new Tuple<int, string>(UserAgeBucketCount, $"{offset + bucket}:1");
         }
 
         /// <summary>
@@ -170,15 +170,15 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
 
             if (!int.TryParse(feature, out occupation))
             {
-                throw new ArgumentException(string.Format("Invalid occupation: {0}.", feature));
+                throw new ArgumentException($"Invalid occupation: {feature}.");
             }
 
             if (occupation < 0 || occupation > 20)
             {
-                throw new ArgumentException(string.Format("Occupation should be between 0 and 20; given {0}.", occupation));
+                throw new ArgumentException($"Occupation should be between 0 and 20; given {occupation}.");
             }
 
-            return new Tuple<int, string>(UserOccupationBucketCount, string.Format("{0}:1", offset + occupation));
+            return new Tuple<int, string>(UserOccupationBucketCount, $"{offset + occupation}:1");
         }
 
         /// <summary>
@@ -196,12 +196,12 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
 
             if (!int.TryParse(feature, out year))
             {
-                throw new ArgumentException(string.Format("Invalid movie release year: {0}.", feature));
+                throw new ArgumentException($"Invalid movie release year: {feature}.");
             }
 
             if (year < 1919 || year > 2000)
             {
-                throw new ArgumentException(string.Format("The movie release year should be between 1919 and 2000; given {0}", feature));
+                throw new ArgumentException($"The movie release year should be between 1919 and 2000; given {feature}");
             }
 
             int bucket = 0;
@@ -219,12 +219,12 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
                 double rvalue = (year - MovieYears[bucket - 1]) / years;
                 double lvalue = 1 - rvalue;
 
-                result = string.Format("{0}:{1}|{2}:{3}", offset + bucket - 1, lvalue, offset + bucket, rvalue);
+                result = $"{offset + bucket - 1}:{lvalue}|{offset + bucket}:{rvalue}";
             }
             else
             {
                 // set only one value
-                result = string.Format("{0}:1", offset + bucket);
+                result = $"{offset + bucket}:1";
             }
 
             return new Tuple<int, string>(MovieYearBucketCount, result);
@@ -242,10 +242,10 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners.MovieLens
             // genres.Length will always be at least 1
             double value = 1.0 / genres.Length;
 
-            var result = new StringBuilder(string.Format("{0}:{1}", offset + MovieGenreBuckets[genres[0]], value));
+            var result = new StringBuilder($"{offset + MovieGenreBuckets[genres[0]]}:{value}");
             for (int i = 1; i < genres.Length; ++i)
             {
-                result.Append(string.Format("|{0}:{1}", offset + MovieGenreBuckets[genres[i].Trim()], value));
+                result.Append($"|{offset + MovieGenreBuckets[genres[i].Trim()]}:{value}");
             }
 
             return new Tuple<int, string>(MovieGenreBucketCount, result.ToString());
diff --git a/src/Learners/Runners/Evaluator/MetricValueDistribution.cs b/src/Learners/Runners/Evaluator/MetricValueDistribution.cs
index 58c8df8..41f0b13 100644
--- a/src/Learners/Runners/Evaluator/MetricValueDistribution.cs
+++ b/src/Learners/Runners/Evaluator/MetricValueDistribution.cs
@@ -102,7 +102,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
         /// <returns>A string that represents the current object.</returns>
         public override string ToString()
         {
-            return string.Format("{0:0.000}  {1:0.000}", this.Mean, this.StdDev);
+            return $"{this.Mean:0.000}  {this.StdDev:0.000}";
         }
     }
 }
diff --git a/src/Learners/Runners/Evaluator/Wrappers/MahoutRecommender.cs b/src/Learners/Runners/Evaluator/Wrappers/MahoutRecommender.cs
index 9cd2be2..9944000 100644
--- a/src/Learners/Runners/Evaluator/Wrappers/MahoutRecommender.cs
+++ b/src/Learners/Runners/Evaluator/Wrappers/MahoutRecommender.cs
@@ -328,37 +328,16 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                 switch (this.Settings.RatingPredictionAlgorithm)
                 {
                     case MahoutRatingPredictionAlgorithm.UserBased:
-                        command = string.Format(
-                            "PredictRatings_UserBased \"{0}\" \"{1}\" \"{2}\" {3} {4}",
-                            this.trainingDatasetFile,
-                            queryFileName,
-                            predictionsFileName,
-                            this.Settings.RatingSimilarity,
-                            this.Settings.UserNeighborhoodSize);
+                        command = $"PredictRatings_UserBased \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\" {this.Settings.RatingSimilarity} {this.Settings.UserNeighborhoodSize}";
                         break;
                     case MahoutRatingPredictionAlgorithm.ItemBased:
-                        command = string.Format(
-                            "PredictRatings_ItemBased \"{0}\" \"{1}\" \"{2}\" {3}",
-                            this.trainingDatasetFile,
-                            queryFileName,
-                            predictionsFileName,
-                            this.Settings.RatingSimilarity);
+                        command = $"PredictRatings_ItemBased \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\" {this.Settings.RatingSimilarity}";
                         break;
                     case MahoutRatingPredictionAlgorithm.SlopeOne:
-                        command = string.Format(
-                            "PredictRatings_SlopeOne \"{0}\" \"{1}\" \"{2}\"",
-                            this.trainingDatasetFile,
-                            queryFileName,
-                            predictionsFileName);
+                        command = $"PredictRatings_SlopeOne \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\"";
                         break;
                     case MahoutRatingPredictionAlgorithm.Svd:
-                        command = string.Format(
-                            "PredictRatings_Svd \"{0}\" \"{1}\" \"{2}\" {3} {4}",
-                            this.trainingDatasetFile,
-                            queryFileName,
-                            predictionsFileName,
-                            this.Settings.TraitCount,
-                            this.Settings.IterationCount);
+                        command = $"PredictRatings_Svd \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\" {this.Settings.TraitCount} {this.Settings.IterationCount}";
                         break;
                     default:
                         Debug.Fail("Unsupported rating prediction algorithm.");
@@ -709,13 +688,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
             {
                 predictionsFileName = Path.GetTempFileName();
                 queryFileName = CreateRelatedEntitiesQueryFile(queries, u => this.userToId[u]);
-                string command = string.Format(
-                    "FindRelatedUsers \"{0}\" \"{1}\" \"{2}\" {3} {4}",
-                    this.trainingDatasetFile,
-                    queryFileName,
-                    predictionsFileName,
-                    relatedUserCount,
-                    this.Settings.RatingSimilarity);
+                string command = $"FindRelatedUsers \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\" {relatedUserCount} {this.Settings.RatingSimilarity}";
                 this.RunMahoutWrapper(command);
                 return ReadRelatedEntityPredictions(predictionsFileName, uId => this.idToUser[uId]);
             }
@@ -748,13 +721,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
             {
                 predictionsFileName = Path.GetTempFileName();
                 queryFileName = CreateRelatedEntitiesQueryFile(queries, i => this.itemToId[i]);
-                string command = string.Format(
-                    "FindRelatedItems \"{0}\" \"{1}\" \"{2}\" {3} {4}",
-                    this.trainingDatasetFile,
-                    queryFileName,
-                    predictionsFileName,
-                    relatedItemCount,
-                    this.Settings.RatingSimilarity);
+                string command = $"FindRelatedItems \"{this.trainingDatasetFile}\" \"{queryFileName}\" \"{predictionsFileName}\" {relatedItemCount} {this.Settings.RatingSimilarity}";
                 this.RunMahoutWrapper(command);
                 return ReadRelatedEntityPredictions(predictionsFileName, iId => this.idToItem[iId]);
             }
diff --git a/src/Learners/Runners/Evaluator/Wrappers/VowpalWabbitRecommender.cs b/src/Learners/Runners/Evaluator/Wrappers/VowpalWabbitRecommender.cs
index a967068..a20bdad 100644
--- a/src/Learners/Runners/Evaluator/Wrappers/VowpalWabbitRecommender.cs
+++ b/src/Learners/Runners/Evaluator/Wrappers/VowpalWabbitRecommender.cs
@@ -246,19 +246,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
 
                 // Invoke VW to train the model
                 string trainingCommand =
-                string.Format(
-                    "{0} -d \"{1}\" -b {2} -q ui --rank {3} --l1 {4} --l2 {5} --learning_rate {6} --decay_learning_rate {7} --passes {8} --power_t 0 -f \"{9}\" --cache_file \"{10}\" -k",
-                    PathToExe,
-                    trainingDatasetFile,
-                    this.Settings.BitPrecision,
-                    this.Settings.TraitCount,
-                    this.Settings.L1Regularization,
-                    this.Settings.L2Regularization,
-                    this.Settings.LearningRate,
-                    this.Settings.LearningRateDecay,
-                    this.Settings.PassCount,
-                    this.modelFileName,
-                    cacheFileName);
+                $"{PathToExe} -d \"{trainingDatasetFile}\" -b {this.Settings.BitPrecision} -q ui --rank {this.Settings.TraitCount} --l1 {this.Settings.L1Regularization} --l2 {this.Settings.L2Regularization} --learning_rate {this.Settings.LearningRate} --decay_learning_rate {this.Settings.LearningRateDecay} --passes {this.Settings.PassCount} --power_t 0 -f \"{this.modelFileName}\" --cache_file \"{cacheFileName}\" -k";
                 WrapperUtils.ExecuteExternalCommand(trainingCommand);
 
                 // Remember users and items used for training
@@ -496,12 +484,7 @@ namespace Microsoft.ML.Probabilistic.Learners.Runners
                 predictionsFile = Path.GetTempFileName();
 
                 // Invoke VW to compute the fractional rating predictions
-                string predictionCommand = string.Format(
-                   "{0} -d \"{1}\" -i {2} -t -p {3}",
-                   PathToExe,
-                   predictionDatasetFile,
-                   this.modelFileName,
-                   predictionsFile);
+                string predictionCommand = $"{PathToExe} -d \"{predictionDatasetFile}\" -i {this.modelFileName} -t -p {predictionsFile}";
                 WrapperUtils.ExecuteExternalCommand(predictionCommand);
                 
                 // Read the predictions from file
diff --git a/src/Runtime/Core/Collections/IListExtensions.cs b/src/Runtime/Core/Collections/IListExtensions.cs
index 2386e20..ecfca4d 100644
--- a/src/Runtime/Core/Collections/IListExtensions.cs
+++ b/src/Runtime/Core/Collections/IListExtensions.cs
@@ -53,9 +53,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <returns></returns>
         public static int ListSum(this IList<int> source)
         {
-            if (source is SparseList<int>)
+            if (source is SparseList<int> sl)
             {
-                SparseList<int> sl = (SparseList<int>) source;
                 int sum = sl.CommonValue*(sl.Count - sl.SparseValues.Count);
                 foreach (var sel in sl.SparseValues) sum += sel.Value;
                 return sum;
@@ -71,9 +70,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <returns></returns>
         public static double ListSum(this IList<int> source, Func<int, double> converter)
         {
-            if (source is SparseList<int>)
+            if (source is SparseList<int> sl)
             {
-                var sl = (SparseList<int>) source;
                 double sum = converter(sl.CommonValue)*(sl.Count - sl.SparseValues.Count);
                 foreach (var sel in sl.SparseValues) sum += converter(sel.Value);
                 return sum;
@@ -123,9 +121,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <returns></returns>
         public static TRes ListReduce<T, TRes>(this IList<T> source, TRes initial, Func<TRes, T, TRes> fun)
         {
-            if (source is SparseList<T>)
+            if (source is SparseList<T> sl)
             {
-                var sl = (SparseList<T>) source;
                 return sl.Reduce(initial, fun);
             }
             return source.Aggregate(initial, fun);
@@ -145,9 +142,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         public static TRes ListReduce<T, T2, TRes>(this IList<T> source, IEnumerable<T2> secondList,
                                                    TRes initial, Func<TRes, T, T2, TRes> fun)
         {
-            if (source is SparseList<T>)
+            if (source is SparseList<T> sl)
             {
-                var sl = (SparseList<T>) source;
                 return sl.Reduce(initial, secondList, fun);
             }
             throw new NotImplementedException("Two argument reduce not implemented for non-sparse lists");
@@ -161,9 +157,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         public static Vector ToVector(this IList<double> source)
         {
             if (source is Vector) return (Vector) source;
-            if (source is SparseList<double>)
+            if (source is SparseList<double> sl)
             {
-                var sl = (SparseList<double>) source;
                 return SparseVector.FromSparseValues(
                     sl.Count, sl.CommonValue,
                     sl.SparseValues
@@ -179,9 +174,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <returns></returns>
         public static Vector ToVector(this IList<int> source)
         {
-            if (source is SparseList<int>)
+            if (source is SparseList<int> sl)
             {
-                var sl = (SparseList<int>) source;
                 return SparseVector.FromSparseValues(
                     sl.Count, sl.CommonValue,
                     sl.SparseValues.Select(sel => new ValueAtIndex<double> {Index = sel.Index, Value = sel.Value}).ToList()
@@ -198,8 +192,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <param name="that"></param>
         public static void SetTo<T>(this IList<T> source, IEnumerable<T> that)
         {
-            if (source is SparseList<T>)
-                ((SparseList<T>) source).SetTo(that);
+            if (source is SparseList<T> Ts)
+                Ts.SetTo(that);
             else
             {
                 var thatlst = that as IList<T>;
@@ -226,8 +220,8 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <param name="that"></param>
         public static void SetTo(this IList<double> source, IEnumerable<double> that)
         {
-            if (source is Vector)
-                ((Vector) source).SetTo(that);
+            if (source is Vector vector)
+                vector.SetTo(that);
             else
                 source.SetTo<double>(that);
         }
diff --git a/src/Runtime/Core/Collections/JaggedArray.cs b/src/Runtime/Core/Collections/JaggedArray.cs
index 4a4c5b1..f9f803d 100644
--- a/src/Runtime/Core/Collections/JaggedArray.cs
+++ b/src/Runtime/Core/Collections/JaggedArray.cs
@@ -244,9 +244,9 @@ namespace Microsoft.ML.Probabilistic.Collections
             foreach (object elt in jaggedArray)
             {
                 if (elt == null || leafType.IsAssignableFrom(elt.GetType())) yield return elt;
-                else if (elt is IEnumerable)
+                else if (elt is IEnumerable iEnumerable)
                 {
-                    foreach (object subElt in ElementIterator((IEnumerable) elt, leafType))
+                    foreach (object subElt in ElementIterator(iEnumerable, leafType))
                         yield return subElt;
                 }
             }
diff --git a/src/Runtime/Core/Collections/SparseList.cs b/src/Runtime/Core/Collections/SparseList.cs
index 0b6ff96..5ca549b 100644
--- a/src/Runtime/Core/Collections/SparseList.cs
+++ b/src/Runtime/Core/Collections/SparseList.cs
@@ -360,7 +360,7 @@ namespace Microsoft.ML.Probabilistic.Collections
         /// <exclude/>
         protected void CheckCompatible<T2>(IList<T2> that, string paramName)
         {
-            Argument.CheckIfValid(that.Count == this.Count, string.Format("Size of {0} does not match size of this list. Expected {1}, got {2}.", paramName, this.Count, that.Count));
+            Argument.CheckIfValid(that.Count == this.Count, $"Size of {paramName} does not match size of this list. Expected {this.Count}, got {that.Count}.");
         }
 
         /// <summary>
diff --git a/src/Runtime/Core/Maths/Matrix.cs b/src/Runtime/Core/Maths/Matrix.cs
index 7c3bc3c..cdc4d15 100644
--- a/src/Runtime/Core/Maths/Matrix.cs
+++ b/src/Runtime/Core/Maths/Matrix.cs
@@ -1505,8 +1505,7 @@ namespace Microsoft.ML.Probabilistic.Math
         public void CheckSymmetry(string paramName)
         {
             double error = SymmetryError();
-            Assert.IsTrue(error < Tolerance, String.Format(
-                "Matrix is not symmetric (SymmetryError = {0})", error));
+            Assert.IsTrue(error < Tolerance, $"Matrix is not symmetric (SymmetryError = {error})");
         }
 
         /// <summary>
@@ -1609,7 +1608,7 @@ namespace Microsoft.ML.Probabilistic.Math
         /// <returns>A string</returns>
         public string ToString(string format)
         {
-            if (cols == 0) return String.Format("[{0}x{1} Matrix]", rows, cols);
+            if (cols == 0) return $"[{rows}x{cols} Matrix]";
             string[][] lines = new string[2*cols - 1][];
             for (int j = 0; j < cols; ++j)
             {
@@ -1647,7 +1646,7 @@ namespace Microsoft.ML.Probabilistic.Math
                     cols = fields.Length;
                     result = new Matrix(rows, cols);
                 }
-                else if (cols != fields.Length) throw new ArgumentException(String.Format("line {0} has {1} columns but line 0 has {2} columns", i, fields.Length, cols));
+                else if (cols != fields.Length) throw new ArgumentException($"line {i} has {fields.Length} columns but line 0 has {cols} columns");
                 for (int j = 0; j < cols; j++)
                 {
                     result[i, j] = double.Parse(fields[j]);
@@ -2253,7 +2252,7 @@ namespace Microsoft.ML.Probabilistic.Math
             for (int iter = 0; ;iter++)
             {
                 if (iter >= 30*n)
-                    throw new Exception(string.Format("EigenvaluesInPlace exceeded {0} iterations", iter));
+                    throw new Exception($"EigenvaluesInPlace exceeded {iter} iterations");
                 // Set small subdiagonal elements to zero
                 double tol = 1e-15;
                 int nonZeroStart = n;
diff --git a/src/Runtime/Core/Maths/Region.cs b/src/Runtime/Core/Maths/Region.cs
index 94db73a..c62b7a5 100644
--- a/src/Runtime/Core/Maths/Region.cs
+++ b/src/Runtime/Core/Maths/Region.cs
@@ -112,7 +112,7 @@ namespace Microsoft.ML.Probabilistic.Math
 
         public string ToString(string format)
         {
-            return string.Format("[{0},{1}]", Lower.ToString(format), Upper.ToString(format));
+            return $"[{Lower.ToString(format)},{Upper.ToString(format)}]";
         }
 
         public override bool Equals(object obj)
diff --git a/src/Runtime/Core/Maths/SparseVector.cs b/src/Runtime/Core/Maths/SparseVector.cs
index 908b18b..4d29bd1 100644
--- a/src/Runtime/Core/Maths/SparseVector.cs
+++ b/src/Runtime/Core/Maths/SparseVector.cs
@@ -182,8 +182,9 @@ namespace Microsoft.ML.Probabilistic.Math
         public override Vector Append(Vector second)
         {
             int jointCount = Count + second.Count;
-            SparseVector seconds = second as SparseVector; // Will be null if not sparse
-            if (seconds != null && seconds.CommonValue == CommonValue)
+
+ // Will be null if not sparse
+            if (second is SparseVector seconds && seconds.CommonValue == CommonValue)
             {
                 SparseVector result = SparseVector.Constant(jointCount, CommonValue);
                 result.SparseValues.AddRange(SparseValues);
@@ -2177,8 +2178,8 @@ namespace Microsoft.ML.Probabilistic.Math
         {
             if (startIndex + that.Count > Count)
                 throw new ArgumentException("startIndex (" + startIndex + ") + that.Count (" + that.Count + ") > this.Count (" + this.Count + ")");
-            SparseVector thats = that as SparseVector;
-            if (thats != null && thats.CommonValue == CommonValue)
+
+            if (that is SparseVector thats && thats.CommonValue == CommonValue)
             {
                 // Build up the new list of sparse elements
                 List<SparseElement> newSV = new List<SparseElement>();
@@ -2405,8 +2406,9 @@ namespace Microsoft.ML.Probabilistic.Math
         public override Vector Append(Vector second)
         {
             int jointCount = Count + second.Count;
-            SparseVector seconds = second as SparseVector; // Will be null if not sparse
-            if (seconds != null && seconds.CommonValue == CommonValue)
+
+ // Will be null if not sparse
+            if (second is SparseVector seconds && seconds.CommonValue == CommonValue)
             {
                 ApproximateSparseVector result = ApproximateSparseVector.Constant(jointCount, CommonValue, Sparsity);
                 result.SparseValues.AddRange(SparseValues);
diff --git a/src/Runtime/Core/Maths/SpecialFunctions.cs b/src/Runtime/Core/Maths/SpecialFunctions.cs
index acf0770..5d902f2 100644
--- a/src/Runtime/Core/Maths/SpecialFunctions.cs
+++ b/src/Runtime/Core/Maths/SpecialFunctions.cs
@@ -597,7 +597,7 @@ namespace Microsoft.ML.Probabilistic.Math
                 }
                 else
                 {
-                    throw new InvalidOperationException(String.Format("Unexpected condition: a = {0}, b = {1}, x = {2}", a, b, x));
+                    throw new InvalidOperationException($"Unexpected condition: a = {a}, b = {b}, x = {x}");
                 }
             }
             else
@@ -669,7 +669,7 @@ namespace Microsoft.ML.Probabilistic.Math
                 }
                 else
                 {
-                    throw new InvalidOperationException(String.Format("Unexpected condition: a = {0}, b = {1}, x = {2}", a, b, x));
+                    throw new InvalidOperationException($"Unexpected condition: a = {a}, b = {b}, x = {x}");
                 }
             }
 
diff --git a/src/Runtime/Core/Maths/Vector.cs b/src/Runtime/Core/Maths/Vector.cs
index b93fedd..ce9aa6e 100644
--- a/src/Runtime/Core/Maths/Vector.cs
+++ b/src/Runtime/Core/Maths/Vector.cs
@@ -664,7 +664,7 @@ namespace Microsoft.ML.Probabilistic.Math
         /// <returns></returns>
         public virtual bool Any(Vector that, Func<double, double, bool> fun)
         {
-            if (that is DenseVector) return ((DenseVector) that).Any(this, (x, y) => fun(y, x));
+            if (that is DenseVector denseVector) return denseVector.Any(this, (x, y) => fun(y, x));
             throw new NotImplementedException();
         }
 
diff --git a/src/Runtime/Core/Serialization/BinaryReaderExtensions.cs b/src/Runtime/Core/Serialization/BinaryReaderExtensions.cs
index 062635c..258c3e7 100644
--- a/src/Runtime/Core/Serialization/BinaryReaderExtensions.cs
+++ b/src/Runtime/Core/Serialization/BinaryReaderExtensions.cs
@@ -78,10 +78,7 @@ namespace Microsoft.ML.Probabilistic.Serialization
             {
                 if (exceptionMessage == null)
                 {
-                    exceptionMessage = string.Format(
-                        "The deserialized version {0} is invalid. Custom binary serialization of this object requires a version between 1 and {1}.",
-                        deserializedVersion,
-                        maxPermittedSerializationVersion);
+                    exceptionMessage = $"The deserialized version {deserializedVersion} is invalid. Custom binary serialization of this object requires a version between 1 and {maxPermittedSerializationVersion}.";
                 }
 
                 throw new SerializationException(exceptionMessage);
diff --git a/src/Runtime/Core/Serialization/MatlabWriter.cs b/src/Runtime/Core/Serialization/MatlabWriter.cs
index 81f96dc..17da0e8 100644
--- a/src/Runtime/Core/Serialization/MatlabWriter.cs
+++ b/src/Runtime/Core/Serialization/MatlabWriter.cs
@@ -515,8 +515,7 @@ namespace Microsoft.ML.Probabilistic.Serialization
                 if (entry.Key.Length >= maxFieldNameLength)
                 {
                     truncatedKey = entry.Key.Substring(0, maxFieldNameLength - 1);
-                    Console.WriteLine(string.Format("dictionary key '{0}' exceeds the MATLAB maximum name length of {1} characters and will be truncated to '{2}'", 
-                        entry.Key, (maxFieldNameLength - 1), truncatedKey));
+                    Console.WriteLine($"dictionary key '{entry.Key}' exceeds the MATLAB maximum name length of {(maxFieldNameLength - 1)} characters and will be truncated to '{truncatedKey}'");
                 }
                 Write(truncatedKey, maxFieldNameLength);
             }
diff --git a/src/Runtime/Core/Serialization/SerializationAttributes.cs b/src/Runtime/Core/Serialization/SerializationAttributes.cs
index 066b930..08a7c0f 100644
--- a/src/Runtime/Core/Serialization/SerializationAttributes.cs
+++ b/src/Runtime/Core/Serialization/SerializationAttributes.cs
@@ -74,21 +74,18 @@ namespace Microsoft.ML.Probabilistic.Serialization
             {
                 throw new ArgumentException("Invalid property or method name '" + Params[paramIndex] + "' for parameter " + paramIndex + " in type " + this.TargetMember?.Name + ".");
             }
-            else if (paramMember is PropertyInfo)
+            else if (paramMember is PropertyInfo prop)
             {
-                PropertyInfo prop = (PropertyInfo) paramMember;
                 type = prop.PropertyType;
                 return prop.GetValue(instance, null);
             }
-            else if (paramMember is FieldInfo)
+            else if (paramMember is FieldInfo field)
             {
-                FieldInfo field = (FieldInfo) paramMember;
                 type = field.FieldType;
                 return field.GetValue(instance);
             }
-            else if (paramMember is MethodInfo)
+            else if (paramMember is MethodInfo method)
             {
-                MethodInfo method = (MethodInfo) paramMember;
                 type = method.ReturnType;
                 return method.Invoke(instance, null);
             }
diff --git a/src/Runtime/Core/Utils/StringUtil.cs b/src/Runtime/Core/Utils/StringUtil.cs
index 5fb4e77..b471009 100644
--- a/src/Runtime/Core/Utils/StringUtil.cs
+++ b/src/Runtime/Core/Utils/StringUtil.cs
@@ -339,8 +339,7 @@ namespace Microsoft.ML.Probabilistic.Utilities
                 string parameterTypeString;
                 if (parameter.ParameterType.IsByRef)
                 {
-                    parameterTypeString = string.Format(
-                        "{0} {1}", parameter.IsOut ? "out" : "ref", TypeToString(parameter.ParameterType.GetElementType()));
+                    parameterTypeString = $"{(parameter.IsOut ? "out" : "ref")} {TypeToString(parameter.ParameterType.GetElementType())}";
                 }
                 else
                 {
diff --git a/src/Runtime/Distributions/ArrayEstimator.cs b/src/Runtime/Distributions/ArrayEstimator.cs
index 420db14..49f9a0e 100644
--- a/src/Runtime/Distributions/ArrayEstimator.cs
+++ b/src/Runtime/Distributions/ArrayEstimator.cs
@@ -638,7 +638,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
             Type leafEstimatorType = EstimatorFactory.Instance.EstimatorType(leafDistributionType);
             if (leafEstimatorType == null)
                 throw new InferRuntimeException(
-                    String.Format("Cannot find Estimator class for {0}", leafDistributionType));
+                    $"Cannot find Estimator class for {leafDistributionType}");
 
             // Distribution types at each depth when considered as a jagged array of distributions
             Type[] arrDistTypes = (JaggedArray.GetTypes(
@@ -654,7 +654,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
             method = method.MakeGenericMethod(leafDistributionType, leafDomainType);
             if (method == null)
                 throw new InferRuntimeException(
-                    String.Format("Cannot find Estimator class for {0}", leafDistributionType));
+                    $"Cannot find Estimator class for {leafDistributionType}");
             Array estimators = JaggedArray.ConvertToNew(
                 distributions, leafDistributionType, leafEstimatorType, elt => Util.Invoke(method, EstimatorFactory.Instance, elt));
 
@@ -722,7 +722,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
             Type leafEstimatorType = EstimatorFactory.Instance.EstimatorType(leafDistributionType);
             if (leafEstimatorType == null)
                 throw new InferRuntimeException(
-                    String.Format("Cannot find Estimator class for {0}", leafDistributionType));
+                    $"Cannot find Estimator class for {leafDistributionType}");
 
             // Get array of distribution types
             Type[] arrDistTypes = (JaggedArray.GetTypes(
diff --git a/src/Runtime/Distributions/Automata/GraphVizAutomatonFormat.cs b/src/Runtime/Distributions/Automata/GraphVizAutomatonFormat.cs
index 2d84ca7..495ef91 100644
--- a/src/Runtime/Distributions/Automata/GraphVizAutomatonFormat.cs
+++ b/src/Runtime/Distributions/Automata/GraphVizAutomatonFormat.cs
@@ -64,10 +64,10 @@ namespace Microsoft.ML.Probabilistic.Distributions.Automata
                         transitionLabel = EscapeLabel(transition.ElementDistribution.ToString());
                     }
 
-                    string label = string.Format("W={0:G5}\\n{1}", transition.Weight.Value, transitionLabel);
+                    string label = $"W={transition.Weight.Value:G5}\\n{transitionLabel}";
                     if (transition.Group != 0)
                     {
-                        label = string.Format("{0}\\n#{1}", label, transition.Group);
+                        label = $"{label}\\n#{transition.Group}";
                     }
 
                     graphVizCode.AppendFormat("  N{0} -> N{1} [ label = \"{2}\" ];", state.Index, transition.DestinationStateIndex, label);
diff --git a/src/Runtime/Distributions/Automata/RegexpTreeBuilder.cs b/src/Runtime/Distributions/Automata/RegexpTreeBuilder.cs
index 09e7e25..b809749 100644
--- a/src/Runtime/Distributions/Automata/RegexpTreeBuilder.cs
+++ b/src/Runtime/Distributions/Automata/RegexpTreeBuilder.cs
@@ -486,7 +486,7 @@ namespace Microsoft.ML.Probabilistic.Distributions.Automata
             /// <returns>A string representation of the instance.</returns>
             public override string ToString()
             {
-                return string.Format("{0} ({1}, {2})", this.Index, this.Regex.Type, this.EdgeType);
+                return $"{this.Index} ({this.Regex.Type}, {this.EdgeType})";
             }
         }
 
@@ -587,7 +587,7 @@ namespace Microsoft.ML.Probabilistic.Distributions.Automata
             /// <returns>A string representation of the instance.</returns>
             public override string ToString()
             {
-                return string.Format("{0}Out: {1}", this.Regex.Type != RegexpTreeNodeType.Empty ? "X" : string.Empty, Util.CollectionToString(this.OutgoingNodes));
+                return $"{(this.Regex.Type != RegexpTreeNodeType.Empty ? "X" : string.Empty)}Out: {Util.CollectionToString(this.OutgoingNodes)}";
             }
 
             /// <summary>
@@ -999,7 +999,7 @@ namespace Microsoft.ML.Probabilistic.Distributions.Automata
 
                 if (currentIndex < endIndex)
                 {
-                    throw new ArgumentException(string.Format("Current index {0} cannot be less than end index {1}", currentIndex, endIndex));
+                    throw new ArgumentException($"Current index {currentIndex} cannot be less than end index {endIndex}");
                 }
 
                 var currentNode = this.Nodes[currentIndex];
diff --git a/src/Runtime/Distributions/Automata/StringAutomaton.cs b/src/Runtime/Distributions/Automata/StringAutomaton.cs
index e407429..32a7892 100644
--- a/src/Runtime/Distributions/Automata/StringAutomaton.cs
+++ b/src/Runtime/Distributions/Automata/StringAutomaton.cs
@@ -198,12 +198,7 @@ namespace Microsoft.ML.Probabilistic.Distributions.Automata
             /// </summary>
             /// <returns>String representation of this instance.</returns>
             public override string ToString() =>
-                string.Format(
-                    "Bound: {0}, Dest: {1}, Weight: {2}, {3}",
-                    this.Position,
-                    this.DestinationStateId,
-                    this.Weight,
-                    this.IsEnd ? "End" : "Start");
+                $"Bound: {this.Position}, Dest: {this.DestinationStateId}, Weight: {this.Weight}, {(this.IsEnd ? "End" : "Start")}";
         }
 
         /// <summary>
diff --git a/src/Runtime/Distributions/BernoulliIntegerSubset.cs b/src/Runtime/Distributions/BernoulliIntegerSubset.cs
index 74381b8..74395b6 100644
--- a/src/Runtime/Distributions/BernoulliIntegerSubset.cs
+++ b/src/Runtime/Distributions/BernoulliIntegerSubset.cs
@@ -270,7 +270,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
 
         public override string ToString()
         {
-            return string.Format("BernoulliIntegerSubset({0})", this.SparseBernoulliList.ToString());
+            return $"BernoulliIntegerSubset({this.SparseBernoulliList.ToString()})";
         }
 
         /// <summary>
diff --git a/src/Runtime/Distributions/Dirichlet.cs b/src/Runtime/Distributions/Dirichlet.cs
index ce717ca..07eb1ef 100644
--- a/src/Runtime/Distributions/Dirichlet.cs
+++ b/src/Runtime/Distributions/Dirichlet.cs
@@ -640,7 +640,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         public double GetAverageLog(Dirichlet that)
         {
             if (this.Dimension != that.Dimension)
-                throw new ArgumentException(String.Format("that.Dimension ({0}) does not match this.Dimension ({1})", that.Dimension, this.Dimension));
+                throw new ArgumentException($"that.Dimension ({that.Dimension}) does not match this.Dimension ({this.Dimension})");
             if (that.IsPointMass)
             {
                 if (this.IsPointMass && Point.Equals(that.Point)) return 0.0;
@@ -1064,7 +1064,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         public double GetLogAverageOf(Dirichlet that)
         {
             if (this.Dimension != that.Dimension)
-                throw new ArgumentException(String.Format("that.Dimension ({0}) does not match this.Dimension ({1})", that.Dimension, this.Dimension));
+                throw new ArgumentException($"that.Dimension ({that.Dimension}) does not match this.Dimension ({this.Dimension})");
             if (IsPointMass)
             {
                 return that.GetLogProb(Point);
diff --git a/src/Runtime/Distributions/Discrete.cs b/src/Runtime/Distributions/Discrete.cs
index 591ec83..7e16723 100644
--- a/src/Runtime/Distributions/Discrete.cs
+++ b/src/Runtime/Distributions/Discrete.cs
@@ -878,7 +878,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         [Construction("Point", "Dimension", UseWhen = "IsPointMass")]
         public static Discrete PointMass(int value, int numValues)
         {
-            if (value < 0 || value >= numValues) throw new ArgumentException(String.Format("value ({0}) is not in the range [0, numValues-1 ({1})]", value, numValues - 1));
+            if (value < 0 || value >= numValues) throw new ArgumentException($"value ({value}) is not in the range [0, numValues-1 ({numValues - 1})]");
             Discrete d = Discrete.Uniform(numValues);
             d.Point = value;
             return d;
diff --git a/src/Runtime/Distributions/DiscreteChar.cs b/src/Runtime/Distributions/DiscreteChar.cs
index e2ea2d8..e7e0d92 100644
--- a/src/Runtime/Distributions/DiscreteChar.cs
+++ b/src/Runtime/Distributions/DiscreteChar.cs
@@ -423,8 +423,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         {
             Argument.CheckIfNotNull(vector, "vector");
 
-            var piecewise = vector as PiecewiseVector;
-            if (piecewise != null)
+            if (vector is PiecewiseVector piecewise)
             {
                 return FromVector(piecewise);
             }
diff --git a/src/Runtime/Distributions/GaussianProcess/SparseGPFixed.cs b/src/Runtime/Distributions/GaussianProcess/SparseGPFixed.cs
index 8c59634..447220a 100644
--- a/src/Runtime/Distributions/GaussianProcess/SparseGPFixed.cs
+++ b/src/Runtime/Distributions/GaussianProcess/SparseGPFixed.cs
@@ -67,8 +67,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         {
             if (ReferenceEquals(null, obj)) return false;
             if (ReferenceEquals(this, obj)) return true;
-            var other = obj as SparseGPFixed;
-            return other != null && Equals(other);
+            return obj is SparseGPFixed other && Equals(other);
         }
 
         public override int GetHashCode()
diff --git a/src/Runtime/Distributions/LeftTruncatedPoisson.cs b/src/Runtime/Distributions/LeftTruncatedPoisson.cs
index 826f73f..be1b1e6 100644
--- a/src/Runtime/Distributions/LeftTruncatedPoisson.cs
+++ b/src/Runtime/Distributions/LeftTruncatedPoisson.cs
@@ -786,7 +786,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
             }
             else
             {
-                return string.Format("TruncPois:Rate={0:0.000},Prec={1:0.00},Start={2}", this.Rate, this.Precision, this.StartPoint);
+                return $"TruncPois:Rate={this.Rate:0.000},Prec={this.Precision:0.00},Start={this.StartPoint}";
             }
         }
 
diff --git a/src/Runtime/Distributions/Pareto.cs b/src/Runtime/Distributions/Pareto.cs
index 8d6425a..69394a5 100644
--- a/src/Runtime/Distributions/Pareto.cs
+++ b/src/Runtime/Distributions/Pareto.cs
@@ -271,7 +271,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         public override string ToString()
         {
             string format = "g4";
-            return string.Format("Pareto({0},{1})", Shape.ToString(format), LowerBound.ToString(format));
+            return $"Pareto({Shape.ToString(format)},{LowerBound.ToString(format)})";
         }
     }
 }
diff --git a/src/Runtime/Distributions/SparseDistributionList.cs b/src/Runtime/Distributions/SparseDistributionList.cs
index 09c3ae7..becec74 100644
--- a/src/Runtime/Distributions/SparseDistributionList.cs
+++ b/src/Runtime/Distributions/SparseDistributionList.cs
@@ -279,8 +279,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
                 return double.PositiveInfinity;
             }
 
-            var sparseThat = thatd as ISparseEnumerable<TDist>;
-            if (sparseThat != null)
+            if (thatd is ISparseEnumerable<TDist> sparseThat)
             {
                 return this.Reduce<double, TDist>(
                     double.NegativeInfinity, sparseThat, (x, y, z) => Math.Max(x, y.MaxDiff(z)), (x, y, z, n) => Math.Max(x, y.MaxDiff(z)));
@@ -318,7 +317,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         /// <returns>The log probability of the given value>.</returns>
         public double GetLogProb(ISparseList<TDomain> value)
         {
-            Argument.CheckIfValid(value.Count == this.Dimension, string.Format("Point value does not match dimension of this distribution. Expected {0}, got {1}.", this.Dimension, value.Count));
+            Argument.CheckIfValid(value.Count == this.Dimension, $"Point value does not match dimension of this distribution. Expected {this.Dimension}, got {value.Count}.");
             return this.Reduce<double, TDomain>(0.0, value, (x, y, z) => x + y.GetLogProb(z), (x, y, z, n) => x + n * y.GetLogProb(z));
         }
 
@@ -341,7 +340,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
         /// <remarks>This method is inefficient in that the result will be dense even though the return type is sparse.</remarks>
         public ISparseList<TDomain> Sample(ISparseList<TDomain> result)
         {
-            Argument.CheckIfValid(result.Count == this.Dimension, string.Format("Result list does not match dimension of this distribution. Expected {0}, got {1}.", this.Dimension, result.Count));
+            Argument.CheckIfValid(result.Count == this.Dimension, $"Result list does not match dimension of this distribution. Expected {this.Dimension}, got {result.Count}.");
             IEnumerator<TDist> e = GetEnumerator();
             int i = 0;
             while (e.MoveNext())
diff --git a/src/Runtime/Distributions/TruncatedPoisson.cs b/src/Runtime/Distributions/TruncatedPoisson.cs
index ceee97b..5e0b2e1 100644
--- a/src/Runtime/Distributions/TruncatedPoisson.cs
+++ b/src/Runtime/Distributions/TruncatedPoisson.cs
@@ -628,7 +628,7 @@ namespace Microsoft.ML.Probabilistic.Distributions
             }
             else
             {
-                return string.Format("TruncPois:Rate={0:0.000},Prec={1:0.00},Start={2}, End={3}", this.Rate, this.Precision, this.StartPoint, this.EndPoint);
+                return $"TruncPois:Rate={this.Rate:0.000},Prec={this.Precision:0.00},Start={this.StartPoint}, End={this.EndPoint}";
             }
         }
 
diff --git a/src/Runtime/Factors/Factor.cs b/src/Runtime/Factors/Factor.cs
index b5d932b..4353fd0 100644
--- a/src/Runtime/Factors/Factor.cs
+++ b/src/Runtime/Factors/Factor.cs
@@ -1522,9 +1522,7 @@ namespace Microsoft.ML.Probabilistic.Factors
                 StringDistribution.String(format), args);
             if (result.IsZero())
             {
-                throw new ConstraintViolatedException(string.Format(
-                    "The format string \"{0}\" was ill-formatted or not consistent with the argument list.",
-                    format));
+                throw new ConstraintViolatedException($"The format string \"{format}\" was ill-formatted or not consistent with the argument list.");
             }
 
             Debug.Assert(result.IsPointMass, "Must be a point mass.");
diff --git a/src/Runtime/Factors/GammaFromShapeAndRate.cs b/src/Runtime/Factors/GammaFromShapeAndRate.cs
index 9fa8f03..424b2c6 100644
--- a/src/Runtime/Factors/GammaFromShapeAndRate.cs
+++ b/src/Runtime/Factors/GammaFromShapeAndRate.cs
@@ -897,7 +897,7 @@ namespace Microsoft.ML.Probabilistic.Factors
                 }
             }
             if (rmin > rmax)
-                throw new Exception(String.Format("Internal: rmin ({0}) > rmax ({1})", rmin, rmax));
+                throw new Exception($"Internal: rmin ({rmin}) > rmax ({rmax})");
             //Console.WriteLine("rmin = {0}, rmax = {1}", rmin, rmax);
         }
 
diff --git a/src/Runtime/Factors/GaussianOp.cs b/src/Runtime/Factors/GaussianOp.cs
index e869d17..d28d198 100644
--- a/src/Runtime/Factors/GaussianOp.cs
+++ b/src/Runtime/Factors/GaussianOp.cs
@@ -1626,7 +1626,7 @@ namespace Microsoft.ML.Probabilistic.Factors
                             else if (x > upperBound)
                                 zeroes.Add(upperBound);
                             else
-                                throw new Exception(string.Format("could not find a zero between {0} and {1}", lowerBound, upperBound));
+                                throw new Exception($"could not find a zero between {lowerBound} and {upperBound}");
                         }
                     }
                 }
diff --git a/src/Visualizers/Windows/GraphViews/TaskGraphView.cs b/src/Visualizers/Windows/GraphViews/TaskGraphView.cs
index 14e5530..fbd40b2 100644
--- a/src/Visualizers/Windows/GraphViews/TaskGraphView.cs
+++ b/src/Visualizers/Windows/GraphViews/TaskGraphView.cs
@@ -48,9 +48,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
                 if (!context.InputAttributes.Has<OperatorMethod>(imd)) continue;
                 foreach (IStatement ist in imd.Body.Statements)
                 {
-                    if (ist is IWhileStatement)
+                    if (ist is IWhileStatement iWhileStatement)
                     {
-                        looptasks.AddRange(((IWhileStatement) ist).Body.Statements);
+                        looptasks.AddRange(iWhileStatement.Body.Statements);
                         continue;
                     }
                     if (context.InputAttributes.Has<OperatorStatement>(ist)) pretasks.Add(ist);
@@ -150,11 +150,9 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
             //if (di.IsOutput) nd.Attr.Fillcolor = Color.LightBlue;
             nd.LabelText = s;
             if (stage == Stage.Initialisation) nd.Attr.FillColor = Color.LightGray;
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
-                IExpressionStatement ies = (IExpressionStatement) ist;
-                IAssignExpression iae = ies.Expression as IAssignExpression;
-                if ((iae != null) && (iae.Target is IVariableDeclarationExpression)) nd.Attr.LineWidth = 2;
+                if ((ies.Expression is IAssignExpression iae) && (iae.Target is IVariableDeclarationExpression)) nd.Attr.LineWidth = 2;
             }
             nd.Attr.Shape = Shape.Box;
             nd.Label.FontSize = 9;
@@ -185,9 +183,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
 
         protected string StatementLabel(IStatement ist)
         {
-            if (ist is IExpressionStatement)
+            if (ist is IExpressionStatement ies)
             {
-                IExpressionStatement ies = (IExpressionStatement) ist;
                 string s;
                 if (ies.Expression is IAssignExpression)
                 {
@@ -198,18 +195,17 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
                 //if (s.EndsWith("[0]")) s = s.Substring(0, s.Length - 3);
                 return s;
             }
-            if (ist is IForStatement)
+            if (ist is IForStatement iForStatement)
             {
-                return StatementLabel(((IForStatement) ist).Body.Statements[0]);
+                return StatementLabel(iForStatement.Body.Statements[0]);
             }
-            if (ist is IConditionStatement)
+            if (ist is IConditionStatement iConditionStatement)
             {
-                return String.Format("if ({0}) {1}", ((IConditionStatement) ist).Condition.ToString(),
-                                     StatementLabel(((IConditionStatement) ist).Then));
+                return $"if ({iConditionStatement.Condition.ToString()}) {StatementLabel(((IConditionStatement)ist).Then)}";
             }
-            if (ist is IBlockStatement)
+            if (ist is IBlockStatement iBlockStatement)
             {
-                int blockSize = ((IBlockStatement) ist).Statements.Count;
+                int blockSize = iBlockStatement.Statements.Count;
                 string s;
                 if (blockSize > 0)
                 {
diff --git a/src/Visualizers/Windows/TransformerChainView/CodeElementInspectorView.xaml.cs b/src/Visualizers/Windows/TransformerChainView/CodeElementInspectorView.xaml.cs
index 85d0c38..4c6a673 100644
--- a/src/Visualizers/Windows/TransformerChainView/CodeElementInspectorView.xaml.cs
+++ b/src/Visualizers/Windows/TransformerChainView/CodeElementInspectorView.xaml.cs
@@ -37,8 +37,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
         private void UserControl_DataContextChanged(object sender, DependencyPropertyChangedEventArgs e)
         {
             List<ICompilerAttribute> attrs = new List<ICompilerAttribute>();
-            if(DataContext is LineOfCode) 
-                ForEachAttributeOfCodeElementAndAncestors((LineOfCode)DataContext, attrs.Add);
+            if(DataContext is LineOfCode lineOfCode) 
+                ForEachAttributeOfCodeElementAndAncestors(lineOfCode, attrs.Add);
             // Ordered by name - good idea?
             AttributeListBox.ItemsSource = attrs.OrderBy(a=>a.GetType().Name);
         }
@@ -62,9 +62,8 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
                 action(attr);
             if (codeElement is IStatement)
             {
-                if (codeElement is IExpressionStatement)
+                if (codeElement is IExpressionStatement ies)
                 {
-                    IExpressionStatement ies = (IExpressionStatement)codeElement;
                     ForEachAttributeOfCodeElement(ies.Expression, action);
                     if (ies.Expression is IVariableDeclarationExpression)
                     {
@@ -83,17 +82,15 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
                         }
                     }
                 }
-                else if (codeElement is IForStatement)
+                else if (codeElement is IForStatement ifs)
                 {
-                    IForStatement ifs = (IForStatement)codeElement;
                     ForEachAttributeOfCodeElementAndContents(ifs.Initializer, action);
                     IBinaryExpression ibe = (IBinaryExpression)ifs.Condition;
                     ForEachAttributeOfCodeElementAndContents(ibe.Right, action);
                 }
             }
-            if (codeElement is IMethodDeclaration)
+            if (codeElement is IMethodDeclaration imd)
             {
-                IMethodDeclaration imd = (IMethodDeclaration)codeElement;
                 foreach (IParameterDeclaration ipd in imd.Parameters)
                 {
                     ForEachAttributeOfCodeElement(ipd, action);
diff --git a/src/Visualizers/Windows/TransformerChainView/DeclarationView.xaml.cs b/src/Visualizers/Windows/TransformerChainView/DeclarationView.xaml.cs
index 4a0d4f4..7236541 100644
--- a/src/Visualizers/Windows/TransformerChainView/DeclarationView.xaml.cs
+++ b/src/Visualizers/Windows/TransformerChainView/DeclarationView.xaml.cs
@@ -59,10 +59,10 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
             lines = new List<LineOfCode>();
             parentOfLine.Clear();
             SourceNode sourceNode;
-            if (DataContext is ITypeDeclaration)
-                sourceNode = languageWriter.GeneratePartialSource((ITypeDeclaration)DataContext);
-            else if (DataContext is IStatement)
-                sourceNode = languageWriter.GeneratePartialSource((IStatement)DataContext);
+            if (DataContext is ITypeDeclaration iTypeDeclaration)
+                sourceNode = languageWriter.GeneratePartialSource(iTypeDeclaration);
+            else if (DataContext is IStatement iStatement)
+                sourceNode = languageWriter.GeneratePartialSource(iStatement);
             else if (DataContext is Func<SourceNode>)
                 sourceNode = ((Func<SourceNode>)DataContext)();
             else
diff --git a/src/Visualizers/Windows/TransformerChainView/LineOfCodeView.xaml.cs b/src/Visualizers/Windows/TransformerChainView/LineOfCodeView.xaml.cs
index 0a2f272..599d5b8 100644
--- a/src/Visualizers/Windows/TransformerChainView/LineOfCodeView.xaml.cs
+++ b/src/Visualizers/Windows/TransformerChainView/LineOfCodeView.xaml.cs
@@ -34,17 +34,16 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
         {
             LineOfCode loc;
             MatchCollection matches = null;
-            if (DataContext is LineOfCode)
+            if (DataContext is LineOfCode lineOfCode)
             {
-                loc = (LineOfCode)DataContext;
+                loc = lineOfCode;
             }
-            else if (DataContext is FaintLine)
+            else if (DataContext is FaintLine faintLine)
             {
-                loc = ((FaintLine)DataContext).Line;
+                loc = faintLine.Line;
             }
-            else if (DataContext is MatchedLine)
+            else if (DataContext is MatchedLine ml)
             {
-                MatchedLine ml = (MatchedLine)DataContext;
                 loc = ml.Line;
                 matches = ml.Matches;
             }
diff --git a/src/Visualizers/Windows/TransformerChainView/TransformerView.xaml.cs b/src/Visualizers/Windows/TransformerChainView/TransformerView.xaml.cs
index 5dd0a19..7f3963a 100644
--- a/src/Visualizers/Windows/TransformerChainView/TransformerView.xaml.cs
+++ b/src/Visualizers/Windows/TransformerChainView/TransformerView.xaml.cs
@@ -41,12 +41,12 @@ namespace Microsoft.ML.Probabilistic.Compiler.Visualizers
                 return;
             var item = e.AddedItems[0];
             LineOfCode line;
-            if (item is LineOfCode)
-                line = (LineOfCode)item;
-            else if (item is FaintLine)
-                line = ((FaintLine)item).Line;
-            else if (item is MatchedLine)
-                line = ((MatchedLine)item).Line;
+            if (item is LineOfCode lineOfCode)
+                line = lineOfCode;
+            else if (item is FaintLine faintLine)
+                line = faintLine.Line;
+            else if (item is MatchedLine matchedLine)
+                line = matchedLine.Line;
             else
                 line = null;
             CodeElementInspector.DataContext = line;
diff --git a/test/Tests/BlogTests.cs b/test/Tests/BlogTests.cs
index f3f0cb3..eccdcad 100644
--- a/test/Tests/BlogTests.cs
+++ b/test/Tests/BlogTests.cs
@@ -783,7 +783,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
                     if (i > 3)
                         continue;
-                    Console.Out.WriteLine(string.Format("Account:{0} Grader:{1} Grade{2}", question[i], worker[i], responseV[i]));
+                    Console.Out.WriteLine($"Account:{question[i]} Grader:{worker[i]} Grade{responseV[i]}");
                 }
                 // because the number is starting from 0
                 nWorkerN++;
diff --git a/test/Tests/ChainTests.cs b/test/Tests/ChainTests.cs
index 942f884..2ea5e20 100644
--- a/test/Tests/ChainTests.cs
+++ b/test/Tests/ChainTests.cs
@@ -447,7 +447,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
                                 if (numDownUpsPerIteration > 1)
                                 {
-                                    displayScheduleName = String.Format("{0} {1} Up Downs/it", displayScheduleName, numDownUpsPerIteration);
+                                    displayScheduleName = $"{displayScheduleName} {numDownUpsPerIteration} Up Downs/it";
                                 }
                             }
 
@@ -479,7 +479,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
                                 if (numDownUpsPerIteration > 1)
                                 {
-                                    displayScheduleName = String.Format("{0} {1} Up Downs/it", displayScheduleName, numDownUpsPerIteration);
+                                    displayScheduleName = $"{displayScheduleName} {numDownUpsPerIteration} Up Downs/it";
                                 }
                             }
                             displayScheduleName += " (failed)";
@@ -1579,7 +1579,7 @@ namespace Microsoft.ML.Probabilistic.Tests
                     {
                         if (i % 2 == 0)
                         {
-                            pixels[i, j] = Variable.Discrete(new double[] { .51, .49 }).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Discrete(new double[] { .51, .49 }).Named($"x_{i}{j}");
                         }
                         else
                         {
@@ -1587,15 +1587,15 @@ namespace Microsoft.ML.Probabilistic.Tests
 
                         if ((i + j) % 3 == 0)
                         {
-                            pixels[i, j] = Variable.Discrete(new double[] { .1, .9 }).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Discrete(new double[] { .1, .9 }).Named($"x_{i}{j}");
                         }
                         else if ((i + j) % 3 == 1)
                         {
-                            pixels[i, j] = Variable.Discrete(new double[] { .6, .4 }).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Discrete(new double[] { .6, .4 }).Named($"x_{i}{j}");
                         }
                         else if ((i + j) % 3 == 2)
                         {
-                            pixels[i, j] = Variable.Discrete(new double[] { .8, .2 }).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Discrete(new double[] { .8, .2 }).Named($"x_{i}{j}");
                         }
                         else
                         {
@@ -1665,15 +1665,15 @@ namespace Microsoft.ML.Probabilistic.Tests
                     {
                         if ((i + j) % 3 == 0)
                         {
-                            pixels[i, j] = Variable.Bernoulli(.9).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Bernoulli(.9).Named($"x_{i}{j}");
                         }
                         else if ((i + j) % 3 == 1)
                         {
-                            pixels[i, j] = Variable.Bernoulli(.4).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Bernoulli(.4).Named($"x_{i}{j}");
                         }
                         else if ((i + j) % 3 == 2)
                         {
-                            pixels[i, j] = Variable.Bernoulli(.2).Named(String.Format("x_{0}{1}", i, j));
+                            pixels[i, j] = Variable.Bernoulli(.2).Named($"x_{i}{j}");
                         }
                         else
                         {
diff --git a/test/Tests/Core/PriorityQueueTest.cs b/test/Tests/Core/PriorityQueueTest.cs
index 73c0884..3d24764 100644
--- a/test/Tests/Core/PriorityQueueTest.cs
+++ b/test/Tests/Core/PriorityQueueTest.cs
@@ -28,7 +28,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
             public override string ToString()
             {
-                return String.Format("({0},{1})", Index, Value);
+                return $"({Index},{Value})";
             }
         }
 
diff --git a/test/Tests/Core/RandomTest.cs b/test/Tests/Core/RandomTest.cs
index 380e53a..b1504b8 100644
--- a/test/Tests/Core/RandomTest.cs
+++ b/test/Tests/Core/RandomTest.cs
@@ -48,7 +48,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             error = hist.MaxDiff(unif);
             if (error > TOLERANCE)
             {
-                Assert.True(false, String.Format("Uniform: error={0}", error));
+                Assert.True(false, $"Uniform: error={error}");
             }
 
             hist.SetAllElementsTo(0);
@@ -64,7 +64,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             error = hist.MaxDiff(p);
             if (error > TOLERANCE)
             {
-                Assert.True(false, String.Format("Sample([0.1,0.2,0.3,0.4]) error={0}", error));
+                Assert.True(false, $"Sample([0.1,0.2,0.3,0.4]) error={error}");
             }
 
             Rand.Restart(7);
@@ -90,14 +90,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = System.Math.Abs(m);
             if (dError > 4/ System.Math.Sqrt(nsamples))
             {
-                Assert.True(false, string.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             // the sample variance is Gamma(n/2,n/2) whose stddev = sqrt(2/n)
             dError = System.Math.Abs(v - 1.0);
             if (dError > 4* System.Math.Sqrt(2.0/ nsamples))
             {
-                Assert.True(false, string.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -133,14 +133,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = System.Math.Abs(m - meanExpected);
             if (dError > 4/ System.Math.Sqrt(nsamples))
             {
-                Assert.True(false, string.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             // the sample variance is Gamma(n/2,n/2) whose stddev = sqrt(2/n)
             dError = System.Math.Abs(v - varianceExpected);
             if (dError > 4* System.Math.Sqrt(2.0/ nsamples))
             {
-                Assert.True(false, string.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -173,14 +173,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = System.Math.Abs(m - meanExpected);
             if (dError > 4/ System.Math.Sqrt(nsamples))
             {
-                Assert.True(false, string.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             // the sample variance is Gamma(n/2,n/2) whose stddev = sqrt(2/n)
             dError = System.Math.Abs(v - varianceExpected);
             if (dError > 4* System.Math.Sqrt(2.0/ nsamples))
             {
-                Assert.True(false, string.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -209,13 +209,13 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = System.Math.Abs(m - a);
             if (dError > 4* System.Math.Sqrt(a / nsamples))
             {
-                Assert.True(false, string.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             dError = System.Math.Abs(v - a);
             if (dError > TOLERANCE)
             {
-                Assert.True(false, String.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -247,14 +247,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = m.MaxDiff(mt);
             if (dError > TOLERANCE)
             {
-                Assert.True(false, String.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             Console.WriteLine("v = \n{0}", v);
             dError = v.MaxDiff(vt);
             if (dError > TOLERANCE)
             {
-                Assert.True(false, String.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -287,14 +287,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             double dError = m.MaxDiff(mt);
             if (dError > TOLERANCE)
             {
-                Assert.True(false, String.Format("m: error = {0}", dError));
+                Assert.True(false, $"m: error = {dError}");
             }
 
             Console.WriteLine("v = \n{0}", v);
             dError = v.MaxDiff(vt);
             if (dError > TOLERANCE)
             {
-                Assert.True(false, String.Format("v: error = {0}", dError));
+                Assert.True(false, $"v: error = {dError}");
             }
         }
 
@@ -336,7 +336,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             }
             if (System.Math.Abs(s - sTrue) > TOLERANCE)
             {
-                Assert.True(false, string.Format("E[logdet]: {0} (should be {1})", s, sTrue));
+                Assert.True(false, $"E[logdet]: {s} (should be {sTrue})");
             }
         }
 
@@ -369,12 +369,12 @@ namespace Microsoft.ML.Probabilistic.Tests
             double error = MMath.AbsDiff(meanExpected, mean, 1e-6);
             if (error > System.Math.Sqrt(varianceExpected) *5)
             {
-                Assert.True(false, string.Format("Binomial({0},{1}) mean = {2} should be {3}, error = {4}", p, n, mean, meanExpected, error));
+                Assert.True(false, $"Binomial({p},{n}) mean = {mean} should be {meanExpected}, error = {error}");
             }
             error = MMath.AbsDiff(varianceExpected, variance, 1e-6);
             if (error > System.Math.Sqrt(varianceExpected) *5)
             {
-                Assert.True(false, string.Format("Binomial({0},{1}) variance = {2} should be {3}, error = {4}", p, n, variance, varianceExpected, error));
+                Assert.True(false, $"Binomial({p},{n}) variance = {variance} should be {varianceExpected}, error = {error}");
             }
         }
 
diff --git a/test/Tests/Core/SpecialFunctionsTest.cs b/test/Tests/Core/SpecialFunctionsTest.cs
index 1f59540..2a39c86 100644
--- a/test/Tests/Core/SpecialFunctionsTest.cs
+++ b/test/Tests/Core/SpecialFunctionsTest.cs
@@ -1419,7 +1419,7 @@ exp(x*x/4)*pcfu(0.5+n,-x)
                 result = -numer / denom;
                 Console.WriteLine("iter {0}: {1}", i, result.ToString("r"));
                 if (double.IsInfinity(result) || double.IsNaN(result))
-                    throw new Exception(string.Format("NormalCdfConFrac4 not converging for x={0} y={1} r={2}", x, y, r));
+                    throw new Exception($"NormalCdfConFrac4 not converging for x={x} y={y} r={r}");
                 if (result == rOld)
                     return result;
                 rOld = result;
@@ -1462,7 +1462,7 @@ exp(x*x/4)*pcfu(0.5+n,-x)
                     rprev = result;
                 }
             }
-            throw new Exception(string.Format("NormalCdfConFrac3 not converging for x={0} y={1} r={2}", x, y, r));
+            throw new Exception($"NormalCdfConFrac3 not converging for x={x} y={y} r={r}");
         }
 
 
@@ -1539,13 +1539,13 @@ exp(x*x/4)*pcfu(0.5+n,-x)
                     result = -numer / denom;
                     Console.WriteLine($"iter {i.ToString().PadLeft(3)}: {result.ToString("r").PadRight(24)} {numer.ToString("r").PadRight(24)} {denom.ToString("r").PadRight(24)} {c}");
                     if (double.IsInfinity(result) || double.IsNaN(result))
-                        throw new Exception(string.Format("NormalCdfRatioConFrac3 not converging for x={0} y={1} r={2} scale={3}", x, y, r, scale));
+                        throw new Exception($"NormalCdfRatioConFrac3 not converging for x={x} y={y} r={r} scale={scale}");
                     //if (result == rOld)
                     //    return result + offset;
                     rOld = result;
                 }
             }
-            throw new Exception(string.Format("NormalCdfRatioConFrac3 not converging for x={0} y={1} r={2} scale={3}", x, y, r, scale));
+            throw new Exception($"NormalCdfRatioConFrac3 not converging for x={x} y={y} r={r} scale={scale}");
         }
 
         /// <summary>
diff --git a/test/Tests/Dynamic/TypeInference.cs b/test/Tests/Dynamic/TypeInference.cs
index a0c6753..327df9e 100644
--- a/test/Tests/Dynamic/TypeInference.cs
+++ b/test/Tests/Dynamic/TypeInference.cs
@@ -523,7 +523,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             if (count < minTrueCount)
             {
                 if (lastError.Count > 0) throw lastError[0];
-                else throw new Exception(String.Format("Only got {0} matches instead of {1}", count, minTrueCount));
+                else throw new Exception($"Only got {count} matches instead of {minTrueCount}");
             }
             if (minTrueCount >= 0) Assert.True(count >= minTrueCount); // count may be greater on newer runtimes
             if (minTrueCount == 0)
diff --git a/test/Tests/InferTests.cs b/test/Tests/InferTests.cs
index 8444eb7..5f2f2bb 100644
--- a/test/Tests/InferTests.cs
+++ b/test/Tests/InferTests.cs
@@ -1898,7 +1898,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             engine.ProgressChanged += delegate (InferenceEngine sender, InferenceProgressEventArgs e)
                 {
                     if (e.Iteration != iterationExpected)
-                        Assert.True(false, String.Format("Wrong iteration number: {0} should be {1}", e.Iteration, iterationExpected));
+                        Assert.True(false, $"Wrong iteration number: {e.Iteration} should be {iterationExpected}");
                     iterationExpected++;
                 };
             double[] data = new double[] { 1, 2 };
@@ -1930,7 +1930,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             engine.ProgressChanged += delegate (InferenceEngine sender, InferenceProgressEventArgs e)
                 {
                     if (e.Iteration != iterationExpected)
-                        Assert.True(false, String.Format("Wrong iteration number: {0} should be {1}", e.Iteration, iterationExpected));
+                        Assert.True(false, $"Wrong iteration number: {e.Iteration} should be {iterationExpected}");
                     iterationExpected++;
                 };
             m.ObservedValue = 10;
@@ -1956,7 +1956,7 @@ namespace Microsoft.ML.Probabilistic.Tests
             gen.ProgressChanged += delegate (object sender, ProgressChangedEventArgs e)
                 {
                     if (e.Iteration != iterationExpected)
-                        Assert.True(false, String.Format("Wrong iteration number: {0} should be {1}", e.Iteration, iterationExpected));
+                        Assert.True(false, $"Wrong iteration number: {e.Iteration} should be {iterationExpected}");
                     iterationExpected++;
                 };
             gen.SetObservedValue(m.NameInGeneratedCode, 10.0);
diff --git a/test/Tests/LDATests.cs b/test/Tests/LDATests.cs
index c230840..1f2dacb 100644
--- a/test/Tests/LDATests.cs
+++ b/test/Tests/LDATests.cs
@@ -320,9 +320,9 @@ namespace Microsoft.ML.Probabilistic.Tests
 
         public static double SparsityFraction(object obj)
         {
-            if (obj is Vector) return SparsityFraction((Vector) obj);
-            else if (obj is Dirichlet) return SparsityFraction(((Dirichlet) obj).PseudoCount);
-            else if (obj is Discrete) return SparsityFraction(((Discrete) obj).GetProbs());
+            if (obj is Vector vector) return SparsityFraction(vector);
+            else if (obj is Dirichlet dirichlet) return SparsityFraction(dirichlet.PseudoCount);
+            else if (obj is Discrete discrete) return SparsityFraction(discrete.GetProbs());
             else
             {
                 Type type = obj.GetType();
@@ -348,9 +348,8 @@ namespace Microsoft.ML.Probabilistic.Tests
 
         public static double SparsityFraction(Vector vector)
         {
-            if (vector is SparseVector)
+            if (vector is SparseVector sv)
             {
-                SparseVector sv = (SparseVector) vector;
                 return (double) sv.SparseValues.Count/sv.Count;
             }
             else return 1.0;
diff --git a/test/Tests/MaxProductTests.cs b/test/Tests/MaxProductTests.cs
index bd78742..e538f1b 100644
--- a/test/Tests/MaxProductTests.cs
+++ b/test/Tests/MaxProductTests.cs
@@ -50,15 +50,15 @@ namespace Microsoft.ML.Probabilistic.Tests
                 {
                     if ((i + j)%3 == 0)
                     {
-                        pixels[i, j] = Variable.Bernoulli(.8).Named(String.Format("x_{0}{1}", i, j));
+                        pixels[i, j] = Variable.Bernoulli(.8).Named($"x_{i}{j}");
                     }
                     else if ((i + j)%3 == 1)
                     {
-                        pixels[i, j] = Variable.Bernoulli(.1).Named(String.Format("x_{0}{1}", i, j));
+                        pixels[i, j] = Variable.Bernoulli(.1).Named($"x_{i}{j}");
                     }
                     else if ((i + j)%3 == 2)
                     {
-                        pixels[i, j] = Variable.Bernoulli(.4).Named(String.Format("x_{0}{1}", i, j));
+                        pixels[i, j] = Variable.Bernoulli(.4).Named($"x_{i}{j}");
                     }
                     else
                     {
@@ -108,7 +108,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
             for (int i = 0; i < N; i++)
             {
-                x[i] = Variable.New<bool>().Named(String.Format("x{0}", i));
+                x[i] = Variable.New<bool>().Named($"x{i}");
                 if (i <= 1)
                 {
                     x[i].SetTo(Variable.Bernoulli(.5));
@@ -155,7 +155,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
             for (int i = 0; i < N; i++)
             {
-                x[i] = Variable.New<double>().Named(String.Format("x{0}", i));
+                x[i] = Variable.New<double>().Named($"x{i}");
                 if (i <= 1)
                 {
                     x[i].SetTo(Variable.GaussianFromMeanAndPrecision(0, 1));
diff --git a/test/Tests/MixtureTests.cs b/test/Tests/MixtureTests.cs
index 862b972..5d1a7a9 100644
--- a/test/Tests/MixtureTests.cs
+++ b/test/Tests/MixtureTests.cs
@@ -449,7 +449,7 @@ namespace Microsoft.ML.Probabilistic.Tests
                 {
                     double mActual = pPost[i, j].GetMean();
                     double mExpected = mean[i, j];
-                    Console.WriteLine(String.Format("pPost[{0}][{1}] = {2} should be {3}", i, j, mActual, mExpected));
+                    Console.WriteLine($"pPost[{i}][{j}] = {mActual} should be {mExpected}");
                     Assert.True(MMath.AbsDiff(mExpected, mActual, 1e-6) < 0.3);
                 }
             }
diff --git a/test/Tests/SharedVariableTests.cs b/test/Tests/SharedVariableTests.cs
index 04e42ca..068b634 100644
--- a/test/Tests/SharedVariableTests.cs
+++ b/test/Tests/SharedVariableTests.cs
@@ -928,14 +928,14 @@ namespace Microsoft.ML.Probabilistic.Tests
             Gamma precPrior = Gamma.FromShapeAndRate(.1, .1);
             Gaussian expectedMeanPost;
             Gamma expectedPrecPost;
-            Console.WriteLine(String.Format("\nNo shared variables ({0})", engine2.Algorithm.Name));
+            Console.WriteLine($"\nNo shared variables ({engine2.Algorithm.Name})");
             var expectedEvidence = EstimateGaussianMeanAndPrec(engine2,
                                                                dataSets[0], meanPrior, precPrior, out expectedMeanPost, out expectedPrecPost);
-            Console.WriteLine(String.Format("\n1 chunk ({0}/{1})", engine1.Algorithm.Name, engine2.Algorithm.Name));
+            Console.WriteLine($"\n1 chunk ({engine1.Algorithm.Name}/{engine2.Algorithm.Name})");
             EstimateGaussianSharedDefinition(engine1, engine2, dataSets,
                                              meanPrior, precPrior, expectedEvidence, expectedMeanPost, expectedPrecPost, divideMessages);
             dataSets = new double[][] {new double[] {5, 5.1, 5.2, 4.9}, new double[] {-5.1, -5.2, -5.3, -4.9}};
-            Console.WriteLine(String.Format("\n2 chunks ({0}/{1})", engine1.Algorithm.Name, engine2.Algorithm.Name));
+            Console.WriteLine($"\n2 chunks ({engine1.Algorithm.Name}/{engine2.Algorithm.Name})");
             EstimateGaussianSharedDefinition(engine1, engine2, dataSets,
                                              meanPrior, precPrior, expectedEvidence, expectedMeanPost, expectedPrecPost, divideMessages);
         }
diff --git a/test/Tests/SpeedTests.cs b/test/Tests/SpeedTests.cs
index 0c0512c..4f21222 100644
--- a/test/Tests/SpeedTests.cs
+++ b/test/Tests/SpeedTests.cs
@@ -155,21 +155,18 @@ namespace Microsoft.ML.Probabilistic.Tests
         {
             foreach (var stmt in methodDeclaration.Body.Statements)
             {
-                var exprStmt = stmt as IExpressionStatement;
-                if (exprStmt != null)
+                if (stmt is IExpressionStatement exprStmt)
                 {
                     IExpression expr = exprStmt.Expression;
-                    if (expr is IAssignExpression)
+                    if (expr is IAssignExpression iAssignExpression)
                     {
-                        expr = ((IAssignExpression) expr).Expression;
+                        expr = iAssignExpression.Expression;
                     }
-                    if (expr is IMethodInvokeExpression)
+                    if (expr is IMethodInvokeExpression invoke)
                     {
-                        var invoke = (IMethodInvokeExpression) expr;
                         if (invoke.Arguments.Count > 1)
                         {
-                            var arg = invoke.Arguments[0] as IDelegateCreateExpression;
-                            if (arg != null)
+                            if (invoke.Arguments[0] is IDelegateCreateExpression arg)
                             {
                                 yield return (MethodInfo)arg.Method.MethodInfo;
                             }
diff --git a/test/Tests/TestUtils.cs b/test/Tests/TestUtils.cs
index 8098f6d..28d6c46 100644
--- a/test/Tests/TestUtils.cs
+++ b/test/Tests/TestUtils.cs
@@ -115,7 +115,7 @@ namespace Microsoft.ML.Probabilistic.Tests
                         }
                         ict = (ICodeTransform)ctor.Invoke(args);
                     }
-                    if (ict.Name != type.Name) throw new Exception(String.Format("{0} has Name=\"{1}\"", type.Name, ict.Name));
+                    if (ict.Name != type.Name) throw new Exception($"{type.Name} has Name=\"{ict.Name}\"");
                 }
             }
         }
@@ -260,7 +260,7 @@ namespace Microsoft.ML.Probabilistic.Tests
                     Console.WriteLine("\t{0}", t.Item1);
                 }
             }
-            return failed.Count();
+            return failed.Count;
         }
 
         private class TestRunner : MarshalByRefObject
@@ -315,7 +315,7 @@ namespace Microsoft.ML.Probabilistic.Tests
                         foreach (var optimise in new[] { true, false })
                         {
                             InferenceEngine.DefaultEngine.Compiler.OptimiseInferenceCode = optimise;
-                            var state = string.Format("UseParallelForLoops={0} FreeMemory={1} ReturnCopies={2} OptimiseInferenceCode={3}", loops, free, copies, optimise);
+                            var state = $"UseParallelForLoops={loops} FreeMemory={free} ReturnCopies={copies} OptimiseInferenceCode={optimise}";
                             output.AddRange(operation(state));
                         }
                     }
@@ -901,7 +901,7 @@ namespace Microsoft.ML.Probabilistic.Tests
 
         public override string ToString()
         {
-            return String.Format("InliningFailed: {0}.{1} in {2}.{3} ({4})", InlineeNamespace, InlineeName, InlinerNamespace, InlinerName, Reason);
+            return $"InliningFailed: {InlineeNamespace}.{InlineeName} in {InlinerNamespace}.{InlinerName} ({Reason})";
         }
     }
 
