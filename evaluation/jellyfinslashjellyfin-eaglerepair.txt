Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: MediaBrowser.Controller
    #1 Path: D:\a\1\s\MediaBrowser.Controller\Drawing\ImageStream.cs, Line: 25, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #2 Path: D:\a\1\s\MediaBrowser.Controller\Entities\BaseItemExtensions.cs, Line: 90, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #3 Path: D:\a\1\s\MediaBrowser.Controller\Entities\CollectionFolder.cs, Line: 360, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Folder.cs, Line: 1642, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Folder.cs, Line: 451, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Folder.cs, Line: 483, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Folder.cs, Line: 497, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Movies\BoxSet.cs, Line: 221, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\MediaBrowser.Controller\Entities\TV\Series.cs, Line: 325, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\MediaBrowser.Controller\Entities\UserView.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\MediaBrowser.Controller\Entities\UserViewBuilder.cs, Line: 754, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\MediaBrowser.Controller\Entities\UserViewBuilder.cs, Line: 979, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\MediaBrowser.Controller\Entities\UserViewBuilder.cs, Line: 988, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\MediaBrowser.Controller\Entities\Video.cs, Line: 519, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: MediaBrowser.Model
    #15 Path: D:\a\1\s\MediaBrowser.Model\Dlna\StreamBuilder.cs, Line: 300, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: MediaBrowser.Providers
    #16 Path: D:\a\1\s\MediaBrowser.Providers\Manager\ImageSaver.cs, Line: 371, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\MediaBrowser.Providers\Manager\ImageSaver.cs, Line: 394, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\MediaBrowser.Providers\Manager\ImageSaver.cs, Line: 533, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\MediaBrowser.Providers\Manager\ImageSaver.cs, Line: 576, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\MediaBrowser.Providers\Manager\ItemImageProvider.cs, Line: 415, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\MediaBrowser.Providers\Manager\MetadataService.cs, Line: 333, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\MediaBrowser.Providers\Manager\MetadataService.cs, Line: 388, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\MediaBrowser.Providers\Manager\MetadataService.cs, Line: 415, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\MediaBrowser.Providers\Manager\MetadataService.cs, Line: 629, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\MediaBrowser.Providers\MediaInfo\AudioImageProvider.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\MediaBrowser.Providers\MediaInfo\SubtitleDownloader.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\MediaBrowser.Providers\MediaInfo\VideoImageProvider.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\AudioDb\AlbumImageProvider.cs, Line: 64, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #29 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\AudioDb\AlbumProvider.cs, Line: 71, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #30 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\AudioDb\ArtistImageProvider.cs, Line: 66, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #31 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\AudioDb\ArtistProvider.cs, Line: 72, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #32 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\Omdb\OmdbItemProvider.cs, Line: 146, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #33 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\Omdb\OmdbItemProvider.cs, Line: 170, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\Omdb\OmdbItemProvider.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\MediaBrowser.Providers\Plugins\Omdb\OmdbProvider.cs, Line: 530, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: MediaBrowser.XbmcMetadata
    #36 Path: D:\a\1\s\MediaBrowser.XbmcMetadata\Parsers\BaseNfoParser.cs, Line: 642, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\MediaBrowser.XbmcMetadata\Parsers\BaseNfoParser.cs, Line: 921, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: MediaBrowser.LocalMetadata
    #38 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Images\LocalImageProvider.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Parsers\BaseItemXmlParser.cs, Line: 472, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Savers\BaseXmlSaver.cs, Line: 300, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Savers\BaseXmlSaver.cs, Line: 316, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #42 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Savers\BaseXmlSaver.cs, Line: 424, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Savers\BaseXmlSaver.cs, Line: 430, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\MediaBrowser.LocalMetadata\Savers\BaseXmlSaver.cs, Line: 436, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: DvdLib
    #45 Path: D:\a\1\s\DvdLib\Ifo\Dvd.cs, Line: 157, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #46 Path: D:\a\1\s\DvdLib\Ifo\Dvd.cs, Line: 79, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Emby.Server.Implementations
    #47 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 1742, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 1873, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 3983, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #50 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4004, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #51 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4025, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #52 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4046, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #53 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4067, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #54 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4088, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #55 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4107, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #56 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4126, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #57 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4145, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #58 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4167, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #59 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4186, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #60 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4201, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #61 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4210, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #62 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4267, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #63 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4276, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #64 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4285, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #65 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4294, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #66 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4347, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #67 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4363, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #68 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4397, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #69 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4417, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #70 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4436, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #71 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4461, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #72 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4504, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #73 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4545, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #74 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4560, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #75 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4572, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #76 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4592, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #77 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4608, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #78 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4618, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #79 Path: D:\a\1\s\Emby.Server.Implementations\Data\SqliteItemRepository.cs, Line: 4627, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #80 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 1046, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 1087, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 751, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 914, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 921, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\Emby.Server.Implementations\Dto\DtoService.cs, Line: 995, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\Emby.Server.Implementations\Images\PlaylistImageProvider.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\Emby.Server.Implementations\Library\LibraryManager.cs, Line: 1703, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\Emby.Server.Implementations\Library\LibraryManager.cs, Line: 2761, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\Emby.Server.Implementations\Library\LibraryManager.cs, Line: 767, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #90 Path: D:\a\1\s\Emby.Server.Implementations\Library\MediaSourceManager.cs, Line: 590, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\Emby.Server.Implementations\Library\MusicManager.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\Emby.Server.Implementations\ScheduledTasks\ScheduledTaskWorker.cs, Line: 353, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\Emby.Server.Implementations\ScheduledTasks\Triggers\DailyTrigger.cs, Line: 71, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #94 Path: D:\a\1\s\Emby.Server.Implementations\ScheduledTasks\Triggers\IntervalTrigger.cs, Line: 90, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #95 Path: D:\a\1\s\Emby.Server.Implementations\ScheduledTasks\Triggers\WeeklyTrigger.cs, Line: 97, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #96 Path: D:\a\1\s\Emby.Server.Implementations\TV\TVSeriesManager.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\Emby.Server.Implementations\TV\TVSeriesManager.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: RSSDP
    #98 Path: D:\a\1\s\RSSDP\HttpRequestParser.cs, Line: 36, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #99 Path: D:\a\1\s\RSSDP\HttpResponseParser.cs, Line: 36, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #100 Path: D:\a\1\s\RSSDP\SsdpDevice.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #101 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 236, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 343, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #103 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 366, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 500, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 525, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 545, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 561, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #108 Path: D:\a\1\s\RSSDP\SsdpDevicePublisher.cs, Line: 608, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: MediaBrowser.MediaEncoding
    #109 Path: D:\a\1\s\MediaBrowser.MediaEncoding\BdInfo\BdInfoExaminer.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\MediaBrowser.MediaEncoding\BdInfo\BdInfoExaminer.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\MediaBrowser.MediaEncoding\BdInfo\BdInfoExaminer.cs, Line: 82, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #112 Path: D:\a\1\s\MediaBrowser.MediaEncoding\BdInfo\BdInfoExaminer.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\MediaBrowser.MediaEncoding\Probing\ProbeResultNormalizer.cs, Line: 1019, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #114 Path: D:\a\1\s\MediaBrowser.MediaEncoding\Probing\ProbeResultNormalizer.cs, Line: 1034, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #115 Path: D:\a\1\s\MediaBrowser.MediaEncoding\Probing\ProbeResultNormalizer.cs, Line: 1048, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #116 Path: D:\a\1\s\MediaBrowser.MediaEncoding\Probing\ProbeResultNormalizer.cs, Line: 84, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



--- Rules Summary ---
R8: 57
R7: 40
R2: 10
R9: 8
R6: 1

--- Summary ---
Fixed ReSharper issues: 106
Fixed SonarQube issues: 1
Total fixed issues: 116

Finished in: 31 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MediaBrowser.Controller\Entities\BaseItem.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Jellyfin.Data.Entities;
using Jellyfin.Data.Enums;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Controller.Channels;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Dto;
using MediaBrowser.Controller.Extensions;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Persistence;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.IO;
using MediaBrowser.Model.Library;
using MediaBrowser.Model.LiveTv;
using MediaBrowser.Model.MediaInfo;
using MediaBrowser.Model.Providers;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.Controller.Entities
{
    /// <summary>
    /// Class BaseItem.
    /// </summary>
    public abstract class BaseItem : IHasProviderIds, IHasLookupInfo<ItemLookupInfo>, IEquatable<BaseItem>
    {
        /// <summary>
        /// The supported image extensions.
        /// </summary>
        public static readonly string[] SupportedImageExtensions
            = new[] { ".png", ".jpg", ".jpeg", ".tbn", ".gif" };

        private static readonly List<string> _supportedExtensions = new List<string>(SupportedImageExtensions)
        {
            ".nfo",
            ".xml",
            ".srt",
            ".vtt",
            ".sub",
            ".idx",
            ".txt",
            ".edl",
            ".bif",
            ".smi",
            ".ttml"
        };

        protected BaseItem()
        {
            Tags = Array.Empty<string>();
            Genres = Array.Empty<string>();
            Studios = Array.Empty<string>();
            ProviderIds = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            LockedFields = Array.Empty<MetadataField>();
            ImageInfos = Array.Empty<ItemImageInfo>();
            ProductionLocations = Array.Empty<string>();
            RemoteTrailers = Array.Empty<MediaUrl>();
            ExtraIds = Array.Empty<Guid>();
        }

        public static readonly char[] SlugReplaceChars = { '?', '/', '&' };
        public static char SlugChar = '-';

        /// <summary>
        /// The trailer folder name.
        /// </summary>
        public const string TrailerFolderName = "trailers";
        public const string ThemeSongsFolderName = "theme-music";
        public const string ThemeSongFilename = "theme";
        public const string ThemeVideosFolderName = "backdrops";
        public const string ExtrasFolderName = "extras";
        public const string BehindTheScenesFolderName = "behind the scenes";
        public const string DeletedScenesFolderName = "deleted scenes";
        public const string InterviewFolderName = "interviews";
        public const string SceneFolderName = "scenes";
        public const string SampleFolderName = "samples";
        public const string ShortsFolderName = "shorts";
        public const string FeaturettesFolderName = "featurettes";

        public static readonly string[] AllExtrasTypesFolderNames = {
            ExtrasFolderName,
            BehindTheScenesFolderName,
            DeletedScenesFolderName,
            InterviewFolderName,
            SceneFolderName,
            SampleFolderName,
            ShortsFolderName,
            FeaturettesFolderName
        };

        [JsonIgnore]
        public Guid[] ThemeSongIds
        {
            get
            {
                if (_themeSongIds == null)
                {
                    _themeSongIds = GetExtras()
                        .Where(extra => extra.ExtraType == Model.Entities.ExtraType.ThemeSong)
                        .Select(song => song.Id)
                        .ToArray();
                }

                return _themeSongIds;
            }

            private set
            {
                _themeSongIds = value;
            }
        }

        [JsonIgnore]
        public Guid[] ThemeVideoIds
        {
            get
            {
                if (_themeVideoIds == null)
                {
                    _themeVideoIds = GetExtras()
                        .Where(extra => extra.ExtraType == Model.Entities.ExtraType.ThemeVideo)
                        .Select(song => song.Id)
                        .ToArray();
                }

                return _themeVideoIds;
            }

            private set
            {
                _themeVideoIds = value;
            }
        }

        [JsonIgnore]
        public string PreferredMetadataCountryCode { get; set; }

        [JsonIgnore]
        public string PreferredMetadataLanguage { get; set; }

        public long? Size { get; set; }

        public string Container { get; set; }

        [JsonIgnore]
        public string Tagline { get; set; }

        [JsonIgnore]
        public virtual ItemImageInfo[] ImageInfos { get; set; }

        [JsonIgnore]
        public bool IsVirtualItem { get; set; }

        /// <summary>
        /// Gets or sets the album.
        /// </summary>
        /// <value>The album.</value>
        [JsonIgnore]
        public string Album { get; set; }

        /// <summary>
        /// Gets or sets the channel identifier.
        /// </summary>
        /// <value>The channel identifier.</value>
        [JsonIgnore]
        public Guid ChannelId { get; set; }

        [JsonIgnore]
        public virtual bool SupportsAddingToPlaylist => false;

        [JsonIgnore]
        public virtual bool AlwaysScanInternalMetadataPath => false;

        /// <summary>
        /// Gets a value indicating whether this instance is in mixed folder.
        /// </summary>
        /// <value><c>true</c> if this instance is in mixed folder; otherwise, <c>false</c>.</value>
        [JsonIgnore]
        public bool IsInMixedFolder { get; set; }

        [JsonIgnore]
        public virtual bool SupportsPlayedStatus => false;

        [JsonIgnore]
        public virtual bool SupportsPositionTicksResume => false;

        [JsonIgnore]
        public virtual bool SupportsRemoteImageDownloading => true;

        private string _name;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        [JsonIgnore]
        public virtual string Name
        {
            get => _name;
            set
            {
                _name = value;

                // lazy load this again
                _sortName = null;
            }
        }

        [JsonIgnore]
        public bool IsUnaired => PremiereDate.HasValue && PremiereDate.Value.ToLocalTime().Date >= DateTime.Now.Date;

        [JsonIgnore]
        public int? TotalBitrate { get; set; }

        [JsonIgnore]
        public ExtraType? ExtraType { get; set; }

        [JsonIgnore]
        public bool IsThemeMedia => ExtraType.HasValue && (ExtraType.Value == Model.Entities.ExtraType.ThemeSong || ExtraType.Value == Model.Entities.ExtraType.ThemeVideo);

        [JsonIgnore]
        public string OriginalTitle { get; set; }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        /// <value>The id.</value>
        [JsonIgnore]
        public Guid Id { get; set; }

        [JsonIgnore]
        public Guid OwnerId { get; set; }

        /// <summary>
        /// Gets or sets the audio.
        /// </summary>
        /// <value>The audio.</value>
        [JsonIgnore]
        public ProgramAudio? Audio { get; set; }

        /// <summary>
        /// Return the id that should be used to key display prefs for this item.
        /// Default is based on the type for everything except actual generic folders.
        /// </summary>
        /// <value>The display prefs id.</value>
        [JsonIgnore]
        public virtual Guid DisplayPreferencesId
        {
            get
            {
                var thisType = GetType();
                return thisType == typeof(Folder) ? Id : thisType.FullName.GetMD5();
            }
        }

        /// <summary>
        /// Gets or sets the path.
        /// </summary>
        /// <value>The path.</value>
        [JsonIgnore]
        public virtual string Path { get; set; }

        [JsonIgnore]
        public virtual SourceType SourceType
        {
            get
            {
                if (!ChannelId.Equals(Guid.Empty))
                {
                    return SourceType.Channel;
                }

                return SourceType.Library;
            }
        }

        /// <summary>
        /// Returns the folder containing the item.
        /// If the item is a folder, it returns the folder itself.
        /// </summary>
        [JsonIgnore]
        public virtual string ContainingFolderPath
        {
            get
            {
                if (IsFolder)
                {
                    return Path;
                }

                return System.IO.Path.GetDirectoryName(Path);
            }
        }

        /// <summary>
        /// Gets or sets the name of the service.
        /// </summary>
        /// <value>The name of the service.</value>
        [JsonIgnore]
        public string ServiceName { get; set; }

        /// <summary>
        /// If this content came from an external service, the id of the content on that service.
        /// </summary>
        [JsonIgnore]
        public string ExternalId { get; set; }

        [JsonIgnore]
        public string ExternalSeriesId { get; set; }

        /// <summary>
        /// Gets or sets the etag.
        /// </summary>
        /// <value>The etag.</value>
        [JsonIgnore]
        public string ExternalEtag { get; set; }

        [JsonIgnore]
        public virtual bool IsHidden => false;

        public BaseItem GetOwner()
        {
            var ownerId = OwnerId;
            return ownerId.Equals(Guid.Empty) ? null : LibraryManager.GetItemById(ownerId);
        }

        /// <summary>
        /// Gets or sets the type of the location.
        /// </summary>
        /// <value>The type of the location.</value>
        [JsonIgnore]
        public virtual LocationType LocationType
        {
            get
            {
                // if (IsOffline)
                //{
                //    return LocationType.Offline;
                //}

                var path = Path;
                if (string.IsNullOrEmpty(path))
                {
                    if (SourceType == SourceType.Channel)
                    {
                        return LocationType.Remote;
                    }

                    return LocationType.Virtual;
                }

                return FileSystem.IsPathFile(path) ? LocationType.FileSystem : LocationType.Remote;
            }
        }

        [JsonIgnore]
        public MediaProtocol? PathProtocol
        {
            get
            {
                var path = Path;

                if (string.IsNullOrEmpty(path))
                {
                    return null;
                }

                return MediaSourceManager.GetPathProtocol(path);
            }
        }

        public bool IsPathProtocol(MediaProtocol protocol)
        {
            var current = PathProtocol;

            return current.HasValue && current.Value == protocol;
        }

        [JsonIgnore]
        public bool IsFileProtocol => IsPathProtocol(MediaProtocol.File);

        [JsonIgnore]
        public bool HasPathProtocol => PathProtocol.HasValue;

        [JsonIgnore]
        public virtual bool SupportsLocalMetadata
        {
            get
            {
                if (SourceType == SourceType.Channel)
                {
                    return false;
                }

                return IsFileProtocol;
            }
        }

        [JsonIgnore]
        public virtual string FileNameWithoutExtension
        {
            get
            {
                if (IsFileProtocol)
                {
                    return System.IO.Path.GetFileNameWithoutExtension(Path);
                }

                return null;
            }
        }

        [JsonIgnore]
        public virtual bool EnableAlphaNumericSorting => true;

        private List<Tuple<StringBuilder, bool>> GetSortChunks(string s1)
        {
            var list = new List<Tuple<StringBuilder, bool>>();

            int thisMarker = 0;

            while (thisMarker < s1.Length)
            {
                char thisCh = s1[thisMarker];

                var thisChunk = new StringBuilder();
                bool isNumeric = char.IsDigit(thisCh);

                while (thisMarker < s1.Length && char.IsDigit(thisCh) == isNumeric)
                {
                    thisChunk.Append(thisCh);
                    thisMarker++;

                    if (thisMarker < s1.Length)
                    {
                        thisCh = s1[thisMarker];
                    }
                }

                list.Add(new Tuple<StringBuilder, bool>(thisChunk, isNumeric));
            }

            return list;
        }

        /// <summary>
        /// This is just a helper for convenience.
        /// </summary>
        /// <value>The primary image path.</value>
        [JsonIgnore]
        public string PrimaryImagePath => this.GetImagePath(ImageType.Primary);

        public virtual bool CanDelete()
        {
            if (SourceType == SourceType.Channel)
            {
                return ChannelManager.CanDelete(this);
            }

            return IsFileProtocol;
        }

        public virtual bool IsAuthorizedToDelete(User user, List<Folder> allCollectionFolders)
        {
            if (user.HasPermission(PermissionKind.EnableContentDeletion))
            {
                return true;
            }

            var allowed = user.GetPreferenceValues<Guid>(PreferenceKind.EnableContentDeletionFromFolders);

            if (SourceType == SourceType.Channel)
            {
                return allowed.Contains(ChannelId);
            }
            else
            {
                var collectionFolders = LibraryManager.GetCollectionFolders(this, allCollectionFolders);

                foreach (var folder in collectionFolders)
                {
                    if (allowed.Contains(folder.Id))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public bool CanDelete(User user, List<Folder> allCollectionFolders)
        {
            return CanDelete() && IsAuthorizedToDelete(user, allCollectionFolders);
        }

        public bool CanDelete(User user)
        {
            var allCollectionFolders = LibraryManager.GetUserRootFolder().Children.OfType<Folder>().ToList();

            return CanDelete(user, allCollectionFolders);
        }

        public virtual bool CanDownload()
        {
            return false;
        }

        public virtual bool IsAuthorizedToDownload(User user)
        {
            return user.HasPermission(PermissionKind.EnableContentDownloading);
        }

        public bool CanDownload(User user)
        {
            return CanDownload() && IsAuthorizedToDownload(user);
        }

        /// <summary>
        /// Gets or sets the date created.
        /// </summary>
        /// <value>The date created.</value>
        [JsonIgnore]
        public DateTime DateCreated { get; set; }

        /// <summary>
        /// Gets or sets the date modified.
        /// </summary>
        /// <value>The date modified.</value>
        [JsonIgnore]
        public DateTime DateModified { get; set; }

        public DateTime DateLastSaved { get; set; }

        [JsonIgnore]
        public DateTime DateLastRefreshed { get; set; }

        /// <summary>
        /// The logger.
        /// </summary>
        public static ILogger<BaseItem> Logger { get; set; }

        public static ILibraryManager LibraryManager { get; set; }

        public static IServerConfigurationManager ConfigurationManager { get; set; }

        public static IProviderManager ProviderManager { get; set; }

        public static ILocalizationManager LocalizationManager { get; set; }

        public static IItemRepository ItemRepository { get; set; }

        public static IFileSystem FileSystem { get; set; }

        public static IUserDataManager UserDataManager { get; set; }

        public static IChannelManager ChannelManager { get; set; }

        public static IMediaSourceManager MediaSourceManager { get; set; }

        /// <summary>
        /// Returns a <see cref="string" /> that represents this instance.
        /// </summary>
        /// <returns>A <see cref="string" /> that represents this instance.</returns>
        public override string ToString()
        {
            return Name;
        }

        [JsonIgnore]
        public bool IsLocked { get; set; }

        /// <summary>
        /// Gets or sets the locked fields.
        /// </summary>
        /// <value>The locked fields.</value>
        [JsonIgnore]
        public MetadataField[] LockedFields { get; set; }

        /// <summary>
        /// Gets the type of the media.
        /// </summary>
        /// <value>The type of the media.</value>
        [JsonIgnore]
        public virtual string MediaType => null;

        [JsonIgnore]
        public virtual string[] PhysicalLocations
        {
            get
            {
                if (!IsFileProtocol)
                {
                    return Array.Empty<string>();
                }

                return new[] { Path };
            }
        }

        private string _forcedSortName;

        /// <summary>
        /// Gets or sets the name of the forced sort.
        /// </summary>
        /// <value>The name of the forced sort.</value>
        [JsonIgnore]
        public string ForcedSortName
        {
            get => _forcedSortName;
            set { _forcedSortName = value; _sortName = null; }
        }

        private string _sortName;
        private Guid[] _themeSongIds;
        private Guid[] _themeVideoIds;

        /// <summary>
        /// Gets the name of the sort.
        /// </summary>
        /// <value>The name of the sort.</value>
        [JsonIgnore]
        public string SortName
        {
            get
            {
                if (_sortName == null)
                {
                    if (!string.IsNullOrEmpty(ForcedSortName))
                    {
                        // Need the ToLower because that's what CreateSortName does
                        _sortName = ModifySortChunks(ForcedSortName).ToLowerInvariant();
                    }
                    else
                    {
                        _sortName = CreateSortName();
                    }
                }

                return _sortName;
            }

            set => _sortName = value;
        }

        public string GetInternalMetadataPath()
        {
            var basePath = ConfigurationManager.ApplicationPaths.InternalMetadataPath;

            return GetInternalMetadataPath(basePath);
        }

        protected virtual string GetInternalMetadataPath(string basePath)
        {
            if (SourceType == SourceType.Channel)
            {
                return System.IO.Path.Combine(basePath, "channels", ChannelId.ToString("N", CultureInfo.InvariantCulture), Id.ToString("N", CultureInfo.InvariantCulture));
            }

            ReadOnlySpan<char> idString = Id.ToString("N", CultureInfo.InvariantCulture);

            basePath = System.IO.Path.Combine(basePath, "library");

            return System.IO.Path.Join(basePath, idString.Slice(0, 2), idString);
        }

        /// <summary>
        /// Creates the name of the sort.
        /// </summary>
        /// <returns>System.String.</returns>
        protected virtual string CreateSortName()
        {
            if (Name == null)
            {
                return null; // some items may not have name filled in properly
            }

            if (!EnableAlphaNumericSorting)
            {
                return Name.TrimStart();
            }

            var sortable = Name.Trim().ToLowerInvariant();

            foreach (var removeChar in ConfigurationManager.Configuration.SortRemoveCharacters)
            {
                sortable = sortable.Replace(removeChar, string.Empty, StringComparison.Ordinal);
            }

            foreach (var replaceChar in ConfigurationManager.Configuration.SortReplaceCharacters)
            {
                sortable = sortable.Replace(replaceChar, " ", StringComparison.Ordinal);
            }

            foreach (var search in ConfigurationManager.Configuration.SortRemoveWords)
            {
                // Remove from beginning if a space follows
                if (sortable.StartsWith(search + " ", StringComparison.Ordinal))
                {
                    sortable = sortable.Remove(0, search.Length + 1);
                }

                // Remove from middle if surrounded by spaces
                sortable = sortable.Replace(" " + search + " ", " ", StringComparison.Ordinal);

                // Remove from end if followed by a space
                if (sortable.EndsWith(" " + search, StringComparison.Ordinal))
                {
                    sortable = sortable.Remove(sortable.Length - (search.Length + 1));
                }
            }

            return ModifySortChunks(sortable);
        }

        private string ModifySortChunks(string name)
        {
            var chunks = GetSortChunks(name);

            var builder = new StringBuilder();

            foreach (var chunk in chunks)
            {
                var chunkBuilder = chunk.Item1;

                // This chunk is numeric
                if (chunk.Item2)
                {
                    while (chunkBuilder.Length < 10)
                    {
                        chunkBuilder.Insert(0, '0');
                    }
                }

                builder.Append(chunkBuilder);
            }

            // logger.LogDebug("ModifySortChunks Start: {0} End: {1}", name, builder.ToString());
            return builder.ToString().RemoveDiacritics();
        }

        [JsonIgnore]
        public bool EnableMediaSourceDisplay
        {
            get
            {
                if (SourceType == SourceType.Channel)
                {
                    return ChannelManager.EnableMediaSourceDisplay(this);
                }

                return true;
            }
        }

        [JsonIgnore]
        public Guid ParentId { get; set; }

        /// <summary>
        /// Gets or sets the parent.
        /// </summary>
        /// <value>The parent.</value>
        [JsonIgnore]
        public Folder Parent
        {
            get => GetParent() as Folder;
            set
            {
            }
        }

        public void SetParent(Folder parent)
        {
            ParentId = parent == null ? Guid.Empty : parent.Id;
        }

        public BaseItem GetParent()
        {
            var parentId = ParentId;
            if (!parentId.Equals(Guid.Empty))
            {
                return LibraryManager.GetItemById(parentId);
            }

            return null;
        }

        public IEnumerable<BaseItem> GetParents()
        {
            var parent = GetParent();

            while (parent != null)
            {
                yield return parent;

                parent = parent.GetParent();
            }
        }

        /// <summary>
        /// Finds a parent of a given type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns>``0.</returns>
        public T FindParent<T>()
            where T : Folder
        {
            foreach (var parent in GetParents())
            {
                var item = parent as T;
                if (item != null)
                {
                    return item;
                }
            }

            return null;
        }

        [JsonIgnore]
        public virtual Guid DisplayParentId
        {
            get
            {
                var parentId = ParentId;
                return parentId;
            }
        }

        [JsonIgnore]
        public BaseItem DisplayParent
        {
            get
            {
                var id = DisplayParentId;
                if (id.Equals(Guid.Empty))
                {
                    return null;
                }

                return LibraryManager.GetItemById(id);
            }
        }

        /// <summary>
        /// When the item first debuted. For movies this could be premiere date, episodes would be first aired
        /// </summary>
        /// <value>The premiere date.</value>
        [JsonIgnore]
        public DateTime? PremiereDate { get; set; }

        /// <summary>
        /// Gets or sets the end date.
        /// </summary>
        /// <value>The end date.</value>
        [JsonIgnore]
        public DateTime? EndDate { get; set; }

        /// <summary>
        /// Gets or sets the official rating.
        /// </summary>
        /// <value>The official rating.</value>
        [JsonIgnore]
        public string OfficialRating { get; set; }

        [JsonIgnore]
        public int InheritedParentalRatingValue { get; set; }

        /// <summary>
        /// Gets or sets the critic rating.
        /// </summary>
        /// <value>The critic rating.</value>
        [JsonIgnore]
        public float? CriticRating { get; set; }

        /// <summary>
        /// Gets or sets the custom rating.
        /// </summary>
        /// <value>The custom rating.</value>
        [JsonIgnore]
        public string CustomRating { get; set; }

        /// <summary>
        /// Gets or sets the overview.
        /// </summary>
        /// <value>The overview.</value>
        [JsonIgnore]
        public string Overview { get; set; }

        /// <summary>
        /// Gets or sets the studios.
        /// </summary>
        /// <value>The studios.</value>
        [JsonIgnore]
        public string[] Studios { get; set; }

        /// <summary>
        /// Gets or sets the genres.
        /// </summary>
        /// <value>The genres.</value>
        [JsonIgnore]
        public string[] Genres { get; set; }

        /// <summary>
        /// Gets or sets the tags.
        /// </summary>
        /// <value>The tags.</value>
        [JsonIgnore]
        public string[] Tags { get; set; }

        [JsonIgnore]
        public string[] ProductionLocations { get; set; }

        /// <summary>
        /// Gets or sets the home page URL.
        /// </summary>
        /// <value>The home page URL.</value>
        [JsonIgnore]
        public string HomePageUrl { get; set; }

        /// <summary>
        /// Gets or sets the community rating.
        /// </summary>
        /// <value>The community rating.</value>
        [JsonIgnore]
        public float? CommunityRating { get; set; }

        /// <summary>
        /// Gets or sets the run time ticks.
        /// </summary>
        /// <value>The run time ticks.</value>
        [JsonIgnore]
        public long? RunTimeTicks { get; set; }

        /// <summary>
        /// Gets or sets the production year.
        /// </summary>
        /// <value>The production year.</value>
        [JsonIgnore]
        public int? ProductionYear { get; set; }

        /// <summary>
        /// If the item is part of a series, this is it's number in the series.
        /// This could be episode number, album track number, etc.
        /// </summary>
        /// <value>The index number.</value>
        [JsonIgnore]
        public int? IndexNumber { get; set; }

        /// <summary>
        /// For an episode this could be the season number, or for a song this could be the disc number.
        /// </summary>
        /// <value>The parent index number.</value>
        [JsonIgnore]
        public int? ParentIndexNumber { get; set; }

        [JsonIgnore]
        public virtual bool HasLocalAlternateVersions => false;

        [JsonIgnore]
        public string OfficialRatingForComparison
        {
            get
            {
                var officialRating = OfficialRating;
                if (!string.IsNullOrEmpty(officialRating))
                {
                    return officialRating;
                }

                var parent = DisplayParent;
                if (parent != null)
                {
                    return parent.OfficialRatingForComparison;
                }

                return null;
            }
        }

        [JsonIgnore]
        public string CustomRatingForComparison
        {
            get
            {
                var customRating = CustomRating;
                if (!string.IsNullOrEmpty(customRating))
                {
                    return customRating;
                }

                var parent = DisplayParent;
                if (parent != null)
                {
                    return parent.CustomRatingForComparison;
                }

                return null;
            }
        }

        /// <summary>
        /// Gets the play access.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns>PlayAccess.</returns>
        public PlayAccess GetPlayAccess(User user)
        {
            if (!user.HasPermission(PermissionKind.EnableMediaPlayback))
            {
                return PlayAccess.None;
            }

            // if (!user.IsParentalScheduleAllowed())
            //{
            //    return PlayAccess.None;
            //}

            return PlayAccess.Full;
        }

        public virtual List<MediaStream> GetMediaStreams()
        {
            return MediaSourceManager.GetMediaStreams(new MediaStreamQuery
            {
                ItemId = Id
            });
        }

        protected virtual bool IsActiveRecording()
        {
            return false;
        }

        public virtual List<MediaSourceInfo> GetMediaSources(bool enablePathSubstitution)
        {
            if (SourceType == SourceType.Channel)
            {
                var sources = ChannelManager.GetStaticMediaSources(this, CancellationToken.None)
                           .ToList();

                if (sources.Count > 0)
                {
                    return sources;
                }
            }

            var list = GetAllItemsForMediaSources();
            var result = list.Select(i => GetVersionInfo(enablePathSubstitution, i.Item1, i.Item2)).ToList();

            if (IsActiveRecording())
            {
                foreach (var mediaSource in result)
                {
                    mediaSource.Type = MediaSourceType.Placeholder;
                }
            }

            return result.OrderBy(i =>
            {
                if (i.VideoType == VideoType.VideoFile)
                {
                    return 0;
                }

                return 1;
            }).ThenBy(i => i.Video3DFormat.HasValue ? 1 : 0)
            .ThenByDescending(i =>
            {
                var stream = i.VideoStream;

                return stream == null || stream.Width == null ? 0 : stream.Width.Value;
            })
            .ToList();
        }

        protected virtual List<Tuple<BaseItem, MediaSourceType>> GetAllItemsForMediaSources()
        {
            return new List<Tuple<BaseItem, MediaSourceType>>();
        }

        private MediaSourceInfo GetVersionInfo(bool enablePathSubstitution, BaseItem item, MediaSourceType type)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var protocol = item.PathProtocol;

            var info = new MediaSourceInfo
            {
                Id = item.Id.ToString("N", CultureInfo.InvariantCulture),
                Protocol = protocol ?? MediaProtocol.File,
                MediaStreams = MediaSourceManager.GetMediaStreams(item.Id),
                MediaAttachments = MediaSourceManager.GetMediaAttachments(item.Id),
                Name = GetMediaSourceName(item),
                Path = enablePathSubstitution ? GetMappedPath(item, item.Path, protocol) : item.Path,
                RunTimeTicks = item.RunTimeTicks,
                Container = item.Container,
                Size = item.Size,
                Type = type
            };

            if (string.IsNullOrEmpty(info.Path))
            {
                info.Type = MediaSourceType.Placeholder;
            }

            if (info.Protocol == MediaProtocol.File)
            {
                info.ETag = item.DateModified.Ticks.ToString(CultureInfo.InvariantCulture).GetMD5().ToString("N", CultureInfo.InvariantCulture);
            }

            var video = item as Video;
            if (video != null)
            {
                info.IsoType = video.IsoType;
                info.VideoType = video.VideoType;
                info.Video3DFormat = video.Video3DFormat;
                info.Timestamp = video.Timestamp;

                if (video.IsShortcut)
                {
                    info.IsRemote = true;
                    info.Path = video.ShortcutPath;
                    info.Protocol = MediaSourceManager.GetPathProtocol(info.Path);
                }

                if (string.IsNullOrEmpty(info.Container))
                {
                    if (video.VideoType == VideoType.VideoFile || video.VideoType == VideoType.Iso)
                    {
                        if (protocol.HasValue && protocol.Value == MediaProtocol.File)
                        {
                            info.Container = System.IO.Path.GetExtension(item.Path).TrimStart('.');
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(info.Container))
            {
                if (protocol.HasValue && protocol.Value == MediaProtocol.File)
                {
                    info.Container = System.IO.Path.GetExtension(item.Path).TrimStart('.');
                }
            }

            if (info.SupportsDirectStream && !string.IsNullOrEmpty(info.Path))
            {
                info.SupportsDirectStream = MediaSourceManager.SupportsDirectStream(info.Path, info.Protocol);
            }

            if (video != null && video.VideoType != VideoType.VideoFile)
            {
                info.SupportsDirectStream = false;
            }

            info.Bitrate = item.TotalBitrate;
            info.InferTotalBitrate();

            return info;
        }

        private string GetMediaSourceName(BaseItem item)
        {
            var terms = new List<string>();

            var path = item.Path;
            if (item.IsFileProtocol && !string.IsNullOrEmpty(path))
            {
                if (HasLocalAlternateVersions)
                {
                    var displayName = System.IO.Path.GetFileNameWithoutExtension(path)
                        .Replace(System.IO.Path.GetFileName(ContainingFolderPath), string.Empty, StringComparison.OrdinalIgnoreCase)
                        .TrimStart(new char[] { ' ', '-' });

                    if (!string.IsNullOrEmpty(displayName))
                    {
                        terms.Add(displayName);
                    }
                }

                if (terms.Count == 0)
                {
                    var displayName = System.IO.Path.GetFileNameWithoutExtension(path);
                    terms.Add(displayName);
                }
            }

            if (terms.Count == 0)
            {
                terms.Add(item.Name);
            }

            var video = item as Video;
            if (video != null)
            {
                if (video.Video3DFormat.HasValue)
                {
                    terms.Add("3D");
                }

                if (video.VideoType == VideoType.BluRay)
                {
                    terms.Add("Bluray");
                }
                else if (video.VideoType == VideoType.Dvd)
                {
                    terms.Add("DVD");
                }
                else if (video.VideoType == VideoType.Iso)
                {
                    if (video.IsoType.HasValue)
                    {
                        if (video.IsoType.Value == IsoType.BluRay)
                        {
                            terms.Add("Bluray");
                        }
                        else if (video.IsoType.Value == IsoType.Dvd)
                        {
                            terms.Add("DVD");
                        }
                    }
                    else
                    {
                        terms.Add("ISO");
                    }
                }
            }

            return string.Join('/', terms.ToArray());
        }

        /// <summary>
        /// Loads the theme songs.
        /// </summary>
        /// <returns>List{Audio.Audio}.</returns>
        private static Audio.Audio[] LoadThemeSongs(List<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var files = fileSystemChildren.Where(i => i.IsDirectory)
                .Where(i => string.Equals(i.Name, ThemeSongsFolderName, StringComparison.OrdinalIgnoreCase))
                .SelectMany(i => FileSystem.GetFiles(i.FullName))
                .ToList();

            // Support plex/xbmc convention
            files.AddRange(fileSystemChildren
                .Where(i => !i.IsDirectory && string.Equals(FileSystem.GetFileNameWithoutExtension(i), ThemeSongFilename, StringComparison.OrdinalIgnoreCase)));

            return LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                .OfType<Audio.Audio>()
                .Select(audio =>
                {
                    // Try to retrieve it from the db. If we don't find it, use the resolved version
                    var dbItem = LibraryManager.GetItemById(audio.Id) as Audio.Audio;

                    if (dbItem != null)
                    {
                        audio = dbItem;
                    }
                    else
                    {
                        // item is new
                        audio.ExtraType = MediaBrowser.Model.Entities.ExtraType.ThemeSong;
                    }

                    return audio;

                    // Sort them so that the list can be easily compared for changes
                }).OrderBy(i => i.Path).ToArray();
        }

        /// <summary>
        /// Loads the video backdrops.
        /// </summary>
        /// <returns>List{Video}.</returns>
        private static Video[] LoadThemeVideos(IEnumerable<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var files = fileSystemChildren.Where(i => i.IsDirectory)
                .Where(i => string.Equals(i.Name, ThemeVideosFolderName, StringComparison.OrdinalIgnoreCase))
                .SelectMany(i => FileSystem.GetFiles(i.FullName));

            return LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                .OfType<Video>()
                .Select(item =>
                {
                    // Try to retrieve it from the db. If we don't find it, use the resolved version

                    if (LibraryManager.GetItemById(item.Id) is Video dbItem)
                    {
                        item = dbItem;
                    }
                    else
                    {
                        // item is new
                        item.ExtraType = Model.Entities.ExtraType.ThemeVideo;
                    }

                    return item;

                    // Sort them so that the list can be easily compared for changes
                }).OrderBy(i => i.Path).ToArray();
        }

        protected virtual BaseItem[] LoadExtras(List<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var extras = new List<Video>();

            var folders = fileSystemChildren.Where(i => i.IsDirectory).ToArray();
            foreach (var extraFolderName in AllExtrasTypesFolderNames)
            {
                var files = folders
                    .Where(i => string.Equals(i.Name, extraFolderName, StringComparison.OrdinalIgnoreCase))
                    .SelectMany(i => FileSystem.GetFiles(i.FullName));

                extras.AddRange(LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                    .OfType<Video>()
                    .Select(item =>
                    {
                        // Try to retrieve it from the db. If we don't find it, use the resolved version
                        if (LibraryManager.GetItemById(item.Id) is Video dbItem)
                        {
                            item = dbItem;
                        }

                        // Use some hackery to get the extra type based on foldername
                        item.ExtraType = Enum.TryParse(extraFolderName.Replace(" ", string.Empty), true, out ExtraType extraType)
                            ? extraType
                            : Model.Entities.ExtraType.Unknown;

                        return item;

                        // Sort them so that the list can be easily compared for changes
                    }).OrderBy(i => i.Path));
            }

            return extras.ToArray();
        }

        public Task RefreshMetadata(CancellationToken cancellationToken)
        {
            return RefreshMetadata(new MetadataRefreshOptions(new DirectoryService(FileSystem)), cancellationToken);
        }

        protected virtual void TriggerOnRefreshStart()
        {
        }

        protected virtual void TriggerOnRefreshComplete()
        {
        }

        /// <summary>
        /// Overrides the base implementation to refresh metadata for local trailers.
        /// </summary>
        /// <param name="options">The options.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>true if a provider reports we changed.</returns>
        public async Task<ItemUpdateType> RefreshMetadata(MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            TriggerOnRefreshStart();

            var requiresSave = false;

            if (SupportsOwnedItems)
            {
                try
                {
                    var files = IsFileProtocol ?
                        GetFileSystemChildren(options.DirectoryService).ToList() :
                        new List<FileSystemMetadata>();

                    var ownedItemsChanged = await RefreshedOwnedItems(options, files, cancellationToken).ConfigureAwait(false);
                    await LibraryManager.UpdateImagesAsync(this).ConfigureAwait(false); // ensure all image properties in DB are fresh

                    if (ownedItemsChanged)
                    {
                        requiresSave = true;
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error refreshing owned items for {path}", Path ?? Name);
                }
            }

            try
            {
                var refreshOptions = requiresSave
                    ? new MetadataRefreshOptions(options)
                    {
                        ForceSave = true
                    }
                    : options;

                return await ProviderManager.RefreshSingleItem(this, refreshOptions, cancellationToken).ConfigureAwait(false);
            }
            finally
            {
                TriggerOnRefreshComplete();
            }
        }

        [JsonIgnore]
        protected virtual bool SupportsOwnedItems => !ParentId.Equals(Guid.Empty) && IsFileProtocol;

        [JsonIgnore]
        public virtual bool SupportsPeople => false;

        [JsonIgnore]
        public virtual bool SupportsThemeMedia => false;

        /// <summary>
        /// Refreshes owned items such as trailers, theme videos, special features, etc.
        /// Returns true or false indicating if changes were found.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="fileSystemChildren"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task<bool> RefreshedOwnedItems(MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var themeSongsChanged = false;

            var themeVideosChanged = false;

            var extrasChanged = false;

            var localTrailersChanged = false;

            if (IsFileProtocol && SupportsOwnedItems)
            {
                if (SupportsThemeMedia)
                {
                    if (!IsInMixedFolder)
                    {
                        themeSongsChanged = await RefreshThemeSongs(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);

                        themeVideosChanged = await RefreshThemeVideos(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);

                        extrasChanged = await RefreshExtras(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);
                    }
                }

                var hasTrailers = this as IHasTrailers;
                if (hasTrailers != null)
                {
                    localTrailersChanged = await RefreshLocalTrailers(hasTrailers, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);
                }
            }

            return themeSongsChanged || themeVideosChanged || extrasChanged || localTrailersChanged;
        }

        protected virtual FileSystemMetadata[] GetFileSystemChildren(IDirectoryService directoryService)
        {
            var path = ContainingFolderPath;

            return directoryService.GetFileSystemEntries(path);
        }

        private async Task<bool> RefreshLocalTrailers(IHasTrailers item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newItems = LibraryManager.FindTrailers(this, fileSystemChildren, options.DirectoryService);

            var newItemIds = newItems.Select(i => i.Id);

            var itemsChanged = !item.LocalTrailerIds.SequenceEqual(newItemIds);
            var ownerId = item.Id;

            var tasks = newItems.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (i.ExtraType != Model.Entities.ExtraType.Trailer ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.Trailer;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            item.LocalTrailerIds = newItemIds.ToArray();

            return itemsChanged;
        }

        private async Task<bool> RefreshExtras(BaseItem item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var extras = LoadExtras(fileSystemChildren, options.DirectoryService);
            var themeVideos = LoadThemeVideos(fileSystemChildren, options.DirectoryService);
            var themeSongs = LoadThemeSongs(fileSystemChildren, options.DirectoryService);
            var newExtras = new BaseItem[extras.Length + themeVideos.Length + themeSongs.Length];
            extras.CopyTo(newExtras, 0);
            themeVideos.CopyTo(newExtras, extras.Length);
            themeSongs.CopyTo(newExtras, extras.Length + themeVideos.Length);

            var newExtraIds = newExtras.Select(i => i.Id).ToArray();

            var extrasChanged = !item.ExtraIds.SequenceEqual(newExtraIds);

            if (extrasChanged)
            {
                var ownerId = item.Id;

                var tasks = newExtras.Select(i =>
                {
                    var subOptions = new MetadataRefreshOptions(options);
                    if (i.OwnerId != ownerId || i.ParentId != Guid.Empty)
                    {
                        i.OwnerId = ownerId;
                        i.ParentId = Guid.Empty;
                        subOptions.ForceSave = true;
                    }

                    return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
                });

                await Task.WhenAll(tasks).ConfigureAwait(false);

                item.ExtraIds = newExtraIds;
            }

            return extrasChanged;
        }

        private async Task<bool> RefreshThemeVideos(BaseItem item, MetadataRefreshOptions options, IEnumerable<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newThemeVideos = LoadThemeVideos(fileSystemChildren, options.DirectoryService);

            var newThemeVideoIds = newThemeVideos.Select(i => i.Id).ToArray();

            var themeVideosChanged = !item.ThemeVideoIds.SequenceEqual(newThemeVideoIds);

            var ownerId = item.Id;

            var tasks = newThemeVideos.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (!i.ExtraType.HasValue ||
                    i.ExtraType.Value != Model.Entities.ExtraType.ThemeVideo ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.ThemeVideo;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            // They are expected to be sorted by SortName
            item.ThemeVideoIds = newThemeVideos.OrderBy(i => i.SortName).Select(i => i.Id).ToArray();

            return themeVideosChanged;
        }

        /// <summary>
        /// Refreshes the theme songs.
        /// </summary>
        private async Task<bool> RefreshThemeSongs(BaseItem item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newThemeSongs = LoadThemeSongs(fileSystemChildren, options.DirectoryService);
            var newThemeSongIds = newThemeSongs.Select(i => i.Id).ToArray();

            var themeSongsChanged = !item.ThemeSongIds.SequenceEqual(newThemeSongIds);

            var ownerId = item.Id;

            var tasks = newThemeSongs.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (!i.ExtraType.HasValue ||
                    i.ExtraType.Value != Model.Entities.ExtraType.ThemeSong ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.ThemeSong;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            // They are expected to be sorted by SortName
            item.ThemeSongIds = newThemeSongs.OrderBy(i => i.SortName).Select(i => i.Id).ToArray();

            return themeSongsChanged;
        }

        /// <summary>
        /// Gets or sets the provider ids.
        /// </summary>
        /// <value>The provider ids.</value>
        [JsonIgnore]
        public Dictionary<string, string> ProviderIds { get; set; }

        [JsonIgnore]
        public virtual Folder LatestItemsIndexContainer => null;

        public virtual double GetDefaultPrimaryImageAspectRatio()
        {
            return 0;
        }

        public virtual string CreatePresentationUniqueKey()
        {
            return Id.ToString("N", CultureInfo.InvariantCulture);
        }

        [JsonIgnore]
        public string PresentationUniqueKey { get; set; }

        public string GetPresentationUniqueKey()
        {
            return PresentationUniqueKey ?? CreatePresentationUniqueKey();
        }

        public virtual bool RequiresRefresh()
        {
            return false;
        }

        public virtual List<string> GetUserDataKeys()
        {
            var list = new List<string>();

            if (SourceType == SourceType.Channel)
            {
                if (!string.IsNullOrEmpty(ExternalId))
                {
                    list.Add(ExternalId);
                }
            }

            list.Add(Id.ToString());
            return list;
        }

        internal virtual ItemUpdateType UpdateFromResolvedItem(BaseItem newItem)
        {
            var updateType = ItemUpdateType.None;

            if (IsInMixedFolder != newItem.IsInMixedFolder)
            {
                IsInMixedFolder = newItem.IsInMixedFolder;
                updateType |= ItemUpdateType.MetadataImport;
            }

            return updateType;
        }

        public void AfterMetadataRefresh()
        {
            _sortName = null;
        }

        /// <summary>
        /// Gets the preferred metadata language.
        /// </summary>
        /// <returns>System.String.</returns>
        public string GetPreferredMetadataLanguage()
        {
            string lang = PreferredMetadataLanguage;

            if (string.IsNullOrEmpty(lang))
            {
                lang = GetParents()
                    .Select(i => i.PreferredMetadataLanguage)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetCollectionFolders(this)
                    .Select(i => i.PreferredMetadataLanguage)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetLibraryOptions(this).PreferredMetadataLanguage;
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = ConfigurationManager.Configuration.PreferredMetadataLanguage;
            }

            return lang;
        }

        /// <summary>
        /// Gets the preferred metadata language.
        /// </summary>
        /// <returns>System.String.</returns>
        public string GetPreferredMetadataCountryCode()
        {
            string lang = PreferredMetadataCountryCode;

            if (string.IsNullOrEmpty(lang))
            {
                lang = GetParents()
                    .Select(i => i.PreferredMetadataCountryCode)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetCollectionFolders(this)
                    .Select(i => i.PreferredMetadataCountryCode)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetLibraryOptions(this).MetadataCountryCode;
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = ConfigurationManager.Configuration.MetadataCountryCode;
            }

            return lang;
        }

        public virtual bool IsSaveLocalMetadataEnabled()
        {
            if (SourceType == SourceType.Channel)
            {
                return false;
            }

            var libraryOptions = LibraryManager.GetLibraryOptions(this);

            return libraryOptions.SaveLocalMetadata;
        }

        /// <summary>
        /// Determines if a given user has access to this item.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns><c>true</c> if [is parental allowed] [the specified user]; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">user</exception>
        public bool IsParentalAllowed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            if (!IsVisibleViaTags(user))
            {
                return false;
            }

            var maxAllowedRating = user.MaxParentalAgeRating;

            if (maxAllowedRating == null)
            {
                return true;
            }

            var rating = CustomRatingForComparison;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRatingForComparison;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return !GetBlockUnratedValue(user);
            }

            var value = LocalizationManager.GetRatingLevel(rating);

            // Could not determine the integer value
            if (!value.HasValue)
            {
                var isAllowed = !GetBlockUnratedValue(user);

                if (!isAllowed)
                {
                    Logger.LogDebug("{0} has an unrecognized parental rating of {1}.", Name, rating);
                }

                return isAllowed;
            }

            return value.Value <= maxAllowedRating.Value;
        }

        public int? GetParentalRatingValue()
        {
            var rating = CustomRating;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRating;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return null;
            }

            return LocalizationManager.GetRatingLevel(rating);
        }

        public int? GetInheritedParentalRatingValue()
        {
            var rating = CustomRatingForComparison;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRatingForComparison;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return null;
            }

            return LocalizationManager.GetRatingLevel(rating);
        }

        public List<string> GetInheritedTags()
        {
            var list = new List<string>();
            list.AddRange(Tags);

            foreach (var parent in GetParents())
            {
                list.AddRange(parent.Tags);
            }

            return list.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        }

        private bool IsVisibleViaTags(User user)
        {
            if (user.GetPreference(PreferenceKind.BlockedTags).Any(i => Tags.Contains(i, StringComparer.OrdinalIgnoreCase)))
            {
                return false;
            }

            return true;
        }

        protected virtual bool IsAllowTagFilterEnforced()
        {
            return true;
        }

        public virtual UnratedItem GetBlockUnratedType()
        {
            if (SourceType == SourceType.Channel)
            {
                return UnratedItem.ChannelContent;
            }

            return UnratedItem.Other;
        }

        /// <summary>
        /// Gets the block unrated value.
        /// </summary>
        /// <param name="user">The configuration.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        protected virtual bool GetBlockUnratedValue(User user)
        {
            // Don't block plain folders that are unrated. Let the media underneath get blocked
            // Special folders like series and albums will override this method.
            if (IsFolder || this is IItemByName)
            {
                return false;
            }

            return user.GetPreferenceValues<UnratedItem>(PreferenceKind.BlockUnratedItems).Contains(GetBlockUnratedType());
        }

        /// <summary>
        /// Determines if this folder should be visible to a given user.
        /// Default is just parental allowed. Can be overridden for more functionality.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns><c>true</c> if the specified user is visible; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">user</exception>
        public virtual bool IsVisible(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            return IsParentalAllowed(user);
        }

        public virtual bool IsVisibleStandalone(User user)
        {
            if (SourceType == SourceType.Channel)
            {
                return IsVisibleStandaloneInternal(user, false) && Channel.IsChannelVisible(this, user);
            }

            return IsVisibleStandaloneInternal(user, true);
        }

        [JsonIgnore]
        public virtual bool SupportsInheritedParentImages => false;

        protected bool IsVisibleStandaloneInternal(User user, bool checkFolders)
        {
            if (!IsVisible(user))
            {
                return false;
            }

            if (GetParents().Any(i => !i.IsVisible(user)))
            {
                return false;
            }

            if (checkFolders)
            {
                var topParent = GetParents().LastOrDefault() ?? this;

                if (string.IsNullOrEmpty(topParent.Path))
                {
                    return true;
                }

                var itemCollectionFolders = LibraryManager.GetCollectionFolders(this).Select(i => i.Id).ToList();

                if (itemCollectionFolders.Count > 0)
                {
                    var userCollectionFolders = LibraryManager.GetUserRootFolder().GetChildren(user, true).Select(i => i.Id).ToList();
                    if (!itemCollectionFolders.Any(userCollectionFolders.Contains))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Gets a value indicating whether this instance is folder.
        /// </summary>
        /// <value><c>true</c> if this instance is folder; otherwise, <c>false</c>.</value>
        [JsonIgnore]
        public virtual bool IsFolder => false;

        [JsonIgnore]
        public virtual bool IsDisplayedAsFolder => false;

        public virtual string GetClientTypeName()
        {
            if (IsFolder && SourceType == SourceType.Channel && !(this is Channel))
            {
                return "ChannelFolderItem";
            }

            return GetType().Name;
        }

        public BaseItemKind GetBaseItemKind()
        {
            return Enum.Parse<BaseItemKind>(GetClientTypeName());
        }

        /// <summary>
        /// Gets the linked child.
        /// </summary>
        /// <param name="info">The info.</param>
        /// <returns>BaseItem.</returns>
        protected BaseItem GetLinkedChild(LinkedChild info)
        {
            // First get using the cached Id
            if (info.ItemId.HasValue)
            {
                if (info.ItemId.Value.Equals(Guid.Empty))
                {
                    return null;
                }

                var itemById = LibraryManager.GetItemById(info.ItemId.Value);

                if (itemById != null)
                {
                    return itemById;
                }
            }

            var item = FindLinkedChild(info);

            // If still null, log
            if (item == null)
            {
                // Don't keep searching over and over
                info.ItemId = Guid.Empty;
            }
            else
            {
                // Cache the id for next time
                info.ItemId = item.Id;
            }

            return item;
        }

        private BaseItem FindLinkedChild(LinkedChild info)
        {
            var path = info.Path;

            if (!string.IsNullOrEmpty(path))
            {
                path = FileSystem.MakeAbsolutePath(ContainingFolderPath, path);

                var itemByPath = LibraryManager.FindByPath(path, null);

                if (itemByPath == null)
                {
                    Logger.LogWarning("Unable to find linked item at path {0}", info.Path);
                }

                return itemByPath;
            }

            if (!string.IsNullOrEmpty(info.LibraryItemId))
            {
                var item = LibraryManager.GetItemById(info.LibraryItemId);

                if (item == null)
                {
                    Logger.LogWarning("Unable to find linked item at path {0}", info.Path);
                }

                return item;
            }

            return null;
        }

        [JsonIgnore]
        public virtual bool EnableRememberingTrackSelections => true;

        /// <summary>
        /// Adds a studio to the item.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddStudio(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException(nameof(name));
            }

            var current = Studios;

            if (!current.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                int curLen = current.Length;
                if (curLen == 0)
                {
                    Studios = new[] { name };
                }
                else
                {
                    var newArr = new string[curLen + 1];
                    current.CopyTo(newArr, 0);
                    newArr[curLen] = name;
                    Studios = newArr;
                }
            }
        }

        public void SetStudios(IEnumerable<string> names)
        {
            Studios = names.Distinct().ToArray();
        }

        /// <summary>
        /// Adds a genre to the item.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddGenre(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException(nameof(name));
            }

            var genres = Genres;
            if (!genres.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                var list = genres.ToList();
                list.Add(name);
                Genres = list.ToArray();
            }
        }

        /// <summary>
        /// Marks the played.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <param name="datePlayed">The date played.</param>
        /// <param name="resetPosition">if set to <c>true</c> [reset position].</param>
        /// <returns>Task.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public virtual void MarkPlayed(
            User user,
            DateTime? datePlayed,
            bool resetPosition)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = UserDataManager.GetUserData(user, this);

            if (datePlayed.HasValue)
            {
                // Increment
                data.PlayCount++;
            }

            // Ensure it's at least one
            data.PlayCount = Math.Max(data.PlayCount, 1);

            if (resetPosition)
            {
                data.PlaybackPositionTicks = 0;
            }

            data.LastPlayedDate = datePlayed ?? data.LastPlayedDate ?? DateTime.UtcNow;
            data.Played = true;

            UserDataManager.SaveUserData(user.Id, this, data, UserDataSaveReason.TogglePlayed, CancellationToken.None);
        }

        /// <summary>
        /// Marks the unplayed.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns>Task.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public virtual void MarkUnplayed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = UserDataManager.GetUserData(user, this);

            // I think it is okay to do this here.
            // if this is only called when a user is manually forcing something to un-played
            // then it probably is what we want to do...
            data.PlayCount = 0;
            data.PlaybackPositionTicks = 0;
            data.LastPlayedDate = null;
            data.Played = false;

            UserDataManager.SaveUserData(user.Id, this, data, UserDataSaveReason.TogglePlayed, CancellationToken.None);
        }

        /// <summary>
        /// Do whatever refreshing is necessary when the filesystem pertaining to this item has changed.
        /// </summary>
        public virtual void ChangedExternally()
        {
            ProviderManager.QueueRefresh(Id, new MetadataRefreshOptions(new DirectoryService(FileSystem)), RefreshPriority.High);
        }

        /// <summary>
        /// Gets an image.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns><c>true</c> if the specified type has image; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">Backdrops should be accessed using Item.Backdrops</exception>
        public bool HasImage(ImageType type, int imageIndex)
        {
            return GetImageInfo(type, imageIndex) != null;
        }

        public void SetImage(ItemImageInfo image, int index)
        {
            if (image.Type == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot set chapter images using SetImagePath");
            }

            var existingImage = GetImageInfo(image.Type, index);

            if (existingImage != null)
            {
                existingImage.Path = image.Path;
                existingImage.DateModified = image.DateModified;
                existingImage.Width = image.Width;
                existingImage.Height = image.Height;
                existingImage.BlurHash = image.BlurHash;
            }
            else
            {
                var current = ImageInfos;
                var currentCount = current.Length;
                var newArr = new ItemImageInfo[currentCount + 1];
                current.CopyTo(newArr, 0);
                newArr[currentCount] = image;
                ImageInfos = newArr;
            }
        }

        public void SetImagePath(ImageType type, int index, FileSystemMetadata file)
        {
            if (type == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot set chapter images using SetImagePath");
            }

            var image = GetImageInfo(type, index);

            if (image == null)
            {
                ImageInfos = ImageInfos.Concat(new[] { GetImageInfo(file, type) }).ToArray();
            }
            else
            {
                var imageInfo = GetImageInfo(file, type);

                image.Path = file.FullName;
                image.DateModified = imageInfo.DateModified;

                // reset these values
                image.Width = 0;
                image.Height = 0;
            }
        }

        /// <summary>
        /// Deletes the image.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="index">The index.</param>
        public async Task DeleteImageAsync(ImageType type, int index)
        {
            var info = GetImageInfo(type, index);

            if (info == null)
            {
                // Nothing to do
                return;
            }

            // Remove it from the item
            RemoveImage(info);

            if (info.IsLocalFile)
            {
                FileSystem.DeleteFile(info.Path);
            }

            await UpdateToRepositoryAsync(ItemUpdateType.ImageUpdate, CancellationToken.None).ConfigureAwait(false);
        }

        public void RemoveImage(ItemImageInfo image)
        {
            RemoveImages(new List<ItemImageInfo> { image });
        }

        public void RemoveImages(List<ItemImageInfo> deletedImages)
        {
            ImageInfos = ImageInfos.Except(deletedImages).ToArray();
        }

        public virtual Task UpdateToRepositoryAsync(ItemUpdateType updateReason, CancellationToken cancellationToken)
         => LibraryManager.UpdateItemAsync(this, GetParent(), updateReason, cancellationToken);

        /// <summary>
        /// Validates that images within the item are still on the filesystem.
        /// </summary>
        public bool ValidateImages(IDirectoryService directoryService)
        {
            var allFiles = ImageInfos
                .Where(i => i.IsLocalFile)
                .Select(i => System.IO.Path.GetDirectoryName(i.Path))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .SelectMany(i => directoryService.GetFilePaths(i))
                .ToList();

            var deletedImages = ImageInfos
                .Where(image => image.IsLocalFile && !allFiles.Contains(image.Path, StringComparer.OrdinalIgnoreCase))
                .ToList();

            if (deletedImages.Count > 0)
            {
                ImageInfos = ImageInfos.Except(deletedImages).ToArray();
            }

            return deletedImages.Count > 0;
        }

        /// <summary>
        /// Gets the image path.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns>System.String.</returns>
        /// <exception cref="InvalidOperationException">
        /// </exception>
        /// <exception cref="ArgumentNullException">item</exception>
        public string GetImagePath(ImageType imageType, int imageIndex)
            => GetImageInfo(imageType, imageIndex)?.Path;

        /// <summary>
        /// Gets the image information.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns>ItemImageInfo.</returns>
        public ItemImageInfo GetImageInfo(ImageType imageType, int imageIndex)
        {
            if (imageType == ImageType.Chapter)
            {
                var chapter = ItemRepository.GetChapter(this, imageIndex);

                if (chapter == null)
                {
                    return null;
                }

                var path = chapter.ImagePath;

                if (string.IsNullOrEmpty(path))
                {
                    return null;
                }

                return new ItemImageInfo
                {
                    Path = path,
                    DateModified = chapter.ImageDateModified,
                    Type = imageType
                };
            }

            return GetImages(imageType)
                .ElementAtOrDefault(imageIndex);
        }

        /// <summary>
        /// Computes image index for given image or raises if no matching image found.
        /// </summary>
        /// <param name="image">Image to compute index for.</param>
        /// <exception cref="ArgumentException">Image index cannot be computed as no matching image found.
        /// </exception>
        /// <returns>Image index.</returns>
        public int GetImageIndex(ItemImageInfo image)
        {
            if (image == null)
            {
                throw new ArgumentNullException(nameof(image));
            }

            if (image.Type == ImageType.Chapter)
            {
                var chapters = ItemRepository.GetChapters(this);
                for (var i = 0; i < chapters.Count; i++)
                {
                    if (chapters[i].ImagePath == image.Path)
                    {
                        return i;
                    }
                }

                throw new ArgumentException("No chapter index found for image path", image.Path);
            }

            var images = GetImages(image.Type).ToArray();
            for (var i = 0; i < images.Length; i++)
            {
                if (images[i].Path == image.Path)
                {
                    return i;
                }
            }

            throw new ArgumentException("No image index found for image path", image.Path);
        }

        public IEnumerable<ItemImageInfo> GetImages(ImageType imageType)
        {
            if (imageType == ImageType.Chapter)
            {
                throw new ArgumentException("No image info for chapter images");
            }

            return ImageInfos.Where(i => i.Type == imageType);
        }

        /// <summary>
        /// Adds the images.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="images">The images.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <exception cref="ArgumentException">Cannot call AddImages with chapter images</exception>
        public bool AddImages(ImageType imageType, List<FileSystemMetadata> images)
        {
            if (imageType == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot call AddImages with chapter images");
            }

            var existingImages = GetImages(imageType)
                .ToList();

            var newImageList = new List<FileSystemMetadata>();
            var imageAdded = false;
            var imageUpdated = false;

            foreach (var newImage in images)
            {
                if (newImage == null)
                {
                    throw new ArgumentException("null image found in list");
                }

                var existing = existingImages
                    .FirstOrDefault(i => string.Equals(i.Path, newImage.FullName, StringComparison.OrdinalIgnoreCase));

                if (existing == null)
                {
                    newImageList.Add(newImage);
                    imageAdded = true;
                }
                else
                {
                    if (existing.IsLocalFile)
                    {
                        var newDateModified = FileSystem.GetLastWriteTimeUtc(newImage);

                        // If date changed then we need to reset saved image dimensions
                        if (existing.DateModified != newDateModified && (existing.Width > 0 || existing.Height > 0))
                        {
                            existing.Width = 0;
                            existing.Height = 0;
                            imageUpdated = true;
                        }

                        existing.DateModified = newDateModified;
                    }
                }
            }

            if (imageAdded || images.Count != existingImages.Count)
            {
                var newImagePaths = images.Select(i => i.FullName).ToList();

                var deleted = existingImages
                    .Where(i => i.IsLocalFile && !newImagePaths.Contains(i.Path, StringComparer.OrdinalIgnoreCase) && !File.Exists(i.Path))
                    .ToList();

                if (deleted.Count > 0)
                {
                    ImageInfos = ImageInfos.Except(deleted).ToArray();
                }
            }

            if (newImageList.Count > 0)
            {
                ImageInfos = ImageInfos.Concat(newImageList.Select(i => GetImageInfo(i, imageType))).ToArray();
            }

            return imageUpdated || newImageList.Count > 0;
        }

        private ItemImageInfo GetImageInfo(FileSystemMetadata file, ImageType type)
        {
            return new ItemImageInfo
            {
                Path = file.FullName,
                Type = type,
                DateModified = FileSystem.GetLastWriteTimeUtc(file)
            };
        }

        /// <summary>
        /// Gets the file system path to delete when the item is to be deleted.
        /// </summary>
        /// <returns></returns>
        public virtual IEnumerable<FileSystemMetadata> GetDeletePaths()
        {
            return new[] {
                new FileSystemMetadata
                {
                    FullName = Path,
                    IsDirectory = IsFolder
                }
            }.Concat(GetLocalMetadataFilesToDelete());
        }

        protected List<FileSystemMetadata> GetLocalMetadataFilesToDelete()
        {
            if (IsFolder || !IsInMixedFolder)
            {
                return new List<FileSystemMetadata>();
            }

            var filename = System.IO.Path.GetFileNameWithoutExtension(Path);

            return FileSystem.GetFiles(System.IO.Path.GetDirectoryName(Path), _supportedExtensions, false, false)
                .Where(i => System.IO.Path.GetFileNameWithoutExtension(i.FullName).StartsWith(filename, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }

        public bool AllowsMultipleImages(ImageType type)
        {
            return type == ImageType.Backdrop || type == ImageType.Screenshot || type == ImageType.Chapter;
        }

        public Task SwapImagesAsync(ImageType type, int index1, int index2)
        {
            if (!AllowsMultipleImages(type))
            {
                throw new ArgumentException("The change index operation is only applicable to backdrops and screen shots");
            }

            var info1 = GetImageInfo(type, index1);
            var info2 = GetImageInfo(type, index2);

            if (info1 == null || info2 == null)
            {
                // Nothing to do
                return Task.CompletedTask;
            }

            if (!info1.IsLocalFile || !info2.IsLocalFile)
            {
                // TODO: Not supported  yet
                return Task.CompletedTask;
            }

            var path1 = info1.Path;
            var path2 = info2.Path;

            FileSystem.SwapFiles(path1, path2);

            // Refresh these values
            info1.DateModified = FileSystem.GetLastWriteTimeUtc(info1.Path);
            info2.DateModified = FileSystem.GetLastWriteTimeUtc(info2.Path);

            info1.Width = 0;
            info1.Height = 0;
            info2.Width = 0;
            info2.Height = 0;

            return UpdateToRepositoryAsync(ItemUpdateType.ImageUpdate, CancellationToken.None);
        }

        public virtual bool IsPlayed(User user)
        {
            var userdata = UserDataManager.GetUserData(user, this);

            return userdata != null && userdata.Played;
        }

        public bool IsFavoriteOrLiked(User user)
        {
            var userdata = UserDataManager.GetUserData(user, this);

            return userdata != null && (userdata.IsFavorite || (userdata.Likes ?? false));
        }

        public virtual bool IsUnplayed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userdata = UserDataManager.GetUserData(user, this);

            return userdata == null || !userdata.Played;
        }

        ItemLookupInfo IHasLookupInfo<ItemLookupInfo>.GetLookupInfo()
        {
            return GetItemLookupInfo<ItemLookupInfo>();
        }

        protected T GetItemLookupInfo<T>()
            where T : ItemLookupInfo, new()
        {
            return new T
            {
                Path = Path,
                MetadataCountryCode = GetPreferredMetadataCountryCode(),
                MetadataLanguage = GetPreferredMetadataLanguage(),
                Name = GetNameForMetadataLookup(),
                ProviderIds = ProviderIds,
                IndexNumber = IndexNumber,
                ParentIndexNumber = ParentIndexNumber,
                Year = ProductionYear,
                PremiereDate = PremiereDate
            };
        }

        protected virtual string GetNameForMetadataLookup()
        {
            return Name;
        }

        /// <summary>
        /// This is called before any metadata refresh and returns true if changes were made.
        /// </summary>
        public virtual bool BeforeMetadataRefresh(bool replaceAllMetdata)
        {
            _sortName = null;

            var hasChanges = false;

            if (string.IsNullOrEmpty(Name) && !string.IsNullOrEmpty(Path))
            {
                Name = System.IO.Path.GetFileNameWithoutExtension(Path);
                hasChanges = true;
            }

            return hasChanges;
        }

        protected static string GetMappedPath(BaseItem item, string path, MediaProtocol? protocol)
        {
            if (protocol.HasValue && protocol.Value == MediaProtocol.File)
            {
                return LibraryManager.GetPathAfterNetworkSubstitution(path, item);
            }

            return path;
        }

        public virtual void FillUserDataDtoValues(UserItemDataDto dto, UserItemData userData, BaseItemDto itemDto, User user, DtoOptions fields)
        {
            if (RunTimeTicks.HasValue)
            {
                double pct = RunTimeTicks.Value;

                if (pct > 0)
                {
                    pct = userData.PlaybackPositionTicks / pct;

                    if (pct > 0)
                    {
                        dto.PlayedPercentage = 100 * pct;
                    }
                }
            }
        }

        protected Task RefreshMetadataForOwnedItem(BaseItem ownedItem, bool copyTitleMetadata, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            var newOptions = new MetadataRefreshOptions(options);
            newOptions.SearchResult = null;

            var item = this;

            if (copyTitleMetadata)
            {
                // Take some data from the main item, for querying purposes
                if (!item.Genres.SequenceEqual(ownedItem.Genres, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.Genres = item.Genres;
                }

                if (!item.Studios.SequenceEqual(ownedItem.Studios, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.Studios = item.Studios;
                }

                if (!item.ProductionLocations.SequenceEqual(ownedItem.ProductionLocations, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.ProductionLocations = item.ProductionLocations;
                }

                if (item.CommunityRating != ownedItem.CommunityRating)
                {
                    ownedItem.CommunityRating = item.CommunityRating;
                    newOptions.ForceSave = true;
                }

                if (item.CriticRating != ownedItem.CriticRating)
                {
                    ownedItem.CriticRating = item.CriticRating;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.Overview, ownedItem.Overview, StringComparison.Ordinal))
                {
                    ownedItem.Overview = item.Overview;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.OfficialRating, ownedItem.OfficialRating, StringComparison.Ordinal))
                {
                    ownedItem.OfficialRating = item.OfficialRating;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.CustomRating, ownedItem.CustomRating, StringComparison.Ordinal))
                {
                    ownedItem.CustomRating = item.CustomRating;
                    newOptions.ForceSave = true;
                }
            }

            return ownedItem.RefreshMetadata(newOptions, cancellationToken);
        }

        protected Task RefreshMetadataForOwnedVideo(MetadataRefreshOptions options, bool copyTitleMetadata, string path, CancellationToken cancellationToken)
        {
            var newOptions = new MetadataRefreshOptions(options);
            newOptions.SearchResult = null;

            var id = LibraryManager.GetNewItemId(path, typeof(Video));

            // Try to retrieve it from the db. If we don't find it, use the resolved version
            var video = LibraryManager.GetItemById(id) as Video;

            if (video == null)
            {
                video = LibraryManager.ResolvePath(FileSystem.GetFileSystemInfo(path)) as Video;

                newOptions.ForceSave = true;
            }

            // var parentId = Id;
            // if (!video.IsOwnedItem || video.ParentId != parentId)
            //{
            //    video.IsOwnedItem = true;
            //    video.ParentId = parentId;
            //    newOptions.ForceSave = true;
            //}

            if (video == null)
            {
                return Task.FromResult(true);
            }

            return RefreshMetadataForOwnedItem(video, copyTitleMetadata, newOptions, cancellationToken);
        }

        public string GetEtag(User user)
        {
            var list = GetEtagValues(user);

            return string.Join('|', list).GetMD5().ToString("N", CultureInfo.InvariantCulture);
        }

        protected virtual List<string> GetEtagValues(User user)
        {
            return new List<string>
            {
                DateLastSaved.Ticks.ToString(CultureInfo.InvariantCulture)
            };
        }

        public virtual IEnumerable<Guid> GetAncestorIds()
        {
            return GetParents().Select(i => i.Id).Concat(LibraryManager.GetCollectionFolders(this).Select(i => i.Id));
        }

        public BaseItem GetTopParent()
        {
            if (IsTopParent)
            {
                return this;
            }

            return GetParents().FirstOrDefault(parent => parent.IsTopParent);
        }

        [JsonIgnore]
        public virtual bool IsTopParent
        {
            get
            {
                if (this is BasePluginFolder || this is Channel)
                {
                    return true;
                }

                if (this is IHasCollectionType view)
                {
                    if (string.Equals(view.CollectionType, CollectionType.LiveTv, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }

                if (GetParent() is AggregateFolder)
                {
                    return true;
                }

                return false;
            }
        }

        [JsonIgnore]
        public virtual bool SupportsAncestors => true;

        [JsonIgnore]
        public virtual bool StopRefreshIfLocalMetadataFound => true;

        public virtual IEnumerable<Guid> GetIdsForAncestorQuery()
        {
            return new[] { Id };
        }

        public virtual List<ExternalUrl> GetRelatedUrls()
        {
            return new List<ExternalUrl>();
        }

        public virtual double? GetRefreshProgress()
        {
            return null;
        }

        public virtual ItemUpdateType OnMetadataChanged()
        {
            var updateType = ItemUpdateType.None;

            var item = this;

            var inheritedParentalRatingValue = item.GetInheritedParentalRatingValue() ?? 0;
            if (inheritedParentalRatingValue != item.InheritedParentalRatingValue)
            {
                item.InheritedParentalRatingValue = inheritedParentalRatingValue;
                updateType |= ItemUpdateType.MetadataImport;
            }

            return updateType;
        }

        /// <summary>
        /// Updates the official rating based on content and returns true or false indicating if it changed.
        /// </summary>
        /// <returns></returns>
        public bool UpdateRatingToItems(IList<BaseItem> children)
        {
            var currentOfficialRating = OfficialRating;

            // Gather all possible ratings
            var ratings = children
                .Select(i => i.OfficialRating)
                .Where(i => !string.IsNullOrEmpty(i))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .Select(i => new Tuple<string, int?>(i, LocalizationManager.GetRatingLevel(i)))
                .OrderBy(i => i.Item2 ?? 1000)
                .Select(i => i.Item1);

            OfficialRating = ratings.FirstOrDefault() ?? currentOfficialRating;

            return !string.Equals(currentOfficialRating ?? string.Empty, OfficialRating ?? string.Empty,
                StringComparison.OrdinalIgnoreCase);
        }

        public IEnumerable<BaseItem> GetThemeSongs()
        {
            return ThemeSongIds.Select(LibraryManager.GetItemById);
        }

        public IEnumerable<BaseItem> GetThemeVideos()
        {
            return ThemeVideoIds.Select(LibraryManager.GetItemById);
        }

        /// <summary>
        /// Gets or sets the remote trailers.
        /// </summary>
        /// <value>The remote trailers.</value>
        public IReadOnlyList<MediaUrl> RemoteTrailers { get; set; }

        /// <summary>
        /// Get all extras associated with this item, sorted by <see cref="SortName"/>.
        /// </summary>
        /// <returns>An enumerable containing the items.</returns>
        public IEnumerable<BaseItem> GetExtras()
        {
            return ExtraIds
                .Select(LibraryManager.GetItemById)
                .Where(i => i != null)
                .OrderBy(i => i.SortName);
        }

        /// <summary>
        /// Get all extras with specific types that are associated with this item.
        /// </summary>
        /// <param name="extraTypes">The types of extras to retrieve.</param>
        /// <returns>An enumerable containing the extras.</returns>
        public IEnumerable<BaseItem> GetExtras(IReadOnlyCollection<ExtraType> extraTypes)
        {
            return ExtraIds
                .Select(LibraryManager.GetItemById)
                .Where(i => i != null)
                .Where(i => i.ExtraType.HasValue && extraTypes.Contains(i.ExtraType.Value));
        }

        public IEnumerable<BaseItem> GetTrailers()
        {
            if (this is IHasTrailers)
            {
                return ((IHasTrailers)this).LocalTrailerIds.Select(LibraryManager.GetItemById).Where(i => i != null).OrderBy(i => i.SortName);
            }
            else
            {
                return Array.Empty<BaseItem>();
            }
        }

        public virtual bool IsHD => Height >= 720;

        public bool IsShortcut { get; set; }

        public string ShortcutPath { get; set; }

        public int Width { get; set; }

        public int Height { get; set; }

        public Guid[] ExtraIds { get; set; }

        public virtual long GetRunTimeTicksForPlayState()
        {
            return RunTimeTicks ?? 0;
        }

        /// <summary>
        /// Extra types that should be counted and displayed as "Special Features" in the UI.
        /// </summary>
        public static readonly IReadOnlyCollection<ExtraType> DisplayExtraTypes = new HashSet<ExtraType>
        {
            Model.Entities.ExtraType.Unknown,
            Model.Entities.ExtraType.BehindTheScenes,
            Model.Entities.ExtraType.Clip,
            Model.Entities.ExtraType.DeletedScene,
            Model.Entities.ExtraType.Interview,
            Model.Entities.ExtraType.Sample,
            Model.Entities.ExtraType.Scene
        };

        public virtual bool SupportsExternalTransfer => false;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            return obj is BaseItem baseItem && this.Equals(baseItem);
        }

        /// <inheritdoc />
        public bool Equals(BaseItem item) => Object.Equals(Id, item?.Id);

        /// <inheritdoc />
        public override int GetHashCode() => HashCode.Combine(Id);
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Jellyfin.Data.Entities;
using Jellyfin.Data.Enums;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Controller.Channels;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Dto;
using MediaBrowser.Controller.Extensions;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Persistence;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.IO;
using MediaBrowser.Model.Library;
using MediaBrowser.Model.LiveTv;
using MediaBrowser.Model.MediaInfo;
using MediaBrowser.Model.Providers;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.Controller.Entities
{
    /// <summary>
    /// Class BaseItem.
    /// </summary>
    public abstract class BaseItem : IHasProviderIds, IHasLookupInfo<ItemLookupInfo>, IEquatable<BaseItem>
    {
        /// <summary>
        /// The supported image extensions.
        /// </summary>
        public static readonly string[] SupportedImageExtensions
            = new[] { ".png", ".jpg", ".jpeg", ".tbn", ".gif" };

        private static readonly List<string> _supportedExtensions = new List<string>(SupportedImageExtensions)
        {
            ".nfo",
            ".xml",
            ".srt",
            ".vtt",
            ".sub",
            ".idx",
            ".txt",
            ".edl",
            ".bif",
            ".smi",
            ".ttml"
        };

        protected BaseItem()
        {
            Tags = Array.Empty<string>();
            Genres = Array.Empty<string>();
            Studios = Array.Empty<string>();
            ProviderIds = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            LockedFields = Array.Empty<MetadataField>();
            ImageInfos = Array.Empty<ItemImageInfo>();
            ProductionLocations = Array.Empty<string>();
            RemoteTrailers = Array.Empty<MediaUrl>();
            ExtraIds = Array.Empty<Guid>();
        }

        public static readonly char[] SlugReplaceChars = { '?', '/', '&' };
        public static char SlugChar = '-';

        /// <summary>
        /// The trailer folder name.
        /// </summary>
        public const string TrailerFolderName = "trailers";
        public const string ThemeSongsFolderName = "theme-music";
        public const string ThemeSongFilename = "theme";
        public const string ThemeVideosFolderName = "backdrops";
        public const string ExtrasFolderName = "extras";
        public const string BehindTheScenesFolderName = "behind the scenes";
        public const string DeletedScenesFolderName = "deleted scenes";
        public const string InterviewFolderName = "interviews";
        public const string SceneFolderName = "scenes";
        public const string SampleFolderName = "samples";
        public const string ShortsFolderName = "shorts";
        public const string FeaturettesFolderName = "featurettes";

        public static readonly string[] AllExtrasTypesFolderNames = {
            ExtrasFolderName,
            BehindTheScenesFolderName,
            DeletedScenesFolderName,
            InterviewFolderName,
            SceneFolderName,
            SampleFolderName,
            ShortsFolderName,
            FeaturettesFolderName
        };

        [JsonIgnore]
        public Guid[] ThemeSongIds
        {
            get
            {
                if (_themeSongIds == null)
                {
                    _themeSongIds = GetExtras()
                        .Where(extra => extra.ExtraType == Model.Entities.ExtraType.ThemeSong)
                        .Select(song => song.Id)
                        .ToArray();
                }

                return _themeSongIds;
            }

            private set
            {
                _themeSongIds = value;
            }
        }

        [JsonIgnore]
        public Guid[] ThemeVideoIds
        {
            get
            {
                if (_themeVideoIds == null)
                {
                    _themeVideoIds = GetExtras()
                        .Where(extra => extra.ExtraType == Model.Entities.ExtraType.ThemeVideo)
                        .Select(song => song.Id)
                        .ToArray();
                }

                return _themeVideoIds;
            }

            private set
            {
                _themeVideoIds = value;
            }
        }

        [JsonIgnore]
        public string PreferredMetadataCountryCode { get; set; }

        [JsonIgnore]
        public string PreferredMetadataLanguage { get; set; }

        public long? Size { get; set; }

        public string Container { get; set; }

        [JsonIgnore]
        public string Tagline { get; set; }

        [JsonIgnore]
        public virtual ItemImageInfo[] ImageInfos { get; set; }

        [JsonIgnore]
        public bool IsVirtualItem { get; set; }

        /// <summary>
        /// Gets or sets the album.
        /// </summary>
        /// <value>The album.</value>
        [JsonIgnore]
        public string Album { get; set; }

        /// <summary>
        /// Gets or sets the channel identifier.
        /// </summary>
        /// <value>The channel identifier.</value>
        [JsonIgnore]
        public Guid ChannelId { get; set; }

        [JsonIgnore]
        public virtual bool SupportsAddingToPlaylist => false;

        [JsonIgnore]
        public virtual bool AlwaysScanInternalMetadataPath => false;

        /// <summary>
        /// Gets a value indicating whether this instance is in mixed folder.
        /// </summary>
        /// <value><c>true</c> if this instance is in mixed folder; otherwise, <c>false</c>.</value>
        [JsonIgnore]
        public bool IsInMixedFolder { get; set; }

        [JsonIgnore]
        public virtual bool SupportsPlayedStatus => false;

        [JsonIgnore]
        public virtual bool SupportsPositionTicksResume => false;

        [JsonIgnore]
        public virtual bool SupportsRemoteImageDownloading => true;

        private string _name;

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        [JsonIgnore]
        public virtual string Name
        {
            get => _name;
            set
            {
                _name = value;

                // lazy load this again
                _sortName = null;
            }
        }

        [JsonIgnore]
        public bool IsUnaired => PremiereDate.HasValue && PremiereDate.Value.ToLocalTime().Date >= DateTime.Now.Date;

        [JsonIgnore]
        public int? TotalBitrate { get; set; }

        [JsonIgnore]
        public ExtraType? ExtraType { get; set; }

        [JsonIgnore]
        public bool IsThemeMedia => ExtraType.HasValue && (ExtraType.Value == Model.Entities.ExtraType.ThemeSong || ExtraType.Value == Model.Entities.ExtraType.ThemeVideo);

        [JsonIgnore]
        public string OriginalTitle { get; set; }

        /// <summary>
        /// Gets or sets the id.
        /// </summary>
        /// <value>The id.</value>
        [JsonIgnore]
        public Guid Id { get; set; }

        [JsonIgnore]
        public Guid OwnerId { get; set; }

        /// <summary>
        /// Gets or sets the audio.
        /// </summary>
        /// <value>The audio.</value>
        [JsonIgnore]
        public ProgramAudio? Audio { get; set; }

        /// <summary>
        /// Return the id that should be used to key display prefs for this item.
        /// Default is based on the type for everything except actual generic folders.
        /// </summary>
        /// <value>The display prefs id.</value>
        [JsonIgnore]
        public virtual Guid DisplayPreferencesId
        {
            get
            {
                var thisType = GetType();
                return thisType == typeof(Folder) ? Id : thisType.FullName.GetMD5();
            }
        }

        /// <summary>
        /// Gets or sets the path.
        /// </summary>
        /// <value>The path.</value>
        [JsonIgnore]
        public virtual string Path { get; set; }

        [JsonIgnore]
        public virtual SourceType SourceType
        {
            get
            {
                if (!ChannelId.Equals(Guid.Empty))
                {
                    return SourceType.Channel;
                }

                return SourceType.Library;
            }
        }

        /// <summary>
        /// Returns the folder containing the item.
        /// If the item is a folder, it returns the folder itself.
        /// </summary>
        [JsonIgnore]
        public virtual string ContainingFolderPath
        {
            get
            {
                if (IsFolder)
                {
                    return Path;
                }

                return System.IO.Path.GetDirectoryName(Path);
            }
        }

        /// <summary>
        /// Gets or sets the name of the service.
        /// </summary>
        /// <value>The name of the service.</value>
        [JsonIgnore]
        public string ServiceName { get; set; }

        /// <summary>
        /// If this content came from an external service, the id of the content on that service.
        /// </summary>
        [JsonIgnore]
        public string ExternalId { get; set; }

        [JsonIgnore]
        public string ExternalSeriesId { get; set; }

        /// <summary>
        /// Gets or sets the etag.
        /// </summary>
        /// <value>The etag.</value>
        [JsonIgnore]
        public string ExternalEtag { get; set; }

        [JsonIgnore]
        public virtual bool IsHidden => false;

        public BaseItem GetOwner()
        {
            var ownerId = OwnerId;
            return ownerId.Equals(Guid.Empty) ? null : LibraryManager.GetItemById(ownerId);
        }

        /// <summary>
        /// Gets or sets the type of the location.
        /// </summary>
        /// <value>The type of the location.</value>
        [JsonIgnore]
        public virtual LocationType LocationType
        {
            get
            {
                // if (IsOffline)
                //{
                //    return LocationType.Offline;
                //}

                var path = Path;
                if (string.IsNullOrEmpty(path))
                {
                    if (SourceType == SourceType.Channel)
                    {
                        return LocationType.Remote;
                    }

                    return LocationType.Virtual;
                }

                return FileSystem.IsPathFile(path) ? LocationType.FileSystem : LocationType.Remote;
            }
        }

        [JsonIgnore]
        public MediaProtocol? PathProtocol
        {
            get
            {
                var path = Path;

                if (string.IsNullOrEmpty(path))
                {
                    return null;
                }

                return MediaSourceManager.GetPathProtocol(path);
            }
        }

        public bool IsPathProtocol(MediaProtocol protocol)
        {
            var current = PathProtocol;

            return current.HasValue && current.Value == protocol;
        }

        [JsonIgnore]
        public bool IsFileProtocol => IsPathProtocol(MediaProtocol.File);

        [JsonIgnore]
        public bool HasPathProtocol => PathProtocol.HasValue;

        [JsonIgnore]
        public virtual bool SupportsLocalMetadata
        {
            get
            {
                if (SourceType == SourceType.Channel)
                {
                    return false;
                }

                return IsFileProtocol;
            }
        }

        [JsonIgnore]
        public virtual string FileNameWithoutExtension
        {
            get
            {
                if (IsFileProtocol)
                {
                    return System.IO.Path.GetFileNameWithoutExtension(Path);
                }

                return null;
            }
        }

        [JsonIgnore]
        public virtual bool EnableAlphaNumericSorting => true;

        private List<Tuple<StringBuilder, bool>> GetSortChunks(string s1)
        {
            var list = new List<Tuple<StringBuilder, bool>>();

            int thisMarker = 0;

            while (thisMarker < s1.Length)
            {
                char thisCh = s1[thisMarker];

                var thisChunk = new StringBuilder();
                bool isNumeric = char.IsDigit(thisCh);

                while (thisMarker < s1.Length && char.IsDigit(thisCh) == isNumeric)
                {
                    thisChunk.Append(thisCh);
                    thisMarker++;

                    if (thisMarker < s1.Length)
                    {
                        thisCh = s1[thisMarker];
                    }
                }

                list.Add(new Tuple<StringBuilder, bool>(thisChunk, isNumeric));
            }

            return list;
        }

        /// <summary>
        /// This is just a helper for convenience.
        /// </summary>
        /// <value>The primary image path.</value>
        [JsonIgnore]
        public string PrimaryImagePath => this.GetImagePath(ImageType.Primary);

        public virtual bool CanDelete()
        {
            if (SourceType == SourceType.Channel)
            {
                return ChannelManager.CanDelete(this);
            }

            return IsFileProtocol;
        }

        public virtual bool IsAuthorizedToDelete(User user, List<Folder> allCollectionFolders)
        {
            if (user.HasPermission(PermissionKind.EnableContentDeletion))
            {
                return true;
            }

            var allowed = user.GetPreferenceValues<Guid>(PreferenceKind.EnableContentDeletionFromFolders);

            if (SourceType == SourceType.Channel)
            {
                return allowed.Contains(ChannelId);
            }
            else
            {
                var collectionFolders = LibraryManager.GetCollectionFolders(this, allCollectionFolders);

                foreach (var folder in collectionFolders)
                {
                    if (allowed.Contains(folder.Id))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public bool CanDelete(User user, List<Folder> allCollectionFolders)
        {
            return CanDelete() && IsAuthorizedToDelete(user, allCollectionFolders);
        }

        public bool CanDelete(User user)
        {
            var allCollectionFolders = LibraryManager.GetUserRootFolder().Children.OfType<Folder>().ToList();

            return CanDelete(user, allCollectionFolders);
        }

        public virtual bool CanDownload()
        {
            return false;
        }

        public virtual bool IsAuthorizedToDownload(User user)
        {
            return user.HasPermission(PermissionKind.EnableContentDownloading);
        }

        public bool CanDownload(User user)
        {
            return CanDownload() && IsAuthorizedToDownload(user);
        }

        /// <summary>
        /// Gets or sets the date created.
        /// </summary>
        /// <value>The date created.</value>
        [JsonIgnore]
        public DateTime DateCreated { get; set; }

        /// <summary>
        /// Gets or sets the date modified.
        /// </summary>
        /// <value>The date modified.</value>
        [JsonIgnore]
        public DateTime DateModified { get; set; }

        public DateTime DateLastSaved { get; set; }

        [JsonIgnore]
        public DateTime DateLastRefreshed { get; set; }

        /// <summary>
        /// The logger.
        /// </summary>
        public static ILogger<BaseItem> Logger { get; set; }

        public static ILibraryManager LibraryManager { get; set; }

        public static IServerConfigurationManager ConfigurationManager { get; set; }

        public static IProviderManager ProviderManager { get; set; }

        public static ILocalizationManager LocalizationManager { get; set; }

        public static IItemRepository ItemRepository { get; set; }

        public static IFileSystem FileSystem { get; set; }

        public static IUserDataManager UserDataManager { get; set; }

        public static IChannelManager ChannelManager { get; set; }

        public static IMediaSourceManager MediaSourceManager { get; set; }

        /// <summary>
        /// Returns a <see cref="string" /> that represents this instance.
        /// </summary>
        /// <returns>A <see cref="string" /> that represents this instance.</returns>
        public override string ToString()
        {
            return Name;
        }

        [JsonIgnore]
        public bool IsLocked { get; set; }

        /// <summary>
        /// Gets or sets the locked fields.
        /// </summary>
        /// <value>The locked fields.</value>
        [JsonIgnore]
        public MetadataField[] LockedFields { get; set; }

        /// <summary>
        /// Gets the type of the media.
        /// </summary>
        /// <value>The type of the media.</value>
        [JsonIgnore]
        public virtual string MediaType => null;

        [JsonIgnore]
        public virtual string[] PhysicalLocations
        {
            get
            {
                if (!IsFileProtocol)
                {
                    return Array.Empty<string>();
                }

                return new[] { Path };
            }
        }

        private string _forcedSortName;

        /// <summary>
        /// Gets or sets the name of the forced sort.
        /// </summary>
        /// <value>The name of the forced sort.</value>
        [JsonIgnore]
        public string ForcedSortName
        {
            get => _forcedSortName;
            set { _forcedSortName = value; _sortName = null; }
        }

        private string _sortName;
        private Guid[] _themeSongIds;
        private Guid[] _themeVideoIds;

        /// <summary>
        /// Gets the name of the sort.
        /// </summary>
        /// <value>The name of the sort.</value>
        [JsonIgnore]
        public string SortName
        {
            get
            {
                if (_sortName == null)
                {
                    if (!string.IsNullOrEmpty(ForcedSortName))
                    {
                        // Need the ToLower because that's what CreateSortName does
                        _sortName = ModifySortChunks(ForcedSortName).ToLowerInvariant();
                    }
                    else
                    {
                        _sortName = CreateSortName();
                    }
                }

                return _sortName;
            }

            set => _sortName = value;
        }

        public string GetInternalMetadataPath()
        {
            var basePath = ConfigurationManager.ApplicationPaths.InternalMetadataPath;

            return GetInternalMetadataPath(basePath);
        }

        protected virtual string GetInternalMetadataPath(string basePath)
        {
            if (SourceType == SourceType.Channel)
            {
                return System.IO.Path.Combine(basePath, "channels", ChannelId.ToString("N", CultureInfo.InvariantCulture), Id.ToString("N", CultureInfo.InvariantCulture));
            }

            ReadOnlySpan<char> idString = Id.ToString("N", CultureInfo.InvariantCulture);

            basePath = System.IO.Path.Combine(basePath, "library");

            return System.IO.Path.Join(basePath, idString.Slice(0, 2), idString);
        }

        /// <summary>
        /// Creates the name of the sort.
        /// </summary>
        /// <returns>System.String.</returns>
        protected virtual string CreateSortName()
        {
            if (Name == null)
            {
                return null; // some items may not have name filled in properly
            }

            if (!EnableAlphaNumericSorting)
            {
                return Name.TrimStart();
            }

            var sortable = Name.Trim().ToLowerInvariant();

            foreach (var removeChar in ConfigurationManager.Configuration.SortRemoveCharacters)
            {
                sortable = sortable.Replace(removeChar, string.Empty, StringComparison.Ordinal);
            }

            foreach (var replaceChar in ConfigurationManager.Configuration.SortReplaceCharacters)
            {
                sortable = sortable.Replace(replaceChar, " ", StringComparison.Ordinal);
            }

            foreach (var search in ConfigurationManager.Configuration.SortRemoveWords)
            {
                // Remove from beginning if a space follows
                if (sortable.StartsWith(search + " ", StringComparison.Ordinal))
                {
                    sortable = sortable.Remove(0, search.Length + 1);
                }

                // Remove from middle if surrounded by spaces
                sortable = sortable.Replace(" " + search + " ", " ", StringComparison.Ordinal);

                // Remove from end if followed by a space
                if (sortable.EndsWith(" " + search, StringComparison.Ordinal))
                {
                    sortable = sortable.Remove(sortable.Length - (search.Length + 1));
                }
            }

            return ModifySortChunks(sortable);
        }

        private string ModifySortChunks(string name)
        {
            var chunks = GetSortChunks(name);

            var builder = new StringBuilder();

            foreach (var chunk in chunks)
            {
                var chunkBuilder = chunk.Item1;

                // This chunk is numeric
                if (chunk.Item2)
                {
                    while (chunkBuilder.Length < 10)
                    {
                        chunkBuilder.Insert(0, '0');
                    }
                }

                builder.Append(chunkBuilder);
            }

            // logger.LogDebug("ModifySortChunks Start: {0} End: {1}", name, builder.ToString());
            return builder.ToString().RemoveDiacritics();
        }

        [JsonIgnore]
        public bool EnableMediaSourceDisplay
        {
            get
            {
                if (SourceType == SourceType.Channel)
                {
                    return ChannelManager.EnableMediaSourceDisplay(this);
                }

                return true;
            }
        }

        [JsonIgnore]
        public Guid ParentId { get; set; }

        /// <summary>
        /// Gets or sets the parent.
        /// </summary>
        /// <value>The parent.</value>
        [JsonIgnore]
        public Folder Parent
        {
            get => GetParent() as Folder;
            set
            {
            }
        }

        public void SetParent(Folder parent)
        {
            ParentId = parent == null ? Guid.Empty : parent.Id;
        }

        public BaseItem GetParent()
        {
            var parentId = ParentId;
            if (!parentId.Equals(Guid.Empty))
            {
                return LibraryManager.GetItemById(parentId);
            }

            return null;
        }

        public IEnumerable<BaseItem> GetParents()
        {
            var parent = GetParent();

            while (parent != null)
            {
                yield return parent;

                parent = parent.GetParent();
            }
        }

        /// <summary>
        /// Finds a parent of a given type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns>``0.</returns>
        public T FindParent<T>()
            where T : Folder
        {
            foreach (var parent in GetParents())
            {
                if (parent is T item)
                {
                    return item;
                }
            }

            return null;
        }

        [JsonIgnore]
        public virtual Guid DisplayParentId
        {
            get
            {
                var parentId = ParentId;
                return parentId;
            }
        }

        [JsonIgnore]
        public BaseItem DisplayParent
        {
            get
            {
                var id = DisplayParentId;
                if (id.Equals(Guid.Empty))
                {
                    return null;
                }

                return LibraryManager.GetItemById(id);
            }
        }

        /// <summary>
        /// When the item first debuted. For movies this could be premiere date, episodes would be first aired
        /// </summary>
        /// <value>The premiere date.</value>
        [JsonIgnore]
        public DateTime? PremiereDate { get; set; }

        /// <summary>
        /// Gets or sets the end date.
        /// </summary>
        /// <value>The end date.</value>
        [JsonIgnore]
        public DateTime? EndDate { get; set; }

        /// <summary>
        /// Gets or sets the official rating.
        /// </summary>
        /// <value>The official rating.</value>
        [JsonIgnore]
        public string OfficialRating { get; set; }

        [JsonIgnore]
        public int InheritedParentalRatingValue { get; set; }

        /// <summary>
        /// Gets or sets the critic rating.
        /// </summary>
        /// <value>The critic rating.</value>
        [JsonIgnore]
        public float? CriticRating { get; set; }

        /// <summary>
        /// Gets or sets the custom rating.
        /// </summary>
        /// <value>The custom rating.</value>
        [JsonIgnore]
        public string CustomRating { get; set; }

        /// <summary>
        /// Gets or sets the overview.
        /// </summary>
        /// <value>The overview.</value>
        [JsonIgnore]
        public string Overview { get; set; }

        /// <summary>
        /// Gets or sets the studios.
        /// </summary>
        /// <value>The studios.</value>
        [JsonIgnore]
        public string[] Studios { get; set; }

        /// <summary>
        /// Gets or sets the genres.
        /// </summary>
        /// <value>The genres.</value>
        [JsonIgnore]
        public string[] Genres { get; set; }

        /// <summary>
        /// Gets or sets the tags.
        /// </summary>
        /// <value>The tags.</value>
        [JsonIgnore]
        public string[] Tags { get; set; }

        [JsonIgnore]
        public string[] ProductionLocations { get; set; }

        /// <summary>
        /// Gets or sets the home page URL.
        /// </summary>
        /// <value>The home page URL.</value>
        [JsonIgnore]
        public string HomePageUrl { get; set; }

        /// <summary>
        /// Gets or sets the community rating.
        /// </summary>
        /// <value>The community rating.</value>
        [JsonIgnore]
        public float? CommunityRating { get; set; }

        /// <summary>
        /// Gets or sets the run time ticks.
        /// </summary>
        /// <value>The run time ticks.</value>
        [JsonIgnore]
        public long? RunTimeTicks { get; set; }

        /// <summary>
        /// Gets or sets the production year.
        /// </summary>
        /// <value>The production year.</value>
        [JsonIgnore]
        public int? ProductionYear { get; set; }

        /// <summary>
        /// If the item is part of a series, this is it's number in the series.
        /// This could be episode number, album track number, etc.
        /// </summary>
        /// <value>The index number.</value>
        [JsonIgnore]
        public int? IndexNumber { get; set; }

        /// <summary>
        /// For an episode this could be the season number, or for a song this could be the disc number.
        /// </summary>
        /// <value>The parent index number.</value>
        [JsonIgnore]
        public int? ParentIndexNumber { get; set; }

        [JsonIgnore]
        public virtual bool HasLocalAlternateVersions => false;

        [JsonIgnore]
        public string OfficialRatingForComparison
        {
            get
            {
                var officialRating = OfficialRating;
                if (!string.IsNullOrEmpty(officialRating))
                {
                    return officialRating;
                }

                var parent = DisplayParent;
                if (parent != null)
                {
                    return parent.OfficialRatingForComparison;
                }

                return null;
            }
        }

        [JsonIgnore]
        public string CustomRatingForComparison
        {
            get
            {
                var customRating = CustomRating;
                if (!string.IsNullOrEmpty(customRating))
                {
                    return customRating;
                }

                var parent = DisplayParent;
                if (parent != null)
                {
                    return parent.CustomRatingForComparison;
                }

                return null;
            }
        }

        /// <summary>
        /// Gets the play access.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns>PlayAccess.</returns>
        public PlayAccess GetPlayAccess(User user)
        {
            if (!user.HasPermission(PermissionKind.EnableMediaPlayback))
            {
                return PlayAccess.None;
            }

            // if (!user.IsParentalScheduleAllowed())
            //{
            //    return PlayAccess.None;
            //}

            return PlayAccess.Full;
        }

        public virtual List<MediaStream> GetMediaStreams()
        {
            return MediaSourceManager.GetMediaStreams(new MediaStreamQuery
            {
                ItemId = Id
            });
        }

        protected virtual bool IsActiveRecording()
        {
            return false;
        }

        public virtual List<MediaSourceInfo> GetMediaSources(bool enablePathSubstitution)
        {
            if (SourceType == SourceType.Channel)
            {
                var sources = ChannelManager.GetStaticMediaSources(this, CancellationToken.None)
                           .ToList();

                if (sources.Count > 0)
                {
                    return sources;
                }
            }

            var list = GetAllItemsForMediaSources();
            var result = list.Select(i => GetVersionInfo(enablePathSubstitution, i.Item1, i.Item2)).ToList();

            if (IsActiveRecording())
            {
                foreach (var mediaSource in result)
                {
                    mediaSource.Type = MediaSourceType.Placeholder;
                }
            }

            return result.OrderBy(i =>
            {
                if (i.VideoType == VideoType.VideoFile)
                {
                    return 0;
                }

                return 1;
            }).ThenBy(i => i.Video3DFormat.HasValue ? 1 : 0)
            .ThenByDescending(i =>
            {
                var stream = i.VideoStream;

                return stream == null || stream.Width == null ? 0 : stream.Width.Value;
            })
            .ToList();
        }

        protected virtual List<Tuple<BaseItem, MediaSourceType>> GetAllItemsForMediaSources()
        {
            return new List<Tuple<BaseItem, MediaSourceType>>();
        }

        private MediaSourceInfo GetVersionInfo(bool enablePathSubstitution, BaseItem item, MediaSourceType type)
        {
            if (item == null)
            {
                throw new ArgumentNullException(nameof(item));
            }

            var protocol = item.PathProtocol;

            var info = new MediaSourceInfo
            {
                Id = item.Id.ToString("N", CultureInfo.InvariantCulture),
                Protocol = protocol ?? MediaProtocol.File,
                MediaStreams = MediaSourceManager.GetMediaStreams(item.Id),
                MediaAttachments = MediaSourceManager.GetMediaAttachments(item.Id),
                Name = GetMediaSourceName(item),
                Path = enablePathSubstitution ? GetMappedPath(item, item.Path, protocol) : item.Path,
                RunTimeTicks = item.RunTimeTicks,
                Container = item.Container,
                Size = item.Size,
                Type = type
            };

            if (string.IsNullOrEmpty(info.Path))
            {
                info.Type = MediaSourceType.Placeholder;
            }

            if (info.Protocol == MediaProtocol.File)
            {
                info.ETag = item.DateModified.Ticks.ToString(CultureInfo.InvariantCulture).GetMD5().ToString("N", CultureInfo.InvariantCulture);
            }

            if (item is Video video)
            {
                info.IsoType = video.IsoType;
                info.VideoType = video.VideoType;
                info.Video3DFormat = video.Video3DFormat;
                info.Timestamp = video.Timestamp;

                if (video.IsShortcut)
                {
                    info.IsRemote = true;
                    info.Path = video.ShortcutPath;
                    info.Protocol = MediaSourceManager.GetPathProtocol(info.Path);
                }

                if (string.IsNullOrEmpty(info.Container))
                {
                    if (video.VideoType == VideoType.VideoFile || video.VideoType == VideoType.Iso)
                    {
                        if (protocol.HasValue && protocol.Value == MediaProtocol.File)
                        {
                            info.Container = System.IO.Path.GetExtension(item.Path).TrimStart('.');
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(info.Container))
            {
                if (protocol.HasValue && protocol.Value == MediaProtocol.File)
                {
                    info.Container = System.IO.Path.GetExtension(item.Path).TrimStart('.');
                }
            }

            if (info.SupportsDirectStream && !string.IsNullOrEmpty(info.Path))
            {
                info.SupportsDirectStream = MediaSourceManager.SupportsDirectStream(info.Path, info.Protocol);
            }

            if (item is Video video && video.VideoType != VideoType.VideoFile)
            {
                info.SupportsDirectStream = false;
            }

            info.Bitrate = item.TotalBitrate;
            info.InferTotalBitrate();

            return info;
        }

        private string GetMediaSourceName(BaseItem item)
        {
            var terms = new List<string>();

            var path = item.Path;
            if (item.IsFileProtocol && !string.IsNullOrEmpty(path))
            {
                if (HasLocalAlternateVersions)
                {
                    var displayName = System.IO.Path.GetFileNameWithoutExtension(path)
                        .Replace(System.IO.Path.GetFileName(ContainingFolderPath), string.Empty, StringComparison.OrdinalIgnoreCase)
                        .TrimStart(new char[] { ' ', '-' });

                    if (!string.IsNullOrEmpty(displayName))
                    {
                        terms.Add(displayName);
                    }
                }

                if (terms.Count == 0)
                {
                    var displayName = System.IO.Path.GetFileNameWithoutExtension(path);
                    terms.Add(displayName);
                }
            }

            if (terms.Count == 0)
            {
                terms.Add(item.Name);
            }

            if (item is Video video)
            {
                if (video.Video3DFormat.HasValue)
                {
                    terms.Add("3D");
                }

                if (video.VideoType == VideoType.BluRay)
                {
                    terms.Add("Bluray");
                }
                else if (video.VideoType == VideoType.Dvd)
                {
                    terms.Add("DVD");
                }
                else if (video.VideoType == VideoType.Iso)
                {
                    if (video.IsoType.HasValue)
                    {
                        if (video.IsoType.Value == IsoType.BluRay)
                        {
                            terms.Add("Bluray");
                        }
                        else if (video.IsoType.Value == IsoType.Dvd)
                        {
                            terms.Add("DVD");
                        }
                    }
                    else
                    {
                        terms.Add("ISO");
                    }
                }
            }

            return string.Join('/', terms.ToArray());
        }

        /// <summary>
        /// Loads the theme songs.
        /// </summary>
        /// <returns>List{Audio.Audio}.</returns>
        private static Audio.Audio[] LoadThemeSongs(List<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var files = fileSystemChildren.Where(i => i.IsDirectory)
                .Where(i => string.Equals(i.Name, ThemeSongsFolderName, StringComparison.OrdinalIgnoreCase))
                .SelectMany(i => FileSystem.GetFiles(i.FullName))
                .ToList();

            // Support plex/xbmc convention
            files.AddRange(fileSystemChildren
                .Where(i => !i.IsDirectory && string.Equals(FileSystem.GetFileNameWithoutExtension(i), ThemeSongFilename, StringComparison.OrdinalIgnoreCase)));

            return LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                .OfType<Audio.Audio>()
                .Select(audio =>
                {
                    // Try to retrieve it from the db. If we don't find it, use the resolved version

                    if (LibraryManager.GetItemById(audio.Id) is Audio.Audio dbItem)
                    {
                        audio = dbItem;
                    }
                    else
                    {
                        // item is new
                        audio.ExtraType = MediaBrowser.Model.Entities.ExtraType.ThemeSong;
                    }

                    return audio;

                    // Sort them so that the list can be easily compared for changes
                }).OrderBy(i => i.Path).ToArray();
        }

        /// <summary>
        /// Loads the video backdrops.
        /// </summary>
        /// <returns>List{Video}.</returns>
        private static Video[] LoadThemeVideos(IEnumerable<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var files = fileSystemChildren.Where(i => i.IsDirectory)
                .Where(i => string.Equals(i.Name, ThemeVideosFolderName, StringComparison.OrdinalIgnoreCase))
                .SelectMany(i => FileSystem.GetFiles(i.FullName));

            return LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                .OfType<Video>()
                .Select(item =>
                {
                    // Try to retrieve it from the db. If we don't find it, use the resolved version

                    if (LibraryManager.GetItemById(item.Id) is Video dbItem)
                    {
                        item = dbItem;
                    }
                    else
                    {
                        // item is new
                        item.ExtraType = Model.Entities.ExtraType.ThemeVideo;
                    }

                    return item;

                    // Sort them so that the list can be easily compared for changes
                }).OrderBy(i => i.Path).ToArray();
        }

        protected virtual BaseItem[] LoadExtras(List<FileSystemMetadata> fileSystemChildren, IDirectoryService directoryService)
        {
            var extras = new List<Video>();

            var folders = fileSystemChildren.Where(i => i.IsDirectory).ToArray();
            foreach (var extraFolderName in AllExtrasTypesFolderNames)
            {
                var files = folders
                    .Where(i => string.Equals(i.Name, extraFolderName, StringComparison.OrdinalIgnoreCase))
                    .SelectMany(i => FileSystem.GetFiles(i.FullName));

                extras.AddRange(LibraryManager.ResolvePaths(files, directoryService, null, new LibraryOptions())
                    .OfType<Video>()
                    .Select(item =>
                    {
                        // Try to retrieve it from the db. If we don't find it, use the resolved version
                        if (LibraryManager.GetItemById(item.Id) is Video dbItem)
                        {
                            item = dbItem;
                        }

                        // Use some hackery to get the extra type based on foldername
                        item.ExtraType = Enum.TryParse(extraFolderName.Replace(" ", string.Empty), true, out ExtraType extraType)
                            ? extraType
                            : Model.Entities.ExtraType.Unknown;

                        return item;

                        // Sort them so that the list can be easily compared for changes
                    }).OrderBy(i => i.Path));
            }

            return extras.ToArray();
        }

        public Task RefreshMetadata(CancellationToken cancellationToken)
        {
            return RefreshMetadata(new MetadataRefreshOptions(new DirectoryService(FileSystem)), cancellationToken);
        }

        protected virtual void TriggerOnRefreshStart()
        {
        }

        protected virtual void TriggerOnRefreshComplete()
        {
        }

        /// <summary>
        /// Overrides the base implementation to refresh metadata for local trailers.
        /// </summary>
        /// <param name="options">The options.</param>
        /// <param name="cancellationToken">The cancellation token.</param>
        /// <returns>true if a provider reports we changed.</returns>
        public async Task<ItemUpdateType> RefreshMetadata(MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            TriggerOnRefreshStart();

            var requiresSave = false;

            if (SupportsOwnedItems)
            {
                try
                {
                    var files = IsFileProtocol ?
                        GetFileSystemChildren(options.DirectoryService).ToList() :
                        new List<FileSystemMetadata>();

                    var ownedItemsChanged = await RefreshedOwnedItems(options, files, cancellationToken).ConfigureAwait(false);
                    await LibraryManager.UpdateImagesAsync(this).ConfigureAwait(false); // ensure all image properties in DB are fresh

                    if (ownedItemsChanged)
                    {
                        requiresSave = true;
                    }
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error refreshing owned items for {path}", Path ?? Name);
                }
            }

            try
            {
                var refreshOptions = requiresSave
                    ? new MetadataRefreshOptions(options)
                    {
                        ForceSave = true
                    }
                    : options;

                return await ProviderManager.RefreshSingleItem(this, refreshOptions, cancellationToken).ConfigureAwait(false);
            }
            finally
            {
                TriggerOnRefreshComplete();
            }
        }

        [JsonIgnore]
        protected virtual bool SupportsOwnedItems => !ParentId.Equals(Guid.Empty) && IsFileProtocol;

        [JsonIgnore]
        public virtual bool SupportsPeople => false;

        [JsonIgnore]
        public virtual bool SupportsThemeMedia => false;

        /// <summary>
        /// Refreshes owned items such as trailers, theme videos, special features, etc.
        /// Returns true or false indicating if changes were found.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="fileSystemChildren"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        protected virtual async Task<bool> RefreshedOwnedItems(MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var themeSongsChanged = false;

            var themeVideosChanged = false;

            var extrasChanged = false;

            var localTrailersChanged = false;

            if (IsFileProtocol && SupportsOwnedItems)
            {
                if (SupportsThemeMedia)
                {
                    if (!IsInMixedFolder)
                    {
                        themeSongsChanged = await RefreshThemeSongs(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);

                        themeVideosChanged = await RefreshThemeVideos(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);

                        extrasChanged = await RefreshExtras(this, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);
                    }
                }

                if (this is IHasTrailers hasTrailers)
                {
                    localTrailersChanged = await RefreshLocalTrailers(hasTrailers, options, fileSystemChildren, cancellationToken).ConfigureAwait(false);
                }
            }

            return themeSongsChanged || themeVideosChanged || extrasChanged || localTrailersChanged;
        }

        protected virtual FileSystemMetadata[] GetFileSystemChildren(IDirectoryService directoryService)
        {
            var path = ContainingFolderPath;

            return directoryService.GetFileSystemEntries(path);
        }

        private async Task<bool> RefreshLocalTrailers(IHasTrailers item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newItems = LibraryManager.FindTrailers(this, fileSystemChildren, options.DirectoryService);

            var newItemIds = newItems.Select(i => i.Id);

            var itemsChanged = !item.LocalTrailerIds.SequenceEqual(newItemIds);
            var ownerId = item.Id;

            var tasks = newItems.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (i.ExtraType != Model.Entities.ExtraType.Trailer ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.Trailer;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            item.LocalTrailerIds = newItemIds.ToArray();

            return itemsChanged;
        }

        private async Task<bool> RefreshExtras(BaseItem item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var extras = LoadExtras(fileSystemChildren, options.DirectoryService);
            var themeVideos = LoadThemeVideos(fileSystemChildren, options.DirectoryService);
            var themeSongs = LoadThemeSongs(fileSystemChildren, options.DirectoryService);
            var newExtras = new BaseItem[extras.Length + themeVideos.Length + themeSongs.Length];
            extras.CopyTo(newExtras, 0);
            themeVideos.CopyTo(newExtras, extras.Length);
            themeSongs.CopyTo(newExtras, extras.Length + themeVideos.Length);

            var newExtraIds = newExtras.Select(i => i.Id).ToArray();

            var extrasChanged = !item.ExtraIds.SequenceEqual(newExtraIds);

            if (extrasChanged)
            {
                var ownerId = item.Id;

                var tasks = newExtras.Select(i =>
                {
                    var subOptions = new MetadataRefreshOptions(options);
                    if (i.OwnerId != ownerId || i.ParentId != Guid.Empty)
                    {
                        i.OwnerId = ownerId;
                        i.ParentId = Guid.Empty;
                        subOptions.ForceSave = true;
                    }

                    return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
                });

                await Task.WhenAll(tasks).ConfigureAwait(false);

                item.ExtraIds = newExtraIds;
            }

            return extrasChanged;
        }

        private async Task<bool> RefreshThemeVideos(BaseItem item, MetadataRefreshOptions options, IEnumerable<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newThemeVideos = LoadThemeVideos(fileSystemChildren, options.DirectoryService);

            var newThemeVideoIds = newThemeVideos.Select(i => i.Id).ToArray();

            var themeVideosChanged = !item.ThemeVideoIds.SequenceEqual(newThemeVideoIds);

            var ownerId = item.Id;

            var tasks = newThemeVideos.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (!i.ExtraType.HasValue ||
                    i.ExtraType.Value != Model.Entities.ExtraType.ThemeVideo ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.ThemeVideo;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            // They are expected to be sorted by SortName
            item.ThemeVideoIds = newThemeVideos.OrderBy(i => i.SortName).Select(i => i.Id).ToArray();

            return themeVideosChanged;
        }

        /// <summary>
        /// Refreshes the theme songs.
        /// </summary>
        private async Task<bool> RefreshThemeSongs(BaseItem item, MetadataRefreshOptions options, List<FileSystemMetadata> fileSystemChildren, CancellationToken cancellationToken)
        {
            var newThemeSongs = LoadThemeSongs(fileSystemChildren, options.DirectoryService);
            var newThemeSongIds = newThemeSongs.Select(i => i.Id).ToArray();

            var themeSongsChanged = !item.ThemeSongIds.SequenceEqual(newThemeSongIds);

            var ownerId = item.Id;

            var tasks = newThemeSongs.Select(i =>
            {
                var subOptions = new MetadataRefreshOptions(options);

                if (!i.ExtraType.HasValue ||
                    i.ExtraType.Value != Model.Entities.ExtraType.ThemeSong ||
                    i.OwnerId != ownerId ||
                    !i.ParentId.Equals(Guid.Empty))
                {
                    i.ExtraType = Model.Entities.ExtraType.ThemeSong;
                    i.OwnerId = ownerId;
                    i.ParentId = Guid.Empty;
                    subOptions.ForceSave = true;
                }

                return RefreshMetadataForOwnedItem(i, true, subOptions, cancellationToken);
            });

            await Task.WhenAll(tasks).ConfigureAwait(false);

            // They are expected to be sorted by SortName
            item.ThemeSongIds = newThemeSongs.OrderBy(i => i.SortName).Select(i => i.Id).ToArray();

            return themeSongsChanged;
        }

        /// <summary>
        /// Gets or sets the provider ids.
        /// </summary>
        /// <value>The provider ids.</value>
        [JsonIgnore]
        public Dictionary<string, string> ProviderIds { get; set; }

        [JsonIgnore]
        public virtual Folder LatestItemsIndexContainer => null;

        public virtual double GetDefaultPrimaryImageAspectRatio()
        {
            return 0;
        }

        public virtual string CreatePresentationUniqueKey()
        {
            return Id.ToString("N", CultureInfo.InvariantCulture);
        }

        [JsonIgnore]
        public string PresentationUniqueKey { get; set; }

        public string GetPresentationUniqueKey()
        {
            return PresentationUniqueKey ?? CreatePresentationUniqueKey();
        }

        public virtual bool RequiresRefresh()
        {
            return false;
        }

        public virtual List<string> GetUserDataKeys()
        {
            var list = new List<string>();

            if (SourceType == SourceType.Channel)
            {
                if (!string.IsNullOrEmpty(ExternalId))
                {
                    list.Add(ExternalId);
                }
            }

            list.Add(Id.ToString());
            return list;
        }

        internal virtual ItemUpdateType UpdateFromResolvedItem(BaseItem newItem)
        {
            var updateType = ItemUpdateType.None;

            if (IsInMixedFolder != newItem.IsInMixedFolder)
            {
                IsInMixedFolder = newItem.IsInMixedFolder;
                updateType |= ItemUpdateType.MetadataImport;
            }

            return updateType;
        }

        public void AfterMetadataRefresh()
        {
            _sortName = null;
        }

        /// <summary>
        /// Gets the preferred metadata language.
        /// </summary>
        /// <returns>System.String.</returns>
        public string GetPreferredMetadataLanguage()
        {
            string lang = PreferredMetadataLanguage;

            if (string.IsNullOrEmpty(lang))
            {
                lang = GetParents()
                    .Select(i => i.PreferredMetadataLanguage)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetCollectionFolders(this)
                    .Select(i => i.PreferredMetadataLanguage)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetLibraryOptions(this).PreferredMetadataLanguage;
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = ConfigurationManager.Configuration.PreferredMetadataLanguage;
            }

            return lang;
        }

        /// <summary>
        /// Gets the preferred metadata language.
        /// </summary>
        /// <returns>System.String.</returns>
        public string GetPreferredMetadataCountryCode()
        {
            string lang = PreferredMetadataCountryCode;

            if (string.IsNullOrEmpty(lang))
            {
                lang = GetParents()
                    .Select(i => i.PreferredMetadataCountryCode)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetCollectionFolders(this)
                    .Select(i => i.PreferredMetadataCountryCode)
                    .FirstOrDefault(i => !string.IsNullOrEmpty(i));
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = LibraryManager.GetLibraryOptions(this).MetadataCountryCode;
            }

            if (string.IsNullOrEmpty(lang))
            {
                lang = ConfigurationManager.Configuration.MetadataCountryCode;
            }

            return lang;
        }

        public virtual bool IsSaveLocalMetadataEnabled()
        {
            if (SourceType == SourceType.Channel)
            {
                return false;
            }

            var libraryOptions = LibraryManager.GetLibraryOptions(this);

            return libraryOptions.SaveLocalMetadata;
        }

        /// <summary>
        /// Determines if a given user has access to this item.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns><c>true</c> if [is parental allowed] [the specified user]; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">user</exception>
        public bool IsParentalAllowed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            if (!IsVisibleViaTags(user))
            {
                return false;
            }

            var maxAllowedRating = user.MaxParentalAgeRating;

            if (maxAllowedRating == null)
            {
                return true;
            }

            var rating = CustomRatingForComparison;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRatingForComparison;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return !GetBlockUnratedValue(user);
            }

            var value = LocalizationManager.GetRatingLevel(rating);

            // Could not determine the integer value
            if (!value.HasValue)
            {
                var isAllowed = !GetBlockUnratedValue(user);

                if (!isAllowed)
                {
                    Logger.LogDebug("{0} has an unrecognized parental rating of {1}.", Name, rating);
                }

                return isAllowed;
            }

            return value.Value <= maxAllowedRating.Value;
        }

        public int? GetParentalRatingValue()
        {
            var rating = CustomRating;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRating;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return null;
            }

            return LocalizationManager.GetRatingLevel(rating);
        }

        public int? GetInheritedParentalRatingValue()
        {
            var rating = CustomRatingForComparison;

            if (string.IsNullOrEmpty(rating))
            {
                rating = OfficialRatingForComparison;
            }

            if (string.IsNullOrEmpty(rating))
            {
                return null;
            }

            return LocalizationManager.GetRatingLevel(rating);
        }

        public List<string> GetInheritedTags()
        {
            var list = new List<string>();
            list.AddRange(Tags);

            foreach (var parent in GetParents())
            {
                list.AddRange(parent.Tags);
            }

            return list.Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        }

        private bool IsVisibleViaTags(User user)
        {
            if (user.GetPreference(PreferenceKind.BlockedTags).Any(i => Tags.Contains(i, StringComparer.OrdinalIgnoreCase)))
            {
                return false;
            }

            return true;
        }

        protected virtual bool IsAllowTagFilterEnforced()
        {
            return true;
        }

        public virtual UnratedItem GetBlockUnratedType()
        {
            if (SourceType == SourceType.Channel)
            {
                return UnratedItem.ChannelContent;
            }

            return UnratedItem.Other;
        }

        /// <summary>
        /// Gets the block unrated value.
        /// </summary>
        /// <param name="user">The configuration.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        protected virtual bool GetBlockUnratedValue(User user)
        {
            // Don't block plain folders that are unrated. Let the media underneath get blocked
            // Special folders like series and albums will override this method.
            if (IsFolder || this is IItemByName)
            {
                return false;
            }

            return user.GetPreferenceValues<UnratedItem>(PreferenceKind.BlockUnratedItems).Contains(GetBlockUnratedType());
        }

        /// <summary>
        /// Determines if this folder should be visible to a given user.
        /// Default is just parental allowed. Can be overridden for more functionality.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns><c>true</c> if the specified user is visible; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentNullException">user</exception>
        public virtual bool IsVisible(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            return IsParentalAllowed(user);
        }

        public virtual bool IsVisibleStandalone(User user)
        {
            if (SourceType == SourceType.Channel)
            {
                return IsVisibleStandaloneInternal(user, false) && Channel.IsChannelVisible(this, user);
            }

            return IsVisibleStandaloneInternal(user, true);
        }

        [JsonIgnore]
        public virtual bool SupportsInheritedParentImages => false;

        protected bool IsVisibleStandaloneInternal(User user, bool checkFolders)
        {
            if (!IsVisible(user))
            {
                return false;
            }

            if (GetParents().Any(i => !i.IsVisible(user)))
            {
                return false;
            }

            if (checkFolders)
            {
                var topParent = GetParents().LastOrDefault() ?? this;

                if (string.IsNullOrEmpty(topParent.Path))
                {
                    return true;
                }

                var itemCollectionFolders = LibraryManager.GetCollectionFolders(this).Select(i => i.Id).ToList();

                if (itemCollectionFolders.Count > 0)
                {
                    var userCollectionFolders = LibraryManager.GetUserRootFolder().GetChildren(user, true).Select(i => i.Id).ToList();
                    if (!itemCollectionFolders.Any(userCollectionFolders.Contains))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Gets a value indicating whether this instance is folder.
        /// </summary>
        /// <value><c>true</c> if this instance is folder; otherwise, <c>false</c>.</value>
        [JsonIgnore]
        public virtual bool IsFolder => false;

        [JsonIgnore]
        public virtual bool IsDisplayedAsFolder => false;

        public virtual string GetClientTypeName()
        {
            if (IsFolder && SourceType == SourceType.Channel && !(this is Channel))
            {
                return "ChannelFolderItem";
            }

            return GetType().Name;
        }

        public BaseItemKind GetBaseItemKind()
        {
            return Enum.Parse<BaseItemKind>(GetClientTypeName());
        }

        /// <summary>
        /// Gets the linked child.
        /// </summary>
        /// <param name="info">The info.</param>
        /// <returns>BaseItem.</returns>
        protected BaseItem GetLinkedChild(LinkedChild info)
        {
            // First get using the cached Id
            if (info.ItemId.HasValue)
            {
                if (info.ItemId.Value.Equals(Guid.Empty))
                {
                    return null;
                }

                var itemById = LibraryManager.GetItemById(info.ItemId.Value);

                if (itemById != null)
                {
                    return itemById;
                }
            }

            var item = FindLinkedChild(info);

            // If still null, log
            if (item == null)
            {
                // Don't keep searching over and over
                info.ItemId = Guid.Empty;
            }
            else
            {
                // Cache the id for next time
                info.ItemId = item.Id;
            }

            return item;
        }

        private BaseItem FindLinkedChild(LinkedChild info)
        {
            var path = info.Path;

            if (!string.IsNullOrEmpty(path))
            {
                path = FileSystem.MakeAbsolutePath(ContainingFolderPath, path);

                var itemByPath = LibraryManager.FindByPath(path, null);

                if (itemByPath == null)
                {
                    Logger.LogWarning("Unable to find linked item at path {0}", info.Path);
                }

                return itemByPath;
            }

            if (!string.IsNullOrEmpty(info.LibraryItemId))
            {
                var item = LibraryManager.GetItemById(info.LibraryItemId);

                if (item == null)
                {
                    Logger.LogWarning("Unable to find linked item at path {0}", info.Path);
                }

                return item;
            }

            return null;
        }

        [JsonIgnore]
        public virtual bool EnableRememberingTrackSelections => true;

        /// <summary>
        /// Adds a studio to the item.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddStudio(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException(nameof(name));
            }

            var current = Studios;

            if (!current.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                int curLen = current.Length;
                if (curLen == 0)
                {
                    Studios = new[] { name };
                }
                else
                {
                    var newArr = new string[curLen + 1];
                    current.CopyTo(newArr, 0);
                    newArr[curLen] = name;
                    Studios = newArr;
                }
            }
        }

        public void SetStudios(IEnumerable<string> names)
        {
            Studios = names.Distinct().ToArray();
        }

        /// <summary>
        /// Adds a genre to the item.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddGenre(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException(nameof(name));
            }

            var genres = Genres;
            if (!genres.Contains(name, StringComparer.OrdinalIgnoreCase))
            {
                var list = genres.ToList();
                list.Add(name);
                Genres = list.ToArray();
            }
        }

        /// <summary>
        /// Marks the played.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <param name="datePlayed">The date played.</param>
        /// <param name="resetPosition">if set to <c>true</c> [reset position].</param>
        /// <returns>Task.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public virtual void MarkPlayed(
            User user,
            DateTime? datePlayed,
            bool resetPosition)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = UserDataManager.GetUserData(user, this);

            if (datePlayed.HasValue)
            {
                // Increment
                data.PlayCount++;
            }

            // Ensure it's at least one
            data.PlayCount = Math.Max(data.PlayCount, 1);

            if (resetPosition)
            {
                data.PlaybackPositionTicks = 0;
            }

            data.LastPlayedDate = datePlayed ?? data.LastPlayedDate ?? DateTime.UtcNow;
            data.Played = true;

            UserDataManager.SaveUserData(user.Id, this, data, UserDataSaveReason.TogglePlayed, CancellationToken.None);
        }

        /// <summary>
        /// Marks the unplayed.
        /// </summary>
        /// <param name="user">The user.</param>
        /// <returns>Task.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public virtual void MarkUnplayed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var data = UserDataManager.GetUserData(user, this);

            // I think it is okay to do this here.
            // if this is only called when a user is manually forcing something to un-played
            // then it probably is what we want to do...
            data.PlayCount = 0;
            data.PlaybackPositionTicks = 0;
            data.LastPlayedDate = null;
            data.Played = false;

            UserDataManager.SaveUserData(user.Id, this, data, UserDataSaveReason.TogglePlayed, CancellationToken.None);
        }

        /// <summary>
        /// Do whatever refreshing is necessary when the filesystem pertaining to this item has changed.
        /// </summary>
        public virtual void ChangedExternally()
        {
            ProviderManager.QueueRefresh(Id, new MetadataRefreshOptions(new DirectoryService(FileSystem)), RefreshPriority.High);
        }

        /// <summary>
        /// Gets an image.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns><c>true</c> if the specified type has image; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">Backdrops should be accessed using Item.Backdrops</exception>
        public bool HasImage(ImageType type, int imageIndex)
        {
            return GetImageInfo(type, imageIndex) != null;
        }

        public void SetImage(ItemImageInfo image, int index)
        {
            if (image.Type == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot set chapter images using SetImagePath");
            }

            var existingImage = GetImageInfo(image.Type, index);

            if (existingImage != null)
            {
                existingImage.Path = image.Path;
                existingImage.DateModified = image.DateModified;
                existingImage.Width = image.Width;
                existingImage.Height = image.Height;
                existingImage.BlurHash = image.BlurHash;
            }
            else
            {
                var current = ImageInfos;
                var currentCount = current.Length;
                var newArr = new ItemImageInfo[currentCount + 1];
                current.CopyTo(newArr, 0);
                newArr[currentCount] = image;
                ImageInfos = newArr;
            }
        }

        public void SetImagePath(ImageType type, int index, FileSystemMetadata file)
        {
            if (type == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot set chapter images using SetImagePath");
            }

            var image = GetImageInfo(type, index);

            if (image == null)
            {
                ImageInfos = ImageInfos.Concat(new[] { GetImageInfo(file, type) }).ToArray();
            }
            else
            {
                var imageInfo = GetImageInfo(file, type);

                image.Path = file.FullName;
                image.DateModified = imageInfo.DateModified;

                // reset these values
                image.Width = 0;
                image.Height = 0;
            }
        }

        /// <summary>
        /// Deletes the image.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="index">The index.</param>
        public async Task DeleteImageAsync(ImageType type, int index)
        {
            var info = GetImageInfo(type, index);

            if (info == null)
            {
                // Nothing to do
                return;
            }

            // Remove it from the item
            RemoveImage(info);

            if (info.IsLocalFile)
            {
                FileSystem.DeleteFile(info.Path);
            }

            await UpdateToRepositoryAsync(ItemUpdateType.ImageUpdate, CancellationToken.None).ConfigureAwait(false);
        }

        public void RemoveImage(ItemImageInfo image)
        {
            RemoveImages(new List<ItemImageInfo> { image });
        }

        public void RemoveImages(List<ItemImageInfo> deletedImages)
        {
            ImageInfos = ImageInfos.Except(deletedImages).ToArray();
        }

        public virtual Task UpdateToRepositoryAsync(ItemUpdateType updateReason, CancellationToken cancellationToken)
         => LibraryManager.UpdateItemAsync(this, GetParent(), updateReason, cancellationToken);

        /// <summary>
        /// Validates that images within the item are still on the filesystem.
        /// </summary>
        public bool ValidateImages(IDirectoryService directoryService)
        {
            var allFiles = ImageInfos
                .Where(i => i.IsLocalFile)
                .Select(i => System.IO.Path.GetDirectoryName(i.Path))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .SelectMany(i => directoryService.GetFilePaths(i))
                .ToList();

            var deletedImages = ImageInfos
                .Where(image => image.IsLocalFile && !allFiles.Contains(image.Path, StringComparer.OrdinalIgnoreCase))
                .ToList();

            if (deletedImages.Count > 0)
            {
                ImageInfos = ImageInfos.Except(deletedImages).ToArray();
            }

            return deletedImages.Count > 0;
        }

        /// <summary>
        /// Gets the image path.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns>System.String.</returns>
        /// <exception cref="InvalidOperationException">
        /// </exception>
        /// <exception cref="ArgumentNullException">item</exception>
        public string GetImagePath(ImageType imageType, int imageIndex)
            => GetImageInfo(imageType, imageIndex)?.Path;

        /// <summary>
        /// Gets the image information.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="imageIndex">Index of the image.</param>
        /// <returns>ItemImageInfo.</returns>
        public ItemImageInfo GetImageInfo(ImageType imageType, int imageIndex)
        {
            if (imageType == ImageType.Chapter)
            {
                var chapter = ItemRepository.GetChapter(this, imageIndex);

                if (chapter == null)
                {
                    return null;
                }

                var path = chapter.ImagePath;

                if (string.IsNullOrEmpty(path))
                {
                    return null;
                }

                return new ItemImageInfo
                {
                    Path = path,
                    DateModified = chapter.ImageDateModified,
                    Type = imageType
                };
            }

            return GetImages(imageType)
                .ElementAtOrDefault(imageIndex);
        }

        /// <summary>
        /// Computes image index for given image or raises if no matching image found.
        /// </summary>
        /// <param name="image">Image to compute index for.</param>
        /// <exception cref="ArgumentException">Image index cannot be computed as no matching image found.
        /// </exception>
        /// <returns>Image index.</returns>
        public int GetImageIndex(ItemImageInfo image)
        {
            if (image == null)
            {
                throw new ArgumentNullException(nameof(image));
            }

            if (image.Type == ImageType.Chapter)
            {
                var chapters = ItemRepository.GetChapters(this);
                for (var i = 0; i < chapters.Count; i++)
                {
                    if (chapters[i].ImagePath == image.Path)
                    {
                        return i;
                    }
                }

                throw new ArgumentException("No chapter index found for image path", image.Path);
            }

            var images = GetImages(image.Type).ToArray();
            for (var i = 0; i < images.Length; i++)
            {
                if (images[i].Path == image.Path)
                {
                    return i;
                }
            }

            throw new ArgumentException("No image index found for image path", image.Path);
        }

        public IEnumerable<ItemImageInfo> GetImages(ImageType imageType)
        {
            if (imageType == ImageType.Chapter)
            {
                throw new ArgumentException("No image info for chapter images");
            }

            return ImageInfos.Where(i => i.Type == imageType);
        }

        /// <summary>
        /// Adds the images.
        /// </summary>
        /// <param name="imageType">Type of the image.</param>
        /// <param name="images">The images.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <exception cref="ArgumentException">Cannot call AddImages with chapter images</exception>
        public bool AddImages(ImageType imageType, List<FileSystemMetadata> images)
        {
            if (imageType == ImageType.Chapter)
            {
                throw new ArgumentException("Cannot call AddImages with chapter images");
            }

            var existingImages = GetImages(imageType)
                .ToList();

            var newImageList = new List<FileSystemMetadata>();
            var imageAdded = false;
            var imageUpdated = false;

            foreach (var newImage in images)
            {
                if (newImage == null)
                {
                    throw new ArgumentException("null image found in list");
                }

                var existing = existingImages
                    .FirstOrDefault(i => string.Equals(i.Path, newImage.FullName, StringComparison.OrdinalIgnoreCase));

                if (existing == null)
                {
                    newImageList.Add(newImage);
                    imageAdded = true;
                }
                else
                {
                    if (existing.IsLocalFile)
                    {
                        var newDateModified = FileSystem.GetLastWriteTimeUtc(newImage);

                        // If date changed then we need to reset saved image dimensions
                        if (existing.DateModified != newDateModified && (existing.Width > 0 || existing.Height > 0))
                        {
                            existing.Width = 0;
                            existing.Height = 0;
                            imageUpdated = true;
                        }

                        existing.DateModified = newDateModified;
                    }
                }
            }

            if (imageAdded || images.Count != existingImages.Count)
            {
                var newImagePaths = images.Select(i => i.FullName).ToList();

                var deleted = existingImages
                    .Where(i => i.IsLocalFile && !newImagePaths.Contains(i.Path, StringComparer.OrdinalIgnoreCase) && !File.Exists(i.Path))
                    .ToList();

                if (deleted.Count > 0)
                {
                    ImageInfos = ImageInfos.Except(deleted).ToArray();
                }
            }

            if (newImageList.Count > 0)
            {
                ImageInfos = ImageInfos.Concat(newImageList.Select(i => GetImageInfo(i, imageType))).ToArray();
            }

            return imageUpdated || newImageList.Count > 0;
        }

        private ItemImageInfo GetImageInfo(FileSystemMetadata file, ImageType type)
        {
            return new ItemImageInfo
            {
                Path = file.FullName,
                Type = type,
                DateModified = FileSystem.GetLastWriteTimeUtc(file)
            };
        }

        /// <summary>
        /// Gets the file system path to delete when the item is to be deleted.
        /// </summary>
        /// <returns></returns>
        public virtual IEnumerable<FileSystemMetadata> GetDeletePaths()
        {
            return new[] {
                new FileSystemMetadata
                {
                    FullName = Path,
                    IsDirectory = IsFolder
                }
            }.Concat(GetLocalMetadataFilesToDelete());
        }

        protected List<FileSystemMetadata> GetLocalMetadataFilesToDelete()
        {
            if (IsFolder || !IsInMixedFolder)
            {
                return new List<FileSystemMetadata>();
            }

            var filename = System.IO.Path.GetFileNameWithoutExtension(Path);

            return FileSystem.GetFiles(System.IO.Path.GetDirectoryName(Path), _supportedExtensions, false, false)
                .Where(i => System.IO.Path.GetFileNameWithoutExtension(i.FullName).StartsWith(filename, StringComparison.OrdinalIgnoreCase))
                .ToList();
        }

        public bool AllowsMultipleImages(ImageType type)
        {
            return type == ImageType.Backdrop || type == ImageType.Screenshot || type == ImageType.Chapter;
        }

        public Task SwapImagesAsync(ImageType type, int index1, int index2)
        {
            if (!AllowsMultipleImages(type))
            {
                throw new ArgumentException("The change index operation is only applicable to backdrops and screen shots");
            }

            var info1 = GetImageInfo(type, index1);
            var info2 = GetImageInfo(type, index2);

            if (info1 == null || info2 == null)
            {
                // Nothing to do
                return Task.CompletedTask;
            }

            if (!info1.IsLocalFile || !info2.IsLocalFile)
            {
                // TODO: Not supported  yet
                return Task.CompletedTask;
            }

            var path1 = info1.Path;
            var path2 = info2.Path;

            FileSystem.SwapFiles(path1, path2);

            // Refresh these values
            info1.DateModified = FileSystem.GetLastWriteTimeUtc(info1.Path);
            info2.DateModified = FileSystem.GetLastWriteTimeUtc(info2.Path);

            info1.Width = 0;
            info1.Height = 0;
            info2.Width = 0;
            info2.Height = 0;

            return UpdateToRepositoryAsync(ItemUpdateType.ImageUpdate, CancellationToken.None);
        }

        public virtual bool IsPlayed(User user)
        {
            var userdata = UserDataManager.GetUserData(user, this);

            return userdata != null && userdata.Played;
        }

        public bool IsFavoriteOrLiked(User user)
        {
            var userdata = UserDataManager.GetUserData(user, this);

            return userdata != null && (userdata.IsFavorite || (userdata.Likes ?? false));
        }

        public virtual bool IsUnplayed(User user)
        {
            if (user == null)
            {
                throw new ArgumentNullException(nameof(user));
            }

            var userdata = UserDataManager.GetUserData(user, this);

            return userdata == null || !userdata.Played;
        }

        ItemLookupInfo IHasLookupInfo<ItemLookupInfo>.GetLookupInfo()
        {
            return GetItemLookupInfo<ItemLookupInfo>();
        }

        protected T GetItemLookupInfo<T>()
            where T : ItemLookupInfo, new()
        {
            return new T
            {
                Path = Path,
                MetadataCountryCode = GetPreferredMetadataCountryCode(),
                MetadataLanguage = GetPreferredMetadataLanguage(),
                Name = GetNameForMetadataLookup(),
                ProviderIds = ProviderIds,
                IndexNumber = IndexNumber,
                ParentIndexNumber = ParentIndexNumber,
                Year = ProductionYear,
                PremiereDate = PremiereDate
            };
        }

        protected virtual string GetNameForMetadataLookup()
        {
            return Name;
        }

        /// <summary>
        /// This is called before any metadata refresh and returns true if changes were made.
        /// </summary>
        public virtual bool BeforeMetadataRefresh(bool replaceAllMetdata)
        {
            _sortName = null;

            var hasChanges = false;

            if (string.IsNullOrEmpty(Name) && !string.IsNullOrEmpty(Path))
            {
                Name = System.IO.Path.GetFileNameWithoutExtension(Path);
                hasChanges = true;
            }

            return hasChanges;
        }

        protected static string GetMappedPath(BaseItem item, string path, MediaProtocol? protocol)
        {
            if (protocol.HasValue && protocol.Value == MediaProtocol.File)
            {
                return LibraryManager.GetPathAfterNetworkSubstitution(path, item);
            }

            return path;
        }

        public virtual void FillUserDataDtoValues(UserItemDataDto dto, UserItemData userData, BaseItemDto itemDto, User user, DtoOptions fields)
        {
            if (RunTimeTicks.HasValue)
            {
                double pct = RunTimeTicks.Value;

                if (pct > 0)
                {
                    pct = userData.PlaybackPositionTicks / pct;

                    if (pct > 0)
                    {
                        dto.PlayedPercentage = 100 * pct;
                    }
                }
            }
        }

        protected Task RefreshMetadataForOwnedItem(BaseItem ownedItem, bool copyTitleMetadata, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            var newOptions = new MetadataRefreshOptions(options);
            newOptions.SearchResult = null;

            var item = this;

            if (copyTitleMetadata)
            {
                // Take some data from the main item, for querying purposes
                if (!item.Genres.SequenceEqual(ownedItem.Genres, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.Genres = item.Genres;
                }

                if (!item.Studios.SequenceEqual(ownedItem.Studios, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.Studios = item.Studios;
                }

                if (!item.ProductionLocations.SequenceEqual(ownedItem.ProductionLocations, StringComparer.Ordinal))
                {
                    newOptions.ForceSave = true;
                    ownedItem.ProductionLocations = item.ProductionLocations;
                }

                if (item.CommunityRating != ownedItem.CommunityRating)
                {
                    ownedItem.CommunityRating = item.CommunityRating;
                    newOptions.ForceSave = true;
                }

                if (item.CriticRating != ownedItem.CriticRating)
                {
                    ownedItem.CriticRating = item.CriticRating;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.Overview, ownedItem.Overview, StringComparison.Ordinal))
                {
                    ownedItem.Overview = item.Overview;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.OfficialRating, ownedItem.OfficialRating, StringComparison.Ordinal))
                {
                    ownedItem.OfficialRating = item.OfficialRating;
                    newOptions.ForceSave = true;
                }

                if (!string.Equals(item.CustomRating, ownedItem.CustomRating, StringComparison.Ordinal))
                {
                    ownedItem.CustomRating = item.CustomRating;
                    newOptions.ForceSave = true;
                }
            }

            return ownedItem.RefreshMetadata(newOptions, cancellationToken);
        }

        protected Task RefreshMetadataForOwnedVideo(MetadataRefreshOptions options, bool copyTitleMetadata, string path, CancellationToken cancellationToken)
        {
            var newOptions = new MetadataRefreshOptions(options);
            newOptions.SearchResult = null;

            var id = LibraryManager.GetNewItemId(path, typeof(Video));

            // Try to retrieve it from the db. If we don't find it, use the resolved version
            var video = LibraryManager.GetItemById(id) as Video;

            if (video == null)
            {
                video = LibraryManager.ResolvePath(FileSystem.GetFileSystemInfo(path)) as Video;

                newOptions.ForceSave = true;
            }

            // var parentId = Id;
            // if (!video.IsOwnedItem || video.ParentId != parentId)
            //{
            //    video.IsOwnedItem = true;
            //    video.ParentId = parentId;
            //    newOptions.ForceSave = true;
            //}

            if (video == null)
            {
                return Task.FromResult(true);
            }

            return RefreshMetadataForOwnedItem(video, copyTitleMetadata, newOptions, cancellationToken);
        }

        public string GetEtag(User user)
        {
            var list = GetEtagValues(user);

            return string.Join('|', list).GetMD5().ToString("N", CultureInfo.InvariantCulture);
        }

        protected virtual List<string> GetEtagValues(User user)
        {
            return new List<string>
            {
                DateLastSaved.Ticks.ToString(CultureInfo.InvariantCulture)
            };
        }

        public virtual IEnumerable<Guid> GetAncestorIds()
        {
            return GetParents().Select(i => i.Id).Concat(LibraryManager.GetCollectionFolders(this).Select(i => i.Id));
        }

        public BaseItem GetTopParent()
        {
            if (IsTopParent)
            {
                return this;
            }

            return GetParents().FirstOrDefault(parent => parent.IsTopParent);
        }

        [JsonIgnore]
        public virtual bool IsTopParent
        {
            get
            {
                if (this is BasePluginFolder || this is Channel)
                {
                    return true;
                }

                if (this is IHasCollectionType view)
                {
                    if (string.Equals(view.CollectionType, CollectionType.LiveTv, StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }

                if (GetParent() is AggregateFolder)
                {
                    return true;
                }

                return false;
            }
        }

        [JsonIgnore]
        public virtual bool SupportsAncestors => true;

        [JsonIgnore]
        public virtual bool StopRefreshIfLocalMetadataFound => true;

        public virtual IEnumerable<Guid> GetIdsForAncestorQuery()
        {
            return new[] { Id };
        }

        public virtual List<ExternalUrl> GetRelatedUrls()
        {
            return new List<ExternalUrl>();
        }

        public virtual double? GetRefreshProgress()
        {
            return null;
        }

        public virtual ItemUpdateType OnMetadataChanged()
        {
            var updateType = ItemUpdateType.None;

            var item = this;

            var inheritedParentalRatingValue = item.GetInheritedParentalRatingValue() ?? 0;
            if (inheritedParentalRatingValue != item.InheritedParentalRatingValue)
            {
                item.InheritedParentalRatingValue = inheritedParentalRatingValue;
                updateType |= ItemUpdateType.MetadataImport;
            }

            return updateType;
        }

        /// <summary>
        /// Updates the official rating based on content and returns true or false indicating if it changed.
        /// </summary>
        /// <returns></returns>
        public bool UpdateRatingToItems(IList<BaseItem> children)
        {
            var currentOfficialRating = OfficialRating;

            // Gather all possible ratings
            var ratings = children
                .Select(i => i.OfficialRating)
                .Where(i => !string.IsNullOrEmpty(i))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .Select(i => new Tuple<string, int?>(i, LocalizationManager.GetRatingLevel(i)))
                .OrderBy(i => i.Item2 ?? 1000)
                .Select(i => i.Item1);

            OfficialRating = ratings.FirstOrDefault() ?? currentOfficialRating;

            return !string.Equals(currentOfficialRating ?? string.Empty, OfficialRating ?? string.Empty,
                StringComparison.OrdinalIgnoreCase);
        }

        public IEnumerable<BaseItem> GetThemeSongs()
        {
            return ThemeSongIds.Select(LibraryManager.GetItemById);
        }

        public IEnumerable<BaseItem> GetThemeVideos()
        {
            return ThemeVideoIds.Select(LibraryManager.GetItemById);
        }

        /// <summary>
        /// Gets or sets the remote trailers.
        /// </summary>
        /// <value>The remote trailers.</value>
        public IReadOnlyList<MediaUrl> RemoteTrailers { get; set; }

        /// <summary>
        /// Get all extras associated with this item, sorted by <see cref="SortName"/>.
        /// </summary>
        /// <returns>An enumerable containing the items.</returns>
        public IEnumerable<BaseItem> GetExtras()
        {
            return ExtraIds
                .Select(LibraryManager.GetItemById)
                .Where(i => i != null)
                .OrderBy(i => i.SortName);
        }

        /// <summary>
        /// Get all extras with specific types that are associated with this item.
        /// </summary>
        /// <param name="extraTypes">The types of extras to retrieve.</param>
        /// <returns>An enumerable containing the extras.</returns>
        public IEnumerable<BaseItem> GetExtras(IReadOnlyCollection<ExtraType> extraTypes)
        {
            return ExtraIds
                .Select(LibraryManager.GetItemById)
                .Where(i => i != null)
                .Where(i => i.ExtraType.HasValue && extraTypes.Contains(i.ExtraType.Value));
        }

        public IEnumerable<BaseItem> GetTrailers()
        {
            if (this is IHasTrailers)
            {
                return ((IHasTrailers)this).LocalTrailerIds.Select(LibraryManager.GetItemById).Where(i => i != null).OrderBy(i => i.SortName);
            }
            else
            {
                return Array.Empty<BaseItem>();
            }
        }

        public virtual bool IsHD => Height >= 720;

        public bool IsShortcut { get; set; }

        public string ShortcutPath { get; set; }

        public int Width { get; set; }

        public int Height { get; set; }

        public Guid[] ExtraIds { get; set; }

        public virtual long GetRunTimeTicksForPlayState()
        {
            return RunTimeTicks ?? 0;
        }

        /// <summary>
        /// Extra types that should be counted and displayed as "Special Features" in the UI.
        /// </summary>
        public static readonly IReadOnlyCollection<ExtraType> DisplayExtraTypes = new HashSet<ExtraType>
        {
            Model.Entities.ExtraType.Unknown,
            Model.Entities.ExtraType.BehindTheScenes,
            Model.Entities.ExtraType.Clip,
            Model.Entities.ExtraType.DeletedScene,
            Model.Entities.ExtraType.Interview,
            Model.Entities.ExtraType.Sample,
            Model.Entities.ExtraType.Scene
        };

        public virtual bool SupportsExternalTransfer => false;

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            return obj is BaseItem baseItem && this.Equals(baseItem);
        }

        /// <inheritdoc />
        public bool Equals(BaseItem item) => Object.Equals(Id, item?.Id);

        /// <inheritdoc />
        public override int GetHashCode() => HashCode.Combine(Id);
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MediaBrowser.Controller\Entities\BaseItem.cs(1166,31): error CS0128: A local variable or function named 'video' is already defined in this scope,D:\a\1\s\MediaBrowser.Controller\Entities\BaseItem.cs(1166,40): error CS0165: Use of unassigned local variable 'video'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MediaBrowser.Controller\Library\ItemResolveArgs.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.IO;

namespace MediaBrowser.Controller.Library
{
    /// <summary>
    /// These are arguments relating to the file system that are collected once and then referred to
    /// whenever needed.  Primarily for entity resolution.
    /// </summary>
    public class ItemResolveArgs : EventArgs
    {
        /// <summary>
        /// The _app paths.
        /// </summary>
        private readonly IServerApplicationPaths _appPaths;

        public IDirectoryService DirectoryService { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemResolveArgs" /> class.
        /// </summary>
        /// <param name="appPaths">The app paths.</param>
        /// <param name="directoryService">The directory service.</param>
        public ItemResolveArgs(IServerApplicationPaths appPaths, IDirectoryService directoryService)
        {
            _appPaths = appPaths;
            DirectoryService = directoryService;
        }

        /// <summary>
        /// Gets the file system children.
        /// </summary>
        /// <value>The file system children.</value>
        public FileSystemMetadata[] FileSystemChildren { get; set; }

        public LibraryOptions LibraryOptions { get; set; }

        public LibraryOptions GetLibraryOptions()
        {
            return LibraryOptions ?? (LibraryOptions = Parent == null ? new LibraryOptions() : BaseItem.LibraryManager.GetLibraryOptions(Parent));
        }

        /// <summary>
        /// Gets or sets the parent.
        /// </summary>
        /// <value>The parent.</value>
        public Folder Parent { get; set; }

        /// <summary>
        /// Gets or sets the file info.
        /// </summary>
        /// <value>The file info.</value>
        public FileSystemMetadata FileInfo { get; set; }

        /// <summary>
        /// Gets or sets the path.
        /// </summary>
        /// <value>The path.</value>
        public string Path { get; set; }

        /// <summary>
        /// Gets a value indicating whether this instance is directory.
        /// </summary>
        /// <value><c>true</c> if this instance is directory; otherwise, <c>false</c>.</value>
        public bool IsDirectory => FileInfo.IsDirectory;

        /// <summary>
        /// Gets a value indicating whether this instance is vf.
        /// </summary>
        /// <value><c>true</c> if this instance is vf; otherwise, <c>false</c>.</value>
        public bool IsVf
        {
            // we should be considered a virtual folder if we are a child of one of the children of the system root folder.
            //  this is a bit of a trick to determine that...  the directory name of a sub-child of the root will start with
            //  the root but not be equal to it
            get
            {
                if (!IsDirectory)
                {
                    return false;
                }

                var parentDir = System.IO.Path.GetDirectoryName(Path) ?? string.Empty;

                return parentDir.Length > _appPaths.RootFolderPath.Length
                       && parentDir.StartsWith(_appPaths.RootFolderPath, StringComparison.OrdinalIgnoreCase);
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is physical root.
        /// </summary>
        /// <value><c>true</c> if this instance is physical root; otherwise, <c>false</c>.</value>
        public bool IsPhysicalRoot => IsDirectory && BaseItem.FileSystem.AreEqual(Path, _appPaths.RootFolderPath);

        /// <summary>
        /// Gets or sets the additional locations.
        /// </summary>
        /// <value>The additional locations.</value>
        private List<string> AdditionalLocations { get; set; }

        public bool HasParent<T>()
            where T : Folder
        {
            var parent = Parent;

            if (parent != null)
            {
                var item = parent as T;

                // Just in case the user decided to nest episodes.
                // Not officially supported but in some cases we can handle it.
                if (item == null)
                {
                    var parents = parent.GetParents();
                    foreach (var currentParent in parents)
                    {
                        if (currentParent is T)
                        {
                            return true;
                        }
                    }
                }

                return item != null;
            }

            return false;
        }

        /// <summary>
        /// Adds the additional location.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddAdditionalLocation(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("The path was empty or null.", nameof(path));
            }

            if (AdditionalLocations == null)
            {
                AdditionalLocations = new List<string>();
            }

            AdditionalLocations.Add(path);
        }

        // REVIEW: @bond

        /// <summary>
        /// Gets the physical locations.
        /// </summary>
        /// <value>The physical locations.</value>
        public string[] PhysicalLocations
        {
            get
            {
                var paths = string.IsNullOrEmpty(Path) ? Array.Empty<string>() : new[] { Path };
                return AdditionalLocations == null ? paths : paths.Concat(AdditionalLocations).ToArray();
            }
        }

        /// <summary>
        /// Gets the name of the file system entry by.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>FileSystemInfo.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public FileSystemMetadata GetFileSystemEntryByName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("The name was empty or null.", nameof(name));
            }

            return GetFileSystemEntryByPath(System.IO.Path.Combine(Path, name));
        }

        /// <summary>
        /// Gets the file system entry by path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>FileSystemInfo.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public FileSystemMetadata GetFileSystemEntryByPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("The path was empty or null.", nameof(path));
            }

            foreach (var file in FileSystemChildren)
            {
                if (string.Equals(file.FullName, path, StringComparison.Ordinal))
                {
                    return file;
                }
            }

            return null;
        }

        /// <summary>
        /// Determines whether [contains file system entry by name] [the specified name].
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns><c>true</c> if [contains file system entry by name] [the specified name]; otherwise, <c>false</c>.</returns>
        public bool ContainsFileSystemEntryByName(string name)
        {
            return GetFileSystemEntryByName(name) != null;
        }

        public string GetCollectionType()
        {
            return CollectionType;
        }

        public string CollectionType { get; set; }

        /// <summary>
        /// Determines whether the specified <see cref="object" /> is equal to this instance.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns><c>true</c> if the specified <see cref="object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as ItemResolveArgs);
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode()
        {
            return Path.GetHashCode();
        }

        /// <summary>
        /// Equals the specified args.
        /// </summary>
        /// <param name="args">The args.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise</returns>
        protected bool Equals(ItemResolveArgs args)
        {
            if (args != null)
            {
                if (args.Path == null && Path == null)
                {
                    return true;
                }

                return args.Path != null && BaseItem.FileSystem.AreEqual(args.Path, Path);
            }

            return false;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.IO;

namespace MediaBrowser.Controller.Library
{
    /// <summary>
    /// These are arguments relating to the file system that are collected once and then referred to
    /// whenever needed.  Primarily for entity resolution.
    /// </summary>
    public class ItemResolveArgs : EventArgs
    {
        /// <summary>
        /// The _app paths.
        /// </summary>
        private readonly IServerApplicationPaths _appPaths;

        public IDirectoryService DirectoryService { get; private set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ItemResolveArgs" /> class.
        /// </summary>
        /// <param name="appPaths">The app paths.</param>
        /// <param name="directoryService">The directory service.</param>
        public ItemResolveArgs(IServerApplicationPaths appPaths, IDirectoryService directoryService)
        {
            _appPaths = appPaths;
            DirectoryService = directoryService;
        }

        /// <summary>
        /// Gets the file system children.
        /// </summary>
        /// <value>The file system children.</value>
        public FileSystemMetadata[] FileSystemChildren { get; set; }

        public LibraryOptions LibraryOptions { get; set; }

        public LibraryOptions GetLibraryOptions()
        {
            return LibraryOptions ?? (LibraryOptions = Parent == null ? new LibraryOptions() : BaseItem.LibraryManager.GetLibraryOptions(Parent));
        }

        /// <summary>
        /// Gets or sets the parent.
        /// </summary>
        /// <value>The parent.</value>
        public Folder Parent { get; set; }

        /// <summary>
        /// Gets or sets the file info.
        /// </summary>
        /// <value>The file info.</value>
        public FileSystemMetadata FileInfo { get; set; }

        /// <summary>
        /// Gets or sets the path.
        /// </summary>
        /// <value>The path.</value>
        public string Path { get; set; }

        /// <summary>
        /// Gets a value indicating whether this instance is directory.
        /// </summary>
        /// <value><c>true</c> if this instance is directory; otherwise, <c>false</c>.</value>
        public bool IsDirectory => FileInfo.IsDirectory;

        /// <summary>
        /// Gets a value indicating whether this instance is vf.
        /// </summary>
        /// <value><c>true</c> if this instance is vf; otherwise, <c>false</c>.</value>
        public bool IsVf
        {
            // we should be considered a virtual folder if we are a child of one of the children of the system root folder.
            //  this is a bit of a trick to determine that...  the directory name of a sub-child of the root will start with
            //  the root but not be equal to it
            get
            {
                if (!IsDirectory)
                {
                    return false;
                }

                var parentDir = System.IO.Path.GetDirectoryName(Path) ?? string.Empty;

                return parentDir.Length > _appPaths.RootFolderPath.Length
                       && parentDir.StartsWith(_appPaths.RootFolderPath, StringComparison.OrdinalIgnoreCase);
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is physical root.
        /// </summary>
        /// <value><c>true</c> if this instance is physical root; otherwise, <c>false</c>.</value>
        public bool IsPhysicalRoot => IsDirectory && BaseItem.FileSystem.AreEqual(Path, _appPaths.RootFolderPath);

        /// <summary>
        /// Gets or sets the additional locations.
        /// </summary>
        /// <value>The additional locations.</value>
        private List<string> AdditionalLocations { get; set; }

        public bool HasParent<T>()
            where T : Folder
        {
            var parent = Parent;

            if (parent != null)
            {

                // Just in case the user decided to nest episodes.
                // Not officially supported but in some cases we can handle it.
                if (item == null)
                {
                    var parents = parent.GetParents();
                    foreach (var currentParent in parents)
                    {
                        if (currentParent is T)
                        {
                            return true;
                        }
                    }
                }

                return parent is T item;
            }

            return false;
        }

        /// <summary>
        /// Adds the additional location.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <exception cref="ArgumentNullException"></exception>
        public void AddAdditionalLocation(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("The path was empty or null.", nameof(path));
            }

            if (AdditionalLocations == null)
            {
                AdditionalLocations = new List<string>();
            }

            AdditionalLocations.Add(path);
        }

        // REVIEW: @bond

        /// <summary>
        /// Gets the physical locations.
        /// </summary>
        /// <value>The physical locations.</value>
        public string[] PhysicalLocations
        {
            get
            {
                var paths = string.IsNullOrEmpty(Path) ? Array.Empty<string>() : new[] { Path };
                return AdditionalLocations == null ? paths : paths.Concat(AdditionalLocations).ToArray();
            }
        }

        /// <summary>
        /// Gets the name of the file system entry by.
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns>FileSystemInfo.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public FileSystemMetadata GetFileSystemEntryByName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("The name was empty or null.", nameof(name));
            }

            return GetFileSystemEntryByPath(System.IO.Path.Combine(Path, name));
        }

        /// <summary>
        /// Gets the file system entry by path.
        /// </summary>
        /// <param name="path">The path.</param>
        /// <returns>FileSystemInfo.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public FileSystemMetadata GetFileSystemEntryByPath(string path)
        {
            if (string.IsNullOrEmpty(path))
            {
                throw new ArgumentException("The path was empty or null.", nameof(path));
            }

            foreach (var file in FileSystemChildren)
            {
                if (string.Equals(file.FullName, path, StringComparison.Ordinal))
                {
                    return file;
                }
            }

            return null;
        }

        /// <summary>
        /// Determines whether [contains file system entry by name] [the specified name].
        /// </summary>
        /// <param name="name">The name.</param>
        /// <returns><c>true</c> if [contains file system entry by name] [the specified name]; otherwise, <c>false</c>.</returns>
        public bool ContainsFileSystemEntryByName(string name)
        {
            return GetFileSystemEntryByName(name) != null;
        }

        public string GetCollectionType()
        {
            return CollectionType;
        }

        public string CollectionType { get; set; }

        /// <summary>
        /// Determines whether the specified <see cref="object" /> is equal to this instance.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns><c>true</c> if the specified <see cref="object" /> is equal to this instance; otherwise, <c>false</c>.</returns>
        public override bool Equals(object obj)
        {
            return Equals(obj as ItemResolveArgs);
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        public override int GetHashCode()
        {
            return Path.GetHashCode();
        }

        /// <summary>
        /// Equals the specified args.
        /// </summary>
        /// <param name="args">The args.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise</returns>
        protected bool Equals(ItemResolveArgs args)
        {
            if (args != null)
            {
                if (args.Path == null && Path == null)
                {
                    return true;
                }

                return args.Path != null && BaseItem.FileSystem.AreEqual(args.Path, Path);
            }

            return false;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MediaBrowser.Controller\Library\ItemResolveArgs.cs(119,21): error CS0841: Cannot use local variable 'item' before it is declared
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MediaBrowser.Providers\MediaInfo\FFProbeProvider.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Controller.Chapters;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Audio;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Entities.TV;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Persistence;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Controller.Subtitles;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.MediaInfo;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.Providers.MediaInfo
{
    public class FFProbeProvider : ICustomMetadataProvider<Episode>,
        ICustomMetadataProvider<MusicVideo>,
        ICustomMetadataProvider<Movie>,
        ICustomMetadataProvider<Trailer>,
        ICustomMetadataProvider<Video>,
        ICustomMetadataProvider<Audio>,
        ICustomMetadataProvider<AudioBook>,
        IHasOrder,
        IForcedProvider,
        IPreRefreshProvider,
        IHasItemChangeMonitor
    {
        private readonly ILogger<FFProbeProvider> _logger;
        private readonly IMediaEncoder _mediaEncoder;
        private readonly IItemRepository _itemRepo;
        private readonly IBlurayExaminer _blurayExaminer;
        private readonly ILocalizationManager _localization;
        private readonly IEncodingManager _encodingManager;
        private readonly IServerConfigurationManager _config;
        private readonly ISubtitleManager _subtitleManager;
        private readonly IChapterManager _chapterManager;
        private readonly ILibraryManager _libraryManager;
        private readonly IMediaSourceManager _mediaSourceManager;
        private readonly SubtitleResolver _subtitleResolver;

        private readonly Task<ItemUpdateType> _cachedTask = Task.FromResult(ItemUpdateType.None);

        public FFProbeProvider(
            ILogger<FFProbeProvider> logger,
            IMediaSourceManager mediaSourceManager,
            IMediaEncoder mediaEncoder,
            IItemRepository itemRepo,
            IBlurayExaminer blurayExaminer,
            ILocalizationManager localization,
            IEncodingManager encodingManager,
            IServerConfigurationManager config,
            ISubtitleManager subtitleManager,
            IChapterManager chapterManager,
            ILibraryManager libraryManager)
        {
            _logger = logger;
            _mediaEncoder = mediaEncoder;
            _itemRepo = itemRepo;
            _blurayExaminer = blurayExaminer;
            _localization = localization;
            _encodingManager = encodingManager;
            _config = config;
            _subtitleManager = subtitleManager;
            _chapterManager = chapterManager;
            _libraryManager = libraryManager;
            _mediaSourceManager = mediaSourceManager;

            _subtitleResolver = new SubtitleResolver(BaseItem.LocalizationManager);
        }

        public string Name => "ffprobe";

        // Run last
        public int Order => 100;

        public bool HasChanged(BaseItem item, IDirectoryService directoryService)
        {
            var video = item as Video;
            if (video == null || video.VideoType == VideoType.VideoFile || video.VideoType == VideoType.Iso)
            {
                var path = item.Path;

                if (!string.IsNullOrWhiteSpace(path) && item.IsFileProtocol)
                {
                    var file = directoryService.GetFile(path);
                    if (file != null && file.LastWriteTimeUtc != item.DateModified)
                    {
                        _logger.LogDebug("Refreshing {0} due to date modified timestamp change.", path);
                        return true;
                    }
                }
            }

            if (item.SupportsLocalMetadata && video != null && !video.IsPlaceHolder
                && !video.SubtitleFiles.SequenceEqual(
                        _subtitleResolver.GetExternalSubtitleFiles(video, directoryService, false), StringComparer.Ordinal))
            {
                _logger.LogDebug("Refreshing {0} due to external subtitles change.", item.Path);
                return true;
            }

            return false;
        }

        public Task<ItemUpdateType> FetchAsync(Episode item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(MusicVideo item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Movie item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Trailer item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Video item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Audio item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(AudioBook item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchVideoInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Video
        {
            if (item.IsPlaceHolder)
            {
                return _cachedTask;
            }

            if (!item.IsCompleteMedia)
            {
                return _cachedTask;
            }

            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            var prober = new FFProbeVideoInfo(
                _logger,
                _mediaSourceManager,
                _mediaEncoder,
                _itemRepo,
                _blurayExaminer,
                _localization,
                _encodingManager,
                _config,
                _subtitleManager,
                _chapterManager,
                _libraryManager);

            return prober.ProbeVideo(item, options, cancellationToken);
        }

        private string NormalizeStrmLine(string line)
        {
            return line.Replace("\t", string.Empty, StringComparison.Ordinal)
                .Replace("\r", string.Empty, StringComparison.Ordinal)
                .Replace("\n", string.Empty, StringComparison.Ordinal)
                .Trim();
        }

        private void FetchShortcutInfo(BaseItem item)
        {
            item.ShortcutPath = File.ReadAllLines(item.Path)
                .Select(NormalizeStrmLine)
                .FirstOrDefault(i => !string.IsNullOrWhiteSpace(i) && !i.StartsWith('#'));
        }

        public Task<ItemUpdateType> FetchAudioInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Audio
        {
            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            var prober = new FFProbeAudioInfo(_mediaSourceManager, _mediaEncoder, _itemRepo, _libraryManager);

            return prober.Probe(item, options, cancellationToken);
        }
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Controller.Chapters;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Audio;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Entities.TV;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Persistence;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Controller.Subtitles;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.MediaInfo;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.Providers.MediaInfo
{
    public class FFProbeProvider : ICustomMetadataProvider<Episode>,
        ICustomMetadataProvider<MusicVideo>,
        ICustomMetadataProvider<Movie>,
        ICustomMetadataProvider<Trailer>,
        ICustomMetadataProvider<Video>,
        ICustomMetadataProvider<Audio>,
        ICustomMetadataProvider<AudioBook>,
        IHasOrder,
        IForcedProvider,
        IPreRefreshProvider,
        IHasItemChangeMonitor
    {
        private readonly ILogger<FFProbeProvider> _logger;
        private readonly IMediaEncoder _mediaEncoder;
        private readonly IItemRepository _itemRepo;
        private readonly IBlurayExaminer _blurayExaminer;
        private readonly ILocalizationManager _localization;
        private readonly IEncodingManager _encodingManager;
        private readonly IServerConfigurationManager _config;
        private readonly ISubtitleManager _subtitleManager;
        private readonly IChapterManager _chapterManager;
        private readonly ILibraryManager _libraryManager;
        private readonly IMediaSourceManager _mediaSourceManager;
        private readonly SubtitleResolver _subtitleResolver;

        private readonly Task<ItemUpdateType> _cachedTask = Task.FromResult(ItemUpdateType.None);

        public FFProbeProvider(
            ILogger<FFProbeProvider> logger,
            IMediaSourceManager mediaSourceManager,
            IMediaEncoder mediaEncoder,
            IItemRepository itemRepo,
            IBlurayExaminer blurayExaminer,
            ILocalizationManager localization,
            IEncodingManager encodingManager,
            IServerConfigurationManager config,
            ISubtitleManager subtitleManager,
            IChapterManager chapterManager,
            ILibraryManager libraryManager)
        {
            _logger = logger;
            _mediaEncoder = mediaEncoder;
            _itemRepo = itemRepo;
            _blurayExaminer = blurayExaminer;
            _localization = localization;
            _encodingManager = encodingManager;
            _config = config;
            _subtitleManager = subtitleManager;
            _chapterManager = chapterManager;
            _libraryManager = libraryManager;
            _mediaSourceManager = mediaSourceManager;

            _subtitleResolver = new SubtitleResolver(BaseItem.LocalizationManager);
        }

        public string Name => "ffprobe";

        // Run last
        public int Order => 100;

        public bool HasChanged(BaseItem item, IDirectoryService directoryService)
        {
            if (video == null || video.VideoType == VideoType.VideoFile || video.VideoType == VideoType.Iso)
            {
                var path = item.Path;

                if (!string.IsNullOrWhiteSpace(path) && item.IsFileProtocol)
                {
                    var file = directoryService.GetFile(path);
                    if (file != null && file.LastWriteTimeUtc != item.DateModified)
                    {
                        _logger.LogDebug("Refreshing {0} due to date modified timestamp change.", path);
                        return true;
                    }
                }
            }

            if (item.SupportsLocalMetadata && item is Video video && !video.IsPlaceHolder
                && !video.SubtitleFiles.SequenceEqual(
                        _subtitleResolver.GetExternalSubtitleFiles(video, directoryService, false), StringComparer.Ordinal))
            {
                _logger.LogDebug("Refreshing {0} due to external subtitles change.", item.Path);
                return true;
            }

            return false;
        }

        public Task<ItemUpdateType> FetchAsync(Episode item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(MusicVideo item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Movie item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Trailer item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Video item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchVideoInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(Audio item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchAsync(AudioBook item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            return FetchAudioInfo(item, options, cancellationToken);
        }

        public Task<ItemUpdateType> FetchVideoInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Video
        {
            if (item.IsPlaceHolder)
            {
                return _cachedTask;
            }

            if (!item.IsCompleteMedia)
            {
                return _cachedTask;
            }

            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            var prober = new FFProbeVideoInfo(
                _logger,
                _mediaSourceManager,
                _mediaEncoder,
                _itemRepo,
                _blurayExaminer,
                _localization,
                _encodingManager,
                _config,
                _subtitleManager,
                _chapterManager,
                _libraryManager);

            return prober.ProbeVideo(item, options, cancellationToken);
        }

        private string NormalizeStrmLine(string line)
        {
            return line.Replace("\t", string.Empty, StringComparison.Ordinal)
                .Replace("\r", string.Empty, StringComparison.Ordinal)
                .Replace("\n", string.Empty, StringComparison.Ordinal)
                .Trim();
        }

        private void FetchShortcutInfo(BaseItem item)
        {
            item.ShortcutPath = File.ReadAllLines(item.Path)
                .Select(NormalizeStrmLine)
                .FirstOrDefault(i => !string.IsNullOrWhiteSpace(i) && !i.StartsWith('#'));
        }

        public Task<ItemUpdateType> FetchAudioInfo<T>(T item, MetadataRefreshOptions options, CancellationToken cancellationToken)
            where T : Audio
        {
            if (item.IsVirtualItem)
            {
                return _cachedTask;
            }

            if (!options.EnableRemoteContentProbe && !item.IsFileProtocol)
            {
                return _cachedTask;
            }

            if (item.IsShortcut)
            {
                FetchShortcutInfo(item);
            }

            var prober = new FFProbeAudioInfo(_mediaSourceManager, _mediaEncoder, _itemRepo, _libraryManager);

            return prober.Probe(item, options, cancellationToken);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MediaBrowser.Providers\MediaInfo\FFProbeProvider.cs(88,17): error CS0841: Cannot use local variable 'video' before it is declared,D:\a\1\s\MediaBrowser.Providers\MediaInfo\FFProbeProvider.cs(88,34): error CS0841: Cannot use local variable 'video' before it is declared,D:\a\1\s\MediaBrowser.Providers\MediaInfo\FFProbeProvider.cs(88,76): error CS0841: Cannot use local variable 'video' before it is declared
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MediaBrowser.XbmcMetadata\Parsers\MovieNfoParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Linq;
using System.Xml;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Entities;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.XbmcMetadata.Parsers
{
    /// <summary>
    /// Nfo parser for movies.
    /// </summary>
    public class MovieNfoParser : BaseNfoParser<Video>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MovieNfoParser"/> class.
        /// </summary>
        /// <param name="logger">Instance of the <see cref="ILogger"/> interface.</param>
        /// <param name="config">Instance of the <see cref="IConfigurationManager"/> interface.</param>
        /// <param name="providerManager">Instance of the <see cref="IProviderManager"/> interface.</param>
        /// <param name="userManager">Instance of the <see cref="IUserManager"/> interface.</param>
        /// <param name="userDataManager">Instance of the <see cref="IUserDataManager"/> interface.</param>
        public MovieNfoParser(
            ILogger logger,
            IConfigurationManager config,
            IProviderManager providerManager,
            IUserManager userManager,
            IUserDataManager userDataManager)
            : base(logger, config, providerManager, userManager, userDataManager)
        {
        }

        /// <inheritdoc />
        protected override bool SupportsUrlAfterClosingXmlTag => true;

        /// <inheritdoc />
        protected override void FetchDataFromXmlNode(XmlReader reader, MetadataResult<Video> itemResult)
        {
            var item = itemResult.Item;

            switch (reader.Name)
            {
                case "id":
                    {
                        string? imdbId = reader.GetAttribute("IMDB");
                        string? tmdbId = reader.GetAttribute("TMDB");

                        if (string.IsNullOrWhiteSpace(imdbId))
                        {
                            imdbId = reader.ReadElementContentAsString();
                        }

                        if (!string.IsNullOrWhiteSpace(imdbId))
                        {
                            item.SetProviderId(MetadataProvider.Imdb, imdbId);
                        }

                        if (!string.IsNullOrWhiteSpace(tmdbId))
                        {
                            item.SetProviderId(MetadataProvider.Tmdb, tmdbId);
                        }

                        break;
                    }

                case "set":
                    {
                        var movie = item as Movie;

                        var tmdbcolid = reader.GetAttribute("tmdbcolid");
                        if (!string.IsNullOrWhiteSpace(tmdbcolid) && movie != null)
                        {
                            movie.SetProviderId(MetadataProvider.TmdbCollection, tmdbcolid);
                        }

                        var val = reader.ReadInnerXml();

                        if (!string.IsNullOrWhiteSpace(val) && movie != null)
                        {
                            // TODO Handle this better later
                            if (!val.Contains('<', StringComparison.Ordinal))
                            {
                                movie.CollectionName = val;
                            }
                            else
                            {
                                try
                                {
                                    ParseSetXml(val, movie);
                                }
                                catch (Exception ex)
                                {
                                    Logger.LogError(ex, "Error parsing set node");
                                }
                            }
                        }

                        break;
                    }

                case "artist":
                    {
                        var val = reader.ReadElementContentAsString();

                        if (!string.IsNullOrWhiteSpace(val) && item is MusicVideo movie)
                        {
                            var list = movie.Artists.ToList();
                            list.Add(val);
                            movie.Artists = list.ToArray();
                        }

                        break;
                    }

                case "album":
                    {
                        var val = reader.ReadElementContentAsString();

                        if (!string.IsNullOrWhiteSpace(val) && item is MusicVideo movie)
                        {
                            movie.Album = val;
                        }

                        break;
                    }

                default:
                    base.FetchDataFromXmlNode(reader, itemResult);
                    break;
            }
        }

        private void ParseSetXml(string xml, Movie movie)
        {
            // These are not going to be valid xml so no sense in causing the provider to fail and spamming the log with exceptions
            try
            {
                using (var stringReader = new StringReader("<set>" + xml + "</set>"))
                using (var reader = XmlReader.Create(stringReader, GetXmlReaderSettings()))
                {
                    reader.MoveToContent();
                    reader.Read();

                    // Loop through each element
                    while (!reader.EOF && reader.ReadState == ReadState.Interactive)
                    {
                        if (reader.NodeType == XmlNodeType.Element)
                        {
                            switch (reader.Name)
                            {
                                case "name":
                                    movie.CollectionName = reader.ReadElementContentAsString();
                                    break;
                                default:
                                    reader.Skip();
                                    break;
                            }
                        }
                        else
                        {
                            reader.Read();
                        }
                    }
                }
            }
            catch (XmlException)
            {
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Linq;
using System.Xml;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Entities;
using Microsoft.Extensions.Logging;

namespace MediaBrowser.XbmcMetadata.Parsers
{
    /// <summary>
    /// Nfo parser for movies.
    /// </summary>
    public class MovieNfoParser : BaseNfoParser<Video>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MovieNfoParser"/> class.
        /// </summary>
        /// <param name="logger">Instance of the <see cref="ILogger"/> interface.</param>
        /// <param name="config">Instance of the <see cref="IConfigurationManager"/> interface.</param>
        /// <param name="providerManager">Instance of the <see cref="IProviderManager"/> interface.</param>
        /// <param name="userManager">Instance of the <see cref="IUserManager"/> interface.</param>
        /// <param name="userDataManager">Instance of the <see cref="IUserDataManager"/> interface.</param>
        public MovieNfoParser(
            ILogger logger,
            IConfigurationManager config,
            IProviderManager providerManager,
            IUserManager userManager,
            IUserDataManager userDataManager)
            : base(logger, config, providerManager, userManager, userDataManager)
        {
        }

        /// <inheritdoc />
        protected override bool SupportsUrlAfterClosingXmlTag => true;

        /// <inheritdoc />
        protected override void FetchDataFromXmlNode(XmlReader reader, MetadataResult<Video> itemResult)
        {
            var item = itemResult.Item;

            switch (reader.Name)
            {
                case "id":
                    {
                        string? imdbId = reader.GetAttribute("IMDB");
                        string? tmdbId = reader.GetAttribute("TMDB");

                        if (string.IsNullOrWhiteSpace(imdbId))
                        {
                            imdbId = reader.ReadElementContentAsString();
                        }

                        if (!string.IsNullOrWhiteSpace(imdbId))
                        {
                            item.SetProviderId(MetadataProvider.Imdb, imdbId);
                        }

                        if (!string.IsNullOrWhiteSpace(tmdbId))
                        {
                            item.SetProviderId(MetadataProvider.Tmdb, tmdbId);
                        }

                        break;
                    }

                case "set":
                    {

                        var tmdbcolid = reader.GetAttribute("tmdbcolid");

                        if (!string.IsNullOrWhiteSpace(tmdbcolid) && item is Movie movie)
                        {
                            movie.SetProviderId(MetadataProvider.TmdbCollection, tmdbcolid);
                        }

                        var val = reader.ReadInnerXml();

                        if (!string.IsNullOrWhiteSpace(val) && item is Movie movie)
                        {
                            // TODO Handle this better later
                            if (!val.Contains('<', StringComparison.Ordinal))
                            {
                                movie.CollectionName = val;
                            }
                            else
                            {
                                try
                                {
                                    ParseSetXml(val, movie);
                                }
                                catch (Exception ex)
                                {
                                    Logger.LogError(ex, "Error parsing set node");
                                }
                            }
                        }

                        break;
                    }

                case "artist":
                    {
                        var val = reader.ReadElementContentAsString();

                        if (!string.IsNullOrWhiteSpace(val) && item is MusicVideo movie)
                        {
                            var list = movie.Artists.ToList();
                            list.Add(val);
                            movie.Artists = list.ToArray();
                        }

                        break;
                    }

                case "album":
                    {
                        var val = reader.ReadElementContentAsString();

                        if (!string.IsNullOrWhiteSpace(val) && item is MusicVideo movie)
                        {
                            movie.Album = val;
                        }

                        break;
                    }

                default:
                    base.FetchDataFromXmlNode(reader, itemResult);
                    break;
            }
        }

        private void ParseSetXml(string xml, Movie movie)
        {
            // These are not going to be valid xml so no sense in causing the provider to fail and spamming the log with exceptions
            try
            {
                using (var stringReader = new StringReader("<set>" + xml + "</set>"))
                using (var reader = XmlReader.Create(stringReader, GetXmlReaderSettings()))
                {
                    reader.MoveToContent();
                    reader.Read();

                    // Loop through each element
                    while (!reader.EOF && reader.ReadState == ReadState.Interactive)
                    {
                        if (reader.NodeType == XmlNodeType.Element)
                        {
                            switch (reader.Name)
                            {
                                case "name":
                                    movie.CollectionName = reader.ReadElementContentAsString();
                                    break;
                                default:
                                    reader.Skip();
                                    break;
                            }
                        }
                        else
                        {
                            reader.Read();
                        }
                    }
                }
            }
            catch (XmlException)
            {
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MediaBrowser.XbmcMetadata\Parsers\MovieNfoParser.cs(83,78): error CS0128: A local variable or function named 'movie' is already defined in this scope,D:\a\1\s\MediaBrowser.XbmcMetadata\Parsers\MovieNfoParser.cs(88,33): error CS0165: Use of unassigned local variable 'movie'
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Emby.Photos\PhotoProvider.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Controller.Drawing;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Drawing;
using MediaBrowser.Model.Entities;
using Microsoft.Extensions.Logging;
using TagLib;
using TagLib.IFD;
using TagLib.IFD.Entries;
using TagLib.IFD.Tags;

namespace Emby.Photos
{
    /// <summary>
    /// Metadata provider for photos.
    /// </summary>
    public class PhotoProvider : ICustomMetadataProvider<Photo>, IForcedProvider, IHasItemChangeMonitor
    {
        private readonly ILogger<PhotoProvider> _logger;
        private readonly IImageProcessor _imageProcessor;

        // These are causing taglib to hang
        private readonly string[] _includeExtensions = new string[] { ".jpg", ".jpeg", ".png", ".tiff", ".cr2" };

        /// <summary>
        /// Initializes a new instance of the <see cref="PhotoProvider" /> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <param name="imageProcessor">The image processor.</param>
        public PhotoProvider(ILogger<PhotoProvider> logger, IImageProcessor imageProcessor)
        {
            _logger = logger;
            _imageProcessor = imageProcessor;
        }

        /// <inheritdoc />
        public string Name => "Embedded Information";

        /// <inheritdoc />
        public bool HasChanged(BaseItem item, IDirectoryService directoryService)
        {
            if (item.IsFileProtocol)
            {
                var file = directoryService.GetFile(item.Path);
                return file != null && file.LastWriteTimeUtc != item.DateModified;
            }

            return false;
        }

        /// <inheritdoc />
        public Task<ItemUpdateType> FetchAsync(Photo item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            item.SetImagePath(ImageType.Primary, item.Path);

            // Examples: https://github.com/mono/taglib-sharp/blob/a5f6949a53d09ce63ee7495580d6802921a21f14/tests/fixtures/TagLib.Tests.Images/NullOrientationTest.cs
            if (_includeExtensions.Contains(Path.GetExtension(item.Path), StringComparer.OrdinalIgnoreCase))
            {
                try
                {
                    using (var file = TagLib.File.Create(item.Path))
                    {
                        if (file.GetTag(TagTypes.TiffIFD) is IFDTag tag)
                        {
                            var structure = tag.Structure;
                            if (structure != null
                                && structure.GetEntry(0, (ushort)IFDEntryTag.ExifIFD) is SubIFDEntry exif)
                            {
                                var exifStructure = exif.Structure;
                                if (exifStructure != null)
                                {
                                    var entry = exifStructure.GetEntry(0, (ushort)ExifEntryTag.ApertureValue) as RationalIFDEntry;
                                    if (entry != null)
                                    {
                                        item.Aperture = (double)entry.Value.Numerator / entry.Value.Denominator;
                                    }

                                    entry = exifStructure.GetEntry(0, (ushort)ExifEntryTag.ShutterSpeedValue) as RationalIFDEntry;
                                    if (entry != null)
                                    {
                                        item.ShutterSpeed = (double)entry.Value.Numerator / entry.Value.Denominator;
                                    }
                                }
                            }
                        }

                        if (file is TagLib.Image.File image)
                        {
                            item.CameraMake = image.ImageTag.Make;
                            item.CameraModel = image.ImageTag.Model;

                            item.Width = image.Properties.PhotoWidth;
                            item.Height = image.Properties.PhotoHeight;

                            var rating = image.ImageTag.Rating;
                            item.CommunityRating = rating.HasValue ? rating : null;

                            item.Overview = image.ImageTag.Comment;

                            if (!string.IsNullOrWhiteSpace(image.ImageTag.Title)
                                && !item.LockedFields.Contains(MetadataField.Name))
                            {
                                item.Name = image.ImageTag.Title;
                            }

                            var dateTaken = image.ImageTag.DateTime;
                            if (dateTaken.HasValue)
                            {
                                item.DateCreated = dateTaken.Value;
                                item.PremiereDate = dateTaken.Value;
                                item.ProductionYear = dateTaken.Value.Year;
                            }

                            item.Genres = image.ImageTag.Genres;
                            item.Tags = image.ImageTag.Keywords;
                            item.Software = image.ImageTag.Software;

                            if (image.ImageTag.Orientation == TagLib.Image.ImageOrientation.None)
                            {
                                item.Orientation = null;
                            }
                            else if (Enum.TryParse(image.ImageTag.Orientation.ToString(), true, out ImageOrientation orientation))
                            {
                                item.Orientation = orientation;
                            }

                            item.ExposureTime = image.ImageTag.ExposureTime;
                            item.FocalLength = image.ImageTag.FocalLength;

                            item.Latitude = image.ImageTag.Latitude;
                            item.Longitude = image.ImageTag.Longitude;
                            item.Altitude = image.ImageTag.Altitude;

                            if (image.ImageTag.ISOSpeedRatings.HasValue)
                            {
                                item.IsoSpeedRating = Convert.ToInt32(image.ImageTag.ISOSpeedRatings.Value);
                            }
                            else
                            {
                                item.IsoSpeedRating = null;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Image Provider - Error reading image tag for {0}", item.Path);
                }
            }

            if (item.Width <= 0 || item.Height <= 0)
            {
                var img = item.GetImageInfo(ImageType.Primary, 0);

                try
                {
                    var size = _imageProcessor.GetImageDimensions(item, img);

                    if (size.Width > 0 && size.Height > 0)
                    {
                        item.Width = size.Width;
                        item.Height = size.Height;
                    }
                }
                catch (ArgumentException)
                {
                    // format not supported
                }
            }

            const ItemUpdateType Result = ItemUpdateType.ImageUpdate | ItemUpdateType.MetadataImport;
            return Task.FromResult(Result);
        }
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Controller.Drawing;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.Providers;
using MediaBrowser.Model.Drawing;
using MediaBrowser.Model.Entities;
using Microsoft.Extensions.Logging;
using TagLib;
using TagLib.IFD;
using TagLib.IFD.Entries;
using TagLib.IFD.Tags;

namespace Emby.Photos
{
    /// <summary>
    /// Metadata provider for photos.
    /// </summary>
    public class PhotoProvider : ICustomMetadataProvider<Photo>, IForcedProvider, IHasItemChangeMonitor
    {
        private readonly ILogger<PhotoProvider> _logger;
        private readonly IImageProcessor _imageProcessor;

        // These are causing taglib to hang
        private readonly string[] _includeExtensions = new string[] { ".jpg", ".jpeg", ".png", ".tiff", ".cr2" };

        /// <summary>
        /// Initializes a new instance of the <see cref="PhotoProvider" /> class.
        /// </summary>
        /// <param name="logger">The logger.</param>
        /// <param name="imageProcessor">The image processor.</param>
        public PhotoProvider(ILogger<PhotoProvider> logger, IImageProcessor imageProcessor)
        {
            _logger = logger;
            _imageProcessor = imageProcessor;
        }

        /// <inheritdoc />
        public string Name => "Embedded Information";

        /// <inheritdoc />
        public bool HasChanged(BaseItem item, IDirectoryService directoryService)
        {
            if (item.IsFileProtocol)
            {
                var file = directoryService.GetFile(item.Path);
                return file != null && file.LastWriteTimeUtc != item.DateModified;
            }

            return false;
        }

        /// <inheritdoc />
        public Task<ItemUpdateType> FetchAsync(Photo item, MetadataRefreshOptions options, CancellationToken cancellationToken)
        {
            item.SetImagePath(ImageType.Primary, item.Path);

            // Examples: https://github.com/mono/taglib-sharp/blob/a5f6949a53d09ce63ee7495580d6802921a21f14/tests/fixtures/TagLib.Tests.Images/NullOrientationTest.cs
            if (_includeExtensions.Contains(Path.GetExtension(item.Path), StringComparer.OrdinalIgnoreCase))
            {
                try
                {
                    using (var file = TagLib.File.Create(item.Path))
                    {
                        if (file.GetTag(TagTypes.TiffIFD) is IFDTag tag)
                        {
                            var structure = tag.Structure;
                            if (structure != null
                                && structure.GetEntry(0, (ushort)IFDEntryTag.ExifIFD) is SubIFDEntry exif)
                            {
                                var exifStructure = exif.Structure;
                                if (exifStructure != null)
                                {
                                    if (exifStructure.GetEntry(0, (ushort)ExifEntryTag.ApertureValue) is RationalIFDEntry entry)
                                    {
                                        item.Aperture = (double)entry.Value.Numerator / entry.Value.Denominator;
                                    }

                                    entry = exifStructure.GetEntry(0, (ushort)ExifEntryTag.ShutterSpeedValue) as RationalIFDEntry;

                                    if (exifStructure.GetEntry(0, (ushort)ExifEntryTag.ApertureValue) is RationalIFDEntry entry)
                                    {
                                        item.ShutterSpeed = (double)entry.Value.Numerator / entry.Value.Denominator;
                                    }
                                }
                            }
                        }

                        if (file is TagLib.Image.File image)
                        {
                            item.CameraMake = image.ImageTag.Make;
                            item.CameraModel = image.ImageTag.Model;

                            item.Width = image.Properties.PhotoWidth;
                            item.Height = image.Properties.PhotoHeight;

                            var rating = image.ImageTag.Rating;
                            item.CommunityRating = rating.HasValue ? rating : null;

                            item.Overview = image.ImageTag.Comment;

                            if (!string.IsNullOrWhiteSpace(image.ImageTag.Title)
                                && !item.LockedFields.Contains(MetadataField.Name))
                            {
                                item.Name = image.ImageTag.Title;
                            }

                            var dateTaken = image.ImageTag.DateTime;
                            if (dateTaken.HasValue)
                            {
                                item.DateCreated = dateTaken.Value;
                                item.PremiereDate = dateTaken.Value;
                                item.ProductionYear = dateTaken.Value.Year;
                            }

                            item.Genres = image.ImageTag.Genres;
                            item.Tags = image.ImageTag.Keywords;
                            item.Software = image.ImageTag.Software;

                            if (image.ImageTag.Orientation == TagLib.Image.ImageOrientation.None)
                            {
                                item.Orientation = null;
                            }
                            else if (Enum.TryParse(image.ImageTag.Orientation.ToString(), true, out ImageOrientation orientation))
                            {
                                item.Orientation = orientation;
                            }

                            item.ExposureTime = image.ImageTag.ExposureTime;
                            item.FocalLength = image.ImageTag.FocalLength;

                            item.Latitude = image.ImageTag.Latitude;
                            item.Longitude = image.ImageTag.Longitude;
                            item.Altitude = image.ImageTag.Altitude;

                            if (image.ImageTag.ISOSpeedRatings.HasValue)
                            {
                                item.IsoSpeedRating = Convert.ToInt32(image.ImageTag.ISOSpeedRatings.Value);
                            }
                            else
                            {
                                item.IsoSpeedRating = null;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Image Provider - Error reading image tag for {0}", item.Path);
                }
            }

            if (item.Width <= 0 || item.Height <= 0)
            {
                var img = item.GetImageInfo(ImageType.Primary, 0);

                try
                {
                    var size = _imageProcessor.GetImageDimensions(item, img);

                    if (size.Width > 0 && size.Height > 0)
                    {
                        item.Width = size.Width;
                        item.Height = size.Height;
                    }
                }
                catch (ArgumentException)
                {
                    // format not supported
                }
            }

            const ItemUpdateType Result = ItemUpdateType.ImageUpdate | ItemUpdateType.MetadataImport;
            return Task.FromResult(Result);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Emby.Photos\PhotoProvider.cs(85,123): error CS0128: A local variable or function named 'entry' is already defined in this scope,D:\a\1\s\Emby.Photos\PhotoProvider.cs(83,45): error CS8600: Converting null literal or possible null value to non-nullable type.,D:\a\1\s\Emby.Photos\PhotoProvider.cs(87,69): error CS8602: Dereference of a possibly null reference.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using MediaBrowser.Controller.Entities.TV;
using MediaBrowser.Controller.Library;
using MediaBrowser.Model.Entities;

namespace Emby.Server.Implementations.Library.Resolvers.TV
{
    /// <summary>
    /// Class EpisodeResolver.
    /// </summary>
    public class EpisodeResolver : BaseVideoResolver<Episode>
    {
        /// <summary>
        /// Resolves the specified args.
        /// </summary>
        /// <param name="args">The args.</param>
        /// <returns>Episode.</returns>
        protected override Episode Resolve(ItemResolveArgs args)
        {
            var parent = args.Parent;

            if (parent == null)
            {
                return null;
            }

            var season = parent as Season;

            // Just in case the user decided to nest episodes.
            // Not officially supported but in some cases we can handle it.
            if (season == null)
            {
                season = parent.GetParents().OfType<Season>().FirstOrDefault();
            }

            // If the parent is a Season or Series, then this is an Episode if the VideoResolver returns something
            // Also handle flat tv folders
            if (season != null ||
                string.Equals(args.GetCollectionType(), CollectionType.TvShows, StringComparison.OrdinalIgnoreCase) ||
                args.HasParent<Series>())
            {
                var episode = ResolveVideo<Episode>(args, false);

                if (episode != null)
                {
                    var series = parent as Series;
                    if (series == null)
                    {
                        series = parent.GetParents().OfType<Series>().FirstOrDefault();
                    }

                    if (series != null)
                    {
                        episode.SeriesId = series.Id;
                        episode.SeriesName = series.Name;
                    }

                    if (season != null)
                    {
                        episode.SeasonId = season.Id;
                        episode.SeasonName = season.Name;
                    }

                    // Assume season 1 if there's no season folder and a season number could not be determined
                    if (season == null && !episode.ParentIndexNumber.HasValue && (episode.IndexNumber.HasValue || episode.PremiereDate.HasValue))
                    {
                        episode.ParentIndexNumber = 1;
                    }
                }

                return episode;
            }

            return null;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EpisodeResolver"/> class.
        /// </summary>
        /// <param name="libraryManager">The library manager.</param>
        public EpisodeResolver(ILibraryManager libraryManager)
            : base(libraryManager)
        {
        }
    }
}

---- Transformed Tree ----
using System;
using System.Linq;
using MediaBrowser.Controller.Entities.TV;
using MediaBrowser.Controller.Library;
using MediaBrowser.Model.Entities;

namespace Emby.Server.Implementations.Library.Resolvers.TV
{
    /// <summary>
    /// Class EpisodeResolver.
    /// </summary>
    public class EpisodeResolver : BaseVideoResolver<Episode>
    {
        /// <summary>
        /// Resolves the specified args.
        /// </summary>
        /// <param name="args">The args.</param>
        /// <returns>Episode.</returns>
        protected override Episode Resolve(ItemResolveArgs args)
        {
            var parent = args.Parent;

            if (parent == null)
            {
                return null;
            }

            // Just in case the user decided to nest episodes.
            // Not officially supported but in some cases we can handle it.
            if (season == null)
            {
                season = parent.GetParents().OfType<Season>().FirstOrDefault();
            }

            // If the parent is a Season or Series, then this is an Episode if the VideoResolver returns something
            // Also handle flat tv folders
            if (parent is Season season ||
                string.Equals(args.GetCollectionType(), CollectionType.TvShows, StringComparison.OrdinalIgnoreCase) ||
                args.HasParent<Series>())
            {
                var episode = ResolveVideo<Episode>(args, false);

                if (episode != null)
                {
                    if (series == null)
                    {
                        series = parent.GetParents().OfType<Series>().FirstOrDefault();
                    }

                    if (parent is Series series)
                    {
                        episode.SeriesId = series.Id;
                        episode.SeriesName = series.Name;
                    }

                    if (parent is Season season)
                    {
                        episode.SeasonId = season.Id;
                        episode.SeasonName = season.Name;
                    }

                    // Assume season 1 if there's no season folder and a season number could not be determined
                    if (season == null && !episode.ParentIndexNumber.HasValue && (episode.IndexNumber.HasValue || episode.PremiereDate.HasValue))
                    {
                        episode.ParentIndexNumber = 1;
                    }
                }

                return episode;
            }

            return null;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EpisodeResolver"/> class.
        /// </summary>
        /// <param name="libraryManager">The library manager.</param>
        public EpisodeResolver(ILibraryManager libraryManager)
            : base(libraryManager)
        {
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(30,17): error CS0841: Cannot use local variable 'season' before it is declared,D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(32,17): error CS0841: Cannot use local variable 'season' before it is declared,D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(45,25): error CS0841: Cannot use local variable 'series' before it is declared,D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(47,25): error CS0841: Cannot use local variable 'series' before it is declared,D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(56,42): error CS0136: A local or parameter named 'season' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Emby.Server.Implementations\Library\Resolvers\TV\EpisodeResolver.cs(63,25): error CS0165: Use of unassigned local variable 'season'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Common.Json;
using MediaBrowser.Common.Net;
using MediaBrowser.Controller;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.LiveTv;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.IO;
using MediaBrowser.Model.LiveTv;
using MediaBrowser.Model.MediaInfo;
using MediaBrowser.Model.Net;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace Emby.Server.Implementations.LiveTv.TunerHosts.HdHomerun
{
    public class HdHomerunHost : BaseTunerHost, ITunerHost, IConfigurableTunerHost
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly IServerApplicationHost _appHost;
        private readonly ISocketFactory _socketFactory;
        private readonly INetworkManager _networkManager;
        private readonly IStreamHelper _streamHelper;

        private readonly JsonSerializerOptions _jsonOptions;

        private readonly Dictionary<string, DiscoverResponse> _modelCache = new Dictionary<string, DiscoverResponse>();

        public HdHomerunHost(
            IServerConfigurationManager config,
            ILogger<HdHomerunHost> logger,
            IFileSystem fileSystem,
            IHttpClientFactory httpClientFactory,
            IServerApplicationHost appHost,
            ISocketFactory socketFactory,
            INetworkManager networkManager,
            IStreamHelper streamHelper,
            IMemoryCache memoryCache)
            : base(config, logger, fileSystem, memoryCache)
        {
            _httpClientFactory = httpClientFactory;
            _appHost = appHost;
            _socketFactory = socketFactory;
            _networkManager = networkManager;
            _streamHelper = streamHelper;

            _jsonOptions = JsonDefaults.GetOptions();
        }

        public string Name => "HD Homerun";

        public override string Type => "hdhomerun";

        protected override string ChannelIdPrefix => "hdhr_";

        private string GetChannelId(TunerHostInfo info, Channels i)
            => ChannelIdPrefix + i.GuideNumber;

        internal async Task<List<Channels>> GetLineup(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            using var response = await _httpClientFactory.CreateClient(NamedClient.Default).GetAsync(model.LineupURL, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            var lineup = await JsonSerializer.DeserializeAsync<List<Channels>>(stream, _jsonOptions, cancellationToken)
                .ConfigureAwait(false) ?? new List<Channels>();

            if (info.ImportFavoritesOnly)
            {
                lineup = lineup.Where(i => i.Favorite).ToList();
            }

            return lineup.Where(i => !i.DRM).ToList();
        }

        private class HdHomerunChannelInfo : ChannelInfo
        {
            public bool IsLegacyTuner { get; set; }
        }

        protected override async Task<List<ChannelInfo>> GetChannelsInternal(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var lineup = await GetLineup(info, cancellationToken).ConfigureAwait(false);

            return lineup.Select(i => new HdHomerunChannelInfo
            {
                Name = i.GuideName,
                Number = i.GuideNumber,
                Id = GetChannelId(info, i),
                IsFavorite = i.Favorite,
                TunerHostId = info.Id,
                IsHD = i.HD,
                AudioCodec = i.AudioCodec,
                VideoCodec = i.VideoCodec,
                ChannelType = ChannelType.TV,
                IsLegacyTuner = (i.URL ?? string.Empty).StartsWith("hdhomerun", StringComparison.OrdinalIgnoreCase),
                Path = i.URL
            }).Cast<ChannelInfo>().ToList();
        }

        internal async Task<DiscoverResponse> GetModelInfo(TunerHostInfo info, bool throwAllExceptions, CancellationToken cancellationToken)
        {
            var cacheKey = info.Id;

            lock (_modelCache)
            {
                if (!string.IsNullOrEmpty(cacheKey))
                {
                    if (_modelCache.TryGetValue(cacheKey, out DiscoverResponse response))
                    {
                        return response;
                    }
                }
            }

            try
            {
                using var response = await _httpClientFactory.CreateClient(NamedClient.Default)
                    .GetAsync(GetApiUrl(info) + "/discover.json", HttpCompletionOption.ResponseHeadersRead, cancellationToken)
                    .ConfigureAwait(false);
                response.EnsureSuccessStatusCode();
                await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
                var discoverResponse = await JsonSerializer.DeserializeAsync<DiscoverResponse>(stream, _jsonOptions, cancellationToken)
                    .ConfigureAwait(false);

                if (!string.IsNullOrEmpty(cacheKey))
                {
                    lock (_modelCache)
                    {
                        _modelCache[cacheKey] = discoverResponse;
                    }
                }

                return discoverResponse;
            }
            catch (HttpRequestException ex)
            {
                if (!throwAllExceptions && ex.StatusCode.HasValue && ex.StatusCode.Value == HttpStatusCode.NotFound)
                {
                    const string DefaultValue = "HDHR";
                    var response = new DiscoverResponse
                    {
                        ModelNumber = DefaultValue
                    };
                    if (!string.IsNullOrEmpty(cacheKey))
                    {
                        // HDHR4 doesn't have this api
                        lock (_modelCache)
                        {
                            _modelCache[cacheKey] = response;
                        }
                    }

                    return response;
                }

                throw;
            }
        }

        private async Task<List<LiveTvTunerInfo>> GetTunerInfosHttp(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            using var response = await _httpClientFactory.CreateClient(NamedClient.Default)
                .GetAsync(string.Format(CultureInfo.InvariantCulture, "{0}/tuners.html", GetApiUrl(info)), HttpCompletionOption.ResponseHeadersRead, cancellationToken)
                .ConfigureAwait(false);
            await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            using var sr = new StreamReader(stream, System.Text.Encoding.UTF8);
            var tuners = new List<LiveTvTunerInfo>();
            while (!sr.EndOfStream)
            {
                string line = StripXML(sr.ReadLine());
                if (line.Contains("Channel", StringComparison.Ordinal))
                {
                    LiveTvTunerStatus status;
                    var index = line.IndexOf("Channel", StringComparison.OrdinalIgnoreCase);
                    var name = line.Substring(0, index - 1);
                    var currentChannel = line.Substring(index + 7);
                    if (currentChannel != "none")
                    {
                        status = LiveTvTunerStatus.LiveTv;
                    }
                    else
                    {
                        status = LiveTvTunerStatus.Available;
                    }

                    tuners.Add(new LiveTvTunerInfo
                    {
                        Name = name,
                        SourceType = string.IsNullOrWhiteSpace(model.ModelNumber) ? Name : model.ModelNumber,
                        ProgramName = currentChannel,
                        Status = status
                    });
                }
            }

            return tuners;
        }

        private static string StripXML(string source)
        {
            if (string.IsNullOrEmpty(source))
            {
                return string.Empty;
            }

            char[] buffer = new char[source.Length];
            int bufferIndex = 0;
            bool inside = false;

            for (int i = 0; i < source.Length; i++)
            {
                char let = source[i];
                if (let == '<')
                {
                    inside = true;
                    continue;
                }

                if (let == '>')
                {
                    inside = false;
                    continue;
                }

                if (!inside)
                {
                    buffer[bufferIndex++] = let;
                }
            }

            return new string(buffer, 0, bufferIndex);
        }

        private async Task<List<LiveTvTunerInfo>> GetTunerInfosUdp(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            var tuners = new List<LiveTvTunerInfo>();

            var uri = new Uri(GetApiUrl(info));

            using (var manager = new HdHomerunManager())
            {
                // Legacy HdHomeruns are IPv4 only
                var ipInfo = IPAddress.Parse(uri.Host);

                for (int i = 0; i < model.TunerCount; ++i)
                {
                    var name = string.Format(CultureInfo.InvariantCulture, "Tuner {0}", i + 1);
                    var currentChannel = "none"; // @todo Get current channel and map back to Station Id
                    var isAvailable = await manager.CheckTunerAvailability(ipInfo, i, cancellationToken).ConfigureAwait(false);
                    var status = isAvailable ? LiveTvTunerStatus.Available : LiveTvTunerStatus.LiveTv;
                    tuners.Add(new LiveTvTunerInfo
                    {
                        Name = name,
                        SourceType = string.IsNullOrWhiteSpace(model.ModelNumber) ? Name : model.ModelNumber,
                        ProgramName = currentChannel,
                        Status = status
                    });
                }
            }

            return tuners;
        }

        public async Task<List<LiveTvTunerInfo>> GetTunerInfos(CancellationToken cancellationToken)
        {
            var list = new List<LiveTvTunerInfo>();

            foreach (var host in GetConfiguration().TunerHosts
                .Where(i => string.Equals(i.Type, Type, StringComparison.OrdinalIgnoreCase)))
            {
                try
                {
                    list.AddRange(await GetTunerInfos(host, cancellationToken).ConfigureAwait(false));
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error getting tuner info");
                }
            }

            return list;
        }

        public async Task<List<LiveTvTunerInfo>> GetTunerInfos(TunerHostInfo info, CancellationToken cancellationToken)
        {
            // TODO Need faster way to determine UDP vs HTTP
            var channels = await GetChannels(info, true, cancellationToken).ConfigureAwait(false);

            var hdHomerunChannelInfo = channels.FirstOrDefault() as HdHomerunChannelInfo;

            if (hdHomerunChannelInfo == null || hdHomerunChannelInfo.IsLegacyTuner)
            {
                return await GetTunerInfosUdp(info, cancellationToken).ConfigureAwait(false);
            }

            return await GetTunerInfosHttp(info, cancellationToken).ConfigureAwait(false);
        }

        private static string GetApiUrl(TunerHostInfo info)
        {
            var url = info.Url;

            if (string.IsNullOrWhiteSpace(url))
            {
                throw new ArgumentException("Invalid tuner info");
            }

            if (!url.StartsWith("http", StringComparison.OrdinalIgnoreCase))
            {
                url = "http://" + url;
            }

            return new Uri(url).AbsoluteUri.TrimEnd('/');
        }

        private static string GetHdHrIdFromChannelId(string channelId)
        {
            return channelId.Split('_')[1];
        }

        private MediaSourceInfo GetMediaSource(TunerHostInfo info, string channelId, ChannelInfo channelInfo, string profile)
        {
            int? width = null;
            int? height = null;
            bool isInterlaced = true;
            string videoCodec = null;

            int? videoBitrate = null;

            var isHd = channelInfo.IsHD ?? true;

            if (string.Equals(profile, "mobile", StringComparison.OrdinalIgnoreCase))
            {
                width = 1280;
                height = 720;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2000000;
            }
            else if (string.Equals(profile, "heavy", StringComparison.OrdinalIgnoreCase))
            {
                width = 1920;
                height = 1080;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 15000000;
            }
            else if (string.Equals(profile, "internet720", StringComparison.OrdinalIgnoreCase))
            {
                width = 1280;
                height = 720;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 8000000;
            }
            else if (string.Equals(profile, "internet540", StringComparison.OrdinalIgnoreCase))
            {
                width = 960;
                height = 540;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2500000;
            }
            else if (string.Equals(profile, "internet480", StringComparison.OrdinalIgnoreCase))
            {
                width = 848;
                height = 480;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2000000;
            }
            else if (string.Equals(profile, "internet360", StringComparison.OrdinalIgnoreCase))
            {
                width = 640;
                height = 360;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 1500000;
            }
            else if (string.Equals(profile, "internet240", StringComparison.OrdinalIgnoreCase))
            {
                width = 432;
                height = 240;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 1000000;
            }
            else
            {
                // This is for android tv's 1200 condition. Remove once not needed anymore so that we can avoid possible side effects of dummying up this data
                if (isHd)
                {
                    width = 1920;
                    height = 1080;
                }
            }

            if (string.IsNullOrWhiteSpace(videoCodec))
            {
                videoCodec = channelInfo.VideoCodec;
            }

            string audioCodec = channelInfo.AudioCodec;

            if (!videoBitrate.HasValue)
            {
                videoBitrate = isHd ? 15000000 : 2000000;
            }

            int? audioBitrate = isHd ? 448000 : 192000;

            // normalize
            if (string.Equals(videoCodec, "mpeg2", StringComparison.OrdinalIgnoreCase))
            {
                videoCodec = "mpeg2video";
            }

            string nal = null;
            if (string.Equals(videoCodec, "h264", StringComparison.OrdinalIgnoreCase))
            {
                nal = "0";
            }

            var url = GetApiUrl(info);

            var id = profile;
            if (string.IsNullOrWhiteSpace(id))
            {
                id = "native";
            }

            id += "_" + channelId.GetMD5().ToString("N", CultureInfo.InvariantCulture) + "_" + url.GetMD5().ToString("N", CultureInfo.InvariantCulture);

            var mediaSource = new MediaSourceInfo
            {
                Path = url,
                Protocol = MediaProtocol.Udp,
                MediaStreams = new List<MediaStream>
                        {
                            new MediaStream
                            {
                                Type = MediaStreamType.Video,
                                // Set the index to -1 because we don't know the exact index of the video stream within the container
                                Index = -1,
                                IsInterlaced = isInterlaced,
                                Codec = videoCodec,
                                Width = width,
                                Height = height,
                                BitRate = videoBitrate,
                                NalLengthSize = nal
                            },
                            new MediaStream
                            {
                                Type = MediaStreamType.Audio,
                                // Set the index to -1 because we don't know the exact index of the audio stream within the container
                                Index = -1,
                                Codec = audioCodec,
                                BitRate = audioBitrate
                            }
                        },
                RequiresOpening = true,
                RequiresClosing = true,
                BufferMs = 0,
                Container = "ts",
                Id = id,
                SupportsDirectPlay = false,
                SupportsDirectStream = true,
                SupportsTranscoding = true,
                IsInfiniteStream = true,
                IgnoreDts = true,
                // IgnoreIndex = true,
                // ReadAtNativeFramerate = true
            };

            mediaSource.InferTotalBitrate();

            return mediaSource;
        }

        protected override async Task<List<MediaSourceInfo>> GetChannelStreamMediaSources(TunerHostInfo info, ChannelInfo channelInfo, CancellationToken cancellationToken)
        {
            var list = new List<MediaSourceInfo>();

            var channelId = channelInfo.Id;
            var hdhrId = GetHdHrIdFromChannelId(channelId);

            var hdHomerunChannelInfo = channelInfo as HdHomerunChannelInfo;

            var isLegacyTuner = hdHomerunChannelInfo != null && hdHomerunChannelInfo.IsLegacyTuner;

            if (isLegacyTuner)
            {
                list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
            }
            else
            {
                var modelInfo = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

                if (modelInfo != null && modelInfo.SupportsTranscoding)
                {
                    if (info.AllowHWTranscoding)
                    {
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "heavy"));

                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet540"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet480"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet360"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet240"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "mobile"));
                    }

                    list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
                }

                if (list.Count == 0)
                {
                    list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
                }
            }

            return list;
        }

        protected override async Task<ILiveStream> GetChannelStream(TunerHostInfo info, ChannelInfo channelInfo, string streamId, List<ILiveStream> currentLiveStreams, CancellationToken cancellationToken)
        {
            var tunerCount = info.TunerCount;

            if (tunerCount > 0)
            {
                var tunerHostId = info.Id;
                var liveStreams = currentLiveStreams.Where(i => string.Equals(i.TunerHostId, tunerHostId, StringComparison.OrdinalIgnoreCase));

                if (liveStreams.Count() >= tunerCount)
                {
                    throw new LiveTvConflictException("HDHomeRun simultaneous stream limit has been reached.");
                }
            }

            var profile = streamId.Split('_')[0];

            Logger.LogInformation("GetChannelStream: channel id: {0}. stream id: {1} profile: {2}", channelInfo.Id, streamId, profile);

            var hdhrId = GetHdHrIdFromChannelId(channelInfo.Id);

            var hdhomerunChannel = channelInfo as HdHomerunChannelInfo;

            var modelInfo = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            if (!modelInfo.SupportsTranscoding)
            {
                profile = "native";
            }

            var mediaSource = GetMediaSource(info, hdhrId, channelInfo, profile);

            if (hdhomerunChannel != null && hdhomerunChannel.IsLegacyTuner)
            {
                return new HdHomerunUdpStream(
                    mediaSource,
                    info,
                    streamId,
                    new LegacyHdHomerunChannelCommands(hdhomerunChannel.Path),
                    modelInfo.TunerCount,
                    FileSystem,
                    Logger,
                    Config,
                    _appHost,
                    _networkManager,
                    _streamHelper);
            }

            var enableHttpStream = true;
            if (enableHttpStream)
            {
                mediaSource.Protocol = MediaProtocol.Http;

                var httpUrl = channelInfo.Path;

                // If raw was used, the tuner doesn't support params
                if (!string.IsNullOrWhiteSpace(profile) && !string.Equals(profile, "native", StringComparison.OrdinalIgnoreCase))
                {
                    httpUrl += "?transcode=" + profile;
                }

                mediaSource.Path = httpUrl;

                return new SharedHttpStream(
                    mediaSource,
                    info,
                    streamId,
                    FileSystem,
                    _httpClientFactory,
                    Logger,
                    Config,
                    _appHost,
                    _streamHelper);
            }

            return new HdHomerunUdpStream(
                mediaSource,
                info,
                streamId,
                new HdHomerunChannelCommands(hdhomerunChannel.Number, profile),
                modelInfo.TunerCount,
                FileSystem,
                Logger,
                Config,
                _appHost,
                _networkManager,
                _streamHelper);
        }

        public async Task Validate(TunerHostInfo info)
        {
            lock (_modelCache)
            {
                _modelCache.Clear();
            }

            try
            {
                // Test it by pulling down the lineup
                var modelInfo = await GetModelInfo(info, true, CancellationToken.None).ConfigureAwait(false);
                info.DeviceId = modelInfo.DeviceID;
            }
            catch (HttpRequestException ex)
            {
                if (ex.StatusCode.HasValue && ex.StatusCode.Value == System.Net.HttpStatusCode.NotFound)
                {
                    // HDHR4 doesn't have this api
                    return;
                }

                throw;
            }
        }

        public async Task<List<TunerHostInfo>> DiscoverDevices(int discoveryDurationMs, CancellationToken cancellationToken)
        {
            lock (_modelCache)
            {
                _modelCache.Clear();
            }

            cancellationToken = CancellationTokenSource.CreateLinkedTokenSource(new CancellationTokenSource(discoveryDurationMs).Token, cancellationToken).Token;
            var list = new List<TunerHostInfo>();

            // Create udp broadcast discovery message
            byte[] discBytes = { 0, 2, 0, 12, 1, 4, 255, 255, 255, 255, 2, 4, 255, 255, 255, 255, 115, 204, 125, 143 };
            using (var udpClient = _socketFactory.CreateUdpBroadcastSocket(0))
            {
                // Need a way to set the Receive timeout on the socket otherwise this might never timeout?
                try
                {
                    await udpClient.SendToAsync(discBytes, 0, discBytes.Length, new IPEndPoint(IPAddress.Parse("255.255.255.255"), 65001), cancellationToken).ConfigureAwait(false);
                    var receiveBuffer = new byte[8192];

                    while (!cancellationToken.IsCancellationRequested)
                    {
                        var response = await udpClient.ReceiveAsync(receiveBuffer, 0, receiveBuffer.Length, cancellationToken).ConfigureAwait(false);
                        var deviceIp = response.RemoteEndPoint.Address.ToString();

                        // check to make sure we have enough bytes received to be a valid message and make sure the 2nd byte is the discover reply byte
                        if (response.ReceivedBytes > 13 && response.Buffer[1] == 3)
                        {
                            var deviceAddress = "http://" + deviceIp;

                            var info = await TryGetTunerHostInfo(deviceAddress, cancellationToken).ConfigureAwait(false);

                            if (info != null)
                            {
                                list.Add(info);
                            }
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                }
                catch (Exception ex)
                {
                    // Socket timeout indicates all messages have been received.
                    Logger.LogError(ex, "Error while sending discovery message");
                }
            }

            return list;
        }

        internal async Task<TunerHostInfo> TryGetTunerHostInfo(string url, CancellationToken cancellationToken)
        {
            var hostInfo = new TunerHostInfo
            {
                Type = Type,
                Url = url
            };

            var modelInfo = await GetModelInfo(hostInfo, false, cancellationToken).ConfigureAwait(false);

            hostInfo.DeviceId = modelInfo.DeviceID;
            hostInfo.FriendlyName = modelInfo.FriendlyName;
            hostInfo.TunerCount = modelInfo.TunerCount;

            return hostInfo;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Common.Json;
using MediaBrowser.Common.Net;
using MediaBrowser.Controller;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.LiveTv;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.IO;
using MediaBrowser.Model.LiveTv;
using MediaBrowser.Model.MediaInfo;
using MediaBrowser.Model.Net;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;

namespace Emby.Server.Implementations.LiveTv.TunerHosts.HdHomerun
{
    public class HdHomerunHost : BaseTunerHost, ITunerHost, IConfigurableTunerHost
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly IServerApplicationHost _appHost;
        private readonly ISocketFactory _socketFactory;
        private readonly INetworkManager _networkManager;
        private readonly IStreamHelper _streamHelper;

        private readonly JsonSerializerOptions _jsonOptions;

        private readonly Dictionary<string, DiscoverResponse> _modelCache = new Dictionary<string, DiscoverResponse>();

        public HdHomerunHost(
            IServerConfigurationManager config,
            ILogger<HdHomerunHost> logger,
            IFileSystem fileSystem,
            IHttpClientFactory httpClientFactory,
            IServerApplicationHost appHost,
            ISocketFactory socketFactory,
            INetworkManager networkManager,
            IStreamHelper streamHelper,
            IMemoryCache memoryCache)
            : base(config, logger, fileSystem, memoryCache)
        {
            _httpClientFactory = httpClientFactory;
            _appHost = appHost;
            _socketFactory = socketFactory;
            _networkManager = networkManager;
            _streamHelper = streamHelper;

            _jsonOptions = JsonDefaults.GetOptions();
        }

        public string Name => "HD Homerun";

        public override string Type => "hdhomerun";

        protected override string ChannelIdPrefix => "hdhr_";

        private string GetChannelId(TunerHostInfo info, Channels i)
            => ChannelIdPrefix + i.GuideNumber;

        internal async Task<List<Channels>> GetLineup(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            using var response = await _httpClientFactory.CreateClient(NamedClient.Default).GetAsync(model.LineupURL, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
            await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            var lineup = await JsonSerializer.DeserializeAsync<List<Channels>>(stream, _jsonOptions, cancellationToken)
                .ConfigureAwait(false) ?? new List<Channels>();

            if (info.ImportFavoritesOnly)
            {
                lineup = lineup.Where(i => i.Favorite).ToList();
            }

            return lineup.Where(i => !i.DRM).ToList();
        }

        private class HdHomerunChannelInfo : ChannelInfo
        {
            public bool IsLegacyTuner { get; set; }
        }

        protected override async Task<List<ChannelInfo>> GetChannelsInternal(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var lineup = await GetLineup(info, cancellationToken).ConfigureAwait(false);

            return lineup.Select(i => new HdHomerunChannelInfo
            {
                Name = i.GuideName,
                Number = i.GuideNumber,
                Id = GetChannelId(info, i),
                IsFavorite = i.Favorite,
                TunerHostId = info.Id,
                IsHD = i.HD,
                AudioCodec = i.AudioCodec,
                VideoCodec = i.VideoCodec,
                ChannelType = ChannelType.TV,
                IsLegacyTuner = (i.URL ?? string.Empty).StartsWith("hdhomerun", StringComparison.OrdinalIgnoreCase),
                Path = i.URL
            }).Cast<ChannelInfo>().ToList();
        }

        internal async Task<DiscoverResponse> GetModelInfo(TunerHostInfo info, bool throwAllExceptions, CancellationToken cancellationToken)
        {
            var cacheKey = info.Id;

            lock (_modelCache)
            {
                if (!string.IsNullOrEmpty(cacheKey))
                {
                    if (_modelCache.TryGetValue(cacheKey, out DiscoverResponse response))
                    {
                        return response;
                    }
                }
            }

            try
            {
                using var response = await _httpClientFactory.CreateClient(NamedClient.Default)
                    .GetAsync(GetApiUrl(info) + "/discover.json", HttpCompletionOption.ResponseHeadersRead, cancellationToken)
                    .ConfigureAwait(false);
                response.EnsureSuccessStatusCode();
                await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
                var discoverResponse = await JsonSerializer.DeserializeAsync<DiscoverResponse>(stream, _jsonOptions, cancellationToken)
                    .ConfigureAwait(false);

                if (!string.IsNullOrEmpty(cacheKey))
                {
                    lock (_modelCache)
                    {
                        _modelCache[cacheKey] = discoverResponse;
                    }
                }

                return discoverResponse;
            }
            catch (HttpRequestException ex)
            {
                if (!throwAllExceptions && ex.StatusCode.HasValue && ex.StatusCode.Value == HttpStatusCode.NotFound)
                {
                    const string DefaultValue = "HDHR";
                    var response = new DiscoverResponse
                    {
                        ModelNumber = DefaultValue
                    };
                    if (!string.IsNullOrEmpty(cacheKey))
                    {
                        // HDHR4 doesn't have this api
                        lock (_modelCache)
                        {
                            _modelCache[cacheKey] = response;
                        }
                    }

                    return response;
                }

                throw;
            }
        }

        private async Task<List<LiveTvTunerInfo>> GetTunerInfosHttp(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            using var response = await _httpClientFactory.CreateClient(NamedClient.Default)
                .GetAsync(string.Format(CultureInfo.InvariantCulture, "{0}/tuners.html", GetApiUrl(info)), HttpCompletionOption.ResponseHeadersRead, cancellationToken)
                .ConfigureAwait(false);
            await using var stream = await response.Content.ReadAsStreamAsync(cancellationToken).ConfigureAwait(false);
            using var sr = new StreamReader(stream, System.Text.Encoding.UTF8);
            var tuners = new List<LiveTvTunerInfo>();
            while (!sr.EndOfStream)
            {
                string line = StripXML(sr.ReadLine());
                if (line.Contains("Channel", StringComparison.Ordinal))
                {
                    LiveTvTunerStatus status;
                    var index = line.IndexOf("Channel", StringComparison.OrdinalIgnoreCase);
                    var name = line.Substring(0, index - 1);
                    var currentChannel = line.Substring(index + 7);
                    if (currentChannel != "none")
                    {
                        status = LiveTvTunerStatus.LiveTv;
                    }
                    else
                    {
                        status = LiveTvTunerStatus.Available;
                    }

                    tuners.Add(new LiveTvTunerInfo
                    {
                        Name = name,
                        SourceType = string.IsNullOrWhiteSpace(model.ModelNumber) ? Name : model.ModelNumber,
                        ProgramName = currentChannel,
                        Status = status
                    });
                }
            }

            return tuners;
        }

        private static string StripXML(string source)
        {
            if (string.IsNullOrEmpty(source))
            {
                return string.Empty;
            }

            char[] buffer = new char[source.Length];
            int bufferIndex = 0;
            bool inside = false;

            for (int i = 0; i < source.Length; i++)
            {
                char let = source[i];
                if (let == '<')
                {
                    inside = true;
                    continue;
                }

                if (let == '>')
                {
                    inside = false;
                    continue;
                }

                if (!inside)
                {
                    buffer[bufferIndex++] = let;
                }
            }

            return new string(buffer, 0, bufferIndex);
        }

        private async Task<List<LiveTvTunerInfo>> GetTunerInfosUdp(TunerHostInfo info, CancellationToken cancellationToken)
        {
            var model = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            var tuners = new List<LiveTvTunerInfo>();

            var uri = new Uri(GetApiUrl(info));

            using (var manager = new HdHomerunManager())
            {
                // Legacy HdHomeruns are IPv4 only
                var ipInfo = IPAddress.Parse(uri.Host);

                for (int i = 0; i < model.TunerCount; ++i)
                {
                    var name = string.Format(CultureInfo.InvariantCulture, "Tuner {0}", i + 1);
                    var currentChannel = "none"; // @todo Get current channel and map back to Station Id
                    var isAvailable = await manager.CheckTunerAvailability(ipInfo, i, cancellationToken).ConfigureAwait(false);
                    var status = isAvailable ? LiveTvTunerStatus.Available : LiveTvTunerStatus.LiveTv;
                    tuners.Add(new LiveTvTunerInfo
                    {
                        Name = name,
                        SourceType = string.IsNullOrWhiteSpace(model.ModelNumber) ? Name : model.ModelNumber,
                        ProgramName = currentChannel,
                        Status = status
                    });
                }
            }

            return tuners;
        }

        public async Task<List<LiveTvTunerInfo>> GetTunerInfos(CancellationToken cancellationToken)
        {
            var list = new List<LiveTvTunerInfo>();

            foreach (var host in GetConfiguration().TunerHosts
                .Where(i => string.Equals(i.Type, Type, StringComparison.OrdinalIgnoreCase)))
            {
                try
                {
                    list.AddRange(await GetTunerInfos(host, cancellationToken).ConfigureAwait(false));
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Error getting tuner info");
                }
            }

            return list;
        }

        public async Task<List<LiveTvTunerInfo>> GetTunerInfos(TunerHostInfo info, CancellationToken cancellationToken)
        {
            // TODO Need faster way to determine UDP vs HTTP
            var channels = await GetChannels(info, true, cancellationToken).ConfigureAwait(false);

            var hdHomerunChannelInfo = channels.FirstOrDefault() as HdHomerunChannelInfo;

            if (hdHomerunChannelInfo == null || hdHomerunChannelInfo.IsLegacyTuner)
            {
                return await GetTunerInfosUdp(info, cancellationToken).ConfigureAwait(false);
            }

            return await GetTunerInfosHttp(info, cancellationToken).ConfigureAwait(false);
        }

        private static string GetApiUrl(TunerHostInfo info)
        {
            var url = info.Url;

            if (string.IsNullOrWhiteSpace(url))
            {
                throw new ArgumentException("Invalid tuner info");
            }

            if (!url.StartsWith("http", StringComparison.OrdinalIgnoreCase))
            {
                url = "http://" + url;
            }

            return new Uri(url).AbsoluteUri.TrimEnd('/');
        }

        private static string GetHdHrIdFromChannelId(string channelId)
        {
            return channelId.Split('_')[1];
        }

        private MediaSourceInfo GetMediaSource(TunerHostInfo info, string channelId, ChannelInfo channelInfo, string profile)
        {
            int? width = null;
            int? height = null;
            bool isInterlaced = true;
            string videoCodec = null;

            int? videoBitrate = null;

            var isHd = channelInfo.IsHD ?? true;

            if (string.Equals(profile, "mobile", StringComparison.OrdinalIgnoreCase))
            {
                width = 1280;
                height = 720;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2000000;
            }
            else if (string.Equals(profile, "heavy", StringComparison.OrdinalIgnoreCase))
            {
                width = 1920;
                height = 1080;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 15000000;
            }
            else if (string.Equals(profile, "internet720", StringComparison.OrdinalIgnoreCase))
            {
                width = 1280;
                height = 720;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 8000000;
            }
            else if (string.Equals(profile, "internet540", StringComparison.OrdinalIgnoreCase))
            {
                width = 960;
                height = 540;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2500000;
            }
            else if (string.Equals(profile, "internet480", StringComparison.OrdinalIgnoreCase))
            {
                width = 848;
                height = 480;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 2000000;
            }
            else if (string.Equals(profile, "internet360", StringComparison.OrdinalIgnoreCase))
            {
                width = 640;
                height = 360;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 1500000;
            }
            else if (string.Equals(profile, "internet240", StringComparison.OrdinalIgnoreCase))
            {
                width = 432;
                height = 240;
                isInterlaced = false;
                videoCodec = "h264";
                videoBitrate = 1000000;
            }
            else
            {
                // This is for android tv's 1200 condition. Remove once not needed anymore so that we can avoid possible side effects of dummying up this data
                if (isHd)
                {
                    width = 1920;
                    height = 1080;
                }
            }

            if (string.IsNullOrWhiteSpace(videoCodec))
            {
                videoCodec = channelInfo.VideoCodec;
            }

            string audioCodec = channelInfo.AudioCodec;

            if (!videoBitrate.HasValue)
            {
                videoBitrate = isHd ? 15000000 : 2000000;
            }

            int? audioBitrate = isHd ? 448000 : 192000;

            // normalize
            if (string.Equals(videoCodec, "mpeg2", StringComparison.OrdinalIgnoreCase))
            {
                videoCodec = "mpeg2video";
            }

            string nal = null;
            if (string.Equals(videoCodec, "h264", StringComparison.OrdinalIgnoreCase))
            {
                nal = "0";
            }

            var url = GetApiUrl(info);

            var id = profile;
            if (string.IsNullOrWhiteSpace(id))
            {
                id = "native";
            }

            id += "_" + channelId.GetMD5().ToString("N", CultureInfo.InvariantCulture) + "_" + url.GetMD5().ToString("N", CultureInfo.InvariantCulture);

            var mediaSource = new MediaSourceInfo
            {
                Path = url,
                Protocol = MediaProtocol.Udp,
                MediaStreams = new List<MediaStream>
                        {
                            new MediaStream
                            {
                                Type = MediaStreamType.Video,
                                // Set the index to -1 because we don't know the exact index of the video stream within the container
                                Index = -1,
                                IsInterlaced = isInterlaced,
                                Codec = videoCodec,
                                Width = width,
                                Height = height,
                                BitRate = videoBitrate,
                                NalLengthSize = nal
                            },
                            new MediaStream
                            {
                                Type = MediaStreamType.Audio,
                                // Set the index to -1 because we don't know the exact index of the audio stream within the container
                                Index = -1,
                                Codec = audioCodec,
                                BitRate = audioBitrate
                            }
                        },
                RequiresOpening = true,
                RequiresClosing = true,
                BufferMs = 0,
                Container = "ts",
                Id = id,
                SupportsDirectPlay = false,
                SupportsDirectStream = true,
                SupportsTranscoding = true,
                IsInfiniteStream = true,
                IgnoreDts = true,
                // IgnoreIndex = true,
                // ReadAtNativeFramerate = true
            };

            mediaSource.InferTotalBitrate();

            return mediaSource;
        }

        protected override async Task<List<MediaSourceInfo>> GetChannelStreamMediaSources(TunerHostInfo info, ChannelInfo channelInfo, CancellationToken cancellationToken)
        {
            var list = new List<MediaSourceInfo>();

            var channelId = channelInfo.Id;
            var hdhrId = GetHdHrIdFromChannelId(channelId);

            var hdHomerunChannelInfo = channelInfo as HdHomerunChannelInfo;

            var isLegacyTuner = hdHomerunChannelInfo != null && hdHomerunChannelInfo.IsLegacyTuner;

            if (isLegacyTuner)
            {
                list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
            }
            else
            {
                var modelInfo = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

                if (modelInfo != null && modelInfo.SupportsTranscoding)
                {
                    if (info.AllowHWTranscoding)
                    {
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "heavy"));

                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet540"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet480"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet360"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "internet240"));
                        list.Add(GetMediaSource(info, hdhrId, channelInfo, "mobile"));
                    }

                    list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
                }

                if (list.Count == 0)
                {
                    list.Add(GetMediaSource(info, hdhrId, channelInfo, "native"));
                }
            }

            return list;
        }

        protected override async Task<ILiveStream> GetChannelStream(TunerHostInfo info, ChannelInfo channelInfo, string streamId, List<ILiveStream> currentLiveStreams, CancellationToken cancellationToken)
        {
            var tunerCount = info.TunerCount;

            if (tunerCount > 0)
            {
                var tunerHostId = info.Id;
                var liveStreams = currentLiveStreams.Where(i => string.Equals(i.TunerHostId, tunerHostId, StringComparison.OrdinalIgnoreCase));

                if (liveStreams.Count() >= tunerCount)
                {
                    throw new LiveTvConflictException("HDHomeRun simultaneous stream limit has been reached.");
                }
            }

            var profile = streamId.Split('_')[0];

            Logger.LogInformation("GetChannelStream: channel id: {0}. stream id: {1} profile: {2}", channelInfo.Id, streamId, profile);

            var hdhrId = GetHdHrIdFromChannelId(channelInfo.Id);

            var modelInfo = await GetModelInfo(info, false, cancellationToken).ConfigureAwait(false);

            if (!modelInfo.SupportsTranscoding)
            {
                profile = "native";
            }

            var mediaSource = GetMediaSource(info, hdhrId, channelInfo, profile);

            if (channelInfo is HdHomerunChannelInfo hdhomerunChannel && hdhomerunChannel.IsLegacyTuner)
            {
                return new HdHomerunUdpStream(
                    mediaSource,
                    info,
                    streamId,
                    new LegacyHdHomerunChannelCommands(hdhomerunChannel.Path),
                    modelInfo.TunerCount,
                    FileSystem,
                    Logger,
                    Config,
                    _appHost,
                    _networkManager,
                    _streamHelper);
            }

            var enableHttpStream = true;
            if (enableHttpStream)
            {
                mediaSource.Protocol = MediaProtocol.Http;

                var httpUrl = channelInfo.Path;

                // If raw was used, the tuner doesn't support params
                if (!string.IsNullOrWhiteSpace(profile) && !string.Equals(profile, "native", StringComparison.OrdinalIgnoreCase))
                {
                    httpUrl += "?transcode=" + profile;
                }

                mediaSource.Path = httpUrl;

                return new SharedHttpStream(
                    mediaSource,
                    info,
                    streamId,
                    FileSystem,
                    _httpClientFactory,
                    Logger,
                    Config,
                    _appHost,
                    _streamHelper);
            }

            return new HdHomerunUdpStream(
                mediaSource,
                info,
                streamId,
                new HdHomerunChannelCommands(hdhomerunChannel.Number, profile),
                modelInfo.TunerCount,
                FileSystem,
                Logger,
                Config,
                _appHost,
                _networkManager,
                _streamHelper);
        }

        public async Task Validate(TunerHostInfo info)
        {
            lock (_modelCache)
            {
                _modelCache.Clear();
            }

            try
            {
                // Test it by pulling down the lineup
                var modelInfo = await GetModelInfo(info, true, CancellationToken.None).ConfigureAwait(false);
                info.DeviceId = modelInfo.DeviceID;
            }
            catch (HttpRequestException ex)
            {
                if (ex.StatusCode.HasValue && ex.StatusCode.Value == System.Net.HttpStatusCode.NotFound)
                {
                    // HDHR4 doesn't have this api
                    return;
                }

                throw;
            }
        }

        public async Task<List<TunerHostInfo>> DiscoverDevices(int discoveryDurationMs, CancellationToken cancellationToken)
        {
            lock (_modelCache)
            {
                _modelCache.Clear();
            }

            cancellationToken = CancellationTokenSource.CreateLinkedTokenSource(new CancellationTokenSource(discoveryDurationMs).Token, cancellationToken).Token;
            var list = new List<TunerHostInfo>();

            // Create udp broadcast discovery message
            byte[] discBytes = { 0, 2, 0, 12, 1, 4, 255, 255, 255, 255, 2, 4, 255, 255, 255, 255, 115, 204, 125, 143 };
            using (var udpClient = _socketFactory.CreateUdpBroadcastSocket(0))
            {
                // Need a way to set the Receive timeout on the socket otherwise this might never timeout?
                try
                {
                    await udpClient.SendToAsync(discBytes, 0, discBytes.Length, new IPEndPoint(IPAddress.Parse("255.255.255.255"), 65001), cancellationToken).ConfigureAwait(false);
                    var receiveBuffer = new byte[8192];

                    while (!cancellationToken.IsCancellationRequested)
                    {
                        var response = await udpClient.ReceiveAsync(receiveBuffer, 0, receiveBuffer.Length, cancellationToken).ConfigureAwait(false);
                        var deviceIp = response.RemoteEndPoint.Address.ToString();

                        // check to make sure we have enough bytes received to be a valid message and make sure the 2nd byte is the discover reply byte
                        if (response.ReceivedBytes > 13 && response.Buffer[1] == 3)
                        {
                            var deviceAddress = "http://" + deviceIp;

                            var info = await TryGetTunerHostInfo(deviceAddress, cancellationToken).ConfigureAwait(false);

                            if (info != null)
                            {
                                list.Add(info);
                            }
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                }
                catch (Exception ex)
                {
                    // Socket timeout indicates all messages have been received.
                    Logger.LogError(ex, "Error while sending discovery message");
                }
            }

            return list;
        }

        internal async Task<TunerHostInfo> TryGetTunerHostInfo(string url, CancellationToken cancellationToken)
        {
            var hostInfo = new TunerHostInfo
            {
                Type = Type,
                Url = url
            };

            var modelInfo = await GetModelInfo(hostInfo, false, cancellationToken).ConfigureAwait(false);

            hostInfo.DeviceId = modelInfo.DeviceID;
            hostInfo.FriendlyName = modelInfo.FriendlyName;
            hostInfo.TunerCount = modelInfo.TunerCount;

            return hostInfo;
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(11,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(22,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(623,46): error CS0165: Use of unassigned local variable 'hdhomerunChannel',D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(22,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Emby.Server.Implementations\LiveTv\TunerHosts\HdHomerun\HdHomerunHost.cs(11,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Emby.Dlna\Didl\DidlBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Emby.Dlna.ContentDirectory;
using Jellyfin.Data.Entities;
using MediaBrowser.Controller.Channels;
using MediaBrowser.Controller.Drawing;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Audio;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Playlists;
using MediaBrowser.Model.Dlna;
using MediaBrowser.Model.Drawing;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.Net;
using Microsoft.Extensions.Logging;
using Episode = MediaBrowser.Controller.Entities.TV.Episode;
using Genre = MediaBrowser.Controller.Entities.Genre;
using Movie = MediaBrowser.Controller.Entities.Movies.Movie;
using MusicAlbum = MediaBrowser.Controller.Entities.Audio.MusicAlbum;
using Season = MediaBrowser.Controller.Entities.TV.Season;
using Series = MediaBrowser.Controller.Entities.TV.Series;
using XmlAttribute = MediaBrowser.Model.Dlna.XmlAttribute;

namespace Emby.Dlna.Didl
{
    public class DidlBuilder
    {
        private const string NsDidl = "urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/";
        private const string NsDc = "http://purl.org/dc/elements/1.1/";
        private const string NsUpnp = "urn:schemas-upnp-org:metadata-1-0/upnp/";
        private const string NsDlna = "urn:schemas-dlna-org:metadata-1-0/";

        private readonly CultureInfo _usCulture = new CultureInfo("en-US");

        private readonly DeviceProfile _profile;
        private readonly IImageProcessor _imageProcessor;
        private readonly string _serverAddress;
        private readonly string _accessToken;
        private readonly User _user;
        private readonly IUserDataManager _userDataManager;
        private readonly ILocalizationManager _localization;
        private readonly IMediaSourceManager _mediaSourceManager;
        private readonly ILogger _logger;
        private readonly IMediaEncoder _mediaEncoder;
        private readonly ILibraryManager _libraryManager;

        public DidlBuilder(
            DeviceProfile profile,
            User user,
            IImageProcessor imageProcessor,
            string serverAddress,
            string accessToken,
            IUserDataManager userDataManager,
            ILocalizationManager localization,
            IMediaSourceManager mediaSourceManager,
            ILogger logger,
            IMediaEncoder mediaEncoder,
            ILibraryManager libraryManager)
        {
            _profile = profile;
            _user = user;
            _imageProcessor = imageProcessor;
            _serverAddress = serverAddress;
            _accessToken = accessToken;
            _userDataManager = userDataManager;
            _localization = localization;
            _mediaSourceManager = mediaSourceManager;
            _logger = logger;
            _mediaEncoder = mediaEncoder;
            _libraryManager = libraryManager;
        }

        public static string NormalizeDlnaMediaUrl(string url)
        {
            return url + "&dlnaheaders=true";
        }

        public string GetItemDidl(BaseItem item, User user, BaseItem context, string deviceId, Filter filter, StreamInfo streamInfo)
        {
            var settings = new XmlWriterSettings
            {
                Encoding = Encoding.UTF8,
                CloseOutput = false,
                OmitXmlDeclaration = true,
                ConformanceLevel = ConformanceLevel.Fragment
            };

            using (StringWriter builder = new StringWriterWithEncoding(Encoding.UTF8))
            {
                // If this using are changed to single lines, then write.Flush needs to be appended before the return.
                using (var writer = XmlWriter.Create(builder, settings))
                {
                    // writer.WriteStartDocument();

                    writer.WriteStartElement(string.Empty, "DIDL-Lite", NsDidl);

                    writer.WriteAttributeString("xmlns", "dc", null, NsDc);
                    writer.WriteAttributeString("xmlns", "dlna", null, NsDlna);
                    writer.WriteAttributeString("xmlns", "upnp", null, NsUpnp);
                    // didl.SetAttribute("xmlns:sec", NS_SEC);

                    WriteXmlRootAttributes(_profile, writer);

                    WriteItemElement(writer, item, user, context, null, deviceId, filter, streamInfo);

                    writer.WriteFullEndElement();
                    // writer.WriteEndDocument();
                }

                return builder.ToString();
            }
        }

        public static void WriteXmlRootAttributes(DeviceProfile profile, XmlWriter writer)
        {
            foreach (var att in profile.XmlRootAttributes)
            {
                var parts = att.Name.Split(':', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 2)
                {
                    writer.WriteAttributeString(parts[0], parts[1], null, att.Value);
                }
                else
                {
                    writer.WriteAttributeString(att.Name, att.Value);
                }
            }
        }

        public void WriteItemElement(
            XmlWriter writer,
            BaseItem item,
            User user,
            BaseItem context,
            StubType? contextStubType,
            string deviceId,
            Filter filter,
            StreamInfo streamInfo = null)
        {
            var clientId = GetClientId(item, null);

            writer.WriteStartElement(string.Empty, "item", NsDidl);

            writer.WriteAttributeString("restricted", "1");
            writer.WriteAttributeString("id", clientId);

            if (context != null)
            {
                writer.WriteAttributeString("parentID", GetClientId(context, contextStubType));
            }
            else
            {
                var parent = item.DisplayParentId;
                if (!parent.Equals(Guid.Empty))
                {
                    writer.WriteAttributeString("parentID", GetClientId(parent, null));
                }
            }

            AddGeneralProperties(item, null, context, writer, filter);

            AddSamsungBookmarkInfo(item, user, writer, streamInfo);

            // refID?
            // storeAttribute(itemNode, object, ClassProperties.REF_ID, false);

            if (item is IHasMediaSources)
            {
                if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase))
                {
                    AddAudioResource(writer, item, deviceId, filter, streamInfo);
                }
                else if (string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
                {
                    AddVideoResource(writer, item, deviceId, filter, streamInfo);
                }
            }

            AddCover(item, null, writer);
            writer.WriteFullEndElement();
        }

        private void AddVideoResource(XmlWriter writer, BaseItem video, string deviceId, Filter filter, StreamInfo streamInfo = null)
        {
            if (streamInfo == null)
            {
                var sources = _mediaSourceManager.GetStaticMediaSources(video, true, _user);

                streamInfo = new StreamBuilder(_mediaEncoder, _logger).BuildVideoItem(new VideoOptions
                {
                    ItemId = video.Id,
                    MediaSources = sources.ToArray(),
                    Profile = _profile,
                    DeviceId = deviceId,
                    MaxBitrate = _profile.MaxStreamingBitrate
                });
            }

            var targetWidth = streamInfo.TargetWidth;
            var targetHeight = streamInfo.TargetHeight;

            var contentFeatureList = new ContentFeatureBuilder(_profile).BuildVideoHeader(
                streamInfo.Container,
                streamInfo.TargetVideoCodec.FirstOrDefault(),
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetWidth,
                targetHeight,
                streamInfo.TargetVideoBitDepth,
                streamInfo.TargetVideoBitrate,
                streamInfo.TargetTimestamp,
                streamInfo.IsDirectStream,
                streamInfo.RunTimeTicks ?? 0,
                streamInfo.TargetVideoProfile,
                streamInfo.TargetVideoLevel,
                streamInfo.TargetFramerate ?? 0,
                streamInfo.TargetPacketLength,
                streamInfo.TranscodeSeekInfo,
                streamInfo.IsTargetAnamorphic,
                streamInfo.IsTargetInterlaced,
                streamInfo.TargetRefFrames,
                streamInfo.TargetVideoStreamCount,
                streamInfo.TargetAudioStreamCount,
                streamInfo.TargetVideoCodecTag,
                streamInfo.IsTargetAVC);

            foreach (var contentFeature in contentFeatureList)
            {
                AddVideoResource(writer, filter, contentFeature, streamInfo);
            }

            var subtitleProfiles = streamInfo.GetSubtitleProfiles(_mediaEncoder, false, _serverAddress, _accessToken);

            foreach (var subtitle in subtitleProfiles)
            {
                if (subtitle.DeliveryMethod != SubtitleDeliveryMethod.External)
                {
                    continue;
                }

                var subtitleAdded = AddSubtitleElement(writer, subtitle);

                if (subtitleAdded && _profile.EnableSingleSubtitleLimit)
                {
                    break;
                }
            }
        }

        private bool AddSubtitleElement(XmlWriter writer, SubtitleStreamInfo info)
        {
            var subtitleProfile = _profile.SubtitleProfiles
                .FirstOrDefault(i => string.Equals(info.Format, i.Format, StringComparison.OrdinalIgnoreCase)
                                    && i.Method == SubtitleDeliveryMethod.External);

            if (subtitleProfile == null)
            {
                return false;
            }

            var subtitleMode = subtitleProfile.DidlMode;

            if (string.Equals(subtitleMode, "CaptionInfoEx", StringComparison.OrdinalIgnoreCase))
            {
                // <sec:CaptionInfoEx sec:type="srt">http://192.168.1.3:9999/video.srt</sec:CaptionInfoEx>
                // <sec:CaptionInfo sec:type="srt">http://192.168.1.3:9999/video.srt</sec:CaptionInfo>

                writer.WriteStartElement("sec", "CaptionInfoEx", null);
                writer.WriteAttributeString("sec", "type", null, info.Format.ToLowerInvariant());

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }
            else if (string.Equals(subtitleMode, "smi", StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteStartElement(string.Empty, "res", NsDidl);

                writer.WriteAttributeString("protocolInfo", "http-get:*:smi/caption:*");

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }
            else
            {
                writer.WriteStartElement(string.Empty, "res", NsDidl);
                var protocolInfo = string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:text/{0}:*",
                    info.Format.ToLowerInvariant());
                writer.WriteAttributeString("protocolInfo", protocolInfo);

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }

            return true;
        }

        private void AddVideoResource(XmlWriter writer, Filter filter, string contentFeatures, StreamInfo streamInfo)
        {
            writer.WriteStartElement(string.Empty, "res", NsDidl);

            var url = NormalizeDlnaMediaUrl(streamInfo.ToUrl(_serverAddress, _accessToken));

            var mediaSource = streamInfo.MediaSource;

            if (mediaSource.RunTimeTicks.HasValue)
            {
                writer.WriteAttributeString("duration", TimeSpan.FromTicks(mediaSource.RunTimeTicks.Value).ToString("c", _usCulture));
            }

            if (filter.Contains("res@size"))
            {
                if (streamInfo.IsDirectStream || streamInfo.EstimateContentLength)
                {
                    var size = streamInfo.TargetSize;

                    if (size.HasValue)
                    {
                        writer.WriteAttributeString("size", size.Value.ToString(_usCulture));
                    }
                }
            }

            var totalBitrate = streamInfo.TargetTotalBitrate;
            var targetSampleRate = streamInfo.TargetAudioSampleRate;
            var targetChannels = streamInfo.TargetAudioChannels;

            var targetWidth = streamInfo.TargetWidth;
            var targetHeight = streamInfo.TargetHeight;

            if (targetChannels.HasValue)
            {
                writer.WriteAttributeString("nrAudioChannels", targetChannels.Value.ToString(_usCulture));
            }

            if (filter.Contains("res@resolution"))
            {
                if (targetWidth.HasValue && targetHeight.HasValue)
                {
                    writer.WriteAttributeString(
                        "resolution",
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "{0}x{1}",
                            targetWidth.Value,
                            targetHeight.Value));
                }
            }

            if (targetSampleRate.HasValue)
            {
                writer.WriteAttributeString("sampleFrequency", targetSampleRate.Value.ToString(_usCulture));
            }

            if (totalBitrate.HasValue)
            {
                writer.WriteAttributeString("bitrate", totalBitrate.Value.ToString(_usCulture));
            }

            var mediaProfile = _profile.GetVideoMediaProfile(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                streamInfo.TargetVideoCodec.FirstOrDefault(),
                streamInfo.TargetAudioBitrate,
                targetWidth,
                targetHeight,
                streamInfo.TargetVideoBitDepth,
                streamInfo.TargetVideoProfile,
                streamInfo.TargetVideoLevel,
                streamInfo.TargetFramerate ?? 0,
                streamInfo.TargetPacketLength,
                streamInfo.TargetTimestamp,
                streamInfo.IsTargetAnamorphic,
                streamInfo.IsTargetInterlaced,
                streamInfo.TargetRefFrames,
                streamInfo.TargetVideoStreamCount,
                streamInfo.TargetAudioStreamCount,
                streamInfo.TargetVideoCodecTag,
                streamInfo.IsTargetAVC);

            var filename = url.Substring(0, url.IndexOf('?', StringComparison.Ordinal));

            var mimeType = mediaProfile == null || string.IsNullOrEmpty(mediaProfile.MimeType)
               ? MimeTypes.GetMimeType(filename)
               : mediaProfile.MimeType;

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    mimeType,
                    contentFeatures));

            writer.WriteString(url);

            writer.WriteFullEndElement();
        }

        private string GetDisplayName(BaseItem item, StubType? itemStubType, BaseItem context)
        {
            if (itemStubType.HasValue)
            {
                switch (itemStubType.Value)
                {
                    case StubType.Latest: return _localization.GetLocalizedString("Latest");
                    case StubType.Playlists: return _localization.GetLocalizedString("Playlists");
                    case StubType.AlbumArtists: return _localization.GetLocalizedString("HeaderAlbumArtists");
                    case StubType.Albums: return _localization.GetLocalizedString("Albums");
                    case StubType.Artists: return _localization.GetLocalizedString("Artists");
                    case StubType.Songs: return _localization.GetLocalizedString("Songs");
                    case StubType.Genres: return _localization.GetLocalizedString("Genres");
                    case StubType.FavoriteAlbums: return _localization.GetLocalizedString("HeaderFavoriteAlbums");
                    case StubType.FavoriteArtists: return _localization.GetLocalizedString("HeaderFavoriteArtists");
                    case StubType.FavoriteSongs: return _localization.GetLocalizedString("HeaderFavoriteSongs");
                    case StubType.ContinueWatching: return _localization.GetLocalizedString("HeaderContinueWatching");
                    case StubType.Movies: return _localization.GetLocalizedString("Movies");
                    case StubType.Collections: return _localization.GetLocalizedString("Collections");
                    case StubType.Favorites: return _localization.GetLocalizedString("Favorites");
                    case StubType.NextUp: return _localization.GetLocalizedString("HeaderNextUp");
                    case StubType.FavoriteSeries: return _localization.GetLocalizedString("HeaderFavoriteShows");
                    case StubType.FavoriteEpisodes: return _localization.GetLocalizedString("HeaderFavoriteEpisodes");
                    case StubType.Series: return _localization.GetLocalizedString("Shows");
                }
            }

            return item is Episode episode
                ? GetEpisodeDisplayName(episode, context)
                : item.Name;
        }

        /// <summary>
        /// Gets episode display name appropriate for the given context.
        /// </summary>
        /// <remarks>
        /// If context is a season, this will return a string containing just episode number and name.
        /// Otherwise the result will include series nams and season number.
        /// </remarks>
        /// <param name="episode">The episode.</param>
        /// <param name="context">Current context.</param>
        /// <returns>Formatted name of the episode.</returns>
        private string GetEpisodeDisplayName(Episode episode, BaseItem context)
        {
            string[] components;

            if (context is Season season)
            {
                // This is a special embedded within a season
                if (episode.ParentIndexNumber.HasValue && episode.ParentIndexNumber.Value == 0
                    && season.IndexNumber.HasValue && season.IndexNumber.Value != 0)
                {
                    return string.Format(
                        CultureInfo.InvariantCulture,
                        _localization.GetLocalizedString("ValueSpecialEpisodeName"),
                        episode.Name);
                }

                // inside a season use simple format (ex. '12 - Episode Name')
                var epNumberName = GetEpisodeIndexFullName(episode);
                components = new[] { epNumberName, episode.Name };
            }
            else
            {
                // outside a season include series and season details (ex. 'TV Show - S05E11 - Episode Name')
                var epNumberName = GetEpisodeNumberDisplayName(episode);
                components = new[] { episode.SeriesName, epNumberName, episode.Name };
            }

            return string.Join(" - ", components.Where(NotNullOrWhiteSpace));
        }

        /// <summary>
        /// Gets complete episode number.
        /// </summary>
        /// <param name="episode">The episode.</param>
        /// <returns>For single episodes returns just the number. For double episodes - current and ending numbers.</returns>
        private string GetEpisodeIndexFullName(Episode episode)
        {
            var name = string.Empty;
            if (episode.IndexNumber.HasValue)
            {
                name += episode.IndexNumber.Value.ToString("00", CultureInfo.InvariantCulture);

                if (episode.IndexNumberEnd.HasValue)
                {
                    name += "-" + episode.IndexNumberEnd.Value.ToString("00", CultureInfo.InvariantCulture);
                }
            }

            return name;
        }

        /// <summary>
        /// Gets episode number formatted as 'S##E##'.
        /// </summary>
        /// <param name="episode">The episode.</param>
        /// <returns>Formatted episode number.</returns>
        private string GetEpisodeNumberDisplayName(Episode episode)
        {
            var name = string.Empty;
            var seasonNumber = episode.Season?.IndexNumber;

            if (seasonNumber.HasValue)
            {
                name = "S" + seasonNumber.Value.ToString("00", CultureInfo.InvariantCulture);
            }

            var indexName = GetEpisodeIndexFullName(episode);

            if (!string.IsNullOrWhiteSpace(indexName))
            {
                name += "E" + indexName;
            }

            return name;
        }

        private bool NotNullOrWhiteSpace(string s) => !string.IsNullOrWhiteSpace(s);

        private void AddAudioResource(XmlWriter writer, BaseItem audio, string deviceId, Filter filter, StreamInfo streamInfo = null)
        {
            writer.WriteStartElement(string.Empty, "res", NsDidl);

            if (streamInfo == null)
            {
                var sources = _mediaSourceManager.GetStaticMediaSources(audio, true, _user);

                streamInfo = new StreamBuilder(_mediaEncoder, _logger).BuildAudioItem(new AudioOptions
                {
                    ItemId = audio.Id,
                    MediaSources = sources.ToArray(),
                    Profile = _profile,
                    DeviceId = deviceId
                });
            }

            var url = NormalizeDlnaMediaUrl(streamInfo.ToUrl(_serverAddress, _accessToken));

            var mediaSource = streamInfo.MediaSource;

            if (mediaSource.RunTimeTicks.HasValue)
            {
                writer.WriteAttributeString("duration", TimeSpan.FromTicks(mediaSource.RunTimeTicks.Value).ToString("c", _usCulture));
            }

            if (filter.Contains("res@size"))
            {
                if (streamInfo.IsDirectStream || streamInfo.EstimateContentLength)
                {
                    var size = streamInfo.TargetSize;

                    if (size.HasValue)
                    {
                        writer.WriteAttributeString("size", size.Value.ToString(_usCulture));
                    }
                }
            }

            var targetAudioBitrate = streamInfo.TargetAudioBitrate;
            var targetSampleRate = streamInfo.TargetAudioSampleRate;
            var targetChannels = streamInfo.TargetAudioChannels;
            var targetAudioBitDepth = streamInfo.TargetAudioBitDepth;

            if (targetChannels.HasValue)
            {
                writer.WriteAttributeString("nrAudioChannels", targetChannels.Value.ToString(_usCulture));
            }

            if (targetSampleRate.HasValue)
            {
                writer.WriteAttributeString("sampleFrequency", targetSampleRate.Value.ToString(_usCulture));
            }

            if (targetAudioBitrate.HasValue)
            {
                writer.WriteAttributeString("bitrate", targetAudioBitrate.Value.ToString(_usCulture));
            }

            var mediaProfile = _profile.GetAudioMediaProfile(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetChannels,
                targetAudioBitrate,
                targetSampleRate,
                targetAudioBitDepth);

            var filename = url.Substring(0, url.IndexOf('?', StringComparison.Ordinal));

            var mimeType = mediaProfile == null || string.IsNullOrEmpty(mediaProfile.MimeType)
                ? MimeTypes.GetMimeType(filename)
                : mediaProfile.MimeType;

            var contentFeatures = new ContentFeatureBuilder(_profile).BuildAudioHeader(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetAudioBitrate,
                targetSampleRate,
                targetChannels,
                targetAudioBitDepth,
                streamInfo.IsDirectStream,
                streamInfo.RunTimeTicks ?? 0,
                streamInfo.TranscodeSeekInfo);

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    mimeType,
                    contentFeatures));

            writer.WriteString(url);

            writer.WriteFullEndElement();
        }

        public static bool IsIdRoot(string id)
            => string.IsNullOrWhiteSpace(id)
                || string.Equals(id, "0", StringComparison.OrdinalIgnoreCase)
                // Samsung sometimes uses 1 as root
                || string.Equals(id, "1", StringComparison.OrdinalIgnoreCase);

        public void WriteFolderElement(XmlWriter writer, BaseItem folder, StubType? stubType, BaseItem context, int childCount, Filter filter, string requestedId = null)
        {
            writer.WriteStartElement(string.Empty, "container", NsDidl);

            writer.WriteAttributeString("restricted", "1");
            writer.WriteAttributeString("searchable", "1");
            writer.WriteAttributeString("childCount", childCount.ToString(_usCulture));

            var clientId = GetClientId(folder, stubType);

            if (string.Equals(requestedId, "0", StringComparison.Ordinal))
            {
                writer.WriteAttributeString("id", "0");
                writer.WriteAttributeString("parentID", "-1");
            }
            else
            {
                writer.WriteAttributeString("id", clientId);

                if (context != null)
                {
                    writer.WriteAttributeString("parentID", GetClientId(context, null));
                }
                else
                {
                    var parent = folder.DisplayParentId;
                    if (parent.Equals(Guid.Empty))
                    {
                        writer.WriteAttributeString("parentID", "0");
                    }
                    else
                    {
                        writer.WriteAttributeString("parentID", GetClientId(parent, null));
                    }
                }
            }

            AddGeneralProperties(folder, stubType, context, writer, filter);

            AddCover(folder, stubType, writer);

            writer.WriteFullEndElement();
        }

        private void AddSamsungBookmarkInfo(BaseItem item, User user, XmlWriter writer, StreamInfo streamInfo)
        {
            if (!item.SupportsPositionTicksResume || item is Folder)
            {
                return;
            }

            XmlAttribute secAttribute = null;
            foreach (var attribute in _profile.XmlRootAttributes)
            {
                if (string.Equals(attribute.Name, "xmlns:sec", StringComparison.OrdinalIgnoreCase))
                {
                    secAttribute = attribute;
                    break;
                }
            }

            // Not a samsung device
            if (secAttribute == null)
            {
                return;
            }

            var userdata = _userDataManager.GetUserData(user, item);
            var playbackPositionTicks = (streamInfo != null && streamInfo.StartPositionTicks > 0) ? streamInfo.StartPositionTicks : userdata.PlaybackPositionTicks;

            if (playbackPositionTicks > 0)
            {
                var elementValue = string.Format(
                    CultureInfo.InvariantCulture,
                    "BM={0}",
                    Convert.ToInt32(TimeSpan.FromTicks(playbackPositionTicks).TotalSeconds));
                AddValue(writer, "sec", "dcmInfo", elementValue, secAttribute.Value);
            }
        }

        /// <summary>
        /// Adds fields used by both items and folders.
        /// </summary>
        private void AddCommonFields(BaseItem item, StubType? itemStubType, BaseItem context, XmlWriter writer, Filter filter)
        {
            // Don't filter on dc:title because not all devices will include it in the filter
            // MediaMonkey for example won't display content without a title
            // if (filter.Contains("dc:title"))
            {
                AddValue(writer, "dc", "title", GetDisplayName(item, itemStubType, context), NsDc);
            }

            WriteObjectClass(writer, item, itemStubType);

            if (filter.Contains("dc:date"))
            {
                if (item.PremiereDate.HasValue)
                {
                    AddValue(writer, "dc", "date", item.PremiereDate.Value.ToString("o", CultureInfo.InvariantCulture), NsDc);
                }
            }

            if (filter.Contains("upnp:genre"))
            {
                foreach (var genre in item.Genres)
                {
                    AddValue(writer, "upnp", "genre", genre, NsUpnp);
                }
            }

            foreach (var studio in item.Studios)
            {
                AddValue(writer, "upnp", "publisher", studio, NsUpnp);
            }

            if (!(item is Folder))
            {
                if (filter.Contains("dc:description"))
                {
                    var desc = item.Overview;

                    if (!string.IsNullOrWhiteSpace(desc))
                    {
                        AddValue(writer, "dc", "description", desc, NsDc);
                    }
                }

                // if (filter.Contains("upnp:longDescription"))
                // {
                //    if (!string.IsNullOrWhiteSpace(item.Overview))
                //    {
                //        AddValue(writer, "upnp", "longDescription", item.Overview, NsUpnp);
                //    }
                // }
            }

            if (!string.IsNullOrEmpty(item.OfficialRating))
            {
                if (filter.Contains("dc:rating"))
                {
                    AddValue(writer, "dc", "rating", item.OfficialRating, NsDc);
                }

                if (filter.Contains("upnp:rating"))
                {
                    AddValue(writer, "upnp", "rating", item.OfficialRating, NsUpnp);
                }
            }

            AddPeople(item, writer);
        }

        private void WriteObjectClass(XmlWriter writer, BaseItem item, StubType? stubType)
        {
            // More types here
            // http://oss.linn.co.uk/repos/Public/LibUpnpCil/DidlLite/UpnpAv/Test/TestDidlLite.cs

            writer.WriteStartElement("upnp", "class", NsUpnp);

            if (item.IsDisplayedAsFolder || stubType.HasValue)
            {
                string classType = null;

                if (!_profile.RequiresPlainFolders)
                {
                    if (item is MusicAlbum)
                    {
                        classType = "object.container.album.musicAlbum";
                    }
                    else if (item is MusicArtist)
                    {
                        classType = "object.container.person.musicArtist";
                    }
                    else if (item is Series || item is Season || item is BoxSet || item is Video)
                    {
                        classType = "object.container.album.videoAlbum";
                    }
                    else if (item is Playlist)
                    {
                        classType = "object.container.playlistContainer";
                    }
                    else if (item is PhotoAlbum)
                    {
                        classType = "object.container.album.photoAlbum";
                    }
                }

                writer.WriteString(classType ?? "object.container.storageFolder");
            }
            else if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteString("object.item.audioItem.musicTrack");
            }
            else if (string.Equals(item.MediaType, MediaType.Photo, StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteString("object.item.imageItem.photo");
            }
            else if (string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
            {
                if (!_profile.RequiresPlainVideoItems && item is Movie)
                {
                    writer.WriteString("object.item.videoItem.movie");
                }
                else if (!_profile.RequiresPlainVideoItems && item is MusicVideo)
                {
                    writer.WriteString("object.item.videoItem.musicVideoClip");
                }
                else
                {
                    writer.WriteString("object.item.videoItem");
                }
            }
            else if (item is MusicGenre)
            {
                writer.WriteString(_profile.RequiresPlainFolders ? "object.container.storageFolder" : "object.container.genre.musicGenre");
            }
            else if (item is Genre)
            {
                writer.WriteString(_profile.RequiresPlainFolders ? "object.container.storageFolder" : "object.container.genre");
            }
            else
            {
                writer.WriteString("object.item");
            }

            writer.WriteFullEndElement();
        }

        private void AddPeople(BaseItem item, XmlWriter writer)
        {
            if (!item.SupportsPeople)
            {
                return;
            }

            var types = new[]
            {
                PersonType.Director,
                PersonType.Writer,
                PersonType.Producer,
                PersonType.Composer,
                "creator"
            };

            // Seeing some LG models locking up due content with large lists of people
            // The actual issue might just be due to processing a more metadata than it can handle
            var people = _libraryManager.GetPeople(
                new InternalPeopleQuery
                {
                    ItemId = item.Id,
                    Limit = 6
                });

            foreach (var actor in people)
            {
                var type = types.FirstOrDefault(i => string.Equals(i, actor.Type, StringComparison.OrdinalIgnoreCase) || string.Equals(i, actor.Role, StringComparison.OrdinalIgnoreCase))
                    ?? PersonType.Actor;

                AddValue(writer, "upnp", type.ToLowerInvariant(), actor.Name, NsUpnp);
            }
        }

        private void AddGeneralProperties(BaseItem item, StubType? itemStubType, BaseItem context, XmlWriter writer, Filter filter)
        {
            AddCommonFields(item, itemStubType, context, writer, filter);

            var hasAlbumArtists = item as IHasAlbumArtist;

            if (item is IHasArtist hasArtists)
            {
                foreach (var artist in hasArtists.Artists)
                {
                    AddValue(writer, "upnp", "artist", artist, NsUpnp);
                    AddValue(writer, "dc", "creator", artist, NsDc);

                    // If it doesn't support album artists (musicvideo), then tag as both
                    if (hasAlbumArtists == null)
                    {
                        AddAlbumArtist(writer, artist);
                    }
                }
            }

            if (hasAlbumArtists != null)
            {
                foreach (var albumArtist in hasAlbumArtists.AlbumArtists)
                {
                    AddAlbumArtist(writer, albumArtist);
                }
            }

            if (!string.IsNullOrWhiteSpace(item.Album))
            {
                AddValue(writer, "upnp", "album", item.Album, NsUpnp);
            }

            if (item.IndexNumber.HasValue)
            {
                AddValue(writer, "upnp", "originalTrackNumber", item.IndexNumber.Value.ToString(_usCulture), NsUpnp);

                if (item is Episode)
                {
                    AddValue(writer, "upnp", "episodeNumber", item.IndexNumber.Value.ToString(_usCulture), NsUpnp);
                }
            }
        }

        private void AddAlbumArtist(XmlWriter writer, string name)
        {
            try
            {
                writer.WriteStartElement("upnp", "artist", NsUpnp);
                writer.WriteAttributeString("role", "AlbumArtist");

                writer.WriteString(name);

                writer.WriteFullEndElement();
            }
            catch (XmlException ex)
            {
                _logger.LogError(ex, "Error adding xml value: {Value}", name);
            }
        }

        private void AddValue(XmlWriter writer, string prefix, string name, string value, string namespaceUri)
        {
            try
            {
                writer.WriteElementString(prefix, name, namespaceUri, value);
            }
            catch (XmlException ex)
            {
                _logger.LogError(ex, "Error adding xml value: {Value}", value);
            }
        }

        private void AddCover(BaseItem item, StubType? stubType, XmlWriter writer)
        {
            ImageDownloadInfo imageInfo = GetImageInfo(item);

            if (imageInfo == null)
            {
                return;
            }

            var albumartUrlInfo = GetImageUrl(imageInfo, _profile.MaxAlbumArtWidth, _profile.MaxAlbumArtHeight, "jpg");

            writer.WriteStartElement("upnp", "albumArtURI", NsUpnp);
            writer.WriteAttributeString("dlna", "profileID", NsDlna, _profile.AlbumArtPn);
            writer.WriteString(albumartUrlInfo.url);
            writer.WriteFullEndElement();

            // TOOD: Remove these default values
            var iconUrlInfo = GetImageUrl(imageInfo, _profile.MaxIconWidth ?? 48, _profile.MaxIconHeight ?? 48, "jpg");
            writer.WriteElementString("upnp", "icon", NsUpnp, iconUrlInfo.url);

            if (!_profile.EnableAlbumArtInDidl)
            {
                if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase)
                    || string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
                {
                    if (!stubType.HasValue)
                    {
                        return;
                    }
                }
            }

            if (!_profile.EnableSingleAlbumArtLimit || string.Equals(item.MediaType, MediaType.Photo, StringComparison.OrdinalIgnoreCase))
            {
                AddImageResElement(item, writer, 4096, 4096, "jpg", "JPEG_LRG");
                AddImageResElement(item, writer, 1024, 768, "jpg", "JPEG_MED");
                AddImageResElement(item, writer, 640, 480, "jpg", "JPEG_SM");
                AddImageResElement(item, writer, 4096, 4096, "png", "PNG_LRG");
                AddImageResElement(item, writer, 160, 160, "png", "PNG_TN");
            }

            AddImageResElement(item, writer, 160, 160, "jpg", "JPEG_TN");
        }

        private void AddImageResElement(
            BaseItem item,
            XmlWriter writer,
            int maxWidth,
            int maxHeight,
            string format,
            string org_Pn)
        {
            var imageInfo = GetImageInfo(item);

            if (imageInfo == null)
            {
                return;
            }

            var albumartUrlInfo = GetImageUrl(imageInfo, maxWidth, maxHeight, format);

            writer.WriteStartElement(string.Empty, "res", NsDidl);

            // Images must have a reported size or many clients (Bubble upnp), will only use the first thumbnail
            // rather than using a larger one when available
            var width = albumartUrlInfo.width ?? maxWidth;
            var height = albumartUrlInfo.height ?? maxHeight;

            var contentFeatures = new ContentFeatureBuilder(_profile)
                .BuildImageHeader(format, width, height, imageInfo.IsDirectStream, org_Pn);

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    MimeTypes.GetMimeType("file." + format),
                    contentFeatures));

            writer.WriteAttributeString(
                "resolution",
                string.Format(CultureInfo.InvariantCulture, "{0}x{1}", width, height));

            writer.WriteString(albumartUrlInfo.url);

            writer.WriteFullEndElement();
        }

        private ImageDownloadInfo GetImageInfo(BaseItem item)
        {
            if (item.HasImage(ImageType.Primary))
            {
                return GetImageInfo(item, ImageType.Primary);
            }

            if (item.HasImage(ImageType.Thumb))
            {
                return GetImageInfo(item, ImageType.Thumb);
            }

            if (item.HasImage(ImageType.Backdrop))
            {
                if (item is Channel)
                {
                    return GetImageInfo(item, ImageType.Backdrop);
                }
            }

            // For audio tracks without art use album art if available.
            if (item is Audio audioItem)
            {
                var album = audioItem.AlbumEntity;
                return album != null && album.HasImage(ImageType.Primary)
                    ? GetImageInfo(album, ImageType.Primary)
                    : null;
            }

            // Don't look beyond album/playlist level. Metadata service may assign an image from a different album/show to the parent folder.
            if (item is MusicAlbum || item is Playlist)
            {
                return null;
            }

            // For other item types check parents, but be aware that image retrieved from a parent may be not suitable for this media item.
            var parentWithImage = GetFirstParentWithImageBelowUserRoot(item);
            if (parentWithImage != null)
            {
                return GetImageInfo(parentWithImage, ImageType.Primary);
            }

            return null;
        }

        private BaseItem GetFirstParentWithImageBelowUserRoot(BaseItem item)
        {
            if (item == null)
            {
                return null;
            }

            if (item.HasImage(ImageType.Primary))
            {
                return item;
            }

            var parent = item.GetParent();
            if (parent is UserRootFolder)
            {
                return null;
            }

            // terminate in case we went past user root folder (unlikely?)
            if (parent is Folder folder && folder.IsRoot)
            {
                return null;
            }

            return GetFirstParentWithImageBelowUserRoot(parent);
        }

        private ImageDownloadInfo GetImageInfo(BaseItem item, ImageType type)
        {
            var imageInfo = item.GetImageInfo(type, 0);
            string tag = null;

            try
            {
                tag = _imageProcessor.GetImageCacheTag(item, type);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting image cache tag");
            }

            int? width = imageInfo.Width;
            int? height = imageInfo.Height;

            if (width == 0 || height == 0)
            {
                width = null;
                height = null;
            }
            else if (width == -1 || height == -1)
            {
                width = null;
                height = null;
            }

            var inputFormat = (Path.GetExtension(imageInfo.Path) ?? string.Empty)
                .TrimStart('.')
                .Replace("jpeg", "jpg", StringComparison.OrdinalIgnoreCase);

            return new ImageDownloadInfo
            {
                ItemId = item.Id,
                Type = type,
                ImageTag = tag,
                Width = width,
                Height = height,
                Format = inputFormat,
                ItemImageInfo = imageInfo
            };
        }

        public static string GetClientId(BaseItem item, StubType? stubType)
        {
            return GetClientId(item.Id, stubType);
        }

        public static string GetClientId(Guid idValue, StubType? stubType)
        {
            var id = idValue.ToString("N", CultureInfo.InvariantCulture);

            if (stubType.HasValue)
            {
                id = stubType.Value.ToString().ToLowerInvariant() + "_" + id;
            }

            return id;
        }

        private (string url, int? width, int? height) GetImageUrl(ImageDownloadInfo info, int maxWidth, int maxHeight, string format)
        {
            var url = string.Format(
                CultureInfo.InvariantCulture,
                "{0}/Items/{1}/Images/{2}/0/{3}/{4}/{5}/{6}/0/0",
                _serverAddress,
                info.ItemId.ToString("N", CultureInfo.InvariantCulture),
                info.Type,
                info.ImageTag,
                format,
                maxWidth.ToString(CultureInfo.InvariantCulture),
                maxHeight.ToString(CultureInfo.InvariantCulture));

            var width = info.Width;
            var height = info.Height;

            info.IsDirectStream = false;

            if (width.HasValue && height.HasValue)
            {
                var newSize = DrawingUtils.Resize(
                        new ImageDimensions(width.Value, height.Value), 0, 0, maxWidth, maxHeight);

                width = newSize.Width;
                height = newSize.Height;

                var normalizedFormat = format
                    .Replace("jpeg", "jpg", StringComparison.OrdinalIgnoreCase);

                if (string.Equals(info.Format, normalizedFormat, StringComparison.OrdinalIgnoreCase))
                {
                    info.IsDirectStream = maxWidth >= width.Value && maxHeight >= height.Value;
                }
            }

            // just lie
            info.IsDirectStream = true;

            return (url, width, height);
        }

        private class ImageDownloadInfo
        {
            internal Guid ItemId { get; set; }

            internal string ImageTag { get; set; }

            internal ImageType Type { get; set; }

            internal int? Width { get; set; }

            internal int? Height { get; set; }

            internal bool IsDirectStream { get; set; }

            internal string Format { get; set; }

            internal ItemImageInfo ItemImageInfo { get; set; }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Emby.Dlna.ContentDirectory;
using Jellyfin.Data.Entities;
using MediaBrowser.Controller.Channels;
using MediaBrowser.Controller.Drawing;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Entities.Audio;
using MediaBrowser.Controller.Entities.Movies;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Playlists;
using MediaBrowser.Model.Dlna;
using MediaBrowser.Model.Drawing;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.Globalization;
using MediaBrowser.Model.Net;
using Microsoft.Extensions.Logging;
using Episode = MediaBrowser.Controller.Entities.TV.Episode;
using Genre = MediaBrowser.Controller.Entities.Genre;
using Movie = MediaBrowser.Controller.Entities.Movies.Movie;
using MusicAlbum = MediaBrowser.Controller.Entities.Audio.MusicAlbum;
using Season = MediaBrowser.Controller.Entities.TV.Season;
using Series = MediaBrowser.Controller.Entities.TV.Series;
using XmlAttribute = MediaBrowser.Model.Dlna.XmlAttribute;

namespace Emby.Dlna.Didl
{
    public class DidlBuilder
    {
        private const string NsDidl = "urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/";
        private const string NsDc = "http://purl.org/dc/elements/1.1/";
        private const string NsUpnp = "urn:schemas-upnp-org:metadata-1-0/upnp/";
        private const string NsDlna = "urn:schemas-dlna-org:metadata-1-0/";

        private readonly CultureInfo _usCulture = new CultureInfo("en-US");

        private readonly DeviceProfile _profile;
        private readonly IImageProcessor _imageProcessor;
        private readonly string _serverAddress;
        private readonly string _accessToken;
        private readonly User _user;
        private readonly IUserDataManager _userDataManager;
        private readonly ILocalizationManager _localization;
        private readonly IMediaSourceManager _mediaSourceManager;
        private readonly ILogger _logger;
        private readonly IMediaEncoder _mediaEncoder;
        private readonly ILibraryManager _libraryManager;

        public DidlBuilder(
            DeviceProfile profile,
            User user,
            IImageProcessor imageProcessor,
            string serverAddress,
            string accessToken,
            IUserDataManager userDataManager,
            ILocalizationManager localization,
            IMediaSourceManager mediaSourceManager,
            ILogger logger,
            IMediaEncoder mediaEncoder,
            ILibraryManager libraryManager)
        {
            _profile = profile;
            _user = user;
            _imageProcessor = imageProcessor;
            _serverAddress = serverAddress;
            _accessToken = accessToken;
            _userDataManager = userDataManager;
            _localization = localization;
            _mediaSourceManager = mediaSourceManager;
            _logger = logger;
            _mediaEncoder = mediaEncoder;
            _libraryManager = libraryManager;
        }

        public static string NormalizeDlnaMediaUrl(string url)
        {
            return url + "&dlnaheaders=true";
        }

        public string GetItemDidl(BaseItem item, User user, BaseItem context, string deviceId, Filter filter, StreamInfo streamInfo)
        {
            var settings = new XmlWriterSettings
            {
                Encoding = Encoding.UTF8,
                CloseOutput = false,
                OmitXmlDeclaration = true,
                ConformanceLevel = ConformanceLevel.Fragment
            };

            using (StringWriter builder = new StringWriterWithEncoding(Encoding.UTF8))
            {
                // If this using are changed to single lines, then write.Flush needs to be appended before the return.
                using (var writer = XmlWriter.Create(builder, settings))
                {
                    // writer.WriteStartDocument();

                    writer.WriteStartElement(string.Empty, "DIDL-Lite", NsDidl);

                    writer.WriteAttributeString("xmlns", "dc", null, NsDc);
                    writer.WriteAttributeString("xmlns", "dlna", null, NsDlna);
                    writer.WriteAttributeString("xmlns", "upnp", null, NsUpnp);
                    // didl.SetAttribute("xmlns:sec", NS_SEC);

                    WriteXmlRootAttributes(_profile, writer);

                    WriteItemElement(writer, item, user, context, null, deviceId, filter, streamInfo);

                    writer.WriteFullEndElement();
                    // writer.WriteEndDocument();
                }

                return builder.ToString();
            }
        }

        public static void WriteXmlRootAttributes(DeviceProfile profile, XmlWriter writer)
        {
            foreach (var att in profile.XmlRootAttributes)
            {
                var parts = att.Name.Split(':', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 2)
                {
                    writer.WriteAttributeString(parts[0], parts[1], null, att.Value);
                }
                else
                {
                    writer.WriteAttributeString(att.Name, att.Value);
                }
            }
        }

        public void WriteItemElement(
            XmlWriter writer,
            BaseItem item,
            User user,
            BaseItem context,
            StubType? contextStubType,
            string deviceId,
            Filter filter,
            StreamInfo streamInfo = null)
        {
            var clientId = GetClientId(item, null);

            writer.WriteStartElement(string.Empty, "item", NsDidl);

            writer.WriteAttributeString("restricted", "1");
            writer.WriteAttributeString("id", clientId);

            if (context != null)
            {
                writer.WriteAttributeString("parentID", GetClientId(context, contextStubType));
            }
            else
            {
                var parent = item.DisplayParentId;
                if (!parent.Equals(Guid.Empty))
                {
                    writer.WriteAttributeString("parentID", GetClientId(parent, null));
                }
            }

            AddGeneralProperties(item, null, context, writer, filter);

            AddSamsungBookmarkInfo(item, user, writer, streamInfo);

            // refID?
            // storeAttribute(itemNode, object, ClassProperties.REF_ID, false);

            if (item is IHasMediaSources)
            {
                if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase))
                {
                    AddAudioResource(writer, item, deviceId, filter, streamInfo);
                }
                else if (string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
                {
                    AddVideoResource(writer, item, deviceId, filter, streamInfo);
                }
            }

            AddCover(item, null, writer);
            writer.WriteFullEndElement();
        }

        private void AddVideoResource(XmlWriter writer, BaseItem video, string deviceId, Filter filter, StreamInfo streamInfo = null)
        {
            if (streamInfo == null)
            {
                var sources = _mediaSourceManager.GetStaticMediaSources(video, true, _user);

                streamInfo = new StreamBuilder(_mediaEncoder, _logger).BuildVideoItem(new VideoOptions
                {
                    ItemId = video.Id,
                    MediaSources = sources.ToArray(),
                    Profile = _profile,
                    DeviceId = deviceId,
                    MaxBitrate = _profile.MaxStreamingBitrate
                });
            }

            var targetWidth = streamInfo.TargetWidth;
            var targetHeight = streamInfo.TargetHeight;

            var contentFeatureList = new ContentFeatureBuilder(_profile).BuildVideoHeader(
                streamInfo.Container,
                streamInfo.TargetVideoCodec.FirstOrDefault(),
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetWidth,
                targetHeight,
                streamInfo.TargetVideoBitDepth,
                streamInfo.TargetVideoBitrate,
                streamInfo.TargetTimestamp,
                streamInfo.IsDirectStream,
                streamInfo.RunTimeTicks ?? 0,
                streamInfo.TargetVideoProfile,
                streamInfo.TargetVideoLevel,
                streamInfo.TargetFramerate ?? 0,
                streamInfo.TargetPacketLength,
                streamInfo.TranscodeSeekInfo,
                streamInfo.IsTargetAnamorphic,
                streamInfo.IsTargetInterlaced,
                streamInfo.TargetRefFrames,
                streamInfo.TargetVideoStreamCount,
                streamInfo.TargetAudioStreamCount,
                streamInfo.TargetVideoCodecTag,
                streamInfo.IsTargetAVC);

            foreach (var contentFeature in contentFeatureList)
            {
                AddVideoResource(writer, filter, contentFeature, streamInfo);
            }

            var subtitleProfiles = streamInfo.GetSubtitleProfiles(_mediaEncoder, false, _serverAddress, _accessToken);

            foreach (var subtitle in subtitleProfiles)
            {
                if (subtitle.DeliveryMethod != SubtitleDeliveryMethod.External)
                {
                    continue;
                }

                var subtitleAdded = AddSubtitleElement(writer, subtitle);

                if (subtitleAdded && _profile.EnableSingleSubtitleLimit)
                {
                    break;
                }
            }
        }

        private bool AddSubtitleElement(XmlWriter writer, SubtitleStreamInfo info)
        {
            var subtitleProfile = _profile.SubtitleProfiles
                .FirstOrDefault(i => string.Equals(info.Format, i.Format, StringComparison.OrdinalIgnoreCase)
                                    && i.Method == SubtitleDeliveryMethod.External);

            if (subtitleProfile == null)
            {
                return false;
            }

            var subtitleMode = subtitleProfile.DidlMode;

            if (string.Equals(subtitleMode, "CaptionInfoEx", StringComparison.OrdinalIgnoreCase))
            {
                // <sec:CaptionInfoEx sec:type="srt">http://192.168.1.3:9999/video.srt</sec:CaptionInfoEx>
                // <sec:CaptionInfo sec:type="srt">http://192.168.1.3:9999/video.srt</sec:CaptionInfo>

                writer.WriteStartElement("sec", "CaptionInfoEx", null);
                writer.WriteAttributeString("sec", "type", null, info.Format.ToLowerInvariant());

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }
            else if (string.Equals(subtitleMode, "smi", StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteStartElement(string.Empty, "res", NsDidl);

                writer.WriteAttributeString("protocolInfo", "http-get:*:smi/caption:*");

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }
            else
            {
                writer.WriteStartElement(string.Empty, "res", NsDidl);
                var protocolInfo = string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:text/{0}:*",
                    info.Format.ToLowerInvariant());
                writer.WriteAttributeString("protocolInfo", protocolInfo);

                writer.WriteString(info.Url);
                writer.WriteFullEndElement();
            }

            return true;
        }

        private void AddVideoResource(XmlWriter writer, Filter filter, string contentFeatures, StreamInfo streamInfo)
        {
            writer.WriteStartElement(string.Empty, "res", NsDidl);

            var url = NormalizeDlnaMediaUrl(streamInfo.ToUrl(_serverAddress, _accessToken));

            var mediaSource = streamInfo.MediaSource;

            if (mediaSource.RunTimeTicks.HasValue)
            {
                writer.WriteAttributeString("duration", TimeSpan.FromTicks(mediaSource.RunTimeTicks.Value).ToString("c", _usCulture));
            }

            if (filter.Contains("res@size"))
            {
                if (streamInfo.IsDirectStream || streamInfo.EstimateContentLength)
                {
                    var size = streamInfo.TargetSize;

                    if (size.HasValue)
                    {
                        writer.WriteAttributeString("size", size.Value.ToString(_usCulture));
                    }
                }
            }

            var totalBitrate = streamInfo.TargetTotalBitrate;
            var targetSampleRate = streamInfo.TargetAudioSampleRate;
            var targetChannels = streamInfo.TargetAudioChannels;

            var targetWidth = streamInfo.TargetWidth;
            var targetHeight = streamInfo.TargetHeight;

            if (targetChannels.HasValue)
            {
                writer.WriteAttributeString("nrAudioChannels", targetChannels.Value.ToString(_usCulture));
            }

            if (filter.Contains("res@resolution"))
            {
                if (targetWidth.HasValue && targetHeight.HasValue)
                {
                    writer.WriteAttributeString(
                        "resolution",
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "{0}x{1}",
                            targetWidth.Value,
                            targetHeight.Value));
                }
            }

            if (targetSampleRate.HasValue)
            {
                writer.WriteAttributeString("sampleFrequency", targetSampleRate.Value.ToString(_usCulture));
            }

            if (totalBitrate.HasValue)
            {
                writer.WriteAttributeString("bitrate", totalBitrate.Value.ToString(_usCulture));
            }

            var mediaProfile = _profile.GetVideoMediaProfile(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                streamInfo.TargetVideoCodec.FirstOrDefault(),
                streamInfo.TargetAudioBitrate,
                targetWidth,
                targetHeight,
                streamInfo.TargetVideoBitDepth,
                streamInfo.TargetVideoProfile,
                streamInfo.TargetVideoLevel,
                streamInfo.TargetFramerate ?? 0,
                streamInfo.TargetPacketLength,
                streamInfo.TargetTimestamp,
                streamInfo.IsTargetAnamorphic,
                streamInfo.IsTargetInterlaced,
                streamInfo.TargetRefFrames,
                streamInfo.TargetVideoStreamCount,
                streamInfo.TargetAudioStreamCount,
                streamInfo.TargetVideoCodecTag,
                streamInfo.IsTargetAVC);

            var filename = url.Substring(0, url.IndexOf('?', StringComparison.Ordinal));

            var mimeType = mediaProfile == null || string.IsNullOrEmpty(mediaProfile.MimeType)
               ? MimeTypes.GetMimeType(filename)
               : mediaProfile.MimeType;

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    mimeType,
                    contentFeatures));

            writer.WriteString(url);

            writer.WriteFullEndElement();
        }

        private string GetDisplayName(BaseItem item, StubType? itemStubType, BaseItem context)
        {
            if (itemStubType.HasValue)
            {
                switch (itemStubType.Value)
                {
                    case StubType.Latest: return _localization.GetLocalizedString("Latest");
                    case StubType.Playlists: return _localization.GetLocalizedString("Playlists");
                    case StubType.AlbumArtists: return _localization.GetLocalizedString("HeaderAlbumArtists");
                    case StubType.Albums: return _localization.GetLocalizedString("Albums");
                    case StubType.Artists: return _localization.GetLocalizedString("Artists");
                    case StubType.Songs: return _localization.GetLocalizedString("Songs");
                    case StubType.Genres: return _localization.GetLocalizedString("Genres");
                    case StubType.FavoriteAlbums: return _localization.GetLocalizedString("HeaderFavoriteAlbums");
                    case StubType.FavoriteArtists: return _localization.GetLocalizedString("HeaderFavoriteArtists");
                    case StubType.FavoriteSongs: return _localization.GetLocalizedString("HeaderFavoriteSongs");
                    case StubType.ContinueWatching: return _localization.GetLocalizedString("HeaderContinueWatching");
                    case StubType.Movies: return _localization.GetLocalizedString("Movies");
                    case StubType.Collections: return _localization.GetLocalizedString("Collections");
                    case StubType.Favorites: return _localization.GetLocalizedString("Favorites");
                    case StubType.NextUp: return _localization.GetLocalizedString("HeaderNextUp");
                    case StubType.FavoriteSeries: return _localization.GetLocalizedString("HeaderFavoriteShows");
                    case StubType.FavoriteEpisodes: return _localization.GetLocalizedString("HeaderFavoriteEpisodes");
                    case StubType.Series: return _localization.GetLocalizedString("Shows");
                }
            }

            return item is Episode episode
                ? GetEpisodeDisplayName(episode, context)
                : item.Name;
        }

        /// <summary>
        /// Gets episode display name appropriate for the given context.
        /// </summary>
        /// <remarks>
        /// If context is a season, this will return a string containing just episode number and name.
        /// Otherwise the result will include series nams and season number.
        /// </remarks>
        /// <param name="episode">The episode.</param>
        /// <param name="context">Current context.</param>
        /// <returns>Formatted name of the episode.</returns>
        private string GetEpisodeDisplayName(Episode episode, BaseItem context)
        {
            string[] components;

            if (context is Season season)
            {
                // This is a special embedded within a season
                if (episode.ParentIndexNumber.HasValue && episode.ParentIndexNumber.Value == 0
                    && season.IndexNumber.HasValue && season.IndexNumber.Value != 0)
                {
                    return string.Format(
                        CultureInfo.InvariantCulture,
                        _localization.GetLocalizedString("ValueSpecialEpisodeName"),
                        episode.Name);
                }

                // inside a season use simple format (ex. '12 - Episode Name')
                var epNumberName = GetEpisodeIndexFullName(episode);
                components = new[] { epNumberName, episode.Name };
            }
            else
            {
                // outside a season include series and season details (ex. 'TV Show - S05E11 - Episode Name')
                var epNumberName = GetEpisodeNumberDisplayName(episode);
                components = new[] { episode.SeriesName, epNumberName, episode.Name };
            }

            return string.Join(" - ", components.Where(NotNullOrWhiteSpace));
        }

        /// <summary>
        /// Gets complete episode number.
        /// </summary>
        /// <param name="episode">The episode.</param>
        /// <returns>For single episodes returns just the number. For double episodes - current and ending numbers.</returns>
        private string GetEpisodeIndexFullName(Episode episode)
        {
            var name = string.Empty;
            if (episode.IndexNumber.HasValue)
            {
                name += episode.IndexNumber.Value.ToString("00", CultureInfo.InvariantCulture);

                if (episode.IndexNumberEnd.HasValue)
                {
                    name += "-" + episode.IndexNumberEnd.Value.ToString("00", CultureInfo.InvariantCulture);
                }
            }

            return name;
        }

        /// <summary>
        /// Gets episode number formatted as 'S##E##'.
        /// </summary>
        /// <param name="episode">The episode.</param>
        /// <returns>Formatted episode number.</returns>
        private string GetEpisodeNumberDisplayName(Episode episode)
        {
            var name = string.Empty;
            var seasonNumber = episode.Season?.IndexNumber;

            if (seasonNumber.HasValue)
            {
                name = "S" + seasonNumber.Value.ToString("00", CultureInfo.InvariantCulture);
            }

            var indexName = GetEpisodeIndexFullName(episode);

            if (!string.IsNullOrWhiteSpace(indexName))
            {
                name += "E" + indexName;
            }

            return name;
        }

        private bool NotNullOrWhiteSpace(string s) => !string.IsNullOrWhiteSpace(s);

        private void AddAudioResource(XmlWriter writer, BaseItem audio, string deviceId, Filter filter, StreamInfo streamInfo = null)
        {
            writer.WriteStartElement(string.Empty, "res", NsDidl);

            if (streamInfo == null)
            {
                var sources = _mediaSourceManager.GetStaticMediaSources(audio, true, _user);

                streamInfo = new StreamBuilder(_mediaEncoder, _logger).BuildAudioItem(new AudioOptions
                {
                    ItemId = audio.Id,
                    MediaSources = sources.ToArray(),
                    Profile = _profile,
                    DeviceId = deviceId
                });
            }

            var url = NormalizeDlnaMediaUrl(streamInfo.ToUrl(_serverAddress, _accessToken));

            var mediaSource = streamInfo.MediaSource;

            if (mediaSource.RunTimeTicks.HasValue)
            {
                writer.WriteAttributeString("duration", TimeSpan.FromTicks(mediaSource.RunTimeTicks.Value).ToString("c", _usCulture));
            }

            if (filter.Contains("res@size"))
            {
                if (streamInfo.IsDirectStream || streamInfo.EstimateContentLength)
                {
                    var size = streamInfo.TargetSize;

                    if (size.HasValue)
                    {
                        writer.WriteAttributeString("size", size.Value.ToString(_usCulture));
                    }
                }
            }

            var targetAudioBitrate = streamInfo.TargetAudioBitrate;
            var targetSampleRate = streamInfo.TargetAudioSampleRate;
            var targetChannels = streamInfo.TargetAudioChannels;
            var targetAudioBitDepth = streamInfo.TargetAudioBitDepth;

            if (targetChannels.HasValue)
            {
                writer.WriteAttributeString("nrAudioChannels", targetChannels.Value.ToString(_usCulture));
            }

            if (targetSampleRate.HasValue)
            {
                writer.WriteAttributeString("sampleFrequency", targetSampleRate.Value.ToString(_usCulture));
            }

            if (targetAudioBitrate.HasValue)
            {
                writer.WriteAttributeString("bitrate", targetAudioBitrate.Value.ToString(_usCulture));
            }

            var mediaProfile = _profile.GetAudioMediaProfile(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetChannels,
                targetAudioBitrate,
                targetSampleRate,
                targetAudioBitDepth);

            var filename = url.Substring(0, url.IndexOf('?', StringComparison.Ordinal));

            var mimeType = mediaProfile == null || string.IsNullOrEmpty(mediaProfile.MimeType)
                ? MimeTypes.GetMimeType(filename)
                : mediaProfile.MimeType;

            var contentFeatures = new ContentFeatureBuilder(_profile).BuildAudioHeader(
                streamInfo.Container,
                streamInfo.TargetAudioCodec.FirstOrDefault(),
                targetAudioBitrate,
                targetSampleRate,
                targetChannels,
                targetAudioBitDepth,
                streamInfo.IsDirectStream,
                streamInfo.RunTimeTicks ?? 0,
                streamInfo.TranscodeSeekInfo);

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    mimeType,
                    contentFeatures));

            writer.WriteString(url);

            writer.WriteFullEndElement();
        }

        public static bool IsIdRoot(string id)
            => string.IsNullOrWhiteSpace(id)
                || string.Equals(id, "0", StringComparison.OrdinalIgnoreCase)
                // Samsung sometimes uses 1 as root
                || string.Equals(id, "1", StringComparison.OrdinalIgnoreCase);

        public void WriteFolderElement(XmlWriter writer, BaseItem folder, StubType? stubType, BaseItem context, int childCount, Filter filter, string requestedId = null)
        {
            writer.WriteStartElement(string.Empty, "container", NsDidl);

            writer.WriteAttributeString("restricted", "1");
            writer.WriteAttributeString("searchable", "1");
            writer.WriteAttributeString("childCount", childCount.ToString(_usCulture));

            var clientId = GetClientId(folder, stubType);

            if (string.Equals(requestedId, "0", StringComparison.Ordinal))
            {
                writer.WriteAttributeString("id", "0");
                writer.WriteAttributeString("parentID", "-1");
            }
            else
            {
                writer.WriteAttributeString("id", clientId);

                if (context != null)
                {
                    writer.WriteAttributeString("parentID", GetClientId(context, null));
                }
                else
                {
                    var parent = folder.DisplayParentId;
                    if (parent.Equals(Guid.Empty))
                    {
                        writer.WriteAttributeString("parentID", "0");
                    }
                    else
                    {
                        writer.WriteAttributeString("parentID", GetClientId(parent, null));
                    }
                }
            }

            AddGeneralProperties(folder, stubType, context, writer, filter);

            AddCover(folder, stubType, writer);

            writer.WriteFullEndElement();
        }

        private void AddSamsungBookmarkInfo(BaseItem item, User user, XmlWriter writer, StreamInfo streamInfo)
        {
            if (!item.SupportsPositionTicksResume || item is Folder)
            {
                return;
            }

            XmlAttribute secAttribute = null;
            foreach (var attribute in _profile.XmlRootAttributes)
            {
                if (string.Equals(attribute.Name, "xmlns:sec", StringComparison.OrdinalIgnoreCase))
                {
                    secAttribute = attribute;
                    break;
                }
            }

            // Not a samsung device
            if (secAttribute == null)
            {
                return;
            }

            var userdata = _userDataManager.GetUserData(user, item);
            var playbackPositionTicks = (streamInfo != null && streamInfo.StartPositionTicks > 0) ? streamInfo.StartPositionTicks : userdata.PlaybackPositionTicks;

            if (playbackPositionTicks > 0)
            {
                var elementValue = string.Format(
                    CultureInfo.InvariantCulture,
                    "BM={0}",
                    Convert.ToInt32(TimeSpan.FromTicks(playbackPositionTicks).TotalSeconds));
                AddValue(writer, "sec", "dcmInfo", elementValue, secAttribute.Value);
            }
        }

        /// <summary>
        /// Adds fields used by both items and folders.
        /// </summary>
        private void AddCommonFields(BaseItem item, StubType? itemStubType, BaseItem context, XmlWriter writer, Filter filter)
        {
            // Don't filter on dc:title because not all devices will include it in the filter
            // MediaMonkey for example won't display content without a title
            // if (filter.Contains("dc:title"))
            {
                AddValue(writer, "dc", "title", GetDisplayName(item, itemStubType, context), NsDc);
            }

            WriteObjectClass(writer, item, itemStubType);

            if (filter.Contains("dc:date"))
            {
                if (item.PremiereDate.HasValue)
                {
                    AddValue(writer, "dc", "date", item.PremiereDate.Value.ToString("o", CultureInfo.InvariantCulture), NsDc);
                }
            }

            if (filter.Contains("upnp:genre"))
            {
                foreach (var genre in item.Genres)
                {
                    AddValue(writer, "upnp", "genre", genre, NsUpnp);
                }
            }

            foreach (var studio in item.Studios)
            {
                AddValue(writer, "upnp", "publisher", studio, NsUpnp);
            }

            if (!(item is Folder))
            {
                if (filter.Contains("dc:description"))
                {
                    var desc = item.Overview;

                    if (!string.IsNullOrWhiteSpace(desc))
                    {
                        AddValue(writer, "dc", "description", desc, NsDc);
                    }
                }

                // if (filter.Contains("upnp:longDescription"))
                // {
                //    if (!string.IsNullOrWhiteSpace(item.Overview))
                //    {
                //        AddValue(writer, "upnp", "longDescription", item.Overview, NsUpnp);
                //    }
                // }
            }

            if (!string.IsNullOrEmpty(item.OfficialRating))
            {
                if (filter.Contains("dc:rating"))
                {
                    AddValue(writer, "dc", "rating", item.OfficialRating, NsDc);
                }

                if (filter.Contains("upnp:rating"))
                {
                    AddValue(writer, "upnp", "rating", item.OfficialRating, NsUpnp);
                }
            }

            AddPeople(item, writer);
        }

        private void WriteObjectClass(XmlWriter writer, BaseItem item, StubType? stubType)
        {
            // More types here
            // http://oss.linn.co.uk/repos/Public/LibUpnpCil/DidlLite/UpnpAv/Test/TestDidlLite.cs

            writer.WriteStartElement("upnp", "class", NsUpnp);

            if (item.IsDisplayedAsFolder || stubType.HasValue)
            {
                string classType = null;

                if (!_profile.RequiresPlainFolders)
                {
                    if (item is MusicAlbum)
                    {
                        classType = "object.container.album.musicAlbum";
                    }
                    else if (item is MusicArtist)
                    {
                        classType = "object.container.person.musicArtist";
                    }
                    else if (item is Series || item is Season || item is BoxSet || item is Video)
                    {
                        classType = "object.container.album.videoAlbum";
                    }
                    else if (item is Playlist)
                    {
                        classType = "object.container.playlistContainer";
                    }
                    else if (item is PhotoAlbum)
                    {
                        classType = "object.container.album.photoAlbum";
                    }
                }

                writer.WriteString(classType ?? "object.container.storageFolder");
            }
            else if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteString("object.item.audioItem.musicTrack");
            }
            else if (string.Equals(item.MediaType, MediaType.Photo, StringComparison.OrdinalIgnoreCase))
            {
                writer.WriteString("object.item.imageItem.photo");
            }
            else if (string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
            {
                if (!_profile.RequiresPlainVideoItems && item is Movie)
                {
                    writer.WriteString("object.item.videoItem.movie");
                }
                else if (!_profile.RequiresPlainVideoItems && item is MusicVideo)
                {
                    writer.WriteString("object.item.videoItem.musicVideoClip");
                }
                else
                {
                    writer.WriteString("object.item.videoItem");
                }
            }
            else if (item is MusicGenre)
            {
                writer.WriteString(_profile.RequiresPlainFolders ? "object.container.storageFolder" : "object.container.genre.musicGenre");
            }
            else if (item is Genre)
            {
                writer.WriteString(_profile.RequiresPlainFolders ? "object.container.storageFolder" : "object.container.genre");
            }
            else
            {
                writer.WriteString("object.item");
            }

            writer.WriteFullEndElement();
        }

        private void AddPeople(BaseItem item, XmlWriter writer)
        {
            if (!item.SupportsPeople)
            {
                return;
            }

            var types = new[]
            {
                PersonType.Director,
                PersonType.Writer,
                PersonType.Producer,
                PersonType.Composer,
                "creator"
            };

            // Seeing some LG models locking up due content with large lists of people
            // The actual issue might just be due to processing a more metadata than it can handle
            var people = _libraryManager.GetPeople(
                new InternalPeopleQuery
                {
                    ItemId = item.Id,
                    Limit = 6
                });

            foreach (var actor in people)
            {
                var type = types.FirstOrDefault(i => string.Equals(i, actor.Type, StringComparison.OrdinalIgnoreCase) || string.Equals(i, actor.Role, StringComparison.OrdinalIgnoreCase))
                    ?? PersonType.Actor;

                AddValue(writer, "upnp", type.ToLowerInvariant(), actor.Name, NsUpnp);
            }
        }

        private void AddGeneralProperties(BaseItem item, StubType? itemStubType, BaseItem context, XmlWriter writer, Filter filter)
        {
            AddCommonFields(item, itemStubType, context, writer, filter);

            if (item is IHasArtist hasArtists)
            {
                foreach (var artist in hasArtists.Artists)
                {
                    AddValue(writer, "upnp", "artist", artist, NsUpnp);
                    AddValue(writer, "dc", "creator", artist, NsDc);

                    // If it doesn't support album artists (musicvideo), then tag as both
                    if (hasAlbumArtists == null)
                    {
                        AddAlbumArtist(writer, artist);
                    }
                }
            }

            if (item is IHasAlbumArtist hasAlbumArtists)
            {
                foreach (var albumArtist in hasAlbumArtists.AlbumArtists)
                {
                    AddAlbumArtist(writer, albumArtist);
                }
            }

            if (!string.IsNullOrWhiteSpace(item.Album))
            {
                AddValue(writer, "upnp", "album", item.Album, NsUpnp);
            }

            if (item.IndexNumber.HasValue)
            {
                AddValue(writer, "upnp", "originalTrackNumber", item.IndexNumber.Value.ToString(_usCulture), NsUpnp);

                if (item is Episode)
                {
                    AddValue(writer, "upnp", "episodeNumber", item.IndexNumber.Value.ToString(_usCulture), NsUpnp);
                }
            }
        }

        private void AddAlbumArtist(XmlWriter writer, string name)
        {
            try
            {
                writer.WriteStartElement("upnp", "artist", NsUpnp);
                writer.WriteAttributeString("role", "AlbumArtist");

                writer.WriteString(name);

                writer.WriteFullEndElement();
            }
            catch (XmlException ex)
            {
                _logger.LogError(ex, "Error adding xml value: {Value}", name);
            }
        }

        private void AddValue(XmlWriter writer, string prefix, string name, string value, string namespaceUri)
        {
            try
            {
                writer.WriteElementString(prefix, name, namespaceUri, value);
            }
            catch (XmlException ex)
            {
                _logger.LogError(ex, "Error adding xml value: {Value}", value);
            }
        }

        private void AddCover(BaseItem item, StubType? stubType, XmlWriter writer)
        {
            ImageDownloadInfo imageInfo = GetImageInfo(item);

            if (imageInfo == null)
            {
                return;
            }

            var albumartUrlInfo = GetImageUrl(imageInfo, _profile.MaxAlbumArtWidth, _profile.MaxAlbumArtHeight, "jpg");

            writer.WriteStartElement("upnp", "albumArtURI", NsUpnp);
            writer.WriteAttributeString("dlna", "profileID", NsDlna, _profile.AlbumArtPn);
            writer.WriteString(albumartUrlInfo.url);
            writer.WriteFullEndElement();

            // TOOD: Remove these default values
            var iconUrlInfo = GetImageUrl(imageInfo, _profile.MaxIconWidth ?? 48, _profile.MaxIconHeight ?? 48, "jpg");
            writer.WriteElementString("upnp", "icon", NsUpnp, iconUrlInfo.url);

            if (!_profile.EnableAlbumArtInDidl)
            {
                if (string.Equals(item.MediaType, MediaType.Audio, StringComparison.OrdinalIgnoreCase)
                    || string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase))
                {
                    if (!stubType.HasValue)
                    {
                        return;
                    }
                }
            }

            if (!_profile.EnableSingleAlbumArtLimit || string.Equals(item.MediaType, MediaType.Photo, StringComparison.OrdinalIgnoreCase))
            {
                AddImageResElement(item, writer, 4096, 4096, "jpg", "JPEG_LRG");
                AddImageResElement(item, writer, 1024, 768, "jpg", "JPEG_MED");
                AddImageResElement(item, writer, 640, 480, "jpg", "JPEG_SM");
                AddImageResElement(item, writer, 4096, 4096, "png", "PNG_LRG");
                AddImageResElement(item, writer, 160, 160, "png", "PNG_TN");
            }

            AddImageResElement(item, writer, 160, 160, "jpg", "JPEG_TN");
        }

        private void AddImageResElement(
            BaseItem item,
            XmlWriter writer,
            int maxWidth,
            int maxHeight,
            string format,
            string org_Pn)
        {
            var imageInfo = GetImageInfo(item);

            if (imageInfo == null)
            {
                return;
            }

            var albumartUrlInfo = GetImageUrl(imageInfo, maxWidth, maxHeight, format);

            writer.WriteStartElement(string.Empty, "res", NsDidl);

            // Images must have a reported size or many clients (Bubble upnp), will only use the first thumbnail
            // rather than using a larger one when available
            var width = albumartUrlInfo.width ?? maxWidth;
            var height = albumartUrlInfo.height ?? maxHeight;

            var contentFeatures = new ContentFeatureBuilder(_profile)
                .BuildImageHeader(format, width, height, imageInfo.IsDirectStream, org_Pn);

            writer.WriteAttributeString(
                "protocolInfo",
                string.Format(
                    CultureInfo.InvariantCulture,
                    "http-get:*:{0}:{1}",
                    MimeTypes.GetMimeType("file." + format),
                    contentFeatures));

            writer.WriteAttributeString(
                "resolution",
                string.Format(CultureInfo.InvariantCulture, "{0}x{1}", width, height));

            writer.WriteString(albumartUrlInfo.url);

            writer.WriteFullEndElement();
        }

        private ImageDownloadInfo GetImageInfo(BaseItem item)
        {
            if (item.HasImage(ImageType.Primary))
            {
                return GetImageInfo(item, ImageType.Primary);
            }

            if (item.HasImage(ImageType.Thumb))
            {
                return GetImageInfo(item, ImageType.Thumb);
            }

            if (item.HasImage(ImageType.Backdrop))
            {
                if (item is Channel)
                {
                    return GetImageInfo(item, ImageType.Backdrop);
                }
            }

            // For audio tracks without art use album art if available.
            if (item is Audio audioItem)
            {
                var album = audioItem.AlbumEntity;
                return album != null && album.HasImage(ImageType.Primary)
                    ? GetImageInfo(album, ImageType.Primary)
                    : null;
            }

            // Don't look beyond album/playlist level. Metadata service may assign an image from a different album/show to the parent folder.
            if (item is MusicAlbum || item is Playlist)
            {
                return null;
            }

            // For other item types check parents, but be aware that image retrieved from a parent may be not suitable for this media item.
            var parentWithImage = GetFirstParentWithImageBelowUserRoot(item);
            if (parentWithImage != null)
            {
                return GetImageInfo(parentWithImage, ImageType.Primary);
            }

            return null;
        }

        private BaseItem GetFirstParentWithImageBelowUserRoot(BaseItem item)
        {
            if (item == null)
            {
                return null;
            }

            if (item.HasImage(ImageType.Primary))
            {
                return item;
            }

            var parent = item.GetParent();
            if (parent is UserRootFolder)
            {
                return null;
            }

            // terminate in case we went past user root folder (unlikely?)
            if (parent is Folder folder && folder.IsRoot)
            {
                return null;
            }

            return GetFirstParentWithImageBelowUserRoot(parent);
        }

        private ImageDownloadInfo GetImageInfo(BaseItem item, ImageType type)
        {
            var imageInfo = item.GetImageInfo(type, 0);
            string tag = null;

            try
            {
                tag = _imageProcessor.GetImageCacheTag(item, type);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error getting image cache tag");
            }

            int? width = imageInfo.Width;
            int? height = imageInfo.Height;

            if (width == 0 || height == 0)
            {
                width = null;
                height = null;
            }
            else if (width == -1 || height == -1)
            {
                width = null;
                height = null;
            }

            var inputFormat = (Path.GetExtension(imageInfo.Path) ?? string.Empty)
                .TrimStart('.')
                .Replace("jpeg", "jpg", StringComparison.OrdinalIgnoreCase);

            return new ImageDownloadInfo
            {
                ItemId = item.Id,
                Type = type,
                ImageTag = tag,
                Width = width,
                Height = height,
                Format = inputFormat,
                ItemImageInfo = imageInfo
            };
        }

        public static string GetClientId(BaseItem item, StubType? stubType)
        {
            return GetClientId(item.Id, stubType);
        }

        public static string GetClientId(Guid idValue, StubType? stubType)
        {
            var id = idValue.ToString("N", CultureInfo.InvariantCulture);

            if (stubType.HasValue)
            {
                id = stubType.Value.ToString().ToLowerInvariant() + "_" + id;
            }

            return id;
        }

        private (string url, int? width, int? height) GetImageUrl(ImageDownloadInfo info, int maxWidth, int maxHeight, string format)
        {
            var url = string.Format(
                CultureInfo.InvariantCulture,
                "{0}/Items/{1}/Images/{2}/0/{3}/{4}/{5}/{6}/0/0",
                _serverAddress,
                info.ItemId.ToString("N", CultureInfo.InvariantCulture),
                info.Type,
                info.ImageTag,
                format,
                maxWidth.ToString(CultureInfo.InvariantCulture),
                maxHeight.ToString(CultureInfo.InvariantCulture));

            var width = info.Width;
            var height = info.Height;

            info.IsDirectStream = false;

            if (width.HasValue && height.HasValue)
            {
                var newSize = DrawingUtils.Resize(
                        new ImageDimensions(width.Value, height.Value), 0, 0, maxWidth, maxHeight);

                width = newSize.Width;
                height = newSize.Height;

                var normalizedFormat = format
                    .Replace("jpeg", "jpg", StringComparison.OrdinalIgnoreCase);

                if (string.Equals(info.Format, normalizedFormat, StringComparison.OrdinalIgnoreCase))
                {
                    info.IsDirectStream = maxWidth >= width.Value && maxHeight >= height.Value;
                }
            }

            // just lie
            info.IsDirectStream = true;

            return (url, width, height);
        }

        private class ImageDownloadInfo
        {
            internal Guid ItemId { get; set; }

            internal string ImageTag { get; set; }

            internal ImageType Type { get; set; }

            internal int? Width { get; set; }

            internal int? Height { get; set; }

            internal bool IsDirectStream { get; set; }

            internal string Format { get; set; }

            internal ItemImageInfo ItemImageInfo { get; set; }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Emby.Dlna\Didl\DidlBuilder.cs(906,25): error CS0841: Cannot use local variable 'hasAlbumArtists' before it is declared
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Jellyfin.Api.Models.StreamingDtos;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Devices;
using MediaBrowser.Controller.Dlna;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Net;
using MediaBrowser.Model.Dlna;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.IO;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Primitives;
using Microsoft.Net.Http.Headers;

namespace Jellyfin.Api.Helpers
{
    /// <summary>
    /// The streaming helpers.
    /// </summary>
    public static class StreamingHelpers
    {
        /// <summary>
        /// Gets the current streaming state.
        /// </summary>
        /// <param name="streamingRequest">The <see cref="StreamingRequestDto"/>.</param>
        /// <param name="httpRequest">The <see cref="HttpRequest"/>.</param>
        /// <param name="authorizationContext">Instance of the <see cref="IAuthorizationContext"/> interface.</param>
        /// <param name="mediaSourceManager">Instance of the <see cref="IMediaSourceManager"/> interface.</param>
        /// <param name="userManager">Instance of the <see cref="IUserManager"/> interface.</param>
        /// <param name="libraryManager">Instance of the <see cref="ILibraryManager"/> interface.</param>
        /// <param name="serverConfigurationManager">Instance of the <see cref="IServerConfigurationManager"/> interface.</param>
        /// <param name="mediaEncoder">Instance of the <see cref="IMediaEncoder"/> interface.</param>
        /// <param name="fileSystem">Instance of the <see cref="IFileSystem"/> interface.</param>
        /// <param name="subtitleEncoder">Instance of the <see cref="ISubtitleEncoder"/> interface.</param>
        /// <param name="configuration">Instance of the <see cref="IConfiguration"/> interface.</param>
        /// <param name="dlnaManager">Instance of the <see cref="IDlnaManager"/> interface.</param>
        /// <param name="deviceManager">Instance of the <see cref="IDeviceManager"/> interface.</param>
        /// <param name="transcodingJobHelper">Initialized <see cref="TranscodingJobHelper"/>.</param>
        /// <param name="transcodingJobType">The <see cref="TranscodingJobType"/>.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/>.</param>
        /// <returns>A <see cref="Task"/> containing the current <see cref="StreamState"/>.</returns>
        public static async Task<StreamState> GetStreamingState(
            StreamingRequestDto streamingRequest,
            HttpRequest httpRequest,
            IAuthorizationContext authorizationContext,
            IMediaSourceManager mediaSourceManager,
            IUserManager userManager,
            ILibraryManager libraryManager,
            IServerConfigurationManager serverConfigurationManager,
            IMediaEncoder mediaEncoder,
            IFileSystem fileSystem,
            ISubtitleEncoder subtitleEncoder,
            IConfiguration configuration,
            IDlnaManager dlnaManager,
            IDeviceManager deviceManager,
            TranscodingJobHelper transcodingJobHelper,
            TranscodingJobType transcodingJobType,
            CancellationToken cancellationToken)
        {
            EncodingHelper encodingHelper = new EncodingHelper(mediaEncoder, fileSystem, subtitleEncoder, configuration);
            // Parse the DLNA time seek header
            if (!streamingRequest.StartTimeTicks.HasValue)
            {
                var timeSeek = httpRequest.Headers["TimeSeekRange.dlna.org"];

                streamingRequest.StartTimeTicks = ParseTimeSeekHeader(timeSeek.ToString());
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.Params))
            {
                ParseParams(streamingRequest);
            }

            streamingRequest.StreamOptions = ParseStreamOptions(httpRequest.Query);
            if (httpRequest.Path.Value == null)
            {
                throw new ResourceNotFoundException(nameof(httpRequest.Path));
            }

            var url = httpRequest.Path.Value.Split('.')[^1];

            if (string.IsNullOrEmpty(streamingRequest.AudioCodec))
            {
                streamingRequest.AudioCodec = encodingHelper.InferAudioCodec(url);
            }

            var enableDlnaHeaders = !string.IsNullOrWhiteSpace(streamingRequest.Params) ||
                                    string.Equals(httpRequest.Headers["GetContentFeatures.DLNA.ORG"], "1", StringComparison.OrdinalIgnoreCase);

            var state = new StreamState(mediaSourceManager, transcodingJobType, transcodingJobHelper)
            {
                Request = streamingRequest,
                RequestedUrl = url,
                UserAgent = httpRequest.Headers[HeaderNames.UserAgent],
                EnableDlnaHeaders = enableDlnaHeaders
            };

            var auth = authorizationContext.GetAuthorizationInfo(httpRequest);
            if (!auth.UserId.Equals(Guid.Empty))
            {
                state.User = userManager.GetUserById(auth.UserId);
            }

            if (state.IsVideoRequest && !string.IsNullOrWhiteSpace(state.Request.VideoCodec))
            {
                state.SupportedVideoCodecs = state.Request.VideoCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.VideoCodec = state.SupportedVideoCodecs.FirstOrDefault();
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.AudioCodec))
            {
                state.SupportedAudioCodecs = streamingRequest.AudioCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.AudioCodec = state.SupportedAudioCodecs.FirstOrDefault(i => mediaEncoder.CanEncodeToAudioCodec(i))
                                           ?? state.SupportedAudioCodecs.FirstOrDefault();
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.SubtitleCodec))
            {
                state.SupportedSubtitleCodecs = streamingRequest.SubtitleCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.SubtitleCodec = state.SupportedSubtitleCodecs.FirstOrDefault(i => mediaEncoder.CanEncodeToSubtitleCodec(i))
                                              ?? state.SupportedSubtitleCodecs.FirstOrDefault();
            }

            var item = libraryManager.GetItemById(streamingRequest.Id);

            state.IsInputVideo = string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase);

            MediaSourceInfo? mediaSource = null;
            if (string.IsNullOrWhiteSpace(streamingRequest.LiveStreamId))
            {
                var currentJob = !string.IsNullOrWhiteSpace(streamingRequest.PlaySessionId)
                    ? transcodingJobHelper.GetTranscodingJob(streamingRequest.PlaySessionId)
                    : null;

                if (currentJob != null)
                {
                    mediaSource = currentJob.MediaSource;
                }

                if (mediaSource == null)
                {
                    var mediaSources = await mediaSourceManager.GetPlaybackMediaSources(libraryManager.GetItemById(streamingRequest.Id), null, false, false, cancellationToken).ConfigureAwait(false);

                    mediaSource = string.IsNullOrEmpty(streamingRequest.MediaSourceId)
                        ? mediaSources[0]
                        : mediaSources.Find(i => string.Equals(i.Id, streamingRequest.MediaSourceId, StringComparison.InvariantCulture));

                    if (mediaSource == null && Guid.Parse(streamingRequest.MediaSourceId) == streamingRequest.Id)
                    {
                        mediaSource = mediaSources[0];
                    }
                }
            }
            else
            {
                var liveStreamInfo = await mediaSourceManager.GetLiveStreamWithDirectStreamProvider(streamingRequest.LiveStreamId, cancellationToken).ConfigureAwait(false);
                mediaSource = liveStreamInfo.Item1;
                state.DirectStreamProvider = liveStreamInfo.Item2;
            }

            var encodingOptions = serverConfigurationManager.GetEncodingOptions();

            encodingHelper.AttachMediaSourceInfo(state, encodingOptions, mediaSource, url);

            string? containerInternal = Path.GetExtension(state.RequestedUrl);

            if (!string.IsNullOrEmpty(streamingRequest.Container))
            {
                containerInternal = streamingRequest.Container;
            }

            if (string.IsNullOrEmpty(containerInternal))
            {
                containerInternal = streamingRequest.Static ?
                    StreamBuilder.NormalizeMediaSourceFormatIntoSingleContainer(state.InputContainer, null, DlnaProfileType.Audio)
                    : GetOutputFileExtension(state);
            }

            state.OutputContainer = (containerInternal ?? string.Empty).TrimStart('.');

            state.OutputAudioBitrate = encodingHelper.GetAudioBitrateParam(streamingRequest.AudioBitRate, streamingRequest.AudioCodec, state.AudioStream);

            state.OutputAudioCodec = streamingRequest.AudioCodec;

            state.OutputAudioChannels = encodingHelper.GetNumAudioChannelsParam(state, state.AudioStream, state.OutputAudioCodec);

            if (state.VideoRequest != null)
            {
                state.OutputVideoCodec = state.Request.VideoCodec;
                state.OutputVideoBitrate = encodingHelper.GetVideoBitrateParamValue(state.VideoRequest, state.VideoStream, state.OutputVideoCodec);

                encodingHelper.TryStreamCopy(state);

                if (!EncodingHelper.IsCopyCodec(state.OutputVideoCodec) && state.OutputVideoBitrate.HasValue)
                {
                    var isVideoResolutionNotRequested = !state.VideoRequest.Width.HasValue
                        && !state.VideoRequest.Height.HasValue
                        && !state.VideoRequest.MaxWidth.HasValue
                        && !state.VideoRequest.MaxHeight.HasValue;

                    if (isVideoResolutionNotRequested
                        && state.VideoStream != null
                        && state.VideoRequest.VideoBitRate.HasValue
                        && state.VideoStream.BitRate.HasValue
                        && state.VideoRequest.VideoBitRate.Value >= state.VideoStream.BitRate.Value)
                    {
                        // Don't downscale the resolution if the width/height/MaxWidth/MaxHeight is not requested,
                        // and the requested video bitrate is higher than source video bitrate.
                        if (state.VideoStream.Width.HasValue || state.VideoStream.Height.HasValue)
                        {
                            state.VideoRequest.MaxWidth = state.VideoStream?.Width;
                            state.VideoRequest.MaxHeight = state.VideoStream?.Height;
                        }
                    }
                    else
                    {
                        var resolution = ResolutionNormalizer.Normalize(
                            state.VideoStream?.BitRate,
                            state.VideoStream?.Width,
                            state.VideoStream?.Height,
                            state.OutputVideoBitrate.Value,
                            state.VideoStream?.Codec,
                            state.OutputVideoCodec,
                            state.VideoRequest.MaxWidth,
                            state.VideoRequest.MaxHeight);

                        state.VideoRequest.MaxWidth = resolution.MaxWidth;
                        state.VideoRequest.MaxHeight = resolution.MaxHeight;
                    }
                }
            }

            ApplyDeviceProfileSettings(state, dlnaManager, deviceManager, httpRequest, streamingRequest.DeviceProfileId, streamingRequest.Static);

            var ext = string.IsNullOrWhiteSpace(state.OutputContainer)
                ? GetOutputFileExtension(state)
                : ("." + state.OutputContainer);

            state.OutputFilePath = GetOutputFilePath(state, ext!, serverConfigurationManager, streamingRequest.DeviceId, streamingRequest.PlaySessionId);

            return state;
        }

        /// <summary>
        /// Adds the dlna headers.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <param name="responseHeaders">The response headers.</param>
        /// <param name="isStaticallyStreamed">if set to <c>true</c> [is statically streamed].</param>
        /// <param name="startTimeTicks">The start time in ticks.</param>
        /// <param name="request">The <see cref="HttpRequest"/>.</param>
        /// <param name="dlnaManager">Instance of the <see cref="IDlnaManager"/> interface.</param>
        public static void AddDlnaHeaders(
            StreamState state,
            IHeaderDictionary responseHeaders,
            bool isStaticallyStreamed,
            long? startTimeTicks,
            HttpRequest request,
            IDlnaManager dlnaManager)
        {
            if (!state.EnableDlnaHeaders)
            {
                return;
            }

            var profile = state.DeviceProfile;

            StringValues transferMode = request.Headers["transferMode.dlna.org"];
            responseHeaders.Add("transferMode.dlna.org", string.IsNullOrEmpty(transferMode) ? "Streaming" : transferMode.ToString());
            responseHeaders.Add("realTimeInfo.dlna.org", "DLNA.ORG_TLAG=*");

            if (state.RunTimeTicks.HasValue)
            {
                if (string.Equals(request.Headers["getMediaInfo.sec"], "1", StringComparison.OrdinalIgnoreCase))
                {
                    var ms = TimeSpan.FromTicks(state.RunTimeTicks.Value).TotalMilliseconds;
                    responseHeaders.Add("MediaInfo.sec", string.Format(
                        CultureInfo.InvariantCulture,
                        "SEC_Duration={0};",
                        Convert.ToInt32(ms)));
                }

                if (!isStaticallyStreamed && profile != null)
                {
                    AddTimeSeekResponseHeaders(state, responseHeaders, startTimeTicks);
                }
            }

            if (profile == null)
            {
                profile = dlnaManager.GetDefaultProfile();
            }

            var audioCodec = state.ActualOutputAudioCodec;

            if (!state.IsVideoRequest)
            {
                responseHeaders.Add("contentFeatures.dlna.org", new ContentFeatureBuilder(profile).BuildAudioHeader(
                    state.OutputContainer,
                    audioCodec,
                    state.OutputAudioBitrate,
                    state.OutputAudioSampleRate,
                    state.OutputAudioChannels,
                    state.OutputAudioBitDepth,
                    isStaticallyStreamed,
                    state.RunTimeTicks,
                    state.TranscodeSeekInfo));
            }
            else
            {
                var videoCodec = state.ActualOutputVideoCodec;

                responseHeaders.Add(
                    "contentFeatures.dlna.org",
                    new ContentFeatureBuilder(profile).BuildVideoHeader(state.OutputContainer, videoCodec, audioCodec, state.OutputWidth, state.OutputHeight, state.TargetVideoBitDepth, state.OutputVideoBitrate, state.TargetTimestamp, isStaticallyStreamed, state.RunTimeTicks, state.TargetVideoProfile, state.TargetVideoLevel, state.TargetFramerate, state.TargetPacketLength, state.TranscodeSeekInfo, state.IsTargetAnamorphic, state.IsTargetInterlaced, state.TargetRefFrames, state.TargetVideoStreamCount, state.TargetAudioStreamCount, state.TargetVideoCodecTag, state.IsTargetAVC).FirstOrDefault() ?? string.Empty);
            }
        }

        /// <summary>
        /// Parses the time seek header.
        /// </summary>
        /// <param name="value">The time seek header string.</param>
        /// <returns>A nullable <see cref="long"/> representing the seek time in ticks.</returns>
        private static long? ParseTimeSeekHeader(ReadOnlySpan<char> value)
        {
            if (value.IsEmpty)
            {
                return null;
            }

            const string npt = "npt=";
            if (!value.StartsWith(npt, StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentException("Invalid timeseek header");
            }

            var index = value.IndexOf('-');
            value = index == -1
                ? value.Slice(npt.Length)
                : value.Slice(npt.Length, index - npt.Length);
            if (value.IndexOf(':') == -1)
            {
                // Parses npt times in the format of '417.33'
                if (double.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out var seconds))
                {
                    return TimeSpan.FromSeconds(seconds).Ticks;
                }

                throw new ArgumentException("Invalid timeseek header");
            }

            try
            {
                // Parses npt times in the format of '10:19:25.7'
                return TimeSpan.Parse(value).Ticks;
            }
            catch
            {
                throw new ArgumentException("Invalid timeseek header");
            }
        }

        /// <summary>
        /// Parses query parameters as StreamOptions.
        /// </summary>
        /// <param name="queryString">The query string.</param>
        /// <returns>A <see cref="Dictionary{String,String}"/> containing the stream options.</returns>
        private static Dictionary<string, string> ParseStreamOptions(IQueryCollection queryString)
        {
            Dictionary<string, string> streamOptions = new Dictionary<string, string>();
            foreach (var param in queryString)
            {
                if (char.IsLower(param.Key[0]))
                {
                    // This was probably not parsed initially and should be a StreamOptions
                    // or the generated URL should correctly serialize it
                    // TODO: This should be incorporated either in the lower framework for parsing requests
                    streamOptions[param.Key] = param.Value;
                }
            }

            return streamOptions;
        }

        /// <summary>
        /// Adds the dlna time seek headers to the response.
        /// </summary>
        /// <param name="state">The current <see cref="StreamState"/>.</param>
        /// <param name="responseHeaders">The <see cref="IHeaderDictionary"/> of the response.</param>
        /// <param name="startTimeTicks">The start time in ticks.</param>
        private static void AddTimeSeekResponseHeaders(StreamState state, IHeaderDictionary responseHeaders, long? startTimeTicks)
        {
            var runtimeSeconds = TimeSpan.FromTicks(state.RunTimeTicks!.Value).TotalSeconds.ToString(CultureInfo.InvariantCulture);
            var startSeconds = TimeSpan.FromTicks(startTimeTicks ?? 0).TotalSeconds.ToString(CultureInfo.InvariantCulture);

            responseHeaders.Add("TimeSeekRange.dlna.org", string.Format(
                CultureInfo.InvariantCulture,
                "npt={0}-{1}/{1}",
                startSeconds,
                runtimeSeconds));
            responseHeaders.Add("X-AvailableSeekRange", string.Format(
                CultureInfo.InvariantCulture,
                "1 npt={0}-{1}",
                startSeconds,
                runtimeSeconds));
        }

        /// <summary>
        /// Gets the output file extension.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <returns>System.String.</returns>
        private static string? GetOutputFileExtension(StreamState state)
        {
            var ext = Path.GetExtension(state.RequestedUrl);

            if (!string.IsNullOrEmpty(ext))
            {
                return ext;
            }

            // Try to infer based on the desired video codec
            if (state.IsVideoRequest)
            {
                var videoCodec = state.Request.VideoCodec;

                if (string.Equals(videoCodec, "h264", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(videoCodec, "h265", StringComparison.OrdinalIgnoreCase))
                {
                    return ".ts";
                }

                if (string.Equals(videoCodec, "theora", StringComparison.OrdinalIgnoreCase))
                {
                    return ".ogv";
                }

                if (string.Equals(videoCodec, "vpx", StringComparison.OrdinalIgnoreCase))
                {
                    return ".webm";
                }

                if (string.Equals(videoCodec, "wmv", StringComparison.OrdinalIgnoreCase))
                {
                    return ".asf";
                }
            }

            // Try to infer based on the desired audio codec
            if (!state.IsVideoRequest)
            {
                var audioCodec = state.Request.AudioCodec;

                if (string.Equals("aac", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".aac";
                }

                if (string.Equals("mp3", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".mp3";
                }

                if (string.Equals("vorbis", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".ogg";
                }

                if (string.Equals("wma", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".wma";
                }
            }

            return null;
        }

        /// <summary>
        /// Gets the output file path for transcoding.
        /// </summary>
        /// <param name="state">The current <see cref="StreamState"/>.</param>
        /// <param name="outputFileExtension">The file extension of the output file.</param>
        /// <param name="serverConfigurationManager">Instance of the <see cref="IServerConfigurationManager"/> interface.</param>
        /// <param name="deviceId">The device id.</param>
        /// <param name="playSessionId">The play session id.</param>
        /// <returns>The complete file path, including the folder, for the transcoding file.</returns>
        private static string GetOutputFilePath(StreamState state, string outputFileExtension, IServerConfigurationManager serverConfigurationManager, string? deviceId, string? playSessionId)
        {
            var data = $"{state.MediaPath}-{state.UserAgent}-{deviceId!}-{playSessionId!}";

            var filename = data.GetMD5().ToString("N", CultureInfo.InvariantCulture);
            var ext = outputFileExtension?.ToLowerInvariant();
            var folder = serverConfigurationManager.GetTranscodePath();

            return Path.Combine(folder, filename + ext);
        }

        private static void ApplyDeviceProfileSettings(StreamState state, IDlnaManager dlnaManager, IDeviceManager deviceManager, HttpRequest request, string? deviceProfileId, bool? @static)
        {
            var headers = request.Headers;

            if (!string.IsNullOrWhiteSpace(deviceProfileId))
            {
                state.DeviceProfile = dlnaManager.GetProfile(deviceProfileId);
            }
            else if (!string.IsNullOrWhiteSpace(deviceProfileId))
            {
                var caps = deviceManager.GetCapabilities(deviceProfileId);

                state.DeviceProfile = caps == null ? dlnaManager.GetProfile(headers) : caps.DeviceProfile;
            }

            var profile = state.DeviceProfile;

            if (profile == null)
            {
                // Don't use settings from the default profile.
                // Only use a specific profile if it was requested.
                return;
            }

            var audioCodec = state.ActualOutputAudioCodec;
            var videoCodec = state.ActualOutputVideoCodec;

            var mediaProfile = !state.IsVideoRequest
                ? profile.GetAudioMediaProfile(state.OutputContainer, audioCodec, state.OutputAudioChannels, state.OutputAudioBitrate, state.OutputAudioSampleRate, state.OutputAudioBitDepth)
                : profile.GetVideoMediaProfile(
                    state.OutputContainer,
                    audioCodec,
                    videoCodec,
                    state.OutputWidth,
                    state.OutputHeight,
                    state.TargetVideoBitDepth,
                    state.OutputVideoBitrate,
                    state.TargetVideoProfile,
                    state.TargetVideoLevel,
                    state.TargetFramerate,
                    state.TargetPacketLength,
                    state.TargetTimestamp,
                    state.IsTargetAnamorphic,
                    state.IsTargetInterlaced,
                    state.TargetRefFrames,
                    state.TargetVideoStreamCount,
                    state.TargetAudioStreamCount,
                    state.TargetVideoCodecTag,
                    state.IsTargetAVC);

            if (mediaProfile != null)
            {
                state.MimeType = mediaProfile.MimeType;
            }

            if (!(@static.HasValue && @static.Value))
            {
                var transcodingProfile = !state.IsVideoRequest ? profile.GetAudioTranscodingProfile(state.OutputContainer, audioCodec) : profile.GetVideoTranscodingProfile(state.OutputContainer, audioCodec, videoCodec);

                if (transcodingProfile != null)
                {
                    state.EstimateContentLength = transcodingProfile.EstimateContentLength;
                    // state.EnableMpegtsM2TsMode = transcodingProfile.EnableMpegtsM2TsMode;
                    state.TranscodeSeekInfo = transcodingProfile.TranscodeSeekInfo;

                    if (state.VideoRequest != null)
                    {
                        state.VideoRequest.CopyTimestamps = transcodingProfile.CopyTimestamps;
                        state.VideoRequest.EnableSubtitlesInManifest = transcodingProfile.EnableSubtitlesInManifest;
                    }
                }
            }
        }

        /// <summary>
        /// Parses the parameters.
        /// </summary>
        /// <param name="request">The request.</param>
        private static void ParseParams(StreamingRequestDto request)
        {
            if (string.IsNullOrEmpty(request.Params))
            {
                return;
            }

            var vals = request.Params.Split(';');

            var videoRequest = request as VideoRequestDto;

            for (var i = 0; i < vals.Length; i++)
            {
                var val = vals[i];

                if (string.IsNullOrWhiteSpace(val))
                {
                    continue;
                }

                switch (i)
                {
                    case 0:
                        request.DeviceProfileId = val;
                        break;
                    case 1:
                        request.DeviceId = val;
                        break;
                    case 2:
                        request.MediaSourceId = val;
                        break;
                    case 3:
                        request.Static = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        break;
                    case 4:
                        if (videoRequest != null)
                        {
                            videoRequest.VideoCodec = val;
                        }

                        break;
                    case 5:
                        request.AudioCodec = val;
                        break;
                    case 6:
                        if (videoRequest != null)
                        {
                            videoRequest.AudioStreamIndex = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 7:
                        if (videoRequest != null)
                        {
                            videoRequest.SubtitleStreamIndex = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 8:
                        if (videoRequest != null)
                        {
                            videoRequest.VideoBitRate = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 9:
                        request.AudioBitRate = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 10:
                        request.MaxAudioChannels = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 11:
                        if (videoRequest != null)
                        {
                            videoRequest.MaxFramerate = float.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 12:
                        if (videoRequest != null)
                        {
                            videoRequest.MaxWidth = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 13:
                        if (videoRequest != null)
                        {
                            videoRequest.MaxHeight = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 14:
                        request.StartTimeTicks = long.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 15:
                        if (videoRequest != null)
                        {
                            videoRequest.Level = val;
                        }

                        break;
                    case 16:
                        if (videoRequest != null)
                        {
                            videoRequest.MaxRefFrames = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 17:
                        if (videoRequest != null)
                        {
                            videoRequest.MaxVideoBitDepth = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 18:
                        if (videoRequest != null)
                        {
                            videoRequest.Profile = val;
                        }

                        break;
                    case 19:
                        // cabac no longer used
                        break;
                    case 20:
                        request.PlaySessionId = val;
                        break;
                    case 21:
                        // api_key
                        break;
                    case 22:
                        request.LiveStreamId = val;
                        break;
                    case 23:
                        // Duplicating ItemId because of MediaMonkey
                        break;
                    case 24:
                        if (videoRequest != null)
                        {
                            videoRequest.CopyTimestamps = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 25:
                        if (!string.IsNullOrWhiteSpace(val) && videoRequest != null)
                        {
                            if (Enum.TryParse(val, out SubtitleDeliveryMethod method))
                            {
                                videoRequest.SubtitleMethod = method;
                            }
                        }

                        break;
                    case 26:
                        request.TranscodingMaxAudioChannels = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 27:
                        if (videoRequest != null)
                        {
                            videoRequest.EnableSubtitlesInManifest = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 28:
                        request.Tag = val;
                        break;
                    case 29:
                        if (videoRequest != null)
                        {
                            videoRequest.RequireAvc = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 30:
                        request.SubtitleCodec = val;
                        break;
                    case 31:
                        if (videoRequest != null)
                        {
                            videoRequest.RequireNonAnamorphic = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 32:
                        if (videoRequest != null)
                        {
                            videoRequest.DeInterlace = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 33:
                        request.TranscodeReasons = val;
                        break;
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Jellyfin.Api.Models.StreamingDtos;
using MediaBrowser.Common.Configuration;
using MediaBrowser.Common.Extensions;
using MediaBrowser.Controller.Configuration;
using MediaBrowser.Controller.Devices;
using MediaBrowser.Controller.Dlna;
using MediaBrowser.Controller.Library;
using MediaBrowser.Controller.MediaEncoding;
using MediaBrowser.Controller.Net;
using MediaBrowser.Model.Dlna;
using MediaBrowser.Model.Dto;
using MediaBrowser.Model.Entities;
using MediaBrowser.Model.IO;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Primitives;
using Microsoft.Net.Http.Headers;

namespace Jellyfin.Api.Helpers
{
    /// <summary>
    /// The streaming helpers.
    /// </summary>
    public static class StreamingHelpers
    {
        /// <summary>
        /// Gets the current streaming state.
        /// </summary>
        /// <param name="streamingRequest">The <see cref="StreamingRequestDto"/>.</param>
        /// <param name="httpRequest">The <see cref="HttpRequest"/>.</param>
        /// <param name="authorizationContext">Instance of the <see cref="IAuthorizationContext"/> interface.</param>
        /// <param name="mediaSourceManager">Instance of the <see cref="IMediaSourceManager"/> interface.</param>
        /// <param name="userManager">Instance of the <see cref="IUserManager"/> interface.</param>
        /// <param name="libraryManager">Instance of the <see cref="ILibraryManager"/> interface.</param>
        /// <param name="serverConfigurationManager">Instance of the <see cref="IServerConfigurationManager"/> interface.</param>
        /// <param name="mediaEncoder">Instance of the <see cref="IMediaEncoder"/> interface.</param>
        /// <param name="fileSystem">Instance of the <see cref="IFileSystem"/> interface.</param>
        /// <param name="subtitleEncoder">Instance of the <see cref="ISubtitleEncoder"/> interface.</param>
        /// <param name="configuration">Instance of the <see cref="IConfiguration"/> interface.</param>
        /// <param name="dlnaManager">Instance of the <see cref="IDlnaManager"/> interface.</param>
        /// <param name="deviceManager">Instance of the <see cref="IDeviceManager"/> interface.</param>
        /// <param name="transcodingJobHelper">Initialized <see cref="TranscodingJobHelper"/>.</param>
        /// <param name="transcodingJobType">The <see cref="TranscodingJobType"/>.</param>
        /// <param name="cancellationToken">The <see cref="CancellationToken"/>.</param>
        /// <returns>A <see cref="Task"/> containing the current <see cref="StreamState"/>.</returns>
        public static async Task<StreamState> GetStreamingState(
            StreamingRequestDto streamingRequest,
            HttpRequest httpRequest,
            IAuthorizationContext authorizationContext,
            IMediaSourceManager mediaSourceManager,
            IUserManager userManager,
            ILibraryManager libraryManager,
            IServerConfigurationManager serverConfigurationManager,
            IMediaEncoder mediaEncoder,
            IFileSystem fileSystem,
            ISubtitleEncoder subtitleEncoder,
            IConfiguration configuration,
            IDlnaManager dlnaManager,
            IDeviceManager deviceManager,
            TranscodingJobHelper transcodingJobHelper,
            TranscodingJobType transcodingJobType,
            CancellationToken cancellationToken)
        {
            EncodingHelper encodingHelper = new EncodingHelper(mediaEncoder, fileSystem, subtitleEncoder, configuration);
            // Parse the DLNA time seek header
            if (!streamingRequest.StartTimeTicks.HasValue)
            {
                var timeSeek = httpRequest.Headers["TimeSeekRange.dlna.org"];

                streamingRequest.StartTimeTicks = ParseTimeSeekHeader(timeSeek.ToString());
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.Params))
            {
                ParseParams(streamingRequest);
            }

            streamingRequest.StreamOptions = ParseStreamOptions(httpRequest.Query);
            if (httpRequest.Path.Value == null)
            {
                throw new ResourceNotFoundException(nameof(httpRequest.Path));
            }

            var url = httpRequest.Path.Value.Split('.')[^1];

            if (string.IsNullOrEmpty(streamingRequest.AudioCodec))
            {
                streamingRequest.AudioCodec = encodingHelper.InferAudioCodec(url);
            }

            var enableDlnaHeaders = !string.IsNullOrWhiteSpace(streamingRequest.Params) ||
                                    string.Equals(httpRequest.Headers["GetContentFeatures.DLNA.ORG"], "1", StringComparison.OrdinalIgnoreCase);

            var state = new StreamState(mediaSourceManager, transcodingJobType, transcodingJobHelper)
            {
                Request = streamingRequest,
                RequestedUrl = url,
                UserAgent = httpRequest.Headers[HeaderNames.UserAgent],
                EnableDlnaHeaders = enableDlnaHeaders
            };

            var auth = authorizationContext.GetAuthorizationInfo(httpRequest);
            if (!auth.UserId.Equals(Guid.Empty))
            {
                state.User = userManager.GetUserById(auth.UserId);
            }

            if (state.IsVideoRequest && !string.IsNullOrWhiteSpace(state.Request.VideoCodec))
            {
                state.SupportedVideoCodecs = state.Request.VideoCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.VideoCodec = state.SupportedVideoCodecs.FirstOrDefault();
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.AudioCodec))
            {
                state.SupportedAudioCodecs = streamingRequest.AudioCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.AudioCodec = state.SupportedAudioCodecs.FirstOrDefault(i => mediaEncoder.CanEncodeToAudioCodec(i))
                                           ?? state.SupportedAudioCodecs.FirstOrDefault();
            }

            if (!string.IsNullOrWhiteSpace(streamingRequest.SubtitleCodec))
            {
                state.SupportedSubtitleCodecs = streamingRequest.SubtitleCodec.Split(',', StringSplitOptions.RemoveEmptyEntries);
                state.Request.SubtitleCodec = state.SupportedSubtitleCodecs.FirstOrDefault(i => mediaEncoder.CanEncodeToSubtitleCodec(i))
                                              ?? state.SupportedSubtitleCodecs.FirstOrDefault();
            }

            var item = libraryManager.GetItemById(streamingRequest.Id);

            state.IsInputVideo = string.Equals(item.MediaType, MediaType.Video, StringComparison.OrdinalIgnoreCase);

            MediaSourceInfo? mediaSource = null;
            if (string.IsNullOrWhiteSpace(streamingRequest.LiveStreamId))
            {
                var currentJob = !string.IsNullOrWhiteSpace(streamingRequest.PlaySessionId)
                    ? transcodingJobHelper.GetTranscodingJob(streamingRequest.PlaySessionId)
                    : null;

                if (currentJob != null)
                {
                    mediaSource = currentJob.MediaSource;
                }

                if (mediaSource == null)
                {
                    var mediaSources = await mediaSourceManager.GetPlaybackMediaSources(libraryManager.GetItemById(streamingRequest.Id), null, false, false, cancellationToken).ConfigureAwait(false);

                    mediaSource = string.IsNullOrEmpty(streamingRequest.MediaSourceId)
                        ? mediaSources[0]
                        : mediaSources.Find(i => string.Equals(i.Id, streamingRequest.MediaSourceId, StringComparison.InvariantCulture));

                    if (mediaSource == null && Guid.Parse(streamingRequest.MediaSourceId) == streamingRequest.Id)
                    {
                        mediaSource = mediaSources[0];
                    }
                }
            }
            else
            {
                var liveStreamInfo = await mediaSourceManager.GetLiveStreamWithDirectStreamProvider(streamingRequest.LiveStreamId, cancellationToken).ConfigureAwait(false);
                mediaSource = liveStreamInfo.Item1;
                state.DirectStreamProvider = liveStreamInfo.Item2;
            }

            var encodingOptions = serverConfigurationManager.GetEncodingOptions();

            encodingHelper.AttachMediaSourceInfo(state, encodingOptions, mediaSource, url);

            string? containerInternal = Path.GetExtension(state.RequestedUrl);

            if (!string.IsNullOrEmpty(streamingRequest.Container))
            {
                containerInternal = streamingRequest.Container;
            }

            if (string.IsNullOrEmpty(containerInternal))
            {
                containerInternal = streamingRequest.Static ?
                    StreamBuilder.NormalizeMediaSourceFormatIntoSingleContainer(state.InputContainer, null, DlnaProfileType.Audio)
                    : GetOutputFileExtension(state);
            }

            state.OutputContainer = (containerInternal ?? string.Empty).TrimStart('.');

            state.OutputAudioBitrate = encodingHelper.GetAudioBitrateParam(streamingRequest.AudioBitRate, streamingRequest.AudioCodec, state.AudioStream);

            state.OutputAudioCodec = streamingRequest.AudioCodec;

            state.OutputAudioChannels = encodingHelper.GetNumAudioChannelsParam(state, state.AudioStream, state.OutputAudioCodec);

            if (state.VideoRequest != null)
            {
                state.OutputVideoCodec = state.Request.VideoCodec;
                state.OutputVideoBitrate = encodingHelper.GetVideoBitrateParamValue(state.VideoRequest, state.VideoStream, state.OutputVideoCodec);

                encodingHelper.TryStreamCopy(state);

                if (!EncodingHelper.IsCopyCodec(state.OutputVideoCodec) && state.OutputVideoBitrate.HasValue)
                {
                    var isVideoResolutionNotRequested = !state.VideoRequest.Width.HasValue
                        && !state.VideoRequest.Height.HasValue
                        && !state.VideoRequest.MaxWidth.HasValue
                        && !state.VideoRequest.MaxHeight.HasValue;

                    if (isVideoResolutionNotRequested
                        && state.VideoStream != null
                        && state.VideoRequest.VideoBitRate.HasValue
                        && state.VideoStream.BitRate.HasValue
                        && state.VideoRequest.VideoBitRate.Value >= state.VideoStream.BitRate.Value)
                    {
                        // Don't downscale the resolution if the width/height/MaxWidth/MaxHeight is not requested,
                        // and the requested video bitrate is higher than source video bitrate.
                        if (state.VideoStream.Width.HasValue || state.VideoStream.Height.HasValue)
                        {
                            state.VideoRequest.MaxWidth = state.VideoStream?.Width;
                            state.VideoRequest.MaxHeight = state.VideoStream?.Height;
                        }
                    }
                    else
                    {
                        var resolution = ResolutionNormalizer.Normalize(
                            state.VideoStream?.BitRate,
                            state.VideoStream?.Width,
                            state.VideoStream?.Height,
                            state.OutputVideoBitrate.Value,
                            state.VideoStream?.Codec,
                            state.OutputVideoCodec,
                            state.VideoRequest.MaxWidth,
                            state.VideoRequest.MaxHeight);

                        state.VideoRequest.MaxWidth = resolution.MaxWidth;
                        state.VideoRequest.MaxHeight = resolution.MaxHeight;
                    }
                }
            }

            ApplyDeviceProfileSettings(state, dlnaManager, deviceManager, httpRequest, streamingRequest.DeviceProfileId, streamingRequest.Static);

            var ext = string.IsNullOrWhiteSpace(state.OutputContainer)
                ? GetOutputFileExtension(state)
                : ("." + state.OutputContainer);

            state.OutputFilePath = GetOutputFilePath(state, ext!, serverConfigurationManager, streamingRequest.DeviceId, streamingRequest.PlaySessionId);

            return state;
        }

        /// <summary>
        /// Adds the dlna headers.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <param name="responseHeaders">The response headers.</param>
        /// <param name="isStaticallyStreamed">if set to <c>true</c> [is statically streamed].</param>
        /// <param name="startTimeTicks">The start time in ticks.</param>
        /// <param name="request">The <see cref="HttpRequest"/>.</param>
        /// <param name="dlnaManager">Instance of the <see cref="IDlnaManager"/> interface.</param>
        public static void AddDlnaHeaders(
            StreamState state,
            IHeaderDictionary responseHeaders,
            bool isStaticallyStreamed,
            long? startTimeTicks,
            HttpRequest request,
            IDlnaManager dlnaManager)
        {
            if (!state.EnableDlnaHeaders)
            {
                return;
            }

            var profile = state.DeviceProfile;

            StringValues transferMode = request.Headers["transferMode.dlna.org"];
            responseHeaders.Add("transferMode.dlna.org", string.IsNullOrEmpty(transferMode) ? "Streaming" : transferMode.ToString());
            responseHeaders.Add("realTimeInfo.dlna.org", "DLNA.ORG_TLAG=*");

            if (state.RunTimeTicks.HasValue)
            {
                if (string.Equals(request.Headers["getMediaInfo.sec"], "1", StringComparison.OrdinalIgnoreCase))
                {
                    var ms = TimeSpan.FromTicks(state.RunTimeTicks.Value).TotalMilliseconds;
                    responseHeaders.Add("MediaInfo.sec", string.Format(
                        CultureInfo.InvariantCulture,
                        "SEC_Duration={0};",
                        Convert.ToInt32(ms)));
                }

                if (!isStaticallyStreamed && profile != null)
                {
                    AddTimeSeekResponseHeaders(state, responseHeaders, startTimeTicks);
                }
            }

            if (profile == null)
            {
                profile = dlnaManager.GetDefaultProfile();
            }

            var audioCodec = state.ActualOutputAudioCodec;

            if (!state.IsVideoRequest)
            {
                responseHeaders.Add("contentFeatures.dlna.org", new ContentFeatureBuilder(profile).BuildAudioHeader(
                    state.OutputContainer,
                    audioCodec,
                    state.OutputAudioBitrate,
                    state.OutputAudioSampleRate,
                    state.OutputAudioChannels,
                    state.OutputAudioBitDepth,
                    isStaticallyStreamed,
                    state.RunTimeTicks,
                    state.TranscodeSeekInfo));
            }
            else
            {
                var videoCodec = state.ActualOutputVideoCodec;

                responseHeaders.Add(
                    "contentFeatures.dlna.org",
                    new ContentFeatureBuilder(profile).BuildVideoHeader(state.OutputContainer, videoCodec, audioCodec, state.OutputWidth, state.OutputHeight, state.TargetVideoBitDepth, state.OutputVideoBitrate, state.TargetTimestamp, isStaticallyStreamed, state.RunTimeTicks, state.TargetVideoProfile, state.TargetVideoLevel, state.TargetFramerate, state.TargetPacketLength, state.TranscodeSeekInfo, state.IsTargetAnamorphic, state.IsTargetInterlaced, state.TargetRefFrames, state.TargetVideoStreamCount, state.TargetAudioStreamCount, state.TargetVideoCodecTag, state.IsTargetAVC).FirstOrDefault() ?? string.Empty);
            }
        }

        /// <summary>
        /// Parses the time seek header.
        /// </summary>
        /// <param name="value">The time seek header string.</param>
        /// <returns>A nullable <see cref="long"/> representing the seek time in ticks.</returns>
        private static long? ParseTimeSeekHeader(ReadOnlySpan<char> value)
        {
            if (value.IsEmpty)
            {
                return null;
            }

            const string npt = "npt=";
            if (!value.StartsWith(npt, StringComparison.OrdinalIgnoreCase))
            {
                throw new ArgumentException("Invalid timeseek header");
            }

            var index = value.IndexOf('-');
            value = index == -1
                ? value.Slice(npt.Length)
                : value.Slice(npt.Length, index - npt.Length);
            if (value.IndexOf(':') == -1)
            {
                // Parses npt times in the format of '417.33'
                if (double.TryParse(value, NumberStyles.Any, CultureInfo.InvariantCulture, out var seconds))
                {
                    return TimeSpan.FromSeconds(seconds).Ticks;
                }

                throw new ArgumentException("Invalid timeseek header");
            }

            try
            {
                // Parses npt times in the format of '10:19:25.7'
                return TimeSpan.Parse(value).Ticks;
            }
            catch
            {
                throw new ArgumentException("Invalid timeseek header");
            }
        }

        /// <summary>
        /// Parses query parameters as StreamOptions.
        /// </summary>
        /// <param name="queryString">The query string.</param>
        /// <returns>A <see cref="Dictionary{String,String}"/> containing the stream options.</returns>
        private static Dictionary<string, string> ParseStreamOptions(IQueryCollection queryString)
        {
            Dictionary<string, string> streamOptions = new Dictionary<string, string>();
            foreach (var param in queryString)
            {
                if (char.IsLower(param.Key[0]))
                {
                    // This was probably not parsed initially and should be a StreamOptions
                    // or the generated URL should correctly serialize it
                    // TODO: This should be incorporated either in the lower framework for parsing requests
                    streamOptions[param.Key] = param.Value;
                }
            }

            return streamOptions;
        }

        /// <summary>
        /// Adds the dlna time seek headers to the response.
        /// </summary>
        /// <param name="state">The current <see cref="StreamState"/>.</param>
        /// <param name="responseHeaders">The <see cref="IHeaderDictionary"/> of the response.</param>
        /// <param name="startTimeTicks">The start time in ticks.</param>
        private static void AddTimeSeekResponseHeaders(StreamState state, IHeaderDictionary responseHeaders, long? startTimeTicks)
        {
            var runtimeSeconds = TimeSpan.FromTicks(state.RunTimeTicks!.Value).TotalSeconds.ToString(CultureInfo.InvariantCulture);
            var startSeconds = TimeSpan.FromTicks(startTimeTicks ?? 0).TotalSeconds.ToString(CultureInfo.InvariantCulture);

            responseHeaders.Add("TimeSeekRange.dlna.org", string.Format(
                CultureInfo.InvariantCulture,
                "npt={0}-{1}/{1}",
                startSeconds,
                runtimeSeconds));
            responseHeaders.Add("X-AvailableSeekRange", string.Format(
                CultureInfo.InvariantCulture,
                "1 npt={0}-{1}",
                startSeconds,
                runtimeSeconds));
        }

        /// <summary>
        /// Gets the output file extension.
        /// </summary>
        /// <param name="state">The state.</param>
        /// <returns>System.String.</returns>
        private static string? GetOutputFileExtension(StreamState state)
        {
            var ext = Path.GetExtension(state.RequestedUrl);

            if (!string.IsNullOrEmpty(ext))
            {
                return ext;
            }

            // Try to infer based on the desired video codec
            if (state.IsVideoRequest)
            {
                var videoCodec = state.Request.VideoCodec;

                if (string.Equals(videoCodec, "h264", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(videoCodec, "h265", StringComparison.OrdinalIgnoreCase))
                {
                    return ".ts";
                }

                if (string.Equals(videoCodec, "theora", StringComparison.OrdinalIgnoreCase))
                {
                    return ".ogv";
                }

                if (string.Equals(videoCodec, "vpx", StringComparison.OrdinalIgnoreCase))
                {
                    return ".webm";
                }

                if (string.Equals(videoCodec, "wmv", StringComparison.OrdinalIgnoreCase))
                {
                    return ".asf";
                }
            }

            // Try to infer based on the desired audio codec
            if (!state.IsVideoRequest)
            {
                var audioCodec = state.Request.AudioCodec;

                if (string.Equals("aac", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".aac";
                }

                if (string.Equals("mp3", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".mp3";
                }

                if (string.Equals("vorbis", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".ogg";
                }

                if (string.Equals("wma", audioCodec, StringComparison.OrdinalIgnoreCase))
                {
                    return ".wma";
                }
            }

            return null;
        }

        /// <summary>
        /// Gets the output file path for transcoding.
        /// </summary>
        /// <param name="state">The current <see cref="StreamState"/>.</param>
        /// <param name="outputFileExtension">The file extension of the output file.</param>
        /// <param name="serverConfigurationManager">Instance of the <see cref="IServerConfigurationManager"/> interface.</param>
        /// <param name="deviceId">The device id.</param>
        /// <param name="playSessionId">The play session id.</param>
        /// <returns>The complete file path, including the folder, for the transcoding file.</returns>
        private static string GetOutputFilePath(StreamState state, string outputFileExtension, IServerConfigurationManager serverConfigurationManager, string? deviceId, string? playSessionId)
        {
            var data = $"{state.MediaPath}-{state.UserAgent}-{deviceId!}-{playSessionId!}";

            var filename = data.GetMD5().ToString("N", CultureInfo.InvariantCulture);
            var ext = outputFileExtension?.ToLowerInvariant();
            var folder = serverConfigurationManager.GetTranscodePath();

            return Path.Combine(folder, filename + ext);
        }

        private static void ApplyDeviceProfileSettings(StreamState state, IDlnaManager dlnaManager, IDeviceManager deviceManager, HttpRequest request, string? deviceProfileId, bool? @static)
        {
            var headers = request.Headers;

            if (!string.IsNullOrWhiteSpace(deviceProfileId))
            {
                state.DeviceProfile = dlnaManager.GetProfile(deviceProfileId);
            }
            else if (!string.IsNullOrWhiteSpace(deviceProfileId))
            {
                var caps = deviceManager.GetCapabilities(deviceProfileId);

                state.DeviceProfile = caps == null ? dlnaManager.GetProfile(headers) : caps.DeviceProfile;
            }

            var profile = state.DeviceProfile;

            if (profile == null)
            {
                // Don't use settings from the default profile.
                // Only use a specific profile if it was requested.
                return;
            }

            var audioCodec = state.ActualOutputAudioCodec;
            var videoCodec = state.ActualOutputVideoCodec;

            var mediaProfile = !state.IsVideoRequest
                ? profile.GetAudioMediaProfile(state.OutputContainer, audioCodec, state.OutputAudioChannels, state.OutputAudioBitrate, state.OutputAudioSampleRate, state.OutputAudioBitDepth)
                : profile.GetVideoMediaProfile(
                    state.OutputContainer,
                    audioCodec,
                    videoCodec,
                    state.OutputWidth,
                    state.OutputHeight,
                    state.TargetVideoBitDepth,
                    state.OutputVideoBitrate,
                    state.TargetVideoProfile,
                    state.TargetVideoLevel,
                    state.TargetFramerate,
                    state.TargetPacketLength,
                    state.TargetTimestamp,
                    state.IsTargetAnamorphic,
                    state.IsTargetInterlaced,
                    state.TargetRefFrames,
                    state.TargetVideoStreamCount,
                    state.TargetAudioStreamCount,
                    state.TargetVideoCodecTag,
                    state.IsTargetAVC);

            if (mediaProfile != null)
            {
                state.MimeType = mediaProfile.MimeType;
            }

            if (!(@static.HasValue && @static.Value))
            {
                var transcodingProfile = !state.IsVideoRequest ? profile.GetAudioTranscodingProfile(state.OutputContainer, audioCodec) : profile.GetVideoTranscodingProfile(state.OutputContainer, audioCodec, videoCodec);

                if (transcodingProfile != null)
                {
                    state.EstimateContentLength = transcodingProfile.EstimateContentLength;
                    // state.EnableMpegtsM2TsMode = transcodingProfile.EnableMpegtsM2TsMode;
                    state.TranscodeSeekInfo = transcodingProfile.TranscodeSeekInfo;

                    if (state.VideoRequest != null)
                    {
                        state.VideoRequest.CopyTimestamps = transcodingProfile.CopyTimestamps;
                        state.VideoRequest.EnableSubtitlesInManifest = transcodingProfile.EnableSubtitlesInManifest;
                    }
                }
            }
        }

        /// <summary>
        /// Parses the parameters.
        /// </summary>
        /// <param name="request">The request.</param>
        private static void ParseParams(StreamingRequestDto request)
        {
            if (string.IsNullOrEmpty(request.Params))
            {
                return;
            }

            var vals = request.Params.Split(';');

            for (var i = 0; i < vals.Length; i++)
            {
                var val = vals[i];

                if (string.IsNullOrWhiteSpace(val))
                {
                    continue;
                }

                switch (i)
                {
                    case 0:
                        request.DeviceProfileId = val;
                        break;
                    case 1:
                        request.DeviceId = val;
                        break;
                    case 2:
                        request.MediaSourceId = val;
                        break;
                    case 3:
                        request.Static = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        break;
                    case 4:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.VideoCodec = val;
                        }

                        break;
                    case 5:
                        request.AudioCodec = val;
                        break;
                    case 6:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.AudioStreamIndex = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 7:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.SubtitleStreamIndex = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 8:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.VideoBitRate = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 9:
                        request.AudioBitRate = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 10:
                        request.MaxAudioChannels = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 11:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.MaxFramerate = float.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 12:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.MaxWidth = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 13:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.MaxHeight = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 14:
                        request.StartTimeTicks = long.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 15:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.Level = val;
                        }

                        break;
                    case 16:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.MaxRefFrames = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 17:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.MaxVideoBitDepth = int.Parse(val, CultureInfo.InvariantCulture);
                        }

                        break;
                    case 18:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.Profile = val;
                        }

                        break;
                    case 19:
                        // cabac no longer used
                        break;
                    case 20:
                        request.PlaySessionId = val;
                        break;
                    case 21:
                        // api_key
                        break;
                    case 22:
                        request.LiveStreamId = val;
                        break;
                    case 23:
                        // Duplicating ItemId because of MediaMonkey
                        break;
                    case 24:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.CopyTimestamps = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 25:

                        if (!string.IsNullOrWhiteSpace(val) && request is VideoRequestDto videoRequest)
                        {
                            if (Enum.TryParse(val, out SubtitleDeliveryMethod method))
                            {
                                videoRequest.SubtitleMethod = method;
                            }
                        }

                        break;
                    case 26:
                        request.TranscodingMaxAudioChannels = int.Parse(val, CultureInfo.InvariantCulture);
                        break;
                    case 27:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.EnableSubtitlesInManifest = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 28:
                        request.Tag = val;
                        break;
                    case 29:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.RequireAvc = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 30:
                        request.SubtitleCodec = val;
                        break;
                    case 31:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.RequireNonAnamorphic = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 32:

                        if (request is VideoRequestDto videoRequest)
                        {
                            videoRequest.DeInterlace = string.Equals("true", val, StringComparison.OrdinalIgnoreCase);
                        }

                        break;
                    case 33:
                        request.TranscodeReasons = val;
                        break;
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(632,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(640,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(648,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(662,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(670,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(678,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(689,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(697,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(705,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(713,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(736,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(744,91): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(758,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(769,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(780,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(788,56): error CS0128: A local variable or function named 'videoRequest' is already defined in this scope,D:\a\1\s\Jellyfin.Api\Helpers\StreamingHelpers.cs(634,29): error CS0165: Use of unassigned local variable 'videoRequest'
######################################################################


