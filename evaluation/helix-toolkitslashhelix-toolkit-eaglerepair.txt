Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: HelixToolkit.Wpf.Tests
    #1 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Tests\CrossThreadTestRunner.cs, Line: 68, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #2 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Tests\Exporters\ExporterTests.cs, Line: 137, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: HelixToolkit.Wpf
    #3 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 747, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #6 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 803, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\CameraSetting.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\CameraSetting.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\ZoomHandler.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3738, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3790, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3930, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3973, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 456, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 464, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 472, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 483, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\Exporter.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\Exporter.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 895, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 902, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 913, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 944, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #28 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 182, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 194, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 207, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #32 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 243, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 304, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 351, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 398, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #39 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 415, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 418, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 421, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\XamlExporter.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #43 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #44 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 194, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 297, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 303, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #52 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 309, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #53 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 380, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 387, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 424, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 430, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 495, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 501, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 548, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #61 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 582, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 660, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 667, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #64 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 741, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 748, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 797, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 804, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #68 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 830, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 849, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #70 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 899, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #71 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 918, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #72 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #73 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 217, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #77 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #78 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 255, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #80 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 42, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #82 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #83 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #84 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 44, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #86 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #87 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #89 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1231, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #90 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 316, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 961, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #93 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 247, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 360, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 408, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 440, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #100 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 455, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #101 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #102 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\XamlHelper.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 455, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 555, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 568, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #109 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #110 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\ViewCubeVisual3D.cs, Line: 746, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #112 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 149, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 146, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: HelixToolkit.Wpf.SharpDX
    #118 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #119 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #120 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 747, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #121 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 803, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs, Line: 116, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #123 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs, Line: 142, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #124 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs, Line: 105, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #125 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\PointBufferModel.cs, Line: 102, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #126 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\SkyBoxRenderCore.cs, Line: 275, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #127 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs, Line: 215, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #128 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #129 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs, Line: 258, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #130 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\SceneNode.cs, Line: 977, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #131 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs, Line: 310, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #132 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs, Line: 277, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #133 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs, Line: 458, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #135 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #136 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #137 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelFormat.cs, Line: 777, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #138 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ShaderResourceViewSelector.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #139 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 162, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 188, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #141 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #142 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 582, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #143 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 592, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #144 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 601, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #145 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #146 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #147 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs, Line: 206, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #148 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #149 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #150 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #151 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #152 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\DisposeObject.cs, Line: 103, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #153 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\DisposeObject.cs, Line: 276, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #154 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 535, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #155 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 612, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #156 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 637, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #157 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 648, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #158 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 745, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #159 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Controls\MouseHandlers\VirtualTouchDevice.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #160 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Controls\WinformHostExtend.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #161 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Model\Elements3D\AbstractElements3D\Element3D.cs, Line: 250, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #162 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\Exporter.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #163 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 135, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #164 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 169, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #166 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 174, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #167 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #168 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 242, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 254, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #172 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 276, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #173 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #174 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #175 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 303, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #176 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 320, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #177 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 327, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #178 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 349, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #179 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 363, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #180 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 380, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #181 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #182 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 386, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #183 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 406, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #184 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #186 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #187 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #188 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #189 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 351, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #190 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 366, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #191 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 426, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #192 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 442, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #193 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 475, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #194 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 478, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #195 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 513, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 513, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #197 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: HelixToolkit.SharpDX.Core(netcoreapp2.1)
    #199 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 747, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #200 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 803, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #201 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs, Line: 116, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #202 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\LineBufferModel.cs, Line: 142, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #203 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\MeshBufferModel.cs, Line: 105, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #204 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\Buffers\PointBufferModel.cs, Line: 102, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #205 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\SkyBoxRenderCore.cs, Line: 275, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #206 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Core\VolumeRenderCore.cs, Line: 215, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #207 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Extensions\IViewportExtensions.cs, Line: 394, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #208 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #209 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Geometry\BillboardBase.cs, Line: 258, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #210 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Model\Scene\Abstract\SceneNode.cs, Line: 977, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #211 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DDSHelper.cs, Line: 310, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #212 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\DepthStencilBuffer.cs, Line: 277, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #213 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Image.cs, Line: 458, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #214 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ImageDescription.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #215 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #216 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelBuffer.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #217 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\PixelFormat.cs, Line: 777, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #218 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\ShaderResourceViewSelector.cs, Line: 36, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #219 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 162, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #220 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 188, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #221 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #222 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 582, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #223 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 592, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #224 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture.cs, Line: 601, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #225 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture1D.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #226 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture2D.cs, Line: 200, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #227 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\Texture3D.cs, Line: 206, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #228 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureCube.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #229 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #230 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #231 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\SharpDX.Toolkit\Graphics\TextureView.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\DisposeObject.cs, Line: 103, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #233 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\DisposeObject.cs, Line: 276, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #234 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 535, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #235 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 612, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #236 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 637, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #237 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 648, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #238 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Shared\Utilities\ImportExport\ObjReader.cs, Line: 745, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: ExampleBrowser
    #239 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\ExampleBrowser\MainWindow.xaml.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\ExampleBrowser\MainWindow.xaml.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #241 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Audio\NAudioWpfDemo\AudioCapture.cs, Line: 104, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #242 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Audio\NAudioWpfDemo\AudioCapture.cs, Line: 129, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #243 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Audio\NAudioWpfDemo\AudioPlayback.cs, Line: 126, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #244 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Audio\NAudioWpfDemo\ControlPanelViewModel.cs, Line: 145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #245 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Audio\NAudioWpfDemo\ControlPanelViewModel.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #246 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\BuildingDemo\BoundsConverter.cs, Line: 22, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #247 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 170, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #248 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 177, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #249 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 268, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #250 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 330, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DataTemplate3D.cs, Line: 353, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #253 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DefaultDataTemplateSelctor3D.cs, Line: 10, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #254 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\DefaultDataTemplateSelctor3D.cs, Line: 18, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #255 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\ItemsVisual3D.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #256 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\DataTemplate\ItemsVisual3D.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #257 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Export\OctaneLauncher.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #259 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #260 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 167, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #263 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\ExtrudedText\Extensions.cs, Line: 196, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #264 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\Airport.cs, Line: 22, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #265 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\FlightVisual3D.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #266 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\FlightVisual3D.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #267 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\FlightVisual3D.cs, Line: 52, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #268 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\MainWindow.xaml.cs, Line: 193, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Flights\MainWindow.xaml.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #270 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\HalfEdgeMesh\HalfEdgeMesh.cs, Line: 333, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #271 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\HalfEdgeMesh\HalfEdgeMesh.cs, Line: 453, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #272 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\HalfEdgeMesh\HalfEdgeMesh.cs, Line: 576, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #273 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\RectSelection\MainWindow.xaml.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #274 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\RectSelection\MainWindow.xaml.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #275 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Examples\Subdivision\MainWindow.xaml.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #276 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\MainWindow.xaml.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #277 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\MainWindow.xaml.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #278 Path: D:\a\1\s\Source\Examples\WPF\ExampleBrowser\Workitems\Workitem10046\FaceTheCameraBillboard.cs, Line: 283, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: SurfaceDemo
    #279 Path: D:\a\1\s\Source\Examples\WPF\SurfaceDemo\Window1.xaml.cs, Line: 142, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #280 Path: D:\a\1\s\Source\Examples\WPF\SurfaceDemo\Window1.xaml.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: BoneSkinDemo
    #281 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\BoneSkinDemo\MainViewModel.cs, Line: 89, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



Project: FileLoadDemo
    #282 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\FileLoadDemo\MainViewModel.cs, Line: 326, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: MemoryLeakTester
    #283 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\MemoryLeakTester\MainWindow.xaml.cs, Line: 108, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: MouseDragDemo
    #284 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\MouseDragDemo\InteractionHandle3D.cs, Line: 362, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: PolygonTriangulationDemo
    #285 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\PolygonTriangulationDemo\MainWindow.xaml.cs, Line: 143, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: SimpleDemo
    #286 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #287 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #288 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #289 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 183, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #290 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 196, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\Source\Examples\WPF.SharpDX\SimpleDemo\Extensions.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: HelixToolkit.SharpDX.Core.Assimp(netcoreapp2.1)
    #292 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Assimp.Shared\ImporterPartial_Animation.cs, Line: 176, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: HelixToolkit.Wpf.SharpDX.Assimp
    #293 Path: D:\a\1\s\Source\HelixToolkit.SharpDX.Assimp.Shared\ImporterPartial_Animation.cs, Line: 176, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: HelixToolkit.SharpDX.Core.Wpf
    #294 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Controls\MouseHandlers\VirtualTouchDevice.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #295 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Controls\WinformHostExtend.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #296 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Model\Elements3D\AbstractElements3D\Element3D.cs, Line: 250, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\Exporter.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #298 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 135, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #299 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #300 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 169, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #301 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 174, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #302 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #303 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #304 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 242, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #305 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 254, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #306 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #307 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 276, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #308 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 281, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #309 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #310 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 303, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #311 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 320, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #312 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 327, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #313 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 349, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #314 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 363, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 380, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #316 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #317 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 386, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #318 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs, Line: 406, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #319 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 123, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #320 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #322 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #324 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 351, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #325 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 366, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 426, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #327 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 442, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #328 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 475, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #329 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 478, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #330 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 513, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #331 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 513, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #332 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #333 Path: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: HelixToolkit.Core.Wpf
    #334 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #335 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshBuilder.cs, Line: 4116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #336 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 747, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #337 Path: D:\a\1\s\Source\HelixToolkit.Shared\Geometry\MeshGeometryHelper.cs, Line: 803, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #338 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\CameraSetting.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #339 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\CameraSetting.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\CameraController\ZoomHandler.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #341 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #342 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3738, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #343 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3790, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #344 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3930, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #345 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\HelixViewport3D.cs, Line: 3973, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #346 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #347 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #348 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 456, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #349 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 464, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #350 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 472, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #351 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ColladaExporter.cs, Line: 483, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #352 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\Exporter.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\Exporter.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #354 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #355 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 895, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #356 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 902, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #357 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 913, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #358 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs, Line: 944, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #359 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 182, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #360 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 194, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #361 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 207, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #362 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #363 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #364 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #365 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 243, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #366 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 304, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #367 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 351, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #368 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 383, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #369 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 398, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #370 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 415, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #371 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 418, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #372 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs, Line: 421, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #373 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\XamlExporter.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #375 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #376 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 176, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #377 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 185, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #378 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 188, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #379 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 194, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #380 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #381 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 297, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #382 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 303, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #383 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 309, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #384 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 380, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #385 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 387, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #386 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 424, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #387 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 430, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #388 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 495, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #389 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 501, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #390 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 548, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #391 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #392 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 582, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #393 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 660, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #394 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 667, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #395 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 741, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #396 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 748, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #397 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 797, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #398 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 804, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #399 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 830, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #400 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 849, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #401 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 899, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #402 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\CameraHelper.cs, Line: 918, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #403 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #404 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #405 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #406 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 217, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\ElementSortingHelper.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 255, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #411 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 33, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #412 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\MaterialHelper.cs, Line: 42, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #413 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 105, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #414 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #415 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #416 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 44, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #417 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Model3DHelper.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #418 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #419 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #420 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 1231, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #421 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #422 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 316, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #423 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Viewport3DHelper.cs, Line: 961, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #424 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #425 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #426 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #427 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 247, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #428 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 360, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #429 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 408, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #430 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 440, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #431 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 455, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #432 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #433 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\Visual3DHelper.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #434 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Helpers\XamlHelper.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #435 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 455, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #436 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 531, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #437 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 555, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #438 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Importers\ObjReader.cs, Line: 568, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #439 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #440 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #441 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\LightVisual3D.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #442 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\ViewCubeVisual3D.cs, Line: 746, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #443 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 149, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #444 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #445 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\GenericHeadLight.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #446 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #448 Path: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\LightSetups\LightSetup.cs, Line: 146, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: CoreWpfTest
    #449 Path: D:\a\1\s\Source\Examples\SharpDX.Core\CoreWpfTest\MainViewModel.cs, Line: 265, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



--- Rules Summary ---
R8: 224
R9: 183
R2: 18
R7: 11
R3: 6
R4: 3
R5: 2
R6: 2

--- Summary ---
Fixed ReSharper issues: 431
Fixed SonarQube issues: 13
Total fixed issues: 449

Finished in: 1 min 6 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.ObjectModel;
    using System.Collections.Specialized;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Base class for controls that use stereo cameras
    /// </summary>
    [ContentProperty("Content")]
    public class StereoControl : ContentControl
    {
        // todo: keyboard shortcut 'x' to change cross/parallel viewing
        /// <summary>
        /// Identifies the <see cref="Camera"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraProperty = DependencyProperty.Register(
            "Camera", typeof(PerspectiveCamera), typeof(StereoControl), new UIPropertyMetadata(null));

        /// <summary>
        /// Identifies the <see cref="CameraRotationMode"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraRotationModeProperty =
            DependencyProperty.Register(
                "CameraRotationMode",
                typeof(CameraRotationMode),
                typeof(StereoControl),
                new UIPropertyMetadata(CameraRotationMode.Turntable));

        /// <summary>
        /// Identifies the <see cref="CopyDirectionVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyDirectionVectorProperty =
            DependencyProperty.Register(
                "CopyDirectionVector",
                typeof(bool),
                typeof(StereoControl),
                new UIPropertyMetadata(true, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CopyUpVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyUpVectorProperty = DependencyProperty.Register(
            "CopyUpVector", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CrossViewing"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CrossViewingProperty = DependencyProperty.Register(
            "CrossViewing", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false));

        /// <summary>
        /// Identifies the <see cref="StereoBase"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty StereoBaseProperty = DependencyProperty.Register(
            "StereoBase", typeof(double), typeof(StereoControl), new UIPropertyMetadata(0.12, StereoViewChanged));

        /// <summary>
        /// Initializes static members of the <see cref="StereoControl"/> class.
        /// </summary>
        static StereoControl()
        {
            DefaultStyleKeyProperty.OverrideMetadata(
                typeof(StereoControl), new FrameworkPropertyMetadata(typeof(StereoControl)));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StereoControl"/> class.
        /// </summary>
        public StereoControl()
        {
            this.Camera = CameraHelper.CreateDefaultCamera();
            this.Camera.Changed += this.CameraChanged;
            this.Children = new ObservableCollection<Visual3D>();
        }

        /*        void StereoControl_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            if (e.Key == Key.X)
            {
                CrossViewing = !CrossViewing;
            }
        }
        */
        /// <summary>
        /// Gets or sets the camera.
        /// </summary>
        /// <value>The camera.</value>
        public PerspectiveCamera Camera
        {
            get
            {
                return (PerspectiveCamera)this.GetValue(CameraProperty);
            }

            set
            {
                this.SetValue(CameraProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the camera rotation mode.
        /// </summary>
        /// <value>The camera rotation mode.</value>
        public CameraRotationMode CameraRotationMode
        {
            get
            {
                return (CameraRotationMode)this.GetValue(CameraRotationModeProperty);
            }

            set
            {
                this.SetValue(CameraRotationModeProperty, value);
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <value>The children.</value>
        public ObservableCollection<Visual3D> Children { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether [copy direction vector].
        /// </summary>
        /// <value><c>true</c> if [copy direction vector]; otherwise, <c>false</c>.</value>
        public bool CopyDirectionVector
        {
            get
            {
                return (bool)this.GetValue(CopyDirectionVectorProperty);
            }

            set
            {
                this.SetValue(CopyDirectionVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether [copy up vector].
        /// </summary>
        /// <value><c>true</c> if [copy up vector]; otherwise, <c>false</c>.</value>
        public bool CopyUpVector
        {
            get
            {
                return (bool)this.GetValue(CopyUpVectorProperty);
            }

            set
            {
                this.SetValue(CopyUpVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the cameras are set up for cross viewing.
        /// </summary>
        /// <value><c>true</c> if [cross viewing]; otherwise, <c>false</c>.</value>
        public bool CrossViewing
        {
            get
            {
                return (bool)this.GetValue(CrossViewingProperty);
            }

            set
            {
                this.SetValue(CrossViewingProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the left camera.
        /// </summary>
        /// <value>The left camera.</value>
        public PerspectiveCamera LeftCamera { get; set; }

        /// <summary>
        /// Gets or sets the left viewport.
        /// </summary>
        /// <value>The left viewport.</value>
        public Viewport3D LeftViewport { get; set; }

        /// <summary>
        /// Gets or sets the right camera.
        /// </summary>
        /// <value>The right camera.</value>
        public PerspectiveCamera RightCamera { get; set; }

        /// <summary>
        /// Gets or sets the right viewport.
        /// </summary>
        /// <value>The right viewport.</value>
        public Viewport3D RightViewport { get; set; }

        /// <summary>
        /// Gets or sets the stereo base.
        /// </summary>
        /// <value>The stereo base.</value>
        public double StereoBase
        {
            get
            {
                return (double)this.GetValue(StereoBaseProperty);
            }

            set
            {
                this.SetValue(StereoBaseProperty, value);
            }
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right)
        {
            this.BindViewports(left, right, true, true);
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        /// <param name="createLights">
        /// if set to <c>true</c> [create lights].
        /// </param>
        /// <param name="createCamera">
        /// if set to <c>true</c> [create camera].
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right, bool createLights, bool createCamera)
        {
            this.LeftViewport = left;
            this.RightViewport = right;

            this.Children.CollectionChanged += this.ChildrenCollectionChanged;

            if (createLights)
            {
                this.Children.Add(new DefaultLights());
            }

            if (createCamera)
            {
                if (this.LeftViewport.Camera == null)
                {
                    this.LeftViewport.Camera = CameraHelper.CreateDefaultCamera();
                }
                else
                {
                    CameraHelper.Reset(this.LeftViewport.Camera as PerspectiveCamera);
                }

                if (this.RightViewport != null && this.RightViewport.Camera == null)
                {
                    this.RightViewport.Camera = new PerspectiveCamera();
                }
            }

            this.LeftCamera = this.LeftViewport.Camera as PerspectiveCamera;
            if (this.RightViewport != null)
            {
                this.RightCamera = this.RightViewport.Camera as PerspectiveCamera;
            }

            this.UpdateCameras();
        }

        /// <summary>
        /// Clears the children collection.
        /// </summary>
        public void Clear()
        {
            this.Children.Clear();
            this.SynchronizeStereoModel();
        }

        /// <summary>
        /// Exports the views to kerkythea.
        /// </summary>
        /// <param name="leftFileName">
        /// Name of the left file.
        /// </param>
        /// <param name="rightFileName">
        /// Name of the right file.
        /// </param>
        public void ExportKerkythea(string leftFileName, string rightFileName)
        {
            var scb = this.Background as SolidColorBrush;

            var leftExporter = new KerkytheaExporter();
            if (scb != null)
            {
                leftExporter.BackgroundColor = scb.Color;
            }

            leftExporter.Reflections = true;
            leftExporter.Shadows = true;
            leftExporter.SoftShadows = true;
            leftExporter.Width = (int)this.LeftViewport.ActualWidth;
            leftExporter.Height = (int)this.LeftViewport.ActualHeight;
            using (var stream = File.Create(leftFileName))
            {
                leftExporter.Export(this.LeftViewport, stream);
            }

            var rightExporter = new KerkytheaExporter();
            if (scb != null)
            {
                rightExporter.BackgroundColor = scb.Color;
            }

            rightExporter.Reflections = true;
            rightExporter.Shadows = true;
            rightExporter.SoftShadows = true;
            rightExporter.Width = (int)this.RightViewport.ActualWidth;
            rightExporter.Height = (int)this.RightViewport.ActualHeight;
            using (var stream = File.Create(rightFileName))
            {
                rightExporter.Export(this.RightViewport, stream);
            }
        }

        /// <summary>
        /// Synchronizes the stereo model.
        /// </summary>
        public void SynchronizeStereoModel()
        {
            this.LeftViewport.Children.Clear();
            if (this.RightViewport != null)
            {
                this.RightViewport.Children.Clear();
            }

            foreach (var v in this.Children)
            {
                this.LeftViewport.Children.Add(v);
                if (this.RightViewport != null)
                {
                    Visual3D clone = StereoHelper.CreateClone(v);
                    if (clone != null)
                    {
                        this.RightViewport.Children.Add(clone);
                    }
                }
            }
        }

        /// <summary>
        /// Updates the cameras.
        /// </summary>
        public void UpdateCameras()
        {
            StereoHelper.UpdateStereoCameras(
                this.Camera,
                this.LeftCamera,
                this.RightCamera,
                this.StereoBase,
                this.CrossViewing,
                this.CopyUpVector,
                this.CopyDirectionVector);
        }

        /// <summary>
        /// The stereo view changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected static void StereoViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var v = (StereoControl)d;
            v.UpdateCameras();
        }

        /// <summary>
        /// Handle the camera changed event.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void CameraChanged(object sender, EventArgs e)
        {
            this.UpdateCameras();
        }

        /// <summary>
        /// Handle changes in the children collection.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void ChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // todo: update left and right collections here
        }

    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.ObjectModel;
    using System.Collections.Specialized;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Base class for controls that use stereo cameras
    /// </summary>
    [ContentProperty("Content")]
    public class StereoControl : ContentControl
    {
        // todo: keyboard shortcut 'x' to change cross/parallel viewing
        /// <summary>
        /// Identifies the <see cref="Camera"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraProperty = DependencyProperty.Register(
            "Camera", typeof(PerspectiveCamera), typeof(StereoControl), new UIPropertyMetadata(null));

        /// <summary>
        /// Identifies the <see cref="CameraRotationMode"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraRotationModeProperty =
            DependencyProperty.Register(
                "CameraRotationMode",
                typeof(CameraRotationMode),
                typeof(StereoControl),
                new UIPropertyMetadata(CameraRotationMode.Turntable));

        /// <summary>
        /// Identifies the <see cref="CopyDirectionVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyDirectionVectorProperty =
            DependencyProperty.Register(
                "CopyDirectionVector",
                typeof(bool),
                typeof(StereoControl),
                new UIPropertyMetadata(true, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CopyUpVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyUpVectorProperty = DependencyProperty.Register(
            "CopyUpVector", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CrossViewing"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CrossViewingProperty = DependencyProperty.Register(
            "CrossViewing", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false));

        /// <summary>
        /// Identifies the <see cref="StereoBase"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty StereoBaseProperty = DependencyProperty.Register(
            "StereoBase", typeof(double), typeof(StereoControl), new UIPropertyMetadata(0.12, StereoViewChanged));

        /// <summary>
        /// Initializes static members of the <see cref="StereoControl"/> class.
        /// </summary>
        static StereoControl()
        {
            DefaultStyleKeyProperty.OverrideMetadata(
                typeof(StereoControl), new FrameworkPropertyMetadata(typeof(StereoControl)));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StereoControl"/> class.
        /// </summary>
        public StereoControl()
        {
            this.Camera = CameraHelper.CreateDefaultCamera();
            this.Camera.Changed += this.CameraChanged;
            this.Children = new ObservableCollection<Visual3D>();
        }

        /*        void StereoControl_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            if (e.Key == Key.X)
            {
                CrossViewing = !CrossViewing;
            }
        }
        */
        /// <summary>
        /// Gets or sets the camera.
        /// </summary>
        /// <value>The camera.</value>
        public PerspectiveCamera Camera
        {
            get
            {
                return (PerspectiveCamera)this.GetValue(CameraProperty);
            }

            set
            {
                this.SetValue(CameraProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the camera rotation mode.
        /// </summary>
        /// <value>The camera rotation mode.</value>
        public CameraRotationMode CameraRotationMode
        {
            get
            {
                return (CameraRotationMode)this.GetValue(CameraRotationModeProperty);
            }

            set
            {
                this.SetValue(CameraRotationModeProperty, value);
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <value>The children.</value>
        public ObservableCollection<Visual3D> Children { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether [copy direction vector].
        /// </summary>
        /// <value><c>true</c> if [copy direction vector]; otherwise, <c>false</c>.</value>
        public bool CopyDirectionVector
        {
            get
            {
                return (bool)this.GetValue(CopyDirectionVectorProperty);
            }

            set
            {
                this.SetValue(CopyDirectionVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether [copy up vector].
        /// </summary>
        /// <value><c>true</c> if [copy up vector]; otherwise, <c>false</c>.</value>
        public bool CopyUpVector
        {
            get
            {
                return (bool)this.GetValue(CopyUpVectorProperty);
            }

            set
            {
                this.SetValue(CopyUpVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the cameras are set up for cross viewing.
        /// </summary>
        /// <value><c>true</c> if [cross viewing]; otherwise, <c>false</c>.</value>
        public bool CrossViewing
        {
            get
            {
                return (bool)this.GetValue(CrossViewingProperty);
            }

            set
            {
                this.SetValue(CrossViewingProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the left camera.
        /// </summary>
        /// <value>The left camera.</value>
        public PerspectiveCamera LeftCamera { get; set; }

        /// <summary>
        /// Gets or sets the left viewport.
        /// </summary>
        /// <value>The left viewport.</value>
        public Viewport3D LeftViewport { get; set; }

        /// <summary>
        /// Gets or sets the right camera.
        /// </summary>
        /// <value>The right camera.</value>
        public PerspectiveCamera RightCamera { get; set; }

        /// <summary>
        /// Gets or sets the right viewport.
        /// </summary>
        /// <value>The right viewport.</value>
        public Viewport3D RightViewport { get; set; }

        /// <summary>
        /// Gets or sets the stereo base.
        /// </summary>
        /// <value>The stereo base.</value>
        public double StereoBase
        {
            get
            {
                return (double)this.GetValue(StereoBaseProperty);
            }

            set
            {
                this.SetValue(StereoBaseProperty, value);
            }
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right)
        {
            this.BindViewports(left, right, true, true);
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        /// <param name="createLights">
        /// if set to <c>true</c> [create lights].
        /// </param>
        /// <param name="createCamera">
        /// if set to <c>true</c> [create camera].
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right, bool createLights, bool createCamera)
        {
            this.LeftViewport = left;
            this.RightViewport = right;

            this.Children.CollectionChanged += this.ChildrenCollectionChanged;

            if (createLights)
            {
                this.Children.Add(new DefaultLights());
            }

            if (createCamera)
            {
                if (this.LeftViewport.Camera == null)
                {
                    this.LeftViewport.Camera = CameraHelper.CreateDefaultCamera();
                }
                else
                {
                    CameraHelper.Reset(this.LeftViewport.Camera as PerspectiveCamera);
                }

                if (this.RightViewport != null && this.RightViewport.Camera == null)
                {
                    this.RightViewport.Camera = new PerspectiveCamera();
                }
            }

            this.LeftCamera = this.LeftViewport.Camera as PerspectiveCamera;
            if (this.RightViewport != null)
            {
                this.RightCamera = this.RightViewport.Camera as PerspectiveCamera;
            }

            this.UpdateCameras();
        }

        /// <summary>
        /// Clears the children collection.
        /// </summary>
        public void Clear()
        {
            this.Children.Clear();
            this.SynchronizeStereoModel();
        }

        /// <summary>
        /// Exports the views to kerkythea.
        /// </summary>
        /// <param name="leftFileName">
        /// Name of the left file.
        /// </param>
        /// <param name="rightFileName">
        /// Name of the right file.
        /// </param>
        public void ExportKerkythea(string leftFileName, string rightFileName)
        {

            var leftExporter = new KerkytheaExporter();

            if (this.Background is SolidColorBrush scb)
            {
                leftExporter.BackgroundColor = scb.Color;
            }

            leftExporter.Reflections = true;
            leftExporter.Shadows = true;
            leftExporter.SoftShadows = true;
            leftExporter.Width = (int)this.LeftViewport.ActualWidth;
            leftExporter.Height = (int)this.LeftViewport.ActualHeight;
            using (var stream = File.Create(leftFileName))
            {
                leftExporter.Export(this.LeftViewport, stream);
            }

            var rightExporter = new KerkytheaExporter();

            if (this.Background is SolidColorBrush scb)
            {
                rightExporter.BackgroundColor = scb.Color;
            }

            rightExporter.Reflections = true;
            rightExporter.Shadows = true;
            rightExporter.SoftShadows = true;
            rightExporter.Width = (int)this.RightViewport.ActualWidth;
            rightExporter.Height = (int)this.RightViewport.ActualHeight;
            using (var stream = File.Create(rightFileName))
            {
                rightExporter.Export(this.RightViewport, stream);
            }
        }

        /// <summary>
        /// Synchronizes the stereo model.
        /// </summary>
        public void SynchronizeStereoModel()
        {
            this.LeftViewport.Children.Clear();
            if (this.RightViewport != null)
            {
                this.RightViewport.Children.Clear();
            }

            foreach (var v in this.Children)
            {
                this.LeftViewport.Children.Add(v);
                if (this.RightViewport != null)
                {
                    Visual3D clone = StereoHelper.CreateClone(v);
                    if (clone != null)
                    {
                        this.RightViewport.Children.Add(clone);
                    }
                }
            }
        }

        /// <summary>
        /// Updates the cameras.
        /// </summary>
        public void UpdateCameras()
        {
            StereoHelper.UpdateStereoCameras(
                this.Camera,
                this.LeftCamera,
                this.RightCamera,
                this.StereoBase,
                this.CrossViewing,
                this.CopyUpVector,
                this.CopyDirectionVector);
        }

        /// <summary>
        /// The stereo view changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected static void StereoViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var v = (StereoControl)d;
            v.UpdateCameras();
        }

        /// <summary>
        /// Handle the camera changed event.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void CameraChanged(object sender, EventArgs e)
        {
            this.UpdateCameras();
        }

        /// <summary>
        /// Handle changes in the children collection.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void ChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // todo: update left and right collections here
        }

    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs(339,52): error CS0128: A local variable or function named 'scb' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs(341,49): error CS0165: Use of unassigned local variable 'scb'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;
    using System.Xml;

    /// <summary>
    /// Exports the 3D visual tree to a <a href="http://www.kerkythea.net/joomla">Kerkythea</a> input file.
    /// </summary>
    public class KerkytheaExporter : Exporter<KerkytheaExporter.KerkytheaWriter>
    {
        /// <summary>
        /// Dictionary of registered materials.
        /// </summary>
        private readonly Dictionary<Material, XmlDocument> registeredMaterials = new Dictionary<Material, XmlDocument>();

        /// <summary>
        /// Initializes a new instance of the <see cref="KerkytheaExporter"/> class.
        /// </summary>
        public KerkytheaExporter()
        {
            this.Name = "My Scene";
            this.BackgroundColor = Colors.Black;
            this.ReflectionColor = Colors.Gray;
            this.Reflections = true;
            this.Shadows = true;
            this.SoftShadows = true;
            this.LightMultiplier = 3.0;
            this.Threads = 2;

            this.ShadowColor = Color.FromArgb(255, 100, 100, 100);
            this.RenderSetting = RenderSettings.RayTracer;
            this.Aperture = "Pinhole";
            this.FocusDistance = 1.0;
            this.LensSamples = 3;

            this.Width = 500;
            this.Height = 500;

            this.TextureWidth = 1024;
            this.TextureHeight = 1024;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Render settings.
        /// </summary>
        public enum RenderSettings
        {
            /// <summary>
            /// Use RayTracer.
            /// </summary>
            RayTracer,

            /// <summary>
            /// Use PhotonMap.
            /// </summary>
            PhotonMap,

            /// <summary>
            /// Use MetropolisLightTransport.
            /// </summary>
            MetropolisLightTransport
        }

        /// <summary>
        /// Gets or sets the aperture.
        /// </summary>
        /// <value>The aperture.</value>
        public string Aperture { get; set; }

        /// <summary>
        /// Gets or sets the color of the background.
        /// </summary>
        /// <value>The color of the background.</value>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Gets or sets the texture file creator.
        /// </summary>
        /// <value>The file creator.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets the length of the focal.
        /// </summary>
        /// <value>The length of the focal.</value>
        public double FocalLength { get; set; }

        /// <summary>
        /// Gets or sets the focus distance.
        /// </summary>
        /// <value>The focus distance.</value>
        public double FocusDistance { get; set; }

        /// <summary>
        /// Gets or sets the height.
        /// </summary>
        /// <value>The height.</value>
        public int Height { get; set; }

        /// <summary>
        /// Gets or sets the lens samples.
        /// </summary>
        /// <value>The lens samples.</value>
        public int LensSamples { get; set; }

        /// <summary>
        /// Gets or sets the light multiplier.
        /// </summary>
        /// <value>The light multiplier.</value>
        public double LightMultiplier { get; set; }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the color of the reflection.
        /// </summary>
        /// <value>The color of the reflection.</value>
        public Color ReflectionColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is reflections.
        /// </summary>
        /// <value><c>true</c> if reflections; otherwise, <c>false</c>.</value>
        public bool Reflections { get; set; }

        /// <summary>
        /// Gets or sets the render setting.
        /// </summary>
        /// <value>The render setting.</value>
        public RenderSettings RenderSetting { get; set; }

        /// <summary>
        /// Gets or sets the color of the shadow.
        /// </summary>
        /// <value>The color of the shadow.</value>
        public Color ShadowColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is shadows.
        /// </summary>
        /// <value><c>true</c> if shadows; otherwise, <c>false</c>.</value>
        public bool Shadows { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether [soft shadows].
        /// </summary>
        /// <value><c>true</c> if [soft shadows]; otherwise, <c>false</c>.</value>
        public bool SoftShadows { get; set; }

        /// <summary>
        /// Gets or sets the height of the texture.
        /// </summary>
        /// <value>The height of the texture.</value>
        public int TextureHeight { get; set; }

        /// <summary>
        /// Gets or sets the texture path.
        /// </summary>
        /// <value>The texture path.</value>
        public string TexturePath { get; set; }

        /// <summary>
        /// Gets or sets the width of the texture.
        /// </summary>
        /// <value>The width of the texture.</value>
        public int TextureWidth { get; set; }

        /// <summary>
        /// Gets or sets the threads.
        /// </summary>
        /// <value>The threads.</value>
        public int Threads { get; set; }

        /// <summary>
        /// Gets or sets the width.
        /// </summary>
        /// <value>The width.</value>
        public int Width { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        public void ExportMesh(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartObject("Triangular Mesh", "Triangular Mesh", string.Empty, "Surface");

            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Vertex List");
                writer.WriteAttributeString("Type", "Point3D List");
                writer.WriteAttributeString("Value", m.Positions.Count.ToString());
                foreach (var p in m.Positions)
                {
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xyz", ToKerkytheaString(p));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            int triangles = m.TriangleIndices.Count / 3;

            // NORMALS
            // todo: write normal list per vertex instead of per triangle index
            if (m.Normals != null && m.Normals.Count > 0)
            {
                writer.WriteStartElement("Parameter");
                {
                    writer.WriteAttributeString("Name", "Normal List");
                    writer.WriteAttributeString("Type", "Point3D List");
                    writer.WriteAttributeString("Value", m.TriangleIndices.Count.ToString());
                    foreach (int index in m.TriangleIndices)
                    {
                        if (index >= m.Normals.Count)
                        {
                            continue;
                        }

                        var n = m.Normals[index];
                        writer.WriteStartElement("P");
                        writer.WriteAttributeString("xyz", ToKerkytheaString(n));
                        writer.WriteEndElement();
                    }
                }

                writer.WriteFullEndElement();
            }

            // TRIANGLE INDICES
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Index List");
                writer.WriteAttributeString("Type", "Triangle Index List");
                writer.WriteAttributeString("Value", triangles.ToString());
                for (int a = 0; a < triangles; a++)
                {
                    int a3 = a * 3;
                    int i = m.TriangleIndices[a3];
                    int j = m.TriangleIndices[a3 + 1];
                    int k = m.TriangleIndices[a3 + 2];
                    writer.WriteStartElement("F");
                    writer.WriteAttributeString("ijk", string.Format("{0} {1} {2}", i, j, k));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            writer.WriteParameter("Smooth", true);
            writer.WriteParameter("AA Tolerance", 15.0);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Registers a material.
        /// </summary>
        /// <param name="m">The material to register.</param>
        /// <param name="stream">The material stream.</param>
        public void RegisterMaterial(Material m, Stream stream)
        {
            var doc = new XmlDocument();
            doc.Load(stream);
            this.registeredMaterials.Add(m, doc);
        }

        /// <summary>
        /// Writes the Metropolis Light Transport properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the MLP ray tracer.</param>
        public void WriteMetropolisLightTransport(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Metropolis Light Transport", name, "Ray Tracer");
            writer.WriteParameter("Max Ray Tracing Depth", 100);
            writer.WriteParameter("Max Iterations", 10000);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Seed Paths", 50000);
            writer.WriteParameter("Large Step Probability", 0.2);
            writer.WriteParameter("Max Mutation Distance", 0.02);
            writer.WriteParameter("Live Probability", 0.7);
            writer.WriteParameter("Max Consecutive Rejections", 200);
            writer.WriteParameter("Bidirectional", true);
            writer.WriteParameter("Super Sampling", "3x3");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("Random Seed", "Automatic");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the standard ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the ray tracer.</param>
        public void WriteStandardRayTracer(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Standard Ray Tracer", name, "Ray Tracer");
            writer.WriteParameter("Rasterization", "Auto");

            // WriteParameter("Antialiasing", "Extra Pass 3x3");
            writer.WriteParameter("Antialiasing", "Production AA");
            writer.WriteParameter("Antialiasing Filter", "Mitchell-Netravali 0.5 0.8");
            writer.WriteParameter("Antialiasing Threshold", 0.3);
            writer.WriteParameter("Texture Filtering", true);
            writer.WriteParameter("Ambient Lighting", true);
            writer.WriteParameter("Direct Lighting", true);
            writer.WriteParameter("Sky Lighting", true);
            writer.WriteParameter("Brightness Threshold", 0.002);
            writer.WriteParameter("Max Ray Tracing Depth", 5);
            writer.WriteParameter("Max Scatter Bounces", 5);
            writer.WriteParameter("Max Dirac Bounces", 5);
            writer.WriteParameter("Irradiance Precomputation", 4);
            writer.WriteParameter("Irradiance Scale", Colors.White);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Max Iterations", 5);
            writer.WriteParameter("Super Sampling", "None");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("./Sampling Criteria/Diffuse Samples", 1024);
            writer.WriteParameter("./Sampling Criteria/Specular Samples", 32);
            writer.WriteParameter("./Sampling Criteria/Dispersion Samples", true);
            writer.WriteParameter("./Sampling Criteria/Trace Diffusers", false);
            writer.WriteParameter("./Sampling Criteria/Trace Translucencies", false);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Trace Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Random Generator", "Pure");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the threaded ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="threads">The number of threads.</param>
        public void WriteThreadedRaytracer(KerkytheaWriter writer, int threads)
        {
            writer.WriteStartObject("./Ray Tracers/Threaded Ray Tracer", "Threaded Ray Tracer", "Threaded Ray Tracer", "Ray Tracer");
            for (int i = 0; i < threads; i++)
            {
                writer.WriteParameter("Thread #" + i, "#" + i);
            }

            writer.WriteParameter("Network Mode", "None");
            writer.WriteParameter("Listening Port", 6200);
            writer.WriteParameter("Host", "127.0.0.1");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Creates the writer for the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>The writer.</returns>
        protected override KerkytheaWriter Create(Stream stream)
        {
            return new KerkytheaWriter(stream);
        }

        /// <summary>
        /// Exports the camera.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="c">The camera.</param>
        /// <exception cref="System.InvalidOperationException">Only perspective cameras are supported.</exception>
        protected override void ExportCamera(KerkytheaWriter writer, Camera c)
        {
            var pc = c as PerspectiveCamera;
            if (pc == null)
            {
                throw new InvalidOperationException("Only perspective cameras are supported.");
            }

            const string name = "Camera #1";
            writer.WriteStartObject("./Cameras/" + name, "Pinhole Camera", name, "Camera");

            // FOV = 2 arctan (x / (2 f)), x is diagonal, f is focal length
            // f = x / 2 / Tan(FOV/2)
            // http://en.wikipedia.org/wiki/Angle_of_view
            // http://kmp.bdimitrov.de/technology/fov.html

            // PerspectiveCamera.FieldOfView: Horizontal field of view
            // Must multiply by ratio of Viewport Width/Height
            double ratio = this.Width / (double)this.Height;
            const double x = 40;
            double f = 0.5 * ratio * x / Math.Tan(0.5 * pc.FieldOfView / 180.0 * Math.PI);

            writer.WriteParameter("Focal Length (mm)", f);
            writer.WriteParameter("Film Height (mm)", x);
            writer.WriteParameter("Resolution", string.Format(CultureInfo.InvariantCulture, "{0}x{1}", this.Width, this.Height));

            var t = CreateTransform(pc.Position, pc.LookDirection, pc.UpDirection);
            writer.WriteTransform("Frame", t);

            writer.WriteParameter("Focus Distance", this.FocusDistance);
            writer.WriteParameter("f-number", this.Aperture);
            writer.WriteParameter("Lens Samples", this.LensSamples);
            writer.WriteParameter("Blades", 6);
            writer.WriteParameter("Diaphragm", "Circular");
            writer.WriteParameter("Projection", "Planar");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the document header.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void ExportHeader(KerkytheaWriter writer)
        {
            writer.WriteStartDocument();

            writer.WriteStartElement("Root");
            writer.WriteAttributeString("Label", "Default Kernel");
            writer.WriteAttributeString("Name", string.Empty);
            writer.WriteAttributeString("Type", "Kernel");

            writer.WriteStartObject("./Modellers/XML Modeller", "XML Modeller", "XML Modeller", "Modeller");
            writer.WriteEndObject();

            writer.WriteStartObject("./Image Handlers/Free Image Support", "Free Image Support", "Free Image Support", "Image Handler");
            writer.WriteParameter("Tone Mapping", "External");
            writer.WriteParameter("Jpeg Quality", "Higher");
            writer.WriteEndObject();

            writer.WriteStartObject("./Direct Light Estimators/Refraction Enhanced", "Refraction Enhanced", "Refraction Enhanced", "Direct Light Estimator");
            writer.WriteParameter("Enabled", "Boolean", "1");
            writer.WriteParameter("PseudoCaustics", "Boolean", "0");
            writer.WriteParameter("PseudoTranslucencies", "Boolean", "0");
            writer.WriteParameter("Area Light Evaluation", "Boolean", "1");
            writer.WriteParameter("Optimized Area Lights", "Boolean", "1");
            writer.WriteParameter("Accurate Soft Shadows", "Boolean", "0");
            writer.WriteParameter("Antialiasing", "String", "High");
            writer.WriteParameter("./Evaluation/Diffuse", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Specular", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Translucent", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Transmitted", "Boolean", "1");
            writer.WriteEndObject();

            // add ray tracer module.
            for (int i = 0; i < this.Threads; i++)
            {
                this.WriteStandardRayTracer(writer, "#" + i);
            }

            this.WriteThreadedRaytracer(writer, this.Threads);

            // add spatial subdivision module.
            writer.WriteStartObject("./Environments/Octree Environment", "Octree Environment", "Octree Environment", "Environment");
            writer.WriteParameter("Max Objects per Cell", 20);
            writer.WriteParameter("Instancing Switch", 1000000);
            writer.WriteParameter("Caching Switch", 6000000);
            writer.WriteEndObject();

            // add basic post filtering / tone mapping.
            writer.WriteStartObject("./Filters/Simple Tone Mapping", "Simple Tone Mapping", string.Empty, "Filter");
            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Method", "Simple");
            writer.WriteParameter("Exposure", 1.0);
            writer.WriteParameter("Gamma", 1.0);
            writer.WriteParameter("Dark Multiplier", 1.0);
            writer.WriteParameter("Bright Multiplier", 1.0);
            writer.WriteParameter("Reverse Correction", true);
            writer.WriteParameter("Reverse Gamma", 2.2);
            writer.WriteEndObject();

            // start of scene description.
            writer.WriteStartObject("./Scenes/" + this.Name, "Default Scene", this.Name, "Scene");
        }

        /// <summary>
        /// Exports the light.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="l">The light.</param>
        /// <param name="t">The transform.</param>
        protected override void ExportLight(KerkytheaWriter writer, Light l, Transform3D t)
        {
            if (l is AmbientLight)
            {
                return;
            }

            string name = this.GetUniqueName(writer, l, l.GetType().Name);

            var d = l as DirectionalLight;
            var s = l as SpotLight;
            var p = l as PointLight;

            writer.WriteStartObject("./Lights/" + name, "Default Light", name, "Light");
            {
                string stype = "Projector Light";
                if (s != null)
                {
                    stype = "Spot Light";
                }

                if (p != null)
                {
                    stype = "Omni Light";
                }

                writer.WriteStartObject(stype, stype, string.Empty, "Emittance");

                // emitter Radiance
                writer.WriteStartObject("./Radiance/Constant Texture", "Constant Texture", string.Empty, "Texture");
                var c = Colors.White;
                writer.WriteParameter("Color", c);
                writer.WriteEndObject();

                // var v = new Vector3D(l.Color.R, l.Color.G, l.Color.B);
                // double lum = v.Length;
                writer.WriteParameter("Attenuation", "None");

                // SpotLight (Spot Light)
                if (s != null)
                {
                    // todo : export the specular parameters
                    // s.ConstantAttenuation
                    // s.LinearAttenuation
                    // s.QuadraticAttenuation
                    writer.WriteParameter("Fall Off", s.OuterConeAngle);
                    writer.WriteParameter("Hot Spot", s.InnerConeAngle);
                }

                // DirectionalLight (Projector Light)
                if (d != null)
                {
                    writer.WriteParameter("Width", 2.0);
                    writer.WriteParameter("Height", 2.0);
                }

                // PointLight (Omni light)
                if (p != null)
                {
                    // todo: export pointlight parameters
                    // name.ConstantAttenuation
                    // name.LinearAttenuation
                    // name.QuadraticAttenuation
                    // name.Range // distance beyond which the light has no effect
                }

                writer.WriteParameter("Focal Length", 1.0);

                writer.WriteEndObject(); // stype

                writer.WriteParameter("Enabled", true);
                writer.WriteParameter("Shadow", this.Shadows);
                writer.WriteParameter("Soft Shadow", this.SoftShadows);

                writer.WriteParameter("Negative Light", false);
                writer.WriteParameter("Global Photons", true);
                writer.WriteParameter("Caustic Photons", true);
                writer.WriteParameter("Multiplier", this.LightMultiplier);

                Matrix3D transform;
                var upVector = new Vector3D(0, 0, 1);
                if (s != null)
                {
                    transform = CreateTransform(s.Position, s.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (d != null)
                {
                    var origin = new Point3D(-1000 * d.Direction.X, -1000 * d.Direction.Y, -1000 * d.Direction.Z);
                    transform = CreateTransform(origin, d.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (p != null)
                {
                    var direction = new Vector3D(-p.Position.X, -p.Position.Y, -p.Position.Z);
                    transform = CreateTransform(p.Position, direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                writer.WriteParameter("Focus Distance", 4.0);
                writer.WriteParameter("Radius", 0.2);
                writer.WriteParameter("Shadow Color", this.ShadowColor);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="g">The model geometry.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(KerkytheaWriter writer, GeometryModel3D g, Transform3D transform)
        {
            var mesh = g.Geometry as MeshGeometry3D;
            if (mesh == null)
            {
                return;
            }

            string name = this.GetUniqueName(writer, g, g.GetType().Name);
            writer.WriteStartObject("./Models/" + name, "Default Model", name, "Model");

            this.ExportMesh(writer, mesh);

            if (g.Material != null)
            {
                this.ExportMaterial(writer, g.Material);
            }

            var tg = new Transform3DGroup();
            tg.Children.Add(g.Transform);
            tg.Children.Add(transform);

            if (mesh.TextureCoordinates != null)
            {
                this.ExportMapChannel(writer, mesh);
            }

            writer.WriteTransform("Frame", tg.Value);

            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Visible", true);
            writer.WriteParameter("Shadow Caster", true);
            writer.WriteParameter("Shadow Receiver", true);
            writer.WriteParameter("Caustics Transmitter", true);
            writer.WriteParameter("Caustics Receiver", true);
            writer.WriteParameter("Exit Blocker", false);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="v">The viewport to export.</param>
        protected override void ExportViewport(KerkytheaWriter writer, Viewport3D v)
        {
            var ambient = Visual3DHelper.Find<AmbientLight>(v);

            // default global settings
            writer.WriteStartObject("Default Global Settings", "Default Global Settings", string.Empty, "Global Settings");
            if (ambient != null)
            {
                writer.WriteParameter("Ambient Light", ambient.Color);
            }

            writer.WriteParameter("Background Color", this.BackgroundColor);
            writer.WriteParameter("Compute Volume Transfer", false);
            writer.WriteParameter("Transfer Recursion Depth", 1);
            writer.WriteParameter("Background Type", "Sky Color");
            writer.WriteParameter("Sky Intensity", 1.0);
            writer.WriteParameter("Sky Frame", "Transform", "1 0 0 0 0 1 0 0 0 0 1 0 ");
            writer.WriteParameter("Sun Direction", "0 0 1");
            writer.WriteParameter("Sky Turbidity", 2.0);
            writer.WriteParameter("Sky Luminance Gamma", 1.2);
            writer.WriteParameter("Sky Chromaticity Gamma", 1.8);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Index of Refraction", 1.0);
            writer.WriteParameter("Scatter Density", 0.1);
            writer.WriteParameter("./Location/Latitude", 0.0);
            writer.WriteParameter("./Location/Longitude", 0.0);
            writer.WriteParameter("./Location/Timezone", 0);
            writer.WriteParameter("./Location/Date", "0/0/2007");
            writer.WriteParameter("./Location/Time", "12:0:0");
            writer.WriteParameter("./Background Image/Filename", "[No Bitmap]");
            writer.WriteParameter("./Background Image/Projection", "UV");
            writer.WriteParameter("./Background Image/Offset X", 0.0);
            writer.WriteParameter("./Background Image/Offset Y", 0.0);
            writer.WriteParameter("./Background Image/Scale X", 1.0);
            writer.WriteParameter("./Background Image/Scale Y", 1.0);
            writer.WriteParameter("./Background Image/Rotation", 0.0);
            writer.WriteParameter("./Background Image/Smooth", true);
            writer.WriteParameter("./Background Image/Inverted", false);
            writer.WriteParameter("./Background Image/Alpha Channel", false);
            writer.WriteEndObject();

            // Visual3DHelper.Traverse<Light>(v.Children, ExportLight);
            // Visual3DHelper.Traverse<GeometryModel3D>(v.Children, ExportGeometryModel3D);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(KerkytheaWriter writer)
        {
            // end of scene description.
            writer.WriteFullEndElement();

            // it is necessary to describe the primary/active modules as there might exist more than one!
            writer.WriteParameter("Mip Mapping", true);
            writer.WriteParameter("./Interfaces/Active", "Null Interface");
            writer.WriteParameter("./Modellers/Active", "XML Modeller");
            writer.WriteParameter("./Image Handlers/Active", "Free Image Support");

            writer.WriteParameter("./Ray Tracers/Active", "Threaded Ray Tracer");
            writer.WriteParameter("./Irradiance Estimators/Active", "Null Irradiance Estimator");
            writer.WriteParameter("./Direct Light Estimators/Active", "Refraction Enhanced");
            writer.WriteParameter("./Environments/Active", "Octree Environment");
            writer.WriteParameter("./Filters/Active", "Simple Tone Mapping");
            writer.WriteParameter("./Scenes/Active", this.Name);
            writer.WriteParameter("./Libraries/Active", "Material Librarian");

            // end of root element
            writer.WriteFullEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        /// <summary>
        /// Creates a transform from the original coordinate system to the system defined by translation origin
        /// </summary>
        /// <param name="origin">The origin.</param>
        /// <param name="direction">The direction vector.</param>
        /// <param name="up">The up vector.</param>
        /// <returns>A transformation matrix.</returns>
        private static Matrix3D CreateTransform(Point3D origin, Vector3D direction, Vector3D up)
        {
            var z = direction;
            var x = Vector3D.CrossProduct(direction, up);
            var y = up;

            x.Normalize();
            y.Normalize();
            z.Normalize();

            var m = new Matrix3D(x.X, y.X, z.X, 0, x.Y, y.Y, z.Y, 0, x.Z, y.Z, z.Z, 0, origin.X, origin.Y, origin.Z, 1);

            return m;
        }

        /// <summary>
        /// Converts a <see cref="Point"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="p">
        /// The point.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point p)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0} {1}", p.X, p.Y);
        }

        /// <summary>
        /// Converts a <see cref="Point3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="point">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point3D point)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(point.X, 1),
                ValueOrDefault(point.Y, 0),
                ValueOrDefault(point.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Vector3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="vector">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the vector.
        /// </returns>
        private static string ToKerkytheaString(Vector3D vector)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(vector.X, 1),
                ValueOrDefault(vector.Y, 0),
                ValueOrDefault(vector.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Color"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="c">
        /// The color.
        /// </param>
        /// <returns>
        /// A string representing the color.
        /// </returns>
        private static string ToKerkytheaString(Color c)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                c.R / 255.0,
                c.G / 255.0,
                c.B / 255.0);
        }

        /// <summary>
        /// Exports the map channel (texture coordinates) from the specified mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        private void ExportMapChannel(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Map Channel");
                writer.WriteAttributeString("Type", "Point2D List");
                int n = m.TriangleIndices.Count;
                writer.WriteAttributeString("Value", n.ToString());
                foreach (int index in m.TriangleIndices)
                {
                    if (index >= m.TextureCoordinates.Count)
                    {
                        continue;
                    }

                    var uv = m.TextureCoordinates[index];
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xy", ToKerkytheaString(uv));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Exports a material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the material.</param>
        /// <param name="material">The material.</param>
        /// <param name="weights">The weights.</param>
        private void ExportMaterial(KerkytheaWriter writer, string name, Material material, IList<double> weights)
        {
            var g = material as MaterialGroup;
            if (g != null)
            {
                foreach (var m in g.Children)
                {
                    this.ExportMaterial(writer, name, m, weights);
                }
            }

            var d = material as DiffuseMaterial;
            if (d != null)
            {
                string texture = null;
                Color? color = null;
                double alpha = 1.0;
                if (d.Brush is SolidColorBrush)
                {
                    color = this.GetSolidColor(d.Brush, d.Color);
                    alpha = color.Value.A / 255.0;
                }
                else
                {
                    texture = this.GetTexture(writer, d.Brush, name);
                }

                if (alpha > 0)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), texture, color, null, null);
                    weights.Add(alpha);
                }

                // The refractive part
                if (alpha < 1)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, null, Colors.White);
                    weights.Add(1 - alpha);
                }
            }

            var s = material as SpecularMaterial;
            if (s != null)
            {
                var color = this.GetSolidColor(s.Brush, s.Color);

                // color = Color.FromArgb((byte)(color.A * factor), (byte)(color.R * factor), (byte)(color.G * factor), (byte)(color.B * factor));
                this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, color, null, s.SpecularPower * 0.5);
                double weight = color.A / 255.0;
                weight *= 0.01;
                weights.Add(weight);
            }

            var e = material as EmissiveMaterial;
            if (e != null)
            {
                // TODO
                System.Diagnostics.Debug.WriteLine("KerkytheaExporter: Emissive materials are not yet supported.");

                // Color color = GetSolidColor(e.Brush, d.Color);
                // WriteWhittedMaterial(string.Format("#{0}", weights.Count + 1), color, null, null);
                // WriteStartObject("./Translucent/Constant Texture", "Constant Texture", "", "Texture");
                // WriteParameter("Color", e.Color);
                // WriteEndObject();
            }
        }

        /// <summary>
        /// Exports the specified material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="material">The material.</param>
        private void ExportMaterial(KerkytheaWriter writer, Material material)
        {
            // If the material is registered, simply output the xml
            if (this.registeredMaterials.ContainsKey(material))
            {
                var doc = this.registeredMaterials[material];
                if (doc?.DocumentElement != null)
                {
                    foreach (XmlNode e in doc.DocumentElement.ChildNodes)
                    {
                        writer.Write(e);
                    }
                }

                return;
            }

            string name = this.GetUniqueName(writer, material, "Material");
            writer.WriteStartObject(name, "Layered Material", name, "Material");

            var weights = new List<double>();

            this.ExportMaterial(writer, name, material, weights);

            // if (Reflections)
            // {
            // WriteConstantTexture("Reflection", ReflectionColor);
            // }
            for (int i = 0; i < weights.Count; i++)
            {
                this.WriteWeight(writer, "Weight #" + i, weights[i]);
            }

            /*
             switch (MaterialType)
             {
                 case MaterialTypes.Ashikhmin:
                     this.WriteParameter("Rotation", 0.0);
                     this.WriteParameter("Attenuation", "Schlick");
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("N-K File", "");
                     break;
                 case MaterialTypes.Diffusive: // Whitted material
                     this.WriteParameter("Shininess", 60.0);
                     this.WriteParameter("Transmitted Shininess", 128.0);
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("Specular Sampling", true);
                     this.WriteParameter("Transmitted Sampling", false);
                     this.WriteParameter("Specular Attenuation", "Cosine");
                     this.WriteParameter("Transmitted Attenuation", "Cosine");
                     break;
             }
             */
            writer.WriteEndObject();
        }

        /// <summary>
        /// Gets the solid color from a brush.
        /// </summary>
        /// <param name="brush">
        /// The brush.
        /// </param>
        /// <param name="defaultColor">
        /// The default color (used if the specified brush is not a <see cref="SolidColorBrush"/>).
        /// </param>
        /// <returns>
        /// The color.
        /// </returns>
        private Color GetSolidColor(Brush brush, Color defaultColor)
        {
            var scb = brush as SolidColorBrush;
            if (scb != null)
            {
                return scb.Color;
            }

            return defaultColor;
        }

        /// <summary>
        /// Gets the texture for a brush.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="brush">The brush.</param>
        /// <param name="name">The name of the material.</param>
        /// <returns>
        /// The texture filename.
        /// </returns>
        private string GetTexture(KerkytheaWriter writer, Brush brush, string name)
        {
            // reuse textures
            string textureFile;
            if (writer.TryGetTexture(brush, out textureFile))
            {
                return textureFile;
            }

            string filename = name + ".png";
            string path = Path.Combine(this.TexturePath, filename);
            using (var s = this.FileCreator(path))
            {
                this.RenderBrush(s, brush, this.TextureWidth, this.TextureHeight);
            }

            writer.AddTexture(brush, filename);
            return filename;
        }

        /// <summary>
        /// Gets a unique name.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="o">The object.</param>
        /// <param name="defaultName">The default name.</param>
        /// <returns>A unique name.</returns>
        private string GetUniqueName(KerkytheaWriter writer, DependencyObject o, string defaultName)
        {
            var name = o.GetValue(FrameworkElement.NameProperty) as string;
            return writer.GetUniqueName(name, defaultName);
        }

        /// <summary>
        /// Writes a ashikhmin material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="shininessXMap">The shininess x map.</param>
        /// <param name="shininessYMap">The shininess y map.</param>
        /// <param name="rotationMap">The rotation map.</param>
        /// <param name="shininessX">The shininess x.</param>
        /// <param name="shininessY">The shininess y.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteAshikhminMaterial(KerkytheaWriter writer,
            string identifier,
            Color? diffuse,
            Color? specular,
            Color? shininessXMap,
            Color? shininessYMap,
            Color? rotationMap,
            double shininessX = 100,
            double shininessY = 100,
            double rotation = 0,
            double indexOfRefraction = 1.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (shininessXMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess X Map", shininessXMap.Value);
            }

            if (shininessYMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess Y Map", shininessYMap.Value);
            }

            if (rotationMap.HasValue)
            {
                this.WriteConstantTexture(writer, "RotationMap", rotationMap.Value);
            }

            writer.WriteParameter("Shininess X", shininessX);
            writer.WriteParameter("Shininess Y", shininessY);
            writer.WriteParameter("Rotation", rotation);
            writer.WriteParameter("Attenuation", "Schlick");
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("N-K File", nkfile);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a bitmap texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="filename">The filename.</param>
        private void WriteBitmapTexture(KerkytheaWriter writer, string name, string filename)
        {
            if (!string.IsNullOrEmpty(filename))
            {
                writer.WriteStartObject("./" + name + "/Bitmap Texture", "Bitmap Texture", string.Empty, "Texture");
                writer.WriteParameter("Filename", filename);
                writer.WriteParameter("Projection", "UV");
                writer.WriteParameter("Offset X", 0.0);
                writer.WriteParameter("Offset Y", 0.0);
                writer.WriteParameter("Scale X", 1.0);
                writer.WriteParameter("Scale Y", 1.0);
                writer.WriteParameter("Rotation", 0.0);
                writer.WriteParameter("Smooth", true);
                writer.WriteParameter("Inverted", false);
                writer.WriteParameter("Alpha Channel", false);
                writer.WriteEndObject();
            }
        }

        /// <summary>
        /// Writes a constant texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="color">The color.</param>
        private void WriteConstantTexture(KerkytheaWriter writer, string name, Color color)
        {
            writer.WriteStartObject("./" + name + "/Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", color);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a dielectric material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="reflection">The reflection.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="dispersion">The dispersion.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteDielectricMaterial(KerkytheaWriter writer,
            string identifier,
            Color? reflection,
            Color? refraction,
            double indexOfRefraction = 1.0,
            double dispersion = 0.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (reflection.HasValue)
            {
                this.WriteConstantTexture(writer, "Reflection", reflection.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Dispersion", dispersion);
            writer.WriteParameter("N-K File", string.Empty);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a weight.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="weight">The weight.</param>
        private void WriteWeight(KerkytheaWriter writer, string identifier, double weight)
        {
            writer.WriteStartObject(identifier, "Weighted Texture", identifier, "Texture");
            writer.WriteStartObject("Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", Colors.White);
            writer.WriteEndObject();
            writer.WriteParameter("Weight #0", weight);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a whitted material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="texture">The texture.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="shininess">The shininess.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        private void WriteWhittedMaterial(KerkytheaWriter writer,
            string identifier,
            string texture,
            Color? diffuse,
            Color? specular,
            Color? refraction,
            double shininess = 128.0,
            double indexOfRefraction = 1.0)
        {
            writer.WriteStartObject(identifier, "Whitted Material", identifier, "Material");

            if (texture != null)
            {
                this.WriteBitmapTexture(writer, "Diffuse", texture);
            }

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Shininess", shininess);
            writer.WriteParameter("Transmitted Shininess", 128.0);
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Specular Sampling", false);
            writer.WriteParameter("Transmitted Sampling", false);
            writer.WriteParameter("Specular Attenuation", "Cosine");
            writer.WriteParameter("Transmitted Attenuation", "Cosine");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Returns the <paramref name="value"/> or the <paramref name="defaultValue"/> if the <paramref name="value"/> is NaN.
        /// </summary>
        /// <param name="value">
        /// The value.
        /// </param>
        /// <param name="defaultValue">
        /// The default value.
        /// </param>
        /// <returns>
        /// The value.
        /// </returns>
        public static double ValueOrDefault(double value, double defaultValue)
        {
            if (double.IsNaN(value))
            {
                return defaultValue;
            }

            return value;
        }

        /// <summary>
        /// Represents the output writer for the <see cref="KerkytheaExporter"/>.
        /// </summary>
        public class KerkytheaWriter
        {
            /// <summary>
            /// The writer
            /// </summary>
            private readonly XmlWriter writer;

            /// <summary>
            /// The names.
            /// </summary>
            private readonly HashSet<string> names = new HashSet<string>();

            /// <summary>
            /// Texture bitmaps are reused. This dictionary contains a map from brush to filename
            /// </summary>
            private readonly Dictionary<Brush, string> textureFiles = new Dictionary<Brush, string>();

            /// <summary>
            /// Initializes a new instance of the <see cref="KerkytheaWriter"/> class.
            /// </summary>
            /// <param name="stream">The stream.</param>
            public KerkytheaWriter(Stream stream)
            {
                var settings = new XmlWriterSettings { Indent = true };
                this.writer = XmlWriter.Create(stream, settings);
            }

            /// <summary>
            /// Writes the start element.
            /// </summary>
            /// <param name="localName">Name of the element.</param>
            public void WriteStartElement(string localName)
            {
                this.writer.WriteStartElement(localName);
            }

            /// <summary>
            /// Writes the attribute string.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="value">The value.</param>
            public void WriteAttributeString(string name, string value)
            {
                this.writer.WriteAttributeString(name, value);
            }

            /// <summary>
            /// Writes the end element.
            /// </summary>
            public void WriteEndElement()
            {
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes the full end element.
            /// </summary>
            public void WriteFullEndElement()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the start document.
            /// </summary>
            public void WriteStartDocument()
            {
                this.writer.WriteStartDocument();
            }

            /// <summary>
            /// Closes this instance.
            /// </summary>
            public void Close()
            {
                this.writer.Close();
            }

            /// <summary>
            /// Writes a parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string type, string value)
            {
                this.writer.WriteStartElement("Parameter");
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
                this.writer.WriteAttributeString("Value", value);
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes a string parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string value)
            {
                this.WriteParameter(name, "String", value);
            }

            /// <summary>
            /// Writes a color parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="color">
            /// The color.
            /// </param>
            public void WriteParameter(string name, Color color)
            {
                this.WriteParameter(name, "RGB", ToKerkytheaString(color));
            }

            /// <summary>
            /// Writes a boolean parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="flag">
            /// The flag.
            /// </param>
            public void WriteParameter(string name, bool flag)
            {
                this.WriteParameter(name, "Boolean", flag ? "1" : "0");
            }

            /// <summary>
            /// Writes a double parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, double value)
            {
                this.WriteParameter(name, "Real", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes an integer parameter.
            /// </summary>
            /// <param name="name">
            /// The parameter name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, int value)
            {
                this.WriteParameter(name, "Integer", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes a transformation matrix.
            /// </summary>
            /// <param name="name">
            /// The name of the matrix.
            /// </param>
            /// <param name="m">
            /// The matrix.
            /// </param>
            public void WriteTransform(string name, Matrix3D m)
            {
                string value = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} {6:0.######} {7:0.######} {8:0.######} {9:0.######} {10:0.######} {11:0.######}",
                    m.M11,
                    m.M12,
                    m.M13,
                    m.OffsetX,
                    m.M21,
                    m.M22,
                    m.M23,
                    m.OffsetY,
                    m.M31,
                    m.M32,
                    m.M33,
                    m.OffsetZ);

                this.WriteParameter(name, "Transform", value);
            }

            /// <summary>
            /// Writes the end object.
            /// </summary>
            public void WriteEndObject()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteObject(string identifier, string label, string name, string type)
            {
                this.WriteStartObject(identifier, label, name, type);
                this.WriteEndObject();
            }

            /// <summary>
            /// Writes the start object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteStartObject(string identifier, string label, string name, string type)
            {
                this.writer.WriteStartElement("Object");
                this.writer.WriteAttributeString("Identifier", identifier);
                this.writer.WriteAttributeString("Label", label);
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
            }

            /// <summary>
            /// Writes the end document.
            /// </summary>
            public void WriteEndDocument()
            {
                this.writer.WriteEndDocument();
            }

            /// <summary>
            /// Writes the specified XML node.
            /// </summary>
            /// <param name="xmlNode">The XML node.</param>
            public void Write(XmlNode xmlNode)
            {
                xmlNode.WriteTo(this.writer);
            }

            /// <summary>
            /// Tries to get the texture for the specified brush.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="textureFile">The texture file.</param>
            /// <returns><c>true</c> if the texture was found.</returns>
            public bool TryGetTexture(Brush brush, out string textureFile)
            {
                return this.textureFiles.TryGetValue(brush, out textureFile);
            }

            /// <summary>
            /// Adds the specified texture.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="filename">The filename.</param>
            public void AddTexture(Brush brush, string filename)
            {
                this.textureFiles.Add(brush, filename);
            }

            /// <summary>
            /// Gets a unique name.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="defaultName">The default name.</param>
            /// <returns></returns>
            public string GetUniqueName(string name, string defaultName)
            {
                if (string.IsNullOrEmpty(name))
                {
                    int n = 1;
                    while (true)
                    {
                        // name = defaultName + " #" + n;
                        name = defaultName + n;
                        if (!this.names.Contains(name))
                        {
                            break;
                        }

                        n++;
                    }
                }

                this.names.Add(name);
                return name;
            }
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;
    using System.Xml;

    /// <summary>
    /// Exports the 3D visual tree to a <a href="http://www.kerkythea.net/joomla">Kerkythea</a> input file.
    /// </summary>
    public class KerkytheaExporter : Exporter<KerkytheaExporter.KerkytheaWriter>
    {
        /// <summary>
        /// Dictionary of registered materials.
        /// </summary>
        private readonly Dictionary<Material, XmlDocument> registeredMaterials = new Dictionary<Material, XmlDocument>();

        /// <summary>
        /// Initializes a new instance of the <see cref="KerkytheaExporter"/> class.
        /// </summary>
        public KerkytheaExporter()
        {
            this.Name = "My Scene";
            this.BackgroundColor = Colors.Black;
            this.ReflectionColor = Colors.Gray;
            this.Reflections = true;
            this.Shadows = true;
            this.SoftShadows = true;
            this.LightMultiplier = 3.0;
            this.Threads = 2;

            this.ShadowColor = Color.FromArgb(255, 100, 100, 100);
            this.RenderSetting = RenderSettings.RayTracer;
            this.Aperture = "Pinhole";
            this.FocusDistance = 1.0;
            this.LensSamples = 3;

            this.Width = 500;
            this.Height = 500;

            this.TextureWidth = 1024;
            this.TextureHeight = 1024;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Render settings.
        /// </summary>
        public enum RenderSettings
        {
            /// <summary>
            /// Use RayTracer.
            /// </summary>
            RayTracer,

            /// <summary>
            /// Use PhotonMap.
            /// </summary>
            PhotonMap,

            /// <summary>
            /// Use MetropolisLightTransport.
            /// </summary>
            MetropolisLightTransport
        }

        /// <summary>
        /// Gets or sets the aperture.
        /// </summary>
        /// <value>The aperture.</value>
        public string Aperture { get; set; }

        /// <summary>
        /// Gets or sets the color of the background.
        /// </summary>
        /// <value>The color of the background.</value>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Gets or sets the texture file creator.
        /// </summary>
        /// <value>The file creator.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets the length of the focal.
        /// </summary>
        /// <value>The length of the focal.</value>
        public double FocalLength { get; set; }

        /// <summary>
        /// Gets or sets the focus distance.
        /// </summary>
        /// <value>The focus distance.</value>
        public double FocusDistance { get; set; }

        /// <summary>
        /// Gets or sets the height.
        /// </summary>
        /// <value>The height.</value>
        public int Height { get; set; }

        /// <summary>
        /// Gets or sets the lens samples.
        /// </summary>
        /// <value>The lens samples.</value>
        public int LensSamples { get; set; }

        /// <summary>
        /// Gets or sets the light multiplier.
        /// </summary>
        /// <value>The light multiplier.</value>
        public double LightMultiplier { get; set; }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the color of the reflection.
        /// </summary>
        /// <value>The color of the reflection.</value>
        public Color ReflectionColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is reflections.
        /// </summary>
        /// <value><c>true</c> if reflections; otherwise, <c>false</c>.</value>
        public bool Reflections { get; set; }

        /// <summary>
        /// Gets or sets the render setting.
        /// </summary>
        /// <value>The render setting.</value>
        public RenderSettings RenderSetting { get; set; }

        /// <summary>
        /// Gets or sets the color of the shadow.
        /// </summary>
        /// <value>The color of the shadow.</value>
        public Color ShadowColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is shadows.
        /// </summary>
        /// <value><c>true</c> if shadows; otherwise, <c>false</c>.</value>
        public bool Shadows { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether [soft shadows].
        /// </summary>
        /// <value><c>true</c> if [soft shadows]; otherwise, <c>false</c>.</value>
        public bool SoftShadows { get; set; }

        /// <summary>
        /// Gets or sets the height of the texture.
        /// </summary>
        /// <value>The height of the texture.</value>
        public int TextureHeight { get; set; }

        /// <summary>
        /// Gets or sets the texture path.
        /// </summary>
        /// <value>The texture path.</value>
        public string TexturePath { get; set; }

        /// <summary>
        /// Gets or sets the width of the texture.
        /// </summary>
        /// <value>The width of the texture.</value>
        public int TextureWidth { get; set; }

        /// <summary>
        /// Gets or sets the threads.
        /// </summary>
        /// <value>The threads.</value>
        public int Threads { get; set; }

        /// <summary>
        /// Gets or sets the width.
        /// </summary>
        /// <value>The width.</value>
        public int Width { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        public void ExportMesh(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartObject("Triangular Mesh", "Triangular Mesh", string.Empty, "Surface");

            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Vertex List");
                writer.WriteAttributeString("Type", "Point3D List");
                writer.WriteAttributeString("Value", m.Positions.Count.ToString());
                foreach (var p in m.Positions)
                {
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xyz", ToKerkytheaString(p));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            int triangles = m.TriangleIndices.Count / 3;

            // NORMALS
            // todo: write normal list per vertex instead of per triangle index
            if (m.Normals != null && m.Normals.Count > 0)
            {
                writer.WriteStartElement("Parameter");
                {
                    writer.WriteAttributeString("Name", "Normal List");
                    writer.WriteAttributeString("Type", "Point3D List");
                    writer.WriteAttributeString("Value", m.TriangleIndices.Count.ToString());
                    foreach (int index in m.TriangleIndices)
                    {
                        if (index >= m.Normals.Count)
                        {
                            continue;
                        }

                        var n = m.Normals[index];
                        writer.WriteStartElement("P");
                        writer.WriteAttributeString("xyz", ToKerkytheaString(n));
                        writer.WriteEndElement();
                    }
                }

                writer.WriteFullEndElement();
            }

            // TRIANGLE INDICES
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Index List");
                writer.WriteAttributeString("Type", "Triangle Index List");
                writer.WriteAttributeString("Value", triangles.ToString());
                for (int a = 0; a < triangles; a++)
                {
                    int a3 = a * 3;
                    int i = m.TriangleIndices[a3];
                    int j = m.TriangleIndices[a3 + 1];
                    int k = m.TriangleIndices[a3 + 2];
                    writer.WriteStartElement("F");
                    writer.WriteAttributeString("ijk", string.Format("{0} {1} {2}", i, j, k));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            writer.WriteParameter("Smooth", true);
            writer.WriteParameter("AA Tolerance", 15.0);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Registers a material.
        /// </summary>
        /// <param name="m">The material to register.</param>
        /// <param name="stream">The material stream.</param>
        public void RegisterMaterial(Material m, Stream stream)
        {
            var doc = new XmlDocument();
            doc.Load(stream);
            this.registeredMaterials.Add(m, doc);
        }

        /// <summary>
        /// Writes the Metropolis Light Transport properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the MLP ray tracer.</param>
        public void WriteMetropolisLightTransport(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Metropolis Light Transport", name, "Ray Tracer");
            writer.WriteParameter("Max Ray Tracing Depth", 100);
            writer.WriteParameter("Max Iterations", 10000);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Seed Paths", 50000);
            writer.WriteParameter("Large Step Probability", 0.2);
            writer.WriteParameter("Max Mutation Distance", 0.02);
            writer.WriteParameter("Live Probability", 0.7);
            writer.WriteParameter("Max Consecutive Rejections", 200);
            writer.WriteParameter("Bidirectional", true);
            writer.WriteParameter("Super Sampling", "3x3");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("Random Seed", "Automatic");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the standard ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the ray tracer.</param>
        public void WriteStandardRayTracer(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Standard Ray Tracer", name, "Ray Tracer");
            writer.WriteParameter("Rasterization", "Auto");

            // WriteParameter("Antialiasing", "Extra Pass 3x3");
            writer.WriteParameter("Antialiasing", "Production AA");
            writer.WriteParameter("Antialiasing Filter", "Mitchell-Netravali 0.5 0.8");
            writer.WriteParameter("Antialiasing Threshold", 0.3);
            writer.WriteParameter("Texture Filtering", true);
            writer.WriteParameter("Ambient Lighting", true);
            writer.WriteParameter("Direct Lighting", true);
            writer.WriteParameter("Sky Lighting", true);
            writer.WriteParameter("Brightness Threshold", 0.002);
            writer.WriteParameter("Max Ray Tracing Depth", 5);
            writer.WriteParameter("Max Scatter Bounces", 5);
            writer.WriteParameter("Max Dirac Bounces", 5);
            writer.WriteParameter("Irradiance Precomputation", 4);
            writer.WriteParameter("Irradiance Scale", Colors.White);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Max Iterations", 5);
            writer.WriteParameter("Super Sampling", "None");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("./Sampling Criteria/Diffuse Samples", 1024);
            writer.WriteParameter("./Sampling Criteria/Specular Samples", 32);
            writer.WriteParameter("./Sampling Criteria/Dispersion Samples", true);
            writer.WriteParameter("./Sampling Criteria/Trace Diffusers", false);
            writer.WriteParameter("./Sampling Criteria/Trace Translucencies", false);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Trace Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Random Generator", "Pure");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the threaded ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="threads">The number of threads.</param>
        public void WriteThreadedRaytracer(KerkytheaWriter writer, int threads)
        {
            writer.WriteStartObject("./Ray Tracers/Threaded Ray Tracer", "Threaded Ray Tracer", "Threaded Ray Tracer", "Ray Tracer");
            for (int i = 0; i < threads; i++)
            {
                writer.WriteParameter("Thread #" + i, "#" + i);
            }

            writer.WriteParameter("Network Mode", "None");
            writer.WriteParameter("Listening Port", 6200);
            writer.WriteParameter("Host", "127.0.0.1");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Creates the writer for the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>The writer.</returns>
        protected override KerkytheaWriter Create(Stream stream)
        {
            return new KerkytheaWriter(stream);
        }

        /// <summary>
        /// Exports the camera.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="c">The camera.</param>
        /// <exception cref="System.InvalidOperationException">Only perspective cameras are supported.</exception>
        protected override void ExportCamera(KerkytheaWriter writer, Camera c)
        {
            var pc = c as PerspectiveCamera;
            if (pc == null)
            {
                throw new InvalidOperationException("Only perspective cameras are supported.");
            }

            const string name = "Camera #1";
            writer.WriteStartObject("./Cameras/" + name, "Pinhole Camera", name, "Camera");

            // FOV = 2 arctan (x / (2 f)), x is diagonal, f is focal length
            // f = x / 2 / Tan(FOV/2)
            // http://en.wikipedia.org/wiki/Angle_of_view
            // http://kmp.bdimitrov.de/technology/fov.html

            // PerspectiveCamera.FieldOfView: Horizontal field of view
            // Must multiply by ratio of Viewport Width/Height
            double ratio = this.Width / (double)this.Height;
            const double x = 40;
            double f = 0.5 * ratio * x / Math.Tan(0.5 * pc.FieldOfView / 180.0 * Math.PI);

            writer.WriteParameter("Focal Length (mm)", f);
            writer.WriteParameter("Film Height (mm)", x);
            writer.WriteParameter("Resolution", string.Format(CultureInfo.InvariantCulture, "{0}x{1}", this.Width, this.Height));

            var t = CreateTransform(pc.Position, pc.LookDirection, pc.UpDirection);
            writer.WriteTransform("Frame", t);

            writer.WriteParameter("Focus Distance", this.FocusDistance);
            writer.WriteParameter("f-number", this.Aperture);
            writer.WriteParameter("Lens Samples", this.LensSamples);
            writer.WriteParameter("Blades", 6);
            writer.WriteParameter("Diaphragm", "Circular");
            writer.WriteParameter("Projection", "Planar");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the document header.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void ExportHeader(KerkytheaWriter writer)
        {
            writer.WriteStartDocument();

            writer.WriteStartElement("Root");
            writer.WriteAttributeString("Label", "Default Kernel");
            writer.WriteAttributeString("Name", string.Empty);
            writer.WriteAttributeString("Type", "Kernel");

            writer.WriteStartObject("./Modellers/XML Modeller", "XML Modeller", "XML Modeller", "Modeller");
            writer.WriteEndObject();

            writer.WriteStartObject("./Image Handlers/Free Image Support", "Free Image Support", "Free Image Support", "Image Handler");
            writer.WriteParameter("Tone Mapping", "External");
            writer.WriteParameter("Jpeg Quality", "Higher");
            writer.WriteEndObject();

            writer.WriteStartObject("./Direct Light Estimators/Refraction Enhanced", "Refraction Enhanced", "Refraction Enhanced", "Direct Light Estimator");
            writer.WriteParameter("Enabled", "Boolean", "1");
            writer.WriteParameter("PseudoCaustics", "Boolean", "0");
            writer.WriteParameter("PseudoTranslucencies", "Boolean", "0");
            writer.WriteParameter("Area Light Evaluation", "Boolean", "1");
            writer.WriteParameter("Optimized Area Lights", "Boolean", "1");
            writer.WriteParameter("Accurate Soft Shadows", "Boolean", "0");
            writer.WriteParameter("Antialiasing", "String", "High");
            writer.WriteParameter("./Evaluation/Diffuse", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Specular", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Translucent", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Transmitted", "Boolean", "1");
            writer.WriteEndObject();

            // add ray tracer module.
            for (int i = 0; i < this.Threads; i++)
            {
                this.WriteStandardRayTracer(writer, "#" + i);
            }

            this.WriteThreadedRaytracer(writer, this.Threads);

            // add spatial subdivision module.
            writer.WriteStartObject("./Environments/Octree Environment", "Octree Environment", "Octree Environment", "Environment");
            writer.WriteParameter("Max Objects per Cell", 20);
            writer.WriteParameter("Instancing Switch", 1000000);
            writer.WriteParameter("Caching Switch", 6000000);
            writer.WriteEndObject();

            // add basic post filtering / tone mapping.
            writer.WriteStartObject("./Filters/Simple Tone Mapping", "Simple Tone Mapping", string.Empty, "Filter");
            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Method", "Simple");
            writer.WriteParameter("Exposure", 1.0);
            writer.WriteParameter("Gamma", 1.0);
            writer.WriteParameter("Dark Multiplier", 1.0);
            writer.WriteParameter("Bright Multiplier", 1.0);
            writer.WriteParameter("Reverse Correction", true);
            writer.WriteParameter("Reverse Gamma", 2.2);
            writer.WriteEndObject();

            // start of scene description.
            writer.WriteStartObject("./Scenes/" + this.Name, "Default Scene", this.Name, "Scene");
        }

        /// <summary>
        /// Exports the light.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="l">The light.</param>
        /// <param name="t">The transform.</param>
        protected override void ExportLight(KerkytheaWriter writer, Light l, Transform3D t)
        {
            if (l is AmbientLight)
            {
                return;
            }

            string name = this.GetUniqueName(writer, l, l.GetType().Name);

            writer.WriteStartObject("./Lights/" + name, "Default Light", name, "Light");
            {
                string stype = "Projector Light";

                if (l is SpotLight s)
                {
                    stype = "Spot Light";
                }

                if (l is PointLight p)
                {
                    stype = "Omni Light";
                }

                writer.WriteStartObject(stype, stype, string.Empty, "Emittance");

                // emitter Radiance
                writer.WriteStartObject("./Radiance/Constant Texture", "Constant Texture", string.Empty, "Texture");
                var c = Colors.White;
                writer.WriteParameter("Color", c);
                writer.WriteEndObject();

                // var v = new Vector3D(l.Color.R, l.Color.G, l.Color.B);
                // double lum = v.Length;
                writer.WriteParameter("Attenuation", "None");

                // SpotLight (Spot Light)
                if (l is SpotLight s)
                {
                    // todo : export the specular parameters
                    // s.ConstantAttenuation
                    // s.LinearAttenuation
                    // s.QuadraticAttenuation
                    writer.WriteParameter("Fall Off", s.OuterConeAngle);
                    writer.WriteParameter("Hot Spot", s.InnerConeAngle);
                }

                // DirectionalLight (Projector Light)
                if (l is DirectionalLight d)
                {
                    writer.WriteParameter("Width", 2.0);
                    writer.WriteParameter("Height", 2.0);
                }

                // PointLight (Omni light)
                if (l is PointLight p)
                {
                    // todo: export pointlight parameters
                    // name.ConstantAttenuation
                    // name.LinearAttenuation
                    // name.QuadraticAttenuation
                    // name.Range // distance beyond which the light has no effect
                }

                writer.WriteParameter("Focal Length", 1.0);

                writer.WriteEndObject(); // stype

                writer.WriteParameter("Enabled", true);
                writer.WriteParameter("Shadow", this.Shadows);
                writer.WriteParameter("Soft Shadow", this.SoftShadows);

                writer.WriteParameter("Negative Light", false);
                writer.WriteParameter("Global Photons", true);
                writer.WriteParameter("Caustic Photons", true);
                writer.WriteParameter("Multiplier", this.LightMultiplier);

                Matrix3D transform;
                var upVector = new Vector3D(0, 0, 1);

                if (l is SpotLight s)
                {
                    transform = CreateTransform(s.Position, s.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (l is DirectionalLight d)
                {
                    var origin = new Point3D(-1000 * d.Direction.X, -1000 * d.Direction.Y, -1000 * d.Direction.Z);
                    transform = CreateTransform(origin, d.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (l is PointLight p)
                {
                    var direction = new Vector3D(-p.Position.X, -p.Position.Y, -p.Position.Z);
                    transform = CreateTransform(p.Position, direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                writer.WriteParameter("Focus Distance", 4.0);
                writer.WriteParameter("Radius", 0.2);
                writer.WriteParameter("Shadow Color", this.ShadowColor);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="g">The model geometry.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(KerkytheaWriter writer, GeometryModel3D g, Transform3D transform)
        {
            var mesh = g.Geometry as MeshGeometry3D;
            if (mesh == null)
            {
                return;
            }

            string name = this.GetUniqueName(writer, g, g.GetType().Name);
            writer.WriteStartObject("./Models/" + name, "Default Model", name, "Model");

            this.ExportMesh(writer, mesh);

            if (g.Material != null)
            {
                this.ExportMaterial(writer, g.Material);
            }

            var tg = new Transform3DGroup();
            tg.Children.Add(g.Transform);
            tg.Children.Add(transform);

            if (mesh.TextureCoordinates != null)
            {
                this.ExportMapChannel(writer, mesh);
            }

            writer.WriteTransform("Frame", tg.Value);

            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Visible", true);
            writer.WriteParameter("Shadow Caster", true);
            writer.WriteParameter("Shadow Receiver", true);
            writer.WriteParameter("Caustics Transmitter", true);
            writer.WriteParameter("Caustics Receiver", true);
            writer.WriteParameter("Exit Blocker", false);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="v">The viewport to export.</param>
        protected override void ExportViewport(KerkytheaWriter writer, Viewport3D v)
        {
            var ambient = Visual3DHelper.Find<AmbientLight>(v);

            // default global settings
            writer.WriteStartObject("Default Global Settings", "Default Global Settings", string.Empty, "Global Settings");
            if (ambient != null)
            {
                writer.WriteParameter("Ambient Light", ambient.Color);
            }

            writer.WriteParameter("Background Color", this.BackgroundColor);
            writer.WriteParameter("Compute Volume Transfer", false);
            writer.WriteParameter("Transfer Recursion Depth", 1);
            writer.WriteParameter("Background Type", "Sky Color");
            writer.WriteParameter("Sky Intensity", 1.0);
            writer.WriteParameter("Sky Frame", "Transform", "1 0 0 0 0 1 0 0 0 0 1 0 ");
            writer.WriteParameter("Sun Direction", "0 0 1");
            writer.WriteParameter("Sky Turbidity", 2.0);
            writer.WriteParameter("Sky Luminance Gamma", 1.2);
            writer.WriteParameter("Sky Chromaticity Gamma", 1.8);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Index of Refraction", 1.0);
            writer.WriteParameter("Scatter Density", 0.1);
            writer.WriteParameter("./Location/Latitude", 0.0);
            writer.WriteParameter("./Location/Longitude", 0.0);
            writer.WriteParameter("./Location/Timezone", 0);
            writer.WriteParameter("./Location/Date", "0/0/2007");
            writer.WriteParameter("./Location/Time", "12:0:0");
            writer.WriteParameter("./Background Image/Filename", "[No Bitmap]");
            writer.WriteParameter("./Background Image/Projection", "UV");
            writer.WriteParameter("./Background Image/Offset X", 0.0);
            writer.WriteParameter("./Background Image/Offset Y", 0.0);
            writer.WriteParameter("./Background Image/Scale X", 1.0);
            writer.WriteParameter("./Background Image/Scale Y", 1.0);
            writer.WriteParameter("./Background Image/Rotation", 0.0);
            writer.WriteParameter("./Background Image/Smooth", true);
            writer.WriteParameter("./Background Image/Inverted", false);
            writer.WriteParameter("./Background Image/Alpha Channel", false);
            writer.WriteEndObject();

            // Visual3DHelper.Traverse<Light>(v.Children, ExportLight);
            // Visual3DHelper.Traverse<GeometryModel3D>(v.Children, ExportGeometryModel3D);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(KerkytheaWriter writer)
        {
            // end of scene description.
            writer.WriteFullEndElement();

            // it is necessary to describe the primary/active modules as there might exist more than one!
            writer.WriteParameter("Mip Mapping", true);
            writer.WriteParameter("./Interfaces/Active", "Null Interface");
            writer.WriteParameter("./Modellers/Active", "XML Modeller");
            writer.WriteParameter("./Image Handlers/Active", "Free Image Support");

            writer.WriteParameter("./Ray Tracers/Active", "Threaded Ray Tracer");
            writer.WriteParameter("./Irradiance Estimators/Active", "Null Irradiance Estimator");
            writer.WriteParameter("./Direct Light Estimators/Active", "Refraction Enhanced");
            writer.WriteParameter("./Environments/Active", "Octree Environment");
            writer.WriteParameter("./Filters/Active", "Simple Tone Mapping");
            writer.WriteParameter("./Scenes/Active", this.Name);
            writer.WriteParameter("./Libraries/Active", "Material Librarian");

            // end of root element
            writer.WriteFullEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        /// <summary>
        /// Creates a transform from the original coordinate system to the system defined by translation origin
        /// </summary>
        /// <param name="origin">The origin.</param>
        /// <param name="direction">The direction vector.</param>
        /// <param name="up">The up vector.</param>
        /// <returns>A transformation matrix.</returns>
        private static Matrix3D CreateTransform(Point3D origin, Vector3D direction, Vector3D up)
        {
            var z = direction;
            var x = Vector3D.CrossProduct(direction, up);
            var y = up;

            x.Normalize();
            y.Normalize();
            z.Normalize();

            var m = new Matrix3D(x.X, y.X, z.X, 0, x.Y, y.Y, z.Y, 0, x.Z, y.Z, z.Z, 0, origin.X, origin.Y, origin.Z, 1);

            return m;
        }

        /// <summary>
        /// Converts a <see cref="Point"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="p">
        /// The point.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point p)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0} {1}", p.X, p.Y);
        }

        /// <summary>
        /// Converts a <see cref="Point3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="point">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point3D point)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(point.X, 1),
                ValueOrDefault(point.Y, 0),
                ValueOrDefault(point.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Vector3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="vector">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the vector.
        /// </returns>
        private static string ToKerkytheaString(Vector3D vector)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(vector.X, 1),
                ValueOrDefault(vector.Y, 0),
                ValueOrDefault(vector.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Color"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="c">
        /// The color.
        /// </param>
        /// <returns>
        /// A string representing the color.
        /// </returns>
        private static string ToKerkytheaString(Color c)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                c.R / 255.0,
                c.G / 255.0,
                c.B / 255.0);
        }

        /// <summary>
        /// Exports the map channel (texture coordinates) from the specified mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        private void ExportMapChannel(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Map Channel");
                writer.WriteAttributeString("Type", "Point2D List");
                int n = m.TriangleIndices.Count;
                writer.WriteAttributeString("Value", n.ToString());
                foreach (int index in m.TriangleIndices)
                {
                    if (index >= m.TextureCoordinates.Count)
                    {
                        continue;
                    }

                    var uv = m.TextureCoordinates[index];
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xy", ToKerkytheaString(uv));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Exports a material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the material.</param>
        /// <param name="material">The material.</param>
        /// <param name="weights">The weights.</param>
        private void ExportMaterial(KerkytheaWriter writer, string name, Material material, IList<double> weights)
        {
            if (material is MaterialGroup g)
            {
                foreach (var m in g.Children)
                {
                    this.ExportMaterial(writer, name, m, weights);
                }
            }

            if (material is DiffuseMaterial d)
            {
                string texture = null;
                Color? color = null;
                double alpha = 1.0;
                if (d.Brush is SolidColorBrush)
                {
                    color = this.GetSolidColor(d.Brush, d.Color);
                    alpha = color.Value.A / 255.0;
                }
                else
                {
                    texture = this.GetTexture(writer, d.Brush, name);
                }

                if (alpha > 0)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), texture, color, null, null);
                    weights.Add(alpha);
                }

                // The refractive part
                if (alpha < 1)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, null, Colors.White);
                    weights.Add(1 - alpha);
                }
            }

            if (material is SpecularMaterial s)
            {
                var color = this.GetSolidColor(s.Brush, s.Color);

                // color = Color.FromArgb((byte)(color.A * factor), (byte)(color.R * factor), (byte)(color.G * factor), (byte)(color.B * factor));
                this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, color, null, s.SpecularPower * 0.5);
                double weight = color.A / 255.0;
                weight *= 0.01;
                weights.Add(weight);
            }

            if (material is EmissiveMaterial e)
            {
                // TODO
                System.Diagnostics.Debug.WriteLine("KerkytheaExporter: Emissive materials are not yet supported.");

                // Color color = GetSolidColor(e.Brush, d.Color);
                // WriteWhittedMaterial(string.Format("#{0}", weights.Count + 1), color, null, null);
                // WriteStartObject("./Translucent/Constant Texture", "Constant Texture", "", "Texture");
                // WriteParameter("Color", e.Color);
                // WriteEndObject();
            }
        }

        /// <summary>
        /// Exports the specified material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="material">The material.</param>
        private void ExportMaterial(KerkytheaWriter writer, Material material)
        {
            // If the material is registered, simply output the xml
            if (this.registeredMaterials.ContainsKey(material))
            {
                var doc = this.registeredMaterials[material];
                if (doc?.DocumentElement != null)
                {
                    foreach (XmlNode e in doc.DocumentElement.ChildNodes)
                    {
                        writer.Write(e);
                    }
                }

                return;
            }

            string name = this.GetUniqueName(writer, material, "Material");
            writer.WriteStartObject(name, "Layered Material", name, "Material");

            var weights = new List<double>();

            this.ExportMaterial(writer, name, material, weights);

            // if (Reflections)
            // {
            // WriteConstantTexture("Reflection", ReflectionColor);
            // }
            for (int i = 0; i < weights.Count; i++)
            {
                this.WriteWeight(writer, "Weight #" + i, weights[i]);
            }

            /*
             switch (MaterialType)
             {
                 case MaterialTypes.Ashikhmin:
                     this.WriteParameter("Rotation", 0.0);
                     this.WriteParameter("Attenuation", "Schlick");
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("N-K File", "");
                     break;
                 case MaterialTypes.Diffusive: // Whitted material
                     this.WriteParameter("Shininess", 60.0);
                     this.WriteParameter("Transmitted Shininess", 128.0);
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("Specular Sampling", true);
                     this.WriteParameter("Transmitted Sampling", false);
                     this.WriteParameter("Specular Attenuation", "Cosine");
                     this.WriteParameter("Transmitted Attenuation", "Cosine");
                     break;
             }
             */
            writer.WriteEndObject();
        }

        /// <summary>
        /// Gets the solid color from a brush.
        /// </summary>
        /// <param name="brush">
        /// The brush.
        /// </param>
        /// <param name="defaultColor">
        /// The default color (used if the specified brush is not a <see cref="SolidColorBrush"/>).
        /// </param>
        /// <returns>
        /// The color.
        /// </returns>
        private Color GetSolidColor(Brush brush, Color defaultColor)
        {
            if (brush is SolidColorBrush scb)
            {
                return scb.Color;
            }

            return defaultColor;
        }

        /// <summary>
        /// Gets the texture for a brush.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="brush">The brush.</param>
        /// <param name="name">The name of the material.</param>
        /// <returns>
        /// The texture filename.
        /// </returns>
        private string GetTexture(KerkytheaWriter writer, Brush brush, string name)
        {
            // reuse textures
            string textureFile;
            if (writer.TryGetTexture(brush, out textureFile))
            {
                return textureFile;
            }

            string filename = name + ".png";
            string path = Path.Combine(this.TexturePath, filename);
            using (var s = this.FileCreator(path))
            {
                this.RenderBrush(s, brush, this.TextureWidth, this.TextureHeight);
            }

            writer.AddTexture(brush, filename);
            return filename;
        }

        /// <summary>
        /// Gets a unique name.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="o">The object.</param>
        /// <param name="defaultName">The default name.</param>
        /// <returns>A unique name.</returns>
        private string GetUniqueName(KerkytheaWriter writer, DependencyObject o, string defaultName)
        {
            var name = o.GetValue(FrameworkElement.NameProperty) as string;
            return writer.GetUniqueName(name, defaultName);
        }

        /// <summary>
        /// Writes a ashikhmin material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="shininessXMap">The shininess x map.</param>
        /// <param name="shininessYMap">The shininess y map.</param>
        /// <param name="rotationMap">The rotation map.</param>
        /// <param name="shininessX">The shininess x.</param>
        /// <param name="shininessY">The shininess y.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteAshikhminMaterial(KerkytheaWriter writer,
            string identifier,
            Color? diffuse,
            Color? specular,
            Color? shininessXMap,
            Color? shininessYMap,
            Color? rotationMap,
            double shininessX = 100,
            double shininessY = 100,
            double rotation = 0,
            double indexOfRefraction = 1.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (shininessXMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess X Map", shininessXMap.Value);
            }

            if (shininessYMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess Y Map", shininessYMap.Value);
            }

            if (rotationMap.HasValue)
            {
                this.WriteConstantTexture(writer, "RotationMap", rotationMap.Value);
            }

            writer.WriteParameter("Shininess X", shininessX);
            writer.WriteParameter("Shininess Y", shininessY);
            writer.WriteParameter("Rotation", rotation);
            writer.WriteParameter("Attenuation", "Schlick");
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("N-K File", nkfile);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a bitmap texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="filename">The filename.</param>
        private void WriteBitmapTexture(KerkytheaWriter writer, string name, string filename)
        {
            if (!string.IsNullOrEmpty(filename))
            {
                writer.WriteStartObject("./" + name + "/Bitmap Texture", "Bitmap Texture", string.Empty, "Texture");
                writer.WriteParameter("Filename", filename);
                writer.WriteParameter("Projection", "UV");
                writer.WriteParameter("Offset X", 0.0);
                writer.WriteParameter("Offset Y", 0.0);
                writer.WriteParameter("Scale X", 1.0);
                writer.WriteParameter("Scale Y", 1.0);
                writer.WriteParameter("Rotation", 0.0);
                writer.WriteParameter("Smooth", true);
                writer.WriteParameter("Inverted", false);
                writer.WriteParameter("Alpha Channel", false);
                writer.WriteEndObject();
            }
        }

        /// <summary>
        /// Writes a constant texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="color">The color.</param>
        private void WriteConstantTexture(KerkytheaWriter writer, string name, Color color)
        {
            writer.WriteStartObject("./" + name + "/Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", color);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a dielectric material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="reflection">The reflection.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="dispersion">The dispersion.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteDielectricMaterial(KerkytheaWriter writer,
            string identifier,
            Color? reflection,
            Color? refraction,
            double indexOfRefraction = 1.0,
            double dispersion = 0.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (reflection.HasValue)
            {
                this.WriteConstantTexture(writer, "Reflection", reflection.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Dispersion", dispersion);
            writer.WriteParameter("N-K File", string.Empty);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a weight.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="weight">The weight.</param>
        private void WriteWeight(KerkytheaWriter writer, string identifier, double weight)
        {
            writer.WriteStartObject(identifier, "Weighted Texture", identifier, "Texture");
            writer.WriteStartObject("Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", Colors.White);
            writer.WriteEndObject();
            writer.WriteParameter("Weight #0", weight);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a whitted material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="texture">The texture.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="shininess">The shininess.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        private void WriteWhittedMaterial(KerkytheaWriter writer,
            string identifier,
            string texture,
            Color? diffuse,
            Color? specular,
            Color? refraction,
            double shininess = 128.0,
            double indexOfRefraction = 1.0)
        {
            writer.WriteStartObject(identifier, "Whitted Material", identifier, "Material");

            if (texture != null)
            {
                this.WriteBitmapTexture(writer, "Diffuse", texture);
            }

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Shininess", shininess);
            writer.WriteParameter("Transmitted Shininess", 128.0);
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Specular Sampling", false);
            writer.WriteParameter("Transmitted Sampling", false);
            writer.WriteParameter("Specular Attenuation", "Cosine");
            writer.WriteParameter("Transmitted Attenuation", "Cosine");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Returns the <paramref name="value"/> or the <paramref name="defaultValue"/> if the <paramref name="value"/> is NaN.
        /// </summary>
        /// <param name="value">
        /// The value.
        /// </param>
        /// <param name="defaultValue">
        /// The default value.
        /// </param>
        /// <returns>
        /// The value.
        /// </returns>
        public static double ValueOrDefault(double value, double defaultValue)
        {
            if (double.IsNaN(value))
            {
                return defaultValue;
            }

            return value;
        }

        /// <summary>
        /// Represents the output writer for the <see cref="KerkytheaExporter"/>.
        /// </summary>
        public class KerkytheaWriter
        {
            /// <summary>
            /// The writer
            /// </summary>
            private readonly XmlWriter writer;

            /// <summary>
            /// The names.
            /// </summary>
            private readonly HashSet<string> names = new HashSet<string>();

            /// <summary>
            /// Texture bitmaps are reused. This dictionary contains a map from brush to filename
            /// </summary>
            private readonly Dictionary<Brush, string> textureFiles = new Dictionary<Brush, string>();

            /// <summary>
            /// Initializes a new instance of the <see cref="KerkytheaWriter"/> class.
            /// </summary>
            /// <param name="stream">The stream.</param>
            public KerkytheaWriter(Stream stream)
            {
                var settings = new XmlWriterSettings { Indent = true };
                this.writer = XmlWriter.Create(stream, settings);
            }

            /// <summary>
            /// Writes the start element.
            /// </summary>
            /// <param name="localName">Name of the element.</param>
            public void WriteStartElement(string localName)
            {
                this.writer.WriteStartElement(localName);
            }

            /// <summary>
            /// Writes the attribute string.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="value">The value.</param>
            public void WriteAttributeString(string name, string value)
            {
                this.writer.WriteAttributeString(name, value);
            }

            /// <summary>
            /// Writes the end element.
            /// </summary>
            public void WriteEndElement()
            {
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes the full end element.
            /// </summary>
            public void WriteFullEndElement()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the start document.
            /// </summary>
            public void WriteStartDocument()
            {
                this.writer.WriteStartDocument();
            }

            /// <summary>
            /// Closes this instance.
            /// </summary>
            public void Close()
            {
                this.writer.Close();
            }

            /// <summary>
            /// Writes a parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string type, string value)
            {
                this.writer.WriteStartElement("Parameter");
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
                this.writer.WriteAttributeString("Value", value);
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes a string parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string value)
            {
                this.WriteParameter(name, "String", value);
            }

            /// <summary>
            /// Writes a color parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="color">
            /// The color.
            /// </param>
            public void WriteParameter(string name, Color color)
            {
                this.WriteParameter(name, "RGB", ToKerkytheaString(color));
            }

            /// <summary>
            /// Writes a boolean parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="flag">
            /// The flag.
            /// </param>
            public void WriteParameter(string name, bool flag)
            {
                this.WriteParameter(name, "Boolean", flag ? "1" : "0");
            }

            /// <summary>
            /// Writes a double parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, double value)
            {
                this.WriteParameter(name, "Real", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes an integer parameter.
            /// </summary>
            /// <param name="name">
            /// The parameter name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, int value)
            {
                this.WriteParameter(name, "Integer", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes a transformation matrix.
            /// </summary>
            /// <param name="name">
            /// The name of the matrix.
            /// </param>
            /// <param name="m">
            /// The matrix.
            /// </param>
            public void WriteTransform(string name, Matrix3D m)
            {
                string value = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} {6:0.######} {7:0.######} {8:0.######} {9:0.######} {10:0.######} {11:0.######}",
                    m.M11,
                    m.M12,
                    m.M13,
                    m.OffsetX,
                    m.M21,
                    m.M22,
                    m.M23,
                    m.OffsetY,
                    m.M31,
                    m.M32,
                    m.M33,
                    m.OffsetZ);

                this.WriteParameter(name, "Transform", value);
            }

            /// <summary>
            /// Writes the end object.
            /// </summary>
            public void WriteEndObject()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteObject(string identifier, string label, string name, string type)
            {
                this.WriteStartObject(identifier, label, name, type);
                this.WriteEndObject();
            }

            /// <summary>
            /// Writes the start object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteStartObject(string identifier, string label, string name, string type)
            {
                this.writer.WriteStartElement("Object");
                this.writer.WriteAttributeString("Identifier", identifier);
                this.writer.WriteAttributeString("Label", label);
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
            }

            /// <summary>
            /// Writes the end document.
            /// </summary>
            public void WriteEndDocument()
            {
                this.writer.WriteEndDocument();
            }

            /// <summary>
            /// Writes the specified XML node.
            /// </summary>
            /// <param name="xmlNode">The XML node.</param>
            public void Write(XmlNode xmlNode)
            {
                xmlNode.WriteTo(this.writer);
            }

            /// <summary>
            /// Tries to get the texture for the specified brush.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="textureFile">The texture file.</param>
            /// <returns><c>true</c> if the texture was found.</returns>
            public bool TryGetTexture(Brush brush, out string textureFile)
            {
                return this.textureFiles.TryGetValue(brush, out textureFile);
            }

            /// <summary>
            /// Adds the specified texture.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="filename">The filename.</param>
            public void AddTexture(Brush brush, string filename)
            {
                this.textureFiles.Add(brush, filename);
            }

            /// <summary>
            /// Gets a unique name.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="defaultName">The default name.</param>
            /// <returns></returns>
            public string GetUniqueName(string name, string defaultName)
            {
                if (string.IsNullOrEmpty(name))
                {
                    int n = 1;
                    while (true)
                    {
                        // name = defaultName + " #" + n;
                        name = defaultName + n;
                        if (!this.names.Contains(name))
                        {
                            break;
                        }

                        n++;
                    }
                }

                this.names.Add(name);
                return name;
            }
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(537,36): error CS0128: A local variable or function named 's' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(555,37): error CS0128: A local variable or function named 'p' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(580,36): error CS0128: A local variable or function named 's' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(586,43): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(593,37): error CS0128: A local variable or function named 'p' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(543,55): error CS0165: Use of unassigned local variable 's',D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(588,54): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(595,51): error CS0165: Use of unassigned local variable 'p'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter<ObjExporter.ObjWriters>
    {
        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<Material, string> exportedMaterials = new Dictionary<Material, string>();

        /// <summary>
        /// The group no.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// The mat no.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// The object no.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter" /> class.
        /// </summary>
        public ObjExporter()
        {
            this.TextureExtension = ".png";
            this.TextureSize = 1024;
            this.TextureQualityLevel = 90;
            this.TextureFolder = ".";

            this.SwitchYZ = false;
            this.ExportNormals = false;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets the texture image and materials file creator.
        /// </summary>
        /// <value>A function used to create streams for texture images and material files.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets the comment.
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Gets or sets the materials file.
        /// </summary>
        /// <value>
        /// The materials file.
        /// </value>
        public string MaterialsFile { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// Gets or sets the texture folder.
        /// </summary>
        public string TextureFolder { get; set; }

        /// <summary>
        /// Gets or sets the texture extension (.png or .jpg).
        /// </summary>
        /// <value>
        /// The default value is ".png".
        /// </value>
        public string TextureExtension { get; set; }

        /// <summary>
        /// Gets or sets the texture size.
        /// </summary>
        /// <value>
        /// The default value is 1024.
        /// </value>
        public int TextureSize { get; set; }

        /// <summary>
        /// Gets or sets the texture quality level (for JPEG encoding).
        /// </summary>
        /// <value>
        /// The quality level of the JPEG image. The value range is 1 (lowest quality) to 100 (highest quality) inclusive. 
        /// The default value is 90.
        /// </value>
        public int TextureQualityLevel { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh geometry.</param>
        /// <param name="t">The transform.</param>
        public void ExportMesh(StreamWriter writer, MeshGeometry3D m, Transform3D t)
        {
            if (m == null)
            {
                throw new ArgumentNullException(nameof(m));
            }

            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = t.Transform(v);
                    writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, this.SwitchYZ ? vn.Z : vn.Y, this.SwitchYZ ? -vn.Y : vn.Z));
                }

                writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
                {
                    bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                    bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                    if (hasTextureIndex && hasNormalIndex)
                    {
                        return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                    }

                    if (hasTextureIndex)
                    {
                        return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                    }

                    if (hasNormalIndex)
                    {
                        return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                    }

                    return vertexIndexMap[i0].ToString();
                };

            if (m.TriangleIndices != null)
            {
                for (int i = 0; i < m.TriangleIndices.Count; i += 3)
                {
                    int i0 = m.TriangleIndices[i];
                    int i1 = m.TriangleIndices[i + 1];
                    int i2 = m.TriangleIndices[i + 2];

                    writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                writer.WriteLine(string.Format("# {0} faces", m.TriangleIndices.Count / 3));
            }

            writer.WriteLine();
        }

        /// <summary>
        /// Creates the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>StreamWriter.</returns>
        protected override ObjWriters Create(Stream stream)
        {
            if (this.MaterialsFile == null)
            {
                throw new InvalidOperationException("The `MaterialsFile` property must be set.");
            }

            var writer = new StreamWriter(stream);

            if (!string.IsNullOrEmpty(this.Comment))
            {
                writer.WriteLine("# {0}", this.Comment);
            }

            writer.WriteLine("mtllib ./" + this.MaterialsFile);

            var materialStream = this.FileCreator(this.MaterialsFile);
            var materialWriter = new StreamWriter(materialStream);

            return new ObjWriters { ObjWriter = writer, MaterialsWriter = materialWriter };
        }

        /// <summary>
        /// Closes the specified writer.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(ObjWriters writer)
        {
            writer.ObjWriter.Close();
            writer.MaterialsWriter.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(ObjWriters writer, GeometryModel3D model, Transform3D transform)
        {
            writer.ObjWriter.WriteLine("o object{0}", this.objectNo++);
            writer.ObjWriter.WriteLine("g group{0}", this.groupNo++);

            if (this.exportedMaterials.ContainsKey(model.Material))
            {
                string matName = this.exportedMaterials[model.Material];
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
            }
            else
            {
                string matName = string.Format("mat{0}", this.matNo++);
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
                this.ExportMaterial(writer.MaterialsWriter, matName, model.Material, model.BackMaterial);
                this.exportedMaterials.Add(model.Material, matName);
            }

            var mesh = model.Geometry as MeshGeometry3D;
            this.ExportMesh(writer.ObjWriter, mesh, Transform3DHelper.CombineTransform(transform, model.Transform));
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="materialWriter">The material writer.</param>
        /// <param name="matName">The mat name.</param>
        /// <param name="material">The material.</param>
        /// <param name="backMaterial">The back material.</param>
        private void ExportMaterial(StreamWriter materialWriter, string matName, Material material, Material backMaterial)
        {
            materialWriter.WriteLine("newmtl {0}", matName);
            var dm = material as DiffuseMaterial;
            var sm = material as SpecularMaterial;
            var mg = material as MaterialGroup;
            if (mg != null)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }

                    if (m is SpecularMaterial)
                    {
                        sm = m as SpecularMaterial;
                    }
                }
            }

            if (dm != null)
            {
                var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity(0.2);

                // materialWriter.WriteLine(string.Format("Ka {0}", this.ToColorString(adjustedAmbientColor)));
                var scb = dm.Brush as SolidColorBrush;
                if (scb != null)
                {
                    materialWriter.WriteLine(string.Format("Kd {0}", this.ToColorString(scb.Color)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", scb.Color.A / 255.0));
                    }
                    else
                    {
                        // Transparency
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", scb.Color.A / 255.0));
                    }
                }
                else
                {
                    var textureFilename = matName + this.TextureExtension;
                    var texturePath = Path.Combine(this.TextureFolder, textureFilename);
                    using (var s = this.FileCreator(texturePath))
                    {
                        // create bitmap file for the brush
                        if (this.TextureExtension == ".jpg")
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize, this.TextureQualityLevel);
                        }
                        else
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize);
                        }
                    }

                    materialWriter.WriteLine(string.Format("map_Kd {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (sm != null)
            {
                var scb = sm.Brush as SolidColorBrush;
                materialWriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(scb != null ? scb.Color : Color.FromScRgb(1.0f, 0.2f, 0.2f, 0.2f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                materialWriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", sm.SpecularPower));
            }

            // roughness
            materialWriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            materialWriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            materialWriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            materialWriter.WriteLine("illum {0}", illum);
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color color)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:F4} {1:F4} {2:F4}", color.R / 255.0, color.G / 255.0, color.B / 255.0);
        }

        /// <summary>
        /// Represents the stream writers for the <see cref="ObjExporter"/>.
        /// </summary>
        public class ObjWriters
        {
            /// <summary>
            /// Gets or sets the object file writer.
            /// </summary>
            public StreamWriter ObjWriter { get; set; }

            /// <summary>
            /// Gets or sets the material file writer.
            /// </summary>
            public StreamWriter MaterialsWriter { get; set; }
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter<ObjExporter.ObjWriters>
    {
        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<Material, string> exportedMaterials = new Dictionary<Material, string>();

        /// <summary>
        /// The group no.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// The mat no.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// The object no.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter" /> class.
        /// </summary>
        public ObjExporter()
        {
            this.TextureExtension = ".png";
            this.TextureSize = 1024;
            this.TextureQualityLevel = 90;
            this.TextureFolder = ".";

            this.SwitchYZ = false;
            this.ExportNormals = false;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets the texture image and materials file creator.
        /// </summary>
        /// <value>A function used to create streams for texture images and material files.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets the comment.
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Gets or sets the materials file.
        /// </summary>
        /// <value>
        /// The materials file.
        /// </value>
        public string MaterialsFile { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// Gets or sets the texture folder.
        /// </summary>
        public string TextureFolder { get; set; }

        /// <summary>
        /// Gets or sets the texture extension (.png or .jpg).
        /// </summary>
        /// <value>
        /// The default value is ".png".
        /// </value>
        public string TextureExtension { get; set; }

        /// <summary>
        /// Gets or sets the texture size.
        /// </summary>
        /// <value>
        /// The default value is 1024.
        /// </value>
        public int TextureSize { get; set; }

        /// <summary>
        /// Gets or sets the texture quality level (for JPEG encoding).
        /// </summary>
        /// <value>
        /// The quality level of the JPEG image. The value range is 1 (lowest quality) to 100 (highest quality) inclusive. 
        /// The default value is 90.
        /// </value>
        public int TextureQualityLevel { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh geometry.</param>
        /// <param name="t">The transform.</param>
        public void ExportMesh(StreamWriter writer, MeshGeometry3D m, Transform3D t)
        {
            if (m == null)
            {
                throw new ArgumentNullException(nameof(m));
            }

            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = t.Transform(v);
                    writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, this.SwitchYZ ? vn.Z : vn.Y, this.SwitchYZ ? -vn.Y : vn.Z));
                }

                writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
                {
                    bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                    bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                    if (hasTextureIndex && hasNormalIndex)
                    {
                        return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                    }

                    if (hasTextureIndex)
                    {
                        return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                    }

                    if (hasNormalIndex)
                    {
                        return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                    }

                    return vertexIndexMap[i0].ToString();
                };

            if (m.TriangleIndices != null)
            {
                for (int i = 0; i < m.TriangleIndices.Count; i += 3)
                {
                    int i0 = m.TriangleIndices[i];
                    int i1 = m.TriangleIndices[i + 1];
                    int i2 = m.TriangleIndices[i + 2];

                    writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                writer.WriteLine(string.Format("# {0} faces", m.TriangleIndices.Count / 3));
            }

            writer.WriteLine();
        }

        /// <summary>
        /// Creates the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>StreamWriter.</returns>
        protected override ObjWriters Create(Stream stream)
        {
            if (this.MaterialsFile == null)
            {
                throw new InvalidOperationException("The `MaterialsFile` property must be set.");
            }

            var writer = new StreamWriter(stream);

            if (!string.IsNullOrEmpty(this.Comment))
            {
                writer.WriteLine("# {0}", this.Comment);
            }

            writer.WriteLine("mtllib ./" + this.MaterialsFile);

            var materialStream = this.FileCreator(this.MaterialsFile);
            var materialWriter = new StreamWriter(materialStream);

            return new ObjWriters { ObjWriter = writer, MaterialsWriter = materialWriter };
        }

        /// <summary>
        /// Closes the specified writer.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(ObjWriters writer)
        {
            writer.ObjWriter.Close();
            writer.MaterialsWriter.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(ObjWriters writer, GeometryModel3D model, Transform3D transform)
        {
            writer.ObjWriter.WriteLine("o object{0}", this.objectNo++);
            writer.ObjWriter.WriteLine("g group{0}", this.groupNo++);

            if (this.exportedMaterials.ContainsKey(model.Material))
            {
                string matName = this.exportedMaterials[model.Material];
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
            }
            else
            {
                string matName = string.Format("mat{0}", this.matNo++);
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
                this.ExportMaterial(writer.MaterialsWriter, matName, model.Material, model.BackMaterial);
                this.exportedMaterials.Add(model.Material, matName);
            }

            var mesh = model.Geometry as MeshGeometry3D;
            this.ExportMesh(writer.ObjWriter, mesh, Transform3DHelper.CombineTransform(transform, model.Transform));
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="materialWriter">The material writer.</param>
        /// <param name="matName">The mat name.</param>
        /// <param name="material">The material.</param>
        /// <param name="backMaterial">The back material.</param>
        private void ExportMaterial(StreamWriter materialWriter, string matName, Material material, Material backMaterial)
        {
            materialWriter.WriteLine("newmtl {0}", matName);

            if (material is MaterialGroup mg)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }

                    if (m is SpecularMaterial)
                    {
                        sm = m as SpecularMaterial;
                    }
                }
            }

            if (material is DiffuseMaterial dm)
            {
                var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity(0.2);

                // materialWriter.WriteLine(string.Format("Ka {0}", this.ToColorString(adjustedAmbientColor)));
                if (dm.Brush is SolidColorBrush scb)
                {
                    materialWriter.WriteLine(string.Format("Kd {0}", this.ToColorString(scb.Color)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", scb.Color.A / 255.0));
                    }
                    else
                    {
                        // Transparency
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", scb.Color.A / 255.0));
                    }
                }
                else
                {
                    var textureFilename = matName + this.TextureExtension;
                    var texturePath = Path.Combine(this.TextureFolder, textureFilename);
                    using (var s = this.FileCreator(texturePath))
                    {
                        // create bitmap file for the brush
                        if (this.TextureExtension == ".jpg")
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize, this.TextureQualityLevel);
                        }
                        else
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize);
                        }
                    }

                    materialWriter.WriteLine(string.Format("map_Kd {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (material is SpecularMaterial sm)
            {
                materialWriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(dm.Brush is SolidColorBrush scb ? scb.Color : Color.FromScRgb(1.0f, 0.2f, 0.2f, 0.2f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                materialWriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", sm.SpecularPower));
            }

            // roughness
            materialWriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            materialWriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            materialWriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            materialWriter.WriteLine("illum {0}", illum);
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color color)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:F4} {1:F4} {2:F4}", color.R / 255.0, color.G / 255.0, color.B / 255.0);
        }

        /// <summary>
        /// Represents the stream writers for the <see cref="ObjExporter"/>.
        /// </summary>
        public class ObjWriters
        {
            /// <summary>
            /// Gets or sets the object file writer.
            /// </summary>
            public StreamWriter ObjWriter { get; set; }

            /// <summary>
            /// Gets or sets the material file writer.
            /// </summary>
            public StreamWriter MaterialsWriter { get; set; }
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(331,25): error CS0841: Cannot use local variable 'dm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(336,25): error CS0841: Cannot use local variable 'sm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(395,54): error CS0165: Use of unassigned local variable 'dm'
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Windows.Controls;

namespace HelixToolkit.Wpf
{
    using System.IO;
    using System.Text;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Exports the 3D visual tree to a STereoLithography binary file.
    /// </summary>
    public class StlExporter : Exporter<BinaryWriter>
    {
        /// <summary>
        /// Creates a <see cref="BinaryWriter"/> used to write the StlFile
        /// </summary>
        /// <param name="stream">The output stream where the STL is written.</param>
        /// <returns>The created <see cref="BinaryWriter"/></returns>
        protected override BinaryWriter Create(Stream stream)
        {
            return new BinaryWriter(stream);
        }

        /// <summary>
        /// Closes a <see cref="BinaryWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to close</param>
        protected override void Close(BinaryWriter writer)
        {
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="viewport">The viewport to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Viewport3D viewport, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            viewport.Children.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);
            
            ExportHeader(writer, triangleIndicesCount / 3);
            viewport.Children.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        /// <summary>
        /// Exports specified <see cref="Visual3D"/>
        /// </summary>
        /// <param name="visual">The <see cref="Visual3D"/> to export.</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Visual3D visual, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            visual.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            visual.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }
        
        /// <summary>
        /// Exports specified <see cref="Model3D"/>.
        /// </summary>
        /// <param name="model">The <see cref="Model3D"/> to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Model3D model, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            model.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            model.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        private void ExportHeader(BinaryWriter writer, int triangleCount)
        {
            ExportHeader(writer);
            writer.Write(triangleCount);
        }

        /// <summary>
        /// Writes an empty STL header.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        protected override void ExportHeader(BinaryWriter writer)
        {
            writer.Write(new byte[80]);
        }

        /// <summary>
        /// Writes a <see cref="GeometryModel3D"/> to a <see cref="BinaryWriter"/> in STL binary format.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        /// <param name="model">The model to write.</param>
        /// <param name="t">All vertices are transformed with this transform before written</param>
        protected override void ExportModel(BinaryWriter writer, GeometryModel3D model, Transform3D t)
        {
            var mesh = (MeshGeometry3D) model.Geometry;

            var normals = mesh.Normals;
            if (normals == null || normals.Count != mesh.Positions.Count)
            {
                normals = MeshGeometryHelper.CalculateNormals(mesh);
            }

            // TODO: Also handle non-uniform scale
            var matrix = t.Clone().Value;
            matrix.OffsetX = 0;
            matrix.OffsetY = 0;
            matrix.OffsetZ = 0;
            var normalTransform = new MatrixTransform3D(matrix);

            var material = model.Material;
            var dm = material as DiffuseMaterial;

            var mg = material as MaterialGroup;
            if (mg != null)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }
                }
            }

            ushort attribute = 0;

            if (dm != null)
            {
                var scb = dm.Brush as SolidColorBrush;
                if (scb != null)
                {
                    byte r = scb.Color.R;
                    byte g = scb.Color.G;
                    byte b = scb.Color.B;
                    attribute = (ushort)((1 << 15) | ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3));
                }
            }

            for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)
            {
                int i0 = mesh.TriangleIndices[i + 0];
                int i1 = mesh.TriangleIndices[i + 1];
                int i2 = mesh.TriangleIndices[i + 2];

                // Normal
                var faceNormal = normalTransform.Transform(normals[i0] + normals[i1] + normals[i2]);
                faceNormal.Normalize();
                WriteVector(writer, faceNormal);

                // Vertices
                WriteVertex(writer, t.Transform(mesh.Positions[i0]));
                WriteVertex(writer, t.Transform(mesh.Positions[i1]));
                WriteVertex(writer, t.Transform(mesh.Positions[i2]));

                // Attributes
                writer.Write(attribute);
            }
        }

        private static void WriteVector(BinaryWriter writer, Vector3D normal)
        {
            writer.Write((float)normal.X);
            writer.Write((float)normal.Y);
            writer.Write((float)normal.Z);
        }

        private static void WriteVertex(BinaryWriter writer, Point3D p)
        {
            writer.Write((float)p.X);
            writer.Write((float)p.Y);
            writer.Write((float)p.Z);
        }
    }
}

---- Transformed Tree ----
using System.Windows.Controls;

namespace HelixToolkit.Wpf
{
    using System.IO;
    using System.Text;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Exports the 3D visual tree to a STereoLithography binary file.
    /// </summary>
    public class StlExporter : Exporter<BinaryWriter>
    {
        /// <summary>
        /// Creates a <see cref="BinaryWriter"/> used to write the StlFile
        /// </summary>
        /// <param name="stream">The output stream where the STL is written.</param>
        /// <returns>The created <see cref="BinaryWriter"/></returns>
        protected override BinaryWriter Create(Stream stream)
        {
            return new BinaryWriter(stream);
        }

        /// <summary>
        /// Closes a <see cref="BinaryWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to close</param>
        protected override void Close(BinaryWriter writer)
        {
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="viewport">The viewport to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Viewport3D viewport, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            viewport.Children.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);
            
            ExportHeader(writer, triangleIndicesCount / 3);
            viewport.Children.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        /// <summary>
        /// Exports specified <see cref="Visual3D"/>
        /// </summary>
        /// <param name="visual">The <see cref="Visual3D"/> to export.</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Visual3D visual, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            visual.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            visual.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }
        
        /// <summary>
        /// Exports specified <see cref="Model3D"/>.
        /// </summary>
        /// <param name="model">The <see cref="Model3D"/> to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Model3D model, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            model.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            model.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        private void ExportHeader(BinaryWriter writer, int triangleCount)
        {
            ExportHeader(writer);
            writer.Write(triangleCount);
        }

        /// <summary>
        /// Writes an empty STL header.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        protected override void ExportHeader(BinaryWriter writer)
        {
            writer.Write(new byte[80]);
        }

        /// <summary>
        /// Writes a <see cref="GeometryModel3D"/> to a <see cref="BinaryWriter"/> in STL binary format.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        /// <param name="model">The model to write.</param>
        /// <param name="t">All vertices are transformed with this transform before written</param>
        protected override void ExportModel(BinaryWriter writer, GeometryModel3D model, Transform3D t)
        {
            var mesh = (MeshGeometry3D) model.Geometry;

            var normals = mesh.Normals;
            if (normals == null || normals.Count != mesh.Positions.Count)
            {
                normals = MeshGeometryHelper.CalculateNormals(mesh);
            }

            // TODO: Also handle non-uniform scale
            var matrix = t.Clone().Value;
            matrix.OffsetX = 0;
            matrix.OffsetY = 0;
            matrix.OffsetZ = 0;
            var normalTransform = new MatrixTransform3D(matrix);

            var material = model.Material;

            if (material is MaterialGroup mg)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }
                }
            }

            ushort attribute = 0;

            if (material is DiffuseMaterial dm)
            {
                if (dm.Brush is SolidColorBrush scb)
                {
                    byte r = scb.Color.R;
                    byte g = scb.Color.G;
                    byte b = scb.Color.B;
                    attribute = (ushort)((1 << 15) | ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3));
                }
            }

            for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)
            {
                int i0 = mesh.TriangleIndices[i + 0];
                int i1 = mesh.TriangleIndices[i + 1];
                int i2 = mesh.TriangleIndices[i + 2];

                // Normal
                var faceNormal = normalTransform.Transform(normals[i0] + normals[i1] + normals[i2]);
                faceNormal.Normalize();
                WriteVector(writer, faceNormal);

                // Vertices
                WriteVertex(writer, t.Transform(mesh.Positions[i0]));
                WriteVertex(writer, t.Transform(mesh.Positions[i1]));
                WriteVertex(writer, t.Transform(mesh.Positions[i2]));

                // Attributes
                writer.Write(attribute);
            }
        }

        private static void WriteVector(BinaryWriter writer, Vector3D normal)
        {
            writer.Write((float)normal.X);
            writer.Write((float)normal.Y);
            writer.Write((float)normal.Z);
        }

        private static void WriteVertex(BinaryWriter writer, Point3D p)
        {
            writer.Write((float)p.X);
            writer.Write((float)p.Y);
            writer.Write((float)p.Z);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(15,5): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(142,25): error CS0841: Cannot use local variable 'dm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(15,5): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\CuttingPlaneGroup.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Defines the cutting operation.
    /// </summary>
    public enum CuttingOperation
    {
        /// <summary>
        /// The intersect operation.
        /// </summary>
        Intersect,

        /// <summary>
        /// The subtract operation.
        /// </summary>
        Subtract,
    }

    /// <summary>
    /// A visual element that applies the intersection of all the specified cutting planes to all children.
    /// </summary>
    public class CuttingPlaneGroup : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="IsEnabled"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.Register(
            "IsEnabled", typeof(bool), typeof(CuttingPlaneGroup), new UIPropertyMetadata(false, IsEnabledChanged));

        /// <summary>
        /// Identifies the <see cref="Operation"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty OperationProperty =
            DependencyProperty.Register("Operation", typeof(CuttingOperation), typeof(CuttingPlaneGroup), new PropertyMetadata(CuttingOperation.Intersect, OperationChanged));

        /// <summary>
        /// The cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> cutGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// The new cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newCutGeometries;

        /// <summary>
        /// The new original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newOriginalGeometries;

        /// <summary>
        /// The original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> originalGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// Initializes a new instance of the <see cref = "CuttingPlaneGroup" /> class.
        /// </summary>
        public CuttingPlaneGroup()
        {
            this.IsEnabled = true;
            this.CuttingPlanes = new List<Plane3D>();
        }

        /// <summary>
        /// Gets or sets the cutting planes.
        /// </summary>
        /// <value>
        /// The cutting planes.
        /// </value>
        /// <remarks>
        /// The the intersection of all the cutting planes will be used to
        /// intersect/subtract (defined in <see cref="Operation" /> all child visuals of the <see cref="CuttingPlaneGroup" />.
        /// </remarks>
        public List<Plane3D> CuttingPlanes { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether cutting is enabled.
        /// </summary>
        public bool IsEnabled
        {
            get
            {
                return (bool)this.GetValue(IsEnabledProperty);
            }

            set
            {
                this.SetValue(IsEnabledProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the cutting operation.
        /// </summary>
        /// <value>The operation.</value>
        public CuttingOperation Operation
        {
            get { return (CuttingOperation)this.GetValue(OperationProperty); }
            set { this.SetValue(OperationProperty, value); }
        }

        /// <summary>
        /// Called when the composition target rendering event is raised.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="RenderingEventArgs"/> instance containing the event data.</param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            // TODO: Find a better way to handle this...
            if (this.IsEnabled)
            {
                this.ApplyCuttingGeometries();
            }
        }

        /// <summary>
        /// Handles changes to the <see cref="IsEnabled" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void IsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var g = (CuttingPlaneGroup)d;

            if (g.IsEnabled)
            {
                g.SubscribeToRenderingEvent();
            }
            else
            {
                g.UnsubscribeRenderingEvent();
            }

            g.ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Handles changes to the <see cref="Operation" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void OperationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((CuttingPlaneGroup)d).ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Applies the cutting planes.
        /// </summary>
        /// <param name="forceUpdate">Force the geometries to be updated if set to <c>true</c>.</param>
        private void ApplyCuttingGeometries(bool forceUpdate = false)
        {
            lock (this)
            {
                this.newCutGeometries = new Dictionary<Model3D, Geometry3D>();
                this.newOriginalGeometries = new Dictionary<Model3D, Geometry3D>();
                this.Children.Traverse<GeometryModel3D>((m, t) => this.ApplyCuttingPlanesToModel(m, t, forceUpdate));
                this.cutGeometries = this.newCutGeometries;
                this.originalGeometries = this.newOriginalGeometries;
            }
        }

        /// <summary>
        /// Applies the cutting planes to the model.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        /// <param name="updateRequired">An update is required if set to <c>true</c>.</param>
        /// <exception cref="System.InvalidOperationException">No inverse transform.</exception>
        /// <exception cref="System.NotImplementedException"></exception>
        private void ApplyCuttingPlanesToModel(GeometryModel3D model, Transform3D transform, bool updateRequired)
        {
            if (model.Geometry == null)
            {
                return;
            }

            if (!this.IsEnabled)
            {
                updateRequired = true;
            }

            Geometry3D cutGeometry;
            if (this.cutGeometries.TryGetValue(model, out cutGeometry))
            {
                // ReSharper disable once RedundantNameQualifier
                if (object.ReferenceEquals(cutGeometry, model.Geometry))
                {
                    updateRequired = true;
                }
            }

            Geometry3D originalGeometry;
            if (!this.originalGeometries.TryGetValue(model, out originalGeometry))
            {
                originalGeometry = model.Geometry;
                updateRequired = true;
            }

            this.newOriginalGeometries.Add(model, originalGeometry);

            if (!updateRequired)
            {
                return;
            }

            var newGeometry = originalGeometry;
            var originalMeshGeometry = originalGeometry as MeshGeometry3D;

            if (this.IsEnabled && originalMeshGeometry != null)
            {
                var inverseTransform = transform.Inverse;
                if (inverseTransform == null)
                {
                    throw new InvalidOperationException("No inverse transform.");
                }

                switch (this.Operation)
                {
                    case CuttingOperation.Intersect:

                        var intersectedGeometry = originalMeshGeometry;

                        // Calculate the intersection of all the intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            intersectedGeometry = this.Intersect(intersectedGeometry, inverseTransform, cp, false);
                        }

                        newGeometry = intersectedGeometry;
                        break;
                    case CuttingOperation.Subtract:
                        var builder = new MeshBuilder(originalMeshGeometry.Normals.Any(), originalMeshGeometry.TextureCoordinates.Any());

                        // Calculate the union of all complement intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            var cg = this.Intersect(originalMeshGeometry, inverseTransform, cp, true);
                            builder.Append(cg);
                        }

                        newGeometry = builder.ToMesh(true);
                        break;
                }
            }

            model.Geometry = newGeometry;
            this.newCutGeometries.Add(model, originalMeshGeometry);
        }

        /// <summary>
        /// Intersects the specified source mesh geometry with the specified plane.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <param name="inverseTransform">The inverse transform of the source.</param>
        /// <param name="plane">The plane.</param>
        /// <param name="complement">Cut with the complement set if set to <c>true</c>.</param>
        /// <returns>The intersected geometry.</returns>
        private MeshGeometry3D Intersect(MeshGeometry3D source, GeneralTransform3D inverseTransform, Plane3D plane, bool complement)
        {
            var p = inverseTransform.Transform(plane.Position);
            var p2 = inverseTransform.Transform(plane.Position + plane.Normal);
            var n = p2 - p;

            if (complement)
            {
                n *= -1;
            }

            return MeshGeometryHelper.Cut(source, p, n);
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Defines the cutting operation.
    /// </summary>
    public enum CuttingOperation
    {
        /// <summary>
        /// The intersect operation.
        /// </summary>
        Intersect,

        /// <summary>
        /// The subtract operation.
        /// </summary>
        Subtract,
    }

    /// <summary>
    /// A visual element that applies the intersection of all the specified cutting planes to all children.
    /// </summary>
    public class CuttingPlaneGroup : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="IsEnabled"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.Register(
            "IsEnabled", typeof(bool), typeof(CuttingPlaneGroup), new UIPropertyMetadata(false, IsEnabledChanged));

        /// <summary>
        /// Identifies the <see cref="Operation"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty OperationProperty =
            DependencyProperty.Register("Operation", typeof(CuttingOperation), typeof(CuttingPlaneGroup), new PropertyMetadata(CuttingOperation.Intersect, OperationChanged));

        /// <summary>
        /// The cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> cutGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// The new cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newCutGeometries;

        /// <summary>
        /// The new original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newOriginalGeometries;

        /// <summary>
        /// The original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> originalGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// Initializes a new instance of the <see cref = "CuttingPlaneGroup" /> class.
        /// </summary>
        public CuttingPlaneGroup()
        {
            this.IsEnabled = true;
            this.CuttingPlanes = new List<Plane3D>();
        }

        /// <summary>
        /// Gets or sets the cutting planes.
        /// </summary>
        /// <value>
        /// The cutting planes.
        /// </value>
        /// <remarks>
        /// The the intersection of all the cutting planes will be used to
        /// intersect/subtract (defined in <see cref="Operation" /> all child visuals of the <see cref="CuttingPlaneGroup" />.
        /// </remarks>
        public List<Plane3D> CuttingPlanes { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether cutting is enabled.
        /// </summary>
        public bool IsEnabled
        {
            get
            {
                return (bool)this.GetValue(IsEnabledProperty);
            }

            set
            {
                this.SetValue(IsEnabledProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the cutting operation.
        /// </summary>
        /// <value>The operation.</value>
        public CuttingOperation Operation
        {
            get { return (CuttingOperation)this.GetValue(OperationProperty); }
            set { this.SetValue(OperationProperty, value); }
        }

        /// <summary>
        /// Called when the composition target rendering event is raised.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="RenderingEventArgs"/> instance containing the event data.</param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            // TODO: Find a better way to handle this...
            if (this.IsEnabled)
            {
                this.ApplyCuttingGeometries();
            }
        }

        /// <summary>
        /// Handles changes to the <see cref="IsEnabled" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void IsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var g = (CuttingPlaneGroup)d;

            if (g.IsEnabled)
            {
                g.SubscribeToRenderingEvent();
            }
            else
            {
                g.UnsubscribeRenderingEvent();
            }

            g.ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Handles changes to the <see cref="Operation" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void OperationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((CuttingPlaneGroup)d).ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Applies the cutting planes.
        /// </summary>
        /// <param name="forceUpdate">Force the geometries to be updated if set to <c>true</c>.</param>
        private void ApplyCuttingGeometries(bool forceUpdate = false)
        {
            lock (this)
            {
                this.newCutGeometries = new Dictionary<Model3D, Geometry3D>();
                this.newOriginalGeometries = new Dictionary<Model3D, Geometry3D>();
                this.Children.Traverse<GeometryModel3D>((m, t) => this.ApplyCuttingPlanesToModel(m, t, forceUpdate));
                this.cutGeometries = this.newCutGeometries;
                this.originalGeometries = this.newOriginalGeometries;
            }
        }

        /// <summary>
        /// Applies the cutting planes to the model.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        /// <param name="updateRequired">An update is required if set to <c>true</c>.</param>
        /// <exception cref="System.InvalidOperationException">No inverse transform.</exception>
        /// <exception cref="System.NotImplementedException"></exception>
        private void ApplyCuttingPlanesToModel(GeometryModel3D model, Transform3D transform, bool updateRequired)
        {
            if (model.Geometry == null)
            {
                return;
            }

            if (!this.IsEnabled)
            {
                updateRequired = true;
            }

            Geometry3D cutGeometry;
            if (this.cutGeometries.TryGetValue(model, out cutGeometry))
            {
                // ReSharper disable once RedundantNameQualifier
                if (object.ReferenceEquals(cutGeometry, model.Geometry))
                {
                    updateRequired = true;
                }
            }

            Geometry3D originalGeometry;
            if (!this.originalGeometries.TryGetValue(model, out originalGeometry))
            {
                originalGeometry = model.Geometry;
                updateRequired = true;
            }

            this.newOriginalGeometries.Add(model, originalGeometry);

            if (!updateRequired)
            {
                return;
            }

            var newGeometry = originalGeometry;

            if (this.IsEnabled && originalGeometry is MeshGeometry3D originalMeshGeometry)
            {
                var inverseTransform = transform.Inverse;
                if (inverseTransform == null)
                {
                    throw new InvalidOperationException("No inverse transform.");
                }

                switch (this.Operation)
                {
                    case CuttingOperation.Intersect:

                        var intersectedGeometry = originalMeshGeometry;

                        // Calculate the intersection of all the intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            intersectedGeometry = this.Intersect(intersectedGeometry, inverseTransform, cp, false);
                        }

                        newGeometry = intersectedGeometry;
                        break;
                    case CuttingOperation.Subtract:
                        var builder = new MeshBuilder(originalMeshGeometry.Normals.Any(), originalMeshGeometry.TextureCoordinates.Any());

                        // Calculate the union of all complement intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            var cg = this.Intersect(originalMeshGeometry, inverseTransform, cp, true);
                            builder.Append(cg);
                        }

                        newGeometry = builder.ToMesh(true);
                        break;
                }
            }

            model.Geometry = newGeometry;
            this.newCutGeometries.Add(model, originalMeshGeometry);
        }

        /// <summary>
        /// Intersects the specified source mesh geometry with the specified plane.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <param name="inverseTransform">The inverse transform of the source.</param>
        /// <param name="plane">The plane.</param>
        /// <param name="complement">Cut with the complement set if set to <c>true</c>.</param>
        /// <returns>The intersected geometry.</returns>
        private MeshGeometry3D Intersect(MeshGeometry3D source, GeneralTransform3D inverseTransform, Plane3D plane, bool complement)
        {
            var p = inverseTransform.Transform(plane.Position);
            var p2 = inverseTransform.Transform(plane.Position + plane.Normal);
            var n = p2 - p;

            if (complement)
            {
                n *= -1;
            }

            return MeshGeometryHelper.Cut(source, p, n);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\CuttingPlaneGroup.cs(264,46): error CS0165: Use of unassigned local variable 'originalMeshGeometry'
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// An abstract base class for visuals that use screen space dimensions when rendering.
    /// </summary>
    public abstract class ScreenSpaceVisual3D : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="Color"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ColorProperty = DependencyProperty.Register(
            "Color", typeof(Color), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(Colors.Black, ColorChanged));

        /// <summary>
        /// Identifies the <see cref="DepthOffset"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty DepthOffsetProperty = DependencyProperty.Register(
            "DepthOffset", typeof(double), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(0.0, GeometryChanged));

        /// <summary>
        /// Identifies the <see cref="Points"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty PointsProperty = DependencyProperty.Register(
            "Points", typeof(Point3DCollection), typeof(ScreenSpaceVisual3D), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure, PointsChanged));

        /// <summary>
        /// The is rendering flag.
        /// </summary>
        private bool isRendering;

        /// <summary>
        /// The listening to collection
        /// </summary>
        private Point3DCollection collectionBeingListenedTo;

        /// <summary>
        /// Initializes a new instance of the <see cref = "ScreenSpaceVisual3D" /> class.
        /// </summary>
        protected ScreenSpaceVisual3D()
        {
            this.Mesh = new MeshGeometry3D();
            this.Model = new GeometryModel3D { Geometry = this.Mesh };
            this.Content = this.Model;
            this.Points = new Point3DCollection();
            this.ColorChanged();
        }

        /// <summary>
        /// Gets or sets the color.
        /// </summary>
        /// <value>
        /// The color.
        /// </value>
        public Color Color
        {
            get
            {
                return (Color)this.GetValue(ColorProperty);
            }

            set
            {
                this.SetValue(ColorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the depth offset.
        /// A small positive number (0.0001) will move the visual slightly in front of other objects.
        /// </summary>
        /// <value>
        /// The depth offset.
        /// </value>
        public double DepthOffset
        {
            get
            {
                return (double)this.GetValue(DepthOffsetProperty);
            }

            set
            {
                this.SetValue(DepthOffsetProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance is being rendered.
        /// When the visual is removed from the visual tree, this property should be set to false.
        /// </summary>
        public bool IsRendering
        {
            get
            {
                return this.isRendering;
            }

            set
            {
                if (value != this.isRendering)
                {
                    this.isRendering = value;
                    if (this.isRendering)
                    {
                        this.SubscribeToRenderingEvent();
                    }
                    else
                    {
                        this.UnsubscribeRenderingEvent();
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the points collection.
        /// </summary>
        /// <value>
        /// The points collection.
        /// </value>
        public Point3DCollection Points
        {
            get
            {
                return (Point3DCollection)this.GetValue(PointsProperty);
            }

            set
            {
                this.SetValue(PointsProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the clipping object.
        /// </summary>
        protected CohenSutherlandClipping Clipping { get; set; }

        /// <summary>
        /// Gets or sets the mesh.
        /// </summary>
        protected MeshGeometry3D Mesh { get; set; }

        /// <summary>
        /// Gets or sets the model.
        /// </summary>
        protected GeometryModel3D Model { get; set; }

        /// <summary>
        /// Called when geometry properties have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        protected static void GeometryChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).UpdateGeometry();
        }

        /// <summary>
        /// Called when points have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void PointsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            var screenSpaceVisual3D = (ScreenSpaceVisual3D)sender;
            screenSpaceVisual3D.UpdateGeometry();

            if (screenSpaceVisual3D.collectionBeingListenedTo != null && !screenSpaceVisual3D.collectionBeingListenedTo.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo.Changed -= screenSpaceVisual3D.HandlePointsChanged;
            }

            var pc = e.NewValue as Point3DCollection;
            if (pc != null && !pc.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;

                // TODO: use a weak event manager
                pc.Changed += screenSpaceVisual3D.HandlePointsChanged;
            }
            else
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;
            }
        }

        /// <summary>
        /// The composition target_ rendering.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            if (this.isRendering)
            {
                if (!Visual3DHelper.IsAttachedToViewport3D(this))
                {
                    return;
                }

                if (this.UpdateTransforms())
                {
                    this.UpdateClipping();
                    this.UpdateGeometry();
                }
            }
        }

        /// <summary>
        /// Called when the parent of the 3-D visual object is changed.
        /// </summary>
        /// <param name="oldParent">
        /// A value of type <see cref="T:System.Windows.DependencyObject"/> that represents the previous parent of the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object. If the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object did not have a previous parent, the value of the parameter is null.
        /// </param>
        protected override void OnVisualParentChanged(DependencyObject oldParent)
        {
            base.OnVisualParentChanged(oldParent);
            var parent = VisualTreeHelper.GetParent(this);
            this.IsRendering = parent != null;
        }

        /// <summary>
        /// Updates the geometry.
        /// </summary>
        protected abstract void UpdateGeometry();

        /// <summary>
        /// Updates the transforms.
        /// </summary>
        /// <returns>
        /// True if the transform is updated.
        /// </returns>
        protected abstract bool UpdateTransforms();

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void ColorChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).ColorChanged();
        }

        /// <summary>
        /// Handles changes in the <see cref="Points" /> collection.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The event arguments.</param>
        private void HandlePointsChanged(object sender, EventArgs e)
        {
            this.UpdateGeometry();
        }

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        private void ColorChanged()
        {
            var mg = new MaterialGroup();
            mg.Children.Add(new DiffuseMaterial(Brushes.Black));
            mg.Children.Add(new EmissiveMaterial(new SolidColorBrush(this.Color)));
            mg.Freeze();
            this.Model.Material = mg;
            this.Model.BackMaterial = mg;
        }

        /// <summary>
        /// Updates the clipping object.
        /// </summary>
        private void UpdateClipping()
        {
            var vp = this.GetViewport3D();
            if (vp == null)
            {
                return;
            }

            this.Clipping = new CohenSutherlandClipping(10, vp.ActualWidth - 20, 10, vp.ActualHeight - 20);
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// An abstract base class for visuals that use screen space dimensions when rendering.
    /// </summary>
    public abstract class ScreenSpaceVisual3D : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="Color"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ColorProperty = DependencyProperty.Register(
            "Color", typeof(Color), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(Colors.Black, ColorChanged));

        /// <summary>
        /// Identifies the <see cref="DepthOffset"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty DepthOffsetProperty = DependencyProperty.Register(
            "DepthOffset", typeof(double), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(0.0, GeometryChanged));

        /// <summary>
        /// Identifies the <see cref="Points"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty PointsProperty = DependencyProperty.Register(
            "Points", typeof(Point3DCollection), typeof(ScreenSpaceVisual3D), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure, PointsChanged));

        /// <summary>
        /// The is rendering flag.
        /// </summary>
        private bool isRendering;

        /// <summary>
        /// The listening to collection
        /// </summary>
        private Point3DCollection collectionBeingListenedTo;

        /// <summary>
        /// Initializes a new instance of the <see cref = "ScreenSpaceVisual3D" /> class.
        /// </summary>
        protected ScreenSpaceVisual3D()
        {
            this.Mesh = new MeshGeometry3D();
            this.Model = new GeometryModel3D { Geometry = this.Mesh };
            this.Content = this.Model;
            this.Points = new Point3DCollection();
            this.ColorChanged();
        }

        /// <summary>
        /// Gets or sets the color.
        /// </summary>
        /// <value>
        /// The color.
        /// </value>
        public Color Color
        {
            get
            {
                return (Color)this.GetValue(ColorProperty);
            }

            set
            {
                this.SetValue(ColorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the depth offset.
        /// A small positive number (0.0001) will move the visual slightly in front of other objects.
        /// </summary>
        /// <value>
        /// The depth offset.
        /// </value>
        public double DepthOffset
        {
            get
            {
                return (double)this.GetValue(DepthOffsetProperty);
            }

            set
            {
                this.SetValue(DepthOffsetProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance is being rendered.
        /// When the visual is removed from the visual tree, this property should be set to false.
        /// </summary>
        public bool IsRendering
        {
            get
            {
                return this.isRendering;
            }

            set
            {
                if (value != this.isRendering)
                {
                    this.isRendering = value;
                    if (this.isRendering)
                    {
                        this.SubscribeToRenderingEvent();
                    }
                    else
                    {
                        this.UnsubscribeRenderingEvent();
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the points collection.
        /// </summary>
        /// <value>
        /// The points collection.
        /// </value>
        public Point3DCollection Points
        {
            get
            {
                return (Point3DCollection)this.GetValue(PointsProperty);
            }

            set
            {
                this.SetValue(PointsProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the clipping object.
        /// </summary>
        protected CohenSutherlandClipping Clipping { get; set; }

        /// <summary>
        /// Gets or sets the mesh.
        /// </summary>
        protected MeshGeometry3D Mesh { get; set; }

        /// <summary>
        /// Gets or sets the model.
        /// </summary>
        protected GeometryModel3D Model { get; set; }

        /// <summary>
        /// Called when geometry properties have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        protected static void GeometryChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).UpdateGeometry();
        }

        /// <summary>
        /// Called when points have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void PointsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            var screenSpaceVisual3D = (ScreenSpaceVisual3D)sender;
            screenSpaceVisual3D.UpdateGeometry();

            if (screenSpaceVisual3D.collectionBeingListenedTo != null && !screenSpaceVisual3D.collectionBeingListenedTo.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo.Changed -= screenSpaceVisual3D.HandlePointsChanged;
            }

            if (e.NewValue is Point3DCollection pc && !pc.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;

                // TODO: use a weak event manager
                pc.Changed += screenSpaceVisual3D.HandlePointsChanged;
            }
            else
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;
            }
        }

        /// <summary>
        /// The composition target_ rendering.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            if (this.isRendering)
            {
                if (!Visual3DHelper.IsAttachedToViewport3D(this))
                {
                    return;
                }

                if (this.UpdateTransforms())
                {
                    this.UpdateClipping();
                    this.UpdateGeometry();
                }
            }
        }

        /// <summary>
        /// Called when the parent of the 3-D visual object is changed.
        /// </summary>
        /// <param name="oldParent">
        /// A value of type <see cref="T:System.Windows.DependencyObject"/> that represents the previous parent of the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object. If the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object did not have a previous parent, the value of the parameter is null.
        /// </param>
        protected override void OnVisualParentChanged(DependencyObject oldParent)
        {
            base.OnVisualParentChanged(oldParent);
            var parent = VisualTreeHelper.GetParent(this);
            this.IsRendering = parent != null;
        }

        /// <summary>
        /// Updates the geometry.
        /// </summary>
        protected abstract void UpdateGeometry();

        /// <summary>
        /// Updates the transforms.
        /// </summary>
        /// <returns>
        /// True if the transform is updated.
        /// </returns>
        protected abstract bool UpdateTransforms();

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void ColorChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).ColorChanged();
        }

        /// <summary>
        /// Handles changes in the <see cref="Points" /> collection.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The event arguments.</param>
        private void HandlePointsChanged(object sender, EventArgs e)
        {
            this.UpdateGeometry();
        }

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        private void ColorChanged()
        {
            var mg = new MaterialGroup();
            mg.Children.Add(new DiffuseMaterial(Brushes.Black));
            mg.Children.Add(new EmissiveMaterial(new SolidColorBrush(this.Color)));
            mg.Freeze();
            this.Model.Material = mg;
            this.Model.BackMaterial = mg;
        }

        /// <summary>
        /// Updates the clipping object.
        /// </summary>
        private void UpdateClipping()
        {
            var vp = this.GetViewport3D();
            if (vp == null)
            {
                return;
            }

            this.Clipping = new CohenSutherlandClipping(10, vp.ActualWidth - 20, 10, vp.ActualHeight - 20);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs(205,65): error CS0165: Use of unassigned local variable 'pc'
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Windows.Media.Media3D;
using global::SharpDX;

#if COREWPF
using HelixToolkit.SharpDX.Core.Model;
using HelixToolkit.SharpDX.Core.Model.Scene;
using MeshGeometry3D = HelixToolkit.SharpDX.Core.MeshGeometry3D;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
    
#if !COREWPF
    using Model;
    using Model.Scene;
#endif

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter
    {
        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// The directory.
        /// </summary>
        private readonly string directory;

        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<MaterialCore, string> exportedMaterials = new Dictionary<MaterialCore, string>();

        /// <summary>
        /// The mwriter.
        /// </summary>
        private readonly StreamWriter mwriter;

        /// <summary>
        /// The writer.
        /// </summary>
        private readonly StreamWriter writer;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Object index counter.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Group index counter.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// Material index counter.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        public ObjExporter(string outputFileName)
            : this(outputFileName, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        /// <param name="comment">
        /// The comment.
        /// </param>
        public ObjExporter(string outputFileName, string comment)
        {
            this.SwitchYZ = true;
            this.ExportNormals = false;

            var fullPath = Path.GetFullPath(outputFileName);
            var mtlPath = Path.ChangeExtension(outputFileName, ".mtl");
            string mtlFilename = Path.GetFileName(mtlPath);
            this.directory = Path.GetDirectoryName(fullPath);

            this.writer = new StreamWriter(outputFileName);
            this.mwriter = new StreamWriter(mtlPath);

            if (!string.IsNullOrEmpty(comment))
            {
                this.writer.WriteLine(string.Format("# {0}", comment));
            }

            this.writer.WriteLine("mtllib ./" + mtlFilename);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        public override void Close()
        {
            this.writer.Close();
            this.mwriter.Close();
            base.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        /// <param name="transform">
        /// The transform.
        /// </param>
        protected override void ExportModel(MeshNode model, Transform3D transform)
        {
            if(model.GeometryValid && model.Material != null)
            {
                if(transform == null)
                {
                    transform = Transform3D.Identity;
                }
                this.writer.WriteLine(string.Format("o object{0}", this.objectNo++));
                this.writer.WriteLine(string.Format("g group{0}", this.groupNo++));

                if (this.exportedMaterials.ContainsKey(model.Material))
                {
                    string matName = this.exportedMaterials[model.Material];
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                }
                else
                {
                    string matName = string.Format("mat{0}", this.matNo++);
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                    this.ExportMaterial(matName, model.Material);
                    this.exportedMaterials.Add(model.Material, matName);
                }

                var mesh = model.Geometry as MeshGeometry3D;
                if (model.HasInstances)
                {
                    var m = transform.ToMatrix();
                    for(int i=0; i<model.Instances.Count; ++i)
                    {
                        this.ExportMesh(mesh, model.Instances[i] * m);
                    }
                }
                else
                {
                    this.ExportMesh(mesh, transform.ToMatrix());
                }
            }
        }

        /// <summary>
        /// The export mesh.
        /// </summary>
        /// <param name="m">
        /// The m.
        /// </param>
        /// <param name="t">
        /// The t.
        /// </param>
        public void ExportMesh(MeshGeometry3D m, Matrix t)
        {
            if (m == null)
            {
                throw new ArgumentNullException("m");
            }

            if (t == null)
            {
                throw new ArgumentNullException("t");
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = Vector3.TransformCoordinate(v, t);
                    this.writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                this.writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    this.writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                this.writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    this.writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, vn.Y, vn.Z));
                }

                this.writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
            {
                bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                if (hasTextureIndex && hasNormalIndex)
                {
                    return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                }

                if (hasTextureIndex)
                {
                    return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                }

                if (hasNormalIndex)
                {
                    return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                }

                return vertexIndexMap[i0].ToString();
            };

            if (m.Indices != null)
            {
                for (int i = 0; i < m.Indices.Count; i += 3)
                {
                    int i0 = m.Indices[i];
                    int i1 = m.Indices[i + 1];
                    int i2 = m.Indices[i + 2];

                    this.writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                this.writer.WriteLine(string.Format("# {0} faces", m.Indices.Count / 3));
            }

            this.writer.WriteLine();
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="matName">
        /// The mat name.
        /// </param>
        /// <param name="material">
        /// The material.
        /// </param>
        private void ExportMaterial(string matName, MaterialCore material)
        {
            this.mwriter.WriteLine(string.Format("newmtl {0}", matName));
            var pm = material as PhongMaterialCore;

            if (pm != null)
            {
                if (pm.DiffuseMap == null)
                {
                    this.mwriter.WriteLine(string.Format("Kd {0}", this.ToColorString(pm.DiffuseColor)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", pm.DiffuseColor.Alpha));
                    }
                    else
                    {
                        // Transparency
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", pm.DiffuseColor.Alpha));
                    }
                }
                else
                {
                    var textureFilename = matName + ".png";
                    var texturePath = Path.Combine(this.directory, textureFilename);

                    // create .png bitmap file for the brush
                    RenderBrush(texturePath, pm.DiffuseMap.CompressedStream);
                    this.mwriter.WriteLine(string.Format("map_Ka {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (pm != null)
            {
                this.mwriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(pm.DiffuseMap == null ? pm.SpecularColor : new Color4(0.2f, 0.2f, 0.2f, 1.0f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                this.mwriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", pm.SpecularShininess));
            }

            // roughness
            this.mwriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            this.mwriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            this.mwriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            this.mwriter.WriteLine(string.Format("illum {0}", illum));
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color4 color)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:F4} {1:F4} {2:F4}",
                color.Red,
                color.Green,
                color.Blue);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Windows.Media.Media3D;
using global::SharpDX;

#if COREWPF
using HelixToolkit.SharpDX.Core.Model;
using HelixToolkit.SharpDX.Core.Model.Scene;
using MeshGeometry3D = HelixToolkit.SharpDX.Core.MeshGeometry3D;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
    
#if !COREWPF
    using Model;
    using Model.Scene;
#endif

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter
    {
        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// The directory.
        /// </summary>
        private readonly string directory;

        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<MaterialCore, string> exportedMaterials = new Dictionary<MaterialCore, string>();

        /// <summary>
        /// The mwriter.
        /// </summary>
        private readonly StreamWriter mwriter;

        /// <summary>
        /// The writer.
        /// </summary>
        private readonly StreamWriter writer;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Object index counter.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Group index counter.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// Material index counter.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        public ObjExporter(string outputFileName)
            : this(outputFileName, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        /// <param name="comment">
        /// The comment.
        /// </param>
        public ObjExporter(string outputFileName, string comment)
        {
            this.SwitchYZ = true;
            this.ExportNormals = false;

            var fullPath = Path.GetFullPath(outputFileName);
            var mtlPath = Path.ChangeExtension(outputFileName, ".mtl");
            string mtlFilename = Path.GetFileName(mtlPath);
            this.directory = Path.GetDirectoryName(fullPath);

            this.writer = new StreamWriter(outputFileName);
            this.mwriter = new StreamWriter(mtlPath);

            if (!string.IsNullOrEmpty(comment))
            {
                this.writer.WriteLine(string.Format("# {0}", comment));
            }

            this.writer.WriteLine("mtllib ./" + mtlFilename);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        public override void Close()
        {
            this.writer.Close();
            this.mwriter.Close();
            base.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        /// <param name="transform">
        /// The transform.
        /// </param>
        protected override void ExportModel(MeshNode model, Transform3D transform)
        {
            if(model.GeometryValid && model.Material != null)
            {
                if(transform == null)
                {
                    transform = Transform3D.Identity;
                }
                this.writer.WriteLine(string.Format("o object{0}", this.objectNo++));
                this.writer.WriteLine(string.Format("g group{0}", this.groupNo++));

                if (this.exportedMaterials.ContainsKey(model.Material))
                {
                    string matName = this.exportedMaterials[model.Material];
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                }
                else
                {
                    string matName = string.Format("mat{0}", this.matNo++);
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                    this.ExportMaterial(matName, model.Material);
                    this.exportedMaterials.Add(model.Material, matName);
                }

                var mesh = model.Geometry as MeshGeometry3D;
                if (model.HasInstances)
                {
                    var m = transform.ToMatrix();
                    for(int i=0; i<model.Instances.Count; ++i)
                    {
                        this.ExportMesh(mesh, model.Instances[i] * m);
                    }
                }
                else
                {
                    this.ExportMesh(mesh, transform.ToMatrix());
                }
            }
        }

        /// <summary>
        /// The export mesh.
        /// </summary>
        /// <param name="m">
        /// The m.
        /// </param>
        /// <param name="t">
        /// The t.
        /// </param>
        public void ExportMesh(MeshGeometry3D m, Matrix t)
        {
            if (m == null)
            {
                throw new ArgumentNullException("m");
            }

            if (t == null)
            {
                throw new ArgumentNullException("t");
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = Vector3.TransformCoordinate(v, t);
                    this.writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                this.writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    this.writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                this.writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    this.writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, vn.Y, vn.Z));
                }

                this.writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
            {
                bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                if (hasTextureIndex && hasNormalIndex)
                {
                    return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                }

                if (hasTextureIndex)
                {
                    return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                }

                if (hasNormalIndex)
                {
                    return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                }

                return vertexIndexMap[i0].ToString();
            };

            if (m.Indices != null)
            {
                for (int i = 0; i < m.Indices.Count; i += 3)
                {
                    int i0 = m.Indices[i];
                    int i1 = m.Indices[i + 1];
                    int i2 = m.Indices[i + 2];

                    this.writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                this.writer.WriteLine(string.Format("# {0} faces", m.Indices.Count / 3));
            }

            this.writer.WriteLine();
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="matName">
        /// The mat name.
        /// </param>
        /// <param name="material">
        /// The material.
        /// </param>
        private void ExportMaterial(string matName, MaterialCore material)
        {
            this.mwriter.WriteLine(string.Format("newmtl {0}", matName));

            if (material is PhongMaterialCore pm)
            {
                if (pm.DiffuseMap == null)
                {
                    this.mwriter.WriteLine(string.Format("Kd {0}", this.ToColorString(pm.DiffuseColor)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", pm.DiffuseColor.Alpha));
                    }
                    else
                    {
                        // Transparency
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", pm.DiffuseColor.Alpha));
                    }
                }
                else
                {
                    var textureFilename = matName + ".png";
                    var texturePath = Path.Combine(this.directory, textureFilename);

                    // create .png bitmap file for the brush
                    RenderBrush(texturePath, pm.DiffuseMap.CompressedStream);
                    this.mwriter.WriteLine(string.Format("map_Ka {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (material is PhongMaterialCore pm)
            {
                this.mwriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(pm.DiffuseMap == null ? pm.SpecularColor : new Color4(0.2f, 0.2f, 0.2f, 1.0f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                this.mwriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", pm.SpecularShininess));
            }

            // roughness
            this.mwriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            this.mwriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            this.mwriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            this.mwriter.WriteLine(string.Format("illum {0}", illum));
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color4 color)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:F4} {1:F4} {2:F4}",
                color.Red,
                color.Green,
                color.Blue);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(209,50): error CS0246: The type or namespace name 'Matrix' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(418,38): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(232,29): error CS0103: The name 'Vector3' does not exist in the current context,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(364,101): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(10,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(209,50): error CS0246: The type or namespace name 'Matrix' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(417,38): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(232,29): error CS0103: The name 'Vector3' does not exist in the current context,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(359,47): error CS0128: A local variable or function named 'pm' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(363,101): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(363,54): error CS0165: Use of unassigned local variable 'pm',D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(10,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 8 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using global::SharpDX;
#if COREWPF
using HelixToolkit.SharpDX.Core;
using HelixToolkit.SharpDX.Core.Utilities;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
#if !COREWPF
    using Core;
#endif

    namespace Utilities
    {
        public abstract class FromToStringTypeConverter : TypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }
        }

        public sealed class Vector2CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector2Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector2Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector3Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector3Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class IntCollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return IntCollection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is IntCollection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Color4Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Color4Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class ColorConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is string source)
                {
                    try
                    {
                        var c = System.Windows.Media.ColorConverter.ConvertFromString(source);
                        if (c != null)
                        {
                            var color = (System.Windows.Media.Color)c;
                            return new Color(color.R, color.G, color.B, color.A);
                        }
                    }
                    catch (FormatException) { }
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Color(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }
                else if(value is System.Windows.Media.Color)
                {
                    return (Color)((System.Windows.Media.Color)value).ToColor4();
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color)
                {
                    var val = (Color)value;
                    if (destinationType == typeof(string))
                    {
                   
                        var str = string.Format("{0},{1},{2},{3}", val.R, val.G, val.B, val.A);
                        return str;
                    }
                    else if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return System.Windows.Media.Color.FromArgb(val.A, val.R, val.G, val.B);
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Color)
                {
                    return ((System.Windows.Media.Color)value).ToColor4();
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var sepChar = TokenizerHelper.GetNumericListSeparator(CultureInfo.InvariantCulture);
                        if (source.Contains(sepChar.ToString()))
                        {
                            var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                            var result = new Color4(
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                            return result;
                        }

                        try
                        {
                            var obj = System.Windows.Media.ColorConverter.ConvertFromString(source);
                            if (obj is System.Windows.Media.Color color)
                            {
                                return color.ToColor4();
                            }
                        } catch (Exception) {}
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color4)
                {
                    var val = (Color4)value;
                    if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return val.ToColor();
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2},{3}", val.Red, val.Green, val.Blue, val.Alpha);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector2Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Vector) || sourceType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Vector) || destinationType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if (value is System.Windows.Vector)
                {
                    var source = (System.Windows.Vector)value;
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else if (value is System.Windows.Media.Media3D.Point3D)
                {
                    var source = (System.Windows.Media.Media3D.Point3D)value;
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector2(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector2)
                {
                    var val = (Vector2)value;
                    if (destinationType == typeof(System.Windows.Vector))
                    {
                        return new System.Windows.Vector(val.X, val.Y);
                    }
                    else if (destinationType == typeof(System.Windows.Point))
                    {
                        return new System.Windows.Point(val.X, val.Y);
                    }
                    else if (destinationType == typeof(string))
                    {
                        var str = string.Format("{0},{1}", val.X, val.Y);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if(sourceType == typeof(System.Windows.Media.Media3D.Vector3D) || sourceType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D) || destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Media3D.Vector3D)
                {
                    var source = (System.Windows.Media.Media3D.Vector3D)value;
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else if(value is System.Windows.Media.Media3D.Point3D)
                {
                    var source = (System.Windows.Media.Media3D.Point3D)value;
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector3(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }


                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector3)
                {
                    var val = (Vector3)value;
                    if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D))
                    {
                        return new System.Windows.Media.Media3D.Vector3D(val.X, val.Y, val.Z);
                    }
                    else if(destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                    {
                        return new System.Windows.Media.Media3D.Point3D(val.X, val.Y, val.Z);
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2}", val.X, val.Y, val.Z);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector4Converter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Vector4(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Vector4)
                {
                    var val = (Vector4)value;
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class QuaternionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Quaternion(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Quaternion val)
                {
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }

}

---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using global::SharpDX;
#if COREWPF
using HelixToolkit.SharpDX.Core;
using HelixToolkit.SharpDX.Core.Utilities;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
#if !COREWPF
    using Core;
#endif

    namespace Utilities
    {
        public abstract class FromToStringTypeConverter : TypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }
        }

        public sealed class Vector2CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector2Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector2Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector3Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector3Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class IntCollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return IntCollection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is IntCollection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Color4Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Color4Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class ColorConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is string source)
                {
                    try
                    {
                        var c = System.Windows.Media.ColorConverter.ConvertFromString(source);
                        if (c != null)
                        {
                            var color = (System.Windows.Media.Color)c;
                            return new Color(color.R, color.G, color.B, color.A);
                        }
                    }
                    catch (FormatException) { }
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Color(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }
                else if(value is System.Windows.Media.Color color)
                {
                    return (Color)color.ToColor4();
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color val)
                {
                    if (destinationType == typeof(string))
                    {
                   
                        var str = string.Format("{0},{1},{2},{3}", val.R, val.G, val.B, val.A);
                        return str;
                    }
                    else if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return System.Windows.Media.Color.FromArgb(val.A, val.R, val.G, val.B);
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Color color)
                {
                    return color.ToColor4();
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var sepChar = TokenizerHelper.GetNumericListSeparator(CultureInfo.InvariantCulture);
                        if (source.Contains(sepChar.ToString()))
                        {
                            var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                            var result = new Color4(
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                            return result;
                        }

                        try
                        {
                            var obj = System.Windows.Media.ColorConverter.ConvertFromString(source);
                            if (obj is System.Windows.Media.Color color)
                            {
                                return color.ToColor4();
                            }
                        } catch (Exception) {}
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color4 val)
                {
                    if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return val.ToColor();
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2},{3}", val.Red, val.Green, val.Blue, val.Alpha);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector2Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Vector) || sourceType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Vector) || destinationType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if (value is System.Windows.Vector source)
                {
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else if (value is System.Windows.Media.Media3D.Point3D source)
                {
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector2(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector2 val)
                {
                    if (destinationType == typeof(System.Windows.Vector))
                    {
                        return new System.Windows.Vector(val.X, val.Y);
                    }
                    else if (destinationType == typeof(System.Windows.Point))
                    {
                        return new System.Windows.Point(val.X, val.Y);
                    }
                    else if (destinationType == typeof(string))
                    {
                        var str = string.Format("{0},{1}", val.X, val.Y);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if(sourceType == typeof(System.Windows.Media.Media3D.Vector3D) || sourceType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D) || destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Media3D.Vector3D source)
                {
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else if(value is System.Windows.Media.Media3D.Point3D source)
                {
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector3(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }


                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector3 val)
                {
                    if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D))
                    {
                        return new System.Windows.Media.Media3D.Vector3D(val.X, val.Y, val.Z);
                    }
                    else if(destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                    {
                        return new System.Windows.Media.Media3D.Point3D(val.X, val.Y, val.Z);
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2}", val.X, val.Y, val.Z);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector4Converter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Vector4(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Vector4)
                {
                    var val = (Vector4)value;
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class QuaternionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Quaternion(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Quaternion val)
                {
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }

}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(516,38): error CS0246: The type or namespace name 'Quaternion' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(529,67): error CS0246: The type or namespace name 'Quaternion' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(340,32): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(345,32): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(354,42): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(194,40): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(199,38): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(208,29): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(478,38): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(491,67): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(493,32): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(272,46): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(215,29): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(217,32): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(365,29): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(367,32): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(295,29): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(297,32): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(415,32): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(420,32): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(429,42): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(443,29): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(445,32): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(18,5): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(10,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(508,38): error CS0246: The type or namespace name 'Quaternion' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(521,67): error CS0246: The type or namespace name 'Quaternion' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(470,38): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(483,67): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(485,32): error CS0246: The type or namespace name 'Vector4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(194,40): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(199,38): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(208,29): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(409,32): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(411,71): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(413,32): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(417,25): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(422,42): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(337,32): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(339,72): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(341,32): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(345,25): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(350,42): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(215,29): error CS0246: The type or namespace name 'Color' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(361,29): error CS0246: The type or namespace name 'Vector2' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(436,29): error CS0246: The type or namespace name 'Vector3' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(271,46): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(282,67): error CS0136: A local or parameter named 'color' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(294,29): error CS0246: The type or namespace name 'Color4' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(18,5): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(10,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\Source\HelixToolkit.SharpDX.Assimp.Shared\ImporterPartial_Animation.cs
Description: Error: Unable to create valid SyntaxTree for document: ImporterPartial_Animation.cs. Caught exception: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitForEachStatement(ForEachStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
------------------------------------------------------------------------
---- Original Tree ----
using Assimp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Animation = Assimp.Animation;

#if !NETFX_CORE
namespace HelixToolkit.Wpf.SharpDX
#else
#if CORE
namespace HelixToolkit.SharpDX.Core
#else
namespace HelixToolkit.UWP
#endif
#endif
{
    using HxAnimations = Animations;
    using HxScene = Model.Scene;
    namespace Assimp
    {
        /// <summary>
        /// 
        /// </summary>
        public partial class Importer
        {
            /// <summary>
            /// Processes the node animation.
            /// </summary>
            /// <param name="channel">The channel.</param>
            /// <param name="ticksPerSecond">The ticks per second.</param>
            /// <param name="list">The list.</param>
            /// <returns></returns>
            protected virtual ErrorCode ProcessNodeAnimation(NodeAnimationChannel channel, double ticksPerSecond, out FastList<HxAnimations.Keyframe> list)
            {
                var posCount = channel.HasPositionKeys ? channel.PositionKeyCount : 0;
                var rotCount = channel.HasRotationKeys ? channel.RotationKeyCount : 0;
                var scaleCount = channel.HasScalingKeys ? channel.ScalingKeyCount : 0;
                int maxCount = Math.Max(posCount, Math.Max(rotCount, scaleCount));
                var ret = new FastList<HxAnimations.Keyframe>(maxCount);
                if (posCount != rotCount || rotCount != scaleCount)
                {
                    Log(HelixToolkit.Logger.LogLevel.Trace, 
                        "Animation Channel is non-uniform lengths." +
                        $" Position={posCount}; Rotation={rotCount}; Scale={scaleCount};" +
                        " Trying to automatically create uniform animation keys");
                    // Adds dummy key if it is empty
                    if (posCount == 0)
                    {
                        channel.PositionKeys.Add(new VectorKey(0, new Vector3D()));
                    }
                    if(rotCount == 0)
                    {
                        channel.RotationKeys.Add(new QuaternionKey(0, new Quaternion()));
                    }
                    if(scaleCount == 0)
                    {
                        channel.ScalingKeys.Add(new VectorKey(0, new Vector3D(1, 1, 1)));
                    }
                    int i = 0, j = 0, k = 0;
                    double nextT1 = channel.PositionKeys[i].Time, 
                        nextT2 = channel.RotationKeys[j].Time, 
                        nextT3 = channel.ScalingKeys[k].Time;
                    var minT = Math.Min(nextT1, Math.Min(nextT2, nextT3));

                    for (int x = 0; x < maxCount && i < posCount && j < rotCount && k < scaleCount; ++x)
                    {                       
                        ret.Add(new HxAnimations.Keyframe()
                        {
                            Time = (float)(minT / ticksPerSecond),
                            Translation = channel.PositionKeys[i].Value.ToSharpDXVector3(),
                            Rotation = channel.RotationKeys[j].Value.ToSharpDXQuaternion(),
                            Scale = channel.ScalingKeys[k].Value.ToSharpDXVector3(),
                        });
                        nextT1 = (i + 1) < posCount ? channel.PositionKeys[i + 1].Time : double.MaxValue; // Set to max so index will not increase
                        nextT2 = (j + 1) < rotCount ? channel.RotationKeys[j + 1].Time : double.MaxValue;
                        nextT3 = (k + 1) < scaleCount ? channel.ScalingKeys[k + 1].Time : double.MaxValue;

                        minT = Math.Min(nextT1, Math.Min(nextT2, nextT3));
                        if (minT == nextT1)
                        {
                            ++i;
                        }
                        if(minT == nextT2)
                        {
                            ++j;
                        }
                        if(minT == nextT3)
                        {
                            ++k;
                        }
                    }
                }
                else
                {
                    for(int i = 0; i < posCount; ++i)
                    {
                        ret.Add(new HxAnimations.Keyframe()
                        {
                            Time = (float)(channel.PositionKeys[i].Time / ticksPerSecond),
                            Translation = channel.PositionKeys[i].Value.ToSharpDXVector3(),
                            Rotation = channel.RotationKeys[i].Value.ToSharpDXQuaternion(),
                            Scale = channel.ScalingKeys[i].Value.ToSharpDXVector3()
                        });
                    }
                }

                list = ret;
                return ErrorCode.Succeed;
            }

            private ErrorCode LoadAnimations(HelixInternalScene scene)
            {
                var dict = new Dictionary<string, HxScene.SceneNode>(SceneNodes.Count);
                foreach (var node in SceneNodes)
                {
                    if (node is HxScene.GroupNode && !dict.ContainsKey(node.Name))
                    {
                        dict.Add(node.Name, node);
                    }
                }

                var nodeIdxDict = new Dictionary<string, int>();
                foreach (var node in SceneNodes.Where(x => x is Animations.IBoneMatricesNode)
                    .Select(x => x as Animations.IBoneMatricesNode))
                {
                    if (node.Bones != null)
                    {
                        nodeIdxDict.Clear();
                        for(var i = 0; i < node.Bones.Length; ++i)
                        {
                            nodeIdxDict.Add(node.Bones[i].Name, i);
                        }
                        for (var i = 0; i < node.Bones.Length; ++i)
                        {
                            if (dict.TryGetValue(node.Bones[i].Name, out var s))
                            {
                                ref var b = ref node.Bones[i];
                                b.ParentNode = s.Parent;
                                b.Node = s;
                                b.BoneLocalTransform = s.ModelMatrix;
                                if(s.Parent != null && nodeIdxDict.TryGetValue(s.Parent.Name, out var idx))
                                {
                                    b.ParentIndex = idx;
                                }
                                s.IsAnimationNode = true; // Make sure to set this to true                                   
                            }
                        }

                        if(Configuration.CreateSkeletonForBoneSkinningMesh 
                            && node is HxScene.BoneSkinMeshNode sk 
                            && sk.Parent is HxScene.GroupNodeBase group)
                        {
                            var skeleton = sk.CreateSkeletonNode(Configuration.SkeletonMaterial,
                                Configuration.SkeletonEffects, Configuration.SkeletonSizeScale);
                            skeleton.Name = "HxSK_" + sk.Name;
                            group.AddChildNode(skeleton);
                        }

                        //Setup bone matrices initially if it's morphable (unable to render w/o bones)
                        if (node is HxScene.BoneSkinMeshNode sn 
                            && sn.MorphTargetWeights.Length > 0 
                            && sn.BoneMatrices?.Length == 0)
                        {
                            sn.UpdateBoneMatrices();
                        }
                    }
                }

                if (scene.AssimpScene.HasAnimations)
                {
                    bool hasBoneSkinnedMesh = scene.Meshes.Where(x => x.Mesh is BoneSkinnedMeshGeometry3D).Any()? true : false;
                    var animationList = new List<HxAnimations.Animation>(scene.AssimpScene.AnimationCount);
                    if (Configuration.EnableParallelProcessing)
                    {
                        Parallel.ForEach(scene.AssimpScene.Animations, ani =>
                        {
                            if (LoadAnimation(ani, dict, hasBoneSkinnedMesh, out var hxAni) == ErrorCode.Succeed)
                            {
                                lock (animationList)
                                {
                                    animationList.Add(hxAni);
                                }
                            }

                            if (LoadMorphAnimation(ani, dict, hasBoneSkinnedMesh, out var hxMAni) == ErrorCode.Succeed)
                            {
                                lock (animationList)
                                {
                                    animationList.AddRange(hxMAni);
                                }
                            }
                        });
                    }
                    else
                    {
                        foreach (var ani in scene.AssimpScene.Animations)
                        {
                            if (LoadAnimation(ani, dict, hasBoneSkinnedMesh, out var hxAni) == ErrorCode.Succeed)
                                animationList.Add(hxAni);
                            if (LoadMorphAnimation(ani, dict, hasBoneSkinnedMesh, out var hxMAni) == ErrorCode.Succeed)
                                animationList.AddRange(hxMAni);
                        }
                    }
                    scene.Animations = animationList;
                    Animations.AddRange(animationList);
                }
                return ErrorCode.Succeed;
            }

            private ErrorCode LoadAnimation(Animation ani, Dictionary<string, HxScene.SceneNode> dict, bool searchBoneSkinMeshNode,
                out HxAnimations.Animation hxAni)
            {
                if (ani.TicksPerSecond == 0)
                {
                    Log(HelixToolkit.Logger.LogLevel.Warning, $"Animation TicksPerSecond is 0. Set to {configuration.TickesPerSecond}");
                    ani.TicksPerSecond = configuration.TickesPerSecond;
                }
                hxAni = new HxAnimations.Animation(HxAnimations.AnimationType.Node)
                {
                    StartTime = 0,
                    EndTime = (float)(ani.DurationInTicks / ani.TicksPerSecond),
                    Name = ani.Name,
                    NodeAnimationCollection = new List<HxAnimations.NodeAnimation>(ani.NodeAnimationChannelCount)
                };

                if (ani.HasNodeAnimations)
                {
                    var code = ErrorCode.None;
                    foreach (var key in ani.NodeAnimationChannels)
                    {
                        System.Diagnostics.Debug.WriteLine(key.NodeName);
                        if (dict.TryGetValue(key.NodeName, out var node))
                        {
                            var nAni = new HxAnimations.NodeAnimation
                            {
                                Node = node
                            };
                            
                            node.IsAnimationNode = true;// Make sure to set this to true
                            code = ProcessNodeAnimation(key, ani.TicksPerSecond, out var keyframes);
                            if (code == ErrorCode.Succeed)
                            {
                                nAni.KeyFrames = keyframes;
                                hxAni.NodeAnimationCollection.Add(nAni);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    if (searchBoneSkinMeshNode)
                    {
                        FindBoneSkinMeshes(hxAni);
                    }
                    return code;
                }

                return ErrorCode.Failed;
            }

            private ErrorCode LoadMorphAnimation(Animation ani, Dictionary<string, HxScene.SceneNode> dict, bool searchBoneSkinMeshNode,
                out List<HxAnimations.Animation> hxAnis)
            {
                if (ani.TicksPerSecond == 0)
                {
                    Log(HelixToolkit.Logger.LogLevel.Warning, $"Animation TicksPerSecond is 0. Set to {configuration.TickesPerSecond}");
                    ani.TicksPerSecond = configuration.TickesPerSecond;
                }

                hxAnis = new List<HxAnimations.Animation>();
                if (ani.MeshMorphAnimationChannelCount > 0)
                {
                    foreach (MeshMorphAnimationChannel aniChannel in ani.MeshMorphAnimationChannels)
                    {
                        HxAnimations.Animation hxAni = new HxAnimations.Animation(HxAnimations.AnimationType.MorphTarget)
                        {
                            StartTime = 0,
                            EndTime = (float)(ani.DurationInTicks / ani.TicksPerSecond),
                            Name = ani.Name,
                            MorphTargetKeyframes = new List<HxAnimations.MorphTargetKeyframe>()
                        };

                        //Reference node (removes "*0", i don't know why but its there sometimes)
                        string nodeName = aniChannel.Name.Replace("*0", "");
                        if (dict.TryGetValue(nodeName, out var node))
                            hxAni.RootNode = node.Items.Where(i => (i as HxScene.BoneSkinMeshNode).MorphTargetWeights?.Length > 0).FirstOrDefault();
                        else
                            continue;

                        //Add keyframes
                        foreach (var key in aniChannel.MeshMorphKeys)
                        {
                            for (int i = 0; i < key.Values.Count; i++)
                            {
                                hxAni.MorphTargetKeyframes.Add(new HxAnimations.MorphTargetKeyframe()
                                {
                                    Index = key.Values[i],
                                    Weight = (float)key.Weights[i],
                                    Time = (float)key.Time / (float)ani.TicksPerSecond
                                });
                            }
                        }
                        if (searchBoneSkinMeshNode)
                        {
                            FindBoneSkinMeshes(hxAni);
                        }
                        hxAnis.Add(hxAni);
                    }

                    return ErrorCode.Succeed;
                }

                return ErrorCode.Failed;
            }

            private void FindBoneSkinMeshes(HxAnimations.Animation animation)
            {
                if (animation.NodeAnimationCollection != null && animation.NodeAnimationCollection.Count > 0)
                {
                    // Search all the bone skinned meshes from the common animation node root
                    var node = animation.NodeAnimationCollection[0].Node;
                    while (node != null && !node.IsAnimationNodeRoot)
                    {
                        node = node.Parent;
                    }

                    if (node == null)
                    {
                        return;
                    }

                    if (node.Parent != null)
                        node = node.Parent;
                    animation.BoneSkinMeshes = new List<Animations.IBoneMatricesNode>();
                    animation.RootNode = node;
                    foreach (var n in SceneNodes[0].Items.PreorderDFT((m) => { return true; }))
                    {
                        if (n is Animations.IBoneMatricesNode boneNode)
                        {
                            animation.BoneSkinMeshes.Add(boneNode);
                        }
                    }
                }
                else if (animation.MorphTargetKeyframes != null && animation.MorphTargetKeyframes.Count > 0)
                {
                    animation.BoneSkinMeshes = new List<HxAnimations.IBoneMatricesNode>();
                    if (animation.RootNode is HxAnimations.IBoneMatricesNode bnode)
                    {
                        animation.BoneSkinMeshes.Add(bnode);
                    }
                }
            }
        }
    }
}
---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 10 - SimplifyLinqRewriterR4
Filepath: D:\a\1\s\Source\HelixToolkit.SharpDX.Assimp.Shared\ImporterPartial_Animation.cs
Description: Error: Unable to create valid SyntaxTree for document: ImporterPartial_Animation.cs. Caught exception: System.InvalidCastException: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
   at EagleRepair.Ast.Rewriter.SimplifyLinqRewriterR4.VisitInvocationExpression(InvocationExpressionSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/SimplifyLinqRewriterR4.cs:line 238
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitForEachStatement(ForEachStatementSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitBlock(BlockSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitMethodDeclaration(MethodDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: Unable to cast object of type 'Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax' to type 'Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax'.
------------------------------------------------------------------------
---- Original Tree ----
using Assimp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Animation = Assimp.Animation;

#if !NETFX_CORE
namespace HelixToolkit.Wpf.SharpDX
#else
#if CORE
namespace HelixToolkit.SharpDX.Core
#else
namespace HelixToolkit.UWP
#endif
#endif
{
    using HxAnimations = Animations;
    using HxScene = Model.Scene;
    namespace Assimp
    {
        /// <summary>
        /// 
        /// </summary>
        public partial class Importer
        {
            /// <summary>
            /// Processes the node animation.
            /// </summary>
            /// <param name="channel">The channel.</param>
            /// <param name="ticksPerSecond">The ticks per second.</param>
            /// <param name="list">The list.</param>
            /// <returns></returns>
            protected virtual ErrorCode ProcessNodeAnimation(NodeAnimationChannel channel, double ticksPerSecond, out FastList<HxAnimations.Keyframe> list)
            {
                var posCount = channel.HasPositionKeys ? channel.PositionKeyCount : 0;
                var rotCount = channel.HasRotationKeys ? channel.RotationKeyCount : 0;
                var scaleCount = channel.HasScalingKeys ? channel.ScalingKeyCount : 0;
                int maxCount = Math.Max(posCount, Math.Max(rotCount, scaleCount));
                var ret = new FastList<HxAnimations.Keyframe>(maxCount);
                if (posCount != rotCount || rotCount != scaleCount)
                {
                    Log(HelixToolkit.Logger.LogLevel.Trace, 
                        "Animation Channel is non-uniform lengths." +
                        $" Position={posCount}; Rotation={rotCount}; Scale={scaleCount};" +
                        " Trying to automatically create uniform animation keys");
                    // Adds dummy key if it is empty
                    if (posCount == 0)
                    {
                        channel.PositionKeys.Add(new VectorKey(0, new Vector3D()));
                    }
                    if(rotCount == 0)
                    {
                        channel.RotationKeys.Add(new QuaternionKey(0, new Quaternion()));
                    }
                    if(scaleCount == 0)
                    {
                        channel.ScalingKeys.Add(new VectorKey(0, new Vector3D(1, 1, 1)));
                    }
                    int i = 0, j = 0, k = 0;
                    double nextT1 = channel.PositionKeys[i].Time, 
                        nextT2 = channel.RotationKeys[j].Time, 
                        nextT3 = channel.ScalingKeys[k].Time;
                    var minT = Math.Min(nextT1, Math.Min(nextT2, nextT3));

                    for (int x = 0; x < maxCount && i < posCount && j < rotCount && k < scaleCount; ++x)
                    {                       
                        ret.Add(new HxAnimations.Keyframe()
                        {
                            Time = (float)(minT / ticksPerSecond),
                            Translation = channel.PositionKeys[i].Value.ToSharpDXVector3(),
                            Rotation = channel.RotationKeys[j].Value.ToSharpDXQuaternion(),
                            Scale = channel.ScalingKeys[k].Value.ToSharpDXVector3(),
                        });
                        nextT1 = (i + 1) < posCount ? channel.PositionKeys[i + 1].Time : double.MaxValue; // Set to max so index will not increase
                        nextT2 = (j + 1) < rotCount ? channel.RotationKeys[j + 1].Time : double.MaxValue;
                        nextT3 = (k + 1) < scaleCount ? channel.ScalingKeys[k + 1].Time : double.MaxValue;

                        minT = Math.Min(nextT1, Math.Min(nextT2, nextT3));
                        if (minT == nextT1)
                        {
                            ++i;
                        }
                        if(minT == nextT2)
                        {
                            ++j;
                        }
                        if(minT == nextT3)
                        {
                            ++k;
                        }
                    }
                }
                else
                {
                    for(int i = 0; i < posCount; ++i)
                    {
                        ret.Add(new HxAnimations.Keyframe()
                        {
                            Time = (float)(channel.PositionKeys[i].Time / ticksPerSecond),
                            Translation = channel.PositionKeys[i].Value.ToSharpDXVector3(),
                            Rotation = channel.RotationKeys[i].Value.ToSharpDXQuaternion(),
                            Scale = channel.ScalingKeys[i].Value.ToSharpDXVector3()
                        });
                    }
                }

                list = ret;
                return ErrorCode.Succeed;
            }

            private ErrorCode LoadAnimations(HelixInternalScene scene)
            {
                var dict = new Dictionary<string, HxScene.SceneNode>(SceneNodes.Count);
                foreach (var node in SceneNodes)
                {
                    if (node is HxScene.GroupNode && !dict.ContainsKey(node.Name))
                    {
                        dict.Add(node.Name, node);
                    }
                }

                var nodeIdxDict = new Dictionary<string, int>();
                foreach (var node in SceneNodes.Where(x => x is Animations.IBoneMatricesNode)
                    .Select(x => x as Animations.IBoneMatricesNode))
                {
                    if (node.Bones != null)
                    {
                        nodeIdxDict.Clear();
                        for(var i = 0; i < node.Bones.Length; ++i)
                        {
                            nodeIdxDict.Add(node.Bones[i].Name, i);
                        }
                        for (var i = 0; i < node.Bones.Length; ++i)
                        {
                            if (dict.TryGetValue(node.Bones[i].Name, out var s))
                            {
                                ref var b = ref node.Bones[i];
                                b.ParentNode = s.Parent;
                                b.Node = s;
                                b.BoneLocalTransform = s.ModelMatrix;
                                if(s.Parent != null && nodeIdxDict.TryGetValue(s.Parent.Name, out var idx))
                                {
                                    b.ParentIndex = idx;
                                }
                                s.IsAnimationNode = true; // Make sure to set this to true                                   
                            }
                        }

                        if(Configuration.CreateSkeletonForBoneSkinningMesh 
                            && node is HxScene.BoneSkinMeshNode sk 
                            && sk.Parent is HxScene.GroupNodeBase group)
                        {
                            var skeleton = sk.CreateSkeletonNode(Configuration.SkeletonMaterial,
                                Configuration.SkeletonEffects, Configuration.SkeletonSizeScale);
                            skeleton.Name = "HxSK_" + sk.Name;
                            group.AddChildNode(skeleton);
                        }

                        //Setup bone matrices initially if it's morphable (unable to render w/o bones)
                        if (node is HxScene.BoneSkinMeshNode sn 
                            && sn.MorphTargetWeights.Length > 0 
                            && sn.BoneMatrices?.Length == 0)
                        {
                            sn.UpdateBoneMatrices();
                        }
                    }
                }

                if (scene.AssimpScene.HasAnimations)
                {
                    bool hasBoneSkinnedMesh = scene.Meshes.Where(x => x.Mesh is BoneSkinnedMeshGeometry3D).Any()? true : false;
                    var animationList = new List<HxAnimations.Animation>(scene.AssimpScene.AnimationCount);
                    if (Configuration.EnableParallelProcessing)
                    {
                        Parallel.ForEach(scene.AssimpScene.Animations, ani =>
                        {
                            if (LoadAnimation(ani, dict, hasBoneSkinnedMesh, out var hxAni) == ErrorCode.Succeed)
                            {
                                lock (animationList)
                                {
                                    animationList.Add(hxAni);
                                }
                            }

                            if (LoadMorphAnimation(ani, dict, hasBoneSkinnedMesh, out var hxMAni) == ErrorCode.Succeed)
                            {
                                lock (animationList)
                                {
                                    animationList.AddRange(hxMAni);
                                }
                            }
                        });
                    }
                    else
                    {
                        foreach (var ani in scene.AssimpScene.Animations)
                        {
                            if (LoadAnimation(ani, dict, hasBoneSkinnedMesh, out var hxAni) == ErrorCode.Succeed)
                                animationList.Add(hxAni);
                            if (LoadMorphAnimation(ani, dict, hasBoneSkinnedMesh, out var hxMAni) == ErrorCode.Succeed)
                                animationList.AddRange(hxMAni);
                        }
                    }
                    scene.Animations = animationList;
                    Animations.AddRange(animationList);
                }
                return ErrorCode.Succeed;
            }

            private ErrorCode LoadAnimation(Animation ani, Dictionary<string, HxScene.SceneNode> dict, bool searchBoneSkinMeshNode,
                out HxAnimations.Animation hxAni)
            {
                if (ani.TicksPerSecond == 0)
                {
                    Log(HelixToolkit.Logger.LogLevel.Warning, $"Animation TicksPerSecond is 0. Set to {configuration.TickesPerSecond}");
                    ani.TicksPerSecond = configuration.TickesPerSecond;
                }
                hxAni = new HxAnimations.Animation(HxAnimations.AnimationType.Node)
                {
                    StartTime = 0,
                    EndTime = (float)(ani.DurationInTicks / ani.TicksPerSecond),
                    Name = ani.Name,
                    NodeAnimationCollection = new List<HxAnimations.NodeAnimation>(ani.NodeAnimationChannelCount)
                };

                if (ani.HasNodeAnimations)
                {
                    var code = ErrorCode.None;
                    foreach (var key in ani.NodeAnimationChannels)
                    {
                        System.Diagnostics.Debug.WriteLine(key.NodeName);
                        if (dict.TryGetValue(key.NodeName, out var node))
                        {
                            var nAni = new HxAnimations.NodeAnimation
                            {
                                Node = node
                            };
                            
                            node.IsAnimationNode = true;// Make sure to set this to true
                            code = ProcessNodeAnimation(key, ani.TicksPerSecond, out var keyframes);
                            if (code == ErrorCode.Succeed)
                            {
                                nAni.KeyFrames = keyframes;
                                hxAni.NodeAnimationCollection.Add(nAni);
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    if (searchBoneSkinMeshNode)
                    {
                        FindBoneSkinMeshes(hxAni);
                    }
                    return code;
                }

                return ErrorCode.Failed;
            }

            private ErrorCode LoadMorphAnimation(Animation ani, Dictionary<string, HxScene.SceneNode> dict, bool searchBoneSkinMeshNode,
                out List<HxAnimations.Animation> hxAnis)
            {
                if (ani.TicksPerSecond == 0)
                {
                    Log(HelixToolkit.Logger.LogLevel.Warning, $"Animation TicksPerSecond is 0. Set to {configuration.TickesPerSecond}");
                    ani.TicksPerSecond = configuration.TickesPerSecond;
                }

                hxAnis = new List<HxAnimations.Animation>();
                if (ani.MeshMorphAnimationChannelCount > 0)
                {
                    foreach (MeshMorphAnimationChannel aniChannel in ani.MeshMorphAnimationChannels)
                    {
                        HxAnimations.Animation hxAni = new HxAnimations.Animation(HxAnimations.AnimationType.MorphTarget)
                        {
                            StartTime = 0,
                            EndTime = (float)(ani.DurationInTicks / ani.TicksPerSecond),
                            Name = ani.Name,
                            MorphTargetKeyframes = new List<HxAnimations.MorphTargetKeyframe>()
                        };

                        //Reference node (removes "*0", i don't know why but its there sometimes)
                        string nodeName = aniChannel.Name.Replace("*0", "");
                        if (dict.TryGetValue(nodeName, out var node))
                            hxAni.RootNode = node.Items.Where(i => (i as HxScene.BoneSkinMeshNode).MorphTargetWeights?.Length > 0).FirstOrDefault();
                        else
                            continue;

                        //Add keyframes
                        foreach (var key in aniChannel.MeshMorphKeys)
                        {
                            for (int i = 0; i < key.Values.Count; i++)
                            {
                                hxAni.MorphTargetKeyframes.Add(new HxAnimations.MorphTargetKeyframe()
                                {
                                    Index = key.Values[i],
                                    Weight = (float)key.Weights[i],
                                    Time = (float)key.Time / (float)ani.TicksPerSecond
                                });
                            }
                        }
                        if (searchBoneSkinMeshNode)
                        {
                            FindBoneSkinMeshes(hxAni);
                        }
                        hxAnis.Add(hxAni);
                    }

                    return ErrorCode.Succeed;
                }

                return ErrorCode.Failed;
            }

            private void FindBoneSkinMeshes(HxAnimations.Animation animation)
            {
                if (animation.NodeAnimationCollection != null && animation.NodeAnimationCollection.Count > 0)
                {
                    // Search all the bone skinned meshes from the common animation node root
                    var node = animation.NodeAnimationCollection[0].Node;
                    while (node != null && !node.IsAnimationNodeRoot)
                    {
                        node = node.Parent;
                    }

                    if (node == null)
                    {
                        return;
                    }

                    if (node.Parent != null)
                        node = node.Parent;
                    animation.BoneSkinMeshes = new List<Animations.IBoneMatricesNode>();
                    animation.RootNode = node;
                    foreach (var n in SceneNodes[0].Items.PreorderDFT((m) => { return true; }))
                    {
                        if (n is Animations.IBoneMatricesNode boneNode)
                        {
                            animation.BoneSkinMeshes.Add(boneNode);
                        }
                    }
                }
                else if (animation.MorphTargetKeyframes != null && animation.MorphTargetKeyframes.Count > 0)
                {
                    animation.BoneSkinMeshes = new List<HxAnimations.IBoneMatricesNode>();
                    if (animation.RootNode is HxAnimations.IBoneMatricesNode bnode)
                    {
                        animation.BoneSkinMeshes.Add(bnode);
                    }
                }
            }
        }
    }
}
---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Windows.Media.Media3D;
using global::SharpDX;

#if COREWPF
using HelixToolkit.SharpDX.Core.Model;
using HelixToolkit.SharpDX.Core.Model.Scene;
using MeshGeometry3D = HelixToolkit.SharpDX.Core.MeshGeometry3D;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
    
#if !COREWPF
    using Model;
    using Model.Scene;
#endif

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter
    {
        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// The directory.
        /// </summary>
        private readonly string directory;

        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<MaterialCore, string> exportedMaterials = new Dictionary<MaterialCore, string>();

        /// <summary>
        /// The mwriter.
        /// </summary>
        private readonly StreamWriter mwriter;

        /// <summary>
        /// The writer.
        /// </summary>
        private readonly StreamWriter writer;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Object index counter.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Group index counter.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// Material index counter.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        public ObjExporter(string outputFileName)
            : this(outputFileName, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        /// <param name="comment">
        /// The comment.
        /// </param>
        public ObjExporter(string outputFileName, string comment)
        {
            this.SwitchYZ = true;
            this.ExportNormals = false;

            var fullPath = Path.GetFullPath(outputFileName);
            var mtlPath = Path.ChangeExtension(outputFileName, ".mtl");
            string mtlFilename = Path.GetFileName(mtlPath);
            this.directory = Path.GetDirectoryName(fullPath);

            this.writer = new StreamWriter(outputFileName);
            this.mwriter = new StreamWriter(mtlPath);

            if (!string.IsNullOrEmpty(comment))
            {
                this.writer.WriteLine(string.Format("# {0}", comment));
            }

            this.writer.WriteLine("mtllib ./" + mtlFilename);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        public override void Close()
        {
            this.writer.Close();
            this.mwriter.Close();
            base.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        /// <param name="transform">
        /// The transform.
        /// </param>
        protected override void ExportModel(MeshNode model, Transform3D transform)
        {
            if(model.GeometryValid && model.Material != null)
            {
                if(transform == null)
                {
                    transform = Transform3D.Identity;
                }
                this.writer.WriteLine(string.Format("o object{0}", this.objectNo++));
                this.writer.WriteLine(string.Format("g group{0}", this.groupNo++));

                if (this.exportedMaterials.ContainsKey(model.Material))
                {
                    string matName = this.exportedMaterials[model.Material];
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                }
                else
                {
                    string matName = string.Format("mat{0}", this.matNo++);
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                    this.ExportMaterial(matName, model.Material);
                    this.exportedMaterials.Add(model.Material, matName);
                }

                var mesh = model.Geometry as MeshGeometry3D;
                if (model.HasInstances)
                {
                    var m = transform.ToMatrix();
                    for(int i=0; i<model.Instances.Count; ++i)
                    {
                        this.ExportMesh(mesh, model.Instances[i] * m);
                    }
                }
                else
                {
                    this.ExportMesh(mesh, transform.ToMatrix());
                }
            }
        }

        /// <summary>
        /// The export mesh.
        /// </summary>
        /// <param name="m">
        /// The m.
        /// </param>
        /// <param name="t">
        /// The t.
        /// </param>
        public void ExportMesh(MeshGeometry3D m, Matrix t)
        {
            if (m == null)
            {
                throw new ArgumentNullException("m");
            }

            if (t == null)
            {
                throw new ArgumentNullException("t");
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = Vector3.TransformCoordinate(v, t);
                    this.writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                this.writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    this.writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                this.writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    this.writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, vn.Y, vn.Z));
                }

                this.writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
            {
                bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                if (hasTextureIndex && hasNormalIndex)
                {
                    return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                }

                if (hasTextureIndex)
                {
                    return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                }

                if (hasNormalIndex)
                {
                    return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                }

                return vertexIndexMap[i0].ToString();
            };

            if (m.Indices != null)
            {
                for (int i = 0; i < m.Indices.Count; i += 3)
                {
                    int i0 = m.Indices[i];
                    int i1 = m.Indices[i + 1];
                    int i2 = m.Indices[i + 2];

                    this.writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                this.writer.WriteLine(string.Format("# {0} faces", m.Indices.Count / 3));
            }

            this.writer.WriteLine();
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="matName">
        /// The mat name.
        /// </param>
        /// <param name="material">
        /// The material.
        /// </param>
        private void ExportMaterial(string matName, MaterialCore material)
        {
            this.mwriter.WriteLine(string.Format("newmtl {0}", matName));
            var pm = material as PhongMaterialCore;

            if (pm != null)
            {
                if (pm.DiffuseMap == null)
                {
                    this.mwriter.WriteLine(string.Format("Kd {0}", this.ToColorString(pm.DiffuseColor)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", pm.DiffuseColor.Alpha));
                    }
                    else
                    {
                        // Transparency
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", pm.DiffuseColor.Alpha));
                    }
                }
                else
                {
                    var textureFilename = matName + ".png";
                    var texturePath = Path.Combine(this.directory, textureFilename);

                    // create .png bitmap file for the brush
                    RenderBrush(texturePath, pm.DiffuseMap.CompressedStream);
                    this.mwriter.WriteLine(string.Format("map_Ka {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (pm != null)
            {
                this.mwriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(pm.DiffuseMap == null ? pm.SpecularColor : new Color4(0.2f, 0.2f, 0.2f, 1.0f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                this.mwriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", pm.SpecularShininess));
            }

            // roughness
            this.mwriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            this.mwriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            this.mwriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            this.mwriter.WriteLine(string.Format("illum {0}", illum));
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color4 color)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:F4} {1:F4} {2:F4}",
                color.Red,
                color.Green,
                color.Blue);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Windows.Media.Media3D;
using global::SharpDX;

#if COREWPF
using HelixToolkit.SharpDX.Core.Model;
using HelixToolkit.SharpDX.Core.Model.Scene;
using MeshGeometry3D = HelixToolkit.SharpDX.Core.MeshGeometry3D;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
    
#if !COREWPF
    using Model;
    using Model.Scene;
#endif

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter
    {
        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// The directory.
        /// </summary>
        private readonly string directory;

        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<MaterialCore, string> exportedMaterials = new Dictionary<MaterialCore, string>();

        /// <summary>
        /// The mwriter.
        /// </summary>
        private readonly StreamWriter mwriter;

        /// <summary>
        /// The writer.
        /// </summary>
        private readonly StreamWriter writer;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Object index counter.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Group index counter.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// Material index counter.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        public ObjExporter(string outputFileName)
            : this(outputFileName, null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter"/> class.
        /// </summary>
        /// <param name="outputFileName">
        /// Name of the output file.
        /// </param>
        /// <param name="comment">
        /// The comment.
        /// </param>
        public ObjExporter(string outputFileName, string comment)
        {
            this.SwitchYZ = true;
            this.ExportNormals = false;

            var fullPath = Path.GetFullPath(outputFileName);
            var mtlPath = Path.ChangeExtension(outputFileName, ".mtl");
            string mtlFilename = Path.GetFileName(mtlPath);
            this.directory = Path.GetDirectoryName(fullPath);

            this.writer = new StreamWriter(outputFileName);
            this.mwriter = new StreamWriter(mtlPath);

            if (!string.IsNullOrEmpty(comment))
            {
                this.writer.WriteLine(string.Format("# {0}", comment));
            }

            this.writer.WriteLine("mtllib ./" + mtlFilename);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        public override void Close()
        {
            this.writer.Close();
            this.mwriter.Close();
            base.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="model">
        /// The model.
        /// </param>
        /// <param name="transform">
        /// The transform.
        /// </param>
        protected override void ExportModel(MeshNode model, Transform3D transform)
        {
            if(model.GeometryValid && model.Material != null)
            {
                if(transform == null)
                {
                    transform = Transform3D.Identity;
                }
                this.writer.WriteLine(string.Format("o object{0}", this.objectNo++));
                this.writer.WriteLine(string.Format("g group{0}", this.groupNo++));

                if (this.exportedMaterials.ContainsKey(model.Material))
                {
                    string matName = this.exportedMaterials[model.Material];
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                }
                else
                {
                    string matName = string.Format("mat{0}", this.matNo++);
                    this.writer.WriteLine(string.Format("usemtl {0}", matName));
                    this.ExportMaterial(matName, model.Material);
                    this.exportedMaterials.Add(model.Material, matName);
                }

                var mesh = model.Geometry as MeshGeometry3D;
                if (model.HasInstances)
                {
                    var m = transform.ToMatrix();
                    for(int i=0; i<model.Instances.Count; ++i)
                    {
                        this.ExportMesh(mesh, model.Instances[i] * m);
                    }
                }
                else
                {
                    this.ExportMesh(mesh, transform.ToMatrix());
                }
            }
        }

        /// <summary>
        /// The export mesh.
        /// </summary>
        /// <param name="m">
        /// The m.
        /// </param>
        /// <param name="t">
        /// The t.
        /// </param>
        public void ExportMesh(MeshGeometry3D m, Matrix t)
        {
            if (m == null)
            {
                throw new ArgumentNullException("m");
            }

            if (t == null)
            {
                throw new ArgumentNullException("t");
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = Vector3.TransformCoordinate(v, t);
                    this.writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                this.writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    this.writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                this.writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    this.writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, vn.Y, vn.Z));
                }

                this.writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
            {
                bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                if (hasTextureIndex && hasNormalIndex)
                {
                    return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                }

                if (hasTextureIndex)
                {
                    return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                }

                if (hasNormalIndex)
                {
                    return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                }

                return vertexIndexMap[i0].ToString();
            };

            if (m.Indices != null)
            {
                for (int i = 0; i < m.Indices.Count; i += 3)
                {
                    int i0 = m.Indices[i];
                    int i1 = m.Indices[i + 1];
                    int i2 = m.Indices[i + 2];

                    this.writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                this.writer.WriteLine(string.Format("# {0} faces", m.Indices.Count / 3));
            }

            this.writer.WriteLine();
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="matName">
        /// The mat name.
        /// </param>
        /// <param name="material">
        /// The material.
        /// </param>
        private void ExportMaterial(string matName, MaterialCore material)
        {
            this.mwriter.WriteLine(string.Format("newmtl {0}", matName));

            if (material is PhongMaterialCore pm)
            {
                if (pm.DiffuseMap == null)
                {
                    this.mwriter.WriteLine(string.Format("Kd {0}", this.ToColorString(pm.DiffuseColor)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", pm.DiffuseColor.Alpha));
                    }
                    else
                    {
                        // Transparency
                        this.mwriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", pm.DiffuseColor.Alpha));
                    }
                }
                else
                {
                    var textureFilename = matName + ".png";
                    var texturePath = Path.Combine(this.directory, textureFilename);

                    // create .png bitmap file for the brush
                    RenderBrush(texturePath, pm.DiffuseMap.CompressedStream);
                    this.mwriter.WriteLine(string.Format("map_Ka {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (material is PhongMaterialCore pm)
            {
                this.mwriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(pm.DiffuseMap == null ? pm.SpecularColor : new Color4(0.2f, 0.2f, 0.2f, 1.0f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                this.mwriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", pm.SpecularShininess));
            }

            // roughness
            this.mwriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            this.mwriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            this.mwriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            this.mwriter.WriteLine(string.Format("illum {0}", illum));
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color4 color)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:F4} {1:F4} {2:F4}",
                color.Red,
                color.Green,
                color.Blue);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(359,47): error CS0128: A local variable or function named 'pm' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\ObjExporter.cs(363,54): error CS0165: Use of unassigned local variable 'pm'
######################################################################


######################################################################
Nr: 12 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using global::SharpDX;
#if COREWPF
using HelixToolkit.SharpDX.Core;
using HelixToolkit.SharpDX.Core.Utilities;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
#if !COREWPF
    using Core;
#endif

    namespace Utilities
    {
        public abstract class FromToStringTypeConverter : TypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }
        }

        public sealed class Vector2CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector2Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector2Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector3Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector3Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class IntCollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return IntCollection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is IntCollection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Color4Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Color4Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class ColorConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is string source)
                {
                    try
                    {
                        var c = System.Windows.Media.ColorConverter.ConvertFromString(source);
                        if (c != null)
                        {
                            var color = (System.Windows.Media.Color)c;
                            return new Color(color.R, color.G, color.B, color.A);
                        }
                    }
                    catch (FormatException) { }
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Color(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }
                else if(value is System.Windows.Media.Color)
                {
                    return (Color)((System.Windows.Media.Color)value).ToColor4();
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color)
                {
                    var val = (Color)value;
                    if (destinationType == typeof(string))
                    {
                   
                        var str = string.Format("{0},{1},{2},{3}", val.R, val.G, val.B, val.A);
                        return str;
                    }
                    else if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return System.Windows.Media.Color.FromArgb(val.A, val.R, val.G, val.B);
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Color)
                {
                    return ((System.Windows.Media.Color)value).ToColor4();
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var sepChar = TokenizerHelper.GetNumericListSeparator(CultureInfo.InvariantCulture);
                        if (source.Contains(sepChar.ToString()))
                        {
                            var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                            var result = new Color4(
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                            return result;
                        }

                        try
                        {
                            var obj = System.Windows.Media.ColorConverter.ConvertFromString(source);
                            if (obj is System.Windows.Media.Color color)
                            {
                                return color.ToColor4();
                            }
                        } catch (Exception) {}
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color4)
                {
                    var val = (Color4)value;
                    if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return val.ToColor();
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2},{3}", val.Red, val.Green, val.Blue, val.Alpha);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector2Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Vector) || sourceType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Vector) || destinationType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if (value is System.Windows.Vector)
                {
                    var source = (System.Windows.Vector)value;
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else if (value is System.Windows.Media.Media3D.Point3D)
                {
                    var source = (System.Windows.Media.Media3D.Point3D)value;
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector2(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector2)
                {
                    var val = (Vector2)value;
                    if (destinationType == typeof(System.Windows.Vector))
                    {
                        return new System.Windows.Vector(val.X, val.Y);
                    }
                    else if (destinationType == typeof(System.Windows.Point))
                    {
                        return new System.Windows.Point(val.X, val.Y);
                    }
                    else if (destinationType == typeof(string))
                    {
                        var str = string.Format("{0},{1}", val.X, val.Y);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if(sourceType == typeof(System.Windows.Media.Media3D.Vector3D) || sourceType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D) || destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Media3D.Vector3D)
                {
                    var source = (System.Windows.Media.Media3D.Vector3D)value;
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else if(value is System.Windows.Media.Media3D.Point3D)
                {
                    var source = (System.Windows.Media.Media3D.Point3D)value;
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector3(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }


                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector3)
                {
                    var val = (Vector3)value;
                    if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D))
                    {
                        return new System.Windows.Media.Media3D.Vector3D(val.X, val.Y, val.Z);
                    }
                    else if(destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                    {
                        return new System.Windows.Media.Media3D.Point3D(val.X, val.Y, val.Z);
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2}", val.X, val.Y, val.Z);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector4Converter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Vector4(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Vector4)
                {
                    var val = (Vector4)value;
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class QuaternionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Quaternion(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Quaternion val)
                {
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }

}

---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.Globalization;
using global::SharpDX;
#if COREWPF
using HelixToolkit.SharpDX.Core;
using HelixToolkit.SharpDX.Core.Utilities;
#endif
namespace HelixToolkit.Wpf.SharpDX
{
#if !COREWPF
    using Core;
#endif

    namespace Utilities
    {
        public abstract class FromToStringTypeConverter : TypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(string))
                {
                    return true;
                }

                return base.CanConvertTo(context, destinationType);
            }
        }

        public sealed class Vector2CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector2Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector2Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Vector3Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Vector3Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class IntCollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return IntCollection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is IntCollection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4CollectionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    return Color4Collection.Parse(source);
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType != null && value is Color4Collection instance)
                {
                    if (destinationType == typeof(string))
                    {
                        return instance.ConvertToString(null, culture);
                    }
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class ColorConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is string source)
                {
                    try
                    {
                        var c = System.Windows.Media.ColorConverter.ConvertFromString(source);
                        if (c != null)
                        {
                            var color = (System.Windows.Media.Color)c;
                            return new Color(color.R, color.G, color.B, color.A);
                        }
                    }
                    catch (FormatException) { }
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Color(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }
                else if(value is System.Windows.Media.Color color)
                {
                    return (Color)color.ToColor4();
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color val)
                {
                    if (destinationType == typeof(string))
                    {
                   
                        var str = string.Format("{0},{1},{2},{3}", val.R, val.G, val.B, val.A);
                        return str;
                    }
                    else if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return System.Windows.Media.Color.FromArgb(val.A, val.R, val.G, val.B);
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Color4Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Color))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Color color)
                {
                    return color.ToColor4();
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var sepChar = TokenizerHelper.GetNumericListSeparator(CultureInfo.InvariantCulture);
                        if (source.Contains(sepChar.ToString()))
                        {
                            var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                            var result = new Color4(
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                                Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                            return result;
                        }

                        try
                        {
                            var obj = System.Windows.Media.ColorConverter.ConvertFromString(source);
                            if (obj is System.Windows.Media.Color color)
                            {
                                return color.ToColor4();
                            }
                        } catch (Exception) {}
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Color4 val)
                {
                    if(destinationType == typeof(System.Windows.Media.Color))
                    {
                        return val.ToColor();
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2},{3}", val.Red, val.Green, val.Blue, val.Alpha);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector2Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if (sourceType == typeof(System.Windows.Vector) || sourceType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Vector) || destinationType == typeof(System.Windows.Point))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if (value is System.Windows.Vector source)
                {
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else if (value is System.Windows.Media.Media3D.Point3D source)
                {
                    return new Vector2((float)source.X, (float)source.Y);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector2(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }
                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector2 val)
                {
                    if (destinationType == typeof(System.Windows.Vector))
                    {
                        return new System.Windows.Vector(val.X, val.Y);
                    }
                    else if (destinationType == typeof(System.Windows.Point))
                    {
                        return new System.Windows.Point(val.X, val.Y);
                    }
                    else if (destinationType == typeof(string))
                    {
                        var str = string.Format("{0},{1}", val.X, val.Y);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector3Converter : FromToStringTypeConverter
        {
            public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
            {
                if(sourceType == typeof(System.Windows.Media.Media3D.Vector3D) || sourceType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertFrom(context, sourceType);
            }

            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
            {
                if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D) || destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }
                if(value is System.Windows.Media.Media3D.Vector3D source)
                {
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else if(value is System.Windows.Media.Media3D.Point3D source)
                {
                    return new Vector3((float)source.X, (float)source.Y, (float)source.Z);
                }
                else
                {
                    var source = value as string;

                    if (source != null)
                    {
                        var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                        var result = new Vector3(
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                            Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                        return result;
                    }
                }


                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if(value is Vector3 val)
                {
                    if (destinationType == typeof(System.Windows.Media.Media3D.Vector3D))
                    {
                        return new System.Windows.Media.Media3D.Vector3D(val.X, val.Y, val.Z);
                    }
                    else if(destinationType == typeof(System.Windows.Media.Media3D.Point3D))
                    {
                        return new System.Windows.Media.Media3D.Point3D(val.X, val.Y, val.Z);
                    }
                    else if (destinationType == typeof(string))
                    {                    
                        var str = string.Format("{0},{1},{2}", val.X, val.Y, val.Z);
                        return str;
                    }
                }
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class Vector4Converter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Vector4(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Vector4)
                {
                    var val = (Vector4)value;
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }

        public sealed class QuaternionConverter : FromToStringTypeConverter
        {
            public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
            {
                if (value == null)
                {
                    throw GetConvertFromException(value);
                }

                var source = value as string;

                if (source != null)
                {
                    var th = new TokenizerHelper(source, CultureInfo.InvariantCulture);
                    var result = new Quaternion(
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture),
                        Convert.ToSingle(th.NextTokenRequired(), CultureInfo.InvariantCulture));
                    return result;
                }

                return base.ConvertFrom(context, culture, value);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
            {
                if (destinationType == typeof(string) && value is Quaternion val)
                {
                    var str = string.Format("{0},{1},{2},{3}", val.X, val.Y, val.Z, val.W);
                    return str;
                }

                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }

}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(282,67): error CS0136: A local or parameter named 'color' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(339,72): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(345,25): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(411,71): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Source\HelixToolkit.Wpf.SharpDX.Shared\Utilities\TypeConverter.cs(417,25): error CS0136: A local or parameter named 'source' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.ObjectModel;
    using System.Collections.Specialized;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Base class for controls that use stereo cameras
    /// </summary>
    [ContentProperty("Content")]
    public class StereoControl : ContentControl
    {
        // todo: keyboard shortcut 'x' to change cross/parallel viewing
        /// <summary>
        /// Identifies the <see cref="Camera"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraProperty = DependencyProperty.Register(
            "Camera", typeof(PerspectiveCamera), typeof(StereoControl), new UIPropertyMetadata(null));

        /// <summary>
        /// Identifies the <see cref="CameraRotationMode"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraRotationModeProperty =
            DependencyProperty.Register(
                "CameraRotationMode",
                typeof(CameraRotationMode),
                typeof(StereoControl),
                new UIPropertyMetadata(CameraRotationMode.Turntable));

        /// <summary>
        /// Identifies the <see cref="CopyDirectionVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyDirectionVectorProperty =
            DependencyProperty.Register(
                "CopyDirectionVector",
                typeof(bool),
                typeof(StereoControl),
                new UIPropertyMetadata(true, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CopyUpVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyUpVectorProperty = DependencyProperty.Register(
            "CopyUpVector", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CrossViewing"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CrossViewingProperty = DependencyProperty.Register(
            "CrossViewing", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false));

        /// <summary>
        /// Identifies the <see cref="StereoBase"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty StereoBaseProperty = DependencyProperty.Register(
            "StereoBase", typeof(double), typeof(StereoControl), new UIPropertyMetadata(0.12, StereoViewChanged));

        /// <summary>
        /// Initializes static members of the <see cref="StereoControl"/> class.
        /// </summary>
        static StereoControl()
        {
            DefaultStyleKeyProperty.OverrideMetadata(
                typeof(StereoControl), new FrameworkPropertyMetadata(typeof(StereoControl)));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StereoControl"/> class.
        /// </summary>
        public StereoControl()
        {
            this.Camera = CameraHelper.CreateDefaultCamera();
            this.Camera.Changed += this.CameraChanged;
            this.Children = new ObservableCollection<Visual3D>();
        }

        /*        void StereoControl_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            if (e.Key == Key.X)
            {
                CrossViewing = !CrossViewing;
            }
        }
        */
        /// <summary>
        /// Gets or sets the camera.
        /// </summary>
        /// <value>The camera.</value>
        public PerspectiveCamera Camera
        {
            get
            {
                return (PerspectiveCamera)this.GetValue(CameraProperty);
            }

            set
            {
                this.SetValue(CameraProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the camera rotation mode.
        /// </summary>
        /// <value>The camera rotation mode.</value>
        public CameraRotationMode CameraRotationMode
        {
            get
            {
                return (CameraRotationMode)this.GetValue(CameraRotationModeProperty);
            }

            set
            {
                this.SetValue(CameraRotationModeProperty, value);
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <value>The children.</value>
        public ObservableCollection<Visual3D> Children { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether [copy direction vector].
        /// </summary>
        /// <value><c>true</c> if [copy direction vector]; otherwise, <c>false</c>.</value>
        public bool CopyDirectionVector
        {
            get
            {
                return (bool)this.GetValue(CopyDirectionVectorProperty);
            }

            set
            {
                this.SetValue(CopyDirectionVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether [copy up vector].
        /// </summary>
        /// <value><c>true</c> if [copy up vector]; otherwise, <c>false</c>.</value>
        public bool CopyUpVector
        {
            get
            {
                return (bool)this.GetValue(CopyUpVectorProperty);
            }

            set
            {
                this.SetValue(CopyUpVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the cameras are set up for cross viewing.
        /// </summary>
        /// <value><c>true</c> if [cross viewing]; otherwise, <c>false</c>.</value>
        public bool CrossViewing
        {
            get
            {
                return (bool)this.GetValue(CrossViewingProperty);
            }

            set
            {
                this.SetValue(CrossViewingProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the left camera.
        /// </summary>
        /// <value>The left camera.</value>
        public PerspectiveCamera LeftCamera { get; set; }

        /// <summary>
        /// Gets or sets the left viewport.
        /// </summary>
        /// <value>The left viewport.</value>
        public Viewport3D LeftViewport { get; set; }

        /// <summary>
        /// Gets or sets the right camera.
        /// </summary>
        /// <value>The right camera.</value>
        public PerspectiveCamera RightCamera { get; set; }

        /// <summary>
        /// Gets or sets the right viewport.
        /// </summary>
        /// <value>The right viewport.</value>
        public Viewport3D RightViewport { get; set; }

        /// <summary>
        /// Gets or sets the stereo base.
        /// </summary>
        /// <value>The stereo base.</value>
        public double StereoBase
        {
            get
            {
                return (double)this.GetValue(StereoBaseProperty);
            }

            set
            {
                this.SetValue(StereoBaseProperty, value);
            }
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right)
        {
            this.BindViewports(left, right, true, true);
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        /// <param name="createLights">
        /// if set to <c>true</c> [create lights].
        /// </param>
        /// <param name="createCamera">
        /// if set to <c>true</c> [create camera].
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right, bool createLights, bool createCamera)
        {
            this.LeftViewport = left;
            this.RightViewport = right;

            this.Children.CollectionChanged += this.ChildrenCollectionChanged;

            if (createLights)
            {
                this.Children.Add(new DefaultLights());
            }

            if (createCamera)
            {
                if (this.LeftViewport.Camera == null)
                {
                    this.LeftViewport.Camera = CameraHelper.CreateDefaultCamera();
                }
                else
                {
                    CameraHelper.Reset(this.LeftViewport.Camera as PerspectiveCamera);
                }

                if (this.RightViewport != null && this.RightViewport.Camera == null)
                {
                    this.RightViewport.Camera = new PerspectiveCamera();
                }
            }

            this.LeftCamera = this.LeftViewport.Camera as PerspectiveCamera;
            if (this.RightViewport != null)
            {
                this.RightCamera = this.RightViewport.Camera as PerspectiveCamera;
            }

            this.UpdateCameras();
        }

        /// <summary>
        /// Clears the children collection.
        /// </summary>
        public void Clear()
        {
            this.Children.Clear();
            this.SynchronizeStereoModel();
        }

        /// <summary>
        /// Exports the views to kerkythea.
        /// </summary>
        /// <param name="leftFileName">
        /// Name of the left file.
        /// </param>
        /// <param name="rightFileName">
        /// Name of the right file.
        /// </param>
        public void ExportKerkythea(string leftFileName, string rightFileName)
        {
            var scb = this.Background as SolidColorBrush;

            var leftExporter = new KerkytheaExporter();
            if (scb != null)
            {
                leftExporter.BackgroundColor = scb.Color;
            }

            leftExporter.Reflections = true;
            leftExporter.Shadows = true;
            leftExporter.SoftShadows = true;
            leftExporter.Width = (int)this.LeftViewport.ActualWidth;
            leftExporter.Height = (int)this.LeftViewport.ActualHeight;
            using (var stream = File.Create(leftFileName))
            {
                leftExporter.Export(this.LeftViewport, stream);
            }

            var rightExporter = new KerkytheaExporter();
            if (scb != null)
            {
                rightExporter.BackgroundColor = scb.Color;
            }

            rightExporter.Reflections = true;
            rightExporter.Shadows = true;
            rightExporter.SoftShadows = true;
            rightExporter.Width = (int)this.RightViewport.ActualWidth;
            rightExporter.Height = (int)this.RightViewport.ActualHeight;
            using (var stream = File.Create(rightFileName))
            {
                rightExporter.Export(this.RightViewport, stream);
            }
        }

        /// <summary>
        /// Synchronizes the stereo model.
        /// </summary>
        public void SynchronizeStereoModel()
        {
            this.LeftViewport.Children.Clear();
            if (this.RightViewport != null)
            {
                this.RightViewport.Children.Clear();
            }

            foreach (var v in this.Children)
            {
                this.LeftViewport.Children.Add(v);
                if (this.RightViewport != null)
                {
                    Visual3D clone = StereoHelper.CreateClone(v);
                    if (clone != null)
                    {
                        this.RightViewport.Children.Add(clone);
                    }
                }
            }
        }

        /// <summary>
        /// Updates the cameras.
        /// </summary>
        public void UpdateCameras()
        {
            StereoHelper.UpdateStereoCameras(
                this.Camera,
                this.LeftCamera,
                this.RightCamera,
                this.StereoBase,
                this.CrossViewing,
                this.CopyUpVector,
                this.CopyDirectionVector);
        }

        /// <summary>
        /// The stereo view changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected static void StereoViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var v = (StereoControl)d;
            v.UpdateCameras();
        }

        /// <summary>
        /// Handle the camera changed event.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void CameraChanged(object sender, EventArgs e)
        {
            this.UpdateCameras();
        }

        /// <summary>
        /// Handle changes in the children collection.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void ChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // todo: update left and right collections here
        }

    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.ObjectModel;
    using System.Collections.Specialized;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Markup;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Base class for controls that use stereo cameras
    /// </summary>
    [ContentProperty("Content")]
    public class StereoControl : ContentControl
    {
        // todo: keyboard shortcut 'x' to change cross/parallel viewing
        /// <summary>
        /// Identifies the <see cref="Camera"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraProperty = DependencyProperty.Register(
            "Camera", typeof(PerspectiveCamera), typeof(StereoControl), new UIPropertyMetadata(null));

        /// <summary>
        /// Identifies the <see cref="CameraRotationMode"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CameraRotationModeProperty =
            DependencyProperty.Register(
                "CameraRotationMode",
                typeof(CameraRotationMode),
                typeof(StereoControl),
                new UIPropertyMetadata(CameraRotationMode.Turntable));

        /// <summary>
        /// Identifies the <see cref="CopyDirectionVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyDirectionVectorProperty =
            DependencyProperty.Register(
                "CopyDirectionVector",
                typeof(bool),
                typeof(StereoControl),
                new UIPropertyMetadata(true, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CopyUpVector"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CopyUpVectorProperty = DependencyProperty.Register(
            "CopyUpVector", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false, StereoViewChanged));

        /// <summary>
        /// Identifies the <see cref="CrossViewing"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty CrossViewingProperty = DependencyProperty.Register(
            "CrossViewing", typeof(bool), typeof(StereoControl), new UIPropertyMetadata(false));

        /// <summary>
        /// Identifies the <see cref="StereoBase"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty StereoBaseProperty = DependencyProperty.Register(
            "StereoBase", typeof(double), typeof(StereoControl), new UIPropertyMetadata(0.12, StereoViewChanged));

        /// <summary>
        /// Initializes static members of the <see cref="StereoControl"/> class.
        /// </summary>
        static StereoControl()
        {
            DefaultStyleKeyProperty.OverrideMetadata(
                typeof(StereoControl), new FrameworkPropertyMetadata(typeof(StereoControl)));
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StereoControl"/> class.
        /// </summary>
        public StereoControl()
        {
            this.Camera = CameraHelper.CreateDefaultCamera();
            this.Camera.Changed += this.CameraChanged;
            this.Children = new ObservableCollection<Visual3D>();
        }

        /*        void StereoControl_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e)
        {
            if (e.Key == Key.X)
            {
                CrossViewing = !CrossViewing;
            }
        }
        */
        /// <summary>
        /// Gets or sets the camera.
        /// </summary>
        /// <value>The camera.</value>
        public PerspectiveCamera Camera
        {
            get
            {
                return (PerspectiveCamera)this.GetValue(CameraProperty);
            }

            set
            {
                this.SetValue(CameraProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the camera rotation mode.
        /// </summary>
        /// <value>The camera rotation mode.</value>
        public CameraRotationMode CameraRotationMode
        {
            get
            {
                return (CameraRotationMode)this.GetValue(CameraRotationModeProperty);
            }

            set
            {
                this.SetValue(CameraRotationModeProperty, value);
            }
        }

        /// <summary>
        /// Gets the children.
        /// </summary>
        /// <value>The children.</value>
        public ObservableCollection<Visual3D> Children { get; private set; }

        /// <summary>
        /// Gets or sets a value indicating whether [copy direction vector].
        /// </summary>
        /// <value><c>true</c> if [copy direction vector]; otherwise, <c>false</c>.</value>
        public bool CopyDirectionVector
        {
            get
            {
                return (bool)this.GetValue(CopyDirectionVectorProperty);
            }

            set
            {
                this.SetValue(CopyDirectionVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether [copy up vector].
        /// </summary>
        /// <value><c>true</c> if [copy up vector]; otherwise, <c>false</c>.</value>
        public bool CopyUpVector
        {
            get
            {
                return (bool)this.GetValue(CopyUpVectorProperty);
            }

            set
            {
                this.SetValue(CopyUpVectorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether the cameras are set up for cross viewing.
        /// </summary>
        /// <value><c>true</c> if [cross viewing]; otherwise, <c>false</c>.</value>
        public bool CrossViewing
        {
            get
            {
                return (bool)this.GetValue(CrossViewingProperty);
            }

            set
            {
                this.SetValue(CrossViewingProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the left camera.
        /// </summary>
        /// <value>The left camera.</value>
        public PerspectiveCamera LeftCamera { get; set; }

        /// <summary>
        /// Gets or sets the left viewport.
        /// </summary>
        /// <value>The left viewport.</value>
        public Viewport3D LeftViewport { get; set; }

        /// <summary>
        /// Gets or sets the right camera.
        /// </summary>
        /// <value>The right camera.</value>
        public PerspectiveCamera RightCamera { get; set; }

        /// <summary>
        /// Gets or sets the right viewport.
        /// </summary>
        /// <value>The right viewport.</value>
        public Viewport3D RightViewport { get; set; }

        /// <summary>
        /// Gets or sets the stereo base.
        /// </summary>
        /// <value>The stereo base.</value>
        public double StereoBase
        {
            get
            {
                return (double)this.GetValue(StereoBaseProperty);
            }

            set
            {
                this.SetValue(StereoBaseProperty, value);
            }
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right)
        {
            this.BindViewports(left, right, true, true);
        }

        /// <summary>
        /// Binds the viewports.
        /// </summary>
        /// <param name="left">
        /// The left.
        /// </param>
        /// <param name="right">
        /// The right.
        /// </param>
        /// <param name="createLights">
        /// if set to <c>true</c> [create lights].
        /// </param>
        /// <param name="createCamera">
        /// if set to <c>true</c> [create camera].
        /// </param>
        public void BindViewports(Viewport3D left, Viewport3D right, bool createLights, bool createCamera)
        {
            this.LeftViewport = left;
            this.RightViewport = right;

            this.Children.CollectionChanged += this.ChildrenCollectionChanged;

            if (createLights)
            {
                this.Children.Add(new DefaultLights());
            }

            if (createCamera)
            {
                if (this.LeftViewport.Camera == null)
                {
                    this.LeftViewport.Camera = CameraHelper.CreateDefaultCamera();
                }
                else
                {
                    CameraHelper.Reset(this.LeftViewport.Camera as PerspectiveCamera);
                }

                if (this.RightViewport != null && this.RightViewport.Camera == null)
                {
                    this.RightViewport.Camera = new PerspectiveCamera();
                }
            }

            this.LeftCamera = this.LeftViewport.Camera as PerspectiveCamera;
            if (this.RightViewport != null)
            {
                this.RightCamera = this.RightViewport.Camera as PerspectiveCamera;
            }

            this.UpdateCameras();
        }

        /// <summary>
        /// Clears the children collection.
        /// </summary>
        public void Clear()
        {
            this.Children.Clear();
            this.SynchronizeStereoModel();
        }

        /// <summary>
        /// Exports the views to kerkythea.
        /// </summary>
        /// <param name="leftFileName">
        /// Name of the left file.
        /// </param>
        /// <param name="rightFileName">
        /// Name of the right file.
        /// </param>
        public void ExportKerkythea(string leftFileName, string rightFileName)
        {

            var leftExporter = new KerkytheaExporter();

            if (this.Background is SolidColorBrush scb)
            {
                leftExporter.BackgroundColor = scb.Color;
            }

            leftExporter.Reflections = true;
            leftExporter.Shadows = true;
            leftExporter.SoftShadows = true;
            leftExporter.Width = (int)this.LeftViewport.ActualWidth;
            leftExporter.Height = (int)this.LeftViewport.ActualHeight;
            using (var stream = File.Create(leftFileName))
            {
                leftExporter.Export(this.LeftViewport, stream);
            }

            var rightExporter = new KerkytheaExporter();

            if (this.Background is SolidColorBrush scb)
            {
                rightExporter.BackgroundColor = scb.Color;
            }

            rightExporter.Reflections = true;
            rightExporter.Shadows = true;
            rightExporter.SoftShadows = true;
            rightExporter.Width = (int)this.RightViewport.ActualWidth;
            rightExporter.Height = (int)this.RightViewport.ActualHeight;
            using (var stream = File.Create(rightFileName))
            {
                rightExporter.Export(this.RightViewport, stream);
            }
        }

        /// <summary>
        /// Synchronizes the stereo model.
        /// </summary>
        public void SynchronizeStereoModel()
        {
            this.LeftViewport.Children.Clear();
            if (this.RightViewport != null)
            {
                this.RightViewport.Children.Clear();
            }

            foreach (var v in this.Children)
            {
                this.LeftViewport.Children.Add(v);
                if (this.RightViewport != null)
                {
                    Visual3D clone = StereoHelper.CreateClone(v);
                    if (clone != null)
                    {
                        this.RightViewport.Children.Add(clone);
                    }
                }
            }
        }

        /// <summary>
        /// Updates the cameras.
        /// </summary>
        public void UpdateCameras()
        {
            StereoHelper.UpdateStereoCameras(
                this.Camera,
                this.LeftCamera,
                this.RightCamera,
                this.StereoBase,
                this.CrossViewing,
                this.CopyUpVector,
                this.CopyDirectionVector);
        }

        /// <summary>
        /// The stereo view changed.
        /// </summary>
        /// <param name="d">
        /// The d.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected static void StereoViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var v = (StereoControl)d;
            v.UpdateCameras();
        }

        /// <summary>
        /// Handle the camera changed event.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void CameraChanged(object sender, EventArgs e)
        {
            this.UpdateCameras();
        }

        /// <summary>
        /// Handle changes in the children collection.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        private void ChildrenCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // todo: update left and right collections here
        }

    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs(339,52): error CS0128: A local variable or function named 'scb' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Controls\Stereo\StereoControl.cs(341,49): error CS0165: Use of unassigned local variable 'scb'
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;
    using System.Xml;

    /// <summary>
    /// Exports the 3D visual tree to a <a href="http://www.kerkythea.net/joomla">Kerkythea</a> input file.
    /// </summary>
    public class KerkytheaExporter : Exporter<KerkytheaExporter.KerkytheaWriter>
    {
        /// <summary>
        /// Dictionary of registered materials.
        /// </summary>
        private readonly Dictionary<Material, XmlDocument> registeredMaterials = new Dictionary<Material, XmlDocument>();

        /// <summary>
        /// Initializes a new instance of the <see cref="KerkytheaExporter"/> class.
        /// </summary>
        public KerkytheaExporter()
        {
            this.Name = "My Scene";
            this.BackgroundColor = Colors.Black;
            this.ReflectionColor = Colors.Gray;
            this.Reflections = true;
            this.Shadows = true;
            this.SoftShadows = true;
            this.LightMultiplier = 3.0;
            this.Threads = 2;

            this.ShadowColor = Color.FromArgb(255, 100, 100, 100);
            this.RenderSetting = RenderSettings.RayTracer;
            this.Aperture = "Pinhole";
            this.FocusDistance = 1.0;
            this.LensSamples = 3;

            this.Width = 500;
            this.Height = 500;

            this.TextureWidth = 1024;
            this.TextureHeight = 1024;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Render settings.
        /// </summary>
        public enum RenderSettings
        {
            /// <summary>
            /// Use RayTracer.
            /// </summary>
            RayTracer,

            /// <summary>
            /// Use PhotonMap.
            /// </summary>
            PhotonMap,

            /// <summary>
            /// Use MetropolisLightTransport.
            /// </summary>
            MetropolisLightTransport
        }

        /// <summary>
        /// Gets or sets the aperture.
        /// </summary>
        /// <value>The aperture.</value>
        public string Aperture { get; set; }

        /// <summary>
        /// Gets or sets the color of the background.
        /// </summary>
        /// <value>The color of the background.</value>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Gets or sets the texture file creator.
        /// </summary>
        /// <value>The file creator.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets the length of the focal.
        /// </summary>
        /// <value>The length of the focal.</value>
        public double FocalLength { get; set; }

        /// <summary>
        /// Gets or sets the focus distance.
        /// </summary>
        /// <value>The focus distance.</value>
        public double FocusDistance { get; set; }

        /// <summary>
        /// Gets or sets the height.
        /// </summary>
        /// <value>The height.</value>
        public int Height { get; set; }

        /// <summary>
        /// Gets or sets the lens samples.
        /// </summary>
        /// <value>The lens samples.</value>
        public int LensSamples { get; set; }

        /// <summary>
        /// Gets or sets the light multiplier.
        /// </summary>
        /// <value>The light multiplier.</value>
        public double LightMultiplier { get; set; }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the color of the reflection.
        /// </summary>
        /// <value>The color of the reflection.</value>
        public Color ReflectionColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is reflections.
        /// </summary>
        /// <value><c>true</c> if reflections; otherwise, <c>false</c>.</value>
        public bool Reflections { get; set; }

        /// <summary>
        /// Gets or sets the render setting.
        /// </summary>
        /// <value>The render setting.</value>
        public RenderSettings RenderSetting { get; set; }

        /// <summary>
        /// Gets or sets the color of the shadow.
        /// </summary>
        /// <value>The color of the shadow.</value>
        public Color ShadowColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is shadows.
        /// </summary>
        /// <value><c>true</c> if shadows; otherwise, <c>false</c>.</value>
        public bool Shadows { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether [soft shadows].
        /// </summary>
        /// <value><c>true</c> if [soft shadows]; otherwise, <c>false</c>.</value>
        public bool SoftShadows { get; set; }

        /// <summary>
        /// Gets or sets the height of the texture.
        /// </summary>
        /// <value>The height of the texture.</value>
        public int TextureHeight { get; set; }

        /// <summary>
        /// Gets or sets the texture path.
        /// </summary>
        /// <value>The texture path.</value>
        public string TexturePath { get; set; }

        /// <summary>
        /// Gets or sets the width of the texture.
        /// </summary>
        /// <value>The width of the texture.</value>
        public int TextureWidth { get; set; }

        /// <summary>
        /// Gets or sets the threads.
        /// </summary>
        /// <value>The threads.</value>
        public int Threads { get; set; }

        /// <summary>
        /// Gets or sets the width.
        /// </summary>
        /// <value>The width.</value>
        public int Width { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        public void ExportMesh(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartObject("Triangular Mesh", "Triangular Mesh", string.Empty, "Surface");

            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Vertex List");
                writer.WriteAttributeString("Type", "Point3D List");
                writer.WriteAttributeString("Value", m.Positions.Count.ToString());
                foreach (var p in m.Positions)
                {
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xyz", ToKerkytheaString(p));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            int triangles = m.TriangleIndices.Count / 3;

            // NORMALS
            // todo: write normal list per vertex instead of per triangle index
            if (m.Normals != null && m.Normals.Count > 0)
            {
                writer.WriteStartElement("Parameter");
                {
                    writer.WriteAttributeString("Name", "Normal List");
                    writer.WriteAttributeString("Type", "Point3D List");
                    writer.WriteAttributeString("Value", m.TriangleIndices.Count.ToString());
                    foreach (int index in m.TriangleIndices)
                    {
                        if (index >= m.Normals.Count)
                        {
                            continue;
                        }

                        var n = m.Normals[index];
                        writer.WriteStartElement("P");
                        writer.WriteAttributeString("xyz", ToKerkytheaString(n));
                        writer.WriteEndElement();
                    }
                }

                writer.WriteFullEndElement();
            }

            // TRIANGLE INDICES
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Index List");
                writer.WriteAttributeString("Type", "Triangle Index List");
                writer.WriteAttributeString("Value", triangles.ToString());
                for (int a = 0; a < triangles; a++)
                {
                    int a3 = a * 3;
                    int i = m.TriangleIndices[a3];
                    int j = m.TriangleIndices[a3 + 1];
                    int k = m.TriangleIndices[a3 + 2];
                    writer.WriteStartElement("F");
                    writer.WriteAttributeString("ijk", string.Format("{0} {1} {2}", i, j, k));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            writer.WriteParameter("Smooth", true);
            writer.WriteParameter("AA Tolerance", 15.0);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Registers a material.
        /// </summary>
        /// <param name="m">The material to register.</param>
        /// <param name="stream">The material stream.</param>
        public void RegisterMaterial(Material m, Stream stream)
        {
            var doc = new XmlDocument();
            doc.Load(stream);
            this.registeredMaterials.Add(m, doc);
        }

        /// <summary>
        /// Writes the Metropolis Light Transport properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the MLP ray tracer.</param>
        public void WriteMetropolisLightTransport(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Metropolis Light Transport", name, "Ray Tracer");
            writer.WriteParameter("Max Ray Tracing Depth", 100);
            writer.WriteParameter("Max Iterations", 10000);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Seed Paths", 50000);
            writer.WriteParameter("Large Step Probability", 0.2);
            writer.WriteParameter("Max Mutation Distance", 0.02);
            writer.WriteParameter("Live Probability", 0.7);
            writer.WriteParameter("Max Consecutive Rejections", 200);
            writer.WriteParameter("Bidirectional", true);
            writer.WriteParameter("Super Sampling", "3x3");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("Random Seed", "Automatic");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the standard ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the ray tracer.</param>
        public void WriteStandardRayTracer(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Standard Ray Tracer", name, "Ray Tracer");
            writer.WriteParameter("Rasterization", "Auto");

            // WriteParameter("Antialiasing", "Extra Pass 3x3");
            writer.WriteParameter("Antialiasing", "Production AA");
            writer.WriteParameter("Antialiasing Filter", "Mitchell-Netravali 0.5 0.8");
            writer.WriteParameter("Antialiasing Threshold", 0.3);
            writer.WriteParameter("Texture Filtering", true);
            writer.WriteParameter("Ambient Lighting", true);
            writer.WriteParameter("Direct Lighting", true);
            writer.WriteParameter("Sky Lighting", true);
            writer.WriteParameter("Brightness Threshold", 0.002);
            writer.WriteParameter("Max Ray Tracing Depth", 5);
            writer.WriteParameter("Max Scatter Bounces", 5);
            writer.WriteParameter("Max Dirac Bounces", 5);
            writer.WriteParameter("Irradiance Precomputation", 4);
            writer.WriteParameter("Irradiance Scale", Colors.White);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Max Iterations", 5);
            writer.WriteParameter("Super Sampling", "None");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("./Sampling Criteria/Diffuse Samples", 1024);
            writer.WriteParameter("./Sampling Criteria/Specular Samples", 32);
            writer.WriteParameter("./Sampling Criteria/Dispersion Samples", true);
            writer.WriteParameter("./Sampling Criteria/Trace Diffusers", false);
            writer.WriteParameter("./Sampling Criteria/Trace Translucencies", false);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Trace Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Random Generator", "Pure");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the threaded ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="threads">The number of threads.</param>
        public void WriteThreadedRaytracer(KerkytheaWriter writer, int threads)
        {
            writer.WriteStartObject("./Ray Tracers/Threaded Ray Tracer", "Threaded Ray Tracer", "Threaded Ray Tracer", "Ray Tracer");
            for (int i = 0; i < threads; i++)
            {
                writer.WriteParameter("Thread #" + i, "#" + i);
            }

            writer.WriteParameter("Network Mode", "None");
            writer.WriteParameter("Listening Port", 6200);
            writer.WriteParameter("Host", "127.0.0.1");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Creates the writer for the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>The writer.</returns>
        protected override KerkytheaWriter Create(Stream stream)
        {
            return new KerkytheaWriter(stream);
        }

        /// <summary>
        /// Exports the camera.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="c">The camera.</param>
        /// <exception cref="System.InvalidOperationException">Only perspective cameras are supported.</exception>
        protected override void ExportCamera(KerkytheaWriter writer, Camera c)
        {
            var pc = c as PerspectiveCamera;
            if (pc == null)
            {
                throw new InvalidOperationException("Only perspective cameras are supported.");
            }

            const string name = "Camera #1";
            writer.WriteStartObject("./Cameras/" + name, "Pinhole Camera", name, "Camera");

            // FOV = 2 arctan (x / (2 f)), x is diagonal, f is focal length
            // f = x / 2 / Tan(FOV/2)
            // http://en.wikipedia.org/wiki/Angle_of_view
            // http://kmp.bdimitrov.de/technology/fov.html

            // PerspectiveCamera.FieldOfView: Horizontal field of view
            // Must multiply by ratio of Viewport Width/Height
            double ratio = this.Width / (double)this.Height;
            const double x = 40;
            double f = 0.5 * ratio * x / Math.Tan(0.5 * pc.FieldOfView / 180.0 * Math.PI);

            writer.WriteParameter("Focal Length (mm)", f);
            writer.WriteParameter("Film Height (mm)", x);
            writer.WriteParameter("Resolution", string.Format(CultureInfo.InvariantCulture, "{0}x{1}", this.Width, this.Height));

            var t = CreateTransform(pc.Position, pc.LookDirection, pc.UpDirection);
            writer.WriteTransform("Frame", t);

            writer.WriteParameter("Focus Distance", this.FocusDistance);
            writer.WriteParameter("f-number", this.Aperture);
            writer.WriteParameter("Lens Samples", this.LensSamples);
            writer.WriteParameter("Blades", 6);
            writer.WriteParameter("Diaphragm", "Circular");
            writer.WriteParameter("Projection", "Planar");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the document header.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void ExportHeader(KerkytheaWriter writer)
        {
            writer.WriteStartDocument();

            writer.WriteStartElement("Root");
            writer.WriteAttributeString("Label", "Default Kernel");
            writer.WriteAttributeString("Name", string.Empty);
            writer.WriteAttributeString("Type", "Kernel");

            writer.WriteStartObject("./Modellers/XML Modeller", "XML Modeller", "XML Modeller", "Modeller");
            writer.WriteEndObject();

            writer.WriteStartObject("./Image Handlers/Free Image Support", "Free Image Support", "Free Image Support", "Image Handler");
            writer.WriteParameter("Tone Mapping", "External");
            writer.WriteParameter("Jpeg Quality", "Higher");
            writer.WriteEndObject();

            writer.WriteStartObject("./Direct Light Estimators/Refraction Enhanced", "Refraction Enhanced", "Refraction Enhanced", "Direct Light Estimator");
            writer.WriteParameter("Enabled", "Boolean", "1");
            writer.WriteParameter("PseudoCaustics", "Boolean", "0");
            writer.WriteParameter("PseudoTranslucencies", "Boolean", "0");
            writer.WriteParameter("Area Light Evaluation", "Boolean", "1");
            writer.WriteParameter("Optimized Area Lights", "Boolean", "1");
            writer.WriteParameter("Accurate Soft Shadows", "Boolean", "0");
            writer.WriteParameter("Antialiasing", "String", "High");
            writer.WriteParameter("./Evaluation/Diffuse", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Specular", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Translucent", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Transmitted", "Boolean", "1");
            writer.WriteEndObject();

            // add ray tracer module.
            for (int i = 0; i < this.Threads; i++)
            {
                this.WriteStandardRayTracer(writer, "#" + i);
            }

            this.WriteThreadedRaytracer(writer, this.Threads);

            // add spatial subdivision module.
            writer.WriteStartObject("./Environments/Octree Environment", "Octree Environment", "Octree Environment", "Environment");
            writer.WriteParameter("Max Objects per Cell", 20);
            writer.WriteParameter("Instancing Switch", 1000000);
            writer.WriteParameter("Caching Switch", 6000000);
            writer.WriteEndObject();

            // add basic post filtering / tone mapping.
            writer.WriteStartObject("./Filters/Simple Tone Mapping", "Simple Tone Mapping", string.Empty, "Filter");
            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Method", "Simple");
            writer.WriteParameter("Exposure", 1.0);
            writer.WriteParameter("Gamma", 1.0);
            writer.WriteParameter("Dark Multiplier", 1.0);
            writer.WriteParameter("Bright Multiplier", 1.0);
            writer.WriteParameter("Reverse Correction", true);
            writer.WriteParameter("Reverse Gamma", 2.2);
            writer.WriteEndObject();

            // start of scene description.
            writer.WriteStartObject("./Scenes/" + this.Name, "Default Scene", this.Name, "Scene");
        }

        /// <summary>
        /// Exports the light.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="l">The light.</param>
        /// <param name="t">The transform.</param>
        protected override void ExportLight(KerkytheaWriter writer, Light l, Transform3D t)
        {
            if (l is AmbientLight)
            {
                return;
            }

            string name = this.GetUniqueName(writer, l, l.GetType().Name);

            var d = l as DirectionalLight;
            var s = l as SpotLight;
            var p = l as PointLight;

            writer.WriteStartObject("./Lights/" + name, "Default Light", name, "Light");
            {
                string stype = "Projector Light";
                if (s != null)
                {
                    stype = "Spot Light";
                }

                if (p != null)
                {
                    stype = "Omni Light";
                }

                writer.WriteStartObject(stype, stype, string.Empty, "Emittance");

                // emitter Radiance
                writer.WriteStartObject("./Radiance/Constant Texture", "Constant Texture", string.Empty, "Texture");
                var c = Colors.White;
                writer.WriteParameter("Color", c);
                writer.WriteEndObject();

                // var v = new Vector3D(l.Color.R, l.Color.G, l.Color.B);
                // double lum = v.Length;
                writer.WriteParameter("Attenuation", "None");

                // SpotLight (Spot Light)
                if (s != null)
                {
                    // todo : export the specular parameters
                    // s.ConstantAttenuation
                    // s.LinearAttenuation
                    // s.QuadraticAttenuation
                    writer.WriteParameter("Fall Off", s.OuterConeAngle);
                    writer.WriteParameter("Hot Spot", s.InnerConeAngle);
                }

                // DirectionalLight (Projector Light)
                if (d != null)
                {
                    writer.WriteParameter("Width", 2.0);
                    writer.WriteParameter("Height", 2.0);
                }

                // PointLight (Omni light)
                if (p != null)
                {
                    // todo: export pointlight parameters
                    // name.ConstantAttenuation
                    // name.LinearAttenuation
                    // name.QuadraticAttenuation
                    // name.Range // distance beyond which the light has no effect
                }

                writer.WriteParameter("Focal Length", 1.0);

                writer.WriteEndObject(); // stype

                writer.WriteParameter("Enabled", true);
                writer.WriteParameter("Shadow", this.Shadows);
                writer.WriteParameter("Soft Shadow", this.SoftShadows);

                writer.WriteParameter("Negative Light", false);
                writer.WriteParameter("Global Photons", true);
                writer.WriteParameter("Caustic Photons", true);
                writer.WriteParameter("Multiplier", this.LightMultiplier);

                Matrix3D transform;
                var upVector = new Vector3D(0, 0, 1);
                if (s != null)
                {
                    transform = CreateTransform(s.Position, s.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (d != null)
                {
                    var origin = new Point3D(-1000 * d.Direction.X, -1000 * d.Direction.Y, -1000 * d.Direction.Z);
                    transform = CreateTransform(origin, d.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (p != null)
                {
                    var direction = new Vector3D(-p.Position.X, -p.Position.Y, -p.Position.Z);
                    transform = CreateTransform(p.Position, direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                writer.WriteParameter("Focus Distance", 4.0);
                writer.WriteParameter("Radius", 0.2);
                writer.WriteParameter("Shadow Color", this.ShadowColor);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="g">The model geometry.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(KerkytheaWriter writer, GeometryModel3D g, Transform3D transform)
        {
            var mesh = g.Geometry as MeshGeometry3D;
            if (mesh == null)
            {
                return;
            }

            string name = this.GetUniqueName(writer, g, g.GetType().Name);
            writer.WriteStartObject("./Models/" + name, "Default Model", name, "Model");

            this.ExportMesh(writer, mesh);

            if (g.Material != null)
            {
                this.ExportMaterial(writer, g.Material);
            }

            var tg = new Transform3DGroup();
            tg.Children.Add(g.Transform);
            tg.Children.Add(transform);

            if (mesh.TextureCoordinates != null)
            {
                this.ExportMapChannel(writer, mesh);
            }

            writer.WriteTransform("Frame", tg.Value);

            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Visible", true);
            writer.WriteParameter("Shadow Caster", true);
            writer.WriteParameter("Shadow Receiver", true);
            writer.WriteParameter("Caustics Transmitter", true);
            writer.WriteParameter("Caustics Receiver", true);
            writer.WriteParameter("Exit Blocker", false);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="v">The viewport to export.</param>
        protected override void ExportViewport(KerkytheaWriter writer, Viewport3D v)
        {
            var ambient = Visual3DHelper.Find<AmbientLight>(v);

            // default global settings
            writer.WriteStartObject("Default Global Settings", "Default Global Settings", string.Empty, "Global Settings");
            if (ambient != null)
            {
                writer.WriteParameter("Ambient Light", ambient.Color);
            }

            writer.WriteParameter("Background Color", this.BackgroundColor);
            writer.WriteParameter("Compute Volume Transfer", false);
            writer.WriteParameter("Transfer Recursion Depth", 1);
            writer.WriteParameter("Background Type", "Sky Color");
            writer.WriteParameter("Sky Intensity", 1.0);
            writer.WriteParameter("Sky Frame", "Transform", "1 0 0 0 0 1 0 0 0 0 1 0 ");
            writer.WriteParameter("Sun Direction", "0 0 1");
            writer.WriteParameter("Sky Turbidity", 2.0);
            writer.WriteParameter("Sky Luminance Gamma", 1.2);
            writer.WriteParameter("Sky Chromaticity Gamma", 1.8);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Index of Refraction", 1.0);
            writer.WriteParameter("Scatter Density", 0.1);
            writer.WriteParameter("./Location/Latitude", 0.0);
            writer.WriteParameter("./Location/Longitude", 0.0);
            writer.WriteParameter("./Location/Timezone", 0);
            writer.WriteParameter("./Location/Date", "0/0/2007");
            writer.WriteParameter("./Location/Time", "12:0:0");
            writer.WriteParameter("./Background Image/Filename", "[No Bitmap]");
            writer.WriteParameter("./Background Image/Projection", "UV");
            writer.WriteParameter("./Background Image/Offset X", 0.0);
            writer.WriteParameter("./Background Image/Offset Y", 0.0);
            writer.WriteParameter("./Background Image/Scale X", 1.0);
            writer.WriteParameter("./Background Image/Scale Y", 1.0);
            writer.WriteParameter("./Background Image/Rotation", 0.0);
            writer.WriteParameter("./Background Image/Smooth", true);
            writer.WriteParameter("./Background Image/Inverted", false);
            writer.WriteParameter("./Background Image/Alpha Channel", false);
            writer.WriteEndObject();

            // Visual3DHelper.Traverse<Light>(v.Children, ExportLight);
            // Visual3DHelper.Traverse<GeometryModel3D>(v.Children, ExportGeometryModel3D);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(KerkytheaWriter writer)
        {
            // end of scene description.
            writer.WriteFullEndElement();

            // it is necessary to describe the primary/active modules as there might exist more than one!
            writer.WriteParameter("Mip Mapping", true);
            writer.WriteParameter("./Interfaces/Active", "Null Interface");
            writer.WriteParameter("./Modellers/Active", "XML Modeller");
            writer.WriteParameter("./Image Handlers/Active", "Free Image Support");

            writer.WriteParameter("./Ray Tracers/Active", "Threaded Ray Tracer");
            writer.WriteParameter("./Irradiance Estimators/Active", "Null Irradiance Estimator");
            writer.WriteParameter("./Direct Light Estimators/Active", "Refraction Enhanced");
            writer.WriteParameter("./Environments/Active", "Octree Environment");
            writer.WriteParameter("./Filters/Active", "Simple Tone Mapping");
            writer.WriteParameter("./Scenes/Active", this.Name);
            writer.WriteParameter("./Libraries/Active", "Material Librarian");

            // end of root element
            writer.WriteFullEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        /// <summary>
        /// Creates a transform from the original coordinate system to the system defined by translation origin
        /// </summary>
        /// <param name="origin">The origin.</param>
        /// <param name="direction">The direction vector.</param>
        /// <param name="up">The up vector.</param>
        /// <returns>A transformation matrix.</returns>
        private static Matrix3D CreateTransform(Point3D origin, Vector3D direction, Vector3D up)
        {
            var z = direction;
            var x = Vector3D.CrossProduct(direction, up);
            var y = up;

            x.Normalize();
            y.Normalize();
            z.Normalize();

            var m = new Matrix3D(x.X, y.X, z.X, 0, x.Y, y.Y, z.Y, 0, x.Z, y.Z, z.Z, 0, origin.X, origin.Y, origin.Z, 1);

            return m;
        }

        /// <summary>
        /// Converts a <see cref="Point"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="p">
        /// The point.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point p)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0} {1}", p.X, p.Y);
        }

        /// <summary>
        /// Converts a <see cref="Point3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="point">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point3D point)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(point.X, 1),
                ValueOrDefault(point.Y, 0),
                ValueOrDefault(point.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Vector3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="vector">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the vector.
        /// </returns>
        private static string ToKerkytheaString(Vector3D vector)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(vector.X, 1),
                ValueOrDefault(vector.Y, 0),
                ValueOrDefault(vector.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Color"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="c">
        /// The color.
        /// </param>
        /// <returns>
        /// A string representing the color.
        /// </returns>
        private static string ToKerkytheaString(Color c)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                c.R / 255.0,
                c.G / 255.0,
                c.B / 255.0);
        }

        /// <summary>
        /// Exports the map channel (texture coordinates) from the specified mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        private void ExportMapChannel(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Map Channel");
                writer.WriteAttributeString("Type", "Point2D List");
                int n = m.TriangleIndices.Count;
                writer.WriteAttributeString("Value", n.ToString());
                foreach (int index in m.TriangleIndices)
                {
                    if (index >= m.TextureCoordinates.Count)
                    {
                        continue;
                    }

                    var uv = m.TextureCoordinates[index];
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xy", ToKerkytheaString(uv));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Exports a material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the material.</param>
        /// <param name="material">The material.</param>
        /// <param name="weights">The weights.</param>
        private void ExportMaterial(KerkytheaWriter writer, string name, Material material, IList<double> weights)
        {
            var g = material as MaterialGroup;
            if (g != null)
            {
                foreach (var m in g.Children)
                {
                    this.ExportMaterial(writer, name, m, weights);
                }
            }

            var d = material as DiffuseMaterial;
            if (d != null)
            {
                string texture = null;
                Color? color = null;
                double alpha = 1.0;
                if (d.Brush is SolidColorBrush)
                {
                    color = this.GetSolidColor(d.Brush, d.Color);
                    alpha = color.Value.A / 255.0;
                }
                else
                {
                    texture = this.GetTexture(writer, d.Brush, name);
                }

                if (alpha > 0)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), texture, color, null, null);
                    weights.Add(alpha);
                }

                // The refractive part
                if (alpha < 1)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, null, Colors.White);
                    weights.Add(1 - alpha);
                }
            }

            var s = material as SpecularMaterial;
            if (s != null)
            {
                var color = this.GetSolidColor(s.Brush, s.Color);

                // color = Color.FromArgb((byte)(color.A * factor), (byte)(color.R * factor), (byte)(color.G * factor), (byte)(color.B * factor));
                this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, color, null, s.SpecularPower * 0.5);
                double weight = color.A / 255.0;
                weight *= 0.01;
                weights.Add(weight);
            }

            var e = material as EmissiveMaterial;
            if (e != null)
            {
                // TODO
                System.Diagnostics.Debug.WriteLine("KerkytheaExporter: Emissive materials are not yet supported.");

                // Color color = GetSolidColor(e.Brush, d.Color);
                // WriteWhittedMaterial(string.Format("#{0}", weights.Count + 1), color, null, null);
                // WriteStartObject("./Translucent/Constant Texture", "Constant Texture", "", "Texture");
                // WriteParameter("Color", e.Color);
                // WriteEndObject();
            }
        }

        /// <summary>
        /// Exports the specified material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="material">The material.</param>
        private void ExportMaterial(KerkytheaWriter writer, Material material)
        {
            // If the material is registered, simply output the xml
            if (this.registeredMaterials.ContainsKey(material))
            {
                var doc = this.registeredMaterials[material];
                if (doc?.DocumentElement != null)
                {
                    foreach (XmlNode e in doc.DocumentElement.ChildNodes)
                    {
                        writer.Write(e);
                    }
                }

                return;
            }

            string name = this.GetUniqueName(writer, material, "Material");
            writer.WriteStartObject(name, "Layered Material", name, "Material");

            var weights = new List<double>();

            this.ExportMaterial(writer, name, material, weights);

            // if (Reflections)
            // {
            // WriteConstantTexture("Reflection", ReflectionColor);
            // }
            for (int i = 0; i < weights.Count; i++)
            {
                this.WriteWeight(writer, "Weight #" + i, weights[i]);
            }

            /*
             switch (MaterialType)
             {
                 case MaterialTypes.Ashikhmin:
                     this.WriteParameter("Rotation", 0.0);
                     this.WriteParameter("Attenuation", "Schlick");
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("N-K File", "");
                     break;
                 case MaterialTypes.Diffusive: // Whitted material
                     this.WriteParameter("Shininess", 60.0);
                     this.WriteParameter("Transmitted Shininess", 128.0);
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("Specular Sampling", true);
                     this.WriteParameter("Transmitted Sampling", false);
                     this.WriteParameter("Specular Attenuation", "Cosine");
                     this.WriteParameter("Transmitted Attenuation", "Cosine");
                     break;
             }
             */
            writer.WriteEndObject();
        }

        /// <summary>
        /// Gets the solid color from a brush.
        /// </summary>
        /// <param name="brush">
        /// The brush.
        /// </param>
        /// <param name="defaultColor">
        /// The default color (used if the specified brush is not a <see cref="SolidColorBrush"/>).
        /// </param>
        /// <returns>
        /// The color.
        /// </returns>
        private Color GetSolidColor(Brush brush, Color defaultColor)
        {
            var scb = brush as SolidColorBrush;
            if (scb != null)
            {
                return scb.Color;
            }

            return defaultColor;
        }

        /// <summary>
        /// Gets the texture for a brush.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="brush">The brush.</param>
        /// <param name="name">The name of the material.</param>
        /// <returns>
        /// The texture filename.
        /// </returns>
        private string GetTexture(KerkytheaWriter writer, Brush brush, string name)
        {
            // reuse textures
            string textureFile;
            if (writer.TryGetTexture(brush, out textureFile))
            {
                return textureFile;
            }

            string filename = name + ".png";
            string path = Path.Combine(this.TexturePath, filename);
            using (var s = this.FileCreator(path))
            {
                this.RenderBrush(s, brush, this.TextureWidth, this.TextureHeight);
            }

            writer.AddTexture(brush, filename);
            return filename;
        }

        /// <summary>
        /// Gets a unique name.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="o">The object.</param>
        /// <param name="defaultName">The default name.</param>
        /// <returns>A unique name.</returns>
        private string GetUniqueName(KerkytheaWriter writer, DependencyObject o, string defaultName)
        {
            var name = o.GetValue(FrameworkElement.NameProperty) as string;
            return writer.GetUniqueName(name, defaultName);
        }

        /// <summary>
        /// Writes a ashikhmin material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="shininessXMap">The shininess x map.</param>
        /// <param name="shininessYMap">The shininess y map.</param>
        /// <param name="rotationMap">The rotation map.</param>
        /// <param name="shininessX">The shininess x.</param>
        /// <param name="shininessY">The shininess y.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteAshikhminMaterial(KerkytheaWriter writer,
            string identifier,
            Color? diffuse,
            Color? specular,
            Color? shininessXMap,
            Color? shininessYMap,
            Color? rotationMap,
            double shininessX = 100,
            double shininessY = 100,
            double rotation = 0,
            double indexOfRefraction = 1.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (shininessXMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess X Map", shininessXMap.Value);
            }

            if (shininessYMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess Y Map", shininessYMap.Value);
            }

            if (rotationMap.HasValue)
            {
                this.WriteConstantTexture(writer, "RotationMap", rotationMap.Value);
            }

            writer.WriteParameter("Shininess X", shininessX);
            writer.WriteParameter("Shininess Y", shininessY);
            writer.WriteParameter("Rotation", rotation);
            writer.WriteParameter("Attenuation", "Schlick");
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("N-K File", nkfile);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a bitmap texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="filename">The filename.</param>
        private void WriteBitmapTexture(KerkytheaWriter writer, string name, string filename)
        {
            if (!string.IsNullOrEmpty(filename))
            {
                writer.WriteStartObject("./" + name + "/Bitmap Texture", "Bitmap Texture", string.Empty, "Texture");
                writer.WriteParameter("Filename", filename);
                writer.WriteParameter("Projection", "UV");
                writer.WriteParameter("Offset X", 0.0);
                writer.WriteParameter("Offset Y", 0.0);
                writer.WriteParameter("Scale X", 1.0);
                writer.WriteParameter("Scale Y", 1.0);
                writer.WriteParameter("Rotation", 0.0);
                writer.WriteParameter("Smooth", true);
                writer.WriteParameter("Inverted", false);
                writer.WriteParameter("Alpha Channel", false);
                writer.WriteEndObject();
            }
        }

        /// <summary>
        /// Writes a constant texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="color">The color.</param>
        private void WriteConstantTexture(KerkytheaWriter writer, string name, Color color)
        {
            writer.WriteStartObject("./" + name + "/Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", color);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a dielectric material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="reflection">The reflection.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="dispersion">The dispersion.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteDielectricMaterial(KerkytheaWriter writer,
            string identifier,
            Color? reflection,
            Color? refraction,
            double indexOfRefraction = 1.0,
            double dispersion = 0.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (reflection.HasValue)
            {
                this.WriteConstantTexture(writer, "Reflection", reflection.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Dispersion", dispersion);
            writer.WriteParameter("N-K File", string.Empty);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a weight.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="weight">The weight.</param>
        private void WriteWeight(KerkytheaWriter writer, string identifier, double weight)
        {
            writer.WriteStartObject(identifier, "Weighted Texture", identifier, "Texture");
            writer.WriteStartObject("Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", Colors.White);
            writer.WriteEndObject();
            writer.WriteParameter("Weight #0", weight);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a whitted material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="texture">The texture.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="shininess">The shininess.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        private void WriteWhittedMaterial(KerkytheaWriter writer,
            string identifier,
            string texture,
            Color? diffuse,
            Color? specular,
            Color? refraction,
            double shininess = 128.0,
            double indexOfRefraction = 1.0)
        {
            writer.WriteStartObject(identifier, "Whitted Material", identifier, "Material");

            if (texture != null)
            {
                this.WriteBitmapTexture(writer, "Diffuse", texture);
            }

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Shininess", shininess);
            writer.WriteParameter("Transmitted Shininess", 128.0);
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Specular Sampling", false);
            writer.WriteParameter("Transmitted Sampling", false);
            writer.WriteParameter("Specular Attenuation", "Cosine");
            writer.WriteParameter("Transmitted Attenuation", "Cosine");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Returns the <paramref name="value"/> or the <paramref name="defaultValue"/> if the <paramref name="value"/> is NaN.
        /// </summary>
        /// <param name="value">
        /// The value.
        /// </param>
        /// <param name="defaultValue">
        /// The default value.
        /// </param>
        /// <returns>
        /// The value.
        /// </returns>
        public static double ValueOrDefault(double value, double defaultValue)
        {
            if (double.IsNaN(value))
            {
                return defaultValue;
            }

            return value;
        }

        /// <summary>
        /// Represents the output writer for the <see cref="KerkytheaExporter"/>.
        /// </summary>
        public class KerkytheaWriter
        {
            /// <summary>
            /// The writer
            /// </summary>
            private readonly XmlWriter writer;

            /// <summary>
            /// The names.
            /// </summary>
            private readonly HashSet<string> names = new HashSet<string>();

            /// <summary>
            /// Texture bitmaps are reused. This dictionary contains a map from brush to filename
            /// </summary>
            private readonly Dictionary<Brush, string> textureFiles = new Dictionary<Brush, string>();

            /// <summary>
            /// Initializes a new instance of the <see cref="KerkytheaWriter"/> class.
            /// </summary>
            /// <param name="stream">The stream.</param>
            public KerkytheaWriter(Stream stream)
            {
                var settings = new XmlWriterSettings { Indent = true };
                this.writer = XmlWriter.Create(stream, settings);
            }

            /// <summary>
            /// Writes the start element.
            /// </summary>
            /// <param name="localName">Name of the element.</param>
            public void WriteStartElement(string localName)
            {
                this.writer.WriteStartElement(localName);
            }

            /// <summary>
            /// Writes the attribute string.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="value">The value.</param>
            public void WriteAttributeString(string name, string value)
            {
                this.writer.WriteAttributeString(name, value);
            }

            /// <summary>
            /// Writes the end element.
            /// </summary>
            public void WriteEndElement()
            {
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes the full end element.
            /// </summary>
            public void WriteFullEndElement()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the start document.
            /// </summary>
            public void WriteStartDocument()
            {
                this.writer.WriteStartDocument();
            }

            /// <summary>
            /// Closes this instance.
            /// </summary>
            public void Close()
            {
                this.writer.Close();
            }

            /// <summary>
            /// Writes a parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string type, string value)
            {
                this.writer.WriteStartElement("Parameter");
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
                this.writer.WriteAttributeString("Value", value);
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes a string parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string value)
            {
                this.WriteParameter(name, "String", value);
            }

            /// <summary>
            /// Writes a color parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="color">
            /// The color.
            /// </param>
            public void WriteParameter(string name, Color color)
            {
                this.WriteParameter(name, "RGB", ToKerkytheaString(color));
            }

            /// <summary>
            /// Writes a boolean parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="flag">
            /// The flag.
            /// </param>
            public void WriteParameter(string name, bool flag)
            {
                this.WriteParameter(name, "Boolean", flag ? "1" : "0");
            }

            /// <summary>
            /// Writes a double parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, double value)
            {
                this.WriteParameter(name, "Real", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes an integer parameter.
            /// </summary>
            /// <param name="name">
            /// The parameter name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, int value)
            {
                this.WriteParameter(name, "Integer", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes a transformation matrix.
            /// </summary>
            /// <param name="name">
            /// The name of the matrix.
            /// </param>
            /// <param name="m">
            /// The matrix.
            /// </param>
            public void WriteTransform(string name, Matrix3D m)
            {
                string value = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} {6:0.######} {7:0.######} {8:0.######} {9:0.######} {10:0.######} {11:0.######}",
                    m.M11,
                    m.M12,
                    m.M13,
                    m.OffsetX,
                    m.M21,
                    m.M22,
                    m.M23,
                    m.OffsetY,
                    m.M31,
                    m.M32,
                    m.M33,
                    m.OffsetZ);

                this.WriteParameter(name, "Transform", value);
            }

            /// <summary>
            /// Writes the end object.
            /// </summary>
            public void WriteEndObject()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteObject(string identifier, string label, string name, string type)
            {
                this.WriteStartObject(identifier, label, name, type);
                this.WriteEndObject();
            }

            /// <summary>
            /// Writes the start object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteStartObject(string identifier, string label, string name, string type)
            {
                this.writer.WriteStartElement("Object");
                this.writer.WriteAttributeString("Identifier", identifier);
                this.writer.WriteAttributeString("Label", label);
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
            }

            /// <summary>
            /// Writes the end document.
            /// </summary>
            public void WriteEndDocument()
            {
                this.writer.WriteEndDocument();
            }

            /// <summary>
            /// Writes the specified XML node.
            /// </summary>
            /// <param name="xmlNode">The XML node.</param>
            public void Write(XmlNode xmlNode)
            {
                xmlNode.WriteTo(this.writer);
            }

            /// <summary>
            /// Tries to get the texture for the specified brush.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="textureFile">The texture file.</param>
            /// <returns><c>true</c> if the texture was found.</returns>
            public bool TryGetTexture(Brush brush, out string textureFile)
            {
                return this.textureFiles.TryGetValue(brush, out textureFile);
            }

            /// <summary>
            /// Adds the specified texture.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="filename">The filename.</param>
            public void AddTexture(Brush brush, string filename)
            {
                this.textureFiles.Add(brush, filename);
            }

            /// <summary>
            /// Gets a unique name.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="defaultName">The default name.</param>
            /// <returns></returns>
            public string GetUniqueName(string name, string defaultName)
            {
                if (string.IsNullOrEmpty(name))
                {
                    int n = 1;
                    while (true)
                    {
                        // name = defaultName + " #" + n;
                        name = defaultName + n;
                        if (!this.names.Contains(name))
                        {
                            break;
                        }

                        n++;
                    }
                }

                this.names.Add(name);
                return name;
            }
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;
    using System.Xml;

    /// <summary>
    /// Exports the 3D visual tree to a <a href="http://www.kerkythea.net/joomla">Kerkythea</a> input file.
    /// </summary>
    public class KerkytheaExporter : Exporter<KerkytheaExporter.KerkytheaWriter>
    {
        /// <summary>
        /// Dictionary of registered materials.
        /// </summary>
        private readonly Dictionary<Material, XmlDocument> registeredMaterials = new Dictionary<Material, XmlDocument>();

        /// <summary>
        /// Initializes a new instance of the <see cref="KerkytheaExporter"/> class.
        /// </summary>
        public KerkytheaExporter()
        {
            this.Name = "My Scene";
            this.BackgroundColor = Colors.Black;
            this.ReflectionColor = Colors.Gray;
            this.Reflections = true;
            this.Shadows = true;
            this.SoftShadows = true;
            this.LightMultiplier = 3.0;
            this.Threads = 2;

            this.ShadowColor = Color.FromArgb(255, 100, 100, 100);
            this.RenderSetting = RenderSettings.RayTracer;
            this.Aperture = "Pinhole";
            this.FocusDistance = 1.0;
            this.LensSamples = 3;

            this.Width = 500;
            this.Height = 500;

            this.TextureWidth = 1024;
            this.TextureHeight = 1024;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Render settings.
        /// </summary>
        public enum RenderSettings
        {
            /// <summary>
            /// Use RayTracer.
            /// </summary>
            RayTracer,

            /// <summary>
            /// Use PhotonMap.
            /// </summary>
            PhotonMap,

            /// <summary>
            /// Use MetropolisLightTransport.
            /// </summary>
            MetropolisLightTransport
        }

        /// <summary>
        /// Gets or sets the aperture.
        /// </summary>
        /// <value>The aperture.</value>
        public string Aperture { get; set; }

        /// <summary>
        /// Gets or sets the color of the background.
        /// </summary>
        /// <value>The color of the background.</value>
        public Color BackgroundColor { get; set; }

        /// <summary>
        /// Gets or sets the texture file creator.
        /// </summary>
        /// <value>The file creator.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets the length of the focal.
        /// </summary>
        /// <value>The length of the focal.</value>
        public double FocalLength { get; set; }

        /// <summary>
        /// Gets or sets the focus distance.
        /// </summary>
        /// <value>The focus distance.</value>
        public double FocusDistance { get; set; }

        /// <summary>
        /// Gets or sets the height.
        /// </summary>
        /// <value>The height.</value>
        public int Height { get; set; }

        /// <summary>
        /// Gets or sets the lens samples.
        /// </summary>
        /// <value>The lens samples.</value>
        public int LensSamples { get; set; }

        /// <summary>
        /// Gets or sets the light multiplier.
        /// </summary>
        /// <value>The light multiplier.</value>
        public double LightMultiplier { get; set; }

        /// <summary>
        /// Gets or sets the name.
        /// </summary>
        /// <value>The name.</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets the color of the reflection.
        /// </summary>
        /// <value>The color of the reflection.</value>
        public Color ReflectionColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is reflections.
        /// </summary>
        /// <value><c>true</c> if reflections; otherwise, <c>false</c>.</value>
        public bool Reflections { get; set; }

        /// <summary>
        /// Gets or sets the render setting.
        /// </summary>
        /// <value>The render setting.</value>
        public RenderSettings RenderSetting { get; set; }

        /// <summary>
        /// Gets or sets the color of the shadow.
        /// </summary>
        /// <value>The color of the shadow.</value>
        public Color ShadowColor { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether this <see cref = "KerkytheaExporter" /> is shadows.
        /// </summary>
        /// <value><c>true</c> if shadows; otherwise, <c>false</c>.</value>
        public bool Shadows { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether [soft shadows].
        /// </summary>
        /// <value><c>true</c> if [soft shadows]; otherwise, <c>false</c>.</value>
        public bool SoftShadows { get; set; }

        /// <summary>
        /// Gets or sets the height of the texture.
        /// </summary>
        /// <value>The height of the texture.</value>
        public int TextureHeight { get; set; }

        /// <summary>
        /// Gets or sets the texture path.
        /// </summary>
        /// <value>The texture path.</value>
        public string TexturePath { get; set; }

        /// <summary>
        /// Gets or sets the width of the texture.
        /// </summary>
        /// <value>The width of the texture.</value>
        public int TextureWidth { get; set; }

        /// <summary>
        /// Gets or sets the threads.
        /// </summary>
        /// <value>The threads.</value>
        public int Threads { get; set; }

        /// <summary>
        /// Gets or sets the width.
        /// </summary>
        /// <value>The width.</value>
        public int Width { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        public void ExportMesh(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartObject("Triangular Mesh", "Triangular Mesh", string.Empty, "Surface");

            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Vertex List");
                writer.WriteAttributeString("Type", "Point3D List");
                writer.WriteAttributeString("Value", m.Positions.Count.ToString());
                foreach (var p in m.Positions)
                {
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xyz", ToKerkytheaString(p));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            int triangles = m.TriangleIndices.Count / 3;

            // NORMALS
            // todo: write normal list per vertex instead of per triangle index
            if (m.Normals != null && m.Normals.Count > 0)
            {
                writer.WriteStartElement("Parameter");
                {
                    writer.WriteAttributeString("Name", "Normal List");
                    writer.WriteAttributeString("Type", "Point3D List");
                    writer.WriteAttributeString("Value", m.TriangleIndices.Count.ToString());
                    foreach (int index in m.TriangleIndices)
                    {
                        if (index >= m.Normals.Count)
                        {
                            continue;
                        }

                        var n = m.Normals[index];
                        writer.WriteStartElement("P");
                        writer.WriteAttributeString("xyz", ToKerkytheaString(n));
                        writer.WriteEndElement();
                    }
                }

                writer.WriteFullEndElement();
            }

            // TRIANGLE INDICES
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Index List");
                writer.WriteAttributeString("Type", "Triangle Index List");
                writer.WriteAttributeString("Value", triangles.ToString());
                for (int a = 0; a < triangles; a++)
                {
                    int a3 = a * 3;
                    int i = m.TriangleIndices[a3];
                    int j = m.TriangleIndices[a3 + 1];
                    int k = m.TriangleIndices[a3 + 2];
                    writer.WriteStartElement("F");
                    writer.WriteAttributeString("ijk", string.Format("{0} {1} {2}", i, j, k));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();

            writer.WriteParameter("Smooth", true);
            writer.WriteParameter("AA Tolerance", 15.0);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Registers a material.
        /// </summary>
        /// <param name="m">The material to register.</param>
        /// <param name="stream">The material stream.</param>
        public void RegisterMaterial(Material m, Stream stream)
        {
            var doc = new XmlDocument();
            doc.Load(stream);
            this.registeredMaterials.Add(m, doc);
        }

        /// <summary>
        /// Writes the Metropolis Light Transport properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the MLP ray tracer.</param>
        public void WriteMetropolisLightTransport(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Metropolis Light Transport", name, "Ray Tracer");
            writer.WriteParameter("Max Ray Tracing Depth", 100);
            writer.WriteParameter("Max Iterations", 10000);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Seed Paths", 50000);
            writer.WriteParameter("Large Step Probability", 0.2);
            writer.WriteParameter("Max Mutation Distance", 0.02);
            writer.WriteParameter("Live Probability", 0.7);
            writer.WriteParameter("Max Consecutive Rejections", 200);
            writer.WriteParameter("Bidirectional", true);
            writer.WriteParameter("Super Sampling", "3x3");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("Random Seed", "Automatic");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the standard ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the ray tracer.</param>
        public void WriteStandardRayTracer(KerkytheaWriter writer, string name)
        {
            writer.WriteStartObject("./Ray Tracers/" + name, "Standard Ray Tracer", name, "Ray Tracer");
            writer.WriteParameter("Rasterization", "Auto");

            // WriteParameter("Antialiasing", "Extra Pass 3x3");
            writer.WriteParameter("Antialiasing", "Production AA");
            writer.WriteParameter("Antialiasing Filter", "Mitchell-Netravali 0.5 0.8");
            writer.WriteParameter("Antialiasing Threshold", 0.3);
            writer.WriteParameter("Texture Filtering", true);
            writer.WriteParameter("Ambient Lighting", true);
            writer.WriteParameter("Direct Lighting", true);
            writer.WriteParameter("Sky Lighting", true);
            writer.WriteParameter("Brightness Threshold", 0.002);
            writer.WriteParameter("Max Ray Tracing Depth", 5);
            writer.WriteParameter("Max Scatter Bounces", 5);
            writer.WriteParameter("Max Dirac Bounces", 5);
            writer.WriteParameter("Irradiance Precomputation", 4);
            writer.WriteParameter("Irradiance Scale", Colors.White);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Max Iterations", 5);
            writer.WriteParameter("Super Sampling", "None");
            writer.WriteParameter("Image Filename", "temp.jpg");
            writer.WriteParameter("./Sampling Criteria/Diffuse Samples", 1024);
            writer.WriteParameter("./Sampling Criteria/Specular Samples", 32);
            writer.WriteParameter("./Sampling Criteria/Dispersion Samples", true);
            writer.WriteParameter("./Sampling Criteria/Trace Diffusers", false);
            writer.WriteParameter("./Sampling Criteria/Trace Translucencies", false);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Fuzzy Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Trace Reflections", true);
            writer.WriteParameter("./Sampling Criteria/Trace Refractions", true);
            writer.WriteParameter("./Sampling Criteria/Random Generator", "Pure");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes the threaded ray tracer properties.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="threads">The number of threads.</param>
        public void WriteThreadedRaytracer(KerkytheaWriter writer, int threads)
        {
            writer.WriteStartObject("./Ray Tracers/Threaded Ray Tracer", "Threaded Ray Tracer", "Threaded Ray Tracer", "Ray Tracer");
            for (int i = 0; i < threads; i++)
            {
                writer.WriteParameter("Thread #" + i, "#" + i);
            }

            writer.WriteParameter("Network Mode", "None");
            writer.WriteParameter("Listening Port", 6200);
            writer.WriteParameter("Host", "127.0.0.1");
            writer.WriteEndObject();
        }

        /// <summary>
        /// Creates the writer for the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>The writer.</returns>
        protected override KerkytheaWriter Create(Stream stream)
        {
            return new KerkytheaWriter(stream);
        }

        /// <summary>
        /// Exports the camera.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="c">The camera.</param>
        /// <exception cref="System.InvalidOperationException">Only perspective cameras are supported.</exception>
        protected override void ExportCamera(KerkytheaWriter writer, Camera c)
        {
            var pc = c as PerspectiveCamera;
            if (pc == null)
            {
                throw new InvalidOperationException("Only perspective cameras are supported.");
            }

            const string name = "Camera #1";
            writer.WriteStartObject("./Cameras/" + name, "Pinhole Camera", name, "Camera");

            // FOV = 2 arctan (x / (2 f)), x is diagonal, f is focal length
            // f = x / 2 / Tan(FOV/2)
            // http://en.wikipedia.org/wiki/Angle_of_view
            // http://kmp.bdimitrov.de/technology/fov.html

            // PerspectiveCamera.FieldOfView: Horizontal field of view
            // Must multiply by ratio of Viewport Width/Height
            double ratio = this.Width / (double)this.Height;
            const double x = 40;
            double f = 0.5 * ratio * x / Math.Tan(0.5 * pc.FieldOfView / 180.0 * Math.PI);

            writer.WriteParameter("Focal Length (mm)", f);
            writer.WriteParameter("Film Height (mm)", x);
            writer.WriteParameter("Resolution", string.Format(CultureInfo.InvariantCulture, "{0}x{1}", this.Width, this.Height));

            var t = CreateTransform(pc.Position, pc.LookDirection, pc.UpDirection);
            writer.WriteTransform("Frame", t);

            writer.WriteParameter("Focus Distance", this.FocusDistance);
            writer.WriteParameter("f-number", this.Aperture);
            writer.WriteParameter("Lens Samples", this.LensSamples);
            writer.WriteParameter("Blades", 6);
            writer.WriteParameter("Diaphragm", "Circular");
            writer.WriteParameter("Projection", "Planar");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the document header.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void ExportHeader(KerkytheaWriter writer)
        {
            writer.WriteStartDocument();

            writer.WriteStartElement("Root");
            writer.WriteAttributeString("Label", "Default Kernel");
            writer.WriteAttributeString("Name", string.Empty);
            writer.WriteAttributeString("Type", "Kernel");

            writer.WriteStartObject("./Modellers/XML Modeller", "XML Modeller", "XML Modeller", "Modeller");
            writer.WriteEndObject();

            writer.WriteStartObject("./Image Handlers/Free Image Support", "Free Image Support", "Free Image Support", "Image Handler");
            writer.WriteParameter("Tone Mapping", "External");
            writer.WriteParameter("Jpeg Quality", "Higher");
            writer.WriteEndObject();

            writer.WriteStartObject("./Direct Light Estimators/Refraction Enhanced", "Refraction Enhanced", "Refraction Enhanced", "Direct Light Estimator");
            writer.WriteParameter("Enabled", "Boolean", "1");
            writer.WriteParameter("PseudoCaustics", "Boolean", "0");
            writer.WriteParameter("PseudoTranslucencies", "Boolean", "0");
            writer.WriteParameter("Area Light Evaluation", "Boolean", "1");
            writer.WriteParameter("Optimized Area Lights", "Boolean", "1");
            writer.WriteParameter("Accurate Soft Shadows", "Boolean", "0");
            writer.WriteParameter("Antialiasing", "String", "High");
            writer.WriteParameter("./Evaluation/Diffuse", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Specular", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Translucent", "Boolean", "1");
            writer.WriteParameter("./Evaluation/Transmitted", "Boolean", "1");
            writer.WriteEndObject();

            // add ray tracer module.
            for (int i = 0; i < this.Threads; i++)
            {
                this.WriteStandardRayTracer(writer, "#" + i);
            }

            this.WriteThreadedRaytracer(writer, this.Threads);

            // add spatial subdivision module.
            writer.WriteStartObject("./Environments/Octree Environment", "Octree Environment", "Octree Environment", "Environment");
            writer.WriteParameter("Max Objects per Cell", 20);
            writer.WriteParameter("Instancing Switch", 1000000);
            writer.WriteParameter("Caching Switch", 6000000);
            writer.WriteEndObject();

            // add basic post filtering / tone mapping.
            writer.WriteStartObject("./Filters/Simple Tone Mapping", "Simple Tone Mapping", string.Empty, "Filter");
            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Method", "Simple");
            writer.WriteParameter("Exposure", 1.0);
            writer.WriteParameter("Gamma", 1.0);
            writer.WriteParameter("Dark Multiplier", 1.0);
            writer.WriteParameter("Bright Multiplier", 1.0);
            writer.WriteParameter("Reverse Correction", true);
            writer.WriteParameter("Reverse Gamma", 2.2);
            writer.WriteEndObject();

            // start of scene description.
            writer.WriteStartObject("./Scenes/" + this.Name, "Default Scene", this.Name, "Scene");
        }

        /// <summary>
        /// Exports the light.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="l">The light.</param>
        /// <param name="t">The transform.</param>
        protected override void ExportLight(KerkytheaWriter writer, Light l, Transform3D t)
        {
            if (l is AmbientLight)
            {
                return;
            }

            string name = this.GetUniqueName(writer, l, l.GetType().Name);

            writer.WriteStartObject("./Lights/" + name, "Default Light", name, "Light");
            {
                string stype = "Projector Light";

                if (l is SpotLight s)
                {
                    stype = "Spot Light";
                }

                if (l is PointLight p)
                {
                    stype = "Omni Light";
                }

                writer.WriteStartObject(stype, stype, string.Empty, "Emittance");

                // emitter Radiance
                writer.WriteStartObject("./Radiance/Constant Texture", "Constant Texture", string.Empty, "Texture");
                var c = Colors.White;
                writer.WriteParameter("Color", c);
                writer.WriteEndObject();

                // var v = new Vector3D(l.Color.R, l.Color.G, l.Color.B);
                // double lum = v.Length;
                writer.WriteParameter("Attenuation", "None");

                // SpotLight (Spot Light)
                if (l is SpotLight s)
                {
                    // todo : export the specular parameters
                    // s.ConstantAttenuation
                    // s.LinearAttenuation
                    // s.QuadraticAttenuation
                    writer.WriteParameter("Fall Off", s.OuterConeAngle);
                    writer.WriteParameter("Hot Spot", s.InnerConeAngle);
                }

                // DirectionalLight (Projector Light)
                if (l is DirectionalLight d)
                {
                    writer.WriteParameter("Width", 2.0);
                    writer.WriteParameter("Height", 2.0);
                }

                // PointLight (Omni light)
                if (l is PointLight p)
                {
                    // todo: export pointlight parameters
                    // name.ConstantAttenuation
                    // name.LinearAttenuation
                    // name.QuadraticAttenuation
                    // name.Range // distance beyond which the light has no effect
                }

                writer.WriteParameter("Focal Length", 1.0);

                writer.WriteEndObject(); // stype

                writer.WriteParameter("Enabled", true);
                writer.WriteParameter("Shadow", this.Shadows);
                writer.WriteParameter("Soft Shadow", this.SoftShadows);

                writer.WriteParameter("Negative Light", false);
                writer.WriteParameter("Global Photons", true);
                writer.WriteParameter("Caustic Photons", true);
                writer.WriteParameter("Multiplier", this.LightMultiplier);

                Matrix3D transform;
                var upVector = new Vector3D(0, 0, 1);

                if (l is SpotLight s)
                {
                    transform = CreateTransform(s.Position, s.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (l is DirectionalLight d)
                {
                    var origin = new Point3D(-1000 * d.Direction.X, -1000 * d.Direction.Y, -1000 * d.Direction.Z);
                    transform = CreateTransform(origin, d.Direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                if (l is PointLight p)
                {
                    var direction = new Vector3D(-p.Position.X, -p.Position.Y, -p.Position.Z);
                    transform = CreateTransform(p.Position, direction, upVector);
                    writer.WriteTransform("Frame", transform);
                }

                writer.WriteParameter("Focus Distance", 4.0);
                writer.WriteParameter("Radius", 0.2);
                writer.WriteParameter("Shadow Color", this.ShadowColor);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="g">The model geometry.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(KerkytheaWriter writer, GeometryModel3D g, Transform3D transform)
        {
            var mesh = g.Geometry as MeshGeometry3D;
            if (mesh == null)
            {
                return;
            }

            string name = this.GetUniqueName(writer, g, g.GetType().Name);
            writer.WriteStartObject("./Models/" + name, "Default Model", name, "Model");

            this.ExportMesh(writer, mesh);

            if (g.Material != null)
            {
                this.ExportMaterial(writer, g.Material);
            }

            var tg = new Transform3DGroup();
            tg.Children.Add(g.Transform);
            tg.Children.Add(transform);

            if (mesh.TextureCoordinates != null)
            {
                this.ExportMapChannel(writer, mesh);
            }

            writer.WriteTransform("Frame", tg.Value);

            writer.WriteParameter("Enabled", true);
            writer.WriteParameter("Visible", true);
            writer.WriteParameter("Shadow Caster", true);
            writer.WriteParameter("Shadow Receiver", true);
            writer.WriteParameter("Caustics Transmitter", true);
            writer.WriteParameter("Caustics Receiver", true);
            writer.WriteParameter("Exit Blocker", false);

            writer.WriteEndObject();
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="v">The viewport to export.</param>
        protected override void ExportViewport(KerkytheaWriter writer, Viewport3D v)
        {
            var ambient = Visual3DHelper.Find<AmbientLight>(v);

            // default global settings
            writer.WriteStartObject("Default Global Settings", "Default Global Settings", string.Empty, "Global Settings");
            if (ambient != null)
            {
                writer.WriteParameter("Ambient Light", ambient.Color);
            }

            writer.WriteParameter("Background Color", this.BackgroundColor);
            writer.WriteParameter("Compute Volume Transfer", false);
            writer.WriteParameter("Transfer Recursion Depth", 1);
            writer.WriteParameter("Background Type", "Sky Color");
            writer.WriteParameter("Sky Intensity", 1.0);
            writer.WriteParameter("Sky Frame", "Transform", "1 0 0 0 0 1 0 0 0 0 1 0 ");
            writer.WriteParameter("Sun Direction", "0 0 1");
            writer.WriteParameter("Sky Turbidity", 2.0);
            writer.WriteParameter("Sky Luminance Gamma", 1.2);
            writer.WriteParameter("Sky Chromaticity Gamma", 1.8);
            writer.WriteParameter("Linear Lightflow", true);
            writer.WriteParameter("Index of Refraction", 1.0);
            writer.WriteParameter("Scatter Density", 0.1);
            writer.WriteParameter("./Location/Latitude", 0.0);
            writer.WriteParameter("./Location/Longitude", 0.0);
            writer.WriteParameter("./Location/Timezone", 0);
            writer.WriteParameter("./Location/Date", "0/0/2007");
            writer.WriteParameter("./Location/Time", "12:0:0");
            writer.WriteParameter("./Background Image/Filename", "[No Bitmap]");
            writer.WriteParameter("./Background Image/Projection", "UV");
            writer.WriteParameter("./Background Image/Offset X", 0.0);
            writer.WriteParameter("./Background Image/Offset Y", 0.0);
            writer.WriteParameter("./Background Image/Scale X", 1.0);
            writer.WriteParameter("./Background Image/Scale Y", 1.0);
            writer.WriteParameter("./Background Image/Rotation", 0.0);
            writer.WriteParameter("./Background Image/Smooth", true);
            writer.WriteParameter("./Background Image/Inverted", false);
            writer.WriteParameter("./Background Image/Alpha Channel", false);
            writer.WriteEndObject();

            // Visual3DHelper.Traverse<Light>(v.Children, ExportLight);
            // Visual3DHelper.Traverse<GeometryModel3D>(v.Children, ExportGeometryModel3D);
        }

        /// <summary>
        /// Closes this exporter.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(KerkytheaWriter writer)
        {
            // end of scene description.
            writer.WriteFullEndElement();

            // it is necessary to describe the primary/active modules as there might exist more than one!
            writer.WriteParameter("Mip Mapping", true);
            writer.WriteParameter("./Interfaces/Active", "Null Interface");
            writer.WriteParameter("./Modellers/Active", "XML Modeller");
            writer.WriteParameter("./Image Handlers/Active", "Free Image Support");

            writer.WriteParameter("./Ray Tracers/Active", "Threaded Ray Tracer");
            writer.WriteParameter("./Irradiance Estimators/Active", "Null Irradiance Estimator");
            writer.WriteParameter("./Direct Light Estimators/Active", "Refraction Enhanced");
            writer.WriteParameter("./Environments/Active", "Octree Environment");
            writer.WriteParameter("./Filters/Active", "Simple Tone Mapping");
            writer.WriteParameter("./Scenes/Active", this.Name);
            writer.WriteParameter("./Libraries/Active", "Material Librarian");

            // end of root element
            writer.WriteFullEndElement();

            writer.WriteEndDocument();
            writer.Close();
        }

        /// <summary>
        /// Creates a transform from the original coordinate system to the system defined by translation origin
        /// </summary>
        /// <param name="origin">The origin.</param>
        /// <param name="direction">The direction vector.</param>
        /// <param name="up">The up vector.</param>
        /// <returns>A transformation matrix.</returns>
        private static Matrix3D CreateTransform(Point3D origin, Vector3D direction, Vector3D up)
        {
            var z = direction;
            var x = Vector3D.CrossProduct(direction, up);
            var y = up;

            x.Normalize();
            y.Normalize();
            z.Normalize();

            var m = new Matrix3D(x.X, y.X, z.X, 0, x.Y, y.Y, z.Y, 0, x.Z, y.Z, z.Z, 0, origin.X, origin.Y, origin.Z, 1);

            return m;
        }

        /// <summary>
        /// Converts a <see cref="Point"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="p">
        /// The point.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point p)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0} {1}", p.X, p.Y);
        }

        /// <summary>
        /// Converts a <see cref="Point3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="point">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the point.
        /// </returns>
        private static string ToKerkytheaString(Point3D point)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(point.X, 1),
                ValueOrDefault(point.Y, 0),
                ValueOrDefault(point.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Vector3D"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="vector">
        /// The vector.
        /// </param>
        /// <returns>
        /// A string representing the vector.
        /// </returns>
        private static string ToKerkytheaString(Vector3D vector)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                ValueOrDefault(vector.X, 1),
                ValueOrDefault(vector.Y, 0),
                ValueOrDefault(vector.Z, 0));
        }

        /// <summary>
        /// Converts a <see cref="Color"/> to a string formatted for Kerkythea.
        /// </summary>
        /// <param name="c">
        /// The color.
        /// </param>
        /// <returns>
        /// A string representing the color.
        /// </returns>
        private static string ToKerkytheaString(Color c)
        {
            return string.Format(
                CultureInfo.InvariantCulture,
                "{0:0.######} {1:0.######} {2:0.######}",
                c.R / 255.0,
                c.G / 255.0,
                c.B / 255.0);
        }

        /// <summary>
        /// Exports the map channel (texture coordinates) from the specified mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh.</param>
        private void ExportMapChannel(KerkytheaWriter writer, MeshGeometry3D m)
        {
            writer.WriteStartElement("Parameter");
            {
                writer.WriteAttributeString("Name", "Map Channel");
                writer.WriteAttributeString("Type", "Point2D List");
                int n = m.TriangleIndices.Count;
                writer.WriteAttributeString("Value", n.ToString());
                foreach (int index in m.TriangleIndices)
                {
                    if (index >= m.TextureCoordinates.Count)
                    {
                        continue;
                    }

                    var uv = m.TextureCoordinates[index];
                    writer.WriteStartElement("P");
                    writer.WriteAttributeString("xy", ToKerkytheaString(uv));
                    writer.WriteEndElement();
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Exports a material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name of the material.</param>
        /// <param name="material">The material.</param>
        /// <param name="weights">The weights.</param>
        private void ExportMaterial(KerkytheaWriter writer, string name, Material material, IList<double> weights)
        {
            if (material is MaterialGroup g)
            {
                foreach (var m in g.Children)
                {
                    this.ExportMaterial(writer, name, m, weights);
                }
            }

            if (material is DiffuseMaterial d)
            {
                string texture = null;
                Color? color = null;
                double alpha = 1.0;
                if (d.Brush is SolidColorBrush)
                {
                    color = this.GetSolidColor(d.Brush, d.Color);
                    alpha = color.Value.A / 255.0;
                }
                else
                {
                    texture = this.GetTexture(writer, d.Brush, name);
                }

                if (alpha > 0)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), texture, color, null, null);
                    weights.Add(alpha);
                }

                // The refractive part
                if (alpha < 1)
                {
                    this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, null, Colors.White);
                    weights.Add(1 - alpha);
                }
            }

            if (material is SpecularMaterial s)
            {
                var color = this.GetSolidColor(s.Brush, s.Color);

                // color = Color.FromArgb((byte)(color.A * factor), (byte)(color.R * factor), (byte)(color.G * factor), (byte)(color.B * factor));
                this.WriteWhittedMaterial(writer, string.Format("#{0}", weights.Count), null, null, color, null, s.SpecularPower * 0.5);
                double weight = color.A / 255.0;
                weight *= 0.01;
                weights.Add(weight);
            }

            if (material is EmissiveMaterial e)
            {
                // TODO
                System.Diagnostics.Debug.WriteLine("KerkytheaExporter: Emissive materials are not yet supported.");

                // Color color = GetSolidColor(e.Brush, d.Color);
                // WriteWhittedMaterial(string.Format("#{0}", weights.Count + 1), color, null, null);
                // WriteStartObject("./Translucent/Constant Texture", "Constant Texture", "", "Texture");
                // WriteParameter("Color", e.Color);
                // WriteEndObject();
            }
        }

        /// <summary>
        /// Exports the specified material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="material">The material.</param>
        private void ExportMaterial(KerkytheaWriter writer, Material material)
        {
            // If the material is registered, simply output the xml
            if (this.registeredMaterials.ContainsKey(material))
            {
                var doc = this.registeredMaterials[material];
                if (doc?.DocumentElement != null)
                {
                    foreach (XmlNode e in doc.DocumentElement.ChildNodes)
                    {
                        writer.Write(e);
                    }
                }

                return;
            }

            string name = this.GetUniqueName(writer, material, "Material");
            writer.WriteStartObject(name, "Layered Material", name, "Material");

            var weights = new List<double>();

            this.ExportMaterial(writer, name, material, weights);

            // if (Reflections)
            // {
            // WriteConstantTexture("Reflection", ReflectionColor);
            // }
            for (int i = 0; i < weights.Count; i++)
            {
                this.WriteWeight(writer, "Weight #" + i, weights[i]);
            }

            /*
             switch (MaterialType)
             {
                 case MaterialTypes.Ashikhmin:
                     this.WriteParameter("Rotation", 0.0);
                     this.WriteParameter("Attenuation", "Schlick");
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("N-K File", "");
                     break;
                 case MaterialTypes.Diffusive: // Whitted material
                     this.WriteParameter("Shininess", 60.0);
                     this.WriteParameter("Transmitted Shininess", 128.0);
                     this.WriteParameter("Index of Refraction", 1.0);
                     this.WriteParameter("Specular Sampling", true);
                     this.WriteParameter("Transmitted Sampling", false);
                     this.WriteParameter("Specular Attenuation", "Cosine");
                     this.WriteParameter("Transmitted Attenuation", "Cosine");
                     break;
             }
             */
            writer.WriteEndObject();
        }

        /// <summary>
        /// Gets the solid color from a brush.
        /// </summary>
        /// <param name="brush">
        /// The brush.
        /// </param>
        /// <param name="defaultColor">
        /// The default color (used if the specified brush is not a <see cref="SolidColorBrush"/>).
        /// </param>
        /// <returns>
        /// The color.
        /// </returns>
        private Color GetSolidColor(Brush brush, Color defaultColor)
        {
            if (brush is SolidColorBrush scb)
            {
                return scb.Color;
            }

            return defaultColor;
        }

        /// <summary>
        /// Gets the texture for a brush.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="brush">The brush.</param>
        /// <param name="name">The name of the material.</param>
        /// <returns>
        /// The texture filename.
        /// </returns>
        private string GetTexture(KerkytheaWriter writer, Brush brush, string name)
        {
            // reuse textures
            string textureFile;
            if (writer.TryGetTexture(brush, out textureFile))
            {
                return textureFile;
            }

            string filename = name + ".png";
            string path = Path.Combine(this.TexturePath, filename);
            using (var s = this.FileCreator(path))
            {
                this.RenderBrush(s, brush, this.TextureWidth, this.TextureHeight);
            }

            writer.AddTexture(brush, filename);
            return filename;
        }

        /// <summary>
        /// Gets a unique name.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="o">The object.</param>
        /// <param name="defaultName">The default name.</param>
        /// <returns>A unique name.</returns>
        private string GetUniqueName(KerkytheaWriter writer, DependencyObject o, string defaultName)
        {
            var name = o.GetValue(FrameworkElement.NameProperty) as string;
            return writer.GetUniqueName(name, defaultName);
        }

        /// <summary>
        /// Writes a ashikhmin material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="shininessXMap">The shininess x map.</param>
        /// <param name="shininessYMap">The shininess y map.</param>
        /// <param name="rotationMap">The rotation map.</param>
        /// <param name="shininessX">The shininess x.</param>
        /// <param name="shininessY">The shininess y.</param>
        /// <param name="rotation">The rotation.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteAshikhminMaterial(KerkytheaWriter writer,
            string identifier,
            Color? diffuse,
            Color? specular,
            Color? shininessXMap,
            Color? shininessYMap,
            Color? rotationMap,
            double shininessX = 100,
            double shininessY = 100,
            double rotation = 0,
            double indexOfRefraction = 1.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (shininessXMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess X Map", shininessXMap.Value);
            }

            if (shininessYMap.HasValue)
            {
                this.WriteConstantTexture(writer, "Shininess Y Map", shininessYMap.Value);
            }

            if (rotationMap.HasValue)
            {
                this.WriteConstantTexture(writer, "RotationMap", rotationMap.Value);
            }

            writer.WriteParameter("Shininess X", shininessX);
            writer.WriteParameter("Shininess Y", shininessY);
            writer.WriteParameter("Rotation", rotation);
            writer.WriteParameter("Attenuation", "Schlick");
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("N-K File", nkfile);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a bitmap texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="filename">The filename.</param>
        private void WriteBitmapTexture(KerkytheaWriter writer, string name, string filename)
        {
            if (!string.IsNullOrEmpty(filename))
            {
                writer.WriteStartObject("./" + name + "/Bitmap Texture", "Bitmap Texture", string.Empty, "Texture");
                writer.WriteParameter("Filename", filename);
                writer.WriteParameter("Projection", "UV");
                writer.WriteParameter("Offset X", 0.0);
                writer.WriteParameter("Offset Y", 0.0);
                writer.WriteParameter("Scale X", 1.0);
                writer.WriteParameter("Scale Y", 1.0);
                writer.WriteParameter("Rotation", 0.0);
                writer.WriteParameter("Smooth", true);
                writer.WriteParameter("Inverted", false);
                writer.WriteParameter("Alpha Channel", false);
                writer.WriteEndObject();
            }
        }

        /// <summary>
        /// Writes a constant texture.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="name">The name.</param>
        /// <param name="color">The color.</param>
        private void WriteConstantTexture(KerkytheaWriter writer, string name, Color color)
        {
            writer.WriteStartObject("./" + name + "/Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", color);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a dielectric material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="reflection">The reflection.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        /// <param name="dispersion">The dispersion.</param>
        /// <param name="nkfile">The nkfile.</param>
        private void WriteDielectricMaterial(KerkytheaWriter writer,
            string identifier,
            Color? reflection,
            Color? refraction,
            double indexOfRefraction = 1.0,
            double dispersion = 0.0,
            string nkfile = null)
        {
            writer.WriteStartObject(identifier, "Ashikhmin Material", identifier, "Material");

            if (reflection.HasValue)
            {
                this.WriteConstantTexture(writer, "Reflection", reflection.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Dispersion", dispersion);
            writer.WriteParameter("N-K File", string.Empty);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a weight.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="weight">The weight.</param>
        private void WriteWeight(KerkytheaWriter writer, string identifier, double weight)
        {
            writer.WriteStartObject(identifier, "Weighted Texture", identifier, "Texture");
            writer.WriteStartObject("Constant Texture", "Constant Texture", string.Empty, "Texture");
            writer.WriteParameter("Color", Colors.White);
            writer.WriteEndObject();
            writer.WriteParameter("Weight #0", weight);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Writes a whitted material.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="identifier">The identifier.</param>
        /// <param name="texture">The texture.</param>
        /// <param name="diffuse">The diffuse.</param>
        /// <param name="specular">The specular.</param>
        /// <param name="refraction">The refraction.</param>
        /// <param name="shininess">The shininess.</param>
        /// <param name="indexOfRefraction">The index of refraction.</param>
        private void WriteWhittedMaterial(KerkytheaWriter writer,
            string identifier,
            string texture,
            Color? diffuse,
            Color? specular,
            Color? refraction,
            double shininess = 128.0,
            double indexOfRefraction = 1.0)
        {
            writer.WriteStartObject(identifier, "Whitted Material", identifier, "Material");

            if (texture != null)
            {
                this.WriteBitmapTexture(writer, "Diffuse", texture);
            }

            if (diffuse.HasValue)
            {
                this.WriteConstantTexture(writer, "Diffuse", diffuse.Value);
            }

            if (specular.HasValue)
            {
                this.WriteConstantTexture(writer, "Specular", specular.Value);
            }

            if (refraction.HasValue)
            {
                this.WriteConstantTexture(writer, "Refraction", refraction.Value);
            }

            writer.WriteParameter("Shininess", shininess);
            writer.WriteParameter("Transmitted Shininess", 128.0);
            writer.WriteParameter("Index of Refraction", indexOfRefraction);
            writer.WriteParameter("Specular Sampling", false);
            writer.WriteParameter("Transmitted Sampling", false);
            writer.WriteParameter("Specular Attenuation", "Cosine");
            writer.WriteParameter("Transmitted Attenuation", "Cosine");

            writer.WriteEndObject();
        }

        /// <summary>
        /// Returns the <paramref name="value"/> or the <paramref name="defaultValue"/> if the <paramref name="value"/> is NaN.
        /// </summary>
        /// <param name="value">
        /// The value.
        /// </param>
        /// <param name="defaultValue">
        /// The default value.
        /// </param>
        /// <returns>
        /// The value.
        /// </returns>
        public static double ValueOrDefault(double value, double defaultValue)
        {
            if (double.IsNaN(value))
            {
                return defaultValue;
            }

            return value;
        }

        /// <summary>
        /// Represents the output writer for the <see cref="KerkytheaExporter"/>.
        /// </summary>
        public class KerkytheaWriter
        {
            /// <summary>
            /// The writer
            /// </summary>
            private readonly XmlWriter writer;

            /// <summary>
            /// The names.
            /// </summary>
            private readonly HashSet<string> names = new HashSet<string>();

            /// <summary>
            /// Texture bitmaps are reused. This dictionary contains a map from brush to filename
            /// </summary>
            private readonly Dictionary<Brush, string> textureFiles = new Dictionary<Brush, string>();

            /// <summary>
            /// Initializes a new instance of the <see cref="KerkytheaWriter"/> class.
            /// </summary>
            /// <param name="stream">The stream.</param>
            public KerkytheaWriter(Stream stream)
            {
                var settings = new XmlWriterSettings { Indent = true };
                this.writer = XmlWriter.Create(stream, settings);
            }

            /// <summary>
            /// Writes the start element.
            /// </summary>
            /// <param name="localName">Name of the element.</param>
            public void WriteStartElement(string localName)
            {
                this.writer.WriteStartElement(localName);
            }

            /// <summary>
            /// Writes the attribute string.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="value">The value.</param>
            public void WriteAttributeString(string name, string value)
            {
                this.writer.WriteAttributeString(name, value);
            }

            /// <summary>
            /// Writes the end element.
            /// </summary>
            public void WriteEndElement()
            {
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes the full end element.
            /// </summary>
            public void WriteFullEndElement()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the start document.
            /// </summary>
            public void WriteStartDocument()
            {
                this.writer.WriteStartDocument();
            }

            /// <summary>
            /// Closes this instance.
            /// </summary>
            public void Close()
            {
                this.writer.Close();
            }

            /// <summary>
            /// Writes a parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string type, string value)
            {
                this.writer.WriteStartElement("Parameter");
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
                this.writer.WriteAttributeString("Value", value);
                this.writer.WriteEndElement();
            }

            /// <summary>
            /// Writes a string parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, string value)
            {
                this.WriteParameter(name, "String", value);
            }

            /// <summary>
            /// Writes a color parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="color">
            /// The color.
            /// </param>
            public void WriteParameter(string name, Color color)
            {
                this.WriteParameter(name, "RGB", ToKerkytheaString(color));
            }

            /// <summary>
            /// Writes a boolean parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="flag">
            /// The flag.
            /// </param>
            public void WriteParameter(string name, bool flag)
            {
                this.WriteParameter(name, "Boolean", flag ? "1" : "0");
            }

            /// <summary>
            /// Writes a double parameter.
            /// </summary>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, double value)
            {
                this.WriteParameter(name, "Real", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes an integer parameter.
            /// </summary>
            /// <param name="name">
            /// The parameter name.
            /// </param>
            /// <param name="value">
            /// The value.
            /// </param>
            public void WriteParameter(string name, int value)
            {
                this.WriteParameter(name, "Integer", value.ToString(CultureInfo.InvariantCulture));
            }

            /// <summary>
            /// Writes a transformation matrix.
            /// </summary>
            /// <param name="name">
            /// The name of the matrix.
            /// </param>
            /// <param name="m">
            /// The matrix.
            /// </param>
            public void WriteTransform(string name, Matrix3D m)
            {
                string value = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0:0.######} {1:0.######} {2:0.######} {3:0.######} {4:0.######} {5:0.######} {6:0.######} {7:0.######} {8:0.######} {9:0.######} {10:0.######} {11:0.######}",
                    m.M11,
                    m.M12,
                    m.M13,
                    m.OffsetX,
                    m.M21,
                    m.M22,
                    m.M23,
                    m.OffsetY,
                    m.M31,
                    m.M32,
                    m.M33,
                    m.OffsetZ);

                this.WriteParameter(name, "Transform", value);
            }

            /// <summary>
            /// Writes the end object.
            /// </summary>
            public void WriteEndObject()
            {
                this.writer.WriteFullEndElement();
            }

            /// <summary>
            /// Writes the object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteObject(string identifier, string label, string name, string type)
            {
                this.WriteStartObject(identifier, label, name, type);
                this.WriteEndObject();
            }

            /// <summary>
            /// Writes the start object.
            /// </summary>
            /// <param name="identifier">
            /// The identifier.
            /// </param>
            /// <param name="label">
            /// The label.
            /// </param>
            /// <param name="name">
            /// The name.
            /// </param>
            /// <param name="type">
            /// The type.
            /// </param>
            public void WriteStartObject(string identifier, string label, string name, string type)
            {
                this.writer.WriteStartElement("Object");
                this.writer.WriteAttributeString("Identifier", identifier);
                this.writer.WriteAttributeString("Label", label);
                this.writer.WriteAttributeString("Name", name);
                this.writer.WriteAttributeString("Type", type);
            }

            /// <summary>
            /// Writes the end document.
            /// </summary>
            public void WriteEndDocument()
            {
                this.writer.WriteEndDocument();
            }

            /// <summary>
            /// Writes the specified XML node.
            /// </summary>
            /// <param name="xmlNode">The XML node.</param>
            public void Write(XmlNode xmlNode)
            {
                xmlNode.WriteTo(this.writer);
            }

            /// <summary>
            /// Tries to get the texture for the specified brush.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="textureFile">The texture file.</param>
            /// <returns><c>true</c> if the texture was found.</returns>
            public bool TryGetTexture(Brush brush, out string textureFile)
            {
                return this.textureFiles.TryGetValue(brush, out textureFile);
            }

            /// <summary>
            /// Adds the specified texture.
            /// </summary>
            /// <param name="brush">The brush.</param>
            /// <param name="filename">The filename.</param>
            public void AddTexture(Brush brush, string filename)
            {
                this.textureFiles.Add(brush, filename);
            }

            /// <summary>
            /// Gets a unique name.
            /// </summary>
            /// <param name="name">The name.</param>
            /// <param name="defaultName">The default name.</param>
            /// <returns></returns>
            public string GetUniqueName(string name, string defaultName)
            {
                if (string.IsNullOrEmpty(name))
                {
                    int n = 1;
                    while (true)
                    {
                        // name = defaultName + " #" + n;
                        name = defaultName + n;
                        if (!this.names.Contains(name))
                        {
                            break;
                        }

                        n++;
                    }
                }

                this.names.Add(name);
                return name;
            }
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(537,36): error CS0128: A local variable or function named 's' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(555,37): error CS0128: A local variable or function named 'p' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(580,36): error CS0128: A local variable or function named 's' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(586,43): error CS0128: A local variable or function named 'd' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(593,37): error CS0128: A local variable or function named 'p' is already defined in this scope,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(543,55): error CS0165: Use of unassigned local variable 's',D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(588,54): error CS0165: Use of unassigned local variable 'd',D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\KerkytheaExporter.cs(595,51): error CS0165: Use of unassigned local variable 'p'
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter<ObjExporter.ObjWriters>
    {
        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<Material, string> exportedMaterials = new Dictionary<Material, string>();

        /// <summary>
        /// The group no.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// The mat no.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// The object no.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter" /> class.
        /// </summary>
        public ObjExporter()
        {
            this.TextureExtension = ".png";
            this.TextureSize = 1024;
            this.TextureQualityLevel = 90;
            this.TextureFolder = ".";

            this.SwitchYZ = false;
            this.ExportNormals = false;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets the texture image and materials file creator.
        /// </summary>
        /// <value>A function used to create streams for texture images and material files.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets the comment.
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Gets or sets the materials file.
        /// </summary>
        /// <value>
        /// The materials file.
        /// </value>
        public string MaterialsFile { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// Gets or sets the texture folder.
        /// </summary>
        public string TextureFolder { get; set; }

        /// <summary>
        /// Gets or sets the texture extension (.png or .jpg).
        /// </summary>
        /// <value>
        /// The default value is ".png".
        /// </value>
        public string TextureExtension { get; set; }

        /// <summary>
        /// Gets or sets the texture size.
        /// </summary>
        /// <value>
        /// The default value is 1024.
        /// </value>
        public int TextureSize { get; set; }

        /// <summary>
        /// Gets or sets the texture quality level (for JPEG encoding).
        /// </summary>
        /// <value>
        /// The quality level of the JPEG image. The value range is 1 (lowest quality) to 100 (highest quality) inclusive. 
        /// The default value is 90.
        /// </value>
        public int TextureQualityLevel { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh geometry.</param>
        /// <param name="t">The transform.</param>
        public void ExportMesh(StreamWriter writer, MeshGeometry3D m, Transform3D t)
        {
            if (m == null)
            {
                throw new ArgumentNullException(nameof(m));
            }

            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = t.Transform(v);
                    writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, this.SwitchYZ ? vn.Z : vn.Y, this.SwitchYZ ? -vn.Y : vn.Z));
                }

                writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
                {
                    bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                    bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                    if (hasTextureIndex && hasNormalIndex)
                    {
                        return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                    }

                    if (hasTextureIndex)
                    {
                        return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                    }

                    if (hasNormalIndex)
                    {
                        return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                    }

                    return vertexIndexMap[i0].ToString();
                };

            if (m.TriangleIndices != null)
            {
                for (int i = 0; i < m.TriangleIndices.Count; i += 3)
                {
                    int i0 = m.TriangleIndices[i];
                    int i1 = m.TriangleIndices[i + 1];
                    int i2 = m.TriangleIndices[i + 2];

                    writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                writer.WriteLine(string.Format("# {0} faces", m.TriangleIndices.Count / 3));
            }

            writer.WriteLine();
        }

        /// <summary>
        /// Creates the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>StreamWriter.</returns>
        protected override ObjWriters Create(Stream stream)
        {
            if (this.MaterialsFile == null)
            {
                throw new InvalidOperationException("The `MaterialsFile` property must be set.");
            }

            var writer = new StreamWriter(stream);

            if (!string.IsNullOrEmpty(this.Comment))
            {
                writer.WriteLine("# {0}", this.Comment);
            }

            writer.WriteLine("mtllib ./" + this.MaterialsFile);

            var materialStream = this.FileCreator(this.MaterialsFile);
            var materialWriter = new StreamWriter(materialStream);

            return new ObjWriters { ObjWriter = writer, MaterialsWriter = materialWriter };
        }

        /// <summary>
        /// Closes the specified writer.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(ObjWriters writer)
        {
            writer.ObjWriter.Close();
            writer.MaterialsWriter.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(ObjWriters writer, GeometryModel3D model, Transform3D transform)
        {
            writer.ObjWriter.WriteLine("o object{0}", this.objectNo++);
            writer.ObjWriter.WriteLine("g group{0}", this.groupNo++);

            if (this.exportedMaterials.ContainsKey(model.Material))
            {
                string matName = this.exportedMaterials[model.Material];
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
            }
            else
            {
                string matName = string.Format("mat{0}", this.matNo++);
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
                this.ExportMaterial(writer.MaterialsWriter, matName, model.Material, model.BackMaterial);
                this.exportedMaterials.Add(model.Material, matName);
            }

            var mesh = model.Geometry as MeshGeometry3D;
            this.ExportMesh(writer.ObjWriter, mesh, Transform3DHelper.CombineTransform(transform, model.Transform));
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="materialWriter">The material writer.</param>
        /// <param name="matName">The mat name.</param>
        /// <param name="material">The material.</param>
        /// <param name="backMaterial">The back material.</param>
        private void ExportMaterial(StreamWriter materialWriter, string matName, Material material, Material backMaterial)
        {
            materialWriter.WriteLine("newmtl {0}", matName);
            var dm = material as DiffuseMaterial;
            var sm = material as SpecularMaterial;
            var mg = material as MaterialGroup;
            if (mg != null)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }

                    if (m is SpecularMaterial)
                    {
                        sm = m as SpecularMaterial;
                    }
                }
            }

            if (dm != null)
            {
                var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity(0.2);

                // materialWriter.WriteLine(string.Format("Ka {0}", this.ToColorString(adjustedAmbientColor)));
                var scb = dm.Brush as SolidColorBrush;
                if (scb != null)
                {
                    materialWriter.WriteLine(string.Format("Kd {0}", this.ToColorString(scb.Color)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", scb.Color.A / 255.0));
                    }
                    else
                    {
                        // Transparency
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", scb.Color.A / 255.0));
                    }
                }
                else
                {
                    var textureFilename = matName + this.TextureExtension;
                    var texturePath = Path.Combine(this.TextureFolder, textureFilename);
                    using (var s = this.FileCreator(texturePath))
                    {
                        // create bitmap file for the brush
                        if (this.TextureExtension == ".jpg")
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize, this.TextureQualityLevel);
                        }
                        else
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize);
                        }
                    }

                    materialWriter.WriteLine(string.Format("map_Kd {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (sm != null)
            {
                var scb = sm.Brush as SolidColorBrush;
                materialWriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(scb != null ? scb.Color : Color.FromScRgb(1.0f, 0.2f, 0.2f, 0.2f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                materialWriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", sm.SpecularPower));
            }

            // roughness
            materialWriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            materialWriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            materialWriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            materialWriter.WriteLine("illum {0}", illum);
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color color)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:F4} {1:F4} {2:F4}", color.R / 255.0, color.G / 255.0, color.B / 255.0);
        }

        /// <summary>
        /// Represents the stream writers for the <see cref="ObjExporter"/>.
        /// </summary>
        public class ObjWriters
        {
            /// <summary>
            /// Gets or sets the object file writer.
            /// </summary>
            public StreamWriter ObjWriter { get; set; }

            /// <summary>
            /// Gets or sets the material file writer.
            /// </summary>
            public StreamWriter MaterialsWriter { get; set; }
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Export the 3D visual tree to a Wavefront OBJ file
    /// </summary>
    /// <remarks>
    /// http://en.wikipedia.org/wiki/Obj
    /// http://www.martinreddy.net/gfx/3d/OBJ.spec
    /// http://www.eg-models.de/formats/Format_Obj.html
    /// </remarks>
    public class ObjExporter : Exporter<ObjExporter.ObjWriters>
    {
        /// <summary>
        /// The exported materials.
        /// </summary>
        private readonly Dictionary<Material, string> exportedMaterials = new Dictionary<Material, string>();

        /// <summary>
        /// The group no.
        /// </summary>
        private int groupNo = 1;

        /// <summary>
        /// The mat no.
        /// </summary>
        private int matNo = 1;

        /// <summary>
        /// Normal index counter.
        /// </summary>
        private int normalIndex = 1;

        /// <summary>
        /// The object no.
        /// </summary>
        private int objectNo = 1;

        /// <summary>
        /// Texture index counter.
        /// </summary>
        private int textureIndex = 1;

        /// <summary>
        /// Vertex index counter.
        /// </summary>
        private int vertexIndex = 1;

        /// <summary>
        /// Initializes a new instance of the <see cref="ObjExporter" /> class.
        /// </summary>
        public ObjExporter()
        {
            this.TextureExtension = ".png";
            this.TextureSize = 1024;
            this.TextureQualityLevel = 90;
            this.TextureFolder = ".";

            this.SwitchYZ = false;
            this.ExportNormals = false;
            this.FileCreator = File.Create;
        }

        /// <summary>
        /// Gets or sets a value indicating whether to export normals.
        /// </summary>
        public bool ExportNormals { get; set; }

        /// <summary>
        /// Gets or sets the texture image and materials file creator.
        /// </summary>
        /// <value>A function used to create streams for texture images and material files.</value>
        public Func<string, Stream> FileCreator { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to use "d" for transparency (default is "Tr").
        /// </summary>
        public bool UseDissolveForTransparency { get; set; }

        /// <summary>
        /// Gets or sets the comment.
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Gets or sets the materials file.
        /// </summary>
        /// <value>
        /// The materials file.
        /// </value>
        public string MaterialsFile { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to switch Y and Z coordinates.
        /// </summary>
        public bool SwitchYZ { get; set; }

        /// <summary>
        /// Gets or sets the texture folder.
        /// </summary>
        public string TextureFolder { get; set; }

        /// <summary>
        /// Gets or sets the texture extension (.png or .jpg).
        /// </summary>
        /// <value>
        /// The default value is ".png".
        /// </value>
        public string TextureExtension { get; set; }

        /// <summary>
        /// Gets or sets the texture size.
        /// </summary>
        /// <value>
        /// The default value is 1024.
        /// </value>
        public int TextureSize { get; set; }

        /// <summary>
        /// Gets or sets the texture quality level (for JPEG encoding).
        /// </summary>
        /// <value>
        /// The quality level of the JPEG image. The value range is 1 (lowest quality) to 100 (highest quality) inclusive. 
        /// The default value is 90.
        /// </value>
        public int TextureQualityLevel { get; set; }

        /// <summary>
        /// Exports the mesh.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="m">The mesh geometry.</param>
        /// <param name="t">The transform.</param>
        public void ExportMesh(StreamWriter writer, MeshGeometry3D m, Transform3D t)
        {
            if (m == null)
            {
                throw new ArgumentNullException(nameof(m));
            }

            if (t == null)
            {
                throw new ArgumentNullException(nameof(t));
            }

            // mapping from local indices (0-based) to the obj file indices (1-based)
            var vertexIndexMap = new Dictionary<int, int>();
            var textureIndexMap = new Dictionary<int, int>();
            var normalIndexMap = new Dictionary<int, int>();

            int index = 0;
            if (m.Positions != null)
            {
                foreach (var v in m.Positions)
                {
                    vertexIndexMap.Add(index++, this.vertexIndex++);
                    var p = t.Transform(v);
                    writer.WriteLine(
                        string.Format(
                            CultureInfo.InvariantCulture,
                            "v {0} {1} {2}",
                            p.X,
                            this.SwitchYZ ? p.Z : p.Y,
                            this.SwitchYZ ? -p.Y : p.Z));
                }

                writer.WriteLine(string.Format("# {0} vertices", index));
            }

            if (m.TextureCoordinates != null)
            {
                index = 0;
                foreach (var vt in m.TextureCoordinates)
                {
                    textureIndexMap.Add(index++, this.textureIndex++);
                    writer.WriteLine(string.Format(CultureInfo.InvariantCulture, "vt {0} {1}", vt.X, 1 - vt.Y));
                }

                writer.WriteLine(string.Format("# {0} texture coordinates", index));
            }

            if (m.Normals != null && ExportNormals)
            {
                index = 0;
                foreach (var vn in m.Normals)
                {
                    normalIndexMap.Add(index++, this.normalIndex++);
                    writer.WriteLine(
                        string.Format(CultureInfo.InvariantCulture, "vn {0} {1} {2}", vn.X, this.SwitchYZ ? vn.Z : vn.Y, this.SwitchYZ ? -vn.Y : vn.Z));
                }

                writer.WriteLine(string.Format("# {0} normals", index));
            }

            Func<int, string> formatIndices = i0 =>
                {
                    bool hasTextureIndex = textureIndexMap.ContainsKey(i0);
                    bool hasNormalIndex = normalIndexMap.ContainsKey(i0);
                    if (hasTextureIndex && hasNormalIndex)
                    {
                        return string.Format("{0}/{1}/{2}", vertexIndexMap[i0], textureIndexMap[i0], normalIndexMap[i0]);
                    }

                    if (hasTextureIndex)
                    {
                        return string.Format("{0}/{1}", vertexIndexMap[i0], textureIndexMap[i0]);
                    }

                    if (hasNormalIndex)
                    {
                        return string.Format("{0}//{1}", vertexIndexMap[i0], normalIndexMap[i0]);
                    }

                    return vertexIndexMap[i0].ToString();
                };

            if (m.TriangleIndices != null)
            {
                for (int i = 0; i < m.TriangleIndices.Count; i += 3)
                {
                    int i0 = m.TriangleIndices[i];
                    int i1 = m.TriangleIndices[i + 1];
                    int i2 = m.TriangleIndices[i + 2];

                    writer.WriteLine("f {0} {1} {2}", formatIndices(i0), formatIndices(i1), formatIndices(i2));
                }

                writer.WriteLine(string.Format("# {0} faces", m.TriangleIndices.Count / 3));
            }

            writer.WriteLine();
        }

        /// <summary>
        /// Creates the specified stream.
        /// </summary>
        /// <param name="stream">The stream.</param>
        /// <returns>StreamWriter.</returns>
        protected override ObjWriters Create(Stream stream)
        {
            if (this.MaterialsFile == null)
            {
                throw new InvalidOperationException("The `MaterialsFile` property must be set.");
            }

            var writer = new StreamWriter(stream);

            if (!string.IsNullOrEmpty(this.Comment))
            {
                writer.WriteLine("# {0}", this.Comment);
            }

            writer.WriteLine("mtllib ./" + this.MaterialsFile);

            var materialStream = this.FileCreator(this.MaterialsFile);
            var materialWriter = new StreamWriter(materialStream);

            return new ObjWriters { ObjWriter = writer, MaterialsWriter = materialWriter };
        }

        /// <summary>
        /// Closes the specified writer.
        /// </summary>
        /// <param name="writer">The writer.</param>
        protected override void Close(ObjWriters writer)
        {
            writer.ObjWriter.Close();
            writer.MaterialsWriter.Close();
        }

        /// <summary>
        /// The export model.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        protected override void ExportModel(ObjWriters writer, GeometryModel3D model, Transform3D transform)
        {
            writer.ObjWriter.WriteLine("o object{0}", this.objectNo++);
            writer.ObjWriter.WriteLine("g group{0}", this.groupNo++);

            if (this.exportedMaterials.ContainsKey(model.Material))
            {
                string matName = this.exportedMaterials[model.Material];
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
            }
            else
            {
                string matName = string.Format("mat{0}", this.matNo++);
                writer.ObjWriter.WriteLine("usemtl {0}", matName);
                this.ExportMaterial(writer.MaterialsWriter, matName, model.Material, model.BackMaterial);
                this.exportedMaterials.Add(model.Material, matName);
            }

            var mesh = model.Geometry as MeshGeometry3D;
            this.ExportMesh(writer.ObjWriter, mesh, Transform3DHelper.CombineTransform(transform, model.Transform));
        }

        /// <summary>
        /// The export material.
        /// </summary>
        /// <param name="materialWriter">The material writer.</param>
        /// <param name="matName">The mat name.</param>
        /// <param name="material">The material.</param>
        /// <param name="backMaterial">The back material.</param>
        private void ExportMaterial(StreamWriter materialWriter, string matName, Material material, Material backMaterial)
        {
            materialWriter.WriteLine("newmtl {0}", matName);

            if (material is MaterialGroup mg)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }

                    if (m is SpecularMaterial)
                    {
                        sm = m as SpecularMaterial;
                    }
                }
            }

            if (material is DiffuseMaterial dm)
            {
                var adjustedAmbientColor = dm.AmbientColor.ChangeIntensity(0.2);

                // materialWriter.WriteLine(string.Format("Ka {0}", this.ToColorString(adjustedAmbientColor)));
                if (dm.Brush is SolidColorBrush scb)
                {
                    materialWriter.WriteLine(string.Format("Kd {0}", this.ToColorString(scb.Color)));

                    if (this.UseDissolveForTransparency)
                    {
                        // Dissolve factor
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "d {0:F4}", scb.Color.A / 255.0));
                    }
                    else
                    {
                        // Transparency
                        materialWriter.WriteLine(
                            string.Format(CultureInfo.InvariantCulture, "Tr {0:F4}", scb.Color.A / 255.0));
                    }
                }
                else
                {
                    var textureFilename = matName + this.TextureExtension;
                    var texturePath = Path.Combine(this.TextureFolder, textureFilename);
                    using (var s = this.FileCreator(texturePath))
                    {
                        // create bitmap file for the brush
                        if (this.TextureExtension == ".jpg")
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize, this.TextureQualityLevel);
                        }
                        else
                        {
                            this.RenderBrush(s, dm.Brush, this.TextureSize, this.TextureSize);
                        }
                    }

                    materialWriter.WriteLine(string.Format("map_Kd {0}", textureFilename));
                }
            }

            // Illumination model 1
            // This is a diffuse illumination model using Lambertian shading. The
            // color includes an ambient constant term and a diffuse shading term for
            // each light source.  The formula is
            // color = KaIa + Kd { SUM j=1..ls, (N * Lj)Ij }
            int illum = 1; // Lambertian

            if (material is SpecularMaterial sm)
            {
                materialWriter.WriteLine(
                    string.Format(
                        "Ks {0}", this.ToColorString(dm.Brush is SolidColorBrush scb ? scb.Color : Color.FromScRgb(1.0f, 0.2f, 0.2f, 0.2f))));

                // Illumination model 2
                // This is a diffuse and specular illumination model using Lambertian
                // shading and Blinn's interpretation of Phong's specular illumination
                // model (BLIN77).  The color includes an ambient constant term, and a
                // diffuse and specular shading term for each light source.  The formula
                // is: color = KaIa + Kd { SUM j=1..ls, (N*Lj)Ij } + Ks { SUM j=1..ls, ((H*Hj)^Ns)Ij }
                illum = 2;

                // Specifies the specular exponent for the current material.  This defines the focus of the specular highlight.
                // "exponent" is the value for the specular exponent.  A high exponent results in a tight, concentrated highlight.  Ns values normally range from 0 to 1000.
                materialWriter.WriteLine(string.Format(CultureInfo.InvariantCulture, "Ns {0:F4}", sm.SpecularPower));
            }

            // roughness
            materialWriter.WriteLine(string.Format("Ns {0}", 2));

            // Optical density (index of refraction)
            materialWriter.WriteLine(string.Format("Ni {0}", 1));

            // Transmission filter
            materialWriter.WriteLine(string.Format("Tf {0} {1} {2}", 1, 1, 1));

            // Illumination model
            // Illumination    Properties that are turned on in the
            // model           Property Editor
            // 0		Color on and Ambient off
            // 1		Color on and Ambient on
            // 2		Highlight on
            // 3		Reflection on and Ray trace on
            // 4		Transparency: Glass on
            // Reflection: Ray trace on
            // 5		Reflection: Fresnel on and Ray trace on
            // 6		Transparency: Refraction on
            // Reflection: Fresnel off and Ray trace on
            // 7		Transparency: Refraction on
            // Reflection: Fresnel on and Ray trace on
            // 8		Reflection on and Ray trace off
            // 9		Transparency: Glass on
            // Reflection: Ray trace off
            // 10		Casts shadows onto invisible surfaces
            materialWriter.WriteLine("illum {0}", illum);
        }

        /// <summary>
        /// Converts a color to a string.
        /// </summary>
        /// <param name="color">
        /// The color.
        /// </param>
        /// <returns>
        /// The string.
        /// </returns>
        private string ToColorString(Color color)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:F4} {1:F4} {2:F4}", color.R / 255.0, color.G / 255.0, color.B / 255.0);
        }

        /// <summary>
        /// Represents the stream writers for the <see cref="ObjExporter"/>.
        /// </summary>
        public class ObjWriters
        {
            /// <summary>
            /// Gets or sets the object file writer.
            /// </summary>
            public StreamWriter ObjWriter { get; set; }

            /// <summary>
            /// Gets or sets the material file writer.
            /// </summary>
            public StreamWriter MaterialsWriter { get; set; }
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(331,25): error CS0841: Cannot use local variable 'dm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(336,25): error CS0841: Cannot use local variable 'sm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\ObjExporter.cs(395,54): error CS0165: Use of unassigned local variable 'dm'
######################################################################


######################################################################
Nr: 16 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Windows.Controls;

namespace HelixToolkit.Wpf
{
    using System.IO;
    using System.Text;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Exports the 3D visual tree to a STereoLithography binary file.
    /// </summary>
    public class StlExporter : Exporter<BinaryWriter>
    {
        /// <summary>
        /// Creates a <see cref="BinaryWriter"/> used to write the StlFile
        /// </summary>
        /// <param name="stream">The output stream where the STL is written.</param>
        /// <returns>The created <see cref="BinaryWriter"/></returns>
        protected override BinaryWriter Create(Stream stream)
        {
            return new BinaryWriter(stream);
        }

        /// <summary>
        /// Closes a <see cref="BinaryWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to close</param>
        protected override void Close(BinaryWriter writer)
        {
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="viewport">The viewport to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Viewport3D viewport, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            viewport.Children.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);
            
            ExportHeader(writer, triangleIndicesCount / 3);
            viewport.Children.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        /// <summary>
        /// Exports specified <see cref="Visual3D"/>
        /// </summary>
        /// <param name="visual">The <see cref="Visual3D"/> to export.</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Visual3D visual, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            visual.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            visual.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }
        
        /// <summary>
        /// Exports specified <see cref="Model3D"/>.
        /// </summary>
        /// <param name="model">The <see cref="Model3D"/> to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Model3D model, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            model.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            model.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        private void ExportHeader(BinaryWriter writer, int triangleCount)
        {
            ExportHeader(writer);
            writer.Write(triangleCount);
        }

        /// <summary>
        /// Writes an empty STL header.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        protected override void ExportHeader(BinaryWriter writer)
        {
            writer.Write(new byte[80]);
        }

        /// <summary>
        /// Writes a <see cref="GeometryModel3D"/> to a <see cref="BinaryWriter"/> in STL binary format.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        /// <param name="model">The model to write.</param>
        /// <param name="t">All vertices are transformed with this transform before written</param>
        protected override void ExportModel(BinaryWriter writer, GeometryModel3D model, Transform3D t)
        {
            var mesh = (MeshGeometry3D) model.Geometry;

            var normals = mesh.Normals;
            if (normals == null || normals.Count != mesh.Positions.Count)
            {
                normals = MeshGeometryHelper.CalculateNormals(mesh);
            }

            // TODO: Also handle non-uniform scale
            var matrix = t.Clone().Value;
            matrix.OffsetX = 0;
            matrix.OffsetY = 0;
            matrix.OffsetZ = 0;
            var normalTransform = new MatrixTransform3D(matrix);

            var material = model.Material;
            var dm = material as DiffuseMaterial;

            var mg = material as MaterialGroup;
            if (mg != null)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }
                }
            }

            ushort attribute = 0;

            if (dm != null)
            {
                var scb = dm.Brush as SolidColorBrush;
                if (scb != null)
                {
                    byte r = scb.Color.R;
                    byte g = scb.Color.G;
                    byte b = scb.Color.B;
                    attribute = (ushort)((1 << 15) | ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3));
                }
            }

            for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)
            {
                int i0 = mesh.TriangleIndices[i + 0];
                int i1 = mesh.TriangleIndices[i + 1];
                int i2 = mesh.TriangleIndices[i + 2];

                // Normal
                var faceNormal = normalTransform.Transform(normals[i0] + normals[i1] + normals[i2]);
                faceNormal.Normalize();
                WriteVector(writer, faceNormal);

                // Vertices
                WriteVertex(writer, t.Transform(mesh.Positions[i0]));
                WriteVertex(writer, t.Transform(mesh.Positions[i1]));
                WriteVertex(writer, t.Transform(mesh.Positions[i2]));

                // Attributes
                writer.Write(attribute);
            }
        }

        private static void WriteVector(BinaryWriter writer, Vector3D normal)
        {
            writer.Write((float)normal.X);
            writer.Write((float)normal.Y);
            writer.Write((float)normal.Z);
        }

        private static void WriteVertex(BinaryWriter writer, Point3D p)
        {
            writer.Write((float)p.X);
            writer.Write((float)p.Y);
            writer.Write((float)p.Z);
        }
    }
}

---- Transformed Tree ----
using System.Windows.Controls;

namespace HelixToolkit.Wpf
{
    using System.IO;
    using System.Text;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Exports the 3D visual tree to a STereoLithography binary file.
    /// </summary>
    public class StlExporter : Exporter<BinaryWriter>
    {
        /// <summary>
        /// Creates a <see cref="BinaryWriter"/> used to write the StlFile
        /// </summary>
        /// <param name="stream">The output stream where the STL is written.</param>
        /// <returns>The created <see cref="BinaryWriter"/></returns>
        protected override BinaryWriter Create(Stream stream)
        {
            return new BinaryWriter(stream);
        }

        /// <summary>
        /// Closes a <see cref="BinaryWriter"/>.
        /// </summary>
        /// <param name="writer">The writer to close</param>
        protected override void Close(BinaryWriter writer)
        {
        }

        /// <summary>
        /// Exports the specified viewport.
        /// </summary>
        /// <param name="viewport">The viewport to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Viewport3D viewport, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            viewport.Children.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);
            
            ExportHeader(writer, triangleIndicesCount / 3);
            viewport.Children.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        /// <summary>
        /// Exports specified <see cref="Visual3D"/>
        /// </summary>
        /// <param name="visual">The <see cref="Visual3D"/> to export.</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Visual3D visual, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            visual.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            visual.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }
        
        /// <summary>
        /// Exports specified <see cref="Model3D"/>.
        /// </summary>
        /// <param name="model">The <see cref="Model3D"/> to export</param>
        /// <param name="stream">The output stream to export to</param>
        public override void Export(Model3D model, Stream stream)
        {
            var writer = Create(stream);

            int triangleIndicesCount = 0;
            model.Traverse<GeometryModel3D>((m, t) => triangleIndicesCount += ((MeshGeometry3D)m.Geometry).TriangleIndices.Count);

            ExportHeader(writer, triangleIndicesCount / 3);
            model.Traverse<GeometryModel3D>((m, t) => ExportModel(writer, m, t));

            Close(writer);
        }

        private void ExportHeader(BinaryWriter writer, int triangleCount)
        {
            ExportHeader(writer);
            writer.Write(triangleCount);
        }

        /// <summary>
        /// Writes an empty STL header.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        protected override void ExportHeader(BinaryWriter writer)
        {
            writer.Write(new byte[80]);
        }

        /// <summary>
        /// Writes a <see cref="GeometryModel3D"/> to a <see cref="BinaryWriter"/> in STL binary format.
        /// </summary>
        /// <param name="writer">The <see cref="BinaryWriter"/> to write to.</param>
        /// <param name="model">The model to write.</param>
        /// <param name="t">All vertices are transformed with this transform before written</param>
        protected override void ExportModel(BinaryWriter writer, GeometryModel3D model, Transform3D t)
        {
            var mesh = (MeshGeometry3D) model.Geometry;

            var normals = mesh.Normals;
            if (normals == null || normals.Count != mesh.Positions.Count)
            {
                normals = MeshGeometryHelper.CalculateNormals(mesh);
            }

            // TODO: Also handle non-uniform scale
            var matrix = t.Clone().Value;
            matrix.OffsetX = 0;
            matrix.OffsetY = 0;
            matrix.OffsetZ = 0;
            var normalTransform = new MatrixTransform3D(matrix);

            var material = model.Material;

            if (material is MaterialGroup mg)
            {
                foreach (var m in mg.Children)
                {
                    if (m is DiffuseMaterial)
                    {
                        dm = m as DiffuseMaterial;
                    }
                }
            }

            ushort attribute = 0;

            if (material is DiffuseMaterial dm)
            {
                if (dm.Brush is SolidColorBrush scb)
                {
                    byte r = scb.Color.R;
                    byte g = scb.Color.G;
                    byte b = scb.Color.B;
                    attribute = (ushort)((1 << 15) | ((r >> 3) << 10) | ((g >> 3) << 5) | (b >> 3));
                }
            }

            for (int i = 0; i < mesh.TriangleIndices.Count; i += 3)
            {
                int i0 = mesh.TriangleIndices[i + 0];
                int i1 = mesh.TriangleIndices[i + 1];
                int i2 = mesh.TriangleIndices[i + 2];

                // Normal
                var faceNormal = normalTransform.Transform(normals[i0] + normals[i1] + normals[i2]);
                faceNormal.Normalize();
                WriteVector(writer, faceNormal);

                // Vertices
                WriteVertex(writer, t.Transform(mesh.Positions[i0]));
                WriteVertex(writer, t.Transform(mesh.Positions[i1]));
                WriteVertex(writer, t.Transform(mesh.Positions[i2]));

                // Attributes
                writer.Write(attribute);
            }
        }

        private static void WriteVector(BinaryWriter writer, Vector3D normal)
        {
            writer.Write((float)normal.X);
            writer.Write((float)normal.Y);
            writer.Write((float)normal.Z);
        }

        private static void WriteVertex(BinaryWriter writer, Point3D p)
        {
            writer.Write((float)p.X);
            writer.Write((float)p.Y);
            writer.Write((float)p.Z);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(15,5): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(142,25): error CS0841: Cannot use local variable 'dm' before it is declared,D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Exporters\StlExporter.cs(15,5): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 17 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\CuttingPlaneGroup.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Defines the cutting operation.
    /// </summary>
    public enum CuttingOperation
    {
        /// <summary>
        /// The intersect operation.
        /// </summary>
        Intersect,

        /// <summary>
        /// The subtract operation.
        /// </summary>
        Subtract,
    }

    /// <summary>
    /// A visual element that applies the intersection of all the specified cutting planes to all children.
    /// </summary>
    public class CuttingPlaneGroup : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="IsEnabled"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.Register(
            "IsEnabled", typeof(bool), typeof(CuttingPlaneGroup), new UIPropertyMetadata(false, IsEnabledChanged));

        /// <summary>
        /// Identifies the <see cref="Operation"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty OperationProperty =
            DependencyProperty.Register("Operation", typeof(CuttingOperation), typeof(CuttingPlaneGroup), new PropertyMetadata(CuttingOperation.Intersect, OperationChanged));

        /// <summary>
        /// The cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> cutGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// The new cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newCutGeometries;

        /// <summary>
        /// The new original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newOriginalGeometries;

        /// <summary>
        /// The original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> originalGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// Initializes a new instance of the <see cref = "CuttingPlaneGroup" /> class.
        /// </summary>
        public CuttingPlaneGroup()
        {
            this.IsEnabled = true;
            this.CuttingPlanes = new List<Plane3D>();
        }

        /// <summary>
        /// Gets or sets the cutting planes.
        /// </summary>
        /// <value>
        /// The cutting planes.
        /// </value>
        /// <remarks>
        /// The the intersection of all the cutting planes will be used to
        /// intersect/subtract (defined in <see cref="Operation" /> all child visuals of the <see cref="CuttingPlaneGroup" />.
        /// </remarks>
        public List<Plane3D> CuttingPlanes { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether cutting is enabled.
        /// </summary>
        public bool IsEnabled
        {
            get
            {
                return (bool)this.GetValue(IsEnabledProperty);
            }

            set
            {
                this.SetValue(IsEnabledProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the cutting operation.
        /// </summary>
        /// <value>The operation.</value>
        public CuttingOperation Operation
        {
            get { return (CuttingOperation)this.GetValue(OperationProperty); }
            set { this.SetValue(OperationProperty, value); }
        }

        /// <summary>
        /// Called when the composition target rendering event is raised.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="RenderingEventArgs"/> instance containing the event data.</param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            // TODO: Find a better way to handle this...
            if (this.IsEnabled)
            {
                this.ApplyCuttingGeometries();
            }
        }

        /// <summary>
        /// Handles changes to the <see cref="IsEnabled" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void IsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var g = (CuttingPlaneGroup)d;

            if (g.IsEnabled)
            {
                g.SubscribeToRenderingEvent();
            }
            else
            {
                g.UnsubscribeRenderingEvent();
            }

            g.ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Handles changes to the <see cref="Operation" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void OperationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((CuttingPlaneGroup)d).ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Applies the cutting planes.
        /// </summary>
        /// <param name="forceUpdate">Force the geometries to be updated if set to <c>true</c>.</param>
        private void ApplyCuttingGeometries(bool forceUpdate = false)
        {
            lock (this)
            {
                this.newCutGeometries = new Dictionary<Model3D, Geometry3D>();
                this.newOriginalGeometries = new Dictionary<Model3D, Geometry3D>();
                this.Children.Traverse<GeometryModel3D>((m, t) => this.ApplyCuttingPlanesToModel(m, t, forceUpdate));
                this.cutGeometries = this.newCutGeometries;
                this.originalGeometries = this.newOriginalGeometries;
            }
        }

        /// <summary>
        /// Applies the cutting planes to the model.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        /// <param name="updateRequired">An update is required if set to <c>true</c>.</param>
        /// <exception cref="System.InvalidOperationException">No inverse transform.</exception>
        /// <exception cref="System.NotImplementedException"></exception>
        private void ApplyCuttingPlanesToModel(GeometryModel3D model, Transform3D transform, bool updateRequired)
        {
            if (model.Geometry == null)
            {
                return;
            }

            if (!this.IsEnabled)
            {
                updateRequired = true;
            }

            Geometry3D cutGeometry;
            if (this.cutGeometries.TryGetValue(model, out cutGeometry))
            {
                // ReSharper disable once RedundantNameQualifier
                if (object.ReferenceEquals(cutGeometry, model.Geometry))
                {
                    updateRequired = true;
                }
            }

            Geometry3D originalGeometry;
            if (!this.originalGeometries.TryGetValue(model, out originalGeometry))
            {
                originalGeometry = model.Geometry;
                updateRequired = true;
            }

            this.newOriginalGeometries.Add(model, originalGeometry);

            if (!updateRequired)
            {
                return;
            }

            var newGeometry = originalGeometry;
            var originalMeshGeometry = originalGeometry as MeshGeometry3D;

            if (this.IsEnabled && originalMeshGeometry != null)
            {
                var inverseTransform = transform.Inverse;
                if (inverseTransform == null)
                {
                    throw new InvalidOperationException("No inverse transform.");
                }

                switch (this.Operation)
                {
                    case CuttingOperation.Intersect:

                        var intersectedGeometry = originalMeshGeometry;

                        // Calculate the intersection of all the intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            intersectedGeometry = this.Intersect(intersectedGeometry, inverseTransform, cp, false);
                        }

                        newGeometry = intersectedGeometry;
                        break;
                    case CuttingOperation.Subtract:
                        var builder = new MeshBuilder(originalMeshGeometry.Normals.Any(), originalMeshGeometry.TextureCoordinates.Any());

                        // Calculate the union of all complement intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            var cg = this.Intersect(originalMeshGeometry, inverseTransform, cp, true);
                            builder.Append(cg);
                        }

                        newGeometry = builder.ToMesh(true);
                        break;
                }
            }

            model.Geometry = newGeometry;
            this.newCutGeometries.Add(model, originalMeshGeometry);
        }

        /// <summary>
        /// Intersects the specified source mesh geometry with the specified plane.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <param name="inverseTransform">The inverse transform of the source.</param>
        /// <param name="plane">The plane.</param>
        /// <param name="complement">Cut with the complement set if set to <c>true</c>.</param>
        /// <returns>The intersected geometry.</returns>
        private MeshGeometry3D Intersect(MeshGeometry3D source, GeneralTransform3D inverseTransform, Plane3D plane, bool complement)
        {
            var p = inverseTransform.Transform(plane.Position);
            var p2 = inverseTransform.Transform(plane.Position + plane.Normal);
            var n = p2 - p;

            if (complement)
            {
                n *= -1;
            }

            return MeshGeometryHelper.Cut(source, p, n);
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// Defines the cutting operation.
    /// </summary>
    public enum CuttingOperation
    {
        /// <summary>
        /// The intersect operation.
        /// </summary>
        Intersect,

        /// <summary>
        /// The subtract operation.
        /// </summary>
        Subtract,
    }

    /// <summary>
    /// A visual element that applies the intersection of all the specified cutting planes to all children.
    /// </summary>
    public class CuttingPlaneGroup : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="IsEnabled"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty IsEnabledProperty = DependencyProperty.Register(
            "IsEnabled", typeof(bool), typeof(CuttingPlaneGroup), new UIPropertyMetadata(false, IsEnabledChanged));

        /// <summary>
        /// Identifies the <see cref="Operation"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty OperationProperty =
            DependencyProperty.Register("Operation", typeof(CuttingOperation), typeof(CuttingPlaneGroup), new PropertyMetadata(CuttingOperation.Intersect, OperationChanged));

        /// <summary>
        /// The cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> cutGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// The new cut geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newCutGeometries;

        /// <summary>
        /// The new original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> newOriginalGeometries;

        /// <summary>
        /// The original geometries.
        /// </summary>
        private Dictionary<Model3D, Geometry3D> originalGeometries = new Dictionary<Model3D, Geometry3D>();

        /// <summary>
        /// Initializes a new instance of the <see cref = "CuttingPlaneGroup" /> class.
        /// </summary>
        public CuttingPlaneGroup()
        {
            this.IsEnabled = true;
            this.CuttingPlanes = new List<Plane3D>();
        }

        /// <summary>
        /// Gets or sets the cutting planes.
        /// </summary>
        /// <value>
        /// The cutting planes.
        /// </value>
        /// <remarks>
        /// The the intersection of all the cutting planes will be used to
        /// intersect/subtract (defined in <see cref="Operation" /> all child visuals of the <see cref="CuttingPlaneGroup" />.
        /// </remarks>
        public List<Plane3D> CuttingPlanes { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether cutting is enabled.
        /// </summary>
        public bool IsEnabled
        {
            get
            {
                return (bool)this.GetValue(IsEnabledProperty);
            }

            set
            {
                this.SetValue(IsEnabledProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the cutting operation.
        /// </summary>
        /// <value>The operation.</value>
        public CuttingOperation Operation
        {
            get { return (CuttingOperation)this.GetValue(OperationProperty); }
            set { this.SetValue(OperationProperty, value); }
        }

        /// <summary>
        /// Called when the composition target rendering event is raised.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="RenderingEventArgs"/> instance containing the event data.</param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            // TODO: Find a better way to handle this...
            if (this.IsEnabled)
            {
                this.ApplyCuttingGeometries();
            }
        }

        /// <summary>
        /// Handles changes to the <see cref="IsEnabled" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void IsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var g = (CuttingPlaneGroup)d;

            if (g.IsEnabled)
            {
                g.SubscribeToRenderingEvent();
            }
            else
            {
                g.UnsubscribeRenderingEvent();
            }

            g.ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Handles changes to the <see cref="Operation" /> property.
        /// </summary>
        /// <param name="d">The sender.</param>
        /// <param name="e">The <see cref="DependencyPropertyChangedEventArgs" /> instance containing the event data.</param>
        private static void OperationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            ((CuttingPlaneGroup)d).ApplyCuttingGeometries(true);
        }

        /// <summary>
        /// Applies the cutting planes.
        /// </summary>
        /// <param name="forceUpdate">Force the geometries to be updated if set to <c>true</c>.</param>
        private void ApplyCuttingGeometries(bool forceUpdate = false)
        {
            lock (this)
            {
                this.newCutGeometries = new Dictionary<Model3D, Geometry3D>();
                this.newOriginalGeometries = new Dictionary<Model3D, Geometry3D>();
                this.Children.Traverse<GeometryModel3D>((m, t) => this.ApplyCuttingPlanesToModel(m, t, forceUpdate));
                this.cutGeometries = this.newCutGeometries;
                this.originalGeometries = this.newOriginalGeometries;
            }
        }

        /// <summary>
        /// Applies the cutting planes to the model.
        /// </summary>
        /// <param name="model">The model.</param>
        /// <param name="transform">The transform.</param>
        /// <param name="updateRequired">An update is required if set to <c>true</c>.</param>
        /// <exception cref="System.InvalidOperationException">No inverse transform.</exception>
        /// <exception cref="System.NotImplementedException"></exception>
        private void ApplyCuttingPlanesToModel(GeometryModel3D model, Transform3D transform, bool updateRequired)
        {
            if (model.Geometry == null)
            {
                return;
            }

            if (!this.IsEnabled)
            {
                updateRequired = true;
            }

            Geometry3D cutGeometry;
            if (this.cutGeometries.TryGetValue(model, out cutGeometry))
            {
                // ReSharper disable once RedundantNameQualifier
                if (object.ReferenceEquals(cutGeometry, model.Geometry))
                {
                    updateRequired = true;
                }
            }

            Geometry3D originalGeometry;
            if (!this.originalGeometries.TryGetValue(model, out originalGeometry))
            {
                originalGeometry = model.Geometry;
                updateRequired = true;
            }

            this.newOriginalGeometries.Add(model, originalGeometry);

            if (!updateRequired)
            {
                return;
            }

            var newGeometry = originalGeometry;

            if (this.IsEnabled && originalGeometry is MeshGeometry3D originalMeshGeometry)
            {
                var inverseTransform = transform.Inverse;
                if (inverseTransform == null)
                {
                    throw new InvalidOperationException("No inverse transform.");
                }

                switch (this.Operation)
                {
                    case CuttingOperation.Intersect:

                        var intersectedGeometry = originalMeshGeometry;

                        // Calculate the intersection of all the intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            intersectedGeometry = this.Intersect(intersectedGeometry, inverseTransform, cp, false);
                        }

                        newGeometry = intersectedGeometry;
                        break;
                    case CuttingOperation.Subtract:
                        var builder = new MeshBuilder(originalMeshGeometry.Normals.Any(), originalMeshGeometry.TextureCoordinates.Any());

                        // Calculate the union of all complement intersections
                        foreach (var cp in this.CuttingPlanes)
                        {
                            var cg = this.Intersect(originalMeshGeometry, inverseTransform, cp, true);
                            builder.Append(cg);
                        }

                        newGeometry = builder.ToMesh(true);
                        break;
                }
            }

            model.Geometry = newGeometry;
            this.newCutGeometries.Add(model, originalMeshGeometry);
        }

        /// <summary>
        /// Intersects the specified source mesh geometry with the specified plane.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <param name="inverseTransform">The inverse transform of the source.</param>
        /// <param name="plane">The plane.</param>
        /// <param name="complement">Cut with the complement set if set to <c>true</c>.</param>
        /// <returns>The intersected geometry.</returns>
        private MeshGeometry3D Intersect(MeshGeometry3D source, GeneralTransform3D inverseTransform, Plane3D plane, bool complement)
        {
            var p = inverseTransform.Transform(plane.Position);
            var p2 = inverseTransform.Transform(plane.Position + plane.Normal);
            var n = p2 - p;

            if (complement)
            {
                n *= -1;
            }

            return MeshGeometryHelper.Cut(source, p, n);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\Composite\CuttingPlaneGroup.cs(264,46): error CS0165: Use of unassigned local variable 'originalMeshGeometry'
######################################################################


######################################################################
Nr: 18 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// An abstract base class for visuals that use screen space dimensions when rendering.
    /// </summary>
    public abstract class ScreenSpaceVisual3D : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="Color"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ColorProperty = DependencyProperty.Register(
            "Color", typeof(Color), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(Colors.Black, ColorChanged));

        /// <summary>
        /// Identifies the <see cref="DepthOffset"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty DepthOffsetProperty = DependencyProperty.Register(
            "DepthOffset", typeof(double), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(0.0, GeometryChanged));

        /// <summary>
        /// Identifies the <see cref="Points"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty PointsProperty = DependencyProperty.Register(
            "Points", typeof(Point3DCollection), typeof(ScreenSpaceVisual3D), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure, PointsChanged));

        /// <summary>
        /// The is rendering flag.
        /// </summary>
        private bool isRendering;

        /// <summary>
        /// The listening to collection
        /// </summary>
        private Point3DCollection collectionBeingListenedTo;

        /// <summary>
        /// Initializes a new instance of the <see cref = "ScreenSpaceVisual3D" /> class.
        /// </summary>
        protected ScreenSpaceVisual3D()
        {
            this.Mesh = new MeshGeometry3D();
            this.Model = new GeometryModel3D { Geometry = this.Mesh };
            this.Content = this.Model;
            this.Points = new Point3DCollection();
            this.ColorChanged();
        }

        /// <summary>
        /// Gets or sets the color.
        /// </summary>
        /// <value>
        /// The color.
        /// </value>
        public Color Color
        {
            get
            {
                return (Color)this.GetValue(ColorProperty);
            }

            set
            {
                this.SetValue(ColorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the depth offset.
        /// A small positive number (0.0001) will move the visual slightly in front of other objects.
        /// </summary>
        /// <value>
        /// The depth offset.
        /// </value>
        public double DepthOffset
        {
            get
            {
                return (double)this.GetValue(DepthOffsetProperty);
            }

            set
            {
                this.SetValue(DepthOffsetProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance is being rendered.
        /// When the visual is removed from the visual tree, this property should be set to false.
        /// </summary>
        public bool IsRendering
        {
            get
            {
                return this.isRendering;
            }

            set
            {
                if (value != this.isRendering)
                {
                    this.isRendering = value;
                    if (this.isRendering)
                    {
                        this.SubscribeToRenderingEvent();
                    }
                    else
                    {
                        this.UnsubscribeRenderingEvent();
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the points collection.
        /// </summary>
        /// <value>
        /// The points collection.
        /// </value>
        public Point3DCollection Points
        {
            get
            {
                return (Point3DCollection)this.GetValue(PointsProperty);
            }

            set
            {
                this.SetValue(PointsProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the clipping object.
        /// </summary>
        protected CohenSutherlandClipping Clipping { get; set; }

        /// <summary>
        /// Gets or sets the mesh.
        /// </summary>
        protected MeshGeometry3D Mesh { get; set; }

        /// <summary>
        /// Gets or sets the model.
        /// </summary>
        protected GeometryModel3D Model { get; set; }

        /// <summary>
        /// Called when geometry properties have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        protected static void GeometryChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).UpdateGeometry();
        }

        /// <summary>
        /// Called when points have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void PointsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            var screenSpaceVisual3D = (ScreenSpaceVisual3D)sender;
            screenSpaceVisual3D.UpdateGeometry();

            if (screenSpaceVisual3D.collectionBeingListenedTo != null && !screenSpaceVisual3D.collectionBeingListenedTo.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo.Changed -= screenSpaceVisual3D.HandlePointsChanged;
            }

            var pc = e.NewValue as Point3DCollection;
            if (pc != null && !pc.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;

                // TODO: use a weak event manager
                pc.Changed += screenSpaceVisual3D.HandlePointsChanged;
            }
            else
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;
            }
        }

        /// <summary>
        /// The composition target_ rendering.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            if (this.isRendering)
            {
                if (!Visual3DHelper.IsAttachedToViewport3D(this))
                {
                    return;
                }

                if (this.UpdateTransforms())
                {
                    this.UpdateClipping();
                    this.UpdateGeometry();
                }
            }
        }

        /// <summary>
        /// Called when the parent of the 3-D visual object is changed.
        /// </summary>
        /// <param name="oldParent">
        /// A value of type <see cref="T:System.Windows.DependencyObject"/> that represents the previous parent of the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object. If the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object did not have a previous parent, the value of the parameter is null.
        /// </param>
        protected override void OnVisualParentChanged(DependencyObject oldParent)
        {
            base.OnVisualParentChanged(oldParent);
            var parent = VisualTreeHelper.GetParent(this);
            this.IsRendering = parent != null;
        }

        /// <summary>
        /// Updates the geometry.
        /// </summary>
        protected abstract void UpdateGeometry();

        /// <summary>
        /// Updates the transforms.
        /// </summary>
        /// <returns>
        /// True if the transform is updated.
        /// </returns>
        protected abstract bool UpdateTransforms();

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void ColorChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).ColorChanged();
        }

        /// <summary>
        /// Handles changes in the <see cref="Points" /> collection.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The event arguments.</param>
        private void HandlePointsChanged(object sender, EventArgs e)
        {
            this.UpdateGeometry();
        }

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        private void ColorChanged()
        {
            var mg = new MaterialGroup();
            mg.Children.Add(new DiffuseMaterial(Brushes.Black));
            mg.Children.Add(new EmissiveMaterial(new SolidColorBrush(this.Color)));
            mg.Freeze();
            this.Model.Material = mg;
            this.Model.BackMaterial = mg;
        }

        /// <summary>
        /// Updates the clipping object.
        /// </summary>
        private void UpdateClipping()
        {
            var vp = this.GetViewport3D();
            if (vp == null)
            {
                return;
            }

            this.Clipping = new CohenSutherlandClipping(10, vp.ActualWidth - 20, 10, vp.ActualHeight - 20);
        }
    }
}
---- Transformed Tree ----
namespace HelixToolkit.Wpf
{
    using System;
    using System.Windows;
    using System.Windows.Media;
    using System.Windows.Media.Media3D;

    /// <summary>
    /// An abstract base class for visuals that use screen space dimensions when rendering.
    /// </summary>
    public abstract class ScreenSpaceVisual3D : RenderingModelVisual3D
    {
        /// <summary>
        /// Identifies the <see cref="Color"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty ColorProperty = DependencyProperty.Register(
            "Color", typeof(Color), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(Colors.Black, ColorChanged));

        /// <summary>
        /// Identifies the <see cref="DepthOffset"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty DepthOffsetProperty = DependencyProperty.Register(
            "DepthOffset", typeof(double), typeof(ScreenSpaceVisual3D), new UIPropertyMetadata(0.0, GeometryChanged));

        /// <summary>
        /// Identifies the <see cref="Points"/> dependency property.
        /// </summary>
        public static readonly DependencyProperty PointsProperty = DependencyProperty.Register(
            "Points", typeof(Point3DCollection), typeof(ScreenSpaceVisual3D), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsArrange | FrameworkPropertyMetadataOptions.AffectsMeasure, PointsChanged));

        /// <summary>
        /// The is rendering flag.
        /// </summary>
        private bool isRendering;

        /// <summary>
        /// The listening to collection
        /// </summary>
        private Point3DCollection collectionBeingListenedTo;

        /// <summary>
        /// Initializes a new instance of the <see cref = "ScreenSpaceVisual3D" /> class.
        /// </summary>
        protected ScreenSpaceVisual3D()
        {
            this.Mesh = new MeshGeometry3D();
            this.Model = new GeometryModel3D { Geometry = this.Mesh };
            this.Content = this.Model;
            this.Points = new Point3DCollection();
            this.ColorChanged();
        }

        /// <summary>
        /// Gets or sets the color.
        /// </summary>
        /// <value>
        /// The color.
        /// </value>
        public Color Color
        {
            get
            {
                return (Color)this.GetValue(ColorProperty);
            }

            set
            {
                this.SetValue(ColorProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the depth offset.
        /// A small positive number (0.0001) will move the visual slightly in front of other objects.
        /// </summary>
        /// <value>
        /// The depth offset.
        /// </value>
        public double DepthOffset
        {
            get
            {
                return (double)this.GetValue(DepthOffsetProperty);
            }

            set
            {
                this.SetValue(DepthOffsetProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets a value indicating whether this instance is being rendered.
        /// When the visual is removed from the visual tree, this property should be set to false.
        /// </summary>
        public bool IsRendering
        {
            get
            {
                return this.isRendering;
            }

            set
            {
                if (value != this.isRendering)
                {
                    this.isRendering = value;
                    if (this.isRendering)
                    {
                        this.SubscribeToRenderingEvent();
                    }
                    else
                    {
                        this.UnsubscribeRenderingEvent();
                    }
                }
            }
        }

        /// <summary>
        /// Gets or sets the points collection.
        /// </summary>
        /// <value>
        /// The points collection.
        /// </value>
        public Point3DCollection Points
        {
            get
            {
                return (Point3DCollection)this.GetValue(PointsProperty);
            }

            set
            {
                this.SetValue(PointsProperty, value);
            }
        }

        /// <summary>
        /// Gets or sets the clipping object.
        /// </summary>
        protected CohenSutherlandClipping Clipping { get; set; }

        /// <summary>
        /// Gets or sets the mesh.
        /// </summary>
        protected MeshGeometry3D Mesh { get; set; }

        /// <summary>
        /// Gets or sets the model.
        /// </summary>
        protected GeometryModel3D Model { get; set; }

        /// <summary>
        /// Called when geometry properties have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        protected static void GeometryChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).UpdateGeometry();
        }

        /// <summary>
        /// Called when points have changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void PointsChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            var screenSpaceVisual3D = (ScreenSpaceVisual3D)sender;
            screenSpaceVisual3D.UpdateGeometry();

            if (screenSpaceVisual3D.collectionBeingListenedTo != null && !screenSpaceVisual3D.collectionBeingListenedTo.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo.Changed -= screenSpaceVisual3D.HandlePointsChanged;
            }

            if (e.NewValue is Point3DCollection pc && !pc.IsFrozen)
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;

                // TODO: use a weak event manager
                pc.Changed += screenSpaceVisual3D.HandlePointsChanged;
            }
            else
            {
                screenSpaceVisual3D.collectionBeingListenedTo = pc;
            }
        }

        /// <summary>
        /// The composition target_ rendering.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The event arguments.
        /// </param>
        protected override void OnCompositionTargetRendering(object sender, RenderingEventArgs e)
        {
            if (this.isRendering)
            {
                if (!Visual3DHelper.IsAttachedToViewport3D(this))
                {
                    return;
                }

                if (this.UpdateTransforms())
                {
                    this.UpdateClipping();
                    this.UpdateGeometry();
                }
            }
        }

        /// <summary>
        /// Called when the parent of the 3-D visual object is changed.
        /// </summary>
        /// <param name="oldParent">
        /// A value of type <see cref="T:System.Windows.DependencyObject"/> that represents the previous parent of the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object. If the <see cref="T:System.Windows.Media.Media3D.Visual3D"/> object did not have a previous parent, the value of the parameter is null.
        /// </param>
        protected override void OnVisualParentChanged(DependencyObject oldParent)
        {
            base.OnVisualParentChanged(oldParent);
            var parent = VisualTreeHelper.GetParent(this);
            this.IsRendering = parent != null;
        }

        /// <summary>
        /// Updates the geometry.
        /// </summary>
        protected abstract void UpdateGeometry();

        /// <summary>
        /// Updates the transforms.
        /// </summary>
        /// <returns>
        /// True if the transform is updated.
        /// </returns>
        protected abstract bool UpdateTransforms();

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        /// <param name="sender">
        /// The sender.
        /// </param>
        /// <param name="e">
        /// The <see cref="DependencyPropertyChangedEventArgs"/> instance containing the event data.
        /// </param>
        private static void ColorChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            ((ScreenSpaceVisual3D)sender).ColorChanged();
        }

        /// <summary>
        /// Handles changes in the <see cref="Points" /> collection.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The event arguments.</param>
        private void HandlePointsChanged(object sender, EventArgs e)
        {
            this.UpdateGeometry();
        }

        /// <summary>
        /// Changes the material when the color changed.
        /// </summary>
        private void ColorChanged()
        {
            var mg = new MaterialGroup();
            mg.Children.Add(new DiffuseMaterial(Brushes.Black));
            mg.Children.Add(new EmissiveMaterial(new SolidColorBrush(this.Color)));
            mg.Freeze();
            this.Model.Material = mg;
            this.Model.BackMaterial = mg;
        }

        /// <summary>
        /// Updates the clipping object.
        /// </summary>
        private void UpdateClipping()
        {
            var vp = this.GetViewport3D();
            if (vp == null)
            {
                return;
            }

            this.Clipping = new CohenSutherlandClipping(10, vp.ActualWidth - 20, 10, vp.ActualHeight - 20);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Source\HelixToolkit.Wpf.Shared\Visual3Ds\ScreenSpaceVisuals\ScreenSpaceVisual3D.cs(205,65): error CS0165: Use of unassigned local variable 'pc'
######################################################################


