Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Tests(net461)
    #1 Path: D:\a\1\s\test\Tests\BlogTests.cs, Line: 786, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #2 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1582, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1590, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1594, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1598, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #6 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1668, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1672, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 1676, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #9 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 450, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\test\Tests\ChainTests.cs, Line: 482, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #11 Path: D:\a\1\s\test\Tests\Core\PriorityQueueTest.cs, Line: 31, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #12 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 100, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 136, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 143, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 212, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 250, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #20 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 257, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #21 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #22 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 297, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #23 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 339, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 372, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 377, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\test\Tests\Core\RandomTest.cs, Line: 93, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\test\Tests\Core\SpecialFunctionsTest.cs, Line: 1422, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\test\Tests\Core\SpecialFunctionsTest.cs, Line: 1465, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\test\Tests\Core\SpecialFunctionsTest.cs, Line: 1542, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #32 Path: D:\a\1\s\test\Tests\Core\SpecialFunctionsTest.cs, Line: 1548, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: D:\a\1\s\test\Tests\Dynamic\TypeInference.cs, Line: 526, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: D:\a\1\s\test\Tests\InferTests.cs, Line: 1901, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\test\Tests\InferTests.cs, Line: 1933, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: D:\a\1\s\test\Tests\InferTests.cs, Line: 1959, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\test\Tests\LDATests.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #38 Path: D:\a\1\s\test\Tests\LDATests.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #39 Path: D:\a\1\s\test\Tests\LDATests.cs, Line: 323, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #40 Path: D:\a\1\s\test\Tests\LDATests.cs, Line: 351, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #41 Path: D:\a\1\s\test\Tests\MaxProductTests.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\test\Tests\MaxProductTests.cs, Line: 158, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: D:\a\1\s\test\Tests\MaxProductTests.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #44 Path: D:\a\1\s\test\Tests\MaxProductTests.cs, Line: 57, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #45 Path: D:\a\1\s\test\Tests\MaxProductTests.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: D:\a\1\s\test\Tests\MixtureTests.cs, Line: 452, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: D:\a\1\s\test\Tests\SharedVariableTests.cs, Line: 931, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\test\Tests\SharedVariableTests.cs, Line: 934, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\test\Tests\SharedVariableTests.cs, Line: 938, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\test\Tests\SpeedTests.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\test\Tests\SpeedTests.cs, Line: 162, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #52 Path: D:\a\1\s\test\Tests\SpeedTests.cs, Line: 166, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #53 Path: D:\a\1\s\test\Tests\SpeedTests.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\test\Tests\TestUtils.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #55 Path: D:\a\1\s\test\Tests\TestUtils.cs, Line: 263, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #56 Path: D:\a\1\s\test\Tests\TestUtils.cs, Line: 318, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: D:\a\1\s\test\Tests\TestUtils.cs, Line: 904, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Runtime
    #58 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 126, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #59 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 148, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #60 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #61 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #62 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 201, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #63 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 229, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #64 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #65 Path: D:\a\1\s\src\Runtime\Core\Collections\IListExtensions.cs, Line: 74, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #66 Path: D:\a\1\s\src\Runtime\Core\Collections\JaggedArray.cs, Line: 247, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #67 Path: D:\a\1\s\src\Runtime\Core\Collections\SparseList.cs, Line: 363, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #68 Path: D:\a\1\s\src\Runtime\Core\Maths\Matrix.cs, Line: 1508, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #69 Path: D:\a\1\s\src\Runtime\Core\Maths\Matrix.cs, Line: 1612, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #70 Path: D:\a\1\s\src\Runtime\Core\Maths\Matrix.cs, Line: 1650, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #71 Path: D:\a\1\s\src\Runtime\Core\Maths\Matrix.cs, Line: 2256, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #72 Path: D:\a\1\s\src\Runtime\Core\Maths\Region.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #73 Path: D:\a\1\s\src\Runtime\Core\Maths\SparseVector.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #74 Path: D:\a\1\s\src\Runtime\Core\Maths\SparseVector.cs, Line: 2181, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #75 Path: D:\a\1\s\src\Runtime\Core\Maths\SparseVector.cs, Line: 2409, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\src\Runtime\Core\Maths\SpecialFunctions.cs, Line: 600, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #77 Path: D:\a\1\s\src\Runtime\Core\Maths\SpecialFunctions.cs, Line: 672, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #78 Path: D:\a\1\s\src\Runtime\Core\Maths\Vector.cs, Line: 667, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #79 Path: D:\a\1\s\src\Runtime\Core\Serialization\BinaryReaderExtensions.cs, Line: 81, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #80 Path: D:\a\1\s\src\Runtime\Core\Serialization\MatlabWriter.cs, Line: 518, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #81 Path: D:\a\1\s\src\Runtime\Core\Serialization\SerializationAttributes.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #82 Path: D:\a\1\s\src\Runtime\Core\Serialization\SerializationAttributes.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #83 Path: D:\a\1\s\src\Runtime\Core\Serialization\SerializationAttributes.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #84 Path: D:\a\1\s\src\Runtime\Core\Utils\StringUtil.cs, Line: 342, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #85 Path: D:\a\1\s\src\Runtime\Distributions\ArrayEstimator.cs, Line: 641, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #86 Path: D:\a\1\s\src\Runtime\Distributions\ArrayEstimator.cs, Line: 657, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #87 Path: D:\a\1\s\src\Runtime\Distributions\ArrayEstimator.cs, Line: 725, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #88 Path: D:\a\1\s\src\Runtime\Distributions\Automata\GraphVizAutomatonFormat.cs, Line: 67, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #89 Path: D:\a\1\s\src\Runtime\Distributions\Automata\GraphVizAutomatonFormat.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #90 Path: D:\a\1\s\src\Runtime\Distributions\Automata\RegexpTreeBuilder.cs, Line: 1002, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #91 Path: D:\a\1\s\src\Runtime\Distributions\Automata\RegexpTreeBuilder.cs, Line: 489, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #92 Path: D:\a\1\s\src\Runtime\Distributions\Automata\RegexpTreeBuilder.cs, Line: 590, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #93 Path: D:\a\1\s\src\Runtime\Distributions\Automata\StringAutomaton.cs, Line: 201, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #94 Path: D:\a\1\s\src\Runtime\Distributions\BernoulliIntegerSubset.cs, Line: 273, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #95 Path: D:\a\1\s\src\Runtime\Distributions\Dirichlet.cs, Line: 1067, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #96 Path: D:\a\1\s\src\Runtime\Distributions\Dirichlet.cs, Line: 643, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #97 Path: D:\a\1\s\src\Runtime\Distributions\Discrete.cs, Line: 881, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #98 Path: D:\a\1\s\src\Runtime\Distributions\DiscreteChar.cs, Line: 427, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #99 Path: D:\a\1\s\src\Runtime\Distributions\GaussianProcess\SparseGPFixed.cs, Line: 71, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #100 Path: D:\a\1\s\src\Runtime\Distributions\LeftTruncatedPoisson.cs, Line: 789, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #101 Path: D:\a\1\s\src\Runtime\Distributions\Pareto.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #102 Path: D:\a\1\s\src\Runtime\Distributions\SparseDistributionList.cs, Line: 283, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #103 Path: D:\a\1\s\src\Runtime\Distributions\SparseDistributionList.cs, Line: 320, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\src\Runtime\Distributions\SparseDistributionList.cs, Line: 343, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\src\Runtime\Distributions\TruncatedPoisson.cs, Line: 631, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\src\Runtime\Factors\Factor.cs, Line: 1525, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\src\Runtime\Factors\GammaFromShapeAndRate.cs, Line: 900, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\src\Runtime\Factors\GaussianOp.cs, Line: 1629, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Compiler
    #109 Path: D:\a\1\s\src\Compiler\Dynamic\Binding.cs, Line: 438, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: D:\a\1\s\src\Compiler\Dynamic\Conversion.cs, Line: 441, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: D:\a\1\s\src\Compiler\Dynamic\DelegateGroup.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #112 Path: D:\a\1\s\src\Compiler\Dynamic\Invoker.cs, Line: 102, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #113 Path: D:\a\1\s\src\Compiler\Dynamic\Invoker.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #114 Path: D:\a\1\s\src\Compiler\Dynamic\Invoker.cs, Line: 127, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #115 Path: D:\a\1\s\src\Compiler\Dynamic\Invoker.cs, Line: 658, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #116 Path: D:\a\1\s\src\Compiler\Dynamic\Invoker.cs, Line: 97, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\src\Compiler\Graphs\Edge.cs, Line: 50, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #118 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 104, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #119 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #120 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #121 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 170, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 248, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 288, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 343, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #126 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 350, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #127 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 351, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #128 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 475, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #129 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 615, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #130 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 637, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #131 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 645, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 675, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #133 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 697, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 758, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\src\Compiler\Graphs\Graph.cs, Line: 785, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #136 Path: D:\a\1\s\src\Compiler\Graphs\GraphSearcher.cs, Line: 40, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #137 Path: D:\a\1\s\src\Compiler\Graphs\LabeledCollection.cs, Line: 216, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #138 Path: D:\a\1\s\src\Compiler\Graphs\LabeledCollection.cs, Line: 227, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #139 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 1029, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 1622, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #141 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 1633, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #142 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 1645, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #143 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 1657, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #144 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 802, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #145 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 813, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #146 Path: D:\a\1\s\src\Compiler\Graphs\ParallelScheduler.cs, Line: 840, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #147 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #148 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #149 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 1031, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #150 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 1082, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #151 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #152 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 18, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #153 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 25, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #154 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 293, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #155 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #156 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #157 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #158 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #159 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #160 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 336, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #161 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 35, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #162 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 458, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #163 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #164 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #165 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #166 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #167 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #168 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #169 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 516, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #170 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 526, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #171 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 744, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #172 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 807, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #173 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 825, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #174 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 926, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #175 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 968, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #176 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\Containers.cs, Line: 993, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #177 Path: D:\a\1\s\src\Compiler\Infer\CompilerAttributes\DebugInfo.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #178 Path: D:\a\1\s\src\Compiler\Infer\Models\ConditionBlock.cs, Line: 74, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #179 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #180 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 252, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #181 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 274, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #182 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 285, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #183 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 333, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #184 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #185 Path: D:\a\1\s\src\Compiler\Infer\Models\MethodInvoke.cs, Line: 69, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #186 Path: D:\a\1\s\src\Compiler\Infer\Models\ModelAttributes.cs, Line: 326, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #187 Path: D:\a\1\s\src\Compiler\Infer\Models\ModelAttributes.cs, Line: 357, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #188 Path: D:\a\1\s\src\Compiler\Infer\Models\ModelAttributes.cs, Line: 396, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #189 Path: D:\a\1\s\src\Compiler\Infer\Models\ModelBuilder.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\src\Compiler\Infer\Models\Variable.cs, Line: 2489, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #191 Path: D:\a\1\s\src\Compiler\Infer\Models\Variable.cs, Line: 2511, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #192 Path: D:\a\1\s\src\Compiler\Infer\Models\Variable.cs, Line: 2849, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #193 Path: D:\a\1\s\src\Compiler\Infer\Models\VariableArray.cs, Line: 158, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #194 Path: D:\a\1\s\src\Compiler\Infer\Models\VariableArray2D.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #195 Path: D:\a\1\s\src\Compiler\Infer\Models\VariableArray3D.cs, Line: 266, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #196 Path: D:\a\1\s\src\Compiler\Infer\Models\VariableArrayBase.cs, Line: 170, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #197 Path: D:\a\1\s\src\Compiler\Infer\Models\VariableArrayBase.cs, Line: 96, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #198 Path: D:\a\1\s\src\Compiler\Infer\Transforms\AccumulationTransform.cs, Line: 43, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #199 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ArraySizeTracingTransform.cs, Line: 76, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #200 Path: D:\a\1\s\src\Compiler\Infer\Transforms\Channel2Transform.cs, Line: 264, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #201 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ChannelInfo.cs, Line: 217, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #202 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ChannelTransform.cs, Line: 116, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #203 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ChannelTransform.cs, Line: 133, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #204 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ChannelTransform.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #205 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ChannelTransform.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #206 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ConditionBinding.cs, Line: 29, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #207 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ConditionBinding.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #208 Path: D:\a\1\s\src\Compiler\Infer\Transforms\CopyPropagationTransform.cs, Line: 231, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #209 Path: D:\a\1\s\src\Compiler\Infer\Transforms\CopyPropagationTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #210 Path: D:\a\1\s\src\Compiler\Infer\Transforms\CopyPropagationTransform.cs, Line: 335, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #211 Path: D:\a\1\s\src\Compiler\Infer\Transforms\CopyPropagationTransform.cs, Line: 404, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #212 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 1023, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #213 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 1257, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #214 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 1402, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #215 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 221, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #216 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #217 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #218 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #219 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #220 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 406, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #221 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 413, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #222 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 711, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #223 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyAnalysisTransform.cs, Line: 839, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #224 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 1487, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #225 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 1493, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #226 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 162, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #227 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 1726, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #228 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #229 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #230 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #231 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #232 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #233 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 646, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #234 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 670, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #235 Path: D:\a\1\s\src\Compiler\Infer\Transforms\DependencyGraph.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #236 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 139, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #237 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 169, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #238 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 211, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #239 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 443, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #240 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 483, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #241 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #242 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 878, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #243 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 917, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #244 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ForwardBackwardTransform.cs, Line: 959, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #245 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateAnalysisTransform.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #246 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateAnalysisTransform.cs, Line: 514, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #247 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateAnalysisTransform.cs, Line: 536, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #248 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateAnalysisTransform.cs, Line: 728, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #249 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 1270, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #250 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 1355, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #251 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 1369, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #252 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 162, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #253 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #254 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GateTransform.cs, Line: 954, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #255 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs, Line: 1047, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #256 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs, Line: 1221, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #257 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs, Line: 1348, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #258 Path: D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs, Line: 1353, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #259 Path: D:\a\1\s\src\Compiler\Infer\Transforms\HoistingTransform.cs, Line: 484, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #260 Path: D:\a\1\s\src\Compiler\Infer\Transforms\HoistingTransform.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #261 Path: D:\a\1\s\src\Compiler\Infer\Transforms\HoistingTransform.cs, Line: 642, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #262 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IfCuttingTransform.cs, Line: 58, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #263 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IfCuttingTransform.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #264 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IfCuttingTransform.cs, Line: 80, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #265 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IncrementPruningTransform.cs, Line: 100, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #266 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexAnalysisTransform.cs, Line: 107, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #267 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexAnalysisTransform.cs, Line: 134, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #268 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexingTransform.cs, Line: 104, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #269 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexingTransform.cs, Line: 534, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #270 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexingTransform.cs, Line: 543, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #271 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IndexingTransform.cs, Line: 704, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #272 Path: D:\a\1\s\src\Compiler\Infer\Transforms\InitializerTransform.cs, Line: 150, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #273 Path: D:\a\1\s\src\Compiler\Infer\Transforms\InitializerTransform.cs, Line: 63, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #274 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterationTransform.cs, Line: 226, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #275 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterationTransform.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #276 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterationTransform.cs, Line: 368, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #277 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 1043, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #278 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 1213, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #279 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 15, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #280 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 16, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #281 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 1615, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #282 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 1639, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #283 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 1643, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #284 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 678, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #285 Path: D:\a\1\s\src\Compiler\Infer\Transforms\IterativeProcessTransform.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #286 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 29, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #287 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #288 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #289 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 41, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #290 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 45, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #291 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LinqExpressionTransform.cs, Line: 49, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #292 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform.cs, Line: 1123, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #293 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform.cs, Line: 1238, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #294 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform.cs, Line: 515, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #295 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform.cs, Line: 876, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #296 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform.cs, Line: 895, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #297 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform2.cs, Line: 1269, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #298 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform2.cs, Line: 561, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #299 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform2.cs, Line: 737, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #300 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalAllocationTransform2.cs, Line: 866, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #301 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 140, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #302 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #303 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #304 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 522, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #305 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 570, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #306 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LocalTransform.cs, Line: 588, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #307 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopMergingTransform.cs, Line: 13, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #308 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopMergingTransform.cs, Line: 14, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #309 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopMergingTransform.cs, Line: 165, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #310 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopMergingTransform.cs, Line: 242, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #311 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopMergingTransform.cs, Line: 413, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #312 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopOrderingTransform.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #313 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopRemovalTransform.cs, Line: 51, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #314 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopReversalTransform.cs, Line: 158, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #315 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopReversalTransform.cs, Line: 408, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #316 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopUnrollingTransform.cs, Line: 40, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #317 Path: D:\a\1\s\src\Compiler\Infer\Transforms\LoopUnrollingTransform.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #318 Path: D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs, Line: 1393, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #319 Path: D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs, Line: 819, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #320 Path: D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs, Line: 823, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #321 Path: D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #322 Path: D:\a\1\s\src\Compiler\Infer\Transforms\PointMassAnalysisTransform.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\src\Compiler\Infer\Transforms\Scheduler.cs, Line: 1901, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #324 Path: D:\a\1\s\src\Compiler\Infer\Transforms\Scheduler.cs, Line: 365, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #325 Path: D:\a\1\s\src\Compiler\Infer\Transforms\Scheduler.cs, Line: 718, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #326 Path: D:\a\1\s\src\Compiler\Infer\Transforms\Scheduler.cs, Line: 847, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #327 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 104, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #328 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 1042, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #329 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 187, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #330 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 199, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #331 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 385, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #332 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 809, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #333 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 912, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #334 Path: D:\a\1\s\src\Compiler\Infer\Transforms\SchedulingTransform.cs, Line: 917, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #335 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #336 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 1615, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #337 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 1685, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #338 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 198, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #339 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 21, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #340 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #341 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #342 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 68, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #343 Path: D:\a\1\s\src\Compiler\Infer\Transforms\StocAnalysisTransform.cs, Line: 706, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #344 Path: D:\a\1\s\src\Compiler\Infer\Transforms\UniquenessTransform.cs, Line: 122, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #345 Path: D:\a\1\s\src\Compiler\Infer\Transforms\UniquenessTransform.cs, Line: 134, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #346 Path: D:\a\1\s\src\Compiler\Infer\Transforms\VariableTransform.cs, Line: 100, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #347 Path: D:\a\1\s\src\Compiler\Infer\Transforms\VariableTransform.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #348 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 102, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #349 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 160, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #350 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 224, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #351 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 326, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #352 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 336, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #353 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\ModelView.cs, Line: 36, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #354 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 147, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #355 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 150, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #356 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #357 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 195, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #358 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 198, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #359 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 199, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #360 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 204, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #361 Path: D:\a\1\s\src\Compiler\Infer\Visualizers\Default\GraphViews\TaskGraphView.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #362 Path: D:\a\1\s\src\Compiler\TransformFramework\AttributeRegistry.cs, Line: 182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #363 Path: D:\a\1\s\src\Compiler\TransformFramework\AttributeRegistry.cs, Line: 202, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #364 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeBuilder.cs, Line: 540, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #365 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #366 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 141, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #367 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 27, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #368 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #371 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 84, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #372 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\Generics.cs, Line: 96, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #373 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\MethodInstanceReference.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\TypeInstanceReference.cs, Line: 204, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #375 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeModel\TypeInstanceReference.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #376 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs, Line: 1283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #377 Path: D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs, Line: 242, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #378 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #379 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 127, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #380 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #381 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #382 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #383 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #384 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #385 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 41, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #386 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #387 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #388 Path: D:\a\1\s\src\Compiler\TransformFramework\ExpressionEvaluator.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #389 Path: D:\a\1\s\src\Compiler\TransformFramework\LanguageWriters\CSharpWriter.cs, Line: 240, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: ClickThroughModel(net461)
    #390 Path: D:\a\1\s\src\Examples\ClickThroughModel\UserData.cs, Line: 28, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: MontyHall
    #391 Path: D:\a\1\s\src\Examples\MontyHall\Window1.xaml.cs, Line: 243, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: LDA(net461)
    #392 Path: D:\a\1\s\src\Examples\LDA\LDAShared.cs, Line: 314, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #394 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 162, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #395 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 163, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #396 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #397 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 204, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #398 Path: D:\a\1\s\src\Examples\LDA\Program.cs, Line: 232, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Csoft
    #399 Path: D:\a\1\s\src\Csoft\DeclarationTreeBuilder.cs, Line: 50, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #400 Path: D:\a\1\s\src\Csoft\DeclarationTreeBuilder.cs, Line: 55, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #401 Path: D:\a\1\s\src\Csoft\EmbeddedResourceSourceProvider.cs, Line: 23, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #402 Path: D:\a\1\s\src\Csoft\EmbeddedResourceSourceProvider.cs, Line: 27, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #403 Path: D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs, Line: 720, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #404 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 195, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #405 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #406 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 228, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 234, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 240, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\src\Csoft\QueryTransform.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: CommandLine(net461)
    #411 Path: D:\a\1\s\src\Learners\Runners\CommandLine\Classifier\BayesPointMachineClassifierModuleUtilities.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #412 Path: D:\a\1\s\src\Learners\Runners\CommandLine\Classifier\BayesPointMachineClassifierModuleUtilities.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #413 Path: D:\a\1\s\src\Learners\Runners\CommandLine\Classifier\BayesPointMachineClassifierModuleUtilities.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #414 Path: D:\a\1\s\src\Learners\Runners\CommandLine\Classifier\BinaryBayesPointMachineClassifierCrossValidationModule.cs, Line: 142, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #415 Path: D:\a\1\s\src\Learners\Runners\CommandLine\Classifier\MulticlassBayesPointMachineClassifierCrossValidationModule.cs, Line: 142, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Common
    #416 Path: D:\a\1\s\src\Learners\Runners\Common\CommandLine\CommandLineModuleSelector.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #417 Path: D:\a\1\s\src\Learners\Runners\Common\CommandLine\CommandLineParser.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #418 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationBase.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #419 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationBase.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #420 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationElement.cs, Line: 173, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #421 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationElement.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #422 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationElement.cs, Line: 183, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #423 Path: D:\a\1\s\src\Learners\Runners\Common\Configuration\ConfigurationElement.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #424 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\FileParsingContext.cs, Line: 61, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #425 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\FileParsingContext.cs, Line: 75, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #426 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RatedUserItem.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #427 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 283, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #428 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #429 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 302, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #430 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 309, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #431 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 75, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #432 Path: D:\a\1\s\src\Learners\Runners\Common\DataModel\RecommenderPersistenceUtils.cs, Line: 91, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Evaluator(net461)
    #433 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Configuration\EvaluatorConfiguration.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #434 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\FeatureProcessor.cs, Line: 87, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #435 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\FeatureProcessor.cs, Line: 91, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #436 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 121, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #437 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 124, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #438 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #439 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 155, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #440 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 158, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #441 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 173, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #442 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #443 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 181, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #444 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #445 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 204, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #446 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 222, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #447 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 227, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #448 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 245, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #449 Path: D:\a\1\s\src\Learners\Runners\Evaluator\DatasetGenerators\MovieLens\Features.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #450 Path: D:\a\1\s\src\Learners\Runners\Evaluator\MetricValueDistribution.cs, Line: 105, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #451 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 331, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #452 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 340, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #453 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 348, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #454 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 355, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #455 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 712, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #456 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\MahoutRecommender.cs, Line: 751, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #457 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\VowpalWabbitRecommender.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #458 Path: D:\a\1\s\src\Learners\Runners\Evaluator\Wrappers\VowpalWabbitRecommender.cs, Line: 499, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Core
    #459 Path: D:\a\1\s\src\Learners\Core\Metrics.cs, Line: 434, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #460 Path: D:\a\1\s\src\Learners\Core\Metrics.cs, Line: 505, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #461 Path: D:\a\1\s\src\Learners\Core\Metrics.cs, Line: 589, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #462 Path: D:\a\1\s\src\Learners\Core\PointEstimator.cs, Line: 108, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #463 Path: D:\a\1\s\src\Learners\Core\PointEstimator.cs, Line: 140, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #464 Path: D:\a\1\s\src\Learners\Core\PointEstimator.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #465 Path: D:\a\1\s\src\Learners\Core\Utilities.cs, Line: 276, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #466 Path: D:\a\1\s\src\Learners\Core\Utilities.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Recommender
    #467 Path: D:\a\1\s\src\Learners\Recommender\Mappings\NegativeDataGeneratorMapping.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #468 Path: D:\a\1\s\src\Learners\Recommender\MatchboxRecommenderInternal\HistogramSampler.cs, Line: 111, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #469 Path: D:\a\1\s\src\Learners\Recommender\MatchboxRecommenderInternal\HistogramSampler.cs, Line: 123, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #470 Path: D:\a\1\s\src\Learners\Recommender\MatchboxRecommenderInternal\HistogramSampler.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Visualizers.Windows
    #471 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 153, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #472 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #473 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 188, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #474 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 201, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #475 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 204, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #476 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 205, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #477 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 210, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #478 Path: D:\a\1\s\src\Visualizers\Windows\GraphViews\TaskGraphView.cs, Line: 51, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #479 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\CodeElementInspectorView.xaml.cs, Line: 21, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #480 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\CodeElementInspectorView.xaml.cs, Line: 40, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #481 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\CodeElementInspectorView.xaml.cs, Line: 65, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #482 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\CodeElementInspectorView.xaml.cs, Line: 94, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #483 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\DeclarationView.xaml.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #484 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\DeclarationView.xaml.cs, Line: 62, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #485 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\LineOfCodeView.xaml.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #486 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\LineOfCodeView.xaml.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #487 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\LineOfCodeView.xaml.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #488 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\TransformerView.xaml.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #489 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\TransformerView.xaml.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #490 Path: D:\a\1\s\src\Visualizers\Windows\TransformerChainView\TransformerView.xaml.cs, Line: 44, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Crowdsourcing(net461)
    #491 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 136, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #492 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 159, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #493 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 286, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #494 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 299, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #495 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 304, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #496 Path: D:\a\1\s\src\Examples\Crowdsourcing\ActiveLearning.cs, Line: 308, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #497 Path: D:\a\1\s\src\Examples\Crowdsourcing\Crowdsourcing.cs, Line: 180, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #498 Path: D:\a\1\s\src\Examples\Crowdsourcing\DataMapping.cs, Line: 181, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #499 Path: D:\a\1\s\src\Examples\Crowdsourcing\Results.cs, Line: 670, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #500 Path: D:\a\1\s\src\Examples\Crowdsourcing\Results.cs, Line: 799, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: CrowdsourcingWithWords(net461)
    #501 Path: D:\a\1\s\src\Examples\CrowdsourcingWithWords\CrowdsourcingWithWords.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #502 Path: D:\a\1\s\src\Examples\CrowdsourcingWithWords\DataMapping.cs, Line: 171, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #503 Path: D:\a\1\s\src\Examples\CrowdsourcingWithWords\DataMapping.cs, Line: 216, Message: ReSharper: ReplaceWithSingleCallToFirst. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #504 Path: D:\a\1\s\src\Examples\CrowdsourcingWithWords\DataMappingWords.cs, Line: 25, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #505 Path: D:\a\1\s\src\Examples\CrowdsourcingWithWords\TFIDFClass.cs, Line: 92, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



--- Rules Summary ---
R5: 225
R9: 192
R8: 55
R4: 13
R2: 8
R6: 6
R7: 4
R3: 2

--- Summary ---
Fixed ReSharper issues: 497
Fixed SonarQube issues: 246
Total fixed issues: 505

Finished in: 0 s

######################################################################
Nr: 1 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\test\Tests\Distributions\DistributionTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Xunit;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;
using GaussianArray2D = Microsoft.ML.Probabilistic.Distributions.DistributionStructArray2D<Microsoft.ML.Probabilistic.Distributions.Gaussian, double>;
using System.Threading.Tasks;
using System.Threading;

namespace Microsoft.ML.Probabilistic.Tests
{
#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

    using Assert = Microsoft.ML.Probabilistic.Tests.AssertHelper;


    public class DistributionTests
    {
        public const int nsamples = 50000;

        [Fact]
        public void BinomialTest()
        {
            Binomial a = new Binomial(10, 0.2);
            Binomial b = new Binomial(10, 0.3);

            ProductWithUniformTest(a);
            ProductWithUniformTest(b);

            RatioWithUniformTest(a);
            RatioWithUniformTest(b);
            SettableToRatioTest(a, b);

            SettableToPowerTest(a);
            SettableToPowerTest(b);

            SettableToTest(a);
            SettableToTest(b);

            int value = 3;
            ProductWithPointMassTest(a, value);
            RatioWithPointMassTest(a, value);
            PointMassPowerTest(a, value);
            PointMassSampleTest(a, value);
            PointMassGetLogProbTest(a, value);

            SamplingTest(a, 3);
        }

        [Fact]
        public void GammaPowerFromMeanAndMeanLogTest()
        {
            var testCases = new[]
            {
                (3, 0.4, 5),
                (2.7196413092151412, 1, 2),
                (0.82657135035599683, -0.19053040661796108, -1.0),
                (0.78123008687766349, -0.24698718364292091, -1.0),
                (0.65867320393062079, -0.41774280264746583, -1.0),
                (32.016744802449665, 3.4078368553200575, -1.0),
                (1.2739417498500658, -0.9778858306365934, -1.0),
                (System.Math.Exp(1.0), 1.0, -1.0),
                (System.Math.Exp(1.25), 1.0, -1.0),
            };
            foreach (var testCase in testCases)
            {
                var (mean, meanLog, power) = testCase;
                GammaPower gammaPower = GammaPower.FromMeanAndMeanLog(mean, meanLog, power);
                Assert.Equal(mean, gammaPower.GetMean(), 1e-10);
                Assert.Equal(meanLog, gammaPower.GetMeanLog(), 1e-10);
            }
            GammaPower.FromMeanAndMeanLog(0.82657135035599683, -0.19053040661796108, -1.0);
            GammaPower.FromMeanAndMeanLog(0.78123008687766349, -0.24698718364292091, -1.0);
        }

        [Fact]
        public void Gamma_GetMode_MaximizesGetLogProb()
        {
            Parallel.ForEach(OperatorTests.Gammas()/*.Take(100000)*/, gamma =>
            {
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = gamma.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                    }
                }
                double mode = gamma.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = gamma.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = gamma.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = gamma.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-4 ||
                    (mode == 0 && gamma.GetLogProb(smallestNormalized) >= max)
                    );
            });
        }

        [Fact]
        public void GammaPower_GetMode_MaximizesGetLogProb()
        {
            long count = 0;
            Parallel.ForEach(new[] {
                GammaPower.FromShapeAndRate(1.7976931348623157E+308, 1.7976931348623157E+308, -1.7976931348623157E+308),
            }.Concat(OperatorTests.GammaPowers()).Take(100000), gammaPower =>
            {
                double argmax = double.NaN;
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = gammaPower.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                        argmax = x;
                    }
                }
                double mode = gammaPower.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = gammaPower.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = gammaPower.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = gammaPower.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-8 ||
                    (mode <= double.Epsilon && gammaPower.GetLogProb(smallestNormalized) >= max)
                    );
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void TruncatedGamma_GetMode_MaximizesGetLogProb()
        {
            long count = 0;
            Parallel.ForEach(OperatorTests.TruncatedGammas().Take(100000), dist =>
            {
                double argmax = double.NaN;
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = dist.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                        argmax = x;
                    }
                }
                double mode = dist.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = dist.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = dist.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = dist.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-8 ||
                    (mode <= double.Epsilon && dist.GetLogProb(smallestNormalized) >= max)
                    );
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void GammaPowerTest()
        {
            foreach (var gammaPower in new[] {
                GammaPower.FromShapeAndRate(3, 2, -4.0552419045546273),
                new GammaPower(0.04591, 19.61, -1),
            })
            {
                gammaPower.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
                Assert.Equal(variance, gammaPower.GetVariance());
            }

            Assert.Equal(0, GammaPower.FromShapeAndRate(2, 0, -1).GetMean());
            Assert.Equal(0, GammaPower.FromShapeAndRate(2, 0, -1).GetVariance());
            Assert.True(GammaPower.FromShapeAndRate(2, double.PositiveInfinity, -1).IsPointMass);

            GammaPower g = new GammaPower(1, 1, -1);
            g.ToString();
            Gamma gamma = new Gamma(1, 1);
            double expectedProbLessThan = gamma.GetProbLessThan(2);
            Assert.Equal(expectedProbLessThan, 1 - g.GetProbLessThan(0.5), 1e-10);
            Assert.Equal(2, gamma.GetQuantile(expectedProbLessThan), 1e-10);
            Assert.Equal(0.5, g.GetQuantile(1 - expectedProbLessThan), 1e-10);

            Assert.Equal(0, g.GetProbLessThan(0));
            Assert.Equal(0, g.GetProbLessThan(double.MinValue));
            Assert.Equal(0, g.GetProbLessThan(double.NegativeInfinity));

            g = GammaPower.FromMeanAndVariance(3, double.PositiveInfinity, -1);
            Assert.Equal(2, g.Shape);
            Assert.Equal(3, g.Rate);

            GammaPowerMomentTest(1);
            GammaPowerMomentTest(-1);
            GammaPowerMomentTest(2);
        }

        private void GammaPowerMomentTest(double power)
        {
            GammaPower g = new GammaPower(9.9, 1, power);
            GammaPower g2 = new GammaPower(4.4, 3.3, power);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);
            g.SetToUniform();
        }

        [Fact]
        public void GammaPowerMeanAndVarianceFuzzTest()
        {
            foreach (var gammaPower in OperatorTests.GammaPowers().Take(100000))
            {
                gammaPower.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
            }
        }

        [Fact]
        public void GammaMeanAndVarianceFuzzTest()
        {
            foreach (var gamma in OperatorTests.Gammas())
            {
                gamma.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
            }
        }

        //[Fact]
        internal void WrappedGaussianTest()
        {
            WrappedGaussian g = new WrappedGaussian(2.2, 3.3);
            WrappedGaussian g2 = new WrappedGaussian(4.4, 5.5);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
        }

        [Fact]
        public void TruncatedGaussianTest()
        {
            double lowerBound = 5;
            double upperBound = 10;
            var g = new TruncatedGaussian(2.2, 3.3, lowerBound, upperBound);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            //Assert.Equal(2.2, m);
            //Assert.Equal(3.3, v);

            var g2 = new TruncatedGaussian(4.4, 5.5, lowerBound, upperBound);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            //SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);

            var ratio = g / g2;
            Assert.Throws<DivideByZeroException>(() =>
            {
                ratio = g / new TruncatedGaussian(4.4, 5.5, lowerBound + 1, upperBound);
            });
            ratio = TruncatedGaussian.PointMass(lowerBound) / new TruncatedGaussian(4.4, 5.5, lowerBound, upperBound);
            Assert.Throws<DivideByZeroException>(() =>
            {
                ratio = TruncatedGaussian.PointMass(2) / new TruncatedGaussian(4.4, 5.5, lowerBound + 1, upperBound);
            });

            g.SetToUniform();
            //GetAndSetMomentTest(g, 0.0, Double.PositiveInfinity);

            g = new TruncatedGaussian(2, 1, 100, double.PositiveInfinity);
            SamplingTest(g, 7.7);
            foreach (double variance in new[] { 1e8, 1e17, double.MaxValue, double.PositiveInfinity })
            {
                g = new TruncatedGaussian(2, variance, 100, 101);
                SamplingTest(g, 7.7);
            }
        }

        [Fact]
        public void TruncatedGammaTest()
        {
            double lowerBound = 5;
            double upperBound = 10;
            var g = new TruncatedGamma(2.2, 3.3, lowerBound, upperBound);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            /* in matlab:
               x = linspace(5,10,1e6);
               inc = x(2)-x(1);
               lp = gampdfln(x,2.2,1/3.3);
               m = sum(x.*exp(lp))/sum(exp(lp))
               sum((x-m).^2.*exp(lp))/sum(exp(lp))
             */
            Assert.True(MMath.AbsDiff(7.2174, m) < 1e-4);
            Assert.True(MMath.AbsDiff(1.9969, v) < 1e-4);

            var g2 = new TruncatedGamma(4.4, 5.5, lowerBound, upperBound);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            // TODO
            //UniformTest(g, 7.7);
            //SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            // TODO
            //SamplingTest(g, 7.7);
            g.SetToUniform();
            //GetAndSetMomentTest(g, 0.0, Double.PositiveInfinity);

            g = new TruncatedGamma(2, 1, 100, double.PositiveInfinity);
            //SamplingTest(g, 7.7);
            g = new TruncatedGamma(2, 1e8, 100, 101);
            //SamplingTest(g, 7.7);

            g = new TruncatedGamma(2, 1, 3, 3);
            Assert.True(g.IsPointMass);
            Assert.Equal(3.0, g.Point);

            g = new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e14);
            Assert.True(g.Sample() >= 0);
        }

        /// <summary>
        /// Checks that TruncatedGamma.GetMean does not return infinity or NaN for proper distributions.
        /// </summary>
        [Fact]
        public void TruncatedGamma_GetMean()
        {
            double target = 0.1;
            double oldDiff = double.PositiveInfinity;
            for (int i = 1; i < 20; i++)
            {
                TruncatedGamma g = new TruncatedGamma(1, System.Math.Exp(-i), target, double.PositiveInfinity);
                var mean = g.GetMean();
                //Trace.WriteLine($"GetNormalizer = {g.GetNormalizer()} GetMean = {g.GetMean()}");
                Assert.False(double.IsInfinity(mean));
                Assert.False(double.IsNaN(mean));
                double diff = System.Math.Abs(mean - target);
                Assert.True(diff == 0 || diff < oldDiff);
                oldDiff = diff;
                double mean2, variance;
                g.GetMeanAndVariance(out mean2, out variance);
                Assert.Equal(mean, mean2);
            }
            oldDiff = double.PositiveInfinity;
            for (int i = 0; i < 20; i++)
            {
                TruncatedGamma g = new TruncatedGamma(System.Math.Exp(i), 1, 0, target);
                var mean = g.GetMean();
                //Trace.WriteLine($"GetNormalizer = {g.GetNormalizer()} GetMean = {g.GetMean()}");
                Assert.False(double.IsInfinity(mean));
                Assert.False(double.IsNaN(mean));
                double diff = System.Math.Abs(mean - target);
                Assert.True(diff == 0 || diff < oldDiff);
                oldDiff = diff;
                double mean2, variance;
                g.GetMeanAndVariance(out mean2, out variance);
                Assert.Equal(mean, mean2);
            }
        }

        /// <summary>
        /// Checks that TruncatedGamma.GetMeanPower does not return infinity or NaN for proper distributions.
        /// </summary>
        [Fact]
        public void TruncatedGamma_GetMeanPower()
        {
            double shape = 1;
            TruncatedGamma g = new TruncatedGamma(shape, 1, 1, double.PositiveInfinity);
            for (int i = 0; i < 100; i++)
            {
                var meanPower = g.GetMeanPower(-i);
                //Trace.WriteLine($"GetMeanPower({-i}) = {meanPower}");
                Assert.False(double.IsNaN(meanPower));
                Assert.False(double.IsInfinity(meanPower));
                if (i == 1) Assert.Equal(MMath.GammaUpper(shape - 1, 1, false) / MMath.GammaUpper(shape, 1, false), meanPower, 1e-8);
            }
        }

        [Fact]
        public void TruncatedGamma_GetMeanAndVariance_WithinBounds()
        {
            long count = 0;
            Parallel.ForEach(OperatorTests.LowerTruncatedGammas()
                .Take(100000), dist =>
                {
                    dist.GetMeanAndVariance(out double mean, out double variance);
                    // Compiler.Quoter.Quote(dist)
                    Assert.True(mean >= dist.LowerBound);
                    Assert.True(mean <= dist.UpperBound);
                    Assert.Equal(mean, dist.GetMean());
                    Assert.True(variance >= 0);
                    Interlocked.Add(ref count, 1);
                    if (count % 100000 == 0)
                        Trace.WriteLine($"{count} cases passed");
                });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        [Trait("Category", "OpenBug")]
        public void TruncatedGamma_GetMeanPower_WithinBounds()
        {
            var g = new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e14);
            Assert.True(g.GetMean() <= g.UpperBound);
            for (int i = 0; i < 308; i++)
            {
                double power = System.Math.Pow(10, i);
                //Trace.WriteLine($"GetMeanPower({power}) = {g.GetMeanPower(power)}");
                Assert.True(g.GetMeanPower(power) <= g.UpperBound);
            }
            Assert.True(g.GetMeanPower(1.7976931348623157E+308) <= g.UpperBound);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e9).GetMeanPower(1.7976931348623157E+308) <= 1e9);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e6).GetMeanPower(1.7976931348623157E+308) <= 1e6);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 100).GetMeanPower(4.94065645841247E-324) <= 100);

            long count = 0;
            Parallel.ForEach(OperatorTests.LowerTruncatedGammas()
                .Take(100000), dist =>
            {
                foreach (var power in OperatorTests.Doubles())
                {
                    if (dist.Gamma.Shape <= -power && dist.LowerBound == 0) continue;
                    double meanPower = dist.GetMeanPower(power);
                    if (power >= 0)
                    {
                        // Compiler.Quoter.Quote(dist)
                        Assert.True(meanPower >= System.Math.Pow(dist.LowerBound, power));
                        Assert.True(meanPower <= System.Math.Pow(dist.UpperBound, power));
                    }
                    else
                    {
                        Assert.True(meanPower <= System.Math.Pow(dist.LowerBound, power));
                        Assert.True(meanPower >= System.Math.Pow(dist.UpperBound, power));
                    }
                    if (power == 1)
                    {
                        Assert.Equal(meanPower, dist.GetMean());
                    }
                }
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void GaussianTest()
        {
            Gaussian g = new Gaussian();
            g.SetMeanAndVariance(2.2, 3.3);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            Assert.Equal(2.2, m);
            Assert.Equal(3.3, v);

            double x = 4.4;
            double probLessThan = g.GetProbLessThan(x);
            Assert.Equal(MMath.NormalCdf((x - 2.2) / System.Math.Sqrt(3.3)), probLessThan, 1e-4);

            Gaussian g2 = new Gaussian(4.4, 5.5);
            /* Test in matlab:
                x = linspace(-100,100,1e6);
                inc = x(2)-x(1);
                m1 = 2.2;
                v1 = 3.3;
                m2 = 4.4;
                v2 = 5.5;
                logsumexp(normpdfln(x,m1,[],v1)+normpdfln(x,m2,[],v2),2)+log(inc)
                    normpdfln(m1,m2,[],v1+v2)
                logsumexp(normpdfln(x,m1,[],v1)-normpdfln(x,m2,[],v2),2)+log(inc)
                    log(v2/(v2-v1)) - normpdfln(m1,m2,[],v2-v1)
                v2 = -5.5
                logsumexp(normpdfln(x,m1,[],v1) -0.5*x.^2/v2+x*(m2/v2),2)+log(inc)
                    -0.5*(m1-m2)^2/(v1+v2) +0.5*log(v2/(v1+v2))
                logsumexp(normpdfln(x,m1,[],v1) +0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                    0.5*(m1-m2)^2/(v2-v1) +0.5*log(v2/(v2-v1))
                logsumexp(0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                v1 = -6.6
                logsumexp(-0.5*x.^2/v1+x*m1/v1 +0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                    0.5*(m1-m2)^2/(v2-v1) +0.5*log(2*pi*v2*v1/(v2-v1))
             */
            // (proper,proper)
            Assert.True(System.Math.Abs(g.GetLogAverageOf(g2) - (-2.28131439394676)) < 1e-8);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 3.32945794526097) < 1e-8);
            // (proper,improper)
            g2.SetMeanAndVariance(4.4, -5.5);
            Assert.True(System.Math.Abs(g.GetLogAverageOf(g2) - (-0.201854634084064)) < 1e-8);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 1.249998185356082) < 1e-8);
            // (uniform,improper)
            g.SetToUniform();
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 3.531312579302817) < 1e-8);
            // (improper,improper)
            g.SetMeanAndVariance(2.2, -6.6);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 6.260525647249976) < 1e-8);
            // (proper,uniform)
            g.SetMeanAndVariance(2.2, 3.3);
            Assert.True(g.GetLogAverageOf(Gaussian.Uniform()) == 0);

            // Checks for infinite means
            Assert.Equal(new Gaussian(double.NegativeInfinity, 2.2), Gaussian.PointMass(double.NegativeInfinity));
            Assert.Equal(new Gaussian(double.PositiveInfinity, 2.2), Gaussian.PointMass(double.PositiveInfinity));
            g.SetMeanAndVariance(double.NegativeInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.NegativeInfinity));
            g.SetMeanAndVariance(double.PositiveInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.PositiveInfinity));
            g.SetMeanAndPrecision(double.NegativeInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.NegativeInfinity));
            g.SetMeanAndPrecision(double.PositiveInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.PositiveInfinity));

            double mean = 1024;
            double precision = double.MaxValue / mean * 2;
            // precision * mean > double.MaxValue
            g.SetMeanAndPrecision(mean, precision);
            g2 = Gaussian.FromMeanAndPrecision(mean, double.MaxValue / mean);
            Assert.Equal(g2, g);
            Assert.Equal(g2, new Gaussian(mean, 1 / precision));
            double inverseIsInfinity = 0.5 / double.MaxValue;
            Assert.Equal(Gaussian.PointMass(mean), new Gaussian(mean, inverseIsInfinity));
            Gaussian.FromNatural(1, inverseIsInfinity).GetMeanAndVarianceImproper(out m, out v);
            if (v > double.MaxValue)
                Assert.Equal(0, m);
            Gaussian.Uniform().GetMeanAndVarianceImproper(out m, out v);
            Assert.Equal(0, m);
            Assert.True(double.IsPositiveInfinity(v));

            g.SetMeanAndVariance(2.2, 3.3);
            g2.SetMeanAndVariance(4.4, 5.5);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);
            g.SetToUniform();
            Assert.True(g.GetVariance() == double.PositiveInfinity);
            Assert.Throws<ImproperDistributionException>(() => g.GetMean());

            Gaussian g3 = new Gaussian();
            g3.SetToSum(1.0, g, double.PositiveInfinity, g2);
            Assert.True(g3.Equals(g2));
        }

        /// <summary>
        /// Tests that a product of high-precision Gaussians produces a point mass.
        /// </summary>
        [Fact]
        public void GaussianSetToProduct_ProducesPointMassTest()
        {
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(1, double.MaxValue));
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(0.9, double.MaxValue));
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(10, double.MaxValue / 10));
        }

        private void GaussianSetToProduct_ProducesPointMass(Gaussian g)
        {
            Gaussian expected = Gaussian.PointMass(g.GetMean());
            Assert.Equal(expected, g * g);
            Assert.Equal(expected, g ^ 2);
        }

        /// <summary>
        /// Tests that a product of high-precision Gaussians produces a point mass.
        /// </summary>
        [Fact]
        public void GammaSetToProduct_ProducesPointMassTest()
        {
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue, double.MaxValue));
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue / 10, double.MaxValue));
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue, double.MaxValue / 10));
        }

        private void GammaSetToProduct_ProducesPointMass(Gamma g)
        {
            Gamma expected = Gamma.PointMass(g.GetMode());
            Assert.Equal(expected, g * g);
            Assert.Equal(expected, g ^ 2);
        }

        [Fact]
        public void VectorGaussianTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            int d = 3;
            VectorGaussian g = new VectorGaussian(d);
            PositiveDefiniteMatrix A = new PositiveDefiniteMatrix(new double[,] { { 2, 2, 2 }, { 2, 3, 3 }, { 2, 3, 4 } });
            Vector b = Vector.FromArray(new double[] { 1, 2, 3 });
            g.Precision.SetTo(A);
            g.MeanTimesPrecision.SetTo(b);
            Console.WriteLine(StringUtil.JoinColumns("g = ", g));

            // test Equals
            VectorGaussian g1 = new VectorGaussian(d);
            g1.Precision.SetTo(A);
            g1.MeanTimesPrecision.SetTo(b);
            Assert.True(g1.Equals(g));
            Assert.True(g1.GetHashCode() == g.GetHashCode());

            // test Sample
            Vector x = null;
            VectorMeanVarianceAccumulator mva = new VectorMeanVarianceAccumulator(d);
            for (int i = 0; i < nsamples; i++)
            {
                x = g.Sample();
                mva.Add(x);
            }
            //Console.WriteLine("x = {0}", x);
            //Console.WriteLine("eval(x) = {0}", g.GetLogProb(x));
            // x = [-1 1 2]';
            // b = [1 2 3]';
            // a = [2 2 2; 2 3 3; 2 3 4];
            // normpdfln(x, a\b, 'inv', a)
            x = Vector.FromArray(new double[] { -1, 1, 2 });
            Assert.True(System.Math.Abs(g.GetLogProb(x) - (-7.160242009334)) < 1e-10);
            PositiveDefiniteMatrix prec = new PositiveDefiniteMatrix(3, 3);
            prec.SetToInverse(mva.Variance);
            Console.WriteLine(StringUtil.JoinColumns("precision = ", prec.ToString()));
            Console.WriteLine(" (error {0})", prec.MaxDiff(A));
            Assert.True(prec.MaxDiff(A) < 0.1);
            Vector pm = prec * mva.Mean;
            Console.WriteLine("precision * mean = {0}", pm);
            Console.WriteLine(" (error {0})", pm.MaxDiff(b));
            Assert.True(pm.MaxDiff(b) < 0.1);

            // test SetToProduct
            VectorGaussian g2 = new VectorGaussian(d);
            A = new PositiveDefiniteMatrix(new double[,] { { 3, 1, 1 }, { 1, 5, 1 }, { 1, 1, 6 } });
            b = Vector.FromArray(new double[] { 3, 2, 1 });
            g2.Precision.SetTo(A);
            g2.MeanTimesPrecision.SetTo(b);
            Console.WriteLine(StringUtil.JoinColumns("g2 = ", g2));

            g.SetToProduct(g1, g2);
            Console.WriteLine(StringUtil.JoinColumns("g1*g2 = ", g));

            VectorGaussian dx = VectorGaussian.PointMass(x);
            g.SetToProduct(g1, dx);
            Console.WriteLine(StringUtil.JoinColumns("g1*dx = ", g));
            Assert.True(g.IsPointMass);

            g.SetToProduct(dx, g2);
            Console.WriteLine(StringUtil.JoinColumns("dx*g2 = ", g));
            Assert.True(g.IsPointMass);

            DistributionTest(g1, g2);
            PointMassTest(g1, b);
            UniformTest(g1, b);
            SetMomentTest(g2, b, A);
            PointMassMomentTest(g2, x, b, A);
            g2.SetToUniform();
            Assert.True(g2.GetMean().EqualsAll(0.0));
            Assert.True(Double.IsPositiveInfinity(g2.GetVariance()[0, 0]));
            SetMomentTest(g, g.GetMean(), g.GetVariance());

            g = new VectorGaussian(Vector.FromArray(2, 3), new PositiveDefiniteMatrix(new double[,] { { 1, 0 }, { 0, 0 } }));
            Assert.True(Double.IsPositiveInfinity(g.Precision[1, 1]));
            Assert.Equal(3.0, g.Point[1]);
        }

        [Fact]
        public void VectorGaussian_GetMarginal_ReturnsUniform()
        {
            VectorGaussian vg = VectorGaussian.FromNatural(Vector.FromArray(0, 2), new PositiveDefiniteMatrix(new double[,] { { 0, 0 }, { 0, 3 } }));
            Gaussian g = vg.GetMarginal(0);
            Assert.True(g.IsUniform());
            VectorGaussian vg1 = new VectorGaussian(1);
            vg1 = vg.GetMarginal(0, vg1);
            Assert.True(vg1.IsUniform());
            VectorGaussian vg2 = new VectorGaussian(2);
            vg2 = vg.GetMarginal(0, vg2);
            Assert.True(vg.MaxDiff(vg2) < 1e-10);
        }

        [Fact]
        public void VectorGaussianMoments_SetToProduct_Singular()
        {
            PositiveDefiniteMatrix A = new PositiveDefiniteMatrix(new double[,] {
                { 4.008640513161180,  1.303104352135630, - 2.696380025254830, - 2.728465435435790 },
                { 1.303104352135630,  4.024136989099960, - 2.681070246787840, - 2.713155656968810 },
                { -2.696380025254830, - 2.681070246787840, 4.136120496920130,  1.403451295855420 },
                { -2.728465435435790, - 2.713155656968810, 1.403451295855420,  4.063123100392480 }
            });
            PositiveDefiniteMatrix B = new PositiveDefiniteMatrix(4, 4);
            B.SetToDiagonal(Vector.FromArray(1, 0, 3, 4));

            VectorGaussianMoments vg1 = new VectorGaussianMoments(Vector.FromArray(6, 5, 4, 3), A);
            VectorGaussianMoments vg2 = new VectorGaussianMoments(Vector.FromArray(1, 2, 3, 4), B);
            var product = vg1 * vg2;

            PositiveDefiniteMatrix vExpected = new PositiveDefiniteMatrix(new double[,]
            {
                { 0.699231932932321,  -0.000000000000000 , -0.330187594961638,  -0.385553717718764 },
                { -0.000000000000000,   0.000000000000000,  -0.000000000000002,   0.000000000000002 },
                { -0.330187594961638,  -0.000000000000002,   0.946948669226297,  -0.569413640803344 },
                { -0.385553717718764,   0.000000000000002,  -0.569413640803344 ,  0.926496676481940 },
            });
            Assert.True(vExpected.MaxDiff(product.Variance) < 1e-4);
            Vector meanExpected = Vector.FromArray(2.640276200841019, 2.000000014880260, 6.527941507328482, 6.908179339051594);
            Assert.True(meanExpected.MaxDiff(product.Mean) < 1e-4);

            vg2.Variance.SetToDiagonal(Vector.FromArray(1, double.PositiveInfinity, 3, 4));
            product = vg1 * vg2;
            vExpected.SetTo(new double[,] {
                { 0.703202829692760,  -0.097044359196042,  -0.287002295003263,  -0.335123696183070 },
                { -0.097044359196042,   2.371534574978036,  -1.055338156807388,  -1.232393390393070 },
                { -0.287002295003263,  -1.055338156807388,   1.416576208767429,  -0.020995915719158 },
                { -0.335123696183070,  -1.232393390393070,  -0.020995915719158,   1.566923316764467 },
            });
            Assert.True(vExpected.MaxDiff(product.Variance) < 1e-4);
            meanExpected.SetTo(new double[] { 2.495869677904531, 5.528904975989440, 4.957577684071078, 5.074347889058121 });
            Assert.True(meanExpected.MaxDiff(product.Mean) < 1e-4);
        }

        [Fact]
        public void GammaTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Gamma w = Gamma.FromMeanAndVariance(3, 7);
            Assert.True(MMath.AbsDiff(w.GetMean(), 3, 1e-6) < 1e-10);
            Assert.True(MMath.AbsDiff(w.GetVariance(), 7, 1e-6) < 1e-10);

            double a = 0.7;
            Gamma g = new Gamma();
            g.Shape = a;
            g.Rate = 2;
            GammaMomentTest(g);
            GammaMomentTest(Gamma.FromShapeAndRate(1.7, 2));
            GammaMomentTest(Gamma.PointMass(2.3));

            DistributionTest(g, new Gamma(10, 11));
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 2.2, 3.3);
            PointMassMomentTest(g, 7.7, 1.1, 2.2);
            g.SetToUniform();
            GetAndSetMomentTest(g, Double.PositiveInfinity, Double.PositiveInfinity);

            // test for round-off errors
            g.SetShapeAndRate(1e-20, 1e-20);
            GammaRoundoffTest(g);
            //DistributionTest(g, g);
            g.SetShapeAndRate(1e20, 1e20);
            GammaRoundoffTest(g);
            DistributionTest(g, Gamma.FromShapeAndRate(2e20, 2e20));

            Assert.Equal(Gamma.FromMeanAndVariance(double.MaxValue, 1), Gamma.PointMass(double.MaxValue));
            Assert.Equal(Gamma.FromMeanAndVariance(double.MaxValue / 1e100, 1e-100), Gamma.PointMass(double.MaxValue / 1e100));
            Assert.Equal(Gamma.FromMeanAndVariance(1, double.Epsilon), Gamma.PointMass(1));
            Assert.Equal(Gamma.PointMass(0), Gamma.FromShapeAndRate(2.5, double.PositiveInfinity));
            Assert.Equal(Gamma.PointMass(0), Gamma.FromShapeAndScale(2.5, 1e-320));
            Assert.Equal(Gamma.PointMass(0), new Gamma(2.5, 1e-320));
            Assert.Equal(Gamma.PointMass(0), new Gamma(2.5, 0));
            Assert.Equal(Gamma.PointMass(1e-300), Gamma.FromShapeAndRate(2, 1e300) ^ 1e10);

            ProductWithUniformTest(g);
            Gamma g2 = new Gamma();
            g2.SetToPower(g, 1.0);
            Assert.True(g2.MaxDiff(g) < 1e-12);

            Assert.Equal(double.NegativeInfinity, g.GetLogProb(double.PositiveInfinity));
            Assert.Equal(double.NegativeInfinity, g.GetLogAverageOf(Gamma.PointMass(double.PositiveInfinity)));
            Assert.Equal(double.NegativeInfinity, g.GetLogProb(0));
            g.Shape = 1;
            g.Rate = 2;
            Assert.Equal(-g.GetLogNormalizer(), g.GetLogProb(0));
            g.Rate = 0;
            Assert.Equal(0, g.GetLogProb(double.PositiveInfinity));
            Assert.Equal(0, g.GetLogProb(0));
        }

        private static void GammaRoundoffTest(Gamma a)
        {
            ProductWithUniformTest(a);
            RatioWithUniformTest(a);
            Gamma c = (a / a);
            Assert.True(c.IsUniform());
            c.SetToPower(a, 1.0);
            Assert.True(a.MaxDiff(c) < 1e-12);
            c.SetToPower(a, 0.0);
            Assert.True(c.IsUniform());
            LogAverageOfPowerTest(a, a);
        }

        [Fact]
        public void GammaSetToPowerTest()
        {
            double[,] gammaSetToPower_pairs = {
                { 1e-20, 1e-20, 0.99999999999999999999 },
                { 1e-20, 1e-10, 0.999999999899999999999999996 },
                { 1e-20, 0.1, 0.89999999999999999 },
                { 1e-20, 1, 1e-20 },
                { 1e-20, 1.1, -0.1000000000000000888 },
                { 1e-20, 1e4, -9998.9999999999999999 },
                { 1e-20, 1e16, -9999999999999998.9999 },
                { 1e-20, -1, 1.99999999999999999999 },
                { 1, 1e-20, 1 },
                { 1, 1e-10, 1 },
                { 1, 1, 1 },
                { 1, 1e4, 1 },
                { 1, 1e10, 1 },
                { 1, 1e16, 1 },
                { 1, 1e20, 1 },
                { 1, -1e20, 1 },
                { 1, -1e-20, 1 },
                { 1e4, 1e4, 99990001.0 },
                { 1e4, 1e20, 999900000000000000000001.0 },
            };

            for (int i = 0; i < gammaSetToPower_pairs.GetLength(0); i++)
            {
                double a = gammaSetToPower_pairs[i, 0];
                double e = gammaSetToPower_pairs[i, 1];
                double a2 = gammaSetToPower_pairs[i, 2];
                Gamma g = Gamma.FromShapeAndRate(a, 1);
                g.SetToPower(g, e);
                Assert.True(MMath.AbsDiff(a2, g.Shape, 1e-10) < 1e-10);
            }
        }

        private void GammaMomentTest(Gamma g)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            double m = 0, s = 0, minv = 0, m2 = 0;
            for (int i = 0; i < nsamples; i++)
            {
                double x = g.Sample();
                m = m + x;
                s = s + System.Math.Log(x);
                minv = minv + 1.0 / x;
                m2 = m2 + x * x;
            }
            m = m / nsamples;
            s = s / nsamples;
            minv = minv / nsamples;
            m2 = m2 / nsamples;
            double mTrue = g.GetMean();
            double sTrue = g.GetMeanLog();
            double m2True = g.GetMeanPower(2);
            Console.WriteLine("|m - mTrue| = {0}", System.Math.Abs(m - mTrue));
            Assert.True(System.Math.Abs(m - mTrue) < 0.05);
            Console.WriteLine("|s - sTrue| = {0}", System.Math.Abs(s - sTrue));
            Assert.True(System.Math.Abs(s - sTrue) < 0.05);
            if (g.Shape > 1)
            {
                double minvTrue = g.GetMeanInverse();
                Console.WriteLine("|minv - minvTrue| = {0}", System.Math.Abs(minv - minvTrue));
                Assert.True(System.Math.Abs(minv - minvTrue) < 0.05);
                Assert.True(System.Math.Abs(g.GetMeanPower(-1) - minvTrue) < 1e-10);
            }
            Console.WriteLine("|m2 - m2True| = {0}", System.Math.Abs(m2 - m2True));
            Assert.True(System.Math.Abs(m2 - m2True) < 0.05);
        }

        [Fact]
        public void WishartTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            int d = 3;
            double a = 1.7 + 2;
            Wishart g = Wishart.Uniform(d);
            Assert.True(g.IsUniform());
            PositiveDefiniteMatrix B = new PositiveDefiniteMatrix(new double[,] { { 2, 1, 1 }, { 1, 3, 1 }, { 1, 1, 4 } });
            g.Rate = B;
            g.Shape = a;

            // test Equals
            Wishart g1 = new Wishart(d);
            g1.Rate = B;
            g1.Shape = a;
            Assert.True(g1.Equals(g));
            Assert.True(g1.GetHashCode() == g.GetHashCode());

            // test Sample and WishartEstimator
            PositiveDefiniteMatrix X = null;
            MatrixMeanVarianceAccumulator mva = new MatrixMeanVarianceAccumulator(d, d);
            WishartEstimator est = new WishartEstimator(g.Dimension);
            double s = 0;
            for (int i = 0; i < nsamples; i++)
            {
                X = g.Sample();
                mva.Add(X);
                s = s + X.LogDeterminant();
                est.Add(X);
            }
            double sTrue = g.GetMeanLogDeterminant();
            s = s / nsamples;

            Console.WriteLine(StringUtil.JoinColumns("X = ", X));
            Console.WriteLine("eval(dx) = {0}", g.GetLogProb(X));
            Console.WriteLine("|s - sTrue| = {0}", System.Math.Abs(s - sTrue));
            Assert.True(System.Math.Abs(s - sTrue) < 0.05);
            PositiveDefiniteMatrix mTrue = new PositiveDefiniteMatrix(d, d);
            PositiveDefiniteMatrix vTrue = new PositiveDefiniteMatrix(d, d);
            g.GetMeanAndVariance(mTrue, vTrue);
            Assert.True(mTrue.MaxDiff(g.GetMean()) < 1e-10);
            Assert.True(vTrue.MaxDiff(g.GetVariance()) < 1e-10);
            Console.WriteLine("|m - mTrue| = {0}", mTrue.MaxDiff(mva.Mean));
            Assert.True(mTrue.MaxDiff(mva.Mean) < 0.05);
            Assert.True(vTrue.MaxDiff(mva.Variance) < 0.05);
            est.GetDistribution(g1);
            Console.WriteLine(g1);
            Assert.True(g.MaxDiff(g1) < 0.05);

            // test SetToProduct
            Wishart g2 = new Wishart(d);
            B = new PositiveDefiniteMatrix(new double[,] { { 3, 1, 1 }, { 1, 3, 1 }, { 1, 1, 3 } });
            g2.Rate = B;
            g2.Shape = 3.3 + 2;
            Console.WriteLine(StringUtil.JoinColumns("g2 = ", g2));

            g.SetToProduct(g1, g2);
            Console.WriteLine(StringUtil.JoinColumns("g1*g2 = ", g));

            Wishart dx = Wishart.PointMass(B);
            g.SetToProduct(g1, dx);
            Console.WriteLine(StringUtil.JoinColumns("g1*dx = ", g));
            Assert.True(g.IsPointMass);

            g.SetToProduct(dx, g2);
            Console.WriteLine(StringUtil.JoinColumns("dx*g2 = ", g));
            Assert.True(g.IsPointMass);

            // test Get/SetMeanAndVariance for a point mass
            PositiveDefiniteMatrix V = new PositiveDefiniteMatrix(d, d);
            g.GetMeanAndVariance(mTrue, vTrue);
            g.SetMeanAndVariance(mTrue, vTrue);
            g.GetMeanAndVariance(B, V);
            Assert.True(mTrue.MaxDiff(B) < 1e-10);
            Assert.True(vTrue.MaxDiff(V) < 1e-10);

            g.Rate = B;
            g.Shape = a;
            g.GetMeanAndVariance(mTrue, vTrue);
            g.SetMeanAndVariance(mTrue, vTrue);
            g.GetMeanAndVariance(B, V);
            Assert.True(mTrue.MaxDiff(B) < 1e-10);
            Assert.True(vTrue.MaxDiff(V) < 1e-10);

            DistributionTest(g, g2);
            PointMassTest(g, B);
            UniformTest(g, B);
            SetMomentTest(g, mTrue, vTrue);
            PointMassMomentTest(g, B, B, V);
            g.SetToUniform();
            Assert.True(g.GetMean().EqualsAll(Double.PositiveInfinity));
            Assert.True(Double.IsPositiveInfinity(g.GetVariance()[0, 0]));
            SetMomentTest(g, g.GetMean(), g.GetVariance());

            // test for round-off errors
            DistributionTest(new Wishart(1e-20, 1e+20), new Wishart(10, 11));
        }

        [Fact]
        public void DistributionArrayConversionTest()
        {
            Gaussian[] ga = new Gaussian[] { new Gaussian(0, 1) };
            IDistribution<double[]> dga = Distribution<double>.Array(ga);
            Gaussian[] ga2 = Distribution.ToArray<Gaussian[]>(dga);
            IDistribution<double[]> dga2 = Distribution<double>.Array(ga2);
            Assert.Equal(dga, dga2);

            Gaussian[,] ga2D = new Gaussian[,] { { new Gaussian(0, 1) } };
            IDistribution<double[,]> dga2D = Distribution<double>.Array(ga2D);
            Gaussian[,] ga2D2 = Distribution.ToArray<Gaussian[,]>(dga2D);
            IDistribution<double[,]> dga2D2 = Distribution<double>.Array(ga2D2);
            Assert.Equal(dga2D, dga2D2);

            Gaussian[][] gaa = new Gaussian[][] { new Gaussian[] { new Gaussian(0, 1) } };
            IDistribution<double[][]> dgaa = Distribution<double>.Array(gaa);
            Gaussian[][] gaa2 = Distribution.ToArray<Gaussian[][]>(dgaa);
            IDistribution<double[][]> dgaa2 = Distribution<double>.Array(gaa2);
            Assert.Equal(dgaa, dgaa2);

            Gaussian[,][] ga2Da = new Gaussian[,][] { { new Gaussian[] { new Gaussian(0, 1) } } };
            IDistribution<double[,][]> dga2Da = Distribution<double>.Array(ga2Da);
            Gaussian[,][] ga2Da2 = Distribution.ToArray<Gaussian[,][]>(dga2Da);
            IDistribution<double[,][]> dga2Da2 = Distribution<double>.Array(ga2Da2);
            Assert.Equal(dga2Da, dga2Da2);

            Gaussian[][,] gaa2D = new Gaussian[][,] { new Gaussian[,] { { new Gaussian(0, 1) } } };
            IDistribution<double[][,]> dgaa2D = Distribution<double>.Array(gaa2D);
            Gaussian[][,] gaa2D2 = Distribution.ToArray<Gaussian[][,]>(dgaa2D);
            IDistribution<double[][,]> dgaa2D2 = Distribution<double>.Array(gaa2D2);
            Assert.Equal(dgaa2D, dgaa2D2);

            Gaussian[][][] gaaa = new Gaussian[][][] { new Gaussian[][] { new Gaussian[] { new Gaussian(0, 1) } } };
            IDistribution<double[][][]> dgaaa = Distribution<double>.Array(gaaa);
            Gaussian[][][] gaaa2 = Distribution.ToArray<Gaussian[][][]>(dgaaa);
            IDistribution<double[][][]> dgaaa2 = Distribution<double>.Array(gaaa2);
            Assert.Equal(dgaaa, dgaaa2);
        }

#pragma warning disable CA2013
        [Fact]
        public void GaussianArrayTest()
        {
            Gaussian g = new Gaussian(0, 1);
            GaussianArray2D a = new GaussianArray2D(new Gaussian(), 3, 2);
            Assert.False(object.ReferenceEquals(a[0], a[1]));
            a.ForEach(delegate (Gaussian item)
            { Assert.True(item.IsUniform()); });
            //GaussianArray a = new GaussianArray(new Gaussian[3,2]);
            //a.ModifyAll(delegate(Gaussian item) { return new Gaussian(); });
            a.SetAllElementsTo(g);
            a[0] = new Gaussian(0, 2);
            Console.WriteLine("a[0] = " + a[0]);
            foreach (Gaussian item in a)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine(a);
            Assert.Equal(g, a[1]);
            Assert.Equal(g, a[0, 1]);
            //Assert.Equal(g, a[new int[] { 0, 1 }]);
            Assert.Equal(1, a.IndexOf(g));
            Assert.Contains(g, a);
            Assert.Equal(1, a.FindIndex(delegate (Gaussian item)
            { return (item.GetVariance() == 1); }));
            GaussianArray2D b = (GaussianArray2D)a.Clone();
            Assert.False(object.ReferenceEquals(b[0], a[0]));
            b.SetTo(a);
            Assert.False(object.ReferenceEquals(b[0], a[0]));
            a.SetToProduct(a, a);
            Assert.True(a[0].MaxDiff(Gaussian.FromMeanAndPrecision(0, 1)) < 1e-10);
            Assert.True(a[1].MaxDiff(Gaussian.FromMeanAndPrecision(0, 2)) < 1e-10);

            DistributionTest(a, new GaussianArray2D(new Gaussian(4, 5), 3, 2));

            a.SetToUniform();
            a.ForEach(delegate (Gaussian item)
            { Assert.True(item.IsUniform()); });
            //UniformTest(a,new double[3,2]);

            b = new GaussianArray2D(new Gaussian(), 3, 3);
            Assert.True(!a.Equals(b));
        }
#pragma warning restore

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

#if false
        [Fact]
        public void GaussianCursorArrayTest()
        {
            VectorGaussian g = new VectorGaussian(3);
            GaussianCursorArray a = new GaussianCursorArray(g, 3, 2);
            int i = 0;
            foreach (VectorGaussian item in a) {
                item.MeanTimesPrecision.SetAllElementsTo(i++);
                item.Precision.SetToIdentity();
            }

            VectorGaussian g2 = new VectorGaussian(3);
            int[] keepAll = new int[] { 0, 1 };
            GaussianCursorArray a2 = new GaussianCursorArray(g2, 3, 2);
            a.ReduceTo(keepAll, a2);
            Console.WriteLine("ReduceTo[0,1]:");
            Console.WriteLine(a2);

            VectorGaussian g3 = new VectorGaussian(3);
            int[] keep1 = new int[] { 0 };
            GaussianCursorArray a3 = new GaussianCursorArray(g3, 3);
            a.ReduceTo(keep1, a3);
            Console.WriteLine("ReduceTo[0]:");
            Console.WriteLine(a3);
            Assert.True(a3[0].MeanTimesPrecision[0] == 1);
            Assert.True(a3[1].MeanTimesPrecision[0] == 5);
            Assert.True(a3[2].MeanTimesPrecision[0] == 9);

            int[] keep2 = new int[] { 1 };
            a3 = new GaussianCursorArray(g3, 2);
            a.ReduceTo(keep2, a3);
            Console.WriteLine("ReduceTo[1]:");
            Console.WriteLine(a3);
            Assert.True(a3[0].MeanTimesPrecision[0] == 6);
            Assert.True(a3[1].MeanTimesPrecision[0] == 9);

            a.ReduceTo(g3);
            Console.WriteLine("ReduceTo[]:");
            Console.WriteLine(g3);
            Assert.True(g3.MeanTimesPrecision[0] == 15);

            a.SetToProduct(a, a);
            Console.WriteLine("SetToProduct:");
            Console.WriteLine(a);

#if false
            a2.Point = a.Sample();
            Console.WriteLine("Sample:");
            Console.WriteLine(a2);
#endif

            a2.SetTo(a);
            Console.WriteLine("SetTo:");
            Console.WriteLine(a);
            Assert.True(a.Equals(a2));
            Assert.True(a.MaxDiff(a2) == 0);

            GaussianCursorArray a3r = a3.Replicate(new int[] { 3, 2 }, new int[] { 1 });
            Console.WriteLine("Replicate[1]:");
            Console.WriteLine(a3r);

            DistributionCursorArray<GaussianCursorArray, Vector[]> jagged;
            try {
                jagged = a.Split(new bool[] { false, false });
                Debug.Fail("Split[F,F] did not fail");
            } catch (ArgumentException ex) {
                Console.WriteLine("Split[F,F] correctly failed with error: " + ex);
            }
            try {
                jagged = a.Split(new bool[] { true, true });
                Debug.Fail("Split[T,T] did not fail");
            } catch (ArgumentException ex) {
                Console.WriteLine("Split[T,T] correctly failed with error: " + ex);
            }
            jagged = a.Split(new bool[] { true, false });
            Console.WriteLine("Split[T,F]:");
            Console.WriteLine(jagged);
            jagged = a.Split(new bool[] { false, true });
            Console.WriteLine("Split[F,T]:");
            Console.WriteLine(jagged);
        }
#endif

        [Fact]
        public void BernoulliTest()
        {
            Assert.Equal(0.0, Bernoulli.LogitProbEqual(0, 0));
            Assert.Equal(0.0, Bernoulli.LogitProbEqual(0, Double.PositiveInfinity));
            Assert.Equal(Double.PositiveInfinity, Bernoulli.LogitProbEqual(Double.PositiveInfinity, Double.PositiveInfinity));
            Assert.Equal(Double.NegativeInfinity, Bernoulli.LogitProbEqual(Double.PositiveInfinity, Double.NegativeInfinity));
            Assert.Equal(Double.PositiveInfinity, Bernoulli.LogitProbEqual(Double.NegativeInfinity, Double.NegativeInfinity));

            Bernoulli b = new Bernoulli(0.1);
            DistributionTest(b, new Bernoulli(0.9));
            PointMassTest(b, true);
            UniformTest(b, true);
            b.SetMean(0.1);
            Assert.True(AbsDiff(0.1, b.GetMean()) < 1e-10);
            b.Point = false;
            Assert.True(AbsDiff(0.0, b.GetMean()) < 1e-10);
            b.SetMean(0.0);
            Assert.True(AbsDiff(0.0, b.GetMean()) < 1e-10);
            Assert.True(b.IsPointMass);
            Assert.False(b.Point);

            // Test the LogitProbEqual calculation
            double logodds1 = -2.0;
            double logodds2 = 0.5;
            Bernoulli b1 = Bernoulli.FromLogOdds(logodds1);
            Bernoulli b2 = Bernoulli.FromLogOdds(logodds2);
            double probtrue1 = b1.GetProbTrue();
            double probtrue2 = b2.GetProbTrue();
            double probx1Eqx2 = (probtrue1 * probtrue2) + (1 - probtrue1) * (1 - probtrue2);
            double logoddsCalc = MMath.Logit(probx1Eqx2);
            double logoddsFunc = Bernoulli.LogitProbEqual(logodds1, logodds2);
            Assert.True(AbsDiff(logoddsCalc, logoddsFunc) < 1e-10);
        }

        [Fact]
        public void DiscreteTest()
        {
            Assert.True(new Discrete(0, 0.71743990380862455, 0.2825600961913754).GetLogAverageOf(Discrete.Uniform(3)) == -System.Math.Log(3));

            Discrete d = new Discrete(0.9, 0.1);
            DistributionTest(d, new Discrete(0.2, 0.8));
            PointMassTest(d, 1);
            UniformTest(d, 1);
            PointMassMomentTest(d, 1, 0.2, 0.1);
            d.SetToUniform();
            GetMomentTest(d, 0.5, 0.25);
            SamplingTest(d, 1);

            Discrete d1 = new Discrete(0.1, 0.9, 0, 0);
            Discrete d2 = new Discrete(0, 0, 0.3, 0.7);
            Assert.True(MMath.AbsDiff(d2.GetAverageLog(d2), 0.3 * System.Math.Log(0.3) + 0.7 * System.Math.Log(0.7), 1 - 6) < 1e-10);
            try
            {
                Discrete d3 = d1 * d2;
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }
            try
            {
                Discrete d3 = new Discrete(0, 0, 0);
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }
            try
            {
                d.SetProbs(Vector.FromArray(0.0, 0.0));
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }

            d = new Discrete(1.0);
            Assert.Equal(0, d.Sample());
            Assert.Equal(0, d.Sample(4));
            Vector p = d.GetWorkspace();
            p[0] = 2.0;
            d.SetProbs(p);
            Assert.Equal(0.0, d.MaxDiff(Discrete.Uniform(1)));
            d = Discrete.PointMass(0, 1);
            DistributionTest(d, new Discrete(1.0));
            UniformTest(d, 0);
            PointMassMomentTest(d, 0, 0.2, 0.1);
            d.SetToUniform();
            GetMomentTest(d, 0.0, 0.0);

            d = Discrete.Uniform(0);
            DistributionTest(d, new Discrete());

            // Sampling when probability vector is sparse
            double[] pcd1 = new double[] { 0.1, 0.3, 0.4, 0.1, 0.1 };
            double[] pcd2 = new double[] { 0.0, 0.4, 0.6, 0.0, 0.0 };
            Vector[] pcv1 = new Vector[4];
            Vector[] pcv2 = new Vector[4];
            Sparsity approxSparsity = Sparsity.ApproximateWithTolerance(0.001);
            pcv1[0] = Vector.FromArray(pcd1);
            pcv1[1] = Vector.FromArray(pcd1, Sparsity.Sparse);
            pcv1[2] = Vector.FromArray(pcd1, approxSparsity);
            pcv1[3] = DenseVector.FromArrayReference(3, pcd1, 2);
            pcv2[0] = Vector.FromArray(pcd2);
            pcv2[1] = Vector.FromArray(pcd2, Sparsity.Sparse);
            pcv2[2] = Vector.FromArray(pcd2, approxSparsity);
            pcv2[3] = DenseVector.FromArrayReference(3, pcd2, 2);
            for (int i = 0; i < pcv1.Length; i++)
            {
                SamplingTest(new Discrete(pcv1[i]), 1);
                SamplingTest(new Discrete(pcv2[i]), 1);
            }

            d = new Discrete(1.0);
            Assert.Equal(0, d.GetMedian());
            d = new Discrete(0.1, 0.2, 0.0, 0.7);
            Assert.Equal(3, d.GetMedian());

            // Test partial uniform
            d = new Discrete(SparseVector.FromArray(0.0, 0.5, 0.5, 0.0));
            Assert.True(d.IsPartialUniform());
            d.SetToUniform();
            Assert.True(d.IsPartialUniform());
            d = new Discrete(SparseVector.FromArray(0.0, 0.3, 0.7, 0.0));
            Assert.False(d.IsPartialUniform());
            d.SetToPartialUniformOf(d);
            Assert.True(d.IsPartialUniform());
            d = new Discrete(SparseVector.FromArray(0.0, 0.3, 0.6, 0.1));
            Assert.False(d.IsPartialUniform());
            d.Point = 1;
            Assert.True(d.IsPartialUniform());
            d2 = Discrete.PointMass(2, 4);
            d.SetToPartialUniformOf(d2);
            Assert.True(d.IsPartialUniform());
            Assert.True(d.IsPointMass && d.Point == 2);
        }

        [Fact]
        [Trait("Category", "ModifiesGlobals")]
        public void DirichletTest()
        {
            Vector mTrue = Vector.FromArray(0.1, 0.2, 0.3, 0.4);
            Dirichlet d = new Dirichlet(mTrue * 7);
            Vector vTrue = Vector.Zero(d.Dimension);
            Vector m = Vector.Zero(d.Dimension);
            Vector v = Vector.Zero(d.Dimension);
            d.GetMeanAndVariance(mTrue, vTrue);
            d.SetMeanAndVariance(mTrue, vTrue);
            d.GetMeanAndVariance(m, v);
            Assert.True(mTrue.MaxDiff(m) < 1e-10);
            Assert.True(vTrue.MaxDiff(v) < 1e-10);

            DistributionTest(d, Dirichlet.Symmetric(d.Dimension, 7.7));
            using (TestUtils.TemporarilyAllowDirichletImproperSums)
            {
                DistributionTest(d, Dirichlet.Symmetric(d.Dimension, 7.7));
            }
            PointMassTest(d, mTrue);
            UniformTest(d, mTrue);
            SetMomentTest(d, mTrue, vTrue);
            PointMassMomentTest(d, mTrue, m, vTrue);
            d.SetToUniform();
            GetAndSetMomentTest(d,
                                Vector.Constant(4, 0.25),
                                Vector.Constant(4, 0.25 * 0.75 / 5));

            DirichletSamplingTest(d);

            // Small pseudocount test
            DirichletSamplingTest(new Dirichlet(1e-5, 2e-5, 3e-5, 4e-5));

            // Small/large pseudocount test
            DirichletSamplingTest(new Dirichlet(1e-5, 2e5, 3e5, 4e-5));

            // Sparse vector pseudocount tests
            double[] pcd1 = new double[] { 1.2, 2.3, 3.4, 1.2, 1.2 };
            double[] pcd2 = new double[] { 0.0, 2.3, 3.4, 0.0, 0.0 };
            Vector[] pcv1 = new Vector[4];
            Vector[] pcv2 = new Vector[4];
            Sparsity approxSparsity = Sparsity.ApproximateWithTolerance(0.001);
            pcv1[0] = Vector.FromArray(pcd1);
            pcv1[1] = Vector.FromArray(pcd1, Sparsity.Sparse);
            pcv1[2] = Vector.FromArray(pcd1, approxSparsity);
            pcv1[3] = DenseVector.FromArrayReference(3, pcd1, 2);
            pcv2[0] = Vector.FromArray(pcd2);
            pcv2[1] = Vector.FromArray(pcd2, Sparsity.Sparse);
            pcv2[2] = Vector.FromArray(pcd2, approxSparsity);
            pcv2[3] = DenseVector.FromArrayReference(3, pcd2, 2);
            for (int i = 0; i < pcv1.Length; i++)
            {
                DirichletSamplingSparseTest(new Dirichlet(pcv1[i]));
                DirichletSamplingSparseTest(new Dirichlet(pcv2[i]));
            }
        }

        private static void DirichletSamplingTest(Dirichlet d)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Vector sample = Vector.Zero(d.Dimension);
            Vector meanSample = Vector.Zero(d.Dimension);
            Vector mean2Sample = Vector.Zero(d.Dimension);
            Vector mean3Sample = Vector.Zero(d.Dimension);
            Vector meanLogSample = Vector.Zero(d.Dimension);
            Vector temp = Vector.Zero(d.Dimension);
            for (int i = 0; i < nsamples; i++)
            {
                d.Sample(sample);
                meanSample.SetToSum(meanSample, sample);
                mean2Sample.SetToSum(mean2Sample, temp.SetToFunction(sample, x => x * x));
                mean3Sample.SetToSum(mean3Sample, temp.SetToFunction(sample, x => x * x * x));
                meanLogSample.SetToSum(meanLogSample, temp.SetToFunction(sample, System.Math.Log));
            }
            meanSample.Scale(1.0 / nsamples);
            mean2Sample.Scale(1.0 / nsamples);
            mean3Sample.Scale(1.0 / nsamples);
            meanLogSample.Scale(1.0 / nsamples);
            Vector mean = d.GetMean();
            Console.WriteLine("mean = {0} should be {1}", meanSample, mean);
            Assert.True(mean.MaxDiff(meanSample) < 5e-3);
            Vector mean2 = d.GetMeanSquare();
            Console.WriteLine("mean2 = {0} should be {1}", mean2Sample, mean2);
            Assert.True(mean2.MaxDiff(mean2Sample) < 5e-3);
            Vector mean3 = d.GetMeanCube();
            Console.WriteLine("mean3 = {0} should be {1}", mean3Sample, mean3);
            Assert.True(mean3.MaxDiff(mean3Sample) < 5e-3);
            Vector meanLog = d.GetMeanLog();
            Console.WriteLine("meanLog = {0} should be {1}", meanLogSample, meanLog);
            if (meanLog.Min() > -70)
            {
                Assert.True(meanLog.MaxDiff(meanLogSample) < 1e-2);
            }
        }

        private static void DirichletSamplingSparseTest(Dirichlet d)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Vector v = d.PseudoCount;
            Vector result = null;

            // Check both versions
            for (int pass = 0; pass < 2; pass++)
            {
                if (pass == 0)
                {
                    result = Vector.Constant(v.Count, 1.234, v.Sparsity);
                    d.Sample(result);
                }
                else
                    result = d.Sample();

                // Check that if any pseudo-counts are 0, then the sample is 0
                // Check for non zero that there are no repeat elements in the sample
                Dictionary<double, bool> dic = new Dictionary<double, bool>();
                for (int i = 0; i < v.Count; i++)
                {
                    double r = result[i];
                    if (v[i] == 0.0)
                        Assert.Equal(0.0, r);
                    else
                    {
                        // Here we are testing that a sparse Dirichlet is not generating the same
                        // sample value for all common value indices
                        if (dic.ContainsKey(r))
                            Assert.True(false, "Dirichlet sampler: repeat element");
                        dic[r] = true;
                    }
                }
            }
        }

        [Fact]
        public void DirichletEstimateNewtonTest()
        {
            Vector alphaTrue = Vector.FromArray(0.1, 0.2, 0.3, 0.4);
            alphaTrue.Scale(7);
            DirichletEstimateNewton(alphaTrue);
        }

        private void DirichletEstimateNewton(Vector alphaTrue)
        {
            Dirichlet d = new Dirichlet(alphaTrue);
            Vector meanLog = d.GetMeanLog();
            Console.WriteLine(meanLog);
            d.SetToUniform();
            d.SetMeanLog(meanLog);
            Console.WriteLine("pseudoCount = {0} should be {1}", d.PseudoCount, alphaTrue);
            Assert.True(alphaTrue.MaxDiff(d.PseudoCount) < 1e-6);
        }

        [Fact]
        public void DirichletModeTest()
        {
            Dirichlet d = null;
            Vector v = null;
            for (int iter = 0; iter < 7; iter++)
            {
                if (iter == 0)
                {
                    d = new Dirichlet(0.1, 0.3, 0.4);
                    v = Vector.FromArray(0, 0, 1);
                }
                else if (iter == 1)
                {
                    d = new Dirichlet(1, 0.3, 0.4);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 2)
                {
                    d = new Dirichlet(1.1, 0.3, 0.4);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 3)
                {
                    d = new Dirichlet(0.3, 1, 1);
                    v = Vector.FromArray(0, 0.5, 0.5);
                }
                else if (iter == 4)
                {
                    d = new Dirichlet(1, 1, 1);
                    v = Vector.FromArray(1.0 / 3, 1.0 / 3, 1.0 / 3);
                }
                else if (iter == 5)
                {
                    d = new Dirichlet(1.3, 1, 1);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 6)
                {
                    d = new Dirichlet(3, 4, 5);
                    double denom = 3 + 4 + 5 - 3;
                    v = Vector.FromArray(2.0 / denom, 3.0 / denom, 4.0 / denom);
                }
                Vector mode = d.GetMode();
                Console.WriteLine("{0}: {1} (should be {2})", d, mode, v);
                Assert.True(mode.MaxDiff(v) < 1e-10);
            }
        }

        [Fact]
        [Trait("Category", "ModifiesGlobals")]
        public void BetaTest()
        {
            Beta d = new Beta(0.2, 0.1);

            DistributionTest(d, new Beta(4.4, 3.3));
            using (TestUtils.TemporarilyAllowBetaImproperSums)
            {
                DistributionTest(d, new Beta(4.4, 3.3));
            }
            PointMassTest(d, 0.7);
            UniformTest(d, 0.7);
            PointMassMomentTest(d, 0.6, 0.2, 0.1);
            d.SetToUniform();
            GetAndSetMomentTest(d, 0.5, 1.0 / 12);
            SamplingTest(d, 0.7);
            SamplingTest(new Beta(1e-5, 2e-5), 0.7);
        }

        internal void BetaEstimateNewtonTest()
        {
            Beta d = new Beta(0.2, 0.1);
            double eLogP, eLogOneMinusP;
            d.GetMeanLogs(out eLogP, out eLogOneMinusP);
            Beta d2 = Beta.FromMeanLogs(eLogP, eLogOneMinusP);
            Console.WriteLine("FromMeanLogs = {0} should be {1}", d2, d);
            Assert.True(d.MaxDiff(d2) < 1e-6);
        }

        internal void BetaFromDerivativesTest()
        {
            Beta d = new Beta(0.2, 0.1);
            double x = 0.3;
            double delta = 1e-7;
            double dLogP, ddLogP;
            dLogP = (d.GetLogProb(x + delta) - d.GetLogProb(x - delta)) / (2 * delta);
            //ddLogP = (d.GetLogProb(x + delta) - 2*d.GetLogProb(x) + d.GetLogProb(x - delta)) / (delta*delta);
            ddLogP = -(d.TrueCount - 1) / x / x - (d.FalseCount - 1) / (1 - x) / (1 - x);
            Beta d2 = Beta.FromDerivatives(x, dLogP, ddLogP, false);
            Console.WriteLine("FromDerivatives = {0} should be {1}", d2, d);
            Assert.True(d.MaxDiff(d2) < 1e-6);
        }

        [Fact]
        public void PoissonTest()
        {
            Rand.Restart(12347);
            double rate = 0.3;
            Poisson geo = new Poisson(rate, 0);
            double m = rate / (1 - rate);
            Assert.True(MMath.AbsDiff(m, geo.GetMean()) < 1e-10);
            Assert.True(MMath.AbsDiff(m / (1 - rate), geo.GetVariance()) < 1e-10);
            // m=0.3; x = 0:1000; sum(m.^x*(1-m).*gammaln(x+1))
            Assert.True(MMath.AbsDiff(0.109116895970604, geo.GetMeanLogFactorial()) < 1e-10);

            Poisson d = new Poisson(1.2);
            PointMassTest(d, 3);
            UniformTest(d, 3);
            PointMassMomentTest(d, 3, 0.2, 0.1);
            GetAndSetMomentTest(d, 1.2, 1.2);
            DistributionTest(d, new Poisson(3.4));
            SamplingTest(d, 3);

            rate = 0.5;
            for (int i = 0; i < 6; i++)
            {
                d = new Poisson(rate);
                SamplingTest(d, 3);
                rate *= 10;
                rate += 0.5;
            }
        }

        [Fact]
        public void PoissonTest2()
        {
            Poisson d = new Poisson(1.2, 0.4);
            double sum = 0;
            double sumX = 0, sumX2 = 0;
            double sumLogFact = 0;
            double sumLogFact2 = 0;
            double sumXLogFact = 0;
            for (int i = 0; i < 1000; i++)
            {
                double p = System.Math.Exp(d.GetLogProb(i));
                sum += p;
                sumX += i * p;
                sumX2 += i * i * p;
                double logFact = MMath.GammaLn(i + 1);
                sumLogFact += logFact * p;
                sumLogFact2 += logFact * logFact * p;
                sumXLogFact += i * logFact * p;
            }
            double meanEst = sumX / sum;
            double varEst = sumX2 / sum - meanEst * meanEst;
            double meanLogFactEst = sumLogFact / sum;
            double meanLogFact2Est = sumLogFact2 / sum;
            double meanXLogFactEst = sumXLogFact / sum;
            double Z = System.Math.Exp(Poisson.GetLogNormalizer(d.Rate, d.Precision));
            double mean = System.Math.Exp(Poisson.GetLogPowerSum(d.Rate, d.Precision, 1)) / Z;
            double var = System.Math.Exp(Poisson.GetLogPowerSum(d.Rate, d.Precision, 2)) / Z - mean * mean;
            double meanLogFact = d.GetMeanLogFactorial();
            double meanLogFact2 = Poisson.GetSumLogFactorial2(d.Rate, d.Precision) / Z;
            double meanXLogFact = Poisson.GetSumXLogFactorial(d.Rate, d.Precision) / Z;
            Assert.True(MMath.AbsDiff(mean, meanEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(var, varEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanLogFact, meanLogFactEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanLogFact2, meanLogFact2Est, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanXLogFact, meanXLogFactEst, 1e-6) < 1e-4);
            double varLogFact = meanLogFact2 - meanLogFact * meanLogFact;
            double covXLogFact = meanXLogFact - mean * meanLogFact;

            Poisson d2 = Poisson.FromMeanAndMeanLogFactorial(mean, meanLogFact);
            Console.WriteLine("d2 = {0} should be {1}", d2, d);
            Assert.True(d2.MaxDiff(d) < 1e-4);

            PointMassTest(d, 3);
            UniformTest(d, 3);
            PointMassMomentTest(d, 3, 0.2, 0.1);
            //SetMomentTest(d, 1.2, 3.4);
            DistributionTest(d, new Poisson(3.4, 1.5));
            SamplingTest(d, 3);
        }

        [Fact]
        public void PoissonTest3()
        {
            double mean = 38.914480999999995;
            double meanLogFact = 115.79687593320728;
            // These cannot be satisfied:
            //double mean = 26.503113193371764;
            //double meanLogFact = 77.463522658901041;
            // Poisson expected = new Poisson(1.09452821574556, 0.029552860669053);
            var actual = Poisson.FromMeanAndMeanLogFactorial(mean, meanLogFact);
            double actualMean = actual.GetMean();
            double actualMeanLogFact = actual.GetMeanLogFactorial();
            Assert.True(MMath.AbsDiff(actualMean, mean) < 1e-4);
            Assert.True(MMath.AbsDiff(actualMeanLogFact, meanLogFact) < 1e-4);
        }

        [Fact]
        public void BetaSumTest()
        {
            Beta b1 = new Beta(2, 2);
            Beta b2 = new Beta(3, 3);
            Beta b = new Beta();
            b.SetToSum(0.9, b1, 0.1, b2);
            Console.WriteLine(b);
        }

        [Fact]
        public void DirichletSumTest()
        {
            Beta b1 = new Beta(2, 1);
            Beta b2 = new Beta(4, 3);
            Beta b = new Beta();
            b.SetToSum(0.9, b1, 0.1, b2);

            Dirichlet d1 = new Dirichlet(1.0, 2);
            Dirichlet d2 = new Dirichlet(3.0, 4);
            Dirichlet d = Dirichlet.Uniform(2);
            d.SetToSum(0.9, d1, 0.1, d2);

            Assert.True(MMath.AbsDiff(d.TotalCount, b.TotalCount, 1e-6) < 1e-10);
            Assert.True(d.PseudoCount.MaxDiff(Vector.FromArray(b.FalseCount, b.TrueCount)) < 1e-10);
        }

        [Fact]
        public void DirichletSumMergeTest()
        {
            Dirichlet d1 = new Dirichlet(2.0, 3.5, 5, 7);
            Dirichlet d2 = new Dirichlet(1.0, 4, 5, 7);
            Dirichlet d = Dirichlet.Uniform(d1.Dimension);
            d.SetToSum(0.9, d1, 0.1, d2);

            Dirichlet s1 = new Dirichlet(2.0, 3.5, 12);
            Dirichlet s2 = new Dirichlet(1.0, 4, 12);
            Dirichlet s = Dirichlet.Uniform(s1.Dimension);
            s.SetToSum(0.9, s1, 0.1, s2);

            Vector dMean = d.GetMean();
            Vector sMean = s.GetMean();
            Vector dMean2 = Vector.Zero(sMean.Count);
            dMean2[0] = dMean[0];
            dMean2[1] = dMean[1];
            dMean2[2] = dMean[2] + dMean[3];
            Assert.True(dMean2.MaxDiff(sMean) < 1e-10);
            Assert.True(MMath.AbsDiff(d.TotalCount, s.TotalCount, 1e-6) < 1e-10);
        }

        [Fact]
        public void GaussianSetToRatioProperTest()
        {
            Gaussian numerator = new Gaussian(5, 4);
            Gaussian denominator = new Gaussian(3, 2);
            Gaussian r = new Gaussian();
            r.SetToRatio(numerator, denominator, true);
            Console.WriteLine("ratio: {0}", r);
            Console.WriteLine("ratio*denom: {0} (should be {1})", r * denominator, new Gaussian(5, 2));
            Assert.True(MMath.AbsDiff((r * denominator).GetMean(), numerator.GetMean(), 1e-8) < 1e-10);
        }

        [Fact]
        public void GammaGetProbLessThanTest()
        {
            // exponential distribution with density exp(-x/m)/m and cdf 1-exp(-x/m)
            double m = 2.3;
            Gamma g = new Gamma(1.0, m);
            double median = -m * System.Math.Log(0.5);
            Assert.Equal(0.5, g.GetProbLessThan(median), 1e-4);
            AssertAlmostEqual(median, g.GetQuantile(0.5));

            g = new Gamma(2, m);
            double probability = g.GetProbLessThan(median);
            double quantile = g.GetQuantile(probability);
            Assert.Equal(median, quantile, 1e-10);
        }

        internal static void AssertAlmostEqual(double x, double y)
        {
            Assert.False(SpecialFunctionsTests.IsErrorSignificant(1e-16, x - y));
        }

        [Fact]
        public void GammaModeTest()
        {
            Gamma g = new Gamma();
            double expected = 0;
            for (int i = 0; i < 7; i++)
            {
                if (i == 0)
                {
                    g = Gamma.FromShapeAndRate(0.1, 0);
                    expected = 0;
                }
                else if (i == 1)
                {
                    g = Gamma.FromShapeAndRate(0.1, 2);
                    expected = 0;
                }
                else if (i == 2)
                {
                    g = Gamma.FromShapeAndRate(1, 2);
                    expected = 0;
                }
                else if (i == 3)
                {
                    g = Gamma.FromShapeAndRate(0, 2);
                    expected = 0;
                }
                else if (i == 4)
                {
                    g = Gamma.FromShapeAndRate(1.1, 2);
                    expected = 0.1 / 2;
                }
                else if (i == 5)
                {
                    g = Gamma.FromShapeAndRate(1, 0);
                    expected = 0;
                }
                else if (i == 6)
                {
                    g = Gamma.FromShapeAndRate(1.1, 0);
                    expected = double.PositiveInfinity;
                }
                double m = g.GetMode();
                Console.WriteLine("{0}: {1} (should be {2})", g, m, expected);
                Assert.True(MMath.AbsDiff(m, expected, 1e-10) < 1e-10);
            }
        }

        [Fact]
        public void GammaSetToRatioTest()
        {
            Gamma numerator = Gamma.FromShapeAndRate(1e20, 1);
            Gamma denominator = numerator;
            Gamma r = numerator / denominator;
            Assert.True(r.IsUniform());
        }

        [Fact]
        public void GammaSetToRatioProperTest()
        {
            foreach (Gamma numerator in new[] {
                Gamma.FromShapeAndRate(0.5, 0.5),
                Gamma.FromShapeAndRate(4, 5),
            })
            {
                foreach (var denominator in new[]
                {
                    Gamma.Uniform(),
                    Gamma.FromShapeAndRate(6, 3),
                    Gamma.FromShapeAndRate(6,7),
                    Gamma.FromShapeAndRate(3,7)
                })
                {
                    Gamma r = new Gamma();
                    r.SetToRatio(numerator, denominator, true);
                    //Trace.WriteLine($"ratio: {r} ratio*denom: {r * denominator} (numerator was {numerator})");
                    Assert.True(r.Shape >= 1);
                    Assert.True(r.Rate >= 0);
                    Assert.True(MMath.AbsDiff((r * denominator).GetMean(), numerator.GetMean(), 1e-8) < 1e-10);
                    // It is counter-intuitive that uniform denominator doesn't return numerator.
                    //if (denominator.IsUniform()) Assert.Equal(numerator, r);
                }
            }
        }

        [Fact]
        public void WishartSetToRatioProperTest()
        {
            int dim = 1;
            Wishart numerator = Wishart.FromShapeAndRate(4, PositiveDefiniteMatrix.IdentityScaledBy(dim, 5));
            foreach (Wishart denominator in new[] {
                Wishart.FromShapeAndRate(6, PositiveDefiniteMatrix.IdentityScaledBy(dim, 3)),
                Wishart.FromShapeAndRate(6, PositiveDefiniteMatrix.IdentityScaledBy(dim, 7)),
                Wishart.FromShapeAndRate(3, PositiveDefiniteMatrix.IdentityScaledBy(dim, 7)),
            })
            {
                Wishart r = new Wishart(dim);
                r.SetToRatio(numerator, denominator, true);
                //Trace.WriteLine($"ratio: {r} ratio*denom: {r * denominator} (numerator was {numerator})");
                Assert.True(r.Shape >= (dim + 1) / 2.0);
                Assert.True((r * denominator).GetMean().MaxDiff(numerator.GetMean()) < 1e-10);
            }
        }

        [Fact]
        public void GammaFromMeanAndMeanLogTest()
        {
            GammaFromMeanAndMeanLog(new Gamma(3, 4));
            GammaFromMeanAndMeanLog(Gamma.PointMass(3));
            Gamma estimated = Gamma.FromMeanAndMeanLog(0, -1e303);
            Assert.True(estimated.IsPointMass && estimated.Point == 0);
        }

        private void GammaFromMeanAndMeanLog(Gamma original)
        {
            double mean = original.GetMean();
            double meanLog = original.GetMeanLog();
            Gamma estimated = Gamma.FromMeanAndMeanLog(mean, meanLog);
            //Console.WriteLine("original = {0}", original);
            //Console.WriteLine("estimated = {0}", estimated);
            Assert.True(original.MaxDiff(estimated) < 1e-10);
        }

        [Fact]
        public void WishartFromMeanAndMeanLogTest()
        {
            PositiveDefiniteMatrix m3 = new PositiveDefiniteMatrix(new double[,] { { 4, 2, 1 }, { 2, 4, 2 }, { 1, 2, 4 } });
            PositiveDefiniteMatrix m2 = new PositiveDefiniteMatrix(new double[,] { { 2, 1 }, { 1, 2 } });
            WishartFromMeanAndMeanLog(new Wishart(3, m2));
            WishartFromMeanAndMeanLog(Wishart.PointMass(m2));
            WishartFromMeanAndMeanLog(new Wishart(4, m3));
            WishartFromMeanAndMeanLog(Wishart.PointMass(m3));
        }

        private void WishartFromMeanAndMeanLog(Wishart original)
        {
            var mean = original.GetMean();
            double meanLog = original.GetMeanLogDeterminant();
            var estimated = Wishart.FromMeanAndMeanLogDeterminant(mean, meanLog);
            Console.WriteLine("original = {0}", original);
            Console.WriteLine("estimated = {0}", estimated);
            Assert.True(original.MaxDiff(estimated) < 1e-10);
        }

        [Fact]
        [Trait("Category", "StringInference")]
        public void StringDistributionTest()
        {
            StringDistribution dist1 = StringDistribution.OneOf("a", "ab", "bcd");
            StringDistribution dist2 = StringDistribution.Capitalized();
            StringDistribution dist3 = StringDistribution.Upper().Append(StringDistribution.Lower());

            stringDistributionTest(dist1, dist2);
            stringDistributionTest(dist1, dist3);
            stringDistributionTest(dist2, dist3);

            StringDistributionPointMassTest(dist1, "ab");
            StringDistributionPointMassTest(dist2, "Abc");
            StringDistributionPointMassTest(dist3, "ABcd");

            InnerProductWithUniformTest(dist1, "ab");
            InnerProductWithUniformTest(dist1, "ad");
            InnerProductWithUniformTest(dist2, "Abc");
            InnerProductWithUniformTest(dist2, "ABbc");
            InnerProductWithUniformTest(dist3, "ABcd");
            InnerProductWithUniformTest(dist3, "cdAB");
        }

        private static void stringDistributionTest(
            StringDistribution distribution1, StringDistribution distribution2)
        {
            ProductWithUniformTest(distribution1);
            ProductWithUniformTest(distribution2);

            SettableToTest(distribution1);
            SettableToTest(distribution2);

            SettableToWeightedSumTest(distribution1, distribution2, false);
        }

        private static void StringDistributionPointMassTest(StringDistribution distribution, string value)
        {
            ProductWithPointMassTest(distribution, value);
            InnerProductPointMassTest(distribution, value);
            PointMassSampleTest(distribution, value);
        }

        // Generic high-level tests ///////////////////////////////////////////////////////////////////////////

        internal static void DistributionTest<T>(T a, T b, bool doSumWithNegativeWeightsTests = true)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, SettableToWeightedSum<T>,
                ICloneable, Diffable, SettableTo<T>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>
        {
            Assert.False(a.Equals(null));
            ProductWithUniformTest(a);
            ProductWithUniformTest(b);

            RatioWithUniformTest(a);
            RatioWithUniformTest(b);
            SettableToRatioTest(a, b);

            SettableToPowerTest(a);
            SettableToPowerTest(b);
            LogAverageOfPowerTest(a, b);

            SettableToTest(a);
            SettableToTest(b);

            SettableToWeightedSumTest(a, b, doSumWithNegativeWeightsTests);
        }

        internal static void PointMassTest<T, DomainType>(T a, DomainType value)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, SettableToWeightedSum<T>,
                ICloneable, Diffable, SettableTo<T>, HasPoint<DomainType>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetLogProb<DomainType>,
                CanGetAverageLog<T>, Sampleable<DomainType>
        {
            ProductWithPointMassTest(a, value);
            RatioWithPointMassTest(a, value);
            PointMassPowerTest(a, value);
            AverageLogPointMassTest(a, value);
            InnerProductPointMassTest(a, value);
            PointMassSampleTest(a, value);
            PointMassGetLogProbTest(a, value);
        }

        internal static void UniformTest<T, DomainType>(T a, DomainType value)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetAverageLog<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            InnerProductWithUniformTest(a, value);
            AverageLogUniformTest(a, value);
        }

        /// <summary>
        /// Check that the moments of a point mass distribution can be get and set.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a">A distribution to clone.</param>
        /// <param name="value"></param>
        /// <param name="mean">A dummy value used only for type inference.</param>
        /// <param name="variance">A dummy value used only for type inference.</param>
        private static void PointMassMomentTest<T, DomainType, MeanType, VarianceType>(T a, DomainType value, MeanType mean, VarianceType variance)
            where T : HasPoint<DomainType>, CanGetMean<MeanType>, CanGetVariance<VarianceType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            MeanType valueMean = b.GetMean();
            VarianceType zero = (VarianceType)GetZero(b.GetVariance());
            GetMomentTest(b, valueMean, zero);
            if (b is CanSetMeanAndVariance<MeanType, VarianceType>)
            {
                ((CanSetMeanAndVariance<MeanType, VarianceType>)b).SetMeanAndVariance(valueMean, zero);
                GetMomentTest(b, valueMean, zero);
                Assert.True(b.IsPointMass);
                Assert.Equal(value, b.Point);
            }
        }

        private static void PointMassSampleTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, Sampleable<DomainType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            for (int iter = 0; iter < 3; iter++)
            {
                DomainType sample = b.Sample();
                AssertEqual(sample, value);
            }
        }

        private static void PointMassGetLogProbTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetLogProb<DomainType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            Assert.Equal(0.0, b.GetLogProb(value));
            Assert.Equal(double.NegativeInfinity, b.GetLogProb(default(DomainType)));
        }

        private static void AssertEqual(object a, object b)
        {
            // todo: handle types that don't implement value equality
            Assert.True(a.Equals(b));
            Assert.True(a.GetHashCode() == b.GetHashCode());
        }

        private static void SamplingTest<T, DomainType>(T d, DomainType value)
            where T : Sampleable<DomainType>, CanGetMean<double>, CanGetVariance<double>
        {
            Rand.Restart(12347);
            MeanVarianceAccumulator mva = new MeanVarianceAccumulator();
            for (int iter = 0; iter < 2000000; iter++)
            {
                DomainType sample = d.Sample();
                mva.Add(Convert.ToDouble(sample));
            }
            Console.WriteLine("mean = {0} should be {1}", mva.Mean, d.GetMean());
            Console.WriteLine("variance = {0} should be {1}", mva.Variance, d.GetVariance());
            Assert.True(MMath.AbsDiff(mva.Mean, d.GetMean(), 1e-6) < 1e-2);
            Assert.True(MMath.AbsDiff(mva.Variance, d.GetVariance(), 1e-6) < 1e-2);
        }

        /// <summary>
        /// Clone a distribution, change the moments, and read them back.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a"></param>
        /// <param name="mean"></param>
        /// <param name="variance"></param>
        private static void SetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>, CanSetMeanAndVariance<MeanType, VarianceType>, ICloneable
        {
            T b = (T)a.Clone();
            b.SetMeanAndVariance(mean, variance);
            GetMomentTest(b, mean, variance);
        }

        /// <summary>
        /// Check that the moments match those given.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a"></param>
        /// <param name="mean"></param>
        /// <param name="variance"></param>
        private static void GetAndSetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>, ICloneable, CanSetMeanAndVariance<MeanType, VarianceType>
        {
            MeanType actualMean = a.GetMean();
            VarianceType actualVariance = a.GetVariance();
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
            SetMomentTest(a, mean, variance);
        }

        // Helper tests ///////////////////////////////////////////////////////////////////////////

        private static void InnerProductWithUniformTest<DomainType, T>(T a, DomainType value)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(MMath.AbsDiff(a.GetLogAverageOf(uniform), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(uniform.GetLogAverageOf(a), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(a.GetLogAverageOfPower(uniform, 1), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(uniform.GetLogAverageOfPower(a, 1), uniform.GetLogProb(value), 1e-6) < 1e-8);
        }

        private static void AverageLogUniformTest<DomainType, T>(T a, DomainType value)
            where T : CanGetAverageLog<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(MMath.AbsDiff(a.GetAverageLog(uniform), uniform.GetLogProb(value), 1e-6) < 1e-8);
        }

        internal static void ProductWithUniformTest<T>(T a)
            where T : SettableToProduct<T>, SettableToUniform, ICloneable, Diffable
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(a.MaxDiff(a) == 0.0);
            if (!a.Equals(uniform))
                Assert.True(a.MaxDiff(uniform) > 0.0);
            Assert.True(a.MaxDiff(uniform) == uniform.MaxDiff(a));
            T b = (T)a.Clone();
            b.SetToProduct(a, uniform);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToProduct(uniform, a);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToProduct(uniform, uniform);
            Assert.True(uniform.MaxDiff(b) < 1e-10);
        }

        internal static void RatioWithUniformTest<T>(T a)
            where T : SettableToRatio<T>, SettableToUniform, ICloneable, Diffable
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            T b = (T)a.Clone();
            b.SetToRatio(a, uniform);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToRatio(uniform, uniform);
            Assert.True(uniform.MaxDiff(b) < 1e-10);
        }

        private static void InnerProductPointMassTest<DomainType, T>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetLogProb<DomainType>, ICloneable
        {
            T pt = (T)a.Clone();
            pt.Point = value;
            Assert.True(MMath.AbsDiff(a.GetLogAverageOf(pt), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetLogAverageOf(a), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(a.GetLogAverageOfPower(pt, 1), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetLogAverageOfPower(a, 1), a.GetLogProb(value), 1e-8) < 1e-8);
        }

        private static void LogAverageOfPowerTest<T>(T a, T b)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToProduct<T>, ICloneable
        {
            for (int n = 0; n < 3; n++)
            {
                LogAverageOfPowerTest(a, b, n);
            }
        }

        private static void LogAverageOfPowerTest<T>(T a, T b, int n)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToProduct<T>, ICloneable
        {
            double expected = 0;
            T productPrev = default(T);
            for (int i = 0; i < n; i++)
            {
                T product = (T)a.Clone();
                if (i > 0)
                    product.SetToProduct(productPrev, b);
                expected += product.GetLogAverageOf(b);
                productPrev = product;
            }
            double actual = a.GetLogAverageOfPower(b, n);
            Assert.True(MMath.AbsDiff(expected, actual, 1e-8) < 1e-8);
        }

        private static void AverageLogPointMassTest<DomainType, T>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetAverageLog<T>, CanGetLogProb<DomainType>, ICloneable
        {
            T pt = (T)a.Clone();
            pt.Point = value;
            Assert.True(MMath.AbsDiff(a.GetAverageLog(pt), Double.NegativeInfinity, 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetAverageLog(pt), 0.0, 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetAverageLog(a), a.GetLogProb(value), 1e-8) < 1e-8);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="value">Anything other than default(DomainType).</param>
        private static void ProductWithPointMassTest<DomainType, T>(T a, DomainType value)
            where T : SettableToProduct<T>, HasPoint<DomainType>, ICloneable, Diffable
        {
            Assert.False(a.IsPointMass);
            T pt = (T)a.Clone();
            if (object.ReferenceEquals(default(DomainType), null))
            {
                pt.Point = value;
            }
            else
            {
                pt.Point = default(DomainType);
            }
            Assert.True(pt.IsPointMass);
            T b = (T)a.Clone();
            AssertEqual(a, b);
            b.SetToProduct(a, pt);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            b.SetToProduct(pt, a);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            b.SetToProduct(pt, pt);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            T pt2 = (T)a.Clone();
            pt2.Point = pt.Point;
            AssertEqual(pt, pt2);
            pt2.Point = value;
            if (!(a is System.Collections.ICollection))
            {
                Assert.True(pt2.Point.Equals(value));
                if (!pt.Point.Equals(pt2.Point))
                {
                    try
                    {
                        b.SetToProduct(pt, pt2);
                        Assert.True(false, "AllZeroException not thrown");
                    }
                    catch (AllZeroException)
                    {
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="value">Anything other than default(DomainType).</param>
        private static void RatioWithPointMassTest<DomainType, T>(T a, DomainType value)
            where T : SettableToRatio<T>, SettableToUniform, HasPoint<DomainType>, ICloneable, Diffable
        {
            Assert.False(a.IsPointMass);
            T pt = (T)a.Clone();
            pt.Point = value;
            T b = (T)a.Clone();
            b.SetToRatio(pt, a);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            try
            {
                b.SetToRatio(a, pt);
                Assert.True(false, "DivideByZeroException not thrown");
            }
            catch (DivideByZeroException)
            {
            }
            if (false)
            {
                try
                {
                    b.SetToRatio(pt, pt);
                    Assert.True(false, "DivideByZeroException not thrown");
                }
                catch (DivideByZeroException)
                {
                }
            }
            if (false)
            {
                b.SetToRatio(pt, pt);
                T uniform = (T)a.Clone();
                uniform.SetToUniform();
                Assert.True(uniform.MaxDiff(b) < 1e-10);
            }
            T pt2 = (T)a.Clone();
            pt2.Point = value;
            if (!(a is System.Collections.ICollection))
            {
                if (!pt.Point.Equals(pt2.Point))
                {
                    try
                    {
                        b.SetToRatio(pt, pt2);
                        Assert.True(false, "DivideByZeroException not thrown");
                    }
                    catch (DivideByZeroException)
                    {
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="b">A distribution that is everywhere non-zero</param>
        private static void SettableToRatioTest<T>(T a, T b)
            where T : SettableToProduct<T>, SettableToRatio<T>, ICloneable, Diffable, SettableToUniform
        {
            T c = (T)a.Clone();
            c.SetToProduct(a, b);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(a) > 0.0);
            if (!a.IsUniform())
                Assert.True(c.MaxDiff(b) > 0.0);
            Assert.True(c.MaxDiff(a) == a.MaxDiff(c));
            Assert.True(c.MaxDiff(b) == b.MaxDiff(c));
            c.SetToRatio(c, b);
            Assert.True(a.MaxDiff(c) < 1e-10);
            c.SetToRatio(a, b);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(a) > 0.0);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(b) > 0.0);
            Assert.True(c.MaxDiff(a) == a.MaxDiff(c));
            Assert.True(c.MaxDiff(b) == b.MaxDiff(c));
            c.SetToProduct(c, b);
            Assert.True(a.MaxDiff(c) < 1e-10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        private static void SettableToPowerTest<T>(T a)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, ICloneable, Diffable
        {
            T c = (T)a.Clone();
            c.SetToPower(a, 2.0);
            c.SetToPower(c, 0.5);
            Assert.True(a.MaxDiff(c) < 1e-10);
            c.SetToPower(a, 2.0);
            c.SetToRatio(c, a);
            Assert.True(a.MaxDiff(c) < 1e-10);
            try
            {
                c.SetToPower(a, -1.0);
                c.SetToProduct(c, a);
                c.SetToProduct(c, a);
                Assert.True(a.MaxDiff(c) < 1e-10);
            }
            catch
            {
            }

            c.SetToPower(a, 1.0);
            Assert.True(a.MaxDiff(c) < 1e-12);
            c.SetToPower(a, 0.0);
            Assert.True(c.IsUniform());
        }

        private static void PointMassPowerTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, SettableToPower<T>, Diffable, SettableToUniform, ICloneable
        {
            T c = (T)a.Clone();
            c.Point = value;
            Assert.True(c.IsPointMass);
            c.SetToPower(c, 0.0);
            Assert.True(c.IsUniform());
            c.Point = value;
            c.SetToPower(c, 0.1);
            Assert.True(c.IsPointMass);
            AssertEqual(c.Point, value);
            try
            {
                c.SetToPower(c, -0.1);
                Assert.True(false, "DivideByZeroException not thrown");
            }
            catch (DivideByZeroException)
            {
            }
        }

        internal static void SettableToTest<T>(T a)
            where T : SettableTo<T>, SettableToUniform, ICloneable
        {
            T b = (T)a.Clone();
            b.SetToUniform();
            b.SetTo(a);
            Assert.True(b.IsUniform() == a.IsUniform());
            // Don't require equality on collections (follows .NET 'standards')
            AssertEqual(a, b);
        }

        private static void SettableToWeightedSumTest<T>(T a, T b, bool doSumWithNegativeWeightsTests = true)
            where T : SettableToWeightedSum<T>, ICloneable, Diffable, SettableToUniform
        {
            T c = (T)a.Clone();
            c.SetToSum(0.5, a, 0.5, b);
            if (!(c is Discrete && ((Discrete)(object)c).Dimension <= 1))
            {
                Assert.False(c.Equals(a));
                Assert.False(c.Equals(b));
            }

            if (doSumWithNegativeWeightsTests)
            {
                c.SetToSum(2.0, c, -1.0, b);
                Assert.True(c.MaxDiff(a) < 1e-10);
            }

            c.SetToUniform();
            c.SetToSum(2.0, a, 0.0, c);
            Assert.True(c.Equals(a));
            c.SetToSum(0.0, c, 2.0, a);
            Assert.True(c.Equals(a));
            c.SetToSum(1.0, c, Double.PositiveInfinity, b);
            Assert.True(c.Equals(b));
            c.SetToSum(Double.PositiveInfinity, a, 1.0, c);
            Assert.True(c.Equals(a));
            c.SetToSum(0.0, a, 0.0, b);
            Assert.True(c.IsUniform());
            try
            {
                c.SetToSum(0.0, a, -1.0, c);
                Assert.True(false, "Did not throw exception");
            }
            catch (ArgumentException)
            {
            }
        }

        private static void GetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>
        {
            MeanType actualMean = a.GetMean();
            VarianceType actualVariance = a.GetVariance();
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
            if (a is CanGetMeanAndVarianceOut<MeanType, VarianceType>)
            {
                ((CanGetMeanAndVarianceOut<MeanType, VarianceType>)a).GetMeanAndVariance(out actualMean, out actualVariance);
            }
            else if (a is CanGetMeanAndVariance<MeanType, VarianceType>)
            {
                ((CanGetMeanAndVariance<MeanType, VarianceType>)a).GetMeanAndVariance(actualMean, actualVariance);
            }
            else
                return;
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
        }

        public static double AbsDiff(object a, object b)
        {
            if (a is double)
                return MMath.AbsDiff((double)a, (double)b, 1e-10);
            else if (a is Vector)
                return ((Vector)a).MaxDiff((Vector)b);
            else if (a is PositiveDefiniteMatrix)
                return ((PositiveDefiniteMatrix)a).MaxDiff((PositiveDefiniteMatrix)b);
            else
                throw new NotImplementedException();
        }

        public static object GetZero(object o)
        {
            if (o is bool)
                return false;
            else if (o is double)
                return 0.0;
            else if (o is Vector)
                return Vector.Zero(((Vector)o).Count);
            else if (o is PositiveDefiniteMatrix)
                return new PositiveDefiniteMatrix(((PositiveDefiniteMatrix)o).Rows, ((PositiveDefiniteMatrix)o).Cols);
            else
                throw new NotImplementedException();
        }
    }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Xunit;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;
using GaussianArray2D = Microsoft.ML.Probabilistic.Distributions.DistributionStructArray2D<Microsoft.ML.Probabilistic.Distributions.Gaussian, double>;
using System.Threading.Tasks;
using System.Threading;

namespace Microsoft.ML.Probabilistic.Tests
{
#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

    using Assert = Microsoft.ML.Probabilistic.Tests.AssertHelper;


    public class DistributionTests
    {
        public const int nsamples = 50000;

        [Fact]
        public void BinomialTest()
        {
            Binomial a = new Binomial(10, 0.2);
            Binomial b = new Binomial(10, 0.3);

            ProductWithUniformTest(a);
            ProductWithUniformTest(b);

            RatioWithUniformTest(a);
            RatioWithUniformTest(b);
            SettableToRatioTest(a, b);

            SettableToPowerTest(a);
            SettableToPowerTest(b);

            SettableToTest(a);
            SettableToTest(b);

            int value = 3;
            ProductWithPointMassTest(a, value);
            RatioWithPointMassTest(a, value);
            PointMassPowerTest(a, value);
            PointMassSampleTest(a, value);
            PointMassGetLogProbTest(a, value);

            SamplingTest(a, 3);
        }

        [Fact]
        public void GammaPowerFromMeanAndMeanLogTest()
        {
            var testCases = new[]
            {
                (3, 0.4, 5),
                (2.7196413092151412, 1, 2),
                (0.82657135035599683, -0.19053040661796108, -1.0),
                (0.78123008687766349, -0.24698718364292091, -1.0),
                (0.65867320393062079, -0.41774280264746583, -1.0),
                (32.016744802449665, 3.4078368553200575, -1.0),
                (1.2739417498500658, -0.9778858306365934, -1.0),
                (System.Math.Exp(1.0), 1.0, -1.0),
                (System.Math.Exp(1.25), 1.0, -1.0),
            };
            foreach (var testCase in testCases)
            {
                var (mean, meanLog, power) = testCase;
                GammaPower gammaPower = GammaPower.FromMeanAndMeanLog(mean, meanLog, power);
                Assert.Equal(mean, gammaPower.GetMean(), 1e-10);
                Assert.Equal(meanLog, gammaPower.GetMeanLog(), 1e-10);
            }
            GammaPower.FromMeanAndMeanLog(0.82657135035599683, -0.19053040661796108, -1.0);
            GammaPower.FromMeanAndMeanLog(0.78123008687766349, -0.24698718364292091, -1.0);
        }

        [Fact]
        public void Gamma_GetMode_MaximizesGetLogProb()
        {
            Parallel.ForEach(OperatorTests.Gammas()/*.Take(100000)*/, gamma =>
            {
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = gamma.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                    }
                }
                double mode = gamma.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = gamma.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = gamma.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = gamma.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-4 ||
                    (mode == 0 && gamma.GetLogProb(smallestNormalized) >= max)
                    );
            });
        }

        [Fact]
        public void GammaPower_GetMode_MaximizesGetLogProb()
        {
            long count = 0;
            Parallel.ForEach(new[] {
                GammaPower.FromShapeAndRate(1.7976931348623157E+308, 1.7976931348623157E+308, -1.7976931348623157E+308),
            }.Concat(OperatorTests.GammaPowers()).Take(100000), gammaPower =>
            {
                double argmax = double.NaN;
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = gammaPower.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                        argmax = x;
                    }
                }
                double mode = gammaPower.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = gammaPower.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = gammaPower.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = gammaPower.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-8 ||
                    (mode <= double.Epsilon && gammaPower.GetLogProb(smallestNormalized) >= max)
                    );
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void TruncatedGamma_GetMode_MaximizesGetLogProb()
        {
            long count = 0;
            Parallel.ForEach(OperatorTests.TruncatedGammas().Take(100000), dist =>
            {
                double argmax = double.NaN;
                double max = double.NegativeInfinity;
                foreach (var x in OperatorTests.DoublesAtLeastZero())
                {
                    double logProb = dist.GetLogProb(x);
                    Assert.False(double.IsNaN(logProb));
                    if (logProb > max)
                    {
                        max = logProb;
                        argmax = x;
                    }
                }
                double mode = dist.GetMode();
                Assert.False(double.IsNaN(mode));
                double logProbBelowMode = dist.GetLogProb(MMath.PreviousDouble(mode));
                Assert.False(double.IsNaN(logProbBelowMode));
                double logProbAboveMode = dist.GetLogProb(MMath.NextDouble(mode));
                Assert.False(double.IsNaN(logProbAboveMode));
                double logProbAtMode = dist.GetLogProb(mode);
                Assert.False(double.IsNaN(logProbAtMode));
                logProbAtMode = System.Math.Max(System.Math.Max(logProbAtMode, logProbAboveMode), logProbBelowMode);
                const double smallestNormalized = 1e-308;
                Assert.True(logProbAtMode >= max ||
                    MMath.AbsDiff(logProbAtMode, max, 1e-8) < 1e-8 ||
                    (mode <= double.Epsilon && dist.GetLogProb(smallestNormalized) >= max)
                    );
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void GammaPowerTest()
        {
            foreach (var gammaPower in new[] {
                GammaPower.FromShapeAndRate(3, 2, -4.0552419045546273),
                new GammaPower(0.04591, 19.61, -1),
            })
            {
                gammaPower.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
                Assert.Equal(variance, gammaPower.GetVariance());
            }

            Assert.Equal(0, GammaPower.FromShapeAndRate(2, 0, -1).GetMean());
            Assert.Equal(0, GammaPower.FromShapeAndRate(2, 0, -1).GetVariance());
            Assert.True(GammaPower.FromShapeAndRate(2, double.PositiveInfinity, -1).IsPointMass);

            GammaPower g = new GammaPower(1, 1, -1);
            g.ToString();
            Gamma gamma = new Gamma(1, 1);
            double expectedProbLessThan = gamma.GetProbLessThan(2);
            Assert.Equal(expectedProbLessThan, 1 - g.GetProbLessThan(0.5), 1e-10);
            Assert.Equal(2, gamma.GetQuantile(expectedProbLessThan), 1e-10);
            Assert.Equal(0.5, g.GetQuantile(1 - expectedProbLessThan), 1e-10);

            Assert.Equal(0, g.GetProbLessThan(0));
            Assert.Equal(0, g.GetProbLessThan(double.MinValue));
            Assert.Equal(0, g.GetProbLessThan(double.NegativeInfinity));

            g = GammaPower.FromMeanAndVariance(3, double.PositiveInfinity, -1);
            Assert.Equal(2, g.Shape);
            Assert.Equal(3, g.Rate);

            GammaPowerMomentTest(1);
            GammaPowerMomentTest(-1);
            GammaPowerMomentTest(2);
        }

        private void GammaPowerMomentTest(double power)
        {
            GammaPower g = new GammaPower(9.9, 1, power);
            GammaPower g2 = new GammaPower(4.4, 3.3, power);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);
            g.SetToUniform();
        }

        [Fact]
        public void GammaPowerMeanAndVarianceFuzzTest()
        {
            foreach (var gammaPower in OperatorTests.GammaPowers().Take(100000))
            {
                gammaPower.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
            }
        }

        [Fact]
        public void GammaMeanAndVarianceFuzzTest()
        {
            foreach (var gamma in OperatorTests.Gammas())
            {
                gamma.GetMeanAndVariance(out double mean, out double variance);
                Assert.False(double.IsNaN(mean));
                Assert.False(double.IsNaN(variance));
                Assert.False(mean < 0);
                Assert.False(variance < 0);
            }
        }

        //[Fact]
        internal void WrappedGaussianTest()
        {
            WrappedGaussian g = new WrappedGaussian(2.2, 3.3);
            WrappedGaussian g2 = new WrappedGaussian(4.4, 5.5);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
        }

        [Fact]
        public void TruncatedGaussianTest()
        {
            double lowerBound = 5;
            double upperBound = 10;
            var g = new TruncatedGaussian(2.2, 3.3, lowerBound, upperBound);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            //Assert.Equal(2.2, m);
            //Assert.Equal(3.3, v);

            var g2 = new TruncatedGaussian(4.4, 5.5, lowerBound, upperBound);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            //SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);

            var ratio = g / g2;
            Assert.Throws<DivideByZeroException>(() =>
            {
                ratio = g / new TruncatedGaussian(4.4, 5.5, lowerBound + 1, upperBound);
            });
            ratio = TruncatedGaussian.PointMass(lowerBound) / new TruncatedGaussian(4.4, 5.5, lowerBound, upperBound);
            Assert.Throws<DivideByZeroException>(() =>
            {
                ratio = TruncatedGaussian.PointMass(2) / new TruncatedGaussian(4.4, 5.5, lowerBound + 1, upperBound);
            });

            g.SetToUniform();
            //GetAndSetMomentTest(g, 0.0, Double.PositiveInfinity);

            g = new TruncatedGaussian(2, 1, 100, double.PositiveInfinity);
            SamplingTest(g, 7.7);
            foreach (double variance in new[] { 1e8, 1e17, double.MaxValue, double.PositiveInfinity })
            {
                g = new TruncatedGaussian(2, variance, 100, 101);
                SamplingTest(g, 7.7);
            }
        }

        [Fact]
        public void TruncatedGammaTest()
        {
            double lowerBound = 5;
            double upperBound = 10;
            var g = new TruncatedGamma(2.2, 3.3, lowerBound, upperBound);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            /* in matlab:
               x = linspace(5,10,1e6);
               inc = x(2)-x(1);
               lp = gampdfln(x,2.2,1/3.3);
               m = sum(x.*exp(lp))/sum(exp(lp))
               sum((x-m).^2.*exp(lp))/sum(exp(lp))
             */
            Assert.True(MMath.AbsDiff(7.2174, m) < 1e-4);
            Assert.True(MMath.AbsDiff(1.9969, v) < 1e-4);

            var g2 = new TruncatedGamma(4.4, 5.5, lowerBound, upperBound);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            // TODO
            //UniformTest(g, 7.7);
            //SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            // TODO
            //SamplingTest(g, 7.7);
            g.SetToUniform();
            //GetAndSetMomentTest(g, 0.0, Double.PositiveInfinity);

            g = new TruncatedGamma(2, 1, 100, double.PositiveInfinity);
            //SamplingTest(g, 7.7);
            g = new TruncatedGamma(2, 1e8, 100, 101);
            //SamplingTest(g, 7.7);

            g = new TruncatedGamma(2, 1, 3, 3);
            Assert.True(g.IsPointMass);
            Assert.Equal(3.0, g.Point);

            g = new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e14);
            Assert.True(g.Sample() >= 0);
        }

        /// <summary>
        /// Checks that TruncatedGamma.GetMean does not return infinity or NaN for proper distributions.
        /// </summary>
        [Fact]
        public void TruncatedGamma_GetMean()
        {
            double target = 0.1;
            double oldDiff = double.PositiveInfinity;
            for (int i = 1; i < 20; i++)
            {
                TruncatedGamma g = new TruncatedGamma(1, System.Math.Exp(-i), target, double.PositiveInfinity);
                var mean = g.GetMean();
                //Trace.WriteLine($"GetNormalizer = {g.GetNormalizer()} GetMean = {g.GetMean()}");
                Assert.False(double.IsInfinity(mean));
                Assert.False(double.IsNaN(mean));
                double diff = System.Math.Abs(mean - target);
                Assert.True(diff == 0 || diff < oldDiff);
                oldDiff = diff;
                double mean2, variance;
                g.GetMeanAndVariance(out mean2, out variance);
                Assert.Equal(mean, mean2);
            }
            oldDiff = double.PositiveInfinity;
            for (int i = 0; i < 20; i++)
            {
                TruncatedGamma g = new TruncatedGamma(System.Math.Exp(i), 1, 0, target);
                var mean = g.GetMean();
                //Trace.WriteLine($"GetNormalizer = {g.GetNormalizer()} GetMean = {g.GetMean()}");
                Assert.False(double.IsInfinity(mean));
                Assert.False(double.IsNaN(mean));
                double diff = System.Math.Abs(mean - target);
                Assert.True(diff == 0 || diff < oldDiff);
                oldDiff = diff;
                double mean2, variance;
                g.GetMeanAndVariance(out mean2, out variance);
                Assert.Equal(mean, mean2);
            }
        }

        /// <summary>
        /// Checks that TruncatedGamma.GetMeanPower does not return infinity or NaN for proper distributions.
        /// </summary>
        [Fact]
        public void TruncatedGamma_GetMeanPower()
        {
            double shape = 1;
            TruncatedGamma g = new TruncatedGamma(shape, 1, 1, double.PositiveInfinity);
            for (int i = 0; i < 100; i++)
            {
                var meanPower = g.GetMeanPower(-i);
                //Trace.WriteLine($"GetMeanPower({-i}) = {meanPower}");
                Assert.False(double.IsNaN(meanPower));
                Assert.False(double.IsInfinity(meanPower));
                if (i == 1) Assert.Equal(MMath.GammaUpper(shape - 1, 1, false) / MMath.GammaUpper(shape, 1, false), meanPower, 1e-8);
            }
        }

        [Fact]
        public void TruncatedGamma_GetMeanAndVariance_WithinBounds()
        {
            long count = 0;
            Parallel.ForEach(OperatorTests.LowerTruncatedGammas()
                .Take(100000), dist =>
                {
                    dist.GetMeanAndVariance(out double mean, out double variance);
                    // Compiler.Quoter.Quote(dist)
                    Assert.True(mean >= dist.LowerBound);
                    Assert.True(mean <= dist.UpperBound);
                    Assert.Equal(mean, dist.GetMean());
                    Assert.True(variance >= 0);
                    Interlocked.Add(ref count, 1);
                    if (count % 100000 == 0)
                        Trace.WriteLine($"{count} cases passed");
                });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        [Trait("Category", "OpenBug")]
        public void TruncatedGamma_GetMeanPower_WithinBounds()
        {
            var g = new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e14);
            Assert.True(g.GetMean() <= g.UpperBound);
            for (int i = 0; i < 308; i++)
            {
                double power = System.Math.Pow(10, i);
                //Trace.WriteLine($"GetMeanPower({power}) = {g.GetMeanPower(power)}");
                Assert.True(g.GetMeanPower(power) <= g.UpperBound);
            }
            Assert.True(g.GetMeanPower(1.7976931348623157E+308) <= g.UpperBound);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e9).GetMeanPower(1.7976931348623157E+308) <= 1e9);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 1e6).GetMeanPower(1.7976931348623157E+308) <= 1e6);
            Assert.True(new TruncatedGamma(Gamma.FromShapeAndRate(4.94065645841247E-324, 4.94065645841247E-324), 0, 100).GetMeanPower(4.94065645841247E-324) <= 100);

            long count = 0;
            Parallel.ForEach(OperatorTests.LowerTruncatedGammas()
                .Take(100000), dist =>
            {
                foreach (var power in OperatorTests.Doubles())
                {
                    if (dist.Gamma.Shape <= -power && dist.LowerBound == 0) continue;
                    double meanPower = dist.GetMeanPower(power);
                    if (power >= 0)
                    {
                        // Compiler.Quoter.Quote(dist)
                        Assert.True(meanPower >= System.Math.Pow(dist.LowerBound, power));
                        Assert.True(meanPower <= System.Math.Pow(dist.UpperBound, power));
                    }
                    else
                    {
                        Assert.True(meanPower <= System.Math.Pow(dist.LowerBound, power));
                        Assert.True(meanPower >= System.Math.Pow(dist.UpperBound, power));
                    }
                    if (power == 1)
                    {
                        Assert.Equal(meanPower, dist.GetMean());
                    }
                }
                Interlocked.Add(ref count, 1);
                if (count % 100000 == 0)
                    Trace.WriteLine($"{count} cases passed");
            });
            Trace.WriteLine($"{count} cases passed");
        }

        [Fact]
        public void GaussianTest()
        {
            Gaussian g = new Gaussian();
            g.SetMeanAndVariance(2.2, 3.3);
            double m, v;
            g.GetMeanAndVariance(out m, out v);
            Assert.Equal(2.2, m);
            Assert.Equal(3.3, v);

            double x = 4.4;
            double probLessThan = g.GetProbLessThan(x);
            Assert.Equal(MMath.NormalCdf((x - 2.2) / System.Math.Sqrt(3.3)), probLessThan, 1e-4);

            Gaussian g2 = new Gaussian(4.4, 5.5);
            /* Test in matlab:
                x = linspace(-100,100,1e6);
                inc = x(2)-x(1);
                m1 = 2.2;
                v1 = 3.3;
                m2 = 4.4;
                v2 = 5.5;
                logsumexp(normpdfln(x,m1,[],v1)+normpdfln(x,m2,[],v2),2)+log(inc)
                    normpdfln(m1,m2,[],v1+v2)
                logsumexp(normpdfln(x,m1,[],v1)-normpdfln(x,m2,[],v2),2)+log(inc)
                    log(v2/(v2-v1)) - normpdfln(m1,m2,[],v2-v1)
                v2 = -5.5
                logsumexp(normpdfln(x,m1,[],v1) -0.5*x.^2/v2+x*(m2/v2),2)+log(inc)
                    -0.5*(m1-m2)^2/(v1+v2) +0.5*log(v2/(v1+v2))
                logsumexp(normpdfln(x,m1,[],v1) +0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                    0.5*(m1-m2)^2/(v2-v1) +0.5*log(v2/(v2-v1))
                logsumexp(0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                v1 = -6.6
                logsumexp(-0.5*x.^2/v1+x*m1/v1 +0.5*x.^2/v2-x*(m2/v2),2)+log(inc)
                    0.5*(m1-m2)^2/(v2-v1) +0.5*log(2*pi*v2*v1/(v2-v1))
             */
            // (proper,proper)
            Assert.True(System.Math.Abs(g.GetLogAverageOf(g2) - (-2.28131439394676)) < 1e-8);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 3.32945794526097) < 1e-8);
            // (proper,improper)
            g2.SetMeanAndVariance(4.4, -5.5);
            Assert.True(System.Math.Abs(g.GetLogAverageOf(g2) - (-0.201854634084064)) < 1e-8);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 1.249998185356082) < 1e-8);
            // (uniform,improper)
            g.SetToUniform();
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 3.531312579302817) < 1e-8);
            // (improper,improper)
            g.SetMeanAndVariance(2.2, -6.6);
            Assert.True(System.Math.Abs(g.GetLogAverageOfPower(g2, -1) - 6.260525647249976) < 1e-8);
            // (proper,uniform)
            g.SetMeanAndVariance(2.2, 3.3);
            Assert.True(g.GetLogAverageOf(Gaussian.Uniform()) == 0);

            // Checks for infinite means
            Assert.Equal(new Gaussian(double.NegativeInfinity, 2.2), Gaussian.PointMass(double.NegativeInfinity));
            Assert.Equal(new Gaussian(double.PositiveInfinity, 2.2), Gaussian.PointMass(double.PositiveInfinity));
            g.SetMeanAndVariance(double.NegativeInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.NegativeInfinity));
            g.SetMeanAndVariance(double.PositiveInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.PositiveInfinity));
            g.SetMeanAndPrecision(double.NegativeInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.NegativeInfinity));
            g.SetMeanAndPrecision(double.PositiveInfinity, 2.2);
            Assert.Equal(g, Gaussian.PointMass(double.PositiveInfinity));

            double mean = 1024;
            double precision = double.MaxValue / mean * 2;
            // precision * mean > double.MaxValue
            g.SetMeanAndPrecision(mean, precision);
            g2 = Gaussian.FromMeanAndPrecision(mean, double.MaxValue / mean);
            Assert.Equal(g2, g);
            Assert.Equal(g2, new Gaussian(mean, 1 / precision));
            double inverseIsInfinity = 0.5 / double.MaxValue;
            Assert.Equal(Gaussian.PointMass(mean), new Gaussian(mean, inverseIsInfinity));
            Gaussian.FromNatural(1, inverseIsInfinity).GetMeanAndVarianceImproper(out m, out v);
            if (v > double.MaxValue)
                Assert.Equal(0, m);
            Gaussian.Uniform().GetMeanAndVarianceImproper(out m, out v);
            Assert.Equal(0, m);
            Assert.True(double.IsPositiveInfinity(v));

            g.SetMeanAndVariance(2.2, 3.3);
            g2.SetMeanAndVariance(4.4, 5.5);
            DistributionTest(g, g2);
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 1.1, 2.2);
            PointMassMomentTest(g, 7.7, 4.4, 5.5);
            SamplingTest(g, 7.7);
            g.SetToUniform();
            Assert.True(g.GetVariance() == double.PositiveInfinity);
            Assert.Throws<ImproperDistributionException>(() => g.GetMean());

            Gaussian g3 = new Gaussian();
            g3.SetToSum(1.0, g, double.PositiveInfinity, g2);
            Assert.True(g3.Equals(g2));
        }

        /// <summary>
        /// Tests that a product of high-precision Gaussians produces a point mass.
        /// </summary>
        [Fact]
        public void GaussianSetToProduct_ProducesPointMassTest()
        {
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(1, double.MaxValue));
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(0.9, double.MaxValue));
            GaussianSetToProduct_ProducesPointMass(Gaussian.FromMeanAndPrecision(10, double.MaxValue / 10));
        }

        private void GaussianSetToProduct_ProducesPointMass(Gaussian g)
        {
            Gaussian expected = Gaussian.PointMass(g.GetMean());
            Assert.Equal(expected, g * g);
            Assert.Equal(expected, g ^ 2);
        }

        /// <summary>
        /// Tests that a product of high-precision Gaussians produces a point mass.
        /// </summary>
        [Fact]
        public void GammaSetToProduct_ProducesPointMassTest()
        {
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue, double.MaxValue));
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue / 10, double.MaxValue));
            GammaSetToProduct_ProducesPointMass(Gamma.FromShapeAndRate(double.MaxValue, double.MaxValue / 10));
        }

        private void GammaSetToProduct_ProducesPointMass(Gamma g)
        {
            Gamma expected = Gamma.PointMass(g.GetMode());
            Assert.Equal(expected, g * g);
            Assert.Equal(expected, g ^ 2);
        }

        [Fact]
        public void VectorGaussianTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            int d = 3;
            VectorGaussian g = new VectorGaussian(d);
            PositiveDefiniteMatrix A = new PositiveDefiniteMatrix(new double[,] { { 2, 2, 2 }, { 2, 3, 3 }, { 2, 3, 4 } });
            Vector b = Vector.FromArray(new double[] { 1, 2, 3 });
            g.Precision.SetTo(A);
            g.MeanTimesPrecision.SetTo(b);
            Console.WriteLine(StringUtil.JoinColumns("g = ", g));

            // test Equals
            VectorGaussian g1 = new VectorGaussian(d);
            g1.Precision.SetTo(A);
            g1.MeanTimesPrecision.SetTo(b);
            Assert.True(g1.Equals(g));
            Assert.True(g1.GetHashCode() == g.GetHashCode());

            // test Sample
            Vector x = null;
            VectorMeanVarianceAccumulator mva = new VectorMeanVarianceAccumulator(d);
            for (int i = 0; i < nsamples; i++)
            {
                x = g.Sample();
                mva.Add(x);
            }
            //Console.WriteLine("x = {0}", x);
            //Console.WriteLine("eval(x) = {0}", g.GetLogProb(x));
            // x = [-1 1 2]';
            // b = [1 2 3]';
            // a = [2 2 2; 2 3 3; 2 3 4];
            // normpdfln(x, a\b, 'inv', a)
            x = Vector.FromArray(new double[] { -1, 1, 2 });
            Assert.True(System.Math.Abs(g.GetLogProb(x) - (-7.160242009334)) < 1e-10);
            PositiveDefiniteMatrix prec = new PositiveDefiniteMatrix(3, 3);
            prec.SetToInverse(mva.Variance);
            Console.WriteLine(StringUtil.JoinColumns("precision = ", prec.ToString()));
            Console.WriteLine(" (error {0})", prec.MaxDiff(A));
            Assert.True(prec.MaxDiff(A) < 0.1);
            Vector pm = prec * mva.Mean;
            Console.WriteLine("precision * mean = {0}", pm);
            Console.WriteLine(" (error {0})", pm.MaxDiff(b));
            Assert.True(pm.MaxDiff(b) < 0.1);

            // test SetToProduct
            VectorGaussian g2 = new VectorGaussian(d);
            A = new PositiveDefiniteMatrix(new double[,] { { 3, 1, 1 }, { 1, 5, 1 }, { 1, 1, 6 } });
            b = Vector.FromArray(new double[] { 3, 2, 1 });
            g2.Precision.SetTo(A);
            g2.MeanTimesPrecision.SetTo(b);
            Console.WriteLine(StringUtil.JoinColumns("g2 = ", g2));

            g.SetToProduct(g1, g2);
            Console.WriteLine(StringUtil.JoinColumns("g1*g2 = ", g));

            VectorGaussian dx = VectorGaussian.PointMass(x);
            g.SetToProduct(g1, dx);
            Console.WriteLine(StringUtil.JoinColumns("g1*dx = ", g));
            Assert.True(g.IsPointMass);

            g.SetToProduct(dx, g2);
            Console.WriteLine(StringUtil.JoinColumns("dx*g2 = ", g));
            Assert.True(g.IsPointMass);

            DistributionTest(g1, g2);
            PointMassTest(g1, b);
            UniformTest(g1, b);
            SetMomentTest(g2, b, A);
            PointMassMomentTest(g2, x, b, A);
            g2.SetToUniform();
            Assert.True(g2.GetMean().EqualsAll(0.0));
            Assert.True(Double.IsPositiveInfinity(g2.GetVariance()[0, 0]));
            SetMomentTest(g, g.GetMean(), g.GetVariance());

            g = new VectorGaussian(Vector.FromArray(2, 3), new PositiveDefiniteMatrix(new double[,] { { 1, 0 }, { 0, 0 } }));
            Assert.True(Double.IsPositiveInfinity(g.Precision[1, 1]));
            Assert.Equal(3.0, g.Point[1]);
        }

        [Fact]
        public void VectorGaussian_GetMarginal_ReturnsUniform()
        {
            VectorGaussian vg = VectorGaussian.FromNatural(Vector.FromArray(0, 2), new PositiveDefiniteMatrix(new double[,] { { 0, 0 }, { 0, 3 } }));
            Gaussian g = vg.GetMarginal(0);
            Assert.True(g.IsUniform());
            VectorGaussian vg1 = new VectorGaussian(1);
            vg1 = vg.GetMarginal(0, vg1);
            Assert.True(vg1.IsUniform());
            VectorGaussian vg2 = new VectorGaussian(2);
            vg2 = vg.GetMarginal(0, vg2);
            Assert.True(vg.MaxDiff(vg2) < 1e-10);
        }

        [Fact]
        public void VectorGaussianMoments_SetToProduct_Singular()
        {
            PositiveDefiniteMatrix A = new PositiveDefiniteMatrix(new double[,] {
                { 4.008640513161180,  1.303104352135630, - 2.696380025254830, - 2.728465435435790 },
                { 1.303104352135630,  4.024136989099960, - 2.681070246787840, - 2.713155656968810 },
                { -2.696380025254830, - 2.681070246787840, 4.136120496920130,  1.403451295855420 },
                { -2.728465435435790, - 2.713155656968810, 1.403451295855420,  4.063123100392480 }
            });
            PositiveDefiniteMatrix B = new PositiveDefiniteMatrix(4, 4);
            B.SetToDiagonal(Vector.FromArray(1, 0, 3, 4));

            VectorGaussianMoments vg1 = new VectorGaussianMoments(Vector.FromArray(6, 5, 4, 3), A);
            VectorGaussianMoments vg2 = new VectorGaussianMoments(Vector.FromArray(1, 2, 3, 4), B);
            var product = vg1 * vg2;

            PositiveDefiniteMatrix vExpected = new PositiveDefiniteMatrix(new double[,]
            {
                { 0.699231932932321,  -0.000000000000000 , -0.330187594961638,  -0.385553717718764 },
                { -0.000000000000000,   0.000000000000000,  -0.000000000000002,   0.000000000000002 },
                { -0.330187594961638,  -0.000000000000002,   0.946948669226297,  -0.569413640803344 },
                { -0.385553717718764,   0.000000000000002,  -0.569413640803344 ,  0.926496676481940 },
            });
            Assert.True(vExpected.MaxDiff(product.Variance) < 1e-4);
            Vector meanExpected = Vector.FromArray(2.640276200841019, 2.000000014880260, 6.527941507328482, 6.908179339051594);
            Assert.True(meanExpected.MaxDiff(product.Mean) < 1e-4);

            vg2.Variance.SetToDiagonal(Vector.FromArray(1, double.PositiveInfinity, 3, 4));
            product = vg1 * vg2;
            vExpected.SetTo(new double[,] {
                { 0.703202829692760,  -0.097044359196042,  -0.287002295003263,  -0.335123696183070 },
                { -0.097044359196042,   2.371534574978036,  -1.055338156807388,  -1.232393390393070 },
                { -0.287002295003263,  -1.055338156807388,   1.416576208767429,  -0.020995915719158 },
                { -0.335123696183070,  -1.232393390393070,  -0.020995915719158,   1.566923316764467 },
            });
            Assert.True(vExpected.MaxDiff(product.Variance) < 1e-4);
            meanExpected.SetTo(new double[] { 2.495869677904531, 5.528904975989440, 4.957577684071078, 5.074347889058121 });
            Assert.True(meanExpected.MaxDiff(product.Mean) < 1e-4);
        }

        [Fact]
        public void GammaTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Gamma w = Gamma.FromMeanAndVariance(3, 7);
            Assert.True(MMath.AbsDiff(w.GetMean(), 3, 1e-6) < 1e-10);
            Assert.True(MMath.AbsDiff(w.GetVariance(), 7, 1e-6) < 1e-10);

            double a = 0.7;
            Gamma g = new Gamma();
            g.Shape = a;
            g.Rate = 2;
            GammaMomentTest(g);
            GammaMomentTest(Gamma.FromShapeAndRate(1.7, 2));
            GammaMomentTest(Gamma.PointMass(2.3));

            DistributionTest(g, new Gamma(10, 11));
            PointMassTest(g, 7.7);
            UniformTest(g, 7.7);
            SetMomentTest(g, 2.2, 3.3);
            PointMassMomentTest(g, 7.7, 1.1, 2.2);
            g.SetToUniform();
            GetAndSetMomentTest(g, Double.PositiveInfinity, Double.PositiveInfinity);

            // test for round-off errors
            g.SetShapeAndRate(1e-20, 1e-20);
            GammaRoundoffTest(g);
            //DistributionTest(g, g);
            g.SetShapeAndRate(1e20, 1e20);
            GammaRoundoffTest(g);
            DistributionTest(g, Gamma.FromShapeAndRate(2e20, 2e20));

            Assert.Equal(Gamma.FromMeanAndVariance(double.MaxValue, 1), Gamma.PointMass(double.MaxValue));
            Assert.Equal(Gamma.FromMeanAndVariance(double.MaxValue / 1e100, 1e-100), Gamma.PointMass(double.MaxValue / 1e100));
            Assert.Equal(Gamma.FromMeanAndVariance(1, double.Epsilon), Gamma.PointMass(1));
            Assert.Equal(Gamma.PointMass(0), Gamma.FromShapeAndRate(2.5, double.PositiveInfinity));
            Assert.Equal(Gamma.PointMass(0), Gamma.FromShapeAndScale(2.5, 1e-320));
            Assert.Equal(Gamma.PointMass(0), new Gamma(2.5, 1e-320));
            Assert.Equal(Gamma.PointMass(0), new Gamma(2.5, 0));
            Assert.Equal(Gamma.PointMass(1e-300), Gamma.FromShapeAndRate(2, 1e300) ^ 1e10);

            ProductWithUniformTest(g);
            Gamma g2 = new Gamma();
            g2.SetToPower(g, 1.0);
            Assert.True(g2.MaxDiff(g) < 1e-12);

            Assert.Equal(double.NegativeInfinity, g.GetLogProb(double.PositiveInfinity));
            Assert.Equal(double.NegativeInfinity, g.GetLogAverageOf(Gamma.PointMass(double.PositiveInfinity)));
            Assert.Equal(double.NegativeInfinity, g.GetLogProb(0));
            g.Shape = 1;
            g.Rate = 2;
            Assert.Equal(-g.GetLogNormalizer(), g.GetLogProb(0));
            g.Rate = 0;
            Assert.Equal(0, g.GetLogProb(double.PositiveInfinity));
            Assert.Equal(0, g.GetLogProb(0));
        }

        private static void GammaRoundoffTest(Gamma a)
        {
            ProductWithUniformTest(a);
            RatioWithUniformTest(a);
            Gamma c = (a / a);
            Assert.True(c.IsUniform());
            c.SetToPower(a, 1.0);
            Assert.True(a.MaxDiff(c) < 1e-12);
            c.SetToPower(a, 0.0);
            Assert.True(c.IsUniform());
            LogAverageOfPowerTest(a, a);
        }

        [Fact]
        public void GammaSetToPowerTest()
        {
            double[,] gammaSetToPower_pairs = {
                { 1e-20, 1e-20, 0.99999999999999999999 },
                { 1e-20, 1e-10, 0.999999999899999999999999996 },
                { 1e-20, 0.1, 0.89999999999999999 },
                { 1e-20, 1, 1e-20 },
                { 1e-20, 1.1, -0.1000000000000000888 },
                { 1e-20, 1e4, -9998.9999999999999999 },
                { 1e-20, 1e16, -9999999999999998.9999 },
                { 1e-20, -1, 1.99999999999999999999 },
                { 1, 1e-20, 1 },
                { 1, 1e-10, 1 },
                { 1, 1, 1 },
                { 1, 1e4, 1 },
                { 1, 1e10, 1 },
                { 1, 1e16, 1 },
                { 1, 1e20, 1 },
                { 1, -1e20, 1 },
                { 1, -1e-20, 1 },
                { 1e4, 1e4, 99990001.0 },
                { 1e4, 1e20, 999900000000000000000001.0 },
            };

            for (int i = 0; i < gammaSetToPower_pairs.GetLength(0); i++)
            {
                double a = gammaSetToPower_pairs[i, 0];
                double e = gammaSetToPower_pairs[i, 1];
                double a2 = gammaSetToPower_pairs[i, 2];
                Gamma g = Gamma.FromShapeAndRate(a, 1);
                g.SetToPower(g, e);
                Assert.True(MMath.AbsDiff(a2, g.Shape, 1e-10) < 1e-10);
            }
        }

        private void GammaMomentTest(Gamma g)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            double m = 0, s = 0, minv = 0, m2 = 0;
            for (int i = 0; i < nsamples; i++)
            {
                double x = g.Sample();
                m = m + x;
                s = s + System.Math.Log(x);
                minv = minv + 1.0 / x;
                m2 = m2 + x * x;
            }
            m = m / nsamples;
            s = s / nsamples;
            minv = minv / nsamples;
            m2 = m2 / nsamples;
            double mTrue = g.GetMean();
            double sTrue = g.GetMeanLog();
            double m2True = g.GetMeanPower(2);
            Console.WriteLine("|m - mTrue| = {0}", System.Math.Abs(m - mTrue));
            Assert.True(System.Math.Abs(m - mTrue) < 0.05);
            Console.WriteLine("|s - sTrue| = {0}", System.Math.Abs(s - sTrue));
            Assert.True(System.Math.Abs(s - sTrue) < 0.05);
            if (g.Shape > 1)
            {
                double minvTrue = g.GetMeanInverse();
                Console.WriteLine("|minv - minvTrue| = {0}", System.Math.Abs(minv - minvTrue));
                Assert.True(System.Math.Abs(minv - minvTrue) < 0.05);
                Assert.True(System.Math.Abs(g.GetMeanPower(-1) - minvTrue) < 1e-10);
            }
            Console.WriteLine("|m2 - m2True| = {0}", System.Math.Abs(m2 - m2True));
            Assert.True(System.Math.Abs(m2 - m2True) < 0.05);
        }

        [Fact]
        public void WishartTest()
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            int d = 3;
            double a = 1.7 + 2;
            Wishart g = Wishart.Uniform(d);
            Assert.True(g.IsUniform());
            PositiveDefiniteMatrix B = new PositiveDefiniteMatrix(new double[,] { { 2, 1, 1 }, { 1, 3, 1 }, { 1, 1, 4 } });
            g.Rate = B;
            g.Shape = a;

            // test Equals
            Wishart g1 = new Wishart(d);
            g1.Rate = B;
            g1.Shape = a;
            Assert.True(g1.Equals(g));
            Assert.True(g1.GetHashCode() == g.GetHashCode());

            // test Sample and WishartEstimator
            PositiveDefiniteMatrix X = null;
            MatrixMeanVarianceAccumulator mva = new MatrixMeanVarianceAccumulator(d, d);
            WishartEstimator est = new WishartEstimator(g.Dimension);
            double s = 0;
            for (int i = 0; i < nsamples; i++)
            {
                X = g.Sample();
                mva.Add(X);
                s = s + X.LogDeterminant();
                est.Add(X);
            }
            double sTrue = g.GetMeanLogDeterminant();
            s = s / nsamples;

            Console.WriteLine(StringUtil.JoinColumns("X = ", X));
            Console.WriteLine("eval(dx) = {0}", g.GetLogProb(X));
            Console.WriteLine("|s - sTrue| = {0}", System.Math.Abs(s - sTrue));
            Assert.True(System.Math.Abs(s - sTrue) < 0.05);
            PositiveDefiniteMatrix mTrue = new PositiveDefiniteMatrix(d, d);
            PositiveDefiniteMatrix vTrue = new PositiveDefiniteMatrix(d, d);
            g.GetMeanAndVariance(mTrue, vTrue);
            Assert.True(mTrue.MaxDiff(g.GetMean()) < 1e-10);
            Assert.True(vTrue.MaxDiff(g.GetVariance()) < 1e-10);
            Console.WriteLine("|m - mTrue| = {0}", mTrue.MaxDiff(mva.Mean));
            Assert.True(mTrue.MaxDiff(mva.Mean) < 0.05);
            Assert.True(vTrue.MaxDiff(mva.Variance) < 0.05);
            est.GetDistribution(g1);
            Console.WriteLine(g1);
            Assert.True(g.MaxDiff(g1) < 0.05);

            // test SetToProduct
            Wishart g2 = new Wishart(d);
            B = new PositiveDefiniteMatrix(new double[,] { { 3, 1, 1 }, { 1, 3, 1 }, { 1, 1, 3 } });
            g2.Rate = B;
            g2.Shape = 3.3 + 2;
            Console.WriteLine(StringUtil.JoinColumns("g2 = ", g2));

            g.SetToProduct(g1, g2);
            Console.WriteLine(StringUtil.JoinColumns("g1*g2 = ", g));

            Wishart dx = Wishart.PointMass(B);
            g.SetToProduct(g1, dx);
            Console.WriteLine(StringUtil.JoinColumns("g1*dx = ", g));
            Assert.True(g.IsPointMass);

            g.SetToProduct(dx, g2);
            Console.WriteLine(StringUtil.JoinColumns("dx*g2 = ", g));
            Assert.True(g.IsPointMass);

            // test Get/SetMeanAndVariance for a point mass
            PositiveDefiniteMatrix V = new PositiveDefiniteMatrix(d, d);
            g.GetMeanAndVariance(mTrue, vTrue);
            g.SetMeanAndVariance(mTrue, vTrue);
            g.GetMeanAndVariance(B, V);
            Assert.True(mTrue.MaxDiff(B) < 1e-10);
            Assert.True(vTrue.MaxDiff(V) < 1e-10);

            g.Rate = B;
            g.Shape = a;
            g.GetMeanAndVariance(mTrue, vTrue);
            g.SetMeanAndVariance(mTrue, vTrue);
            g.GetMeanAndVariance(B, V);
            Assert.True(mTrue.MaxDiff(B) < 1e-10);
            Assert.True(vTrue.MaxDiff(V) < 1e-10);

            DistributionTest(g, g2);
            PointMassTest(g, B);
            UniformTest(g, B);
            SetMomentTest(g, mTrue, vTrue);
            PointMassMomentTest(g, B, B, V);
            g.SetToUniform();
            Assert.True(g.GetMean().EqualsAll(Double.PositiveInfinity));
            Assert.True(Double.IsPositiveInfinity(g.GetVariance()[0, 0]));
            SetMomentTest(g, g.GetMean(), g.GetVariance());

            // test for round-off errors
            DistributionTest(new Wishart(1e-20, 1e+20), new Wishart(10, 11));
        }

        [Fact]
        public void DistributionArrayConversionTest()
        {
            Gaussian[] ga = new Gaussian[] { new Gaussian(0, 1) };
            IDistribution<double[]> dga = Distribution<double>.Array(ga);
            Gaussian[] ga2 = Distribution.ToArray<Gaussian[]>(dga);
            IDistribution<double[]> dga2 = Distribution<double>.Array(ga2);
            Assert.Equal(dga, dga2);

            Gaussian[,] ga2D = new Gaussian[,] { { new Gaussian(0, 1) } };
            IDistribution<double[,]> dga2D = Distribution<double>.Array(ga2D);
            Gaussian[,] ga2D2 = Distribution.ToArray<Gaussian[,]>(dga2D);
            IDistribution<double[,]> dga2D2 = Distribution<double>.Array(ga2D2);
            Assert.Equal(dga2D, dga2D2);

            Gaussian[][] gaa = new Gaussian[][] { new Gaussian[] { new Gaussian(0, 1) } };
            IDistribution<double[][]> dgaa = Distribution<double>.Array(gaa);
            Gaussian[][] gaa2 = Distribution.ToArray<Gaussian[][]>(dgaa);
            IDistribution<double[][]> dgaa2 = Distribution<double>.Array(gaa2);
            Assert.Equal(dgaa, dgaa2);

            Gaussian[,][] ga2Da = new Gaussian[,][] { { new Gaussian[] { new Gaussian(0, 1) } } };
            IDistribution<double[,][]> dga2Da = Distribution<double>.Array(ga2Da);
            Gaussian[,][] ga2Da2 = Distribution.ToArray<Gaussian[,][]>(dga2Da);
            IDistribution<double[,][]> dga2Da2 = Distribution<double>.Array(ga2Da2);
            Assert.Equal(dga2Da, dga2Da2);

            Gaussian[][,] gaa2D = new Gaussian[][,] { new Gaussian[,] { { new Gaussian(0, 1) } } };
            IDistribution<double[][,]> dgaa2D = Distribution<double>.Array(gaa2D);
            Gaussian[][,] gaa2D2 = Distribution.ToArray<Gaussian[][,]>(dgaa2D);
            IDistribution<double[][,]> dgaa2D2 = Distribution<double>.Array(gaa2D2);
            Assert.Equal(dgaa2D, dgaa2D2);

            Gaussian[][][] gaaa = new Gaussian[][][] { new Gaussian[][] { new Gaussian[] { new Gaussian(0, 1) } } };
            IDistribution<double[][][]> dgaaa = Distribution<double>.Array(gaaa);
            Gaussian[][][] gaaa2 = Distribution.ToArray<Gaussian[][][]>(dgaaa);
            IDistribution<double[][][]> dgaaa2 = Distribution<double>.Array(gaaa2);
            Assert.Equal(dgaaa, dgaaa2);
        }

#pragma warning disable CA2013
        [Fact]
        public void GaussianArrayTest()
        {
            Gaussian g = new Gaussian(0, 1);
            GaussianArray2D a = new GaussianArray2D(new Gaussian(), 3, 2);
            Assert.False(object.ReferenceEquals(a[0], a[1]));
            a.ForEach(delegate (Gaussian item)
            { Assert.True(item.IsUniform()); });
            //GaussianArray a = new GaussianArray(new Gaussian[3,2]);
            //a.ModifyAll(delegate(Gaussian item) { return new Gaussian(); });
            a.SetAllElementsTo(g);
            a[0] = new Gaussian(0, 2);
            Console.WriteLine("a[0] = " + a[0]);
            foreach (Gaussian item in a)
            {
                Console.WriteLine(item);
            }
            Console.WriteLine(a);
            Assert.Equal(g, a[1]);
            Assert.Equal(g, a[0, 1]);
            //Assert.Equal(g, a[new int[] { 0, 1 }]);
            Assert.Equal(1, a.IndexOf(g));
            Assert.Contains(g, a);
            Assert.Equal(1, a.FindIndex(delegate (Gaussian item)
            { return (item.GetVariance() == 1); }));
            GaussianArray2D b = (GaussianArray2D)a.Clone();
            Assert.False(object.ReferenceEquals(b[0], a[0]));
            b.SetTo(a);
            Assert.False(object.ReferenceEquals(b[0], a[0]));
            a.SetToProduct(a, a);
            Assert.True(a[0].MaxDiff(Gaussian.FromMeanAndPrecision(0, 1)) < 1e-10);
            Assert.True(a[1].MaxDiff(Gaussian.FromMeanAndPrecision(0, 2)) < 1e-10);

            DistributionTest(a, new GaussianArray2D(new Gaussian(4, 5), 3, 2));

            a.SetToUniform();
            a.ForEach(delegate (Gaussian item)
            { Assert.True(item.IsUniform()); });
            //UniformTest(a,new double[3,2]);

            b = new GaussianArray2D(new Gaussian(), 3, 3);
            Assert.True(!a.Equals(b));
        }
#pragma warning restore

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

#if false
        [Fact]
        public void GaussianCursorArrayTest()
        {
            VectorGaussian g = new VectorGaussian(3);
            GaussianCursorArray a = new GaussianCursorArray(g, 3, 2);
            int i = 0;
            foreach (VectorGaussian item in a) {
                item.MeanTimesPrecision.SetAllElementsTo(i++);
                item.Precision.SetToIdentity();
            }

            VectorGaussian g2 = new VectorGaussian(3);
            int[] keepAll = new int[] { 0, 1 };
            GaussianCursorArray a2 = new GaussianCursorArray(g2, 3, 2);
            a.ReduceTo(keepAll, a2);
            Console.WriteLine("ReduceTo[0,1]:");
            Console.WriteLine(a2);

            VectorGaussian g3 = new VectorGaussian(3);
            int[] keep1 = new int[] { 0 };
            GaussianCursorArray a3 = new GaussianCursorArray(g3, 3);
            a.ReduceTo(keep1, a3);
            Console.WriteLine("ReduceTo[0]:");
            Console.WriteLine(a3);
            Assert.True(a3[0].MeanTimesPrecision[0] == 1);
            Assert.True(a3[1].MeanTimesPrecision[0] == 5);
            Assert.True(a3[2].MeanTimesPrecision[0] == 9);

            int[] keep2 = new int[] { 1 };
            a3 = new GaussianCursorArray(g3, 2);
            a.ReduceTo(keep2, a3);
            Console.WriteLine("ReduceTo[1]:");
            Console.WriteLine(a3);
            Assert.True(a3[0].MeanTimesPrecision[0] == 6);
            Assert.True(a3[1].MeanTimesPrecision[0] == 9);

            a.ReduceTo(g3);
            Console.WriteLine("ReduceTo[]:");
            Console.WriteLine(g3);
            Assert.True(g3.MeanTimesPrecision[0] == 15);

            a.SetToProduct(a, a);
            Console.WriteLine("SetToProduct:");
            Console.WriteLine(a);

#if false
            a2.Point = a.Sample();
            Console.WriteLine("Sample:");
            Console.WriteLine(a2);
#endif

            a2.SetTo(a);
            Console.WriteLine("SetTo:");
            Console.WriteLine(a);
            Assert.True(a.Equals(a2));
            Assert.True(a.MaxDiff(a2) == 0);

            GaussianCursorArray a3r = a3.Replicate(new int[] { 3, 2 }, new int[] { 1 });
            Console.WriteLine("Replicate[1]:");
            Console.WriteLine(a3r);

            DistributionCursorArray<GaussianCursorArray, Vector[]> jagged;
            try {
                jagged = a.Split(new bool[] { false, false });
                Debug.Fail("Split[F,F] did not fail");
            } catch (ArgumentException ex) {
                Console.WriteLine("Split[F,F] correctly failed with error: " + ex);
            }
            try {
                jagged = a.Split(new bool[] { true, true });
                Debug.Fail("Split[T,T] did not fail");
            } catch (ArgumentException ex) {
                Console.WriteLine("Split[T,T] correctly failed with error: " + ex);
            }
            jagged = a.Split(new bool[] { true, false });
            Console.WriteLine("Split[T,F]:");
            Console.WriteLine(jagged);
            jagged = a.Split(new bool[] { false, true });
            Console.WriteLine("Split[F,T]:");
            Console.WriteLine(jagged);
        }
#endif

        [Fact]
        public void BernoulliTest()
        {
            Assert.Equal(0.0, Bernoulli.LogitProbEqual(0, 0));
            Assert.Equal(0.0, Bernoulli.LogitProbEqual(0, Double.PositiveInfinity));
            Assert.Equal(Double.PositiveInfinity, Bernoulli.LogitProbEqual(Double.PositiveInfinity, Double.PositiveInfinity));
            Assert.Equal(Double.NegativeInfinity, Bernoulli.LogitProbEqual(Double.PositiveInfinity, Double.NegativeInfinity));
            Assert.Equal(Double.PositiveInfinity, Bernoulli.LogitProbEqual(Double.NegativeInfinity, Double.NegativeInfinity));

            Bernoulli b = new Bernoulli(0.1);
            DistributionTest(b, new Bernoulli(0.9));
            PointMassTest(b, true);
            UniformTest(b, true);
            b.SetMean(0.1);
            Assert.True(AbsDiff(0.1, b.GetMean()) < 1e-10);
            b.Point = false;
            Assert.True(AbsDiff(0.0, b.GetMean()) < 1e-10);
            b.SetMean(0.0);
            Assert.True(AbsDiff(0.0, b.GetMean()) < 1e-10);
            Assert.True(b.IsPointMass);
            Assert.False(b.Point);

            // Test the LogitProbEqual calculation
            double logodds1 = -2.0;
            double logodds2 = 0.5;
            Bernoulli b1 = Bernoulli.FromLogOdds(logodds1);
            Bernoulli b2 = Bernoulli.FromLogOdds(logodds2);
            double probtrue1 = b1.GetProbTrue();
            double probtrue2 = b2.GetProbTrue();
            double probx1Eqx2 = (probtrue1 * probtrue2) + (1 - probtrue1) * (1 - probtrue2);
            double logoddsCalc = MMath.Logit(probx1Eqx2);
            double logoddsFunc = Bernoulli.LogitProbEqual(logodds1, logodds2);
            Assert.True(AbsDiff(logoddsCalc, logoddsFunc) < 1e-10);
        }

        [Fact]
        public void DiscreteTest()
        {
            Assert.True(new Discrete(0, 0.71743990380862455, 0.2825600961913754).GetLogAverageOf(Discrete.Uniform(3)) == -System.Math.Log(3));

            Discrete d = new Discrete(0.9, 0.1);
            DistributionTest(d, new Discrete(0.2, 0.8));
            PointMassTest(d, 1);
            UniformTest(d, 1);
            PointMassMomentTest(d, 1, 0.2, 0.1);
            d.SetToUniform();
            GetMomentTest(d, 0.5, 0.25);
            SamplingTest(d, 1);

            Discrete d1 = new Discrete(0.1, 0.9, 0, 0);
            Discrete d2 = new Discrete(0, 0, 0.3, 0.7);
            Assert.True(MMath.AbsDiff(d2.GetAverageLog(d2), 0.3 * System.Math.Log(0.3) + 0.7 * System.Math.Log(0.7), 1 - 6) < 1e-10);
            try
            {
                Discrete d3 = d1 * d2;
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }
            try
            {
                Discrete d3 = new Discrete(0, 0, 0);
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }
            try
            {
                d.SetProbs(Vector.FromArray(0.0, 0.0));
                Assert.True(false, "Did not throw exception");
            }
            catch (AllZeroException)
            {
            }

            d = new Discrete(1.0);
            Assert.Equal(0, d.Sample());
            Assert.Equal(0, d.Sample(4));
            Vector p = d.GetWorkspace();
            p[0] = 2.0;
            d.SetProbs(p);
            Assert.Equal(0.0, d.MaxDiff(Discrete.Uniform(1)));
            d = Discrete.PointMass(0, 1);
            DistributionTest(d, new Discrete(1.0));
            UniformTest(d, 0);
            PointMassMomentTest(d, 0, 0.2, 0.1);
            d.SetToUniform();
            GetMomentTest(d, 0.0, 0.0);

            d = Discrete.Uniform(0);
            DistributionTest(d, new Discrete());

            // Sampling when probability vector is sparse
            double[] pcd1 = new double[] { 0.1, 0.3, 0.4, 0.1, 0.1 };
            double[] pcd2 = new double[] { 0.0, 0.4, 0.6, 0.0, 0.0 };
            Vector[] pcv1 = new Vector[4];
            Vector[] pcv2 = new Vector[4];
            Sparsity approxSparsity = Sparsity.ApproximateWithTolerance(0.001);
            pcv1[0] = Vector.FromArray(pcd1);
            pcv1[1] = Vector.FromArray(pcd1, Sparsity.Sparse);
            pcv1[2] = Vector.FromArray(pcd1, approxSparsity);
            pcv1[3] = DenseVector.FromArrayReference(3, pcd1, 2);
            pcv2[0] = Vector.FromArray(pcd2);
            pcv2[1] = Vector.FromArray(pcd2, Sparsity.Sparse);
            pcv2[2] = Vector.FromArray(pcd2, approxSparsity);
            pcv2[3] = DenseVector.FromArrayReference(3, pcd2, 2);
            for (int i = 0; i < pcv1.Length; i++)
            {
                SamplingTest(new Discrete(pcv1[i]), 1);
                SamplingTest(new Discrete(pcv2[i]), 1);
            }

            d = new Discrete(1.0);
            Assert.Equal(0, d.GetMedian());
            d = new Discrete(0.1, 0.2, 0.0, 0.7);
            Assert.Equal(3, d.GetMedian());

            // Test partial uniform
            d = new Discrete(SparseVector.FromArray(0.0, 0.5, 0.5, 0.0));
            Assert.True(d.IsPartialUniform());
            d.SetToUniform();
            Assert.True(d.IsPartialUniform());
            d = new Discrete(SparseVector.FromArray(0.0, 0.3, 0.7, 0.0));
            Assert.False(d.IsPartialUniform());
            d.SetToPartialUniformOf(d);
            Assert.True(d.IsPartialUniform());
            d = new Discrete(SparseVector.FromArray(0.0, 0.3, 0.6, 0.1));
            Assert.False(d.IsPartialUniform());
            d.Point = 1;
            Assert.True(d.IsPartialUniform());
            d2 = Discrete.PointMass(2, 4);
            d.SetToPartialUniformOf(d2);
            Assert.True(d.IsPartialUniform());
            Assert.True(d.IsPointMass && d.Point == 2);
        }

        [Fact]
        [Trait("Category", "ModifiesGlobals")]
        public void DirichletTest()
        {
            Vector mTrue = Vector.FromArray(0.1, 0.2, 0.3, 0.4);
            Dirichlet d = new Dirichlet(mTrue * 7);
            Vector vTrue = Vector.Zero(d.Dimension);
            Vector m = Vector.Zero(d.Dimension);
            Vector v = Vector.Zero(d.Dimension);
            d.GetMeanAndVariance(mTrue, vTrue);
            d.SetMeanAndVariance(mTrue, vTrue);
            d.GetMeanAndVariance(m, v);
            Assert.True(mTrue.MaxDiff(m) < 1e-10);
            Assert.True(vTrue.MaxDiff(v) < 1e-10);

            DistributionTest(d, Dirichlet.Symmetric(d.Dimension, 7.7));
            using (TestUtils.TemporarilyAllowDirichletImproperSums)
            {
                DistributionTest(d, Dirichlet.Symmetric(d.Dimension, 7.7));
            }
            PointMassTest(d, mTrue);
            UniformTest(d, mTrue);
            SetMomentTest(d, mTrue, vTrue);
            PointMassMomentTest(d, mTrue, m, vTrue);
            d.SetToUniform();
            GetAndSetMomentTest(d,
                                Vector.Constant(4, 0.25),
                                Vector.Constant(4, 0.25 * 0.75 / 5));

            DirichletSamplingTest(d);

            // Small pseudocount test
            DirichletSamplingTest(new Dirichlet(1e-5, 2e-5, 3e-5, 4e-5));

            // Small/large pseudocount test
            DirichletSamplingTest(new Dirichlet(1e-5, 2e5, 3e5, 4e-5));

            // Sparse vector pseudocount tests
            double[] pcd1 = new double[] { 1.2, 2.3, 3.4, 1.2, 1.2 };
            double[] pcd2 = new double[] { 0.0, 2.3, 3.4, 0.0, 0.0 };
            Vector[] pcv1 = new Vector[4];
            Vector[] pcv2 = new Vector[4];
            Sparsity approxSparsity = Sparsity.ApproximateWithTolerance(0.001);
            pcv1[0] = Vector.FromArray(pcd1);
            pcv1[1] = Vector.FromArray(pcd1, Sparsity.Sparse);
            pcv1[2] = Vector.FromArray(pcd1, approxSparsity);
            pcv1[3] = DenseVector.FromArrayReference(3, pcd1, 2);
            pcv2[0] = Vector.FromArray(pcd2);
            pcv2[1] = Vector.FromArray(pcd2, Sparsity.Sparse);
            pcv2[2] = Vector.FromArray(pcd2, approxSparsity);
            pcv2[3] = DenseVector.FromArrayReference(3, pcd2, 2);
            for (int i = 0; i < pcv1.Length; i++)
            {
                DirichletSamplingSparseTest(new Dirichlet(pcv1[i]));
                DirichletSamplingSparseTest(new Dirichlet(pcv2[i]));
            }
        }

        private static void DirichletSamplingTest(Dirichlet d)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Vector sample = Vector.Zero(d.Dimension);
            Vector meanSample = Vector.Zero(d.Dimension);
            Vector mean2Sample = Vector.Zero(d.Dimension);
            Vector mean3Sample = Vector.Zero(d.Dimension);
            Vector meanLogSample = Vector.Zero(d.Dimension);
            Vector temp = Vector.Zero(d.Dimension);
            for (int i = 0; i < nsamples; i++)
            {
                d.Sample(sample);
                meanSample.SetToSum(meanSample, sample);
                mean2Sample.SetToSum(mean2Sample, temp.SetToFunction(sample, x => x * x));
                mean3Sample.SetToSum(mean3Sample, temp.SetToFunction(sample, x => x * x * x));
                meanLogSample.SetToSum(meanLogSample, temp.SetToFunction(sample, System.Math.Log));
            }
            meanSample.Scale(1.0 / nsamples);
            mean2Sample.Scale(1.0 / nsamples);
            mean3Sample.Scale(1.0 / nsamples);
            meanLogSample.Scale(1.0 / nsamples);
            Vector mean = d.GetMean();
            Console.WriteLine("mean = {0} should be {1}", meanSample, mean);
            Assert.True(mean.MaxDiff(meanSample) < 5e-3);
            Vector mean2 = d.GetMeanSquare();
            Console.WriteLine("mean2 = {0} should be {1}", mean2Sample, mean2);
            Assert.True(mean2.MaxDiff(mean2Sample) < 5e-3);
            Vector mean3 = d.GetMeanCube();
            Console.WriteLine("mean3 = {0} should be {1}", mean3Sample, mean3);
            Assert.True(mean3.MaxDiff(mean3Sample) < 5e-3);
            Vector meanLog = d.GetMeanLog();
            Console.WriteLine("meanLog = {0} should be {1}", meanLogSample, meanLog);
            if (meanLog.Min() > -70)
            {
                Assert.True(meanLog.MaxDiff(meanLogSample) < 1e-2);
            }
        }

        private static void DirichletSamplingSparseTest(Dirichlet d)
        {
            Rand.Restart(12347); // Restart random number generator so as to get a consistent test
            Vector v = d.PseudoCount;
            Vector result = null;

            // Check both versions
            for (int pass = 0; pass < 2; pass++)
            {
                if (pass == 0)
                {
                    result = Vector.Constant(v.Count, 1.234, v.Sparsity);
                    d.Sample(result);
                }
                else
                    result = d.Sample();

                // Check that if any pseudo-counts are 0, then the sample is 0
                // Check for non zero that there are no repeat elements in the sample
                Dictionary<double, bool> dic = new Dictionary<double, bool>();
                for (int i = 0; i < v.Count; i++)
                {
                    double r = result[i];
                    if (v[i] == 0.0)
                        Assert.Equal(0.0, r);
                    else
                    {
                        // Here we are testing that a sparse Dirichlet is not generating the same
                        // sample value for all common value indices
                        if (dic.ContainsKey(r))
                            Assert.True(false, "Dirichlet sampler: repeat element");
                        dic[r] = true;
                    }
                }
            }
        }

        [Fact]
        public void DirichletEstimateNewtonTest()
        {
            Vector alphaTrue = Vector.FromArray(0.1, 0.2, 0.3, 0.4);
            alphaTrue.Scale(7);
            DirichletEstimateNewton(alphaTrue);
        }

        private void DirichletEstimateNewton(Vector alphaTrue)
        {
            Dirichlet d = new Dirichlet(alphaTrue);
            Vector meanLog = d.GetMeanLog();
            Console.WriteLine(meanLog);
            d.SetToUniform();
            d.SetMeanLog(meanLog);
            Console.WriteLine("pseudoCount = {0} should be {1}", d.PseudoCount, alphaTrue);
            Assert.True(alphaTrue.MaxDiff(d.PseudoCount) < 1e-6);
        }

        [Fact]
        public void DirichletModeTest()
        {
            Dirichlet d = null;
            Vector v = null;
            for (int iter = 0; iter < 7; iter++)
            {
                if (iter == 0)
                {
                    d = new Dirichlet(0.1, 0.3, 0.4);
                    v = Vector.FromArray(0, 0, 1);
                }
                else if (iter == 1)
                {
                    d = new Dirichlet(1, 0.3, 0.4);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 2)
                {
                    d = new Dirichlet(1.1, 0.3, 0.4);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 3)
                {
                    d = new Dirichlet(0.3, 1, 1);
                    v = Vector.FromArray(0, 0.5, 0.5);
                }
                else if (iter == 4)
                {
                    d = new Dirichlet(1, 1, 1);
                    v = Vector.FromArray(1.0 / 3, 1.0 / 3, 1.0 / 3);
                }
                else if (iter == 5)
                {
                    d = new Dirichlet(1.3, 1, 1);
                    v = Vector.FromArray(1, 0, 0);
                }
                else if (iter == 6)
                {
                    d = new Dirichlet(3, 4, 5);
                    double denom = 3 + 4 + 5 - 3;
                    v = Vector.FromArray(2.0 / denom, 3.0 / denom, 4.0 / denom);
                }
                Vector mode = d.GetMode();
                Console.WriteLine("{0}: {1} (should be {2})", d, mode, v);
                Assert.True(mode.MaxDiff(v) < 1e-10);
            }
        }

        [Fact]
        [Trait("Category", "ModifiesGlobals")]
        public void BetaTest()
        {
            Beta d = new Beta(0.2, 0.1);

            DistributionTest(d, new Beta(4.4, 3.3));
            using (TestUtils.TemporarilyAllowBetaImproperSums)
            {
                DistributionTest(d, new Beta(4.4, 3.3));
            }
            PointMassTest(d, 0.7);
            UniformTest(d, 0.7);
            PointMassMomentTest(d, 0.6, 0.2, 0.1);
            d.SetToUniform();
            GetAndSetMomentTest(d, 0.5, 1.0 / 12);
            SamplingTest(d, 0.7);
            SamplingTest(new Beta(1e-5, 2e-5), 0.7);
        }

        internal void BetaEstimateNewtonTest()
        {
            Beta d = new Beta(0.2, 0.1);
            double eLogP, eLogOneMinusP;
            d.GetMeanLogs(out eLogP, out eLogOneMinusP);
            Beta d2 = Beta.FromMeanLogs(eLogP, eLogOneMinusP);
            Console.WriteLine("FromMeanLogs = {0} should be {1}", d2, d);
            Assert.True(d.MaxDiff(d2) < 1e-6);
        }

        internal void BetaFromDerivativesTest()
        {
            Beta d = new Beta(0.2, 0.1);
            double x = 0.3;
            double delta = 1e-7;
            double dLogP, ddLogP;
            dLogP = (d.GetLogProb(x + delta) - d.GetLogProb(x - delta)) / (2 * delta);
            //ddLogP = (d.GetLogProb(x + delta) - 2*d.GetLogProb(x) + d.GetLogProb(x - delta)) / (delta*delta);
            ddLogP = -(d.TrueCount - 1) / x / x - (d.FalseCount - 1) / (1 - x) / (1 - x);
            Beta d2 = Beta.FromDerivatives(x, dLogP, ddLogP, false);
            Console.WriteLine("FromDerivatives = {0} should be {1}", d2, d);
            Assert.True(d.MaxDiff(d2) < 1e-6);
        }

        [Fact]
        public void PoissonTest()
        {
            Rand.Restart(12347);
            double rate = 0.3;
            Poisson geo = new Poisson(rate, 0);
            double m = rate / (1 - rate);
            Assert.True(MMath.AbsDiff(m, geo.GetMean()) < 1e-10);
            Assert.True(MMath.AbsDiff(m / (1 - rate), geo.GetVariance()) < 1e-10);
            // m=0.3; x = 0:1000; sum(m.^x*(1-m).*gammaln(x+1))
            Assert.True(MMath.AbsDiff(0.109116895970604, geo.GetMeanLogFactorial()) < 1e-10);

            Poisson d = new Poisson(1.2);
            PointMassTest(d, 3);
            UniformTest(d, 3);
            PointMassMomentTest(d, 3, 0.2, 0.1);
            GetAndSetMomentTest(d, 1.2, 1.2);
            DistributionTest(d, new Poisson(3.4));
            SamplingTest(d, 3);

            rate = 0.5;
            for (int i = 0; i < 6; i++)
            {
                d = new Poisson(rate);
                SamplingTest(d, 3);
                rate *= 10;
                rate += 0.5;
            }
        }

        [Fact]
        public void PoissonTest2()
        {
            Poisson d = new Poisson(1.2, 0.4);
            double sum = 0;
            double sumX = 0, sumX2 = 0;
            double sumLogFact = 0;
            double sumLogFact2 = 0;
            double sumXLogFact = 0;
            for (int i = 0; i < 1000; i++)
            {
                double p = System.Math.Exp(d.GetLogProb(i));
                sum += p;
                sumX += i * p;
                sumX2 += i * i * p;
                double logFact = MMath.GammaLn(i + 1);
                sumLogFact += logFact * p;
                sumLogFact2 += logFact * logFact * p;
                sumXLogFact += i * logFact * p;
            }
            double meanEst = sumX / sum;
            double varEst = sumX2 / sum - meanEst * meanEst;
            double meanLogFactEst = sumLogFact / sum;
            double meanLogFact2Est = sumLogFact2 / sum;
            double meanXLogFactEst = sumXLogFact / sum;
            double Z = System.Math.Exp(Poisson.GetLogNormalizer(d.Rate, d.Precision));
            double mean = System.Math.Exp(Poisson.GetLogPowerSum(d.Rate, d.Precision, 1)) / Z;
            double var = System.Math.Exp(Poisson.GetLogPowerSum(d.Rate, d.Precision, 2)) / Z - mean * mean;
            double meanLogFact = d.GetMeanLogFactorial();
            double meanLogFact2 = Poisson.GetSumLogFactorial2(d.Rate, d.Precision) / Z;
            double meanXLogFact = Poisson.GetSumXLogFactorial(d.Rate, d.Precision) / Z;
            Assert.True(MMath.AbsDiff(mean, meanEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(var, varEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanLogFact, meanLogFactEst, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanLogFact2, meanLogFact2Est, 1e-6) < 1e-4);
            Assert.True(MMath.AbsDiff(meanXLogFact, meanXLogFactEst, 1e-6) < 1e-4);
            double varLogFact = meanLogFact2 - meanLogFact * meanLogFact;
            double covXLogFact = meanXLogFact - mean * meanLogFact;

            Poisson d2 = Poisson.FromMeanAndMeanLogFactorial(mean, meanLogFact);
            Console.WriteLine("d2 = {0} should be {1}", d2, d);
            Assert.True(d2.MaxDiff(d) < 1e-4);

            PointMassTest(d, 3);
            UniformTest(d, 3);
            PointMassMomentTest(d, 3, 0.2, 0.1);
            //SetMomentTest(d, 1.2, 3.4);
            DistributionTest(d, new Poisson(3.4, 1.5));
            SamplingTest(d, 3);
        }

        [Fact]
        public void PoissonTest3()
        {
            double mean = 38.914480999999995;
            double meanLogFact = 115.79687593320728;
            // These cannot be satisfied:
            //double mean = 26.503113193371764;
            //double meanLogFact = 77.463522658901041;
            // Poisson expected = new Poisson(1.09452821574556, 0.029552860669053);
            var actual = Poisson.FromMeanAndMeanLogFactorial(mean, meanLogFact);
            double actualMean = actual.GetMean();
            double actualMeanLogFact = actual.GetMeanLogFactorial();
            Assert.True(MMath.AbsDiff(actualMean, mean) < 1e-4);
            Assert.True(MMath.AbsDiff(actualMeanLogFact, meanLogFact) < 1e-4);
        }

        [Fact]
        public void BetaSumTest()
        {
            Beta b1 = new Beta(2, 2);
            Beta b2 = new Beta(3, 3);
            Beta b = new Beta();
            b.SetToSum(0.9, b1, 0.1, b2);
            Console.WriteLine(b);
        }

        [Fact]
        public void DirichletSumTest()
        {
            Beta b1 = new Beta(2, 1);
            Beta b2 = new Beta(4, 3);
            Beta b = new Beta();
            b.SetToSum(0.9, b1, 0.1, b2);

            Dirichlet d1 = new Dirichlet(1.0, 2);
            Dirichlet d2 = new Dirichlet(3.0, 4);
            Dirichlet d = Dirichlet.Uniform(2);
            d.SetToSum(0.9, d1, 0.1, d2);

            Assert.True(MMath.AbsDiff(d.TotalCount, b.TotalCount, 1e-6) < 1e-10);
            Assert.True(d.PseudoCount.MaxDiff(Vector.FromArray(b.FalseCount, b.TrueCount)) < 1e-10);
        }

        [Fact]
        public void DirichletSumMergeTest()
        {
            Dirichlet d1 = new Dirichlet(2.0, 3.5, 5, 7);
            Dirichlet d2 = new Dirichlet(1.0, 4, 5, 7);
            Dirichlet d = Dirichlet.Uniform(d1.Dimension);
            d.SetToSum(0.9, d1, 0.1, d2);

            Dirichlet s1 = new Dirichlet(2.0, 3.5, 12);
            Dirichlet s2 = new Dirichlet(1.0, 4, 12);
            Dirichlet s = Dirichlet.Uniform(s1.Dimension);
            s.SetToSum(0.9, s1, 0.1, s2);

            Vector dMean = d.GetMean();
            Vector sMean = s.GetMean();
            Vector dMean2 = Vector.Zero(sMean.Count);
            dMean2[0] = dMean[0];
            dMean2[1] = dMean[1];
            dMean2[2] = dMean[2] + dMean[3];
            Assert.True(dMean2.MaxDiff(sMean) < 1e-10);
            Assert.True(MMath.AbsDiff(d.TotalCount, s.TotalCount, 1e-6) < 1e-10);
        }

        [Fact]
        public void GaussianSetToRatioProperTest()
        {
            Gaussian numerator = new Gaussian(5, 4);
            Gaussian denominator = new Gaussian(3, 2);
            Gaussian r = new Gaussian();
            r.SetToRatio(numerator, denominator, true);
            Console.WriteLine("ratio: {0}", r);
            Console.WriteLine("ratio*denom: {0} (should be {1})", r * denominator, new Gaussian(5, 2));
            Assert.True(MMath.AbsDiff((r * denominator).GetMean(), numerator.GetMean(), 1e-8) < 1e-10);
        }

        [Fact]
        public void GammaGetProbLessThanTest()
        {
            // exponential distribution with density exp(-x/m)/m and cdf 1-exp(-x/m)
            double m = 2.3;
            Gamma g = new Gamma(1.0, m);
            double median = -m * System.Math.Log(0.5);
            Assert.Equal(0.5, g.GetProbLessThan(median), 1e-4);
            AssertAlmostEqual(median, g.GetQuantile(0.5));

            g = new Gamma(2, m);
            double probability = g.GetProbLessThan(median);
            double quantile = g.GetQuantile(probability);
            Assert.Equal(median, quantile, 1e-10);
        }

        internal static void AssertAlmostEqual(double x, double y)
        {
            Assert.False(SpecialFunctionsTests.IsErrorSignificant(1e-16, x - y));
        }

        [Fact]
        public void GammaModeTest()
        {
            Gamma g = new Gamma();
            double expected = 0;
            for (int i = 0; i < 7; i++)
            {
                if (i == 0)
                {
                    g = Gamma.FromShapeAndRate(0.1, 0);
                    expected = 0;
                }
                else if (i == 1)
                {
                    g = Gamma.FromShapeAndRate(0.1, 2);
                    expected = 0;
                }
                else if (i == 2)
                {
                    g = Gamma.FromShapeAndRate(1, 2);
                    expected = 0;
                }
                else if (i == 3)
                {
                    g = Gamma.FromShapeAndRate(0, 2);
                    expected = 0;
                }
                else if (i == 4)
                {
                    g = Gamma.FromShapeAndRate(1.1, 2);
                    expected = 0.1 / 2;
                }
                else if (i == 5)
                {
                    g = Gamma.FromShapeAndRate(1, 0);
                    expected = 0;
                }
                else if (i == 6)
                {
                    g = Gamma.FromShapeAndRate(1.1, 0);
                    expected = double.PositiveInfinity;
                }
                double m = g.GetMode();
                Console.WriteLine("{0}: {1} (should be {2})", g, m, expected);
                Assert.True(MMath.AbsDiff(m, expected, 1e-10) < 1e-10);
            }
        }

        [Fact]
        public void GammaSetToRatioTest()
        {
            Gamma numerator = Gamma.FromShapeAndRate(1e20, 1);
            Gamma denominator = numerator;
            Gamma r = numerator / denominator;
            Assert.True(r.IsUniform());
        }

        [Fact]
        public void GammaSetToRatioProperTest()
        {
            foreach (Gamma numerator in new[] {
                Gamma.FromShapeAndRate(0.5, 0.5),
                Gamma.FromShapeAndRate(4, 5),
            })
            {
                foreach (var denominator in new[]
                {
                    Gamma.Uniform(),
                    Gamma.FromShapeAndRate(6, 3),
                    Gamma.FromShapeAndRate(6,7),
                    Gamma.FromShapeAndRate(3,7)
                })
                {
                    Gamma r = new Gamma();
                    r.SetToRatio(numerator, denominator, true);
                    //Trace.WriteLine($"ratio: {r} ratio*denom: {r * denominator} (numerator was {numerator})");
                    Assert.True(r.Shape >= 1);
                    Assert.True(r.Rate >= 0);
                    Assert.True(MMath.AbsDiff((r * denominator).GetMean(), numerator.GetMean(), 1e-8) < 1e-10);
                    // It is counter-intuitive that uniform denominator doesn't return numerator.
                    //if (denominator.IsUniform()) Assert.Equal(numerator, r);
                }
            }
        }

        [Fact]
        public void WishartSetToRatioProperTest()
        {
            int dim = 1;
            Wishart numerator = Wishart.FromShapeAndRate(4, PositiveDefiniteMatrix.IdentityScaledBy(dim, 5));
            foreach (Wishart denominator in new[] {
                Wishart.FromShapeAndRate(6, PositiveDefiniteMatrix.IdentityScaledBy(dim, 3)),
                Wishart.FromShapeAndRate(6, PositiveDefiniteMatrix.IdentityScaledBy(dim, 7)),
                Wishart.FromShapeAndRate(3, PositiveDefiniteMatrix.IdentityScaledBy(dim, 7)),
            })
            {
                Wishart r = new Wishart(dim);
                r.SetToRatio(numerator, denominator, true);
                //Trace.WriteLine($"ratio: {r} ratio*denom: {r * denominator} (numerator was {numerator})");
                Assert.True(r.Shape >= (dim + 1) / 2.0);
                Assert.True((r * denominator).GetMean().MaxDiff(numerator.GetMean()) < 1e-10);
            }
        }

        [Fact]
        public void GammaFromMeanAndMeanLogTest()
        {
            GammaFromMeanAndMeanLog(new Gamma(3, 4));
            GammaFromMeanAndMeanLog(Gamma.PointMass(3));
            Gamma estimated = Gamma.FromMeanAndMeanLog(0, -1e303);
            Assert.True(estimated.IsPointMass && estimated.Point == 0);
        }

        private void GammaFromMeanAndMeanLog(Gamma original)
        {
            double mean = original.GetMean();
            double meanLog = original.GetMeanLog();
            Gamma estimated = Gamma.FromMeanAndMeanLog(mean, meanLog);
            //Console.WriteLine("original = {0}", original);
            //Console.WriteLine("estimated = {0}", estimated);
            Assert.True(original.MaxDiff(estimated) < 1e-10);
        }

        [Fact]
        public void WishartFromMeanAndMeanLogTest()
        {
            PositiveDefiniteMatrix m3 = new PositiveDefiniteMatrix(new double[,] { { 4, 2, 1 }, { 2, 4, 2 }, { 1, 2, 4 } });
            PositiveDefiniteMatrix m2 = new PositiveDefiniteMatrix(new double[,] { { 2, 1 }, { 1, 2 } });
            WishartFromMeanAndMeanLog(new Wishart(3, m2));
            WishartFromMeanAndMeanLog(Wishart.PointMass(m2));
            WishartFromMeanAndMeanLog(new Wishart(4, m3));
            WishartFromMeanAndMeanLog(Wishart.PointMass(m3));
        }

        private void WishartFromMeanAndMeanLog(Wishart original)
        {
            var mean = original.GetMean();
            double meanLog = original.GetMeanLogDeterminant();
            var estimated = Wishart.FromMeanAndMeanLogDeterminant(mean, meanLog);
            Console.WriteLine("original = {0}", original);
            Console.WriteLine("estimated = {0}", estimated);
            Assert.True(original.MaxDiff(estimated) < 1e-10);
        }

        [Fact]
        [Trait("Category", "StringInference")]
        public void StringDistributionTest()
        {
            StringDistribution dist1 = StringDistribution.OneOf("a", "ab", "bcd");
            StringDistribution dist2 = StringDistribution.Capitalized();
            StringDistribution dist3 = StringDistribution.Upper().Append(StringDistribution.Lower());

            stringDistributionTest(dist1, dist2);
            stringDistributionTest(dist1, dist3);
            stringDistributionTest(dist2, dist3);

            StringDistributionPointMassTest(dist1, "ab");
            StringDistributionPointMassTest(dist2, "Abc");
            StringDistributionPointMassTest(dist3, "ABcd");

            InnerProductWithUniformTest(dist1, "ab");
            InnerProductWithUniformTest(dist1, "ad");
            InnerProductWithUniformTest(dist2, "Abc");
            InnerProductWithUniformTest(dist2, "ABbc");
            InnerProductWithUniformTest(dist3, "ABcd");
            InnerProductWithUniformTest(dist3, "cdAB");
        }

        private static void stringDistributionTest(
            StringDistribution distribution1, StringDistribution distribution2)
        {
            ProductWithUniformTest(distribution1);
            ProductWithUniformTest(distribution2);

            SettableToTest(distribution1);
            SettableToTest(distribution2);

            SettableToWeightedSumTest(distribution1, distribution2, false);
        }

        private static void StringDistributionPointMassTest(StringDistribution distribution, string value)
        {
            ProductWithPointMassTest(distribution, value);
            InnerProductPointMassTest(distribution, value);
            PointMassSampleTest(distribution, value);
        }

        // Generic high-level tests ///////////////////////////////////////////////////////////////////////////

        internal static void DistributionTest<T>(T a, T b, bool doSumWithNegativeWeightsTests = true)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, SettableToWeightedSum<T>,
                ICloneable, Diffable, SettableTo<T>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>
        {
            Assert.False(a.Equals(null));
            ProductWithUniformTest(a);
            ProductWithUniformTest(b);

            RatioWithUniformTest(a);
            RatioWithUniformTest(b);
            SettableToRatioTest(a, b);

            SettableToPowerTest(a);
            SettableToPowerTest(b);
            LogAverageOfPowerTest(a, b);

            SettableToTest(a);
            SettableToTest(b);

            SettableToWeightedSumTest(a, b, doSumWithNegativeWeightsTests);
        }

        internal static void PointMassTest<T, DomainType>(T a, DomainType value)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, SettableToWeightedSum<T>,
                ICloneable, Diffable, SettableTo<T>, HasPoint<DomainType>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetLogProb<DomainType>,
                CanGetAverageLog<T>, Sampleable<DomainType>
        {
            ProductWithPointMassTest(a, value);
            RatioWithPointMassTest(a, value);
            PointMassPowerTest(a, value);
            AverageLogPointMassTest(a, value);
            InnerProductPointMassTest(a, value);
            PointMassSampleTest(a, value);
            PointMassGetLogProbTest(a, value);
        }

        internal static void UniformTest<T, DomainType>(T a, DomainType value)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetAverageLog<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            InnerProductWithUniformTest(a, value);
            AverageLogUniformTest(a, value);
        }

        /// <summary>
        /// Check that the moments of a point mass distribution can be get and set.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a">A distribution to clone.</param>
        /// <param name="value"></param>
        /// <param name="mean">A dummy value used only for type inference.</param>
        /// <param name="variance">A dummy value used only for type inference.</param>
        private static void PointMassMomentTest<T, DomainType, MeanType, VarianceType>(T a, DomainType value, MeanType mean, VarianceType variance)
            where T : HasPoint<DomainType>, CanGetMean<MeanType>, CanGetVariance<VarianceType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            MeanType valueMean = b.GetMean();
            VarianceType zero = (VarianceType)GetZero(b.GetVariance());
            GetMomentTest(b, valueMean, zero);
            if (b is CanSetMeanAndVariance<MeanType, VarianceType> MeanTypes)
            {
                MeanTypes.SetMeanAndVariance(valueMean, zero);
                GetMomentTest(b, valueMean, zero);
                Assert.True(b.IsPointMass);
                Assert.Equal(value, b.Point);
            }
        }

        private static void PointMassSampleTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, Sampleable<DomainType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            for (int iter = 0; iter < 3; iter++)
            {
                DomainType sample = b.Sample();
                AssertEqual(sample, value);
            }
        }

        private static void PointMassGetLogProbTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetLogProb<DomainType>, ICloneable
        {
            T b = (T)a.Clone();
            b.Point = value;
            Assert.Equal(0.0, b.GetLogProb(value));
            Assert.Equal(double.NegativeInfinity, b.GetLogProb(default(DomainType)));
        }

        private static void AssertEqual(object a, object b)
        {
            // todo: handle types that don't implement value equality
            Assert.True(a.Equals(b));
            Assert.True(a.GetHashCode() == b.GetHashCode());
        }

        private static void SamplingTest<T, DomainType>(T d, DomainType value)
            where T : Sampleable<DomainType>, CanGetMean<double>, CanGetVariance<double>
        {
            Rand.Restart(12347);
            MeanVarianceAccumulator mva = new MeanVarianceAccumulator();
            for (int iter = 0; iter < 2000000; iter++)
            {
                DomainType sample = d.Sample();
                mva.Add(Convert.ToDouble(sample));
            }
            Console.WriteLine("mean = {0} should be {1}", mva.Mean, d.GetMean());
            Console.WriteLine("variance = {0} should be {1}", mva.Variance, d.GetVariance());
            Assert.True(MMath.AbsDiff(mva.Mean, d.GetMean(), 1e-6) < 1e-2);
            Assert.True(MMath.AbsDiff(mva.Variance, d.GetVariance(), 1e-6) < 1e-2);
        }

        /// <summary>
        /// Clone a distribution, change the moments, and read them back.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a"></param>
        /// <param name="mean"></param>
        /// <param name="variance"></param>
        private static void SetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>, CanSetMeanAndVariance<MeanType, VarianceType>, ICloneable
        {
            T b = (T)a.Clone();
            b.SetMeanAndVariance(mean, variance);
            GetMomentTest(b, mean, variance);
        }

        /// <summary>
        /// Check that the moments match those given.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <typeparam name="MeanType"></typeparam>
        /// <typeparam name="VarianceType"></typeparam>
        /// <param name="a"></param>
        /// <param name="mean"></param>
        /// <param name="variance"></param>
        private static void GetAndSetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>, ICloneable, CanSetMeanAndVariance<MeanType, VarianceType>
        {
            MeanType actualMean = a.GetMean();
            VarianceType actualVariance = a.GetVariance();
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
            SetMomentTest(a, mean, variance);
        }

        // Helper tests ///////////////////////////////////////////////////////////////////////////

        private static void InnerProductWithUniformTest<DomainType, T>(T a, DomainType value)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(MMath.AbsDiff(a.GetLogAverageOf(uniform), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(uniform.GetLogAverageOf(a), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(a.GetLogAverageOfPower(uniform, 1), uniform.GetLogProb(value), 1e-6) < 1e-8);
            Assert.True(MMath.AbsDiff(uniform.GetLogAverageOfPower(a, 1), uniform.GetLogProb(value), 1e-6) < 1e-8);
        }

        private static void AverageLogUniformTest<DomainType, T>(T a, DomainType value)
            where T : CanGetAverageLog<T>, SettableToUniform, ICloneable, CanGetLogProb<DomainType>
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(MMath.AbsDiff(a.GetAverageLog(uniform), uniform.GetLogProb(value), 1e-6) < 1e-8);
        }

        internal static void ProductWithUniformTest<T>(T a)
            where T : SettableToProduct<T>, SettableToUniform, ICloneable, Diffable
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            Assert.True(uniform.IsUniform());
            Assert.True(a.MaxDiff(a) == 0.0);
            if (!a.Equals(uniform))
                Assert.True(a.MaxDiff(uniform) > 0.0);
            Assert.True(a.MaxDiff(uniform) == uniform.MaxDiff(a));
            T b = (T)a.Clone();
            b.SetToProduct(a, uniform);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToProduct(uniform, a);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToProduct(uniform, uniform);
            Assert.True(uniform.MaxDiff(b) < 1e-10);
        }

        internal static void RatioWithUniformTest<T>(T a)
            where T : SettableToRatio<T>, SettableToUniform, ICloneable, Diffable
        {
            T uniform = (T)a.Clone();
            uniform.SetToUniform();
            T b = (T)a.Clone();
            b.SetToRatio(a, uniform);
            Assert.True(a.MaxDiff(b) < 1e-10);
            b.SetToRatio(uniform, uniform);
            Assert.True(uniform.MaxDiff(b) < 1e-10);
        }

        private static void InnerProductPointMassTest<DomainType, T>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, CanGetLogProb<DomainType>, ICloneable
        {
            T pt = (T)a.Clone();
            pt.Point = value;
            Assert.True(MMath.AbsDiff(a.GetLogAverageOf(pt), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetLogAverageOf(a), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(a.GetLogAverageOfPower(pt, 1), a.GetLogProb(value), 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetLogAverageOfPower(a, 1), a.GetLogProb(value), 1e-8) < 1e-8);
        }

        private static void LogAverageOfPowerTest<T>(T a, T b)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToProduct<T>, ICloneable
        {
            for (int n = 0; n < 3; n++)
            {
                LogAverageOfPowerTest(a, b, n);
            }
        }

        private static void LogAverageOfPowerTest<T>(T a, T b, int n)
            where T : CanGetLogAverageOf<T>, CanGetLogAverageOfPower<T>, SettableToProduct<T>, ICloneable
        {
            double expected = 0;
            T productPrev = default(T);
            for (int i = 0; i < n; i++)
            {
                T product = (T)a.Clone();
                if (i > 0)
                    product.SetToProduct(productPrev, b);
                expected += product.GetLogAverageOf(b);
                productPrev = product;
            }
            double actual = a.GetLogAverageOfPower(b, n);
            Assert.True(MMath.AbsDiff(expected, actual, 1e-8) < 1e-8);
        }

        private static void AverageLogPointMassTest<DomainType, T>(T a, DomainType value)
            where T : HasPoint<DomainType>, CanGetAverageLog<T>, CanGetLogProb<DomainType>, ICloneable
        {
            T pt = (T)a.Clone();
            pt.Point = value;
            Assert.True(MMath.AbsDiff(a.GetAverageLog(pt), Double.NegativeInfinity, 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetAverageLog(pt), 0.0, 1e-8) < 1e-8);
            Assert.True(MMath.AbsDiff(pt.GetAverageLog(a), a.GetLogProb(value), 1e-8) < 1e-8);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="value">Anything other than default(DomainType).</param>
        private static void ProductWithPointMassTest<DomainType, T>(T a, DomainType value)
            where T : SettableToProduct<T>, HasPoint<DomainType>, ICloneable, Diffable
        {
            Assert.False(a.IsPointMass);
            T pt = (T)a.Clone();
            if (object.ReferenceEquals(default(DomainType), null))
            {
                pt.Point = value;
            }
            else
            {
                pt.Point = default(DomainType);
            }
            Assert.True(pt.IsPointMass);
            T b = (T)a.Clone();
            AssertEqual(a, b);
            b.SetToProduct(a, pt);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            b.SetToProduct(pt, a);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            b.SetToProduct(pt, pt);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            T pt2 = (T)a.Clone();
            pt2.Point = pt.Point;
            AssertEqual(pt, pt2);
            pt2.Point = value;
            if (!(a is System.Collections.ICollection))
            {
                Assert.True(pt2.Point.Equals(value));
                if (!pt.Point.Equals(pt2.Point))
                {
                    try
                    {
                        b.SetToProduct(pt, pt2);
                        Assert.True(false, "AllZeroException not thrown");
                    }
                    catch (AllZeroException)
                    {
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="DomainType"></typeparam>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="value">Anything other than default(DomainType).</param>
        private static void RatioWithPointMassTest<DomainType, T>(T a, DomainType value)
            where T : SettableToRatio<T>, SettableToUniform, HasPoint<DomainType>, ICloneable, Diffable
        {
            Assert.False(a.IsPointMass);
            T pt = (T)a.Clone();
            pt.Point = value;
            T b = (T)a.Clone();
            b.SetToRatio(pt, a);
            Assert.True(pt.MaxDiff(b) < 1e-10);
            try
            {
                b.SetToRatio(a, pt);
                Assert.True(false, "DivideByZeroException not thrown");
            }
            catch (DivideByZeroException)
            {
            }
            if (false)
            {
                try
                {
                    b.SetToRatio(pt, pt);
                    Assert.True(false, "DivideByZeroException not thrown");
                }
                catch (DivideByZeroException)
                {
                }
            }
            if (false)
            {
                b.SetToRatio(pt, pt);
                T uniform = (T)a.Clone();
                uniform.SetToUniform();
                Assert.True(uniform.MaxDiff(b) < 1e-10);
            }
            T pt2 = (T)a.Clone();
            pt2.Point = value;
            if (!(a is System.Collections.ICollection))
            {
                if (!pt.Point.Equals(pt2.Point))
                {
                    try
                    {
                        b.SetToRatio(pt, pt2);
                        Assert.True(false, "DivideByZeroException not thrown");
                    }
                    catch (DivideByZeroException)
                    {
                    }
                }
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        /// <param name="b">A distribution that is everywhere non-zero</param>
        private static void SettableToRatioTest<T>(T a, T b)
            where T : SettableToProduct<T>, SettableToRatio<T>, ICloneable, Diffable, SettableToUniform
        {
            T c = (T)a.Clone();
            c.SetToProduct(a, b);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(a) > 0.0);
            if (!a.IsUniform())
                Assert.True(c.MaxDiff(b) > 0.0);
            Assert.True(c.MaxDiff(a) == a.MaxDiff(c));
            Assert.True(c.MaxDiff(b) == b.MaxDiff(c));
            c.SetToRatio(c, b);
            Assert.True(a.MaxDiff(c) < 1e-10);
            c.SetToRatio(a, b);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(a) > 0.0);
            if (!b.IsUniform())
                Assert.True(c.MaxDiff(b) > 0.0);
            Assert.True(c.MaxDiff(a) == a.MaxDiff(c));
            Assert.True(c.MaxDiff(b) == b.MaxDiff(c));
            c.SetToProduct(c, b);
            Assert.True(a.MaxDiff(c) < 1e-10);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a">A distribution that is everywhere non-zero</param>
        private static void SettableToPowerTest<T>(T a)
            where T : SettableToProduct<T>, SettableToRatio<T>, SettableToPower<T>, SettableToUniform, ICloneable, Diffable
        {
            T c = (T)a.Clone();
            c.SetToPower(a, 2.0);
            c.SetToPower(c, 0.5);
            Assert.True(a.MaxDiff(c) < 1e-10);
            c.SetToPower(a, 2.0);
            c.SetToRatio(c, a);
            Assert.True(a.MaxDiff(c) < 1e-10);
            try
            {
                c.SetToPower(a, -1.0);
                c.SetToProduct(c, a);
                c.SetToProduct(c, a);
                Assert.True(a.MaxDiff(c) < 1e-10);
            }
            catch
            {
            }

            c.SetToPower(a, 1.0);
            Assert.True(a.MaxDiff(c) < 1e-12);
            c.SetToPower(a, 0.0);
            Assert.True(c.IsUniform());
        }

        private static void PointMassPowerTest<T, DomainType>(T a, DomainType value)
            where T : HasPoint<DomainType>, SettableToPower<T>, Diffable, SettableToUniform, ICloneable
        {
            T c = (T)a.Clone();
            c.Point = value;
            Assert.True(c.IsPointMass);
            c.SetToPower(c, 0.0);
            Assert.True(c.IsUniform());
            c.Point = value;
            c.SetToPower(c, 0.1);
            Assert.True(c.IsPointMass);
            AssertEqual(c.Point, value);
            try
            {
                c.SetToPower(c, -0.1);
                Assert.True(false, "DivideByZeroException not thrown");
            }
            catch (DivideByZeroException)
            {
            }
        }

        internal static void SettableToTest<T>(T a)
            where T : SettableTo<T>, SettableToUniform, ICloneable
        {
            T b = (T)a.Clone();
            b.SetToUniform();
            b.SetTo(a);
            Assert.True(b.IsUniform() == a.IsUniform());
            // Don't require equality on collections (follows .NET 'standards')
            AssertEqual(a, b);
        }

        private static void SettableToWeightedSumTest<T>(T a, T b, bool doSumWithNegativeWeightsTests = true)
            where T : SettableToWeightedSum<T>, ICloneable, Diffable, SettableToUniform
        {
            T c = (T)a.Clone();
            c.SetToSum(0.5, a, 0.5, b);
            if (!(c is Discrete && ((Discrete)(object)c).Dimension <= 1))
            {
                Assert.False(c.Equals(a));
                Assert.False(c.Equals(b));
            }

            if (doSumWithNegativeWeightsTests)
            {
                c.SetToSum(2.0, c, -1.0, b);
                Assert.True(c.MaxDiff(a) < 1e-10);
            }

            c.SetToUniform();
            c.SetToSum(2.0, a, 0.0, c);
            Assert.True(c.Equals(a));
            c.SetToSum(0.0, c, 2.0, a);
            Assert.True(c.Equals(a));
            c.SetToSum(1.0, c, Double.PositiveInfinity, b);
            Assert.True(c.Equals(b));
            c.SetToSum(Double.PositiveInfinity, a, 1.0, c);
            Assert.True(c.Equals(a));
            c.SetToSum(0.0, a, 0.0, b);
            Assert.True(c.IsUniform());
            try
            {
                c.SetToSum(0.0, a, -1.0, c);
                Assert.True(false, "Did not throw exception");
            }
            catch (ArgumentException)
            {
            }
        }

        private static void GetMomentTest<T, MeanType, VarianceType>(T a, MeanType mean, VarianceType variance)
            where T : CanGetMean<MeanType>, CanGetVariance<VarianceType>
        {
            MeanType actualMean = a.GetMean();
            VarianceType actualVariance = a.GetVariance();
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
            if (a is CanGetMeanAndVarianceOut<MeanType, VarianceType> MeanTypes)
            {
                MeanTypes.GetMeanAndVariance(out actualMean, out actualVariance);
            }
            else if (a is CanGetMeanAndVariance<MeanType, VarianceType> MeanTypes)
            {
                MeanTypes.GetMeanAndVariance(actualMean, actualVariance);
            }
            else
                return;
            Assert.True(AbsDiff(mean, actualMean) < 1e-10);
            Assert.True(AbsDiff(variance, actualVariance) < 1e-10);
        }

        public static double AbsDiff(object a, object b)
        {
            if (a is double d)
                return MMath.AbsDiff(d, (double)b, 1e-10);
            else if (a is Vector vector)
                return vector.MaxDiff((Vector)b);
            else if (a is PositiveDefiniteMatrix positiveDefiniteMatrix)
                return positiveDefiniteMatrix.MaxDiff((PositiveDefiniteMatrix)b);
            else
                throw new NotImplementedException();
        }

        public static object GetZero(object o)
        {
            if (o is bool)
                return false;
            else if (o is double)
                return 0.0;
            else if (o is Vector vector)
                return Vector.Zero(vector.Count);
            else if (o is PositiveDefiniteMatrix positiveDefiniteMatrix)
                return new PositiveDefiniteMatrix(positiveDefiniteMatrix.Rows, ((PositiveDefiniteMatrix)o).Cols);
            else
                throw new NotImplementedException();
        }
    }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(9,7): error CS0246: The type or namespace name 'Xunit' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(30,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(30,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(59,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(59,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(85,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(85,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(117,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(117,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(158,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(158,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(197,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(197,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(251,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(251,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(264,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(264,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(287,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(287,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(329,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(329,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(375,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(375,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(414,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(414,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(429,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(429,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(449,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(449,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(450,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(450,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(497,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(497,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(598,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(598,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(616,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(616,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(631,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(631,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(711,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(711,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(725,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(725,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(765,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(765,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(835,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(835,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(905,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(905,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1004,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1004,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1045,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1045,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1178,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1178,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1213,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1213,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1316,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1316,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1317,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1317,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1449,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1449,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1468,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1468,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1517,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1517,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1518,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1518,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1561,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1561,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1591,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1591,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1642,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1642,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1658,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1658,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1668,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1668,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1685,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1685,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1708,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1708,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1720,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1720,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1741,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1741,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1789,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1789,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1798,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1798,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1826,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1826,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1845,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1845,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1864,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1864,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1885,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1885,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1886,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1886,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(94,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(101,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(103,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(105,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(107,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(110,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(130,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(138,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(140,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(142,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(144,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(147,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(169,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(177,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(179,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(181,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(183,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(186,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(206,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(207,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(208,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(209,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(210,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(213,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(214,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(215,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(225,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(226,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(227,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(230,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(231,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(257,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(258,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(259,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(260,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(270,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(271,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(272,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(273,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(307,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(312,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(344,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(345,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(365,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(366,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(369,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(385,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(386,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(388,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(392,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(400,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(401,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(403,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(407,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(423,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(424,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(438,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(439,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(440,28): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(441,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(454,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(459,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(461,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(462,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(463,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(464,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(477,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(478,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(482,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(483,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(487,32): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(504,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(505,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(534,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(535,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(538,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(539,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(542,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(545,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(548,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(551,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(552,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(554,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(556,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(558,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(560,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(567,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(568,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(570,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(573,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(575,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(576,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(587,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(588,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(592,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(609,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(610,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(627,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(628,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(647,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(648,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(665,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(670,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(674,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(690,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(694,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(702,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(703,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(707,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(708,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(716,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(719,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(722,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(748,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(750,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(760,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(762,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(770,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(771,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(797,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(798,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(799,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(800,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(801,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(802,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(803,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(804,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(809,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(811,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(812,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(813,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(816,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(818,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(819,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(827,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(829,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(831,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(867,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(891,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(893,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(898,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(899,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(902,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(912,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(921,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(922,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(942,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(946,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(947,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(949,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(950,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(953,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(968,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(972,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(979,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(980,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(987,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(988,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(996,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(997,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1011,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1017,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1023,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1029,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1035,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1041,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1050,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1052,22): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1063,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1064,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1066,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1067,20): error CS0117: 'AssertHelper' does not contain a definition for 'Contains',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1068,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1071,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1073,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1075,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1076,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1082,22): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1086,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1181,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1182,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1183,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1184,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1185,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1192,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1194,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1196,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1197,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1198,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1210,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1216,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1229,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1233,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1241,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1249,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1256,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1257,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1261,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1293,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1295,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1299,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1301,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1303,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1305,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1307,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1309,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1312,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1313,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1328,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1329,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1397,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1400,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1403,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1408,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1436,32): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1442,36): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1465,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1513,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1544,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1558,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1568,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1569,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1571,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1622,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1623,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1624,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1625,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1626,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1632,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1654,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1655,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1681,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1682,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1704,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1705,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1717,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1738,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1785,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1795,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1817,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1818,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1819,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1840,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1841,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1851,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1861,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1882,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1934,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1996,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1997,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2018,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2019,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2025,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2026,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2041,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2042,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2076,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2077,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2088,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2089,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2090,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2091,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2092,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2100,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2101,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2109,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2110,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2112,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2113,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2116,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2118,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2120,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2130,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2132,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2140,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2141,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2142,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2143,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2169,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2177,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2178,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2179,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2192,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2202,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2206,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2208,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2210,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2217,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2223,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2242,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2247,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2251,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2261,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2272,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2283,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2304,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2306,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2307,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2308,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2310,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2313,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2315,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2316,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2317,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2319,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2333,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2336,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2342,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2349,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2351,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2359,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2361,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2364,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2369,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2382,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2394,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2395,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2401,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2406,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2408,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2410,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2412,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2414,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2418,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2430,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2431,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2442,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2443,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(9,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(9,7): error CS0246: The type or namespace name 'Xunit' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(30,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(30,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(59,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(59,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(85,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(85,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(117,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(117,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(158,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(158,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(197,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(197,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(251,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(251,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(264,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(264,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(287,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(287,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(329,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(329,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(375,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(375,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(414,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(414,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(429,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(429,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(449,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(449,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(450,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(450,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(497,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(497,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(598,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(598,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(616,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(616,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(631,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(631,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(711,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(711,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(725,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(725,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(765,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(765,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(835,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(835,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(905,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(905,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1004,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1004,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1045,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1045,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1178,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1178,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1213,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1213,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1316,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1316,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1317,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1317,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1449,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1449,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1468,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1468,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1517,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1517,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1518,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1518,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1561,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1561,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1591,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1591,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1642,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1642,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1658,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1658,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1668,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1668,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1685,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1685,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1708,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1708,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1720,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1720,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1741,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1741,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1789,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1789,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1798,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1798,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1826,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1826,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1845,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1845,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1864,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1864,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1885,10): error CS0246: The type or namespace name 'FactAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1885,10): error CS0246: The type or namespace name 'Fact' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1886,10): error CS0246: The type or namespace name 'TraitAttribute' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1886,10): error CS0246: The type or namespace name 'Trait' could not be found (are you missing a using directive or an assembly reference?),D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(94,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(101,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(103,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(105,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(107,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(110,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(130,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(138,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(140,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(142,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(144,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(147,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(169,28): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(177,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(179,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(181,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(183,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(186,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(206,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(207,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(208,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(209,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(210,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(213,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(214,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(215,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(225,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(226,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(227,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(230,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(231,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(257,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(258,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(259,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(260,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(270,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(271,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(272,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(273,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(307,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(312,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(344,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(345,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(365,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(366,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(369,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(385,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(386,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(388,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(392,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(400,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(401,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(403,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(407,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(423,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(424,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(438,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(439,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(440,28): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(441,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(454,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(459,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(461,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(462,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(463,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(464,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(477,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(478,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(482,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(483,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(487,32): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(504,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(505,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(534,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(535,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(538,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(539,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(542,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(545,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(548,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(551,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(552,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(554,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(556,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(558,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(560,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(567,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(568,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(570,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(573,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(575,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(576,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(587,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(588,20): error CS0117: 'AssertHelper' does not contain a definition for 'Throws',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(592,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(609,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(610,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(627,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(628,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(647,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(648,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(665,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(670,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(674,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(690,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(694,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(702,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(703,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(707,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(708,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(716,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(719,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(722,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(748,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(750,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(760,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(762,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(770,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(771,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(797,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(798,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(799,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(800,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(801,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(802,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(803,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(804,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(809,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(811,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(812,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(813,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(816,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(818,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(819,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(827,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(829,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(831,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(867,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(891,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(893,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(898,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(899,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(902,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(912,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(921,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(922,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(942,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(946,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(947,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(949,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(950,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(953,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(968,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(972,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(979,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(980,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(987,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(988,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(996,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(997,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1011,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1017,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1023,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1029,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1035,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1041,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1050,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1052,22): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1063,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1064,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1066,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1067,20): error CS0117: 'AssertHelper' does not contain a definition for 'Contains',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1068,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1071,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1073,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1075,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1076,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1082,22): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1086,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1181,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1182,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1183,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1184,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1185,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1192,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1194,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1196,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1197,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1198,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1210,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1216,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1229,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1233,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1241,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1249,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1256,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1257,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1261,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1293,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1295,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1299,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1301,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1303,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1305,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1307,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1309,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1312,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1313,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1328,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1329,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1397,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1400,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1403,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1408,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1436,32): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1442,36): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1465,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1513,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1544,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1558,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1568,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1569,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1571,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1622,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1623,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1624,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1625,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1626,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1632,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1654,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1655,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1681,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1682,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1704,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1705,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1717,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1738,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1785,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1795,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1817,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1818,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1819,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1840,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1841,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1851,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1861,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1882,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1934,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1996,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(1997,24): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2018,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2019,20): error CS1501: No overload for method 'Equal' takes 2 arguments,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2025,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2026,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2041,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2042,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2076,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2077,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2088,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2089,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2090,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2091,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2092,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2100,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2101,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2109,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2110,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2112,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2113,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2116,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2118,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2120,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2130,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2132,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2140,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2141,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2142,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2143,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2169,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2177,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2178,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2179,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2192,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2202,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2206,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2208,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2210,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2217,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2223,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2242,20): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2247,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2251,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2261,28): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2272,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2283,32): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2304,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2306,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2307,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2308,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2310,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2313,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2315,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2316,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2317,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2319,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2333,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2336,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2342,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2349,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2351,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2359,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2361,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2364,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2369,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2382,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2394,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2395,24): error CS0117: 'AssertHelper' does not contain a definition for 'False',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2401,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2406,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2408,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2410,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2412,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2414,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2418,24): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2430,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2431,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2436,73): error CS0136: A local or parameter named 'MeanTypes' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2442,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(2443,20): error CS0117: 'AssertHelper' does not contain a definition for 'True',D:\a\1\s\test\Tests\Distributions\DistributionTests.cs(9,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Runtime\Core\Collections\SparseList.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.ML.Probabilistic.Utilities;
using System.Collections;
using Microsoft.ML.Probabilistic.Math;
using System.Linq;

namespace Microsoft.ML.Probabilistic.Collections
{
    using Microsoft.ML.Probabilistic.Serialization;
    using System.Runtime.Serialization;

    /// <summary>
    /// A list which is optimised for the case where most of its elements share a common value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    [Serializable]
    [DataContract]
    public class SparseList<T> : ISparseList<T>, IList, ICloneable
    {
        #region Properties

        // Sparsity
        [DataMember]
        private Sparsity sparsity = Sparsity.Sparse;

        /// <summary>
        /// The <see cref="Sparsity"/> specification of this list.
        /// </summary>
        public Sparsity Sparsity
        {
            get { return sparsity; }
            protected set { sparsity = value; }
        }

        /// <summary>
        /// A list of the value and indices of elements which may not have the common value 
        /// (although they are not precluded from doing so).
        /// This list is kept sorted by index to allow efficient operations on the sparse list.
        /// </summary>
        [DataMember]
        public List<ValueAtIndex<T>> SparseValues { get; protected set; }

        /// <summary>
        /// The value of all elements not mentioned explicitly as sparse values.
        /// </summary>
        [DataMember]
        public T CommonValue { get; protected set; }

        [DataMember]
        private int count;

        /// <summary>
        /// Get or set the number of elements in this list.  Set the number of elements
        /// will grow or shrink the list accordingly.
        /// </summary>
        public int Count
        {
            get { return count; }
            set
            {
                if (value < count)
                {
                    throw new NotImplementedException("Shrinking sparse lists is not yet implemented.");
                }
                count = value;
            }
        }

        /// <summary>
        /// The number of elements not equal to the common value
        /// </summary>
        public int SparseCount
        {
            get { return SparseValues == null ? 0 : SparseValues.Count; }
        }

        #endregion

        #region Factory methods and constructors

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to the default value for the element type
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <returns></returns>
        public static SparseList<T> FromSize(int count)
        {
            var v = new SparseList<T>(count, default(T));
            return v;
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to a specified value
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="value">Value for each element</param>
        /// <returns></returns>
        public static SparseList<T> Constant(int count, T value)
        {
            var v = new SparseList<T>(count, value);
            return v;
        }

        /// <summary>
        /// Creator a sparse list as a copy of another list (which may not be sparse)
        /// </summary>
        /// <param name="that">The source list - can be dense or sparse</param>
        public static SparseList<T> Copy(IList<T> that)
        {
            var v = new SparseList<T>(that.Count);
            v.SetTo(that);
            return v;
        }

        /// <summary>
        /// Constructs a sparse list from a sorted list of sparse elements.
        /// </summary>
        /// <param name="count">Count for result</param>
        /// <param name="commonValue">Common value</param>
        /// <param name="sortedSparseValues">Sorted list of sparse elements</param>
        [Construction("Count", "CommonValue", "SparseValues")]
        public static SparseList<T> FromSparseValues(int count, T commonValue,
                                                     List<ValueAtIndex<T>> sortedSparseValues)
        {
            var result = new SparseList<T>
                {
                    CommonValue = commonValue,
                    Count = count,
                    SparseValues = sortedSparseValues,
                };
            return result;
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Null constructor.
        /// </summary>
        protected SparseList()
        {
        }

        /// <summary>
        /// Constructs a sparse list with the given number of elements.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        protected SparseList(int count)
        {
            SparseValues = new List<ValueAtIndex<T>>();
            Count = count;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        protected SparseList(int count, T commonValue)
            : this(count)
        {
            CommonValue = commonValue;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        protected SparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues)
            : this(count, commonValue)
        {
            SparseValues = sortedSparseValues;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        protected SparseList(ISparseList<T> that)
        {
            SparseValues = new List<ValueAtIndex<T>>();
            Count = that.Count;
            SetTo(that);
        }

        #endregion

        #region Element-wise access

        /// <summary>Gets or sets an element.</summary>
        public virtual T this[int index]
        {
            get
            {
                var k = GetSparseIndex(index);
                if (k < 0) return CommonValue;
                return SparseValues[k].Value;
            }
            set
            {
                var k = GetSparseIndex(index);
                if (Equals(CommonValue, value))
                {
                    if (k >= 0) SparseValues.RemoveAt(k);
                    return;
                }
                if (k < 0)
                {
                    SparseValues.Insert(~k, new ValueAtIndex<T> {Index = index, Value = value});
                }
                else
                {
                    var sel = SparseValues[k];
                    sel.Value = value;
                    SparseValues[k] = sel;
                }
            }
        }

        #endregion

        #region Sparsity-related operations

        /// <summary>
        /// Gets the index into the sparse values array corresponding to an element index.
        /// If there is no sparse value at that index, returns the binary complement of the 
        /// index in the sparse array where such an element should be inserted to retain the
        /// sort order of the sparse array.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        protected int GetSparseIndex(int index)
        {
            return SparseValues.BinarySearch(new ValueAtIndex<T> {Index = index}, new ByIndexComparer<T>());
        }

        /// <summary>
        /// Returns true if there is at least one element which has the common value.
        /// </summary>
        public bool HasCommonElements
        {
            get { return Count > SparseValues.Count; }
        }


        /// <summary>
        /// Gets the dense index of the first common element.
        /// </summary>
        /// <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        public int GetFirstCommonIndex()
        {
            if (HasCommonElements)
            {
                int index = 0;
                foreach (var sel in SparseValues)
                {
                    if (index != sel.Index)
                        return index;
                    index++;
                }
            }
            return -1;
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Gets a typed enumerator which yields the list elements
        /// </summary>
        /// <returns></returns>
        public IEnumerator<T> GetEnumerator()
        {
            int index = 0;
            foreach (var sel in SparseValues)
            {
                while (index < sel.Index)
                {
                    index++;
                    yield return CommonValue;
                }
                index++;
                yield return sel.Value;
            }
            while (index < Count)
            {
                index++;
                yield return CommonValue;
            }
        }

        /// <summary>
        /// Gets an enumerator which yields the list elements
        /// </summary>
        /// <returns></returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region Cloning, SetTo operations

        /// <summary>
        /// Sets all elements to a given value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetAllElementsTo(T value)
        {
            SparseValues.Clear();
            CommonValue = value;
        }


        /// <summary>
        /// Copies values from another list.
        /// </summary>
        /// <param name="that"></param>
        /// <remarks> The source list can be dense, in which case 
        /// default(T) is used as the common value.</remarks>
        public void SetTo(IList<T> that)
        {
            if (that is SparseList<T>)
            {
                SetTo((SparseList<T>) that);
            }
            else if (Count == that.Count)
            {
                SetTo(that, default(T));
            }
            else
            {
                CommonValue = default(T);
                count = that.Count;
                SparseValues = that.Select((x, i) => new ValueAtIndex<T>(i, x)).ToList();
            }
        }

        /// <summary>
        /// Checks that a given list is the same size as this list.
        /// Throws an exception if not with the given string
        /// </summary>
        /// <param name="that">The list to check</param>
        /// <param name="paramName"></param>
        /// <exclude/>
        protected void CheckCompatible<T2>(IList<T2> that, string paramName)
        {
            Argument.CheckIfValid(that.Count == this.Count, string.Format("Size of {0} does not match size of this list. Expected {1}, got {2}.", paramName, this.Count, that.Count));
        }

        /// <summary>
        /// Copies values from a sparse list to this sparse list.
        /// </summary>
        /// <param name="that"></param>
        public void SetTo(SparseList<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            CheckCompatible(that, nameof(that));
            CommonValue = that.CommonValue;
            SparseValues = new List<ValueAtIndex<T>>(that.SparseValues);
        }

        public void SetTo(IEnumerable<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            if (that is ISparseEnumerable<T>)
            {
                var ise = (that as ISparseEnumerable<T>).GetSparseEnumerator();
                var sel = new List<ValueAtIndex<T>>();
                while (ise.MoveNext())
                    sel.Add(new ValueAtIndex<T>(ise.CurrentIndex, ise.Current));

                CommonValue = ise.CommonValue;
                SparseValues = sel;
                count = ise.CommonValueCount + SparseValues.Count;
            }
            else
            {
                SetTo(that.ToList());
            }
        }


        /// <summary>
        /// Copies values from a list which must have the same size as this list,
        /// using the specified common value.
        /// </summary>
        /// <param name="dlist">The list to copy from</param>
        /// <param name="commonValue">Common value</param>
        public virtual void SetTo(IList<T> dlist, T commonValue)
        {
            SetAllElementsTo(commonValue);
            for (int i = 0; i < dlist.Count; i++)
            {
                T val = dlist[i];
                if (!Equals(val, commonValue)) SparseValues.Add(new ValueAtIndex<T> {Index = i, Value = val});
            }
        }

        /// <summary>
        /// Clones this list - return as a sparse list.
        /// </summary>
        /// <returns></returns>
        public SparseList<T> Clone()
        {
            return new SparseList<T>(this);
        }

        /// <summary>
        /// Clones this list - return as an object
        /// </summary>
        /// <returns></returns>
        object ICloneable.Clone()
        {
            return Clone();
        }

        #endregion

        #region Equality

        /// <summary>
        /// Determines object equality.
        /// </summary>
        /// <param name="obj">Another (list) object.</param>
        /// <returns>True if equal.</returns>
        /// <exclude/>
        public override bool Equals(object obj)
        {
            var that = obj as IList<T>;
            if (ReferenceEquals(this, that)) return true;
            if (ReferenceEquals(that, null))
                return false;
            if (this.Count != that.Count) return false;
            var isEqual = SparseList<bool>.Constant(Count, false);
            return Reduce(true, that, (res, o1, o2) => res && Equals(o1, o2));
        }

        /// <summary>
        /// Gets a hash code for the instance.
        /// </summary>
        /// <returns>The code.</returns>
        /// <exclude/>
        public override int GetHashCode()
        {
            int hash = Hash.Start;
            hash = Hash.Combine(hash, CommonValue.GetHashCode());
            if (SparseValues != null)
                foreach (var sel in SparseValues) hash = Hash.Combine(hash, sel.GetHashCode());
            return hash;
        }

        /// <summary>
        /// Tests if all elements are equal to the given value.
        /// </summary>
        /// <param name="value">The value to test against.</param>
        /// <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        public bool EqualsAll(T value)
        {
            return All(x => Equals(x, value));
        }

        #endregion

        #region LINQ-like operators (All, Any, IndexOfAll etc.)

        /// <summary>
        /// Tests if all elements in the list satisfy the specified condition.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public bool All(Converter<T, bool> fun)
        {
            if (HasCommonElements)
            {
                // At least one element has the common value
                if (!fun(CommonValue)) return false;
            }
            foreach (var sel in SparseValues)
            {
                if (!fun(sel.Value)) return false;
            }
            return true;
        }

        /// <summary>
        /// Tests if any elements in the list satisfy the specified condition.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public bool Any(Converter<T, bool> fun)
        {
            if (HasCommonElements)
            {
                if (fun(CommonValue)) return true;
            }
            foreach (var sel in SparseValues)
            {
                if (fun(sel.Value)) return true;
            }
            return false;
        }

        /// <summary>
        /// Returns an enumeration of the indices of all elements which satisfy the specified condition.
        /// Indices are returned in sorted order.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public IEnumerable<int> IndexOfAll(Converter<T, bool> fun)
        {
            if (fun(CommonValue))
            {
                for (int i = 0; i < Count; i++)
                {
                    if (fun(this[i])) yield return i;
                }
            }
            else
            {
                foreach (var sel in SparseValues)
                {
                    if (fun(sel.Value)) yield return sel.Index;
                }
            }
        }

        #endregion

        #region Reduce operation

        /// <summary>
        /// Reduce method. Operates on this list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes>(TRes initial, Func<TRes, T, TRes> fun)
        {
            TRes result = initial;
            for (int i = 0; i < Count - SparseValues.Count; i++)
                result = fun(result, CommonValue);
            foreach (var sel in SparseValues)
                result = fun(result, sel.Value);
            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes>(TRes initial, Func<TRes, T, TRes> fun, Func<TRes, T, int, TRes> repeatedFun)
        {
            TRes result = initial;
            result = repeatedFun(result, CommonValue, Count - SparseValues.Count);
            foreach (var sel in SparseValues)
                result = fun(result, sel.Value);
            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// and another sparse list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="that">The other sparse list</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        public TRes Reduce<TRes, T1>(TRes initial, ISparseEnumerable<T1> that, Func<TRes, T, T1, TRes> fun, Func<TRes, T, T1, int, TRes> repeatedFun)
        {
            TRes result = initial;
            int sparseValueCount = 0;
            var ae = this.GetSparseEnumerator();
            var be = that.GetSparseEnumerator();
            bool aActive = ae.MoveNext();
            bool bActive = be.MoveNext();
            var aCommon = ae.CommonValue;
            var bCommon = be.CommonValue;
            while (aActive || bActive)
            {
                if (aActive)
                {
                    // a is the earlier index
                    if ((!bActive) || ae.CurrentIndex < be.CurrentIndex)
                    {
                        result = fun(result, ae.Current, bCommon);
                        aActive = ae.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                    // a and b equal indices
                    if (bActive && ae.CurrentIndex == be.CurrentIndex)
                    {
                        result = fun(result, ae.Current, be.Current);
                        aActive = ae.MoveNext();
                        bActive = be.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                }
                if (bActive)
                {
                    // b is the earlier index
                    if ((!aActive) || be.CurrentIndex < ae.CurrentIndex)
                    {
                        result = fun(result, aCommon, be.Current);
                        bActive = be.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                }
            }
            int repeatCount = Count - sparseValueCount;
            if (repeatCount > 0)
                result = repeatedFun(result, aCommon, bCommon, repeatCount);

            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// and two other sparse lists
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="b">A second sparse list</param>
        /// <param name="c">A third sparse list</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        public TRes Reduce<TRes, T1, T2>(TRes initial, ISparseEnumerable<T1> b, ISparseEnumerable<T2> c, Func<TRes, T, T1, T2, TRes> fun,
                                         Func<TRes, T, T1, T2, int, TRes> repeatedFun)
        {
            TRes result = initial;
            int sparseValueCount = 0;
            var ae = this.GetSparseEnumerator();
            var be = b.GetSparseEnumerator();
            var ce = c.GetSparseEnumerator();
            bool aActive = ae.MoveNext();
            bool bActive = be.MoveNext();
            bool cActive = ce.MoveNext();
            var aCommon = ae.CommonValue;
            var bCommon = be.CommonValue;
            var cCommon = ce.CommonValue;
            while (aActive || bActive || cActive)
            {
                if (aActive)
                {
                    if ((!bActive) || ae.CurrentIndex < be.CurrentIndex)
                    {
                        // a is the earliest index
                        if ((!cActive) || ae.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, bCommon, cCommon);
                            aActive = ae.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // a and c are the earliest index
                        if (cActive && ae.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, bCommon, ce.Current);
                            aActive = ae.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                    if (bActive && ae.CurrentIndex == be.CurrentIndex)
                    {
                        // a and b are the earliest index
                        if ((!cActive) || ae.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, be.Current, cCommon);
                            aActive = ae.MoveNext();
                            bActive = be.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // a, b, and c are the earliest index
                        if (cActive && ae.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, be.Current, ce.Current);
                            aActive = ae.MoveNext();
                            bActive = be.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
                if (bActive)
                {
                    if ((!aActive) || be.CurrentIndex < ae.CurrentIndex)
                    {
                        // b is the earliest index
                        if ((!cActive) || be.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, aCommon, be.Current, cCommon);
                            bActive = be.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // b and c are the earliest index
                        if (cActive && be.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, aCommon, be.Current, ce.Current);
                            bActive = be.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
                if (cActive)
                {
                    if ((!aActive) || ce.CurrentIndex < ae.CurrentIndex)
                    {
                        // c is the earliest index
                        if ((!bActive) || ce.CurrentIndex < be.CurrentIndex)
                        {
                            result = fun(result, aCommon, bCommon, ce.Current);
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
            }

            int repeatCount = Count - sparseValueCount;
            if (repeatCount > 0)
                result = repeatedFun(result, aCommon, bCommon, cCommon, repeatCount);

            return result;
        }

        /// <summary>
        /// Reduce method. Operates on this list and another list.
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="that">A second list</param>
        /// <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes, T2>(TRes initial, IEnumerable<T2> that, Func<TRes, T, T2, TRes> fun)
        {
            TRes result = initial;
            IEnumerator<T> thisEnum = GetEnumerator();
            IEnumerator<T2> thatEnum = that.GetEnumerator();

            while (thisEnum.MoveNext() && thatEnum.MoveNext())
                result = fun(result, thisEnum.Current, thatEnum.Current);
            return result;
        }

        /// <summary>
        /// Reduce method. Operates on this list and two other lists.
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="a">A second list</param>
        /// <param name="b">A third list</param>
        /// <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="a"/> and <paramref name="b"/></param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes, T1, T2>(TRes initial, IList<T1> a, IList<T2> b, Func<TRes, T, T1, T2, TRes> fun)
        {
            TRes result = initial;
            IEnumerator<T> thisEnum = GetEnumerator();
            IEnumerator<T1> aEnum = a.GetEnumerator();
            IEnumerator<T2> bEnum = b.GetEnumerator();

            while (thisEnum.MoveNext() && aEnum.MoveNext() && bEnum.MoveNext())
                result = fun(result, thisEnum.Current, aEnum.Current, bEnum.Current);
            return result;
        }

        #endregion

        #region IList support (interface implemented mainly for convenience, most operations are not supported)

        /// <summary>
        /// Returns true if this list contains the specified value
        /// </summary>
        /// <param name="value">The value to test for</param>
        /// <returns></returns>
        public bool Contains(T value)
        {
            if (HasCommonElements)
            {
                // At least one element has the common value
                if (Equals(CommonValue, value)) return true;
            }
            foreach (var sel in SparseValues)
            {
                if (Equals(sel.Value, value)) return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the index of the first occurence of the given value in the list.
        /// Returns -1 if the value is not in the list
        /// </summary>
        /// <param name="item">The item to check for</param>
        /// <returns>Its index in the list</returns>
        public int IndexOf(T item)
        {
            if (HasCommonElements)
            {
                if (Equals(item, CommonValue))
                {
                    int idx = 0;
                    foreach (var sel in SparseValues)
                    {
                        if (sel.Index != idx) return idx;
                        idx++;
                    }
                }
            }
            foreach (var sel in SparseValues)
            {
                if (Equals(sel.Value, item)) return sel.Index;
            }
            return -1;
        }

        /// <summary>
        /// Sparse lists are not read only.
        /// </summary>
        public bool IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Copies this sparse list to the given array starting at the specified index
        /// in the target array
        /// </summary>
        /// <param name="array">The target array</param>
        /// <param name="index">The start index in the target array</param>
        public void CopyTo(T[] array, int index)
        {
            int j = index;
            for (int i = 0; i < Count; i++, j++)
                array[j] = CommonValue;
            foreach (var sel in SparseValues)
                array[index + sel.Index] = sel.Value;
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        public void Insert(int index, T item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        public void RemoveAt(int index)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Clears this list, setting it to zero length.
        /// </summary>
        public void Clear()
        {
            Count = 0;
            SparseValues.Clear();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            throw new NotImplementedException();
        }


        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        int IList.Add(object value)
        {
            throw new NotImplementedException();
        }


        bool IList.Contains(object value)
        {
            if (!(value is T)) return false;
            return Contains((T) value);
        }

        int IList.IndexOf(object value)
        {
            if (!(value is T)) return -1;
            return IndexOf((T) value);
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        void IList.Insert(int index, object value)
        {
            throw new NotImplementedException();
        }

        bool IList.IsFixedSize
        {
            get { return false; }
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="value"></param>
        void IList.Remove(object value)
        {
            throw new NotImplementedException();
        }

        object IList.this[int index]
        {
            get { return this[index]; }
            set { this[index] = (T) value; }
        }


        void ICollection.CopyTo(Array array, int index)
        {
            CopyTo((T[]) array, index);
        }

        bool ICollection.IsSynchronized
        {
            get { return false; }
        }

        object ICollection.SyncRoot
        {
            get { return null; }
        }

        #endregion

        #region General purpose function operators

        /// <summary>
        /// Creates an array from the list
        /// </summary>
        /// <typeparam name="T2"></typeparam>
        /// <param name="that"></param>
        /// <returns></returns>
        protected T2[] ToArray<T2>(IList<T2> that)
        {
            var thatArray = new T2[that.Count];
            that.CopyTo(thatArray, 0);
            return thatArray;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of another sparse list
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(SparseList<T2> that, Func<T2, T> fun)
        {
            CheckCompatible(that, nameof(that));
            CommonValue = fun(that.CommonValue);
            SparseValues = that.SparseValues.ConvertAll(x => new ValueAtIndex<T> {Index = x.Index, Value = fun(x.Value)});
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a sparse collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(ISparseEnumerable<T2> that, Func<T2, T> fun)
        {
            if (that is IList<T2>)
                CheckCompatible((IList<T2>) that, nameof(that));

            ISparseEnumerable<T> res = fun.Map(that) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            SparseValues.Clear();
            while (rese.MoveNext())
                SparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(IEnumerable<T2> that, Func<T2, T> fun)
        {
            if (that is SparseList<T2>)
                return SetToFunction((SparseList<T2>) that, fun);

            if (that is ISparseEnumerable<T2>)
                return SetToFunction((ISparseEnumerable<T2>) that, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(that);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are all the same length</remarks>
        public SparseList<T> SetToFunction<T1, T2>(SparseList<T1> a, SparseList<T2> b, Func<T1, T2, T> fun)
        {
            CheckCompatible(a, nameof(a));
            CheckCompatible(b, nameof(b));
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) && !ReferenceEquals(b, this)) return SetToFunctionInPlace<T2>(b, (x, y) => fun((T1) (object) x, y));
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this))
            {
                // This vector is one of the arguments, do not modify in place. Instead create
                // a new list to hold the sparse values of the results.

                // Set the new capacity conservatively, assuming the sparse values do not overlap
                newSparseValues = new List<ValueAtIndex<T>>(a.SparseValues.Count + b.SparseValues.Count);
            }
            else
            {
                // We can safely modify the sparse values list in place
                SparseValues.Clear();
                int targetCapacity = a.SparseValues.Count + b.SparseValues.Count;
                int currentCapacity = SparseValues.Capacity;
                if ((currentCapacity < targetCapacity/2) || (currentCapacity > targetCapacity*2))
                {
                    SparseValues.Capacity = targetCapacity;
                }
                newSparseValues = SparseValues;
            }
            // TODO: consider changing to use enumerators
            int aIndex = 0;
            int bIndex = 0;
            var aSel = a.GetSparseValue(aIndex);
            var bSel = b.GetSparseValue(bIndex);
            T newCommonValue = fun(a.CommonValue, b.CommonValue);
            while ((aSel.Index != -1) || (bSel.Index != -1))
            {
                if (((aSel.Index < bSel.Index) && (aSel.Index != -1)) || (bSel.Index == -1))
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = aSel.Index, Value = fun(aSel.Value, b.CommonValue)});
                    aIndex++;
                    aSel = a.GetSparseValue(aIndex);
                    continue;
                }
                if ((bSel.Index < aSel.Index) || (aSel.Index == -1))
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = bSel.Index, Value = fun(a.CommonValue, bSel.Value)});
                    bIndex++;
                    bSel = b.GetSparseValue(bIndex);
                    continue;
                }
                // If two indices are the same, apply operator to both
                if (aSel.Index == bSel.Index)
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = aSel.Index, Value = fun(aSel.Value, bSel.Value)});
                    aIndex++;
                    bIndex++;
                    aSel = a.GetSparseValue(aIndex);
                    bSel = b.GetSparseValue(bIndex);
                }
            }
            CommonValue = newCommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            if (a is IList<T1>)
                CheckCompatible((IList<T1>) a, nameof(a));
            if (b is IList<T2>)
                CheckCompatible((IList<T2>) b, nameof(b));

            ISparseEnumerable<T> res = fun.Map(a, b) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this list to a function of the elements of two collections
        /// </summary>
        /// <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T1, T2>(IEnumerable<T1> a, IEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            if ((a is SparseList<T1>) && (b is SparseList<T2>))
                return SetToFunction((SparseList<T1>) a, (SparseList<T2>) b, fun);

            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }


        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, ISparseEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            if (a is IList<T1>)
                CheckCompatible((IList<T1>) a, nameof(a));
            if (b is IList<T2>)
                CheckCompatible((IList<T2>) b, nameof(b));
            if (c is IList<T3>)
                CheckCompatible((IList<T3>) c, nameof(c));
            ISparseEnumerable<T> res = fun.Map(a, b, c) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this) || ReferenceEquals(c, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, (ISparseEnumerable<T3>) c, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b, c);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three other collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3, T4>(
            ISparseList<T1> a, ISparseList<T2> b, ISparseList<T3> c, ISparseList<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            if (a is IList<T1>)
                CheckCompatible((IList<T1>) a, nameof(a));
            if (b is IList<T2>)
                CheckCompatible((IList<T2>) b, nameof(b));
            if (c is IList<T3>)
                CheckCompatible((IList<T3>) c, nameof(c));
            if (d is IList<T4>)
                CheckCompatible((IList<T4>) d, nameof(d));

            ISparseEnumerable<T> res = fun.Map(a, b, c, d) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this) || ReferenceEquals(c, this) || ReferenceEquals(d, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of four sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3, T4>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, IEnumerable<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, (ISparseEnumerable<T3>) c, (ISparseEnumerable<T4>) d, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b, c, d);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of this sparse list and another sparse list
        /// x = fun(x,b)
        /// </summary>
        /// <param name="fun">The function which maps (T,T1) to T</param>
        /// <param name="b">The other sparse list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public virtual SparseList<T> SetToFunctionInPlace<T1>(SparseList<T1> b, Func<T, T1, T> fun)
        {
            CheckCompatible(b, nameof(b));
            if (ReferenceEquals(b, this))
            {
                throw new NotSupportedException($"{nameof(b)} must not be equal to this");
            }
            // TODO: consider changing to use enumerators
            int aIndex = 0;
            int bIndex = 0;
            var aSel = GetSparseValue(aIndex);
            var bSel = b.GetSparseValue(bIndex);
            T newCommonValue = fun(CommonValue, b.CommonValue);
            while ((aSel.Index != -1) || (bSel.Index != -1))
            {
                if (((aSel.Index < bSel.Index) && (aSel.Index != -1)) || (bSel.Index == -1))
                {
                    aSel.Value = fun(aSel.Value, b.CommonValue);
                    SparseValues[aIndex] = aSel;
                    aIndex++;
                    aSel = GetSparseValue(aIndex);
                    continue;
                }
                if ((bSel.Index < aSel.Index) || (aSel.Index == -1))
                {
                    SparseValues.Insert(aIndex, new ValueAtIndex<T> {Index = bSel.Index, Value = fun(CommonValue, bSel.Value)});
                    aIndex++;
                    bIndex++;
                    bSel = b.GetSparseValue(bIndex);
                    continue;
                }
                // If two indices are the same, apply operator to both
                if (aSel.Index == bSel.Index)
                {
                    aSel.Value = fun(aSel.Value, bSel.Value);
                    SparseValues[aIndex] = aSel;
                    aIndex++;
                    bIndex++;
                    aSel = GetSparseValue(aIndex);
                    bSel = b.GetSparseValue(bIndex);
                }
            }
            CommonValue = newCommonValue;
            return this;
        }

        internal ValueAtIndex<T> GetSparseValue(int index)
        {
            return index < SparseValues.Count ? SparseValues[index] : ValueAtIndex<T>.NoElement;
        }

        #endregion

        #region Conversions (ToString, ToArray etc.)

        /// <summary>
        /// Converts this sparse list into a human readable string
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(",");
        }

        /// <summary>
        /// String representation of this list with a specified delimiter
        /// </summary>
        /// <param name="delimiter"></param>
        /// <returns></returns>
        public string ToString(string delimiter)
        {
            StringBuilder sb = new StringBuilder();
            if (HasCommonElements)
            {
                sb.Append("[0.." + (Count - 1) + "]=" + CommonValue);
                if (SparseValues.Count > 0) sb.Append(" except " + SparseValues.Count + " values ");
            }
            else
            {
                sb.Append("[Warning: dense sparse list] ");
            }
            int ct = 0;
            foreach (var sel in SparseValues)
            {
                if (ct++ > 0) sb.Append(delimiter);
                sb.Append(sel);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts this sparse list to an array
        /// </summary>
        /// <returns></returns>
        public T[] ToArray()
        {
            T[] result = new T[Count];
            CopyTo(result, 0);
            return result;
        }

        /// <summary>
        /// Converts this sparse list to an ordinary non-sparse list
        /// </summary>
        /// <returns></returns>
        public List<T> ToList()
        {
            return new List<T>(this);
        }

        #endregion

        #region ISparseEnumerable<T> Members

        /// <summary>
        /// Gets a sparse enumerator
        /// </summary>
        /// <returns></returns>
        public ISparseEnumerator<T> GetSparseEnumerator()
        {
            return new SparseListEnumerator<T>(SparseValues, Count, CommonValue);
        }

        #endregion
    }

    /// <summary>
    /// Approximate Sparse List.
    /// </summary>
    /// <typeparam name="T">List element type. Must implement <see cref="Diffable"/>.</typeparam>
    [Serializable]
    [DataContract]
    public class ApproximateSparseList<T> : SparseList<T>, ISparseList<T>, IList<T>, IList, ICloneable
        where T : Diffable
    {
        /// <summary>
        /// The default tolerance for the approximate sparse list
        /// </summary>
        public static double DefaultTolerance = 0.000001;

        /// <summary>
        /// The tolerance for the approximation
        /// </summary>
        public double Tolerance
        {
            get { return Sparsity.Tolerance; }
            protected set { Sparsity = Sparsity.ApproximateWithTolerance(value); }
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to the default value for the element type
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        /// <returns></returns>
        public static ApproximateSparseList<T> FromSize(int count, double tolerance)
        {
            var v = new ApproximateSparseList<T>(count, default(T), tolerance);
            return v;
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to a specified value
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="value">Value for each element</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        /// <returns></returns>
        public static ApproximateSparseList<T> Constant(int count, T value, double tolerance)
        {
            var v = new ApproximateSparseList<T>(count, value, tolerance);
            return v;
        }

        /// <summary>
        /// Constructs a sparse list from a sorted list of sparse elements.
        /// </summary>
        /// <param name="count">Count for result</param>
        /// <param name="commonValue">Common value</param>
        /// <param name="sortedSparseValues">Sorted list of sparse elements</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        [Construction("Count", "CommonValue", "SparseValues", "Tolerance")]
        public static SparseList<T> FromSparseValues(int count, T commonValue,
                                                     List<ValueAtIndex<T>> sortedSparseValues, double tolerance)
        {
            for (int i = 1; i < sortedSparseValues.Count; i++)
            {
                Assert.IsTrue(sortedSparseValues[i].Index > sortedSparseValues[i - 1].Index);
            }

            var result = new ApproximateSparseList<T>
                {
                    CommonValue = commonValue,
                    Count = count,
                    SparseValues = sortedSparseValues,
                    Tolerance = tolerance,
                };
            return result;
        }

        #region Constructors

        /// <summary>
        /// Null constructor.
        /// </summary>
        protected ApproximateSparseList() : this(DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given number of elements
        /// and with default tolerance.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        protected ApproximateSparseList(int count) : this(count, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// The tolerance is set to the default value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        protected ApproximateSparseList(int count, T commonValue) : this(count, commonValue, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// The tolerance is set to the default value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        protected ApproximateSparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues)
            : this(count, commonValue, sortedSparseValues, DefaultTolerance)
        {
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        protected ApproximateSparseList(ISparseList<T> that) : this(that, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given tolerance
        /// </summary>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(double tolerance) : base()
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given number of elements
        /// and with the given tolerance.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, double tolerance)
            : base(count)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, T commonValue, double tolerance)
            : base(count, commonValue)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues, double tolerance)
            : base(count, commonValue, sortedSparseValues)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(ISparseList<T> that, double tolerance)
            : base(that)
        {
            this.Tolerance = tolerance;
        }

        #endregion

        private void AdjustToTolerance()
        {
            SparseValues.RemoveAll(item => item.Value.MaxDiff(CommonValue) <= Sparsity.Tolerance);
        }

        #region Element-wise access

        /// <summary>Gets or sets an element.</summary>
        public override T this[int index]
        {
            get
            {
                var k = GetSparseIndex(index);
                if (k < 0) return CommonValue;
                return SparseValues[k].Value;
            }
            set
            {
                var k = GetSparseIndex(index);
                if (value.MaxDiff(CommonValue) <= Sparsity.Tolerance)
                {
                    if (k >= 0) SparseValues.RemoveAt(k);
                    return;
                }
                if (k < 0)
                {
                    SparseValues.Insert(~k, new ValueAtIndex<T> {Index = index, Value = value});
                }
                else
                {
                    var sel = SparseValues[k];
                    sel.Value = value;
                    SparseValues[k] = sel;
                }
            }
        }

        #endregion

        #region Cloning, SetTo operations

        /// <summary>
        /// Copies values from a sparse list to this sparse list.
        /// </summary>
        /// <param name="that"></param>
        public void SetTo(ApproximateSparseList<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            CheckCompatible(that, nameof(that));
            CommonValue = that.CommonValue;
            SparseValues = new List<ValueAtIndex<T>>(that.SparseValues);
            Sparsity = that.Sparsity;
        }

        /// <summary>
        /// Copies values from a list which must have the same size as this list,
        /// using the specified common value.
        /// </summary>
        /// <param name="dlist">The list to copy from</param>
        /// <param name="commonValue">Common value</param>
        public override void SetTo(IList<T> dlist, T commonValue)
        {
            SetAllElementsTo(commonValue);
            for (int i = 0; i < dlist.Count; i++)
            {
                T val = dlist[i];
                if (val.MaxDiff(commonValue) > Sparsity.Tolerance) SparseValues.Add(new ValueAtIndex<T> {Index = i, Value = val});
            }
        }

        /// <summary>
        /// Clones this list - return as a sparse list.
        /// </summary>
        /// <returns></returns>
        public new ApproximateSparseList<T> Clone()
        {
            return new ApproximateSparseList<T>(this);
        }

        #endregion

        #region Equality

        /// <summary>
        /// Determines object equality.
        /// </summary>
        /// <param name="obj">Another object.</param>
        /// <returns>True if equal.</returns>
        /// <exclude/>
        public override bool Equals(object obj)
        {
            if (!base.Equals(obj))
                return false;

            ApproximateSparseList<T> that = obj as ApproximateSparseList<T>;
            if (that == null)
                return false;
            return Sparsity == that.Sparsity;
        }

        /// <summary>
        /// Gets a hash code for the instance.
        /// </summary>
        /// <returns>The code.</returns>
        /// <exclude/>
        public override int GetHashCode()
        {
            int hash = base.GetHashCode();
            hash = Hash.Combine(hash, Sparsity.GetHashCode());
            return hash;
        }

        #endregion

        #region General purpose function operators

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of another sparse list
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(SparseList<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a sparse collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(ISparseEnumerable<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(IEnumerable<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this approximate sparse list to a function of the elements of
        /// two other sparse lists
        /// </summary>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are all the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(SparseList<T1> a, SparseList<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this list to a function of the elements of two collections
        /// </summary>
        /// <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(IEnumerable<T1> a, IEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, ISparseEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            base.SetToFunction(a, b, c, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            base.SetToFunction(a, b, c, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three other collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3, T4>(
            ISparseList<T1> a, ISparseList<T2> b, ISparseList<T3> c, ISparseList<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            base.SetToFunction(a, b, c, d, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of four sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3, T4>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, IEnumerable<T4> d,
                                                                          Func<T1, T2, T3, T4, T> fun)
        {
            base.SetToFunction(a, b, c, d, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this approximate sparse list to a function of the elements
        /// of this sparse list and another sparse list x = fun(x,b)
        /// </summary>
        /// <param name="fun">The function which maps (T,T1) to T</param>
        /// <param name="b">The other sparse list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunctionInPlace<T1>(SparseList<T1> b, Func<T, T1, T> fun)
        {
            base.SetToFunctionInPlace(b, fun);
            AdjustToTolerance();
            return this;
        }

        #endregion
    }

    /// <summary>
    /// Exposes sparse lists. Inherits from <see cref="IList{T}"/>
    /// </summary>
    /// <typeparam name="T">Element type</typeparam>
    public interface ISparseList<T> : IList<T>, ISparseEnumerable<T>
    {
    }

    /// <summary>
    /// Contract for sparse enumeration
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface ISparseEnumerator<T> : IEnumerator<T>
    {
        /// <summary>
        /// Current index. If past end of list, current index shows count
        /// </summary>
        int CurrentIndex { get; }

        /// <summary>
        /// Current common value count
        /// </summary>
        int CommonValueCount { get; }

        /// <summary>
        /// The common value for the sparse enumeration
        /// </summary>
        T CommonValue { get; }
    }

    /// <summary>
    /// Sparsely enumerable
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface ISparseEnumerable<T> : IEnumerable<T>
    {
        /// <summary>
        /// Returns a sparse enumerator
        /// </summary>
        /// <returns></returns>
        ISparseEnumerator<T> GetSparseEnumerator();
    }

    /// <summary>
    /// Iterator class for sparse lists
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal class SparseListEnumerator<T> : SparseEnumeratorBase<T>
    {
        private IList<ValueAtIndex<T>> sparseValues;
        private int totalCount;

        /// <summary>
        /// Constructs a sparse enumerator instance for a sparse list
        /// </summary>
        /// <param name="sparseList"></param>
        /// <param name="totalCount"></param>
        /// <param name="commonValue"></param>
        public SparseListEnumerator(IList<ValueAtIndex<T>> sparseList, int totalCount, T commonValue)
        {
            this.sparseValues = sparseList;
            this.commonValue = commonValue;
            this.totalCount = totalCount;
            Reset();
        }

        /// <summary>
        /// Advances the enumerator to the next sparse element of the list.
        /// </summary>
        /// <returns></returns>
        public override bool MoveNext()
        {
            if (sparseValueCount < sparseValues.Count)
            {
                current = sparseValues[sparseValueCount].Value;
                index = sparseValues[sparseValueCount].Index;
                sparseValueCount++;
                return true;
            }
            index = totalCount;
            return false;
        }

        /// <summary>
        /// Resets this enumeration to the beginning
        /// </summary>
        public override void Reset()
        {
            index = -1;
            current = default(T);
            sparseValueCount = 0;
        }
    }

    /// <summary>
    /// Iterator base class for sparse enumeration
    /// </summary>
    /// <typeparam name="TRes"></typeparam>
    internal abstract class SparseEnumeratorBase<TRes> : ISparseEnumerator<TRes>
    {
        protected int index;
        protected TRes current;
        protected TRes commonValue;
        protected int sparseValueCount;

        #region ISparseEnumerator<TRes> Members

        /// <summary>
        /// Returns the index of the current sparse element
        /// </summary>
        public int CurrentIndex
        {
            get { return index; }
        }

        /// <summary>
        /// Returns the count of common values up to this point. Once <see cref="MoveNext"/> returns
        /// false, this property gives the total common value count
        /// </summary>
        public int CommonValueCount
        {
            get
            {
                if (index < 0)
                    throw new InvalidOperationException(
                        "The enumerator is positioned before the first or after the last element of the collection.");
                return index - sparseValueCount;
            }
        }

        /// <summary>
        /// Gets the common value for this sparse collection
        /// </summary>
        public TRes CommonValue
        {
            get { return commonValue; }
        }

        #endregion

        #region IEnumerator<TRes> Members

        /// <summary>
        /// Gets the current element in the collection.
        /// </summary>
        /// <exception cref="System.InvalidOperationException">The enumerator is
        /// positioned before the first or after the last element of the collection.</exception>
        public TRes Current
        {
            get
            {
                if (index < 0)
                    throw new InvalidOperationException(
                        "The enumerator is positioned before the first or after the last element of the collection.");
                return current;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            return;
        }

        #endregion

        #region IEnumerator Members

        object IEnumerator.Current
        {
            get { return (object) Current; }
        }

        /// <summary>
        /// Advances the enumerator to the next sparse element of the list.
        /// </summary>
        /// <returns></returns>
        public abstract bool MoveNext();

        /// <summary>
        /// Resets this enumeration to the beginning
        /// </summary>
        public virtual void Reset()
        {
            index = -1;
            current = default(TRes);
            sparseValueCount = 0;
        }

        #endregion
    }

    internal class ByIndexComparer<T> : IComparer<ValueAtIndex<T>>
    {
        public int Compare(ValueAtIndex<T> x, ValueAtIndex<T> y)
        {
            return x.Index.CompareTo(y.Index);
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.ML.Probabilistic.Utilities;
using System.Collections;
using Microsoft.ML.Probabilistic.Math;
using System.Linq;

namespace Microsoft.ML.Probabilistic.Collections
{
    using Microsoft.ML.Probabilistic.Serialization;
    using System.Runtime.Serialization;

    /// <summary>
    /// A list which is optimised for the case where most of its elements share a common value.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    [Serializable]
    [DataContract]
    public class SparseList<T> : ISparseList<T>, IList, ICloneable
    {
        #region Properties

        // Sparsity
        [DataMember]
        private Sparsity sparsity = Sparsity.Sparse;

        /// <summary>
        /// The <see cref="Sparsity"/> specification of this list.
        /// </summary>
        public Sparsity Sparsity
        {
            get { return sparsity; }
            protected set { sparsity = value; }
        }

        /// <summary>
        /// A list of the value and indices of elements which may not have the common value 
        /// (although they are not precluded from doing so).
        /// This list is kept sorted by index to allow efficient operations on the sparse list.
        /// </summary>
        [DataMember]
        public List<ValueAtIndex<T>> SparseValues { get; protected set; }

        /// <summary>
        /// The value of all elements not mentioned explicitly as sparse values.
        /// </summary>
        [DataMember]
        public T CommonValue { get; protected set; }

        [DataMember]
        private int count;

        /// <summary>
        /// Get or set the number of elements in this list.  Set the number of elements
        /// will grow or shrink the list accordingly.
        /// </summary>
        public int Count
        {
            get { return count; }
            set
            {
                if (value < count)
                {
                    throw new NotImplementedException("Shrinking sparse lists is not yet implemented.");
                }
                count = value;
            }
        }

        /// <summary>
        /// The number of elements not equal to the common value
        /// </summary>
        public int SparseCount
        {
            get { return SparseValues == null ? 0 : SparseValues.Count; }
        }

        #endregion

        #region Factory methods and constructors

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to the default value for the element type
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <returns></returns>
        public static SparseList<T> FromSize(int count)
        {
            var v = new SparseList<T>(count, default(T));
            return v;
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to a specified value
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="value">Value for each element</param>
        /// <returns></returns>
        public static SparseList<T> Constant(int count, T value)
        {
            var v = new SparseList<T>(count, value);
            return v;
        }

        /// <summary>
        /// Creator a sparse list as a copy of another list (which may not be sparse)
        /// </summary>
        /// <param name="that">The source list - can be dense or sparse</param>
        public static SparseList<T> Copy(IList<T> that)
        {
            var v = new SparseList<T>(that.Count);
            v.SetTo(that);
            return v;
        }

        /// <summary>
        /// Constructs a sparse list from a sorted list of sparse elements.
        /// </summary>
        /// <param name="count">Count for result</param>
        /// <param name="commonValue">Common value</param>
        /// <param name="sortedSparseValues">Sorted list of sparse elements</param>
        [Construction("Count", "CommonValue", "SparseValues")]
        public static SparseList<T> FromSparseValues(int count, T commonValue,
                                                     List<ValueAtIndex<T>> sortedSparseValues)
        {
            var result = new SparseList<T>
                {
                    CommonValue = commonValue,
                    Count = count,
                    SparseValues = sortedSparseValues,
                };
            return result;
        }

        #endregion

        #region Constructors

        /// <summary>
        /// Null constructor.
        /// </summary>
        protected SparseList()
        {
        }

        /// <summary>
        /// Constructs a sparse list with the given number of elements.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        protected SparseList(int count)
        {
            SparseValues = new List<ValueAtIndex<T>>();
            Count = count;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        protected SparseList(int count, T commonValue)
            : this(count)
        {
            CommonValue = commonValue;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        protected SparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues)
            : this(count, commonValue)
        {
            SparseValues = sortedSparseValues;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        protected SparseList(ISparseList<T> that)
        {
            SparseValues = new List<ValueAtIndex<T>>();
            Count = that.Count;
            SetTo(that);
        }

        #endregion

        #region Element-wise access

        /// <summary>Gets or sets an element.</summary>
        public virtual T this[int index]
        {
            get
            {
                var k = GetSparseIndex(index);
                if (k < 0) return CommonValue;
                return SparseValues[k].Value;
            }
            set
            {
                var k = GetSparseIndex(index);
                if (Equals(CommonValue, value))
                {
                    if (k >= 0) SparseValues.RemoveAt(k);
                    return;
                }
                if (k < 0)
                {
                    SparseValues.Insert(~k, new ValueAtIndex<T> {Index = index, Value = value});
                }
                else
                {
                    var sel = SparseValues[k];
                    sel.Value = value;
                    SparseValues[k] = sel;
                }
            }
        }

        #endregion

        #region Sparsity-related operations

        /// <summary>
        /// Gets the index into the sparse values array corresponding to an element index.
        /// If there is no sparse value at that index, returns the binary complement of the 
        /// index in the sparse array where such an element should be inserted to retain the
        /// sort order of the sparse array.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        protected int GetSparseIndex(int index)
        {
            return SparseValues.BinarySearch(new ValueAtIndex<T> {Index = index}, new ByIndexComparer<T>());
        }

        /// <summary>
        /// Returns true if there is at least one element which has the common value.
        /// </summary>
        public bool HasCommonElements
        {
            get { return Count > SparseValues.Count; }
        }


        /// <summary>
        /// Gets the dense index of the first common element.
        /// </summary>
        /// <returns>Returns the dense index of the first common element or -1 if there are no common elements</returns>
        public int GetFirstCommonIndex()
        {
            if (HasCommonElements)
            {
                int index = 0;
                foreach (var sel in SparseValues)
                {
                    if (index != sel.Index)
                        return index;
                    index++;
                }
            }
            return -1;
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Gets a typed enumerator which yields the list elements
        /// </summary>
        /// <returns></returns>
        public IEnumerator<T> GetEnumerator()
        {
            int index = 0;
            foreach (var sel in SparseValues)
            {
                while (index < sel.Index)
                {
                    index++;
                    yield return CommonValue;
                }
                index++;
                yield return sel.Value;
            }
            while (index < Count)
            {
                index++;
                yield return CommonValue;
            }
        }

        /// <summary>
        /// Gets an enumerator which yields the list elements
        /// </summary>
        /// <returns></returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #endregion

        #region Cloning, SetTo operations

        /// <summary>
        /// Sets all elements to a given value.
        /// </summary>
        /// <param name="value">The new value.</param>
        public void SetAllElementsTo(T value)
        {
            SparseValues.Clear();
            CommonValue = value;
        }


        /// <summary>
        /// Copies values from another list.
        /// </summary>
        /// <param name="that"></param>
        /// <remarks> The source list can be dense, in which case 
        /// default(T) is used as the common value.</remarks>
        public void SetTo(IList<T> that)
        {
            if (that is SparseList<T> Ts)
            {
                SetTo(Ts);
            }
            else if (Count == that.Count)
            {
                SetTo(that, default(T));
            }
            else
            {
                CommonValue = default(T);
                count = that.Count;
                SparseValues = that.Select((x, i) => new ValueAtIndex<T>(i, x)).ToList();
            }
        }

        /// <summary>
        /// Checks that a given list is the same size as this list.
        /// Throws an exception if not with the given string
        /// </summary>
        /// <param name="that">The list to check</param>
        /// <param name="paramName"></param>
        /// <exclude/>
        protected void CheckCompatible<T2>(IList<T2> that, string paramName)
        {
            Argument.CheckIfValid(that.Count == this.Count, string.Format("Size of {0} does not match size of this list. Expected {1}, got {2}.", paramName, this.Count, that.Count));
        }

        /// <summary>
        /// Copies values from a sparse list to this sparse list.
        /// </summary>
        /// <param name="that"></param>
        public void SetTo(SparseList<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            CheckCompatible(that, nameof(that));
            CommonValue = that.CommonValue;
            SparseValues = new List<ValueAtIndex<T>>(that.SparseValues);
        }

        public void SetTo(IEnumerable<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            if (that is ISparseEnumerable<T>)
            {
                var ise = (that as ISparseEnumerable<T>).GetSparseEnumerator();
                var sel = new List<ValueAtIndex<T>>();
                while (ise.MoveNext())
                    sel.Add(new ValueAtIndex<T>(ise.CurrentIndex, ise.Current));

                CommonValue = ise.CommonValue;
                SparseValues = sel;
                count = ise.CommonValueCount + SparseValues.Count;
            }
            else
            {
                SetTo(that.ToList());
            }
        }


        /// <summary>
        /// Copies values from a list which must have the same size as this list,
        /// using the specified common value.
        /// </summary>
        /// <param name="dlist">The list to copy from</param>
        /// <param name="commonValue">Common value</param>
        public virtual void SetTo(IList<T> dlist, T commonValue)
        {
            SetAllElementsTo(commonValue);
            for (int i = 0; i < dlist.Count; i++)
            {
                T val = dlist[i];
                if (!Equals(val, commonValue)) SparseValues.Add(new ValueAtIndex<T> {Index = i, Value = val});
            }
        }

        /// <summary>
        /// Clones this list - return as a sparse list.
        /// </summary>
        /// <returns></returns>
        public SparseList<T> Clone()
        {
            return new SparseList<T>(this);
        }

        /// <summary>
        /// Clones this list - return as an object
        /// </summary>
        /// <returns></returns>
        object ICloneable.Clone()
        {
            return Clone();
        }

        #endregion

        #region Equality

        /// <summary>
        /// Determines object equality.
        /// </summary>
        /// <param name="obj">Another (list) object.</param>
        /// <returns>True if equal.</returns>
        /// <exclude/>
        public override bool Equals(object obj)
        {
            var that = obj as IList<T>;
            if (ReferenceEquals(this, that)) return true;
            if (ReferenceEquals(that, null))
                return false;
            if (this.Count != that.Count) return false;
            var isEqual = SparseList<bool>.Constant(Count, false);
            return Reduce(true, that, (res, o1, o2) => res && Equals(o1, o2));
        }

        /// <summary>
        /// Gets a hash code for the instance.
        /// </summary>
        /// <returns>The code.</returns>
        /// <exclude/>
        public override int GetHashCode()
        {
            int hash = Hash.Start;
            hash = Hash.Combine(hash, CommonValue.GetHashCode());
            if (SparseValues != null)
                foreach (var sel in SparseValues) hash = Hash.Combine(hash, sel.GetHashCode());
            return hash;
        }

        /// <summary>
        /// Tests if all elements are equal to the given value.
        /// </summary>
        /// <param name="value">The value to test against.</param>
        /// <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        public bool EqualsAll(T value)
        {
            return All(x => Equals(x, value));
        }

        #endregion

        #region LINQ-like operators (All, Any, IndexOfAll etc.)

        /// <summary>
        /// Tests if all elements in the list satisfy the specified condition.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public bool All(Converter<T, bool> fun)
        {
            if (HasCommonElements)
            {
                // At least one element has the common value
                if (!fun(CommonValue)) return false;
            }
            foreach (var sel in SparseValues)
            {
                if (!fun(sel.Value)) return false;
            }
            return true;
        }

        /// <summary>
        /// Tests if any elements in the list satisfy the specified condition.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public bool Any(Converter<T, bool> fun)
        {
            if (HasCommonElements)
            {
                if (fun(CommonValue)) return true;
            }
            foreach (var sel in SparseValues)
            {
                if (fun(sel.Value)) return true;
            }
            return false;
        }

        /// <summary>
        /// Returns an enumeration of the indices of all elements which satisfy the specified condition.
        /// Indices are returned in sorted order.
        /// </summary>
        /// <param name="fun"></param>
        /// <returns></returns>
        public IEnumerable<int> IndexOfAll(Converter<T, bool> fun)
        {
            if (fun(CommonValue))
            {
                for (int i = 0; i < Count; i++)
                {
                    if (fun(this[i])) yield return i;
                }
            }
            else
            {
                foreach (var sel in SparseValues)
                {
                    if (fun(sel.Value)) yield return sel.Index;
                }
            }
        }

        #endregion

        #region Reduce operation

        /// <summary>
        /// Reduce method. Operates on this list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes>(TRes initial, Func<TRes, T, TRes> fun)
        {
            TRes result = initial;
            for (int i = 0; i < Count - SparseValues.Count; i++)
                result = fun(result, CommonValue);
            foreach (var sel in SparseValues)
                result = fun(result, sel.Value);
            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes>(TRes initial, Func<TRes, T, TRes> fun, Func<TRes, T, int, TRes> repeatedFun)
        {
            TRes result = initial;
            result = repeatedFun(result, CommonValue, Count - SparseValues.Count);
            foreach (var sel in SparseValues)
                result = fun(result, sel.Value);
            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// and another sparse list
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="that">The other sparse list</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        public TRes Reduce<TRes, T1>(TRes initial, ISparseEnumerable<T1> that, Func<TRes, T, T1, TRes> fun, Func<TRes, T, T1, int, TRes> repeatedFun)
        {
            TRes result = initial;
            int sparseValueCount = 0;
            var ae = this.GetSparseEnumerator();
            var be = that.GetSparseEnumerator();
            bool aActive = ae.MoveNext();
            bool bActive = be.MoveNext();
            var aCommon = ae.CommonValue;
            var bCommon = be.CommonValue;
            while (aActive || bActive)
            {
                if (aActive)
                {
                    // a is the earlier index
                    if ((!bActive) || ae.CurrentIndex < be.CurrentIndex)
                    {
                        result = fun(result, ae.Current, bCommon);
                        aActive = ae.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                    // a and b equal indices
                    if (bActive && ae.CurrentIndex == be.CurrentIndex)
                    {
                        result = fun(result, ae.Current, be.Current);
                        aActive = ae.MoveNext();
                        bActive = be.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                }
                if (bActive)
                {
                    // b is the earlier index
                    if ((!aActive) || be.CurrentIndex < ae.CurrentIndex)
                    {
                        result = fun(result, aCommon, be.Current);
                        bActive = be.MoveNext();
                        sparseValueCount++;
                        continue;
                    }
                }
            }
            int repeatCount = Count - sparseValueCount;
            if (repeatCount > 0)
                result = repeatedFun(result, aCommon, bCommon, repeatCount);

            return result;
        }

        /// <summary>
        /// Reduce method which can take advantage of sparse structure. Operates on this list
        /// and two other sparse lists
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="b">A second sparse list</param>
        /// <param name="c">A third sparse list</param>
        /// <param name="fun">Reduction function taking partial result and current element</param>
        /// <param name="repeatedFun">Function which computes the reduction function applied multiple times</param>
        /// <returns></returns>
        public TRes Reduce<TRes, T1, T2>(TRes initial, ISparseEnumerable<T1> b, ISparseEnumerable<T2> c, Func<TRes, T, T1, T2, TRes> fun,
                                         Func<TRes, T, T1, T2, int, TRes> repeatedFun)
        {
            TRes result = initial;
            int sparseValueCount = 0;
            var ae = this.GetSparseEnumerator();
            var be = b.GetSparseEnumerator();
            var ce = c.GetSparseEnumerator();
            bool aActive = ae.MoveNext();
            bool bActive = be.MoveNext();
            bool cActive = ce.MoveNext();
            var aCommon = ae.CommonValue;
            var bCommon = be.CommonValue;
            var cCommon = ce.CommonValue;
            while (aActive || bActive || cActive)
            {
                if (aActive)
                {
                    if ((!bActive) || ae.CurrentIndex < be.CurrentIndex)
                    {
                        // a is the earliest index
                        if ((!cActive) || ae.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, bCommon, cCommon);
                            aActive = ae.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // a and c are the earliest index
                        if (cActive && ae.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, bCommon, ce.Current);
                            aActive = ae.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                    if (bActive && ae.CurrentIndex == be.CurrentIndex)
                    {
                        // a and b are the earliest index
                        if ((!cActive) || ae.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, be.Current, cCommon);
                            aActive = ae.MoveNext();
                            bActive = be.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // a, b, and c are the earliest index
                        if (cActive && ae.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, ae.Current, be.Current, ce.Current);
                            aActive = ae.MoveNext();
                            bActive = be.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
                if (bActive)
                {
                    if ((!aActive) || be.CurrentIndex < ae.CurrentIndex)
                    {
                        // b is the earliest index
                        if ((!cActive) || be.CurrentIndex < ce.CurrentIndex)
                        {
                            result = fun(result, aCommon, be.Current, cCommon);
                            bActive = be.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                        // b and c are the earliest index
                        if (cActive && be.CurrentIndex == ce.CurrentIndex)
                        {
                            result = fun(result, aCommon, be.Current, ce.Current);
                            bActive = be.MoveNext();
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
                if (cActive)
                {
                    if ((!aActive) || ce.CurrentIndex < ae.CurrentIndex)
                    {
                        // c is the earliest index
                        if ((!bActive) || ce.CurrentIndex < be.CurrentIndex)
                        {
                            result = fun(result, aCommon, bCommon, ce.Current);
                            cActive = ce.MoveNext();
                            sparseValueCount++;
                            continue;
                        }
                    }
                }
            }

            int repeatCount = Count - sparseValueCount;
            if (repeatCount > 0)
                result = repeatedFun(result, aCommon, bCommon, cCommon, repeatCount);

            return result;
        }

        /// <summary>
        /// Reduce method. Operates on this list and another list.
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="that">A second list</param>
        /// <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="that"/></param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes, T2>(TRes initial, IEnumerable<T2> that, Func<TRes, T, T2, TRes> fun)
        {
            TRes result = initial;
            IEnumerator<T> thisEnum = GetEnumerator();
            IEnumerator<T2> thatEnum = that.GetEnumerator();

            while (thisEnum.MoveNext() && thatEnum.MoveNext())
                result = fun(result, thisEnum.Current, thatEnum.Current);
            return result;
        }

        /// <summary>
        /// Reduce method. Operates on this list and two other lists.
        /// </summary>
        /// <param name="initial">Initial value</param>
        /// <param name="a">A second list</param>
        /// <param name="b">A third list</param>
        /// <param name="fun">Reduction function taking partial result, current element, and current element of <paramref name="a"/> and <paramref name="b"/></param>
        /// <returns></returns>
        /// <remarks>This method does not take advantage of this list's sparseness.</remarks>
        public TRes Reduce<TRes, T1, T2>(TRes initial, IList<T1> a, IList<T2> b, Func<TRes, T, T1, T2, TRes> fun)
        {
            TRes result = initial;
            IEnumerator<T> thisEnum = GetEnumerator();
            IEnumerator<T1> aEnum = a.GetEnumerator();
            IEnumerator<T2> bEnum = b.GetEnumerator();

            while (thisEnum.MoveNext() && aEnum.MoveNext() && bEnum.MoveNext())
                result = fun(result, thisEnum.Current, aEnum.Current, bEnum.Current);
            return result;
        }

        #endregion

        #region IList support (interface implemented mainly for convenience, most operations are not supported)

        /// <summary>
        /// Returns true if this list contains the specified value
        /// </summary>
        /// <param name="value">The value to test for</param>
        /// <returns></returns>
        public bool Contains(T value)
        {
            if (HasCommonElements)
            {
                // At least one element has the common value
                if (Equals(CommonValue, value)) return true;
            }
            foreach (var sel in SparseValues)
            {
                if (Equals(sel.Value, value)) return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the index of the first occurence of the given value in the list.
        /// Returns -1 if the value is not in the list
        /// </summary>
        /// <param name="item">The item to check for</param>
        /// <returns>Its index in the list</returns>
        public int IndexOf(T item)
        {
            if (HasCommonElements)
            {
                if (Equals(item, CommonValue))
                {
                    int idx = 0;
                    foreach (var sel in SparseValues)
                    {
                        if (sel.Index != idx) return idx;
                        idx++;
                    }
                }
            }
            foreach (var sel in SparseValues)
            {
                if (Equals(sel.Value, item)) return sel.Index;
            }
            return -1;
        }

        /// <summary>
        /// Sparse lists are not read only.
        /// </summary>
        public bool IsReadOnly
        {
            get { return false; }
        }

        /// <summary>
        /// Copies this sparse list to the given array starting at the specified index
        /// in the target array
        /// </summary>
        /// <param name="array">The target array</param>
        /// <param name="index">The start index in the target array</param>
        public void CopyTo(T[] array, int index)
        {
            int j = index;
            for (int i = 0; i < Count; i++, j++)
                array[j] = CommonValue;
            foreach (var sel in SparseValues)
                array[index + sel.Index] = sel.Value;
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        public void Insert(int index, T item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        public void RemoveAt(int index)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Clears this list, setting it to zero length.
        /// </summary>
        public void Clear()
        {
            Count = 0;
            SparseValues.Clear();
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            throw new NotImplementedException();
        }


        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        int IList.Add(object value)
        {
            throw new NotImplementedException();
        }


        bool IList.Contains(object value)
        {
            if (!(value is T)) return false;
            return Contains((T) value);
        }

        int IList.IndexOf(object value)
        {
            if (!(value is T)) return -1;
            return IndexOf((T) value);
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        void IList.Insert(int index, object value)
        {
            throw new NotImplementedException();
        }

        bool IList.IsFixedSize
        {
            get { return false; }
        }

        /// <summary>
        /// Not implemented
        /// </summary>
        /// <param name="value"></param>
        void IList.Remove(object value)
        {
            throw new NotImplementedException();
        }

        object IList.this[int index]
        {
            get { return this[index]; }
            set { this[index] = (T) value; }
        }


        void ICollection.CopyTo(Array array, int index)
        {
            CopyTo((T[]) array, index);
        }

        bool ICollection.IsSynchronized
        {
            get { return false; }
        }

        object ICollection.SyncRoot
        {
            get { return null; }
        }

        #endregion

        #region General purpose function operators

        /// <summary>
        /// Creates an array from the list
        /// </summary>
        /// <typeparam name="T2"></typeparam>
        /// <param name="that"></param>
        /// <returns></returns>
        protected T2[] ToArray<T2>(IList<T2> that)
        {
            var thatArray = new T2[that.Count];
            that.CopyTo(thatArray, 0);
            return thatArray;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of another sparse list
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(SparseList<T2> that, Func<T2, T> fun)
        {
            CheckCompatible(that, nameof(that));
            CommonValue = fun(that.CommonValue);
            SparseValues = that.SparseValues.ConvertAll(x => new ValueAtIndex<T> {Index = x.Index, Value = fun(x.Value)});
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a sparse collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(ISparseEnumerable<T2> that, Func<T2, T> fun)
        {
            if (that is IList<T2> T2s)
                CheckCompatible(T2s, nameof(that));

            ISparseEnumerable<T> res = fun.Map(that) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            SparseValues.Clear();
            while (rese.MoveNext())
                SparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T2>(IEnumerable<T2> that, Func<T2, T> fun)
        {
            if (that is SparseList<T2> T2s)
                return SetToFunction(T2s, fun);

            if (that is ISparseEnumerable<T2> T2s)
                return SetToFunction(T2s, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(that);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are all the same length</remarks>
        public SparseList<T> SetToFunction<T1, T2>(SparseList<T1> a, SparseList<T2> b, Func<T1, T2, T> fun)
        {
            CheckCompatible(a, nameof(a));
            CheckCompatible(b, nameof(b));
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) && !ReferenceEquals(b, this)) return SetToFunctionInPlace<T2>(b, (x, y) => fun((T1) (object) x, y));
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this))
            {
                // This vector is one of the arguments, do not modify in place. Instead create
                // a new list to hold the sparse values of the results.

                // Set the new capacity conservatively, assuming the sparse values do not overlap
                newSparseValues = new List<ValueAtIndex<T>>(a.SparseValues.Count + b.SparseValues.Count);
            }
            else
            {
                // We can safely modify the sparse values list in place
                SparseValues.Clear();
                int targetCapacity = a.SparseValues.Count + b.SparseValues.Count;
                int currentCapacity = SparseValues.Capacity;
                if ((currentCapacity < targetCapacity/2) || (currentCapacity > targetCapacity*2))
                {
                    SparseValues.Capacity = targetCapacity;
                }
                newSparseValues = SparseValues;
            }
            // TODO: consider changing to use enumerators
            int aIndex = 0;
            int bIndex = 0;
            var aSel = a.GetSparseValue(aIndex);
            var bSel = b.GetSparseValue(bIndex);
            T newCommonValue = fun(a.CommonValue, b.CommonValue);
            while ((aSel.Index != -1) || (bSel.Index != -1))
            {
                if (((aSel.Index < bSel.Index) && (aSel.Index != -1)) || (bSel.Index == -1))
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = aSel.Index, Value = fun(aSel.Value, b.CommonValue)});
                    aIndex++;
                    aSel = a.GetSparseValue(aIndex);
                    continue;
                }
                if ((bSel.Index < aSel.Index) || (aSel.Index == -1))
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = bSel.Index, Value = fun(a.CommonValue, bSel.Value)});
                    bIndex++;
                    bSel = b.GetSparseValue(bIndex);
                    continue;
                }
                // If two indices are the same, apply operator to both
                if (aSel.Index == bSel.Index)
                {
                    newSparseValues.Add(new ValueAtIndex<T> {Index = aSel.Index, Value = fun(aSel.Value, bSel.Value)});
                    aIndex++;
                    bIndex++;
                    aSel = a.GetSparseValue(aIndex);
                    bSel = b.GetSparseValue(bIndex);
                }
            }
            CommonValue = newCommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            if (a is IList<T1> T1s)
                CheckCompatible(T1s, nameof(a));
            if (b is IList<T2> T2s)
                CheckCompatible(T2s, nameof(b));

            ISparseEnumerable<T> res = fun.Map(a, b) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this list to a function of the elements of two collections
        /// </summary>
        /// <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public SparseList<T> SetToFunction<T1, T2>(IEnumerable<T1> a, IEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            if ((a is SparseList<T1>) && (b is SparseList<T2>))
                return SetToFunction((SparseList<T1>) a, (SparseList<T2>) b, fun);

            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }


        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, ISparseEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            if (a is IList<T1> T1s)
                CheckCompatible(T1s, nameof(a));
            if (b is IList<T2> T2s)
                CheckCompatible(T2s, nameof(b));
            if (c is IList<T3> T3s)
                CheckCompatible(T3s, nameof(c));
            ISparseEnumerable<T> res = fun.Map(a, b, c) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this) || ReferenceEquals(c, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, (ISparseEnumerable<T3>) c, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b, c);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three other collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3, T4>(
            ISparseList<T1> a, ISparseList<T2> b, ISparseList<T3> c, ISparseList<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            if (a is IList<T1> T1s)
                CheckCompatible(T1s, nameof(a));
            if (b is IList<T2> T2s)
                CheckCompatible(T2s, nameof(b));
            if (c is IList<T3> T3s)
                CheckCompatible(T3s, nameof(c));
            if (d is IList<T4> T4s)
                CheckCompatible(T4s, nameof(d));

            ISparseEnumerable<T> res = fun.Map(a, b, c, d) as ISparseEnumerable<T>; // Lazy
            var rese = res.GetSparseEnumerator();
            List<ValueAtIndex<T>> newSparseValues;
            if (ReferenceEquals(a, this) || ReferenceEquals(b, this) || ReferenceEquals(c, this) || ReferenceEquals(d, this))
                newSparseValues = new List<ValueAtIndex<T>>();
            else
            {
                SparseValues.Clear();
                newSparseValues = SparseValues;
            }
            while (rese.MoveNext())
                newSparseValues.Add(new ValueAtIndex<T>(rese.CurrentIndex, rese.Current));
            CommonValue = rese.CommonValue;
            SparseValues = newSparseValues;
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of four sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public SparseList<T> SetToFunction<T1, T2, T3, T4>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, IEnumerable<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            if ((a is ISparseEnumerable<T1>) && (b is ISparseEnumerable<T2>))
                return SetToFunction((ISparseEnumerable<T1>) a, (ISparseEnumerable<T2>) b, (ISparseEnumerable<T3>) c, (ISparseEnumerable<T4>) d, fun);

            List<T> fdata = new List<T>();
            var fmap = fun.Map(a, b, c, d);
            foreach (T elem in fmap)
                fdata.Add(elem);
            SetTo(ToArray(fdata));
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of this sparse list and another sparse list
        /// x = fun(x,b)
        /// </summary>
        /// <param name="fun">The function which maps (T,T1) to T</param>
        /// <param name="b">The other sparse list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public virtual SparseList<T> SetToFunctionInPlace<T1>(SparseList<T1> b, Func<T, T1, T> fun)
        {
            CheckCompatible(b, nameof(b));
            if (ReferenceEquals(b, this))
            {
                throw new NotSupportedException($"{nameof(b)} must not be equal to this");
            }
            // TODO: consider changing to use enumerators
            int aIndex = 0;
            int bIndex = 0;
            var aSel = GetSparseValue(aIndex);
            var bSel = b.GetSparseValue(bIndex);
            T newCommonValue = fun(CommonValue, b.CommonValue);
            while ((aSel.Index != -1) || (bSel.Index != -1))
            {
                if (((aSel.Index < bSel.Index) && (aSel.Index != -1)) || (bSel.Index == -1))
                {
                    aSel.Value = fun(aSel.Value, b.CommonValue);
                    SparseValues[aIndex] = aSel;
                    aIndex++;
                    aSel = GetSparseValue(aIndex);
                    continue;
                }
                if ((bSel.Index < aSel.Index) || (aSel.Index == -1))
                {
                    SparseValues.Insert(aIndex, new ValueAtIndex<T> {Index = bSel.Index, Value = fun(CommonValue, bSel.Value)});
                    aIndex++;
                    bIndex++;
                    bSel = b.GetSparseValue(bIndex);
                    continue;
                }
                // If two indices are the same, apply operator to both
                if (aSel.Index == bSel.Index)
                {
                    aSel.Value = fun(aSel.Value, bSel.Value);
                    SparseValues[aIndex] = aSel;
                    aIndex++;
                    bIndex++;
                    aSel = GetSparseValue(aIndex);
                    bSel = b.GetSparseValue(bIndex);
                }
            }
            CommonValue = newCommonValue;
            return this;
        }

        internal ValueAtIndex<T> GetSparseValue(int index)
        {
            return index < SparseValues.Count ? SparseValues[index] : ValueAtIndex<T>.NoElement;
        }

        #endregion

        #region Conversions (ToString, ToArray etc.)

        /// <summary>
        /// Converts this sparse list into a human readable string
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return ToString(",");
        }

        /// <summary>
        /// String representation of this list with a specified delimiter
        /// </summary>
        /// <param name="delimiter"></param>
        /// <returns></returns>
        public string ToString(string delimiter)
        {
            StringBuilder sb = new StringBuilder();
            if (HasCommonElements)
            {
                sb.Append("[0.." + (Count - 1) + "]=" + CommonValue);
                if (SparseValues.Count > 0) sb.Append(" except " + SparseValues.Count + " values ");
            }
            else
            {
                sb.Append("[Warning: dense sparse list] ");
            }
            int ct = 0;
            foreach (var sel in SparseValues)
            {
                if (ct++ > 0) sb.Append(delimiter);
                sb.Append(sel);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts this sparse list to an array
        /// </summary>
        /// <returns></returns>
        public T[] ToArray()
        {
            T[] result = new T[Count];
            CopyTo(result, 0);
            return result;
        }

        /// <summary>
        /// Converts this sparse list to an ordinary non-sparse list
        /// </summary>
        /// <returns></returns>
        public List<T> ToList()
        {
            return new List<T>(this);
        }

        #endregion

        #region ISparseEnumerable<T> Members

        /// <summary>
        /// Gets a sparse enumerator
        /// </summary>
        /// <returns></returns>
        public ISparseEnumerator<T> GetSparseEnumerator()
        {
            return new SparseListEnumerator<T>(SparseValues, Count, CommonValue);
        }

        #endregion
    }

    /// <summary>
    /// Approximate Sparse List.
    /// </summary>
    /// <typeparam name="T">List element type. Must implement <see cref="Diffable"/>.</typeparam>
    [Serializable]
    [DataContract]
    public class ApproximateSparseList<T> : SparseList<T>, ISparseList<T>, IList<T>, IList, ICloneable
        where T : Diffable
    {
        /// <summary>
        /// The default tolerance for the approximate sparse list
        /// </summary>
        public static double DefaultTolerance = 0.000001;

        /// <summary>
        /// The tolerance for the approximation
        /// </summary>
        public double Tolerance
        {
            get { return Sparsity.Tolerance; }
            protected set { Sparsity = Sparsity.ApproximateWithTolerance(value); }
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to the default value for the element type
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        /// <returns></returns>
        public static ApproximateSparseList<T> FromSize(int count, double tolerance)
        {
            var v = new ApproximateSparseList<T>(count, default(T), tolerance);
            return v;
        }

        /// <summary>
        /// Create a sparse list of given length with elements all equal
        /// to a specified value
        /// </summary>
        /// <param name="count">Number of elements in the list</param>
        /// <param name="value">Value for each element</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        /// <returns></returns>
        public static ApproximateSparseList<T> Constant(int count, T value, double tolerance)
        {
            var v = new ApproximateSparseList<T>(count, value, tolerance);
            return v;
        }

        /// <summary>
        /// Constructs a sparse list from a sorted list of sparse elements.
        /// </summary>
        /// <param name="count">Count for result</param>
        /// <param name="commonValue">Common value</param>
        /// <param name="sortedSparseValues">Sorted list of sparse elements</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        [Construction("Count", "CommonValue", "SparseValues", "Tolerance")]
        public static SparseList<T> FromSparseValues(int count, T commonValue,
                                                     List<ValueAtIndex<T>> sortedSparseValues, double tolerance)
        {
            for (int i = 1; i < sortedSparseValues.Count; i++)
            {
                Assert.IsTrue(sortedSparseValues[i].Index > sortedSparseValues[i - 1].Index);
            }

            var result = new ApproximateSparseList<T>
                {
                    CommonValue = commonValue,
                    Count = count,
                    SparseValues = sortedSparseValues,
                    Tolerance = tolerance,
                };
            return result;
        }

        #region Constructors

        /// <summary>
        /// Null constructor.
        /// </summary>
        protected ApproximateSparseList() : this(DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given number of elements
        /// and with default tolerance.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        protected ApproximateSparseList(int count) : this(count, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// The tolerance is set to the default value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        protected ApproximateSparseList(int count, T commonValue) : this(count, commonValue, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// The tolerance is set to the default value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        protected ApproximateSparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues)
            : this(count, commonValue, sortedSparseValues, DefaultTolerance)
        {
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        protected ApproximateSparseList(ISparseList<T> that) : this(that, DefaultTolerance)
        {
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given tolerance
        /// </summary>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(double tolerance) : base()
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs an approximate sparse list with the given number of elements
        /// and with the given tolerance.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, double tolerance)
            : base(count)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, T commonValue, double tolerance)
            : base(count, commonValue)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Constructs a sparse list of a given length and assigns all elements the given value, except
        /// for the specified list of sparse values. This list is stored internally as is
        /// so MUST be sorted by index and must not be modified externally after being passed in.
        /// </summary>
        /// <param name="count">Number of elements to allocate (>= 0).</param>
        /// <param name="commonValue">The value to assign to all elements.</param>
        /// <param name="sortedSparseValues">The list of sparse values, which must be sorted by index.</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(int count, T commonValue, List<ValueAtIndex<T>> sortedSparseValues, double tolerance)
            : base(count, commonValue, sortedSparseValues)
        {
            this.Tolerance = tolerance;
        }

        /// <summary>
        /// Copy constructor.
        /// </summary>
        /// <param name="that">the sparse list to copy into this new sparse list</param>
        /// <param name="tolerance">The tolerance for the approximation</param>
        protected ApproximateSparseList(ISparseList<T> that, double tolerance)
            : base(that)
        {
            this.Tolerance = tolerance;
        }

        #endregion

        private void AdjustToTolerance()
        {
            SparseValues.RemoveAll(item => item.Value.MaxDiff(CommonValue) <= Sparsity.Tolerance);
        }

        #region Element-wise access

        /// <summary>Gets or sets an element.</summary>
        public override T this[int index]
        {
            get
            {
                var k = GetSparseIndex(index);
                if (k < 0) return CommonValue;
                return SparseValues[k].Value;
            }
            set
            {
                var k = GetSparseIndex(index);
                if (value.MaxDiff(CommonValue) <= Sparsity.Tolerance)
                {
                    if (k >= 0) SparseValues.RemoveAt(k);
                    return;
                }
                if (k < 0)
                {
                    SparseValues.Insert(~k, new ValueAtIndex<T> {Index = index, Value = value});
                }
                else
                {
                    var sel = SparseValues[k];
                    sel.Value = value;
                    SparseValues[k] = sel;
                }
            }
        }

        #endregion

        #region Cloning, SetTo operations

        /// <summary>
        /// Copies values from a sparse list to this sparse list.
        /// </summary>
        /// <param name="that"></param>
        public void SetTo(ApproximateSparseList<T> that)
        {
            if (Object.ReferenceEquals(this, that)) return;
            CheckCompatible(that, nameof(that));
            CommonValue = that.CommonValue;
            SparseValues = new List<ValueAtIndex<T>>(that.SparseValues);
            Sparsity = that.Sparsity;
        }

        /// <summary>
        /// Copies values from a list which must have the same size as this list,
        /// using the specified common value.
        /// </summary>
        /// <param name="dlist">The list to copy from</param>
        /// <param name="commonValue">Common value</param>
        public override void SetTo(IList<T> dlist, T commonValue)
        {
            SetAllElementsTo(commonValue);
            for (int i = 0; i < dlist.Count; i++)
            {
                T val = dlist[i];
                if (val.MaxDiff(commonValue) > Sparsity.Tolerance) SparseValues.Add(new ValueAtIndex<T> {Index = i, Value = val});
            }
        }

        /// <summary>
        /// Clones this list - return as a sparse list.
        /// </summary>
        /// <returns></returns>
        public new ApproximateSparseList<T> Clone()
        {
            return new ApproximateSparseList<T>(this);
        }

        #endregion

        #region Equality

        /// <summary>
        /// Determines object equality.
        /// </summary>
        /// <param name="obj">Another object.</param>
        /// <returns>True if equal.</returns>
        /// <exclude/>
        public override bool Equals(object obj)
        {
            if (!base.Equals(obj))
                return false;

            ApproximateSparseList<T> that = obj as ApproximateSparseList<T>;
            if (that == null)
                return false;
            return Sparsity == that.Sparsity;
        }

        /// <summary>
        /// Gets a hash code for the instance.
        /// </summary>
        /// <returns>The code.</returns>
        /// <exclude/>
        public override int GetHashCode()
        {
            int hash = base.GetHashCode();
            hash = Hash.Combine(hash, Sparsity.GetHashCode());
            return hash;
        }

        #endregion

        #region General purpose function operators

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of another sparse list
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(SparseList<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a sparse collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(ISparseEnumerable<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of a collection
        /// </summary>
        /// <param name="fun">The function which maps from type T2 to type T</param>
        /// <param name="that">The other list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T2>(IEnumerable<T2> that, Func<T2, T> fun)
        {
            base.SetToFunction(that, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this approximate sparse list to a function of the elements of
        /// two other sparse lists
        /// </summary>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are all the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(SparseList<T1> a, SparseList<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of two other sparse lists
        /// </summary>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <param name="fun">The function which maps two elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this list to a function of the elements of two collections
        /// </summary>
        /// <param name="fun">The function which maps the two elements of the other lists to an element of this list</param>
        /// <param name="a">The first list</param>
        /// <param name="b">The second list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunction<T1, T2>(IEnumerable<T1> a, IEnumerable<T2> b, Func<T1, T2, T> fun)
        {
            base.SetToFunction(a, b, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3>(
            ISparseEnumerable<T1> a, ISparseEnumerable<T2> b, ISparseEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            base.SetToFunction(a, b, c, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="fun">The function which maps three elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, Func<T1, T2, T3, T> fun)
        {
            base.SetToFunction(a, b, c, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of three other collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3, T4>(
            ISparseList<T1> a, ISparseList<T2> b, ISparseList<T3> c, ISparseList<T4> d, Func<T1, T2, T3, T4, T> fun)
        {
            base.SetToFunction(a, b, c, d, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this sparse list to a function of the elements of four sparse collections
        /// </summary>
        /// <param name="a">The first collection</param>
        /// <param name="b">The second collection</param>
        /// <param name="c">The third collection</param>
        /// <param name="d">The fourth collection</param>
        /// <param name="fun">The function which maps four elements to an element of this list</param>
        /// <returns></returns>
        public new ApproximateSparseList<T> SetToFunction<T1, T2, T3, T4>(IEnumerable<T1> a, IEnumerable<T2> b, IEnumerable<T3> c, IEnumerable<T4> d,
                                                                          Func<T1, T2, T3, T4, T> fun)
        {
            base.SetToFunction(a, b, c, d, fun);
            AdjustToTolerance();
            return this;
        }

        /// <summary>
        /// Sets the elements of this approximate sparse list to a function of the elements
        /// of this sparse list and another sparse list x = fun(x,b)
        /// </summary>
        /// <param name="fun">The function which maps (T,T1) to T</param>
        /// <param name="b">The other sparse list</param>
        /// <returns></returns>
        /// <remarks>Assumes the lists are the same length</remarks>
        public new ApproximateSparseList<T> SetToFunctionInPlace<T1>(SparseList<T1> b, Func<T, T1, T> fun)
        {
            base.SetToFunctionInPlace(b, fun);
            AdjustToTolerance();
            return this;
        }

        #endregion
    }

    /// <summary>
    /// Exposes sparse lists. Inherits from <see cref="IList{T}"/>
    /// </summary>
    /// <typeparam name="T">Element type</typeparam>
    public interface ISparseList<T> : IList<T>, ISparseEnumerable<T>
    {
    }

    /// <summary>
    /// Contract for sparse enumeration
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface ISparseEnumerator<T> : IEnumerator<T>
    {
        /// <summary>
        /// Current index. If past end of list, current index shows count
        /// </summary>
        int CurrentIndex { get; }

        /// <summary>
        /// Current common value count
        /// </summary>
        int CommonValueCount { get; }

        /// <summary>
        /// The common value for the sparse enumeration
        /// </summary>
        T CommonValue { get; }
    }

    /// <summary>
    /// Sparsely enumerable
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface ISparseEnumerable<T> : IEnumerable<T>
    {
        /// <summary>
        /// Returns a sparse enumerator
        /// </summary>
        /// <returns></returns>
        ISparseEnumerator<T> GetSparseEnumerator();
    }

    /// <summary>
    /// Iterator class for sparse lists
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal class SparseListEnumerator<T> : SparseEnumeratorBase<T>
    {
        private IList<ValueAtIndex<T>> sparseValues;
        private int totalCount;

        /// <summary>
        /// Constructs a sparse enumerator instance for a sparse list
        /// </summary>
        /// <param name="sparseList"></param>
        /// <param name="totalCount"></param>
        /// <param name="commonValue"></param>
        public SparseListEnumerator(IList<ValueAtIndex<T>> sparseList, int totalCount, T commonValue)
        {
            this.sparseValues = sparseList;
            this.commonValue = commonValue;
            this.totalCount = totalCount;
            Reset();
        }

        /// <summary>
        /// Advances the enumerator to the next sparse element of the list.
        /// </summary>
        /// <returns></returns>
        public override bool MoveNext()
        {
            if (sparseValueCount < sparseValues.Count)
            {
                current = sparseValues[sparseValueCount].Value;
                index = sparseValues[sparseValueCount].Index;
                sparseValueCount++;
                return true;
            }
            index = totalCount;
            return false;
        }

        /// <summary>
        /// Resets this enumeration to the beginning
        /// </summary>
        public override void Reset()
        {
            index = -1;
            current = default(T);
            sparseValueCount = 0;
        }
    }

    /// <summary>
    /// Iterator base class for sparse enumeration
    /// </summary>
    /// <typeparam name="TRes"></typeparam>
    internal abstract class SparseEnumeratorBase<TRes> : ISparseEnumerator<TRes>
    {
        protected int index;
        protected TRes current;
        protected TRes commonValue;
        protected int sparseValueCount;

        #region ISparseEnumerator<TRes> Members

        /// <summary>
        /// Returns the index of the current sparse element
        /// </summary>
        public int CurrentIndex
        {
            get { return index; }
        }

        /// <summary>
        /// Returns the count of common values up to this point. Once <see cref="MoveNext"/> returns
        /// false, this property gives the total common value count
        /// </summary>
        public int CommonValueCount
        {
            get
            {
                if (index < 0)
                    throw new InvalidOperationException(
                        "The enumerator is positioned before the first or after the last element of the collection.");
                return index - sparseValueCount;
            }
        }

        /// <summary>
        /// Gets the common value for this sparse collection
        /// </summary>
        public TRes CommonValue
        {
            get { return commonValue; }
        }

        #endregion

        #region IEnumerator<TRes> Members

        /// <summary>
        /// Gets the current element in the collection.
        /// </summary>
        /// <exception cref="System.InvalidOperationException">The enumerator is
        /// positioned before the first or after the last element of the collection.</exception>
        public TRes Current
        {
            get
            {
                if (index < 0)
                    throw new InvalidOperationException(
                        "The enumerator is positioned before the first or after the last element of the collection.");
                return current;
            }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// 
        /// </summary>
        public void Dispose()
        {
            return;
        }

        #endregion

        #region IEnumerator Members

        object IEnumerator.Current
        {
            get { return (object) Current; }
        }

        /// <summary>
        /// Advances the enumerator to the next sparse element of the list.
        /// </summary>
        /// <returns></returns>
        public abstract bool MoveNext();

        /// <summary>
        /// Resets this enumeration to the beginning
        /// </summary>
        public virtual void Reset()
        {
            index = -1;
            current = default(TRes);
            sparseValueCount = 0;
        }

        #endregion
    }

    internal class ByIndexComparer<T> : IComparer<ValueAtIndex<T>>
    {
        public int Compare(ValueAtIndex<T> x, ValueAtIndex<T> y)
        {
            return x.Index.CompareTo(y.Index);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Runtime\Core\Collections\SparseList.cs(1053,47): error CS0128: A local variable or function named 'T2s' is already defined in this scope,D:\a\1\s\src\Runtime\Core\Collections\SparseList.cs(1054,38): error CS0165: Use of unassigned local variable 'T2s'
######################################################################


######################################################################
Nr: 3 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Runtime\Core\Serialization\MatlabWriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;

namespace Microsoft.ML.Probabilistic.Serialization
{
    /// <summary>
    /// Write data objects to a MAT file
    /// </summary>
    /// <remarks>
    /// The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
    /// </remarks>
    public class MatlabWriter : IDisposable
    {
        private Stream writer;

        /// <summary>
        /// Create a MatlabWriter to write to a given file name.
        /// </summary>
        /// <param name="fileName">The file name to write to (will be created if missing, or truncated if already exists)</param>
        public MatlabWriter(string fileName)
        {
            writer = new FileStream(fileName, FileMode.Create);
            Write(Matlab5Header("MATLAB 5.0 MAT-file, Created by Microsoft.ML.Probabilistic.Utililies.MatlabWriter"));
        }

        /// <summary>
        /// Write an array of bytes to the stream
        /// </summary>
        /// <param name="bytes"></param>
        protected void Write(byte[] bytes)
        {
            writer.Write(bytes, 0, bytes.Length);
        }

        protected void Write(MatType type)
        {
            Write((int) type);
        }

        protected void Write(short value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(ushort value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(int value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(uint value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(long value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(ulong value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(double value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(Single value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(byte value)
        {
            writer.WriteByte(value);
        }

        /// <summary>
        /// Write a string value with zero padding to write numBytes in total.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="numBytes"></param>
        protected void Write(string value, int numBytes)
        {
            for (int i = 0; i < value.Length; i++)
            {
                writer.WriteByte((byte) value[i]);
            }
            for (int i = value.Length; i < numBytes; i++)
            {
                writer.WriteByte(0);
            }
        }

        /// <summary>
        /// Write a named object to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, object value)
        {
            if (value is Matrix) Write(name, (Matrix)value);
            else if (value is bool) Write(name, (bool)value ? (byte)1 : (byte)0);
            else if (value is byte) Write(name, (byte)value);
            else if (value is short) Write(name, (short)value);
            else if (value is ushort) Write(name, (ushort)value);
            else if (value is int) Write(name, (int)value);
            else if (value is uint) Write(name, (uint)value);
            else if (value is long) Write(name, (long)value);
            else if (value is ulong) Write(name, (ulong)value);
            else if (value is Single) Write(name, (Single)value);
            else if (value is double) Write(name, (double)value);
            else if (value is MatlabReader.ComplexMatrix) Write(name, (MatlabReader.ComplexMatrix)value);
            else if (value is string) Write(name, (string)value);
            else if (value is object[,]) Write(name, (object[,])value);
            else if (value is IReadOnlyList<bool>) Write(name, (IReadOnlyList<bool>)value);
            else if (value is IReadOnlyList<int>) Write(name, (IReadOnlyList<int>)value);
            else if (value is IReadOnlyList<uint>) Write(name, (IReadOnlyList<uint>)value);
            else if (value is IReadOnlyList<long>) Write(name, (IReadOnlyList<long>)value);
            else if (value is IReadOnlyList<double>) Write(name, (IReadOnlyList<double>)value);
            else if (value is IReadOnlyList<object>) Write<object>(name, (IReadOnlyList<object>)value);
            else if (value is IReadOnlyList<string>) Write<string>(name, (IReadOnlyList<string>)value);
            else if (value is Array) WriteArray(name, (Array)value);
            else if (ReferenceEquals(value, null))
            {
                Write(MatType.MATRIX);
                Write(0);
            }
            else if (value is IReadOnlyDictionary<string, object>) Write(name, (IReadOnlyDictionary<string, object>)value);
            else if (TryWriteDictionary(name, value)) return;
            else throw new NotImplementedException("Cannot write type " + StringUtil.TypeToString(value.GetType()));
        }

        protected bool TryWriteDictionary(string name, object value)
        {
            Type type = value.GetType();
            foreach(Type interfaceType in type.GetInterfaces()) {
                if (interfaceType.Name == typeof(IReadOnlyDictionary<,>).Name)
                {
                    Type[] args = interfaceType.GetGenericArguments();
                    if (args[0].Equals(typeof(string)))
                    {
                        var method = new Action<string, IReadOnlyDictionary<string, object>>(Write).Method;
                        method = method.GetGenericMethodDefinition();
                        Util.Invoke(method.MakeGenericMethod(args[1]), this, name, value);
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Write a named bool array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<bool> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT8, 1, false, true);
            Write(MatType.UINT8);
            int numBytes = 1*array.Count;
            int numPaddedBytes = ((numBytes + 7)/8)*8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i] ? (byte) 1 : (byte) 0);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte) 0);
            }
        }

        /// <summary>
        /// Write a named int array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<int> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.INT32, 4);
            Write(MatType.INT32);
            int numBytes = 4*array.Count;
            int numPaddedBytes = ((numBytes + 7)/8)*8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte) 0);
            }
        }

        /// <summary>
        /// Write a named int array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<uint> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT32, 4);
            Write(MatType.UINT32);
            int numBytes = 4 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named long array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<long> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.INT64, 8);
            Write(MatType.INT64);
            int numBytes = 8 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named ulong array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<ulong> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT64, 8);
            Write(MatType.UINT64);
            int numBytes = 8 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named scalar to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, double value)
        {
            Write(name, new double[] {value});
        }

        /// <summary>
        /// Write a named vector to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<double> array)
        {
            Matrix m = new Matrix(array.Count, 1);
            for (int i = 0; i < array.Count; i++)
            {
                m[i, 0] = array[i];
            }
            Write(name, m);
        }

        /// <summary>
        /// Write a named cell vector to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write<T>(string name, IReadOnlyList<T> array)
        {
            object[,] m = new object[array.Count,1];
            for (int i = 0; i < array.Count; i++)
            {
                m[i, 0] = array[i];
            }
            Write(name, m);
        }

        /// <summary>
        /// Write a named Matrix to the stream
        /// </summary>
        /// <param name="name">Name of the matrix.</param>
        /// <param name="matrix">A matrix.</param>
        /// <param name="imaginary">If writing a complex matrix, the imaginary part of the matrix.</param>
        public void Write(string name, Matrix matrix, Matrix imaginary = null)
        {
            WriteMatrixHeader(name, matrix.Rows, matrix.Cols, mxClass.DOUBLE, 8, imaginary != null);

            // write the matrix data
            Write(matrix);
            if (imaginary != null) Write(imaginary);
        }

        protected void WriteMatrixHeader(string name, int rows, int cols, mxClass dataClass, int elementSize, bool isComplex = false, bool isLogical = false)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            int numNameBytes = ((name.Length + 7)/8)*8;

            // compute total size of buffer
            int numericBytes = 8 + elementSize*rows*cols;
            numericBytes = ((numericBytes + 7)/8)*8;
            int numBytes = 48 + numNameBytes + numericBytes;
            if (isComplex) numBytes += numericBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int flags = (int) dataClass;
            if (isComplex) flags |= 0x0800;
            if (isLogical) flags |= 0x0200;
            Write(flags);
            Write(0);

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(rows); // number of rows
            Write(cols); // number of columns

            // write the matrix name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);
        }

        protected void Write(Matrix matrix)
        {
            Write(MatType.DOUBLE);
            Write(8*matrix.Rows*matrix.Cols); // bytes to follow
            for (int i = 0; i < matrix.Cols; i++)
                for (int j = 0; j < matrix.Rows; j++)
                    Write(matrix[j, i]);
        }

        /// <summary>
        /// Write a named ComplexMatrix to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="matrix"></param>
        public void Write(string name, MatlabReader.ComplexMatrix matrix)
        {
            Write(name, matrix.Real, matrix.Imaginary);
        }

        public static void WriteFromCsvFolder(string outputFilename, string inputFolder)
        {
            using (var writer = new MatlabWriter(outputFilename))
            {
                foreach (var filename in Directory.EnumerateFiles(inputFolder, "*.csv"))
                {
                    // EnumerateFiles may return files that don't exactly match the given searchPattern
                    if (Path.GetExtension(filename) != ".csv") continue;
                    string name = Path.GetFileNameWithoutExtension(filename);
                    writer.WriteFromCsv(name, filename);
                }
            }
        }

        /// <summary>
        /// Write a named struct whose fields are the columns of a csv file
        /// </summary>
        /// <param name="name"></param>
        /// <param name="path"></param>
        public void WriteFromCsv(string name, string path)
        {
            Dictionary<string,List<string>> dict = MatlabReader.ReadCsv(path);
            // try to convert strings into numbers
            Dictionary<string, object> dict2 = new Dictionary<string, object>();
            foreach (var entry in dict)
            {
                bool isDouble = true;
                List<double> doubles = new List<double>();
                foreach (string s in entry.Value)
                {
                    double d;
                    if (s.Length == 0)
                    {
                        d = double.NaN;
                        doubles.Add(d);
                    }
                    else if (double.TryParse(s, out d)) doubles.Add(d);
                    else
                    {
                        isDouble = false;
                        break;
                    }
                }
                if (isDouble) dict2.Add(entry.Key, doubles);
                else dict2.Add(entry.Key, entry.Value);
            }
            Write(name, dict2);
        }

        /// <summary>
        /// Write a named struct to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="dict"></param>
        public void Write<T>(string name, IReadOnlyDictionary<string, T> dict)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7)/8)*8;

            // precompute the field bytes
            int numDataBytes = 0;
            Dictionary<string, byte[]> bytes = new Dictionary<string, byte[]>();
            Stream oldWriter = writer;
            try
            {
                foreach (var entry in dict)
                {
                    MemoryStream ms = new MemoryStream(128);
                    writer = ms;
                    Write("", entry.Value);
                    byte[] valueBytes = ms.ToArray();
                    bytes[entry.Key] = valueBytes;
                    numDataBytes += valueBytes.Length;
                }
            }
            finally
            {
                writer = oldWriter;
            }

            // compute total size of buffer
            const int fieldNameLimit = 64;
            int maxFieldNameLength = 0;
            foreach (var key in dict.Keys)
            {
                maxFieldNameLength = System.Math.Max(maxFieldNameLength, key.Length);
            }
            // add 1 byte for the null terminator
            maxFieldNameLength++;
            maxFieldNameLength = System.Math.Min(maxFieldNameLength, fieldNameLimit);
            // round up to multiple of 8 bytes
            maxFieldNameLength = ((maxFieldNameLength + 7)/8)*8;
            //maxFieldNameLength = fieldNameLimit;
            int numFieldNameBytes = maxFieldNameLength * dict.Count;
            int numBytes = 48 + numNameBytes + 16 + numFieldNameBytes + numDataBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int dataClass = (int) mxClass.STRUCT;
            Write(dataClass);
            Write(0); // reserved

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(1); // number of rows
            Write(1); // number of columns

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of (padded) name in bytes
            Write(name, numNameBytes);

            // write the field name length
            Write((int) MatType.INT32 | (4 << 16));
            Write(maxFieldNameLength);

            // write the field names
            Write(MatType.INT8);
            Write(numFieldNameBytes);
            foreach (var entry in dict)
            {
                string truncatedKey = entry.Key;
                if (entry.Key.Length >= maxFieldNameLength)
                {
                    truncatedKey = entry.Key.Substring(0, maxFieldNameLength - 1);
                    Console.WriteLine(string.Format("dictionary key '{0}' exceeds the MATLAB maximum name length of {1} characters and will be truncated to '{2}'", 
                        entry.Key, (maxFieldNameLength - 1), truncatedKey));
                }
                Write(truncatedKey, maxFieldNameLength);
            }

            // write the field values
            foreach (var entry in dict)
            {
                Write(bytes[entry.Key]);
            }
        }

        private static mxClass GetDataClass(Type type)
        {
            if (type.Equals(typeof(object))) return mxClass.CELL;
            else if (type.Equals(typeof(double))) return mxClass.DOUBLE;
            else if (type.Equals(typeof(Single))) return mxClass.SINGLE;
            else if (type.Equals(typeof(byte)))
                return mxClass.INT8;
            else if (type.Equals(typeof(short)))
                return mxClass.INT16;
            else if (type.Equals(typeof(ushort)))
                return mxClass.UINT16;
            else if (type.Equals(typeof(int)))
                return mxClass.INT32;
            else if (type.Equals(typeof(uint)))
                return mxClass.UINT32;
            else if (type.Equals(typeof(long)))
                return mxClass.INT64;
            else if (type.Equals(typeof(ulong)))
                return mxClass.UINT64;
            else
                throw new NotSupportedException("type " + StringUtil.TypeToString(type) + " not supported");
        }

        private static MatType GetElementClass(Type type)
        {
            if (type.Equals(typeof(double))) return MatType.DOUBLE;
            else if (type.Equals(typeof(Single))) return MatType.SINGLE;
            else if (type.Equals(typeof(byte)))
                return MatType.INT8;
            else if (type.Equals(typeof(short)))
                return MatType.INT16;
            else if (type.Equals(typeof(ushort)))
                return MatType.UINT16;
            else if (type.Equals(typeof(int)))
                return MatType.INT32;
            else if (type.Equals(typeof(uint)))
                return MatType.UINT32;
            else if (type.Equals(typeof(long)))
                return MatType.INT64;
            else if (type.Equals(typeof(ulong)))
                return MatType.UINT64;
            else
                throw new NotSupportedException("type " + StringUtil.TypeToString(type) + " not supported");
        }

        /// <summary>
        /// Write a named array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void WriteArray(string name, Array array)
        {
            Type eltType = array.GetType().GetElementType();
            mxClass dataClass = GetDataClass(eltType);

            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7) / 8) * 8;

            // precompute the cell bytes
            int numDataBytes = 0;
            int numDims = array.Rank;
            int numElts = array.Length;
            int[] sizes = new int[numDims];
            for (int i = 0; i < numDims; i++)
            {
                sizes[i] = array.GetLength(i);
            }
            MatlabReader.Reverse(sizes);
            int[] strides = StringUtil.ArrayStrides(sizes);
            MatlabReader.Reverse(sizes);
            int[] index = new int[numDims];
            List<byte[]> bytes = new List<byte[]>();
            Stream oldWriter = writer;
            try
            {
                for (int i = 0; i < numElts; i++)
                {
                    StringUtil.LinearIndexToMultidimensionalIndex(i, strides, index);
                    MatlabReader.Reverse(index);
                    object cell = array.GetValue(index);
                    MemoryStream ms = new MemoryStream(128);
                    writer = ms;
                    if (dataClass == mxClass.CELL) Write("", cell);
                    else if (dataClass == mxClass.DOUBLE) Write((double)cell);
                    else if (dataClass == mxClass.SINGLE) Write((Single)cell);
                    else if (dataClass == mxClass.INT8) Write((byte)cell);
                    else if (dataClass == mxClass.INT16) Write((short)cell);
                    else if (dataClass == mxClass.UINT16) Write((ushort)cell);
                    else if (dataClass == mxClass.INT32) Write((int)cell);
                    else if (dataClass == mxClass.UINT32) Write((uint)cell);
                    else if (dataClass == mxClass.INT64) Write((long)cell);
                    else if (dataClass == mxClass.UINT64) Write((ulong)cell);
                    else throw new NotImplementedException(dataClass.ToString());
                    byte[] valueBytes = ms.ToArray();
                    bytes.Add(valueBytes);
                    numDataBytes += valueBytes.Length;
                }
            }
            finally
            {
                writer = oldWriter;
            }

            // compute total size of buffer
            int sizeBytes = numDims * 4;
            if (numDims % 2 == 1) sizeBytes += 4;
            int numBytes = 32 + sizeBytes + numNameBytes + numDataBytes;
            if (dataClass != mxClass.CELL) numBytes += 8;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            Write((int)dataClass);
            Write(0); // reserved

            // write the dimension field
            Write(MatType.INT32);
            if (numDims == 1)
            {
                Write(8); // 8 bytes to follow
                Write(sizes[0]);
                Write(1);
            }
            else
            {
                Write(numDims * 4);
                for (int i = 0; i < numDims; i++)
                {
                    Write(sizes[i]);
                }
                if (numDims % 2 == 1) Write(0);
            }

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);

            if (dataClass != mxClass.CELL)
            {
                MatType elementClass = GetElementClass(eltType);
                Write((int)elementClass);
                Write(numDataBytes);
            }
            // write the cell values
            for (int i = 0; i < bytes.Count; i++)
            {
                Write(bytes[i]);
            }
        }

        /// <summary>
        /// Write a named cell array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, object[,] array)
        {
            WriteArray(name, array);
        }

        /// <summary>
        /// Write a named string to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, string value)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7)/8)*8;

            // pad the data to an 8-byte boundary
            int numDataBytes = ((value.Length + 7)/8)*8;

            // compute total size of buffer
            int numBytes = 48 + numNameBytes + 8 + numDataBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int dataClass = (int) mxClass.CHAR;
            Write(dataClass);
            Write(0);

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(1); // number of rows
            Write(value.Length); // number of columns

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);

            // write the string
            Write(MatType.UTF8);
            Write(value.Length); // bytes to follow
            Write(value, numDataBytes);
        }

        /// <summary>
        /// Converts a variable name to a valid variable name by changing all invalid characters to an underscore.
        /// </summary>
        /// <param name="name">Variable name</param>
        /// <returns>A valid MATLAB variable name.</returns>
        private static string MakeValidVariableName(string name)
        {
            string result = "";

            for (int i = 0; i < name.Length; i++)
                if (!Char.IsDigit(name[i]) && !Char.IsLetter(name[i]))
                    result += '_';
                else
                    result += name[i];

            return result;
        }

        /// <summary>
        /// Generate a Matlab V5 compatible header byte array
        /// </summary>
        /// <param name="comments">The comments that will go into the header of the Matlab file.</param>
        /// <returns>The header as a byte array.</returns>
        protected static byte[] Matlab5Header(string comments)
        {
            byte[] header = new byte[128];

            if (comments.Length > 124)
                comments = comments.Substring(0, 124);
            else
                comments = comments.PadRight(124);
            for (int i = 0; i < comments.Length; i++)
                header[i] = (byte) comments[i];
            header[124] = 0x00;
            header[125] = 0x01;
            header[126] = (byte) 'I';
            header[127] = (byte) 'M';

            return header;
        }

        /// <summary>
        /// Release the stream used by a MatlabWriter
        /// </summary>
        public void Dispose()
        {
            writer.Dispose();
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// A number type in a MAT file
    /// </summary>
    public enum MatType
    {
        INT8 = 1,
        UINT8 = 2,
        INT16 = 3,
        UINT16 = 4,
        INT32 = 5,
        UINT32 = 6,
        SINGLE = 7,
        DOUBLE = 9,
        INT64 = 12,
        UINT64 = 13,
        MATRIX = 14,
        COMPRESSED = 15,
        UTF8 = 16,
        UTF16 = 17,
        UTF32 = 18
    }

    /// <summary>
    /// An object class in a MAT file
    /// </summary>
    public enum mxClass
    {
        CELL = 1,
        STRUCT = 2,
        OBJECT = 3,
        CHAR = 4,
        SPARSE = 5,
        DOUBLE = 6,
        SINGLE = 7,
        INT8 = 8,
        UINT8 = 9,
        INT16 = 10,
        UINT16 = 11,
        INT32 = 12,
        UINT32 = 13,
        INT64 = 14,
        UINT64 = 15
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;

namespace Microsoft.ML.Probabilistic.Serialization
{
    /// <summary>
    /// Write data objects to a MAT file
    /// </summary>
    /// <remarks>
    /// The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
    /// </remarks>
    public class MatlabWriter : IDisposable
    {
        private Stream writer;

        /// <summary>
        /// Create a MatlabWriter to write to a given file name.
        /// </summary>
        /// <param name="fileName">The file name to write to (will be created if missing, or truncated if already exists)</param>
        public MatlabWriter(string fileName)
        {
            writer = new FileStream(fileName, FileMode.Create);
            Write(Matlab5Header("MATLAB 5.0 MAT-file, Created by Microsoft.ML.Probabilistic.Utililies.MatlabWriter"));
        }

        /// <summary>
        /// Write an array of bytes to the stream
        /// </summary>
        /// <param name="bytes"></param>
        protected void Write(byte[] bytes)
        {
            writer.Write(bytes, 0, bytes.Length);
        }

        protected void Write(MatType type)
        {
            Write((int) type);
        }

        protected void Write(short value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(ushort value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(int value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(uint value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(long value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(ulong value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(double value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(Single value)
        {
            Write(BitConverter.GetBytes(value));
        }

        protected void Write(byte value)
        {
            writer.WriteByte(value);
        }

        /// <summary>
        /// Write a string value with zero padding to write numBytes in total.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="numBytes"></param>
        protected void Write(string value, int numBytes)
        {
            for (int i = 0; i < value.Length; i++)
            {
                writer.WriteByte((byte) value[i]);
            }
            for (int i = value.Length; i < numBytes; i++)
            {
                writer.WriteByte(0);
            }
        }

        /// <summary>
        /// Write a named object to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, object value)
        {
            if (value is Matrix matrix) Write(name, matrix);
            else if (value is bool) Write(name, (bool)value ? (byte)1 : (byte)0);
            else if (value is byte b) Write(name, b);
            else if (value is short sh) Write(name, sh);
            else if (value is ushort us) Write(name, us);
            else if (value is int i) Write(name, i);
            else if (value is uint ui) Write(name, ui);
            else if (value is long l) Write(name, l);
            else if (value is ulong ul) Write(name, ul);
            else if (value is Single single) Write(name, single);
            else if (value is double d) Write(name, d);
            else if (value is MatlabReader.ComplexMatrix complexMatrix) Write(name, complexMatrix);
            else if (value is string s) Write(name, s);
            else if (value is object[, ] objects) Write(name, objects);
            else if (value is IReadOnlyList<bool> bools) Write(name, bools);
            else if (value is IReadOnlyList<int> ints) Write(name, ints);
            else if (value is IReadOnlyList<uint> uints) Write(name, uints);
            else if (value is IReadOnlyList<long> longs) Write(name, longs);
            else if (value is IReadOnlyList<double> doubles) Write(name, doubles);
            else if (value is IReadOnlyList<object> objects) Write<object>(name, objects);
            else if (value is IReadOnlyList<string> strings) Write<string>(name, strings);
            else if (value is Array array) WriteArray(name, array);
            else if (ReferenceEquals(value, null))
            {
                Write(MatType.MATRIX);
                Write(0);
            }
            else if (value is IReadOnlyDictionary<string, object> strings) Write(name, strings);
            else if (TryWriteDictionary(name, value)) return;
            else throw new NotImplementedException("Cannot write type " + StringUtil.TypeToString(value.GetType()));
        }

        protected bool TryWriteDictionary(string name, object value)
        {
            Type type = value.GetType();
            foreach(Type interfaceType in type.GetInterfaces()) {
                if (interfaceType.Name == typeof(IReadOnlyDictionary<,>).Name)
                {
                    Type[] args = interfaceType.GetGenericArguments();
                    if (args[0].Equals(typeof(string)))
                    {
                        var method = new Action<string, IReadOnlyDictionary<string, object>>(Write).Method;
                        method = method.GetGenericMethodDefinition();
                        Util.Invoke(method.MakeGenericMethod(args[1]), this, name, value);
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Write a named bool array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<bool> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT8, 1, false, true);
            Write(MatType.UINT8);
            int numBytes = 1*array.Count;
            int numPaddedBytes = ((numBytes + 7)/8)*8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i] ? (byte) 1 : (byte) 0);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte) 0);
            }
        }

        /// <summary>
        /// Write a named int array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<int> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.INT32, 4);
            Write(MatType.INT32);
            int numBytes = 4*array.Count;
            int numPaddedBytes = ((numBytes + 7)/8)*8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte) 0);
            }
        }

        /// <summary>
        /// Write a named int array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<uint> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT32, 4);
            Write(MatType.UINT32);
            int numBytes = 4 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named long array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<long> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.INT64, 8);
            Write(MatType.INT64);
            int numBytes = 8 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named ulong array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<ulong> array)
        {
            WriteMatrixHeader(name, array.Count, 1, mxClass.UINT64, 8);
            Write(MatType.UINT64);
            int numBytes = 8 * array.Count;
            int numPaddedBytes = ((numBytes + 7) / 8) * 8;
            Write(numBytes); // bytes to follow
            for (int i = 0; i < array.Count; i++)
                Write(array[i]);
            int padding = numPaddedBytes - numBytes;
            for (int i = 0; i < padding; i++)
            {
                Write((byte)0);
            }
        }

        /// <summary>
        /// Write a named scalar to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, double value)
        {
            Write(name, new double[] {value});
        }

        /// <summary>
        /// Write a named vector to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, IReadOnlyList<double> array)
        {
            Matrix m = new Matrix(array.Count, 1);
            for (int i = 0; i < array.Count; i++)
            {
                m[i, 0] = array[i];
            }
            Write(name, m);
        }

        /// <summary>
        /// Write a named cell vector to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write<T>(string name, IReadOnlyList<T> array)
        {
            object[,] m = new object[array.Count,1];
            for (int i = 0; i < array.Count; i++)
            {
                m[i, 0] = array[i];
            }
            Write(name, m);
        }

        /// <summary>
        /// Write a named Matrix to the stream
        /// </summary>
        /// <param name="name">Name of the matrix.</param>
        /// <param name="matrix">A matrix.</param>
        /// <param name="imaginary">If writing a complex matrix, the imaginary part of the matrix.</param>
        public void Write(string name, Matrix matrix, Matrix imaginary = null)
        {
            WriteMatrixHeader(name, matrix.Rows, matrix.Cols, mxClass.DOUBLE, 8, imaginary != null);

            // write the matrix data
            Write(matrix);
            if (imaginary != null) Write(imaginary);
        }

        protected void WriteMatrixHeader(string name, int rows, int cols, mxClass dataClass, int elementSize, bool isComplex = false, bool isLogical = false)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            int numNameBytes = ((name.Length + 7)/8)*8;

            // compute total size of buffer
            int numericBytes = 8 + elementSize*rows*cols;
            numericBytes = ((numericBytes + 7)/8)*8;
            int numBytes = 48 + numNameBytes + numericBytes;
            if (isComplex) numBytes += numericBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int flags = (int) dataClass;
            if (isComplex) flags |= 0x0800;
            if (isLogical) flags |= 0x0200;
            Write(flags);
            Write(0);

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(rows); // number of rows
            Write(cols); // number of columns

            // write the matrix name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);
        }

        protected void Write(Matrix matrix)
        {
            Write(MatType.DOUBLE);
            Write(8*matrix.Rows*matrix.Cols); // bytes to follow
            for (int i = 0; i < matrix.Cols; i++)
                for (int j = 0; j < matrix.Rows; j++)
                    Write(matrix[j, i]);
        }

        /// <summary>
        /// Write a named ComplexMatrix to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="matrix"></param>
        public void Write(string name, MatlabReader.ComplexMatrix matrix)
        {
            Write(name, matrix.Real, matrix.Imaginary);
        }

        public static void WriteFromCsvFolder(string outputFilename, string inputFolder)
        {
            using (var writer = new MatlabWriter(outputFilename))
            {
                foreach (var filename in Directory.EnumerateFiles(inputFolder, "*.csv"))
                {
                    // EnumerateFiles may return files that don't exactly match the given searchPattern
                    if (Path.GetExtension(filename) != ".csv") continue;
                    string name = Path.GetFileNameWithoutExtension(filename);
                    writer.WriteFromCsv(name, filename);
                }
            }
        }

        /// <summary>
        /// Write a named struct whose fields are the columns of a csv file
        /// </summary>
        /// <param name="name"></param>
        /// <param name="path"></param>
        public void WriteFromCsv(string name, string path)
        {
            Dictionary<string,List<string>> dict = MatlabReader.ReadCsv(path);
            // try to convert strings into numbers
            Dictionary<string, object> dict2 = new Dictionary<string, object>();
            foreach (var entry in dict)
            {
                bool isDouble = true;
                List<double> doubles = new List<double>();
                foreach (string s in entry.Value)
                {
                    double d;
                    if (s.Length == 0)
                    {
                        d = double.NaN;
                        doubles.Add(d);
                    }
                    else if (double.TryParse(s, out d)) doubles.Add(d);
                    else
                    {
                        isDouble = false;
                        break;
                    }
                }
                if (isDouble) dict2.Add(entry.Key, doubles);
                else dict2.Add(entry.Key, entry.Value);
            }
            Write(name, dict2);
        }

        /// <summary>
        /// Write a named struct to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="dict"></param>
        public void Write<T>(string name, IReadOnlyDictionary<string, T> dict)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7)/8)*8;

            // precompute the field bytes
            int numDataBytes = 0;
            Dictionary<string, byte[]> bytes = new Dictionary<string, byte[]>();
            Stream oldWriter = writer;
            try
            {
                foreach (var entry in dict)
                {
                    MemoryStream ms = new MemoryStream(128);
                    writer = ms;
                    Write("", entry.Value);
                    byte[] valueBytes = ms.ToArray();
                    bytes[entry.Key] = valueBytes;
                    numDataBytes += valueBytes.Length;
                }
            }
            finally
            {
                writer = oldWriter;
            }

            // compute total size of buffer
            const int fieldNameLimit = 64;
            int maxFieldNameLength = 0;
            foreach (var key in dict.Keys)
            {
                maxFieldNameLength = System.Math.Max(maxFieldNameLength, key.Length);
            }
            // add 1 byte for the null terminator
            maxFieldNameLength++;
            maxFieldNameLength = System.Math.Min(maxFieldNameLength, fieldNameLimit);
            // round up to multiple of 8 bytes
            maxFieldNameLength = ((maxFieldNameLength + 7)/8)*8;
            //maxFieldNameLength = fieldNameLimit;
            int numFieldNameBytes = maxFieldNameLength * dict.Count;
            int numBytes = 48 + numNameBytes + 16 + numFieldNameBytes + numDataBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int dataClass = (int) mxClass.STRUCT;
            Write(dataClass);
            Write(0); // reserved

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(1); // number of rows
            Write(1); // number of columns

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of (padded) name in bytes
            Write(name, numNameBytes);

            // write the field name length
            Write((int) MatType.INT32 | (4 << 16));
            Write(maxFieldNameLength);

            // write the field names
            Write(MatType.INT8);
            Write(numFieldNameBytes);
            foreach (var entry in dict)
            {
                string truncatedKey = entry.Key;
                if (entry.Key.Length >= maxFieldNameLength)
                {
                    truncatedKey = entry.Key.Substring(0, maxFieldNameLength - 1);
                    Console.WriteLine(string.Format("dictionary key '{0}' exceeds the MATLAB maximum name length of {1} characters and will be truncated to '{2}'", 
                        entry.Key, (maxFieldNameLength - 1), truncatedKey));
                }
                Write(truncatedKey, maxFieldNameLength);
            }

            // write the field values
            foreach (var entry in dict)
            {
                Write(bytes[entry.Key]);
            }
        }

        private static mxClass GetDataClass(Type type)
        {
            if (type.Equals(typeof(object))) return mxClass.CELL;
            else if (type.Equals(typeof(double))) return mxClass.DOUBLE;
            else if (type.Equals(typeof(Single))) return mxClass.SINGLE;
            else if (type.Equals(typeof(byte)))
                return mxClass.INT8;
            else if (type.Equals(typeof(short)))
                return mxClass.INT16;
            else if (type.Equals(typeof(ushort)))
                return mxClass.UINT16;
            else if (type.Equals(typeof(int)))
                return mxClass.INT32;
            else if (type.Equals(typeof(uint)))
                return mxClass.UINT32;
            else if (type.Equals(typeof(long)))
                return mxClass.INT64;
            else if (type.Equals(typeof(ulong)))
                return mxClass.UINT64;
            else
                throw new NotSupportedException("type " + StringUtil.TypeToString(type) + " not supported");
        }

        private static MatType GetElementClass(Type type)
        {
            if (type.Equals(typeof(double))) return MatType.DOUBLE;
            else if (type.Equals(typeof(Single))) return MatType.SINGLE;
            else if (type.Equals(typeof(byte)))
                return MatType.INT8;
            else if (type.Equals(typeof(short)))
                return MatType.INT16;
            else if (type.Equals(typeof(ushort)))
                return MatType.UINT16;
            else if (type.Equals(typeof(int)))
                return MatType.INT32;
            else if (type.Equals(typeof(uint)))
                return MatType.UINT32;
            else if (type.Equals(typeof(long)))
                return MatType.INT64;
            else if (type.Equals(typeof(ulong)))
                return MatType.UINT64;
            else
                throw new NotSupportedException("type " + StringUtil.TypeToString(type) + " not supported");
        }

        /// <summary>
        /// Write a named array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void WriteArray(string name, Array array)
        {
            Type eltType = array.GetType().GetElementType();
            mxClass dataClass = GetDataClass(eltType);

            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7) / 8) * 8;

            // precompute the cell bytes
            int numDataBytes = 0;
            int numDims = array.Rank;
            int numElts = array.Length;
            int[] sizes = new int[numDims];
            for (int i = 0; i < numDims; i++)
            {
                sizes[i] = array.GetLength(i);
            }
            MatlabReader.Reverse(sizes);
            int[] strides = StringUtil.ArrayStrides(sizes);
            MatlabReader.Reverse(sizes);
            int[] index = new int[numDims];
            List<byte[]> bytes = new List<byte[]>();
            Stream oldWriter = writer;
            try
            {
                for (int i = 0; i < numElts; i++)
                {
                    StringUtil.LinearIndexToMultidimensionalIndex(i, strides, index);
                    MatlabReader.Reverse(index);
                    object cell = array.GetValue(index);
                    MemoryStream ms = new MemoryStream(128);
                    writer = ms;
                    if (dataClass == mxClass.CELL) Write("", cell);
                    else if (dataClass == mxClass.DOUBLE) Write((double)cell);
                    else if (dataClass == mxClass.SINGLE) Write((Single)cell);
                    else if (dataClass == mxClass.INT8) Write((byte)cell);
                    else if (dataClass == mxClass.INT16) Write((short)cell);
                    else if (dataClass == mxClass.UINT16) Write((ushort)cell);
                    else if (dataClass == mxClass.INT32) Write((int)cell);
                    else if (dataClass == mxClass.UINT32) Write((uint)cell);
                    else if (dataClass == mxClass.INT64) Write((long)cell);
                    else if (dataClass == mxClass.UINT64) Write((ulong)cell);
                    else throw new NotImplementedException(dataClass.ToString());
                    byte[] valueBytes = ms.ToArray();
                    bytes.Add(valueBytes);
                    numDataBytes += valueBytes.Length;
                }
            }
            finally
            {
                writer = oldWriter;
            }

            // compute total size of buffer
            int sizeBytes = numDims * 4;
            if (numDims % 2 == 1) sizeBytes += 4;
            int numBytes = 32 + sizeBytes + numNameBytes + numDataBytes;
            if (dataClass != mxClass.CELL) numBytes += 8;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            Write((int)dataClass);
            Write(0); // reserved

            // write the dimension field
            Write(MatType.INT32);
            if (numDims == 1)
            {
                Write(8); // 8 bytes to follow
                Write(sizes[0]);
                Write(1);
            }
            else
            {
                Write(numDims * 4);
                for (int i = 0; i < numDims; i++)
                {
                    Write(sizes[i]);
                }
                if (numDims % 2 == 1) Write(0);
            }

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);

            if (dataClass != mxClass.CELL)
            {
                MatType elementClass = GetElementClass(eltType);
                Write((int)elementClass);
                Write(numDataBytes);
            }
            // write the cell values
            for (int i = 0; i < bytes.Count; i++)
            {
                Write(bytes[i]);
            }
        }

        /// <summary>
        /// Write a named cell array to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="array"></param>
        public void Write(string name, object[,] array)
        {
            WriteArray(name, array);
        }

        /// <summary>
        /// Write a named string to the stream
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void Write(string name, string value)
        {
            // convert to a valid variable name
            name = MakeValidVariableName(name);

            // pad the name to an 8-byte boundary
            int numNameBytes = ((name.Length + 7)/8)*8;

            // pad the data to an 8-byte boundary
            int numDataBytes = ((value.Length + 7)/8)*8;

            // compute total size of buffer
            int numBytes = 48 + numNameBytes + 8 + numDataBytes;

            // write the data type field
            Write(MatType.MATRIX);
            Write(numBytes - 8); // number of bytes 

            // write the array flags
            Write(MatType.UINT32);
            Write(8); // 8 bytes to follow
            int dataClass = (int) mxClass.CHAR;
            Write(dataClass);
            Write(0);

            // write the dimension field
            Write(MatType.INT32);
            Write(8); // 8 bytes to follow
            Write(1); // number of rows
            Write(value.Length); // number of columns

            // write the name
            Write(MatType.INT8);
            Write(name.Length); // length of name in bytes
            Write(name, numNameBytes);

            // write the string
            Write(MatType.UTF8);
            Write(value.Length); // bytes to follow
            Write(value, numDataBytes);
        }

        /// <summary>
        /// Converts a variable name to a valid variable name by changing all invalid characters to an underscore.
        /// </summary>
        /// <param name="name">Variable name</param>
        /// <returns>A valid MATLAB variable name.</returns>
        private static string MakeValidVariableName(string name)
        {
            string result = "";

            for (int i = 0; i < name.Length; i++)
                if (!Char.IsDigit(name[i]) && !Char.IsLetter(name[i]))
                    result += '_';
                else
                    result += name[i];

            return result;
        }

        /// <summary>
        /// Generate a Matlab V5 compatible header byte array
        /// </summary>
        /// <param name="comments">The comments that will go into the header of the Matlab file.</param>
        /// <returns>The header as a byte array.</returns>
        protected static byte[] Matlab5Header(string comments)
        {
            byte[] header = new byte[128];

            if (comments.Length > 124)
                comments = comments.Substring(0, 124);
            else
                comments = comments.PadRight(124);
            for (int i = 0; i < comments.Length; i++)
                header[i] = (byte) comments[i];
            header[124] = 0x00;
            header[125] = 0x01;
            header[126] = (byte) 'I';
            header[127] = (byte) 'M';

            return header;
        }

        /// <summary>
        /// Release the stream used by a MatlabWriter
        /// </summary>
        public void Dispose()
        {
            writer.Dispose();
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// A number type in a MAT file
    /// </summary>
    public enum MatType
    {
        INT8 = 1,
        UINT8 = 2,
        INT16 = 3,
        UINT16 = 4,
        INT32 = 5,
        UINT32 = 6,
        SINGLE = 7,
        DOUBLE = 9,
        INT64 = 12,
        UINT64 = 13,
        MATRIX = 14,
        COMPRESSED = 15,
        UTF8 = 16,
        UTF16 = 17,
        UTF32 = 18
    }

    /// <summary>
    /// An object class in a MAT file
    /// </summary>
    public enum mxClass
    {
        CELL = 1,
        STRUCT = 2,
        OBJECT = 3,
        CHAR = 4,
        SPARSE = 5,
        DOUBLE = 6,
        SINGLE = 7,
        INT8 = 8,
        UINT8 = 9,
        INT16 = 10,
        UINT16 = 11,
        INT32 = 12,
        UINT32 = 13,
        INT64 = 14,
        UINT64 = 15
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Runtime\Core\Serialization\MatlabWriter.cs(135,53): error CS0136: A local or parameter named 'objects' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Runtime\Core\Serialization\MatlabWriter.cs(143,67): error CS0136: A local or parameter named 'strings' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Compiler\Infer\Models\ModelBuilder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler;
using System.Reflection;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Models.Attributes;
using Microsoft.ML.Probabilistic.Factors;

namespace Microsoft.ML.Probabilistic.Models
{
    /// <summary>
    /// Builds an MSL model from an in-memory graph of model expression objects.
    /// </summary>
    internal class ModelBuilder
    {
        /// <summary>
        /// Helps build class declarations
        /// </summary>
        private static CodeBuilder Builder = CodeBuilder.Instance;

        public ITypeDeclaration modelType;
        public AttributeRegistry<object, ICompilerAttribute> Attributes;
        private Stack<IModelExpression> toSearch = new Stack<IModelExpression>();
        private Set<IModelExpression> searched = new Set<IModelExpression>(ReferenceEqualityComparer<IModelExpression>.Instance);

        /// <summary>
        /// The set of condition variables used in 'IfNot' blocks.  Filled in during search.
        /// </summary>
        private Set<Variable> negatedConditionVariables = new Set<Variable>(ReferenceEqualityComparer<Variable>.Instance);

        // optimizes ModelBuilder.Compile
        internal List<Variable> observedVars = new List<Variable>();
        internal Set<IVariable> variablesToInfer = new Set<IVariable>(ReferenceEqualityComparer<IVariable>.Instance);

        protected IMethodDeclaration modelMethod;
        protected Stack<IList<IStatement>> blockStack;
        protected bool inferOnlySpecifiedVars = false;

        /// <summary>
        /// Mapping from constant values to their declarations in the generated code.
        /// </summary>
        protected Dictionary<object, IVariableDeclaration> constants = new Dictionary<object, IVariableDeclaration>();

        internal IReadOnlyCollection<IModelExpression> ModelExpressions { get; private set; }

        /// <summary>
        /// The default namespace for generated code.
        /// This should not be a child of any existing namespace, such as Microsoft.ML.Probabilistic, because of possible name conflicts.
        /// </summary>
        public const string ModelNamespace = "Models";

        public void Reset()
        {
            modelType = Builder.TypeDecl();
            modelType.Namespace = ModelNamespace;
            modelType.Owner = null;
            modelType.BaseType = null;
            modelType.Visibility = TypeVisibility.Public;
            modelMethod = Builder.MethodDecl(MethodVisibility.Public, "Model", typeof(void), modelType);
            IBlockStatement body = Builder.BlockStmt();
            modelMethod.Body = body;
            //blocks = new List<IList<IStatement>>();
            blockStack = new Stack<IList<IStatement>>();
            blockStack.Push(body.Statements);
            modelType.Methods.Add(modelMethod);
            Attributes = new AttributeRegistry<object, ICompilerAttribute>(true);
            searched.Clear();
            observedVars.Clear();
            variablesToInfer.Clear();
            constants.Clear();
            ModelExpressions = null;
        }

        /// <summary>
        /// Builds the model necessary to infer marginals for the supplied variables and algorithm.
        /// </summary>
        /// <param name="engine">The inference algorithm being used</param>
        /// <param name="inferOnlySpecifiedVars">If true, inference will be restricted to only the variables given.</param>
        /// <param name="vars">Variables to infer.</param>
        /// <returns></returns>
        /// <remarks>
        /// Algorithm: starting from the variables to infer, we search through the graph to build up a "searched set".
        /// Each Variable and MethodInvoke in this set has an associated timestamp.
        /// We sort by timestamp, and then generate code.
        /// </remarks>
        public ITypeDeclaration Build(InferenceEngine engine, bool inferOnlySpecifiedVars, IEnumerable<IVariable> vars)
        {
            List<IStatementBlock> openBlocks = StatementBlock.GetOpenBlocks();
            if (openBlocks.Count > 0)
            {
                throw new InvalidOperationException("The block " + openBlocks[0] + " has not been closed.");
            }
            Reset();
            this.inferOnlySpecifiedVars = inferOnlySpecifiedVars;
            variablesToInfer.AddRange(vars);
            foreach (IVariable var in vars) toSearch.Push(var);
            while (toSearch.Count > 0)
            {
                IModelExpression expr = toSearch.Pop();
                SearchExpressionUntyped(expr);
            }
            // lock in the set of model expressions.
            ModelExpressions = new List<IModelExpression>(searched);
            List<int> timestamps = new List<int>();
            List<IModelExpression> exprs = new List<IModelExpression>();
            foreach (IModelExpression expr in ModelExpressions)
            {
                if (expr is Variable var)
                {
                    exprs.Add(var);
                    timestamps.Add(var.timestamp);
                }
                else if (expr is MethodInvoke mi)
                {
                    exprs.Add(mi);
                    timestamps.Add(mi.timestamp);
                }
            }
            Collection.Sort(timestamps, exprs);
            foreach (IModelExpression expr in exprs)
            {
                BuildExpressionUntyped(expr);
            }
            foreach (IModelExpression expr in exprs)
            {
                FinishExpressionUntyped(expr, engine.Algorithm);
            }
            return modelType;
        }

        internal static string ToString(IVariable[] vars)
        {
            StringBuilder sb = new StringBuilder();
            foreach (Variable v in vars)
            {
                if (sb.Length > 0) sb.Append(",");
                sb.Append(v.Name);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Set modelType.Name to a valid identifier.
        /// </summary>
        /// <param name="namespaceName">The desired namespace.  Must be a valid identifier.</param>
        /// <param name="name">The desired name.  Need not be a valid identifier.</param>
        public void SetModelName(string namespaceName, string name)
        {
            modelType.Namespace = namespaceName;
            string validName = CodeBuilder.MakeValid(name);
            modelType.Name = validName;
        }

        /// <summary>
        /// Get the abstract syntax tree for the generated code.
        /// </summary>
        /// <param name="engine"></param>
        /// <returns></returns>
        public List<ITypeDeclaration> GetGeneratedSyntax(InferenceEngine engine)
        {
            SetModelName(engine.ModelNamespace, engine.ModelName);
            return engine.Compiler.GetTransformedDeclaration(modelType, null, Attributes);
        }

        private void AddStatement(IStatement ist)
        {
            //blocks[blocks.Count - 1].Add(ist);
            blockStack.Peek().Add(ist);
        }

        protected void BuildExpressionUntyped(IModelExpression var)
        {
            if (var == null) throw new NullReferenceException("Model expression was null.");
            // Console.WriteLine("Building expression: "+var+" "+builtVars.ContainsKey(var));
            if (var is MethodInvoke methodInvoke)
            {
                BuildMethodInvoke(methodInvoke);
                return;
            }
            MethodInfo mb = new Action<IModelExpression<object>>(this.BuildExpression<object>).Method.GetGenericMethodDefinition();

            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = var.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + var + " does not implement IModelExpression<>");
            // Construct the BuildExpression method for this type.
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            // Invoke the typed BuildExpression method. This will recurse into BuildExpressionUntyped
            // as necessary
            Util.Invoke(mi2, this, var);
        }

        protected void FinishExpressionUntyped(IModelExpression expr, IAlgorithm alg)
        {
            if (expr is MethodInvoke) return;
            MethodInfo mb = new Action<IModelExpression<object>, IAlgorithm>(this.FinishExpression<object>).Method.GetGenericMethodDefinition();
            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = expr.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + expr + " does not implement IModelExpression<>");
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            Util.Invoke(mi2, this, expr, alg);
        }

        protected void SearchExpressionUntyped(IModelExpression expr)
        {
            if (expr == null) throw new NullReferenceException("Model expression was null.");
            // Console.WriteLine("Searching expression: "+var+" "+builtVars.ContainsKey(var));
            if (searched.Contains(expr)) return;
            if (expr is MethodInvoke methodInvoke)
            {
                SearchMethodInvoke(methodInvoke);
                return;
            }
            if (expr is Range range)
            {
                SearchRange(range);
                return;
            }
            MethodInfo mb = new Action<IModelExpression<object>>(this.SearchExpression<object>).Method.GetGenericMethodDefinition();
            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = expr.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + expr + " does not implement IModelExpression<>");
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            Util.Invoke(mi2, this, expr);
        }

        private void SearchMethodInvoke(MethodInvoke method)
        {
            if (searched.Contains(method)) return;
            searched.Add(method);
            if (method.returnValue != null)
            {
                IModelExpression target = method.returnValue;
                if (method.method.DeclaringType == target.GetType() && method.method.Name == new Func<bool>(Variable<bool>.RemovedBySetTo).Method.Name)
                    throw new InvalidOperationException("Variable '" + target +
                                                        "' was consumed by variable.SetTo().  It can no longer be used or inferred.  Perhaps you meant Variable.ConstrainEqual instead of SetTo.");
            }
            if (method.returnValue != null) toSearch.Push(method.returnValue);
            foreach (IModelExpression arg in method.args) toSearch.Push(arg);
            SearchContainers(method.Containers);
        }

        /// <summary>
        /// Add a statement of the form x = f(...) to the MSL.
        /// </summary>
        /// <param name="method">Stores the method to call, the argument variables, and target variable.</param>
        /// <remarks>
        /// If any variable in the statement is an item variable, then we surround the statement with a loop over its range.
        /// Since there may be multiple item variables, and each item may depend on multiple ranges, we may end up with multiple loops.
        /// </remarks>
        private void BuildMethodInvoke(MethodInvoke method)
        {
            if (method.ReturnValue is Variable && ((Variable)method.ReturnValue).Inline) return;
            // Open containing blocks
            List<IStatementBlock> stBlocks = method.Containers;
            List<Range> localRanges = new List<Range>();
            // each argument of method puts a partial order on the ranges.
            // e.g.  array[i,j][k]  requires i < k, j < k  but says nothing about i and j
            // we assemble these constraints into a total order.
            Dictionary<Range, int> indexOfRange = new Dictionary<Range, int>();
            Dictionary<IModelExpression, List<List<Range>>> dict = MethodInvoke.GetRangeBrackets(method.returnValueAndArgs());
            foreach (IModelExpression arg in method.returnValueAndArgs())
            {
                MethodInvoke.ForEachRange(arg,
                                          delegate (Range r) { if (!localRanges.Contains(r)) localRanges.Add(r); });
            }
            ParameterInfo[] pis = method.method.GetParameters();
            for (int i = 0; i < pis.Length; i++)
            {
                IModelExpression arg = method.Arguments[i];
                ParameterInfo pi = pis[i];
                if (pi.IsOut && arg is HasObservedValue && ((HasObservedValue)arg).IsObserved)
                {
                    throw new NotImplementedException(string.Format("Out parameter '{0}' of {1} cannot be observed.  Use ConstrainEqual or observe a copy of the variable.", pi.Name, method));
                }
            }
            foreach (IStatementBlock b in method.Containers)
            {
                if (b is HasRange)
                {
                    HasRange br = (HasRange)b;
                    localRanges.Remove(br.Range);
                }
            }
            localRanges.Sort(delegate (Range a, Range b) { return MethodInvoke.CompareRanges(dict, a, b); });
            // convert from List<Range> to List<IStatementBlock>
            List<IStatementBlock> localRangeBlocks = new List<IStatementBlock>(localRanges.Select(r => r));
            BuildStatementBlocks(stBlocks, true);
            BuildStatementBlocks(localRangeBlocks, true);

            // Invoke method
            IExpression methodExpr = method.GetExpression();
            IStatement st = Builder.ExprStatement(methodExpr);
            if (methodExpr is IAssignExpression && method.ReturnValue is HasObservedValue && ((HasObservedValue)method.ReturnValue).IsObserved)
            {
                Attributes.Set(st, new Constraint());
            }
            AddStatement(st);
            foreach (ICompilerAttribute attr in method.attributes) Attributes.Add(methodExpr, attr);

            BuildStatementBlocks(localRangeBlocks, false);
            BuildStatementBlocks(stBlocks, false);
        }

        internal void BuildStatementBlocks(List<IStatementBlock> statementBlocks, bool open)
        {
            if (open)
            {
                // Build statements around method invocation
                foreach (IStatementBlock isb in statementBlocks)
                {
                    IList<IStatement> innerBlock;
                    IStatement ist = isb.GetStatement(out innerBlock);
                    if (ist != null)
                    {
                        ModifyStatement(ist, isb);
                        AddStatement(ist);
                        blockStack.Push(innerBlock);
                    }
                    else blockStack.Push(blockStack.Peek());
                }
            }
            else
            {
                // Close 'if' statements
                for (int i = statementBlocks.Count - 1; i >= 0; i--)
                {
                    blockStack.Pop();
                }
            }
        }

        private void ModifyStatement(IStatement ist, IStatementBlock isb)
        {
            if (isb is IfBlock)
            {
                IfBlock ib = (IfBlock)isb;
                var condVar = ib.ConditionVariable;
                if (!negatedConditionVariables.Contains(condVar))
                {
                    if (condVar.definition != null)
                    {
                        MethodInvoke mi = condVar.definition;
                        if (mi.method.Equals(new Func<int, int, bool>(Factor.AreEqual).Method))
                        {
                            if (mi.Arguments[1] is Variable)
                            {
                                Variable arg1 = (Variable)mi.Arguments[1];
                                if (arg1.IsObserved || arg1.IsLoopIndex)
                                {
                                    // convert 'if(vbool1)' into 'if(x==value)'  where value is observed (or a loop index) and vbool1 is never negated.
                                    // if vbool1 is negated, then we cannot make this substitution since we need to match the corresponding 'if(!vbool1)' condition.
                                    IConditionStatement ics = (IConditionStatement)ist;
                                    ics.Condition = Builder.BinaryExpr(mi.Arguments[0].GetExpression(), BinaryOperator.ValueEquality, arg1.GetExpression());
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Search a variable expression
        /// </summary>
        /// <typeparam name="T">Domain type of the variable expression</typeparam>
        /// <param name="var">The variable expression</param>
        /// 
        public void SearchExpression<T>(IModelExpression<T> var)
        {
            if (var is Variable<T> varT) SearchVariable<T>(varT);
            else throw new InferCompilerException("Unhandled model expression type: " + var.GetType());
        }

        /// <summary>
        /// Define a variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        private void SearchVariable<T>(Variable<T> variable)
        {
            if (searched.Contains(variable))
                return;
            if (variable.IsBase && variable.NameInGeneratedCode != null)
            {
                string name = variable.NameInGeneratedCode;
                foreach (IModelExpression expr in searched)
                {
                    if (name.Equals(expr.Name))
                    {
                        throw new InferCompilerException("Model contains multiple items with the name '" + name + "'.  Names must be unique.");
                    }
                }
            }
            if (variable.IsLoopIndex)
                return; // do nothing

            searched.Add(variable); // must do this first to prevent re-entry
            SearchContainers(variable.Containers);
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            if (variable.IsArrayElement)
            {
                SearchItem(variable);
            }
            else
            {
                // base variable
                // Process dependencies
                if (variable.initialiseTo != null)
                {
                    toSearch.Push(variable.initialiseTo);
                }
                if (variable.initialiseBackwardTo != null)
                {
                    toSearch.Push(variable.initialiseBackwardTo);
                }

                if (!variable.Inline)
                {
                    // Determine if the variable should be inlined
                    bool inline;
                    if (variable.definition != null)
                    {
                        inline = variable.definition.CanBeInlined();
                    }
                    else
                    {
                        inline = (variable.conditionalDefinitions.Values.Count == 1);
                        foreach (MethodInvoke condDef in variable.conditionalDefinitions.Values)
                        {
                            inline = inline && condDef.CanBeInlined();
                        }
                        if (variable is HasItemVariables)
                        {
                            ICollection<IVariable> items = ((HasItemVariables)variable).GetItemsUntyped().Values;
                            if (items.Count > 0)
                                inline = false;
                        }
                    }
                    variable.Inline = inline;
                }

                if (variable is IVariableArray)
                {
                    IVariableArray iva = (IVariableArray)variable;
                    IList<IVariableDeclaration[]> jaggedIndexVars;
                    IList<IExpression[]> jaggedSizes;
                    GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                }
                // ivde is null if randVar has been declared at this point.
                if (variable.definition != null)
                {
                    SearchMethodInvoke(variable.definition);
                }

                foreach (var attr in variable.GetAttributes<ICompilerAttribute>())
                {
                    if (attr is ValueRange)
                    {
                        ValueRange vr = (ValueRange)attr;
                        SearchRange(vr.Range);
                    }
                    else if (attr is DistributedCommunication)
                    {
                        DistributedCommunication dc = (DistributedCommunication)attr;
                        toSearch.Push(dc.arrayIndicesToSendExpression);
                        toSearch.Push(dc.arrayIndicesToReceiveExpression);
                        var attr2 = new DistributedCommunicationExpression(dc.arrayIndicesToSendExpression.GetExpression(), dc.arrayIndicesToReceiveExpression.GetExpression());
                        // find the base variable
                        Variable parent = variable;
                        while (parent.ArrayVariable != null)
                        {
                            parent = (Variable)parent.ArrayVariable;
                        }
                        var parentDecl = parent.GetDeclaration();
                        if (Attributes.Has<DistributedCommunicationExpression>(parentDecl))
                            throw new Exception($"{parent} has multiple DistributedCommunication attributes");
                        Attributes.Set(parentDecl, attr2);
                    }
                }
            }
            foreach (MethodInvoke condDef in variable.conditionalDefinitions.Values)
            {
                SearchMethodInvoke(condDef);
            }

            if (variable is HasItemVariables)
            {
                // fill the array via the definition of its item variable, if any.
                ICollection<IVariable> ie = ((HasItemVariables)variable).GetItemsUntyped().Values;
                foreach (IVariable irv in ie)
                {
                    toSearch.Push(irv);
                }
            }

            foreach (MethodInvoke constraint in variable.constraints)
                SearchMethodInvoke(constraint);
            foreach (MethodInvoke factor in variable.childFactors)
                SearchMethodInvoke(factor);
        }

        private void FinishExpression<T>(IModelExpression<T> expr, IAlgorithm alg)
        {
            if (expr is Variable<T>)
                FinishVariable<T>((Variable<T>)expr, alg);
            else
                throw new InferCompilerException("Unhandled model expression type: " + expr.GetType());
        }

        private void FinishVariable<T>(Variable<T> variable, IAlgorithm alg)
        {
            if (variable.IsLoopIndex) return; // do nothing
            if (variable.IsArrayElement) return;
            if (variable.Inline) return;

            object ivd = variable.GetDeclaration();
            bool doNotInfer = false;
            // Add attributes
            foreach (ICompilerAttribute attr in variable.GetAttributes<ICompilerAttribute>())
            {
                if (attr is DoNotInfer) doNotInfer = true;
                else Attributes.Add(ivd, attr);
            }
            foreach (IStatementBlock stBlock in variable.Containers)
            {
                if (stBlock is HasRange)
                {
                    doNotInfer = true;
                    break;
                }
            }
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            stBlocks.AddRange(variable.Containers);
            // Add Infer statement 
            bool isConstant = (variable.IsBase && variable.IsReadOnly);
            if (!doNotInfer && ((!inferOnlySpecifiedVars && !isConstant) || variablesToInfer.Contains(variable)))
            {
                // If there has been no explicit indication of query types for inference, set the
                // default types
                List<QueryTypeCompilerAttribute> qtlist = Attributes.GetAll<QueryTypeCompilerAttribute>(ivd);
                if (qtlist.Count == 0)
                {
                    alg.ForEachDefaultQueryType(qt => Attributes.Add(ivd, new QueryTypeCompilerAttribute(qt)));
                    qtlist = Attributes.GetAll<QueryTypeCompilerAttribute>(ivd);
                }
                variablesToInfer.Add(variable);
                BuildStatementBlocks(stBlocks, true);
                IExpression varExpr = variable.GetExpression();
                IExpression varName = Builder.LiteralExpr(variable.NameInGeneratedCode);
                foreach (QueryTypeCompilerAttribute qt in qtlist)
                {
                    IExpression queryExpr = Builder.FieldRefExpr(Builder.TypeRefExpr(typeof(QueryTypes)), typeof(QueryTypes), qt.QueryType.Name);
                    // for a constant, we must get the variable reference, not the value
                    if (isConstant) varExpr = Builder.VarRefExpr((IVariableDeclaration)variable.GetDeclaration());
                    AddStatement(Builder.ExprStatement(
                        Builder.StaticMethod(new Action<object>(InferNet.Infer), varExpr, varName, queryExpr)));
                }
                BuildStatementBlocks(stBlocks, false);
            }
        }

        /// <summary>
        /// Build a variable expression
        /// </summary>
        /// <typeparam name="T">Domain type of the variable expression</typeparam>
        /// <param name="expr">The variable expression</param>
        private void BuildExpression<T>(IModelExpression<T> expr)
        {
            if (expr is Variable<T> var) BuildVariable<T>(var);
            else throw new InferCompilerException("Unhandled model expression type: " + expr.GetType());
        }

        /// <summary>
        /// Define a variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        private void BuildVariable<T>(Variable<T> variable)
        {
            if (variable.IsLoopIndex) return; // do nothing

            if (!variable.IsObserved)
            {
                BuildRandVar(variable);
            }
            else if (!variable.IsReadOnly)
            {
                BuildGiven(variable);
            }
            else
            {
                BuildConstant(variable);
            }
        }

        private bool ShouldInlineConstant<T>(Variable<T> constant)
        {
            return (Quoter.ShouldInlineType(typeof(T)) && (!constant.IsDefined) && !variablesToInfer.Contains(constant));
        }

        /// <summary>
        /// Define a constant in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="constant"></param>
        private void BuildConstant<T>(Variable<T> constant)
        {
            if (constant.IsBase)
            {
                if (ShouldInlineConstant(constant))
                {
                    // do nothing.  the value will be put inline.
                }
                else
                {
                    // check if we have defined a constant with the same value already
                    IVariableDeclaration ivd;
                    bool useExisting = false;
                    object key = constant.ObservedValue;
                    if (ReferenceEquals(key, null)) key = new NullValue<T>();
                    if (constants.TryGetValue(key, out ivd))
                    {
                        // use the declaration of the existing constant
                        useExisting = constant.SetDeclaration(ivd);
                    }
                    if (!useExisting)
                    {
                        // create a new declaration
                        ivd = (IVariableDeclaration)constant.GetDeclaration();
                        var rhs = Quoter.Quote(constant.ObservedValue);
                        if (ReferenceEquals(constant.ObservedValue, null)) rhs = Builder.CastExpr(rhs, typeof(T));
                        AddStatement(Builder.AssignStmt(Builder.VarDeclExpr(ivd), rhs));
                        constants[key] = ivd;
                    }
                    FinishGivenOrConstant(constant, ivd);
                }
            }
            else if (constant.IsArrayElement)
            {
                // do nothing
            }
            else
            {
                throw new NotImplementedException("Unhandled constant type: " + constant);
            }
        }

        private class NullValue<T>
        {
            public override bool Equals(object obj)
            {
                return (obj is NullValue<T>);
            }

            public override int GetHashCode()
            {
                return GetType().GetHashCode();
            }
        }

        /// <summary>
        /// Search all variables referred to by an item variable.
        /// </summary>
        /// <param name="item"></param>
        /// 
        private void SearchItem(Variable item)
        {
            foreach (IModelExpression ind in item.indices) toSearch.Push(ind);
            toSearch.Push(item.ArrayVariable);
            if (item.definition != null) toSearch.Push(item.definition);
            foreach (MethodInvoke constraint in item.constraints) toSearch.Push(constraint);
            if (item.initialiseTo != null) toSearch.Push(item.initialiseTo);
            if (item.initialiseBackwardTo != null)
                toSearch.Push(item.initialiseBackwardTo);
        }

        /// <summary>
        /// Search all variables referred to by a Range.
        /// </summary>
        /// <param name="range"></param>
        private void SearchRange(Range range)
        {
            if (searched.Contains(range)) return;
            string name = ((IModelExpression)range).Name;
            foreach (IModelExpression expr in searched)
            {
                if (name.Equals(expr.Name))
                {
                    throw new InferCompilerException("Model contains multiple items with the name '" + name + "'.  Names must be unique.");
                }
            }
            searched.Add(range);
            toSearch.Push(range.Size);
            IVariableDeclaration ivd = range.GetIndexDeclaration();
            foreach (ICompilerAttribute attr in range.GetAttributes<ICompilerAttribute>())
            {
                if (attr is ParallelSchedule)
                {
                    var ps = (ParallelSchedule)attr;
                    toSearch.Push(ps.scheduleExpression);
                    var attr2 = new ParallelScheduleExpression(ps.scheduleExpression.GetExpression());
                    Attributes.Set(ivd, attr2);
                }
                else if (attr is DistributedSchedule)
                {
                    var ds = (DistributedSchedule)attr;
                    toSearch.Push(ds.commExpression);
                    if (ds.scheduleExpression != null)
                        toSearch.Push(ds.scheduleExpression);
                    if (ds.schedulePerThreadExpression != null)
                        toSearch.Push(ds.schedulePerThreadExpression);
                    var attr2 = new DistributedScheduleExpression(ds.commExpression.GetExpression(), ds.scheduleExpression?.GetExpression(), ds.schedulePerThreadExpression?.GetExpression());
                    Attributes.Set(ivd, attr2);
                }
                else
                {
                    Attributes.Set(ivd, attr);
                }
            }
        }

        /// <summary>
        /// Build condition variable expressions associated with each condition block
        /// Build range variable expressions associated with each range
        /// </summary>
        /// <param name="containers">Containers - condition blocks or foreach block</param>
        /// 
        private void SearchContainers(IEnumerable<IStatementBlock> containers)
        {
            foreach (IStatementBlock sb in containers)
            {
                if (sb is ConditionBlock cb)
                {
                    if (cb is SwitchBlock swb)
                    {
                        SearchRange(swb.Range);
                    }
                    Variable condVar = cb.ConditionVariableUntyped;
                    if (cb is IfBlock ib)
                    {
                        if (ib.ConditionValue == false) negatedConditionVariables.Add(condVar);
                    }
                    toSearch.Push(condVar);
                }
                else if (sb is ForEachBlock fb)
                {
                    SearchRange(fb.Range);
                }
                else if (sb is RepeatBlock rb)
                {
                    toSearch.Push(rb.Count);
                }
            }
        }

        /// <summary>
        /// Add the definition of a random variable to the MSL, inside of the necessary containers.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// <remarks>
        /// A scalar variable is declared and defined in one line such as: <c>int x = factor(...);</c>.
        /// An array variable is first declared with an initializer such as: <c>int[] array = new int[4];</c>.
        /// Then it is defined either with a bulk factor such as: <c>array = factor(...);</c>,
        /// or it is defined via its item variable.
        /// An item variable is defined by 'for' loop whose body is: <c>array[i] = factor(...);</c>.
        /// </remarks>
        protected void BuildRandVar<T>(Variable<T> variable)
        {
            if (!variable.IsDefined) throw new InferCompilerException("Variable '" + variable + "' has no definition");
            if (variable.IsArrayElement)
            {
                for (int initType = 0; initType < 2; initType++)
                {
                    IModelExpression init = (initType == 0) ? variable.initialiseTo : variable.initialiseBackwardTo;
                    if (init != null)
                    {
                        IExpression initExpr = init.GetExpression();
                        // find the base variable
                        Variable parent = variable;
                        while (parent.ArrayVariable != null)
                        {
                            IVariableDeclaration[] indexVars = new IVariableDeclaration[parent.indices.Count];
                            for (int i = 0; i < indexVars.Length; i++)
                            {
                                IModelExpression expr = parent.indices[i];
                                if (!(expr is Range))
                                    throw new Exception(parent + ".InitializeTo is not allowed since the indices are not ranges");
                                indexVars[i] = ((Range)expr).GetIndexDeclaration();
                            }
                            initExpr = VariableInformation.MakePlaceHolderArrayCreate(initExpr, indexVars);
                            parent = (Variable)parent.ArrayVariable;
                        }
                        IVariableDeclaration parentDecl = (IVariableDeclaration)parent.GetDeclaration();
                        ICompilerAttribute attr;
                        if (initType == 0)
                            attr = new InitialiseTo(initExpr);
                        else attr = new InitialiseBackwardTo(initExpr);
                        Attributes.Set(parentDecl, attr);
                    }
                }
                return;
            }
            IVariableDeclaration ivd = (IVariableDeclaration)variable.GetDeclaration();
            if (variable.initialiseTo != null)
            {
                Attributes.Set(ivd, new InitialiseTo(variable.initialiseTo.GetExpression()));
            }
            if (variable.initialiseBackwardTo != null)
            {
                Attributes.Set(ivd, new InitialiseBackwardTo(variable.initialiseBackwardTo.GetExpression()));
            }
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            stBlocks.AddRange(variable.Containers);

            IVariableDeclarationExpression ivde = Builder.VarDeclExpr(ivd);
            if (variable is IVariableArray iva)
            {
                IList<IStatement> sc = Builder.StmtCollection();
                IList<IVariableDeclaration[]> jaggedIndexVars;
                IList<IExpression[]> jaggedSizes;
                GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                // check that containers are all unique and distinct from jaggedIndexVars
                Set<IVariableDeclaration> loopVars = new Set<IVariableDeclaration>();
                foreach (IStatementBlock stBlock in stBlocks)
                {
                    if (stBlock is ForEachBlock fb)
                    {
                        IVariableDeclaration loopVar = fb.Range.GetIndexDeclaration();
                        if (loopVars.Contains(loopVar))
                            throw new InvalidOperationException("Variable '" + ivd.Name + "' uses range '" + loopVar.Name + "' twice. Use a cloned range instead.");
                        loopVars.Add(loopVar);
                    }
                }
                foreach (IVariableDeclaration[] bracket in jaggedIndexVars)
                {
                    foreach (IVariableDeclaration indexVar in bracket)
                    {
                        if (loopVars.Contains(indexVar))
                            throw new InvalidOperationException("Variable '" + ivd.Name + "' uses range '" + indexVar.Name + "' twice. Use a cloned range instead.");
                    }
                }
                Builder.NewJaggedArray(sc, ivd, jaggedIndexVars, jaggedSizes);
                if (!variable.Inline)
                {
                    BuildStatementBlocks(stBlocks, true);
                    foreach (IStatement stmt in sc)
                    {
                        AddStatement(stmt);
                    }
                    BuildStatementBlocks(stBlocks, false);
                }
                ivde = null; // prevent re-declaration
            }
            if (ivde != null)
            {
                if (!variable.Inline)
                {
                    BuildStatementBlocks(stBlocks, true);
                    AddStatement(Builder.ExprStatement(ivde));
                    BuildStatementBlocks(stBlocks, false);
                }
                ivde = null;
            }
            if (ivde != null) throw new InferCompilerException("Variable '" + variable + "' has no definition");
        }

        protected void FinishRandVar<T>(Variable<T> variable, IAlgorithm alg)
        {
        }

        protected void GetJaggedArrayIndicesAndSizes(IVariableArray array, out IList<IVariableDeclaration[]> jaggedIndexVars, out IList<IExpression[]> jaggedSizes)
        {
            Set<IVariableDeclaration> allVars = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
            jaggedIndexVars = new List<IVariableDeclaration[]>();
            jaggedSizes = new List<IExpression[]>();
            while (true)
            {
                Type arrayType = array.GetExpression().GetExpressionType();
                Type elementType = Util.GetElementType(arrayType, out int rank);
                if (!arrayType.IsAssignableFrom(Util.MakeArrayType(elementType, rank)))
                {
                    break;
                }
                IVariableDeclaration[] indexVars;
                IExpression[] sizes;
                GetArrayIndicesAndSizes(array, out indexVars, out sizes);
                foreach (IVariableDeclaration ivd in indexVars)
                {
                    if (allVars.Contains(ivd))
                        throw new CompilationFailedException("Array '" + array.Name + "' is indexed by range '" + ivd.Name +
                                                             "' on multiple dimensions, which is not allowed.  Use range cloning instead.");
                    allVars.Add(ivd);
                }
                jaggedIndexVars.Add(indexVars);
                jaggedSizes.Add(sizes);
                if (array is IVariableJaggedArray variableJaggedArray)
                {
                    IVariable itemPrototype = variableJaggedArray.ItemPrototype;
                    if (itemPrototype is IVariableArray variableArray) array = variableArray;
                    else break;
                }
                else break;
            }
        }

        protected void GetArrayIndicesAndSizes(IVariableArray array, out IVariableDeclaration[] indexVars, out IExpression[] sizes)
        {
            IList<Range> ranges = array.Ranges;
            sizes = new IExpression[ranges.Count];
            indexVars = new IVariableDeclaration[ranges.Count];
            int i = 0;
            foreach (Range r in ranges)
            {
                SearchRange(r);
                indexVars[i] = r.GetIndexDeclaration();
                sizes[i] = r.GetSizeExpression();
                i++;
            }
        }

        /// <summary>
        /// Define a given variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        protected void BuildGiven<T>(Variable<T> variable)
        {
            if (variable.IsBase)
            {
                IParameterDeclaration ipd = (IParameterDeclaration)variable.GetDeclaration();
                modelMethod.Parameters.Add(ipd);
                FinishGivenOrConstant(variable, ipd);
                // must do this after the sizes are built
                observedVars.Add(variable);
            }
            else if (variable.IsArrayElement)
            {
                // do nothing
            }
            else
            {
                throw new NotImplementedException("Unhandled given type: " + variable);
            }
        }

        private void FinishGivenOrConstant(Variable variable, object decl)
        {
            if (variable is IVariableArray iva)
            {
                // attach a VariableInformation attribute that holds the array sizes
                // this is needed because the array size never appears in the code
                IList<IVariableDeclaration[]> jaggedIndexVars;
                IList<IExpression[]> jaggedSizes;
                GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                var vi = new VariableInformation(decl);
                vi.sizes.AddRange(jaggedSizes);
                vi.indexVars.AddRange(jaggedIndexVars);
                Attributes.Set(decl, vi);

                // see ModelTests.RangeWithConstantSizeTest
                bool addLengthConstraints = false;
                if (addLengthConstraints)
                {
                    IExpression array = variable.GetExpression();
                    IExpression valueIsNotNull = Builder.BinaryExpr(array, BinaryOperator.ValueInequality, Builder.LiteralExpr(null));
                    IConditionStatement cs = Builder.CondStmt(valueIsNotNull, Builder.BlockStmt());
                    var constraint = new Action<int, int>(Microsoft.ML.Probabilistic.Factors.Constrain.Equal);
                    Type arrayType = array.GetExpressionType();
                    int rank = vi.sizes[0].Length;
                    //Util.GetElementType(arrayType, out rank);
                    for (int i = 0; i < rank; i++)
                    {
                        IExpression lengthExpr;
                        if (rank == 1)
                        {
                            lengthExpr = Builder.PropRefExpr(array, arrayType, arrayType.IsArray ? "Length" : "Count", typeof(int));
                        }
                        else
                        {
                            lengthExpr = Builder.Method(array, typeof(Array).GetMethod("GetLength"), Builder.LiteralExpr(i));
                        }
                        cs.Then.Statements.Add(Builder.ExprStatement(
                            Builder.StaticMethod(constraint, lengthExpr, vi.sizes[0][i])));
                    }
                    AddStatement(cs);
                }
            }
        }

        public string ModelString()
        {
            return CodeCompiler.DeclarationToString(modelType);
        }
    }

    /// <summary>
    /// Attached to assignment statements to indicate that they are not really assignments but equality constraints between the left and right hand side.
    /// </summary>
    internal class Constraint : ICompilerAttribute
    {
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler;
using System.Reflection;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Models.Attributes;
using Microsoft.ML.Probabilistic.Factors;

namespace Microsoft.ML.Probabilistic.Models
{
    /// <summary>
    /// Builds an MSL model from an in-memory graph of model expression objects.
    /// </summary>
    internal class ModelBuilder
    {
        /// <summary>
        /// Helps build class declarations
        /// </summary>
        private static CodeBuilder Builder = CodeBuilder.Instance;

        public ITypeDeclaration modelType;
        public AttributeRegistry<object, ICompilerAttribute> Attributes;
        private Stack<IModelExpression> toSearch = new Stack<IModelExpression>();
        private Set<IModelExpression> searched = new Set<IModelExpression>(ReferenceEqualityComparer<IModelExpression>.Instance);

        /// <summary>
        /// The set of condition variables used in 'IfNot' blocks.  Filled in during search.
        /// </summary>
        private Set<Variable> negatedConditionVariables = new Set<Variable>(ReferenceEqualityComparer<Variable>.Instance);

        // optimizes ModelBuilder.Compile
        internal List<Variable> observedVars = new List<Variable>();
        internal Set<IVariable> variablesToInfer = new Set<IVariable>(ReferenceEqualityComparer<IVariable>.Instance);

        protected IMethodDeclaration modelMethod;
        protected Stack<IList<IStatement>> blockStack;
        protected bool inferOnlySpecifiedVars = false;

        /// <summary>
        /// Mapping from constant values to their declarations in the generated code.
        /// </summary>
        protected Dictionary<object, IVariableDeclaration> constants = new Dictionary<object, IVariableDeclaration>();

        internal IReadOnlyCollection<IModelExpression> ModelExpressions { get; private set; }

        /// <summary>
        /// The default namespace for generated code.
        /// This should not be a child of any existing namespace, such as Microsoft.ML.Probabilistic, because of possible name conflicts.
        /// </summary>
        public const string ModelNamespace = "Models";

        public void Reset()
        {
            modelType = Builder.TypeDecl();
            modelType.Namespace = ModelNamespace;
            modelType.Owner = null;
            modelType.BaseType = null;
            modelType.Visibility = TypeVisibility.Public;
            modelMethod = Builder.MethodDecl(MethodVisibility.Public, "Model", typeof(void), modelType);
            IBlockStatement body = Builder.BlockStmt();
            modelMethod.Body = body;
            //blocks = new List<IList<IStatement>>();
            blockStack = new Stack<IList<IStatement>>();
            blockStack.Push(body.Statements);
            modelType.Methods.Add(modelMethod);
            Attributes = new AttributeRegistry<object, ICompilerAttribute>(true);
            searched.Clear();
            observedVars.Clear();
            variablesToInfer.Clear();
            constants.Clear();
            ModelExpressions = null;
        }

        /// <summary>
        /// Builds the model necessary to infer marginals for the supplied variables and algorithm.
        /// </summary>
        /// <param name="engine">The inference algorithm being used</param>
        /// <param name="inferOnlySpecifiedVars">If true, inference will be restricted to only the variables given.</param>
        /// <param name="vars">Variables to infer.</param>
        /// <returns></returns>
        /// <remarks>
        /// Algorithm: starting from the variables to infer, we search through the graph to build up a "searched set".
        /// Each Variable and MethodInvoke in this set has an associated timestamp.
        /// We sort by timestamp, and then generate code.
        /// </remarks>
        public ITypeDeclaration Build(InferenceEngine engine, bool inferOnlySpecifiedVars, IEnumerable<IVariable> vars)
        {
            List<IStatementBlock> openBlocks = StatementBlock.GetOpenBlocks();
            if (openBlocks.Count > 0)
            {
                throw new InvalidOperationException("The block " + openBlocks[0] + " has not been closed.");
            }
            Reset();
            this.inferOnlySpecifiedVars = inferOnlySpecifiedVars;
            variablesToInfer.AddRange(vars);
            foreach (IVariable var in vars) toSearch.Push(var);
            while (toSearch.Count > 0)
            {
                IModelExpression expr = toSearch.Pop();
                SearchExpressionUntyped(expr);
            }
            // lock in the set of model expressions.
            ModelExpressions = new List<IModelExpression>(searched);
            List<int> timestamps = new List<int>();
            List<IModelExpression> exprs = new List<IModelExpression>();
            foreach (IModelExpression expr in ModelExpressions)
            {
                if (expr is Variable var)
                {
                    exprs.Add(var);
                    timestamps.Add(var.timestamp);
                }
                else if (expr is MethodInvoke mi)
                {
                    exprs.Add(mi);
                    timestamps.Add(mi.timestamp);
                }
            }
            Collection.Sort(timestamps, exprs);
            foreach (IModelExpression expr in exprs)
            {
                BuildExpressionUntyped(expr);
            }
            foreach (IModelExpression expr in exprs)
            {
                FinishExpressionUntyped(expr, engine.Algorithm);
            }
            return modelType;
        }

        internal static string ToString(IVariable[] vars)
        {
            StringBuilder sb = new StringBuilder();
            foreach (Variable v in vars)
            {
                if (sb.Length > 0) sb.Append(",");
                sb.Append(v.Name);
            }
            return sb.ToString();
        }

        /// <summary>
        /// Set modelType.Name to a valid identifier.
        /// </summary>
        /// <param name="namespaceName">The desired namespace.  Must be a valid identifier.</param>
        /// <param name="name">The desired name.  Need not be a valid identifier.</param>
        public void SetModelName(string namespaceName, string name)
        {
            modelType.Namespace = namespaceName;
            string validName = CodeBuilder.MakeValid(name);
            modelType.Name = validName;
        }

        /// <summary>
        /// Get the abstract syntax tree for the generated code.
        /// </summary>
        /// <param name="engine"></param>
        /// <returns></returns>
        public List<ITypeDeclaration> GetGeneratedSyntax(InferenceEngine engine)
        {
            SetModelName(engine.ModelNamespace, engine.ModelName);
            return engine.Compiler.GetTransformedDeclaration(modelType, null, Attributes);
        }

        private void AddStatement(IStatement ist)
        {
            //blocks[blocks.Count - 1].Add(ist);
            blockStack.Peek().Add(ist);
        }

        protected void BuildExpressionUntyped(IModelExpression var)
        {
            if (var == null) throw new NullReferenceException("Model expression was null.");
            // Console.WriteLine("Building expression: "+var+" "+builtVars.ContainsKey(var));
            if (var is MethodInvoke methodInvoke)
            {
                BuildMethodInvoke(methodInvoke);
                return;
            }
            MethodInfo mb = new Action<IModelExpression<object>>(this.BuildExpression<object>).Method.GetGenericMethodDefinition();

            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = var.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + var + " does not implement IModelExpression<>");
            // Construct the BuildExpression method for this type.
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            // Invoke the typed BuildExpression method. This will recurse into BuildExpressionUntyped
            // as necessary
            Util.Invoke(mi2, this, var);
        }

        protected void FinishExpressionUntyped(IModelExpression expr, IAlgorithm alg)
        {
            if (expr is MethodInvoke) return;
            MethodInfo mb = new Action<IModelExpression<object>, IAlgorithm>(this.FinishExpression<object>).Method.GetGenericMethodDefinition();
            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = expr.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + expr + " does not implement IModelExpression<>");
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            Util.Invoke(mi2, this, expr, alg);
        }

        protected void SearchExpressionUntyped(IModelExpression expr)
        {
            if (expr == null) throw new NullReferenceException("Model expression was null.");
            // Console.WriteLine("Searching expression: "+var+" "+builtVars.ContainsKey(var));
            if (searched.Contains(expr)) return;
            if (expr is MethodInvoke methodInvoke)
            {
                SearchMethodInvoke(methodInvoke);
                return;
            }
            if (expr is Range range)
            {
                SearchRange(range);
                return;
            }
            MethodInfo mb = new Action<IModelExpression<object>>(this.SearchExpression<object>).Method.GetGenericMethodDefinition();
            Type domainType = null;
            // Look through the interfaces for this model expression (is there a better way of doing this?).
            // We expect to find IModelExpression<> - we can then get the type parameter from this interface
            Type[] faces = expr.GetType().GetInterfaces();
            foreach (Type face in faces)
            {
                if (face.IsGenericType && face.GetGenericTypeDefinition() == typeof(IModelExpression<>))
                {
                    domainType = face.GetGenericArguments()[0];
                    break;
                }
            }
            if (domainType == null) throw new ArgumentException("Expression: " + expr + " does not implement IModelExpression<>");
            MethodInfo mi2 = mb.MakeGenericMethod(domainType);
            Util.Invoke(mi2, this, expr);
        }

        private void SearchMethodInvoke(MethodInvoke method)
        {
            if (searched.Contains(method)) return;
            searched.Add(method);
            if (method.returnValue != null)
            {
                IModelExpression target = method.returnValue;
                if (method.method.DeclaringType == target.GetType() && method.method.Name == new Func<bool>(Variable<bool>.RemovedBySetTo).Method.Name)
                    throw new InvalidOperationException("Variable '" + target +
                                                        "' was consumed by variable.SetTo().  It can no longer be used or inferred.  Perhaps you meant Variable.ConstrainEqual instead of SetTo.");
            }
            if (method.returnValue != null) toSearch.Push(method.returnValue);
            foreach (IModelExpression arg in method.args) toSearch.Push(arg);
            SearchContainers(method.Containers);
        }

        /// <summary>
        /// Add a statement of the form x = f(...) to the MSL.
        /// </summary>
        /// <param name="method">Stores the method to call, the argument variables, and target variable.</param>
        /// <remarks>
        /// If any variable in the statement is an item variable, then we surround the statement with a loop over its range.
        /// Since there may be multiple item variables, and each item may depend on multiple ranges, we may end up with multiple loops.
        /// </remarks>
        private void BuildMethodInvoke(MethodInvoke method)
        {
            if (method.ReturnValue is Variable && ((Variable)method.ReturnValue).Inline) return;
            // Open containing blocks
            List<IStatementBlock> stBlocks = method.Containers;
            List<Range> localRanges = new List<Range>();
            // each argument of method puts a partial order on the ranges.
            // e.g.  array[i,j][k]  requires i < k, j < k  but says nothing about i and j
            // we assemble these constraints into a total order.
            Dictionary<Range, int> indexOfRange = new Dictionary<Range, int>();
            Dictionary<IModelExpression, List<List<Range>>> dict = MethodInvoke.GetRangeBrackets(method.returnValueAndArgs());
            foreach (IModelExpression arg in method.returnValueAndArgs())
            {
                MethodInvoke.ForEachRange(arg,
                                          delegate (Range r) { if (!localRanges.Contains(r)) localRanges.Add(r); });
            }
            ParameterInfo[] pis = method.method.GetParameters();
            for (int i = 0; i < pis.Length; i++)
            {
                IModelExpression arg = method.Arguments[i];
                ParameterInfo pi = pis[i];
                if (pi.IsOut && arg is HasObservedValue && ((HasObservedValue)arg).IsObserved)
                {
                    throw new NotImplementedException(string.Format("Out parameter '{0}' of {1} cannot be observed.  Use ConstrainEqual or observe a copy of the variable.", pi.Name, method));
                }
            }
            foreach (IStatementBlock b in method.Containers)
            {
                if (b is HasRange br)
                {
                    localRanges.Remove(br.Range);
                }
            }
            localRanges.Sort(delegate (Range a, Range b) { return MethodInvoke.CompareRanges(dict, a, b); });
            // convert from List<Range> to List<IStatementBlock>
            List<IStatementBlock> localRangeBlocks = new List<IStatementBlock>(localRanges.Select(r => r));
            BuildStatementBlocks(stBlocks, true);
            BuildStatementBlocks(localRangeBlocks, true);

            // Invoke method
            IExpression methodExpr = method.GetExpression();
            IStatement st = Builder.ExprStatement(methodExpr);
            if (methodExpr is IAssignExpression && method.ReturnValue is HasObservedValue && ((HasObservedValue)method.ReturnValue).IsObserved)
            {
                Attributes.Set(st, new Constraint());
            }
            AddStatement(st);
            foreach (ICompilerAttribute attr in method.attributes) Attributes.Add(methodExpr, attr);

            BuildStatementBlocks(localRangeBlocks, false);
            BuildStatementBlocks(stBlocks, false);
        }

        internal void BuildStatementBlocks(List<IStatementBlock> statementBlocks, bool open)
        {
            if (open)
            {
                // Build statements around method invocation
                foreach (IStatementBlock isb in statementBlocks)
                {
                    IList<IStatement> innerBlock;
                    IStatement ist = isb.GetStatement(out innerBlock);
                    if (ist != null)
                    {
                        ModifyStatement(ist, isb);
                        AddStatement(ist);
                        blockStack.Push(innerBlock);
                    }
                    else blockStack.Push(blockStack.Peek());
                }
            }
            else
            {
                // Close 'if' statements
                for (int i = statementBlocks.Count - 1; i >= 0; i--)
                {
                    blockStack.Pop();
                }
            }
        }

        private void ModifyStatement(IStatement ist, IStatementBlock isb)
        {
            if (isb is IfBlock ib)
            {
                var condVar = ib.ConditionVariable;
                if (!negatedConditionVariables.Contains(condVar))
                {
                    if (condVar.definition != null)
                    {
                        MethodInvoke mi = condVar.definition;
                        if (mi.method.Equals(new Func<int, int, bool>(Factor.AreEqual).Method))
                        {
                            if (mi.Arguments[1] is Variable)
                            {
                                Variable arg1 = (Variable)mi.Arguments[1];
                                if (arg1.IsObserved || arg1.IsLoopIndex)
                                {
                                    // convert 'if(vbool1)' into 'if(x==value)'  where value is observed (or a loop index) and vbool1 is never negated.
                                    // if vbool1 is negated, then we cannot make this substitution since we need to match the corresponding 'if(!vbool1)' condition.
                                    IConditionStatement ics = (IConditionStatement)ist;
                                    ics.Condition = Builder.BinaryExpr(mi.Arguments[0].GetExpression(), BinaryOperator.ValueEquality, arg1.GetExpression());
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Search a variable expression
        /// </summary>
        /// <typeparam name="T">Domain type of the variable expression</typeparam>
        /// <param name="var">The variable expression</param>
        /// 
        public void SearchExpression<T>(IModelExpression<T> var)
        {
            if (var is Variable<T> varT) SearchVariable<T>(varT);
            else throw new InferCompilerException("Unhandled model expression type: " + var.GetType());
        }

        /// <summary>
        /// Define a variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        private void SearchVariable<T>(Variable<T> variable)
        {
            if (searched.Contains(variable))
                return;
            if (variable.IsBase && variable.NameInGeneratedCode != null)
            {
                string name = variable.NameInGeneratedCode;
                foreach (IModelExpression expr in searched)
                {
                    if (name.Equals(expr.Name))
                    {
                        throw new InferCompilerException("Model contains multiple items with the name '" + name + "'.  Names must be unique.");
                    }
                }
            }
            if (variable.IsLoopIndex)
                return; // do nothing

            searched.Add(variable); // must do this first to prevent re-entry
            SearchContainers(variable.Containers);
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            if (variable.IsArrayElement)
            {
                SearchItem(variable);
            }
            else
            {
                // base variable
                // Process dependencies
                if (variable.initialiseTo != null)
                {
                    toSearch.Push(variable.initialiseTo);
                }
                if (variable.initialiseBackwardTo != null)
                {
                    toSearch.Push(variable.initialiseBackwardTo);
                }

                if (!variable.Inline)
                {
                    // Determine if the variable should be inlined
                    bool inline;
                    if (variable.definition != null)
                    {
                        inline = variable.definition.CanBeInlined();
                    }
                    else
                    {
                        inline = (variable.conditionalDefinitions.Values.Count == 1);
                        foreach (MethodInvoke condDef in variable.conditionalDefinitions.Values)
                        {
                            inline = inline && condDef.CanBeInlined();
                        }
                        if (variable is HasItemVariables hasItemVariables)
                        {
                            ICollection<IVariable> items = hasItemVariables.GetItemsUntyped().Values;
                            if (items.Count > 0)
                                inline = false;
                        }
                    }
                    variable.Inline = inline;
                }

                if (variable is IVariableArray iva)
                {
                    IList<IVariableDeclaration[]> jaggedIndexVars;
                    IList<IExpression[]> jaggedSizes;
                    GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                }
                // ivde is null if randVar has been declared at this point.
                if (variable.definition != null)
                {
                    SearchMethodInvoke(variable.definition);
                }

                foreach (var attr in variable.GetAttributes<ICompilerAttribute>())
                {
                    if (attr is ValueRange vr)
                    {
                        SearchRange(vr.Range);
                    }
                    else if (attr is DistributedCommunication dc)
                    {
                        toSearch.Push(dc.arrayIndicesToSendExpression);
                        toSearch.Push(dc.arrayIndicesToReceiveExpression);
                        var attr2 = new DistributedCommunicationExpression(dc.arrayIndicesToSendExpression.GetExpression(), dc.arrayIndicesToReceiveExpression.GetExpression());
                        // find the base variable
                        Variable parent = variable;
                        while (parent.ArrayVariable != null)
                        {
                            parent = (Variable)parent.ArrayVariable;
                        }
                        var parentDecl = parent.GetDeclaration();
                        if (Attributes.Has<DistributedCommunicationExpression>(parentDecl))
                            throw new Exception($"{parent} has multiple DistributedCommunication attributes");
                        Attributes.Set(parentDecl, attr2);
                    }
                }
            }
            foreach (MethodInvoke condDef in variable.conditionalDefinitions.Values)
            {
                SearchMethodInvoke(condDef);
            }

            if (variable is HasItemVariables hasItemVariables)
            {
                // fill the array via the definition of its item variable, if any.
                ICollection<IVariable> ie = hasItemVariables.GetItemsUntyped().Values;
                foreach (IVariable irv in ie)
                {
                    toSearch.Push(irv);
                }
            }

            foreach (MethodInvoke constraint in variable.constraints)
                SearchMethodInvoke(constraint);
            foreach (MethodInvoke factor in variable.childFactors)
                SearchMethodInvoke(factor);
        }

        private void FinishExpression<T>(IModelExpression<T> expr, IAlgorithm alg)
        {
            if (expr is Variable<T> Ts)
                FinishVariable<T>(Ts, alg);
            else
                throw new InferCompilerException("Unhandled model expression type: " + expr.GetType());
        }

        private void FinishVariable<T>(Variable<T> variable, IAlgorithm alg)
        {
            if (variable.IsLoopIndex) return; // do nothing
            if (variable.IsArrayElement) return;
            if (variable.Inline) return;

            object ivd = variable.GetDeclaration();
            bool doNotInfer = false;
            // Add attributes
            foreach (ICompilerAttribute attr in variable.GetAttributes<ICompilerAttribute>())
            {
                if (attr is DoNotInfer) doNotInfer = true;
                else Attributes.Add(ivd, attr);
            }
            foreach (IStatementBlock stBlock in variable.Containers)
            {
                if (stBlock is HasRange)
                {
                    doNotInfer = true;
                    break;
                }
            }
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            stBlocks.AddRange(variable.Containers);
            // Add Infer statement 
            bool isConstant = (variable.IsBase && variable.IsReadOnly);
            if (!doNotInfer && ((!inferOnlySpecifiedVars && !isConstant) || variablesToInfer.Contains(variable)))
            {
                // If there has been no explicit indication of query types for inference, set the
                // default types
                List<QueryTypeCompilerAttribute> qtlist = Attributes.GetAll<QueryTypeCompilerAttribute>(ivd);
                if (qtlist.Count == 0)
                {
                    alg.ForEachDefaultQueryType(qt => Attributes.Add(ivd, new QueryTypeCompilerAttribute(qt)));
                    qtlist = Attributes.GetAll<QueryTypeCompilerAttribute>(ivd);
                }
                variablesToInfer.Add(variable);
                BuildStatementBlocks(stBlocks, true);
                IExpression varExpr = variable.GetExpression();
                IExpression varName = Builder.LiteralExpr(variable.NameInGeneratedCode);
                foreach (QueryTypeCompilerAttribute qt in qtlist)
                {
                    IExpression queryExpr = Builder.FieldRefExpr(Builder.TypeRefExpr(typeof(QueryTypes)), typeof(QueryTypes), qt.QueryType.Name);
                    // for a constant, we must get the variable reference, not the value
                    if (isConstant) varExpr = Builder.VarRefExpr((IVariableDeclaration)variable.GetDeclaration());
                    AddStatement(Builder.ExprStatement(
                        Builder.StaticMethod(new Action<object>(InferNet.Infer), varExpr, varName, queryExpr)));
                }
                BuildStatementBlocks(stBlocks, false);
            }
        }

        /// <summary>
        /// Build a variable expression
        /// </summary>
        /// <typeparam name="T">Domain type of the variable expression</typeparam>
        /// <param name="expr">The variable expression</param>
        private void BuildExpression<T>(IModelExpression<T> expr)
        {
            if (expr is Variable<T> var) BuildVariable<T>(var);
            else throw new InferCompilerException("Unhandled model expression type: " + expr.GetType());
        }

        /// <summary>
        /// Define a variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        private void BuildVariable<T>(Variable<T> variable)
        {
            if (variable.IsLoopIndex) return; // do nothing

            if (!variable.IsObserved)
            {
                BuildRandVar(variable);
            }
            else if (!variable.IsReadOnly)
            {
                BuildGiven(variable);
            }
            else
            {
                BuildConstant(variable);
            }
        }

        private bool ShouldInlineConstant<T>(Variable<T> constant)
        {
            return (Quoter.ShouldInlineType(typeof(T)) && (!constant.IsDefined) && !variablesToInfer.Contains(constant));
        }

        /// <summary>
        /// Define a constant in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="constant"></param>
        private void BuildConstant<T>(Variable<T> constant)
        {
            if (constant.IsBase)
            {
                if (ShouldInlineConstant(constant))
                {
                    // do nothing.  the value will be put inline.
                }
                else
                {
                    // check if we have defined a constant with the same value already
                    IVariableDeclaration ivd;
                    bool useExisting = false;
                    object key = constant.ObservedValue;
                    if (ReferenceEquals(key, null)) key = new NullValue<T>();
                    if (constants.TryGetValue(key, out ivd))
                    {
                        // use the declaration of the existing constant
                        useExisting = constant.SetDeclaration(ivd);
                    }
                    if (!useExisting)
                    {
                        // create a new declaration
                        ivd = (IVariableDeclaration)constant.GetDeclaration();
                        var rhs = Quoter.Quote(constant.ObservedValue);
                        if (ReferenceEquals(constant.ObservedValue, null)) rhs = Builder.CastExpr(rhs, typeof(T));
                        AddStatement(Builder.AssignStmt(Builder.VarDeclExpr(ivd), rhs));
                        constants[key] = ivd;
                    }
                    FinishGivenOrConstant(constant, ivd);
                }
            }
            else if (constant.IsArrayElement)
            {
                // do nothing
            }
            else
            {
                throw new NotImplementedException("Unhandled constant type: " + constant);
            }
        }

        private class NullValue<T>
        {
            public override bool Equals(object obj)
            {
                return (obj is NullValue<T>);
            }

            public override int GetHashCode()
            {
                return GetType().GetHashCode();
            }
        }

        /// <summary>
        /// Search all variables referred to by an item variable.
        /// </summary>
        /// <param name="item"></param>
        /// 
        private void SearchItem(Variable item)
        {
            foreach (IModelExpression ind in item.indices) toSearch.Push(ind);
            toSearch.Push(item.ArrayVariable);
            if (item.definition != null) toSearch.Push(item.definition);
            foreach (MethodInvoke constraint in item.constraints) toSearch.Push(constraint);
            if (item.initialiseTo != null) toSearch.Push(item.initialiseTo);
            if (item.initialiseBackwardTo != null)
                toSearch.Push(item.initialiseBackwardTo);
        }

        /// <summary>
        /// Search all variables referred to by a Range.
        /// </summary>
        /// <param name="range"></param>
        private void SearchRange(Range range)
        {
            if (searched.Contains(range)) return;
            string name = ((IModelExpression)range).Name;
            foreach (IModelExpression expr in searched)
            {
                if (name.Equals(expr.Name))
                {
                    throw new InferCompilerException("Model contains multiple items with the name '" + name + "'.  Names must be unique.");
                }
            }
            searched.Add(range);
            toSearch.Push(range.Size);
            IVariableDeclaration ivd = range.GetIndexDeclaration();
            foreach (ICompilerAttribute attr in range.GetAttributes<ICompilerAttribute>())
            {
                if (attr is ParallelSchedule ps)
                {
                    toSearch.Push(ps.scheduleExpression);
                    var attr2 = new ParallelScheduleExpression(ps.scheduleExpression.GetExpression());
                    Attributes.Set(ivd, attr2);
                }
                else if (attr is DistributedSchedule ds)
                {
                    toSearch.Push(ds.commExpression);
                    if (ds.scheduleExpression != null)
                        toSearch.Push(ds.scheduleExpression);
                    if (ds.schedulePerThreadExpression != null)
                        toSearch.Push(ds.schedulePerThreadExpression);
                    var attr2 = new DistributedScheduleExpression(ds.commExpression.GetExpression(), ds.scheduleExpression?.GetExpression(), ds.schedulePerThreadExpression?.GetExpression());
                    Attributes.Set(ivd, attr2);
                }
                else
                {
                    Attributes.Set(ivd, attr);
                }
            }
        }

        /// <summary>
        /// Build condition variable expressions associated with each condition block
        /// Build range variable expressions associated with each range
        /// </summary>
        /// <param name="containers">Containers - condition blocks or foreach block</param>
        /// 
        private void SearchContainers(IEnumerable<IStatementBlock> containers)
        {
            foreach (IStatementBlock sb in containers)
            {
                if (sb is ConditionBlock cb)
                {
                    if (cb is SwitchBlock swb)
                    {
                        SearchRange(swb.Range);
                    }
                    Variable condVar = cb.ConditionVariableUntyped;
                    if (cb is IfBlock ib)
                    {
                        if (ib.ConditionValue == false) negatedConditionVariables.Add(condVar);
                    }
                    toSearch.Push(condVar);
                }
                else if (sb is ForEachBlock fb)
                {
                    SearchRange(fb.Range);
                }
                else if (sb is RepeatBlock rb)
                {
                    toSearch.Push(rb.Count);
                }
            }
        }

        /// <summary>
        /// Add the definition of a random variable to the MSL, inside of the necessary containers.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// <remarks>
        /// A scalar variable is declared and defined in one line such as: <c>int x = factor(...);</c>.
        /// An array variable is first declared with an initializer such as: <c>int[] array = new int[4];</c>.
        /// Then it is defined either with a bulk factor such as: <c>array = factor(...);</c>,
        /// or it is defined via its item variable.
        /// An item variable is defined by 'for' loop whose body is: <c>array[i] = factor(...);</c>.
        /// </remarks>
        protected void BuildRandVar<T>(Variable<T> variable)
        {
            if (!variable.IsDefined) throw new InferCompilerException("Variable '" + variable + "' has no definition");
            if (variable.IsArrayElement)
            {
                for (int initType = 0; initType < 2; initType++)
                {
                    IModelExpression init = (initType == 0) ? variable.initialiseTo : variable.initialiseBackwardTo;
                    if (init != null)
                    {
                        IExpression initExpr = init.GetExpression();
                        // find the base variable
                        Variable parent = variable;
                        while (parent.ArrayVariable != null)
                        {
                            IVariableDeclaration[] indexVars = new IVariableDeclaration[parent.indices.Count];
                            for (int i = 0; i < indexVars.Length; i++)
                            {
                                IModelExpression expr = parent.indices[i];
                                if (!(expr is Range))
                                    throw new Exception(parent + ".InitializeTo is not allowed since the indices are not ranges");
                                indexVars[i] = ((Range)expr).GetIndexDeclaration();
                            }
                            initExpr = VariableInformation.MakePlaceHolderArrayCreate(initExpr, indexVars);
                            parent = (Variable)parent.ArrayVariable;
                        }
                        IVariableDeclaration parentDecl = (IVariableDeclaration)parent.GetDeclaration();
                        ICompilerAttribute attr;
                        if (initType == 0)
                            attr = new InitialiseTo(initExpr);
                        else attr = new InitialiseBackwardTo(initExpr);
                        Attributes.Set(parentDecl, attr);
                    }
                }
                return;
            }
            IVariableDeclaration ivd = (IVariableDeclaration)variable.GetDeclaration();
            if (variable.initialiseTo != null)
            {
                Attributes.Set(ivd, new InitialiseTo(variable.initialiseTo.GetExpression()));
            }
            if (variable.initialiseBackwardTo != null)
            {
                Attributes.Set(ivd, new InitialiseBackwardTo(variable.initialiseBackwardTo.GetExpression()));
            }
            List<IStatementBlock> stBlocks = new List<IStatementBlock>();
            stBlocks.AddRange(variable.Containers);

            IVariableDeclarationExpression ivde = Builder.VarDeclExpr(ivd);
            if (variable is IVariableArray iva)
            {
                IList<IStatement> sc = Builder.StmtCollection();
                IList<IVariableDeclaration[]> jaggedIndexVars;
                IList<IExpression[]> jaggedSizes;
                GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                // check that containers are all unique and distinct from jaggedIndexVars
                Set<IVariableDeclaration> loopVars = new Set<IVariableDeclaration>();
                foreach (IStatementBlock stBlock in stBlocks)
                {
                    if (stBlock is ForEachBlock fb)
                    {
                        IVariableDeclaration loopVar = fb.Range.GetIndexDeclaration();
                        if (loopVars.Contains(loopVar))
                            throw new InvalidOperationException("Variable '" + ivd.Name + "' uses range '" + loopVar.Name + "' twice. Use a cloned range instead.");
                        loopVars.Add(loopVar);
                    }
                }
                foreach (IVariableDeclaration[] bracket in jaggedIndexVars)
                {
                    foreach (IVariableDeclaration indexVar in bracket)
                    {
                        if (loopVars.Contains(indexVar))
                            throw new InvalidOperationException("Variable '" + ivd.Name + "' uses range '" + indexVar.Name + "' twice. Use a cloned range instead.");
                    }
                }
                Builder.NewJaggedArray(sc, ivd, jaggedIndexVars, jaggedSizes);
                if (!variable.Inline)
                {
                    BuildStatementBlocks(stBlocks, true);
                    foreach (IStatement stmt in sc)
                    {
                        AddStatement(stmt);
                    }
                    BuildStatementBlocks(stBlocks, false);
                }
                ivde = null; // prevent re-declaration
            }
            if (ivde != null)
            {
                if (!variable.Inline)
                {
                    BuildStatementBlocks(stBlocks, true);
                    AddStatement(Builder.ExprStatement(ivde));
                    BuildStatementBlocks(stBlocks, false);
                }
                ivde = null;
            }
            if (ivde != null) throw new InferCompilerException("Variable '" + variable + "' has no definition");
        }

        protected void FinishRandVar<T>(Variable<T> variable, IAlgorithm alg)
        {
        }

        protected void GetJaggedArrayIndicesAndSizes(IVariableArray array, out IList<IVariableDeclaration[]> jaggedIndexVars, out IList<IExpression[]> jaggedSizes)
        {
            Set<IVariableDeclaration> allVars = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
            jaggedIndexVars = new List<IVariableDeclaration[]>();
            jaggedSizes = new List<IExpression[]>();
            while (true)
            {
                Type arrayType = array.GetExpression().GetExpressionType();
                Type elementType = Util.GetElementType(arrayType, out int rank);
                if (!arrayType.IsAssignableFrom(Util.MakeArrayType(elementType, rank)))
                {
                    break;
                }
                IVariableDeclaration[] indexVars;
                IExpression[] sizes;
                GetArrayIndicesAndSizes(array, out indexVars, out sizes);
                foreach (IVariableDeclaration ivd in indexVars)
                {
                    if (allVars.Contains(ivd))
                        throw new CompilationFailedException("Array '" + array.Name + "' is indexed by range '" + ivd.Name +
                                                             "' on multiple dimensions, which is not allowed.  Use range cloning instead.");
                    allVars.Add(ivd);
                }
                jaggedIndexVars.Add(indexVars);
                jaggedSizes.Add(sizes);
                if (array is IVariableJaggedArray variableJaggedArray)
                {
                    IVariable itemPrototype = variableJaggedArray.ItemPrototype;
                    if (itemPrototype is IVariableArray variableArray) array = variableArray;
                    else break;
                }
                else break;
            }
        }

        protected void GetArrayIndicesAndSizes(IVariableArray array, out IVariableDeclaration[] indexVars, out IExpression[] sizes)
        {
            IList<Range> ranges = array.Ranges;
            sizes = new IExpression[ranges.Count];
            indexVars = new IVariableDeclaration[ranges.Count];
            int i = 0;
            foreach (Range r in ranges)
            {
                SearchRange(r);
                indexVars[i] = r.GetIndexDeclaration();
                sizes[i] = r.GetSizeExpression();
                i++;
            }
        }

        /// <summary>
        /// Define a given variable in the MSL.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="variable"></param>
        /// 
        protected void BuildGiven<T>(Variable<T> variable)
        {
            if (variable.IsBase)
            {
                IParameterDeclaration ipd = (IParameterDeclaration)variable.GetDeclaration();
                modelMethod.Parameters.Add(ipd);
                FinishGivenOrConstant(variable, ipd);
                // must do this after the sizes are built
                observedVars.Add(variable);
            }
            else if (variable.IsArrayElement)
            {
                // do nothing
            }
            else
            {
                throw new NotImplementedException("Unhandled given type: " + variable);
            }
        }

        private void FinishGivenOrConstant(Variable variable, object decl)
        {
            if (variable is IVariableArray iva)
            {
                // attach a VariableInformation attribute that holds the array sizes
                // this is needed because the array size never appears in the code
                IList<IVariableDeclaration[]> jaggedIndexVars;
                IList<IExpression[]> jaggedSizes;
                GetJaggedArrayIndicesAndSizes(iva, out jaggedIndexVars, out jaggedSizes);
                var vi = new VariableInformation(decl);
                vi.sizes.AddRange(jaggedSizes);
                vi.indexVars.AddRange(jaggedIndexVars);
                Attributes.Set(decl, vi);

                // see ModelTests.RangeWithConstantSizeTest
                bool addLengthConstraints = false;
                if (addLengthConstraints)
                {
                    IExpression array = variable.GetExpression();
                    IExpression valueIsNotNull = Builder.BinaryExpr(array, BinaryOperator.ValueInequality, Builder.LiteralExpr(null));
                    IConditionStatement cs = Builder.CondStmt(valueIsNotNull, Builder.BlockStmt());
                    var constraint = new Action<int, int>(Microsoft.ML.Probabilistic.Factors.Constrain.Equal);
                    Type arrayType = array.GetExpressionType();
                    int rank = vi.sizes[0].Length;
                    //Util.GetElementType(arrayType, out rank);
                    for (int i = 0; i < rank; i++)
                    {
                        IExpression lengthExpr;
                        if (rank == 1)
                        {
                            lengthExpr = Builder.PropRefExpr(array, arrayType, arrayType.IsArray ? "Length" : "Count", typeof(int));
                        }
                        else
                        {
                            lengthExpr = Builder.Method(array, typeof(Array).GetMethod("GetLength"), Builder.LiteralExpr(i));
                        }
                        cs.Then.Statements.Add(Builder.ExprStatement(
                            Builder.StaticMethod(constraint, lengthExpr, vi.sizes[0][i])));
                    }
                    AddStatement(cs);
                }
            }
        }

        public string ModelString()
        {
            return CodeCompiler.DeclarationToString(modelType);
        }
    }

    /// <summary>
    /// Attached to assignment statements to indicate that they are not really assignments but equality constraints between the left and right hand side.
    /// </summary>
    internal class Constraint : ICompilerAttribute
    {
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\Infer\Models\ModelBuilder.cs(470,58): error CS0136: A local or parameter named 'hasItemVariables' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Compiler.Graphs;
using Microsoft.ML.Probabilistic.Factors;
using System.Linq;
using Microsoft.ML.Probabilistic.Models.Attributes;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// The group transform deals with all aspects of group handling
    /// It creates groups as necessary for deterministic factors and constraints
    /// and changes the group annotations into MessagePath annotations on factor expressions.
    /// It also creates related annotations (ChannelPath attributes) on variable declarations
    /// so that the message transform knows what type of variables to create.
    /// </summary>
    /// <remarks>
    /// The group transform has the following steps:
    /// 
    /// 1. Builds a bipartite factor graph of factors and variables. This is done using the
    ///    transform framework. This will also create groups for deterministic factors and
    ///    constraints
    ///
    /// 2. For each existing group (i.e. manually specified group) consisting of more than one
    ///    variable expression, picks a variable, and finds the shortest path from that variable
    ///    to all other variables in the group. Add all nodes in the path to the group.
    ///    
    /// 3a. For any deterministic factor which is not a variable factor, creates a group
    ///     for each input argument, and add the output argument (unless such a pair exists)
    /// 3b. Similarly for constraints, where the first argument to the constraint acts as
    ///     the output argument.
    ///     
    /// 4. For each variable factor, if any argument is in a group, ensures that all other arguments
    ///     are in the group.
    ///     
    /// 5. Finds the root of each group. With the current architecture, the root variable cannot
    ///    be on the 'uses' side of any other variable in the group. This is because 'uses' are
    ///    currently treated as a whole in terms of type, and if one of the uses (or anything downstream)
    ///    were picked as the root, then one of the uses would need to be a different type.
    ///    The exception to this is GateExitRandom which is used for variables defined within
    ///    a gate - in this case, the root must be the exit side. 
    ///    
    ///       NOTE: In future, it would be nice to have a factor which allowed one of the uses to be
    ///       treated differently from all the other uses. This factor could then be inserted in situations
    ///       where roots were manually specified the uses side of any variable in the group. This would
    ///       require that the Group transform should go before the Channel transform so that we can
    ///       insert the correct type of variable factor
    ///    
    /// 6. Calculates distances from the root for each group
    ///    
    /// 7. Loops through the factor expressions, and call the algorithm to set the paths.
    ///    for the MessagePath attributes. This is done whether or not the expression
    ///    participates in a group.
    ///
    /// 8. Traverses the factor graph to create the ChannelPath attributes
    /// </remarks>
    internal class GroupTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "GroupTransform"; }
        }

        // The algorithm instance 
        protected IAlgorithm algorithm;

        private VariableGroup currentGroup = null;
        private GroupNode currentRoot = null;
        private IVariableDeclaration currentConditionVar;

        // The factor graph
        private Graph<GroupNode> factorGraph = new Graph<GroupNode>();

        // A dictionary of nodes in the factor graph keyed by variable declaration
        private Dictionary<IVariableDeclaration, GroupNode> nodeOfVariable = new Dictionary<IVariableDeclaration, GroupNode>();

        // List of factor expression nodes
        private List<GroupNode> factorExpressionNodes = new List<GroupNode>();

        // Dictionary mapping variable group to group member root node
        private Dictionary<VariableGroup, GroupMemberWithDistanceCount> rootOfGroup = new Dictionary<VariableGroup, GroupMemberWithDistanceCount>();

        // Dictionary mapping variable group to its GroupNodes
        private Dictionary<VariableGroup, ICollection<GroupNode>> nodesInGroup = new Dictionary<VariableGroup, ICollection<GroupNode>>();

        // The set of automatically generated groups
        private Set<VariableGroup> generatedGroups = new Set<VariableGroup>();

        /// <summary>
        /// Constucts a Group transform
        /// </summary>
        /// <param name="algorithm"></param>
        public GroupTransform(IAlgorithm algorithm)
            : base()
        {
            this.algorithm = algorithm;
        }

        protected override void DoConvertMethodBody(IList<IStatement> outputs, IList<IStatement> inputs)
        {
            base.DoConvertMethodBody(outputs, inputs);
            if (context.Results.IsErrors()) return;
            // Convert variable reference dependencies into statement dependencies.
            PostProcessDependencies();
        }

        // Create any missing groups for deterministic factors
        private void CreateMissingGroups(GroupNode gn)
        {
            if (!gn.IsFactorNode) return;
            if (gn.isVariableFactor) return;
            if (!gn.isDeterministic) return;

            IVariableDeclaration anchorDecl = gn.anchorNode.variableDeclaration;
            int parentIndex = 0;
            foreach (GroupNode vgn in gn.Neighbors)
            {
                if (object.ReferenceEquals(vgn, gn.anchorNode))
                    continue;
                parentIndex++;
                if (gn.isGateExit && parentIndex != 2) continue;
                IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(vgn.variableDeclaration);
                // See if there is a common group between this node and the anchor node.
                // If not, add a group member                    
                if (findGroupMatch(anchorDecl, vgn.variableDeclaration) == null)
                {
                    VariableGroup vg = new VariableGroup();
                    vg.Name = gn.factorExpression.Method.Method.Name + groupCount;
                    groupCount++;
                    generatedGroups.Add(vg);
                    nodesInGroup.Add(vg, new Set<GroupNode>());
                    nodesInGroup[vg].Add(gn.anchorNode);
                    context.OutputAttributes.Add(anchorDecl, new GroupMember(vg, false));
#if writeToConsole
                    Console.WriteLine("Creating group "+vg+" for ("+anchorDecl.Name+","+vgn.variableDeclaration.Name+")");
#endif
                    AddOrMergeGroups(vgn, vg);
                }
            }
        }

        /// <summary>
        /// Used for assigning unique names to groups
        /// </summary>
        private int groupCount;

        // Attach distance counters.
        private void AttachGroupInfo(GroupNode vgn)
        {
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(vgn.variableDeclaration);
            vgn.AttachGroupMembers(gms);
        }

        /// <summary>
        /// Mark distance from current root
        /// </summary>
        /// <param name="edge"></param>
        private void MarkDistanceFromRoot(Edge<GroupNode> edge)
        {
            GroupNode sgn = edge.Source;
            GroupNode tgn = edge.Target;
#if writeToConsole
            Console.WriteLine(sgn+" ("+sgn.currentDistance+") -> "+tgn);
#endif
            tgn.currentDistance = sgn.currentDistance + 1;
        }

        /// <summary>
        /// Attach distances for current group
        /// </summary>
        /// <param name="gn"></param>
        private void AttachDistances(GroupNode gn)
        {
            if (gn.IsFactorNode)
                return;

            foreach (GroupMemberWithDistanceCount tgm in gn.groupMembers)
            {
                if (tgm.group.Equals(currentGroup))
                {
                    tgm.distance = gn.currentDistance;
#if writeToConsole
                    Console.WriteLine("Distance of {0} from root: {1})", gn.variableDeclaration, tgm.distance);
#endif
                }
            }
        }

        // Create message path attributes from a factor to a variable. The paths are filled in by
        // the algorithm.
        private void CreateMessagePathAttr(GroupNode fgn, GroupNode vgn)
        {
            if (vgn.groupMembers == null) return;
            foreach (GroupMemberWithDistanceCount vgm in vgn.groupMembers)
            {
                string toName = fgn.argumentMap[vgn];
                foreach (GroupNode sgn in fgn.Neighbors)
                {
                    string fromName = fgn.argumentMap[sgn];
                    if (toName == fromName)
                        continue;
                    GroupMemberWithDistanceCount sgm = null;
                    foreach (GroupMemberWithDistanceCount gmwdc in sgn.groupMembers)
                        if (gmwdc.group == vgm.group)
                        {
                            sgm = gmwdc;
                            break;
                        }

                    if (sgm == null)
                        continue;
                    context.OutputAttributes.Add(fgn.factorExpression, new MessagePathAttribute(fromName, toName, sgm.distance, vgm.distance));
                }
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

        // Create channel path attributes for a given variable to factor. These are all the
        // messages paths (if any) which are associated with a given channel, and whether
        // backwards or forwards
        // Note: we never need to attach CurrentSample ChannelPaths, since that is the default
        private void CreateChannelPaths(GroupNode vgn)
        {
            if (vgn.IsFactorNode)
                return;

            Set<ChannelPathAttribute> cpas = Set<ChannelPathAttribute>.FromEnumerable(context.OutputAttributes.GetAll<ChannelPathAttribute>(vgn.variableDeclaration));

            // Loop through all attached factors
            int factorCount = 0;
            foreach (GroupNode fgn in vgn.Neighbors)
            {
                if (fgn.isVariableFactor) continue;
                factorCount++;
                // Get the factor node message path attributes
                var mpas = context.OutputAttributes.GetAll<MessagePathAttribute>(fgn.factorExpression);

                bool isOutput = factorGraph.ContainsEdge(fgn, vgn);
                bool hasStochasticSource = false;

                // We are going from this variable to the factor
                string fromName = fgn.argumentMap[vgn];
                // Loop through all the variables attached to this factor
                foreach (GroupNode sgn in fgn.Neighbors)
                {
                    if (sgn == vgn && fgn.Neighbors.Count != 1) continue;
                    string toName = fgn.argumentMap[sgn];
                    // Look for all message paths which match the from/to
                    foreach (MessagePathAttribute mpa in mpas)
                    {
                        if (mpa.AppliesTo(fromName, toName))
                        {
                            ChannelPathAttribute cpa = new ChannelPathAttribute(mpa.Path, isOutput ? MessageDirection.Backwards : MessageDirection.Forwards, mpa.IsDefault);
                            if (!cpas.Contains(cpa))
                            {
                                cpas.Add(cpa);
                                context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                            }
                        }
                        else if (mpa.AppliesTo(toName, fromName))
                        {
                            bool ignoreSource = fgn.isGateExit && IsFirstParent(fgn, sgn);
                            if (mpa.Path == "Distribution" && !ignoreSource) hasStochasticSource = true;
                        }
                    }
                }
                if (false)
                {
                    if (hasStochasticSource || (!fgn.isDeterministic && !(fgn.isGateExit && !isOutput)))
                    {
                        ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", isOutput ? MessageDirection.Forwards : MessageDirection.Backwards, false);
                        if (!cpas.Contains(cpa))
                        {
                            cpas.Add(cpa);
                            context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                        }
                    }
                }
                else
                {
                    if (isOutput && fgn.isDeterministic && !hasStochasticSource)
                    {
                        // a deterministic factor with all deterministic inputs will send a sample to the output variable
                    }
                    else if ((fgn.isGateExit && fromName == "values" && !hasStochasticSource) ||
                             (fgn.isCopy && fromName == "value" && !hasStochasticSource))
                    {
                        // Gate.ExitRandom sends a sample to values
                        // Factor.Copy sends a sample to value
                    }
                    else
                    {
                        // all other factors will send a distribution to the variable
                        ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", isOutput ? MessageDirection.Forwards : MessageDirection.Backwards, false);
                        if (!cpas.Contains(cpa))
                        {
                            cpas.Add(cpa);
                            context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                        }
                    }
                }
            }
            if (factorCount == 0)
            {
                // vgn must be a marginal channel or an unused uses channel
                ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", MessageDirection.Backwards, false);
                context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif

        // Check if a node is in a group. If no, add it, and add it to the list of nodes
        // for that variable group
        internal void checkAndAddToGroup(GroupNode gn, VariableGroup vg)
        {
            // See if the node is already in the group
            bool found = false;
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                if (object.ReferenceEquals(gm.Group, vg))
                {
                    found = true;
                    break;
                }
            }
            // Not in the group so add it
            if (!found)
            {
                GroupMember gm = new GroupMember(vg, false);
                context.OutputAttributes.Add(gn.variableDeclaration, gm);
                nodesInGroup[vg].Add(gn);
            }
        }

        private void AddOrMergeGroups(GroupNode gn, VariableGroup vg)
        {
            // does the node already belong to any groups?
            VariableGroup existingGroup = null;
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                existingGroup = gm.Group;
                break;
            }
            if (existingGroup == vg) return; // already in this group
            context.OutputAttributes.Add(gn.variableDeclaration, new GroupMember(vg, false));
            nodesInGroup[vg].Add(gn);
            if (existingGroup != null)
            {
                // merge groups
                if (generatedGroups.Contains(vg))
                {
                    MergeGroups(vg, existingGroup);
                }
                else if (generatedGroups.Contains(existingGroup))
                {
                    MergeGroups(existingGroup, vg);
                }
                else
                {
                    Error("Groups " + vg + " and " + existingGroup + " have an invalid overlap.  Try merging them into one group.");
                }
            }
        }

        private void MergeGroups(VariableGroup child, VariableGroup parent)
        {
            if (child == parent) return;
#if writeToConsole
            Console.WriteLine("Merging group "+child+" into group "+parent);
#endif
            ICollection<GroupNode> childNodes = nodesInGroup[child];
            ICollection<GroupNode> parentNodes = nodesInGroup[parent];
            // move all childNodes to the parent group
            foreach (GroupNode gn in childNodes)
            {
                bool alreadyInParentGroup = parentNodes.Contains(gn);
                if (!alreadyInParentGroup) parentNodes.Add(gn);
                if (gn.variableDeclaration == null) continue;
                if (!alreadyInParentGroup) context.InputAttributes.Add(gn.variableDeclaration, new GroupMember(parent, false));
                var newGroups = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration)
                    .Where(gm => gm.Group != child);
                context.InputAttributes.Remove<GroupMember>(gn.variableDeclaration);
                foreach (GroupMember gm in newGroups) context.InputAttributes.Add(gn.variableDeclaration, gm);
            }
            nodesInGroup.Remove(child);
        }

        private IEnumerable<GroupNode> ChildDetFactorsOf(GroupNode gn)
        {
            foreach (GroupNode childNode in gn.Targets)
            {
                foreach (GroupNode gn2 in childNode.Neighbors)
                {
                    if (gn2 == gn) continue;
                    if (!gn2.IsFactorNode || !(gn2.isDeterministic || gn2.isGateExit || gn2.isVariableFactor) || gn2.Targets.Count == 0) continue;
                    yield return gn2;
                }
            }
        }

        private bool IsFirstParent(GroupNode fn, GroupNode vn)
        {
            foreach (GroupNode tn in fn.Sources)
            {
                return (tn == vn);
            }
            return false;
        }

        private IEnumerable<GroupNode> TargetsInGroup(ICollection<GroupNode> nodes, GroupNode gn)
        {
            foreach (GroupNode gn2 in gn.Targets)
            {
                if (gn2.IsFactorNode || nodes.Contains(gn2)) yield return gn2;
            }
        }

        private IEnumerable<GroupNode> NeighborsInGroup(ICollection<GroupNode> nodes, GroupNode gn)
        {
            foreach (GroupNode gn2 in gn.Neighbors)
            {
                if (gn2.IsFactorNode || nodes.Contains(gn2)) yield return gn2;
            }
        }

        private IEnumerable<GroupNode> NeighborsInSameGate(GroupNode gn)
        {
            if (gn.conditionVar != null)
            {
                foreach (GroupNode gn2 in gn.Neighbors)
                {
                    if (gn2.conditionVar == gn.conditionVar) yield return gn2;
                }
            }
        }

        private bool IsDefinitionChannel(IVariableDeclaration ivd)
        {
            ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(ivd);
            return ci != null && ci.IsDef;
        }

        private void WriteGroups(GroupNode gn)
        {
            Console.Write(gn + " groups: ");
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                Console.Write(gm.Group);
                Console.Write(" ");
            }
            Console.WriteLine();
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

        /// <summary>
        /// Post-process dependencies. Converts GroupMember attributes to MessagePath attributes
        /// </summary>
        internal void PostProcessDependencies()
        {
            BreadthFirstSearch<GroupNode> bfs;

#if writeToConsole
            if (false) {
                foreach (GroupNode gn in factorGraph.Nodes) {
                    foreach (GroupNode target in factorGraph.TargetsOf(gn)) {
                        Console.WriteLine(" {0} -> {1}", gn, target);
                    }
                }
                Console.WriteLine();
            }
#endif

            if (true)
            {
                // Check that each group is connected
                ICollection<GroupNode> nodes = null;
                bfs = new BreadthFirstSearch<GroupNode>(gn => NeighborsInGroup(nodes, gn), factorGraph);
                bfs.DiscoverNode += delegate(GroupNode node) { node.currentDistance = 0; };
                foreach (KeyValuePair<VariableGroup, ICollection<GroupNode>> kvp in nodesInGroup)
                {
                    // The variable group
                    VariableGroup vg = kvp.Key;
                    // All the nodes in the factor graph which are currently in this group
                    List<GroupNode> groupNodes = new List<GroupNode>(kvp.Value);
                    // If only 1, then no need to do anything
                    if (groupNodes.Count <= 1)
                        continue;
                    nodes = kvp.Value;
                    // Reset distances
                    foreach (GroupNode gn in nodes)
                    {
                        gn.currentDistance = -1;
                    }

                    bfs.Clear();
                    GroupNode start = groupNodes[0];
                    bfs.SearchFrom(start);

                    // Check that all nodes in group have nonnegative distance
                    foreach (GroupNode gn in nodes)
                    {
                        if (gn.currentDistance < 0)
                        {
                            Error("Group " + vg + " is not connected (could not reach " + gn + " from " + start + ")");
                            return;
                        }
                    }
                }
            }
            if (true)
            {
                // Check that there is no path from a stochastic var to another stochastic var in the same gate
                GroupNode stocVarNode = null;
                var dfsStoc = new DepthFirstSearch<GroupNode>(NeighborsInSameGate, factorGraph);
                dfsStoc.DiscoverNode += delegate(GroupNode node)
                    {
                        if (node != stocVarNode && !node.IsFactorNode && !context.InputAttributes.Has<DerivedVariable>(node.variableDeclaration) &&
                            IsDefinitionChannel(node.variableDeclaration))
                        {
                            Error("Gibbs Sampling does not support two random variables '" + node.variableDeclaration.Name + "' and '" + stocVarNode.variableDeclaration.Name +
                                  "' in the same condition block");
                        }
                    };
                foreach (GroupNode node in factorGraph.Nodes)
                {
                    if (node.IsFactorNode || context.InputAttributes.Has<DerivedVariable>(node.variableDeclaration) || !IsDefinitionChannel(node.variableDeclaration))
                        continue;
                    stocVarNode = node;
                    dfsStoc.SearchFrom(node);
                }
            }

            // Create groups for equality constraints
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (!gn.isConstrainEqual) continue;
                CreateMissingGroups(gn);
            }

            //-----------------------------------------------------
            // Mark all deterministic factors with groups if they
            // are not manually marked
            //-----------------------------------------------------
            DepthFirstSearch<GroupNode> dfs = new DepthFirstSearch<GroupNode>(ChildDetFactorsOf, factorGraph);
            // an exit variable may be the child of multiple factors.  we want to group with the firstParent of only one of them.
            Set<GroupNode> variablesChecked = new Set<GroupNode>();
            dfs.FinishNode += delegate(GroupNode gn)
                {
                    if (gn.isDeterministic || gn.isVariableFactor)
                    {
                        Set<GroupNode> parents = new Set<GroupNode>();
                        int ignoreCount = 0;
                        // for GateExit we want to ignore the first argument
                        if (gn.isGateExit) ignoreCount = 1;
                        GroupNode firstParent = null;
                        foreach (GroupNode vgn in gn.Sources)
                        {
                            if (ignoreCount > 0)
                            {
                                ignoreCount--;
                                continue;
                            }
                            parents.Add(vgn);
                            if (firstParent == null) firstParent = vgn;
                        }
                        foreach (GroupNode childNode in gn.Targets)
                        {
                            if (firstParent != null && !variablesChecked.Contains(childNode))
                            {
                                // check all groups of the child variable
                                List<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(childNode.variableDeclaration);
                                foreach (GroupMember gm in gms)
                                {
                                    ICollection<GroupNode> nodes = nodesInGroup[gm.Group];
                                    // does the group contain any parent?
                                    bool containsAnyParent = nodes.ContainsAny(parents);
                                    if (!containsAnyParent)
                                    {
                                        // add the first parent to the group
#if writeToConsole
                                    Console.WriteLine("adding firstParent "+firstParent+" of "+childNode+" to group "+gm.Group);
#endif
                                        AddOrMergeGroups(firstParent, gm.Group);
                                    }
                                }
                                variablesChecked.Add(childNode);
                            }
                        }
                    }
                    CreateMissingGroups(gn);
                };
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                if (!(fgn.isDeterministic || fgn.isGateExit || fgn.isVariableFactor) || fgn.Targets.Count == 0) continue;
                dfs.SearchFrom(fgn);
            }

            //--------------------------------------------
            // Attach the distance counters to the nodes
            //--------------------------------------------
            foreach (GroupNode vgn in factorGraph.Nodes)
                if (!vgn.IsFactorNode)
                    AttachGroupInfo(vgn);

            //-----------------------------------------------------
            // For each factor with a child node, mark any child variable node
            // group members as 'cannotBeRoot' if there is a parent
            // variable node within the same group (this is overridden if
            // a group has been manually set)
            //-----------------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                foreach (GroupNode childNode in fgn.Targets)
                {
                    foreach (GroupMemberWithDistanceCount gmdc in childNode.groupMembers)
                    {
                        VariableGroup vg = gmdc.group;
                        ICollection<GroupNode> nodes = nodesInGroup[vg];
                        // root must be a parent
                        // Is there a parent variable in the same group?
                        bool foundParent = false;
                        foreach (GroupNode vgn in fgn.Sources)
                        {
                            if (nodes.Contains(vgn))
                            {
                                foundParent = true;
                                break;
                            }
                        }
                        if (foundParent)
                        {
                            // If there is a parent in the same group, then the child cannot be a root
                            gmdc.cannotBeRoot = true;
                        }
                    }
                }
            }

            //---------------------------------------------------
            // Set up the group dictionary to point to the roots
            //---------------------------------------------------
            int grpCount = 0;
            int numGroups = nodesInGroup.Count;
            rootOfGroup.Clear();
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (gn.IsFactorNode) continue;

                foreach (GroupMemberWithDistanceCount gmdc in gn.groupMembers)
                {
                    if (gmdc.cannotBeRoot && !gmdc.groupMember.IsRoot)
                        continue;
                    GroupMember gm = gmdc.groupMember;
                    VariableGroup vg = gm.Group;
                    bool previouslyAssigned = rootOfGroup.ContainsKey(vg);
                    // Manually assigned root overrides 'cannotBeRoot'
                    if ((!previouslyAssigned) || gmdc.groupMember.IsRoot)
                    {
                        if (previouslyAssigned)
                        {
#if writeToConsole
                            Console.WriteLine("Undo {0} as root of {1}", rootOfGroup[vg].groupNode, vg);
#endif
                            rootOfGroup[vg].groupMember.IsRoot = false;
                            rootOfGroup.Remove(vg);
                        }
                        else
                        {
                            grpCount++;
                        }
                        IVariableDeclaration ivd = gmdc.groupNode.variableDeclaration;
                        if (context.InputAttributes.GetAll<GroupMember>(ivd).Count > 1)
                            Error("Variable '" + ivd.Name + "' belongs to multiple groups so it cannot be a root");
#if writeToConsole
                        Console.WriteLine("{0} is root of {1}", gn, vg);
#endif
                        gm.IsRoot = true;
                        rootOfGroup.Add(vg, gmdc);
                    }
                    if (grpCount >= numGroups)
                        break;
                }
            }

            if (rootOfGroup.Count != nodesInGroup.Count)
                Error("Cannot find root for " + (nodesInGroup.Count - rootOfGroup.Count).ToString(CultureInfo.InvariantCulture) + " groups");

            //--------------------------------------------
            // Mark distances for each variable group
            //--------------------------------------------
            if (true)
            {
                ICollection<GroupNode> nodes = null;
                bfs = new BreadthFirstSearch<GroupNode>(gn => NeighborsInGroup(nodes, gn), factorGraph);
                bfs.TreeEdge += MarkDistanceFromRoot;
                bfs.FinishNode += AttachDistances;
                foreach (KeyValuePair<VariableGroup, GroupMemberWithDistanceCount> kvp in rootOfGroup)
                {
                    currentGroup = kvp.Key;
                    nodes = nodesInGroup[currentGroup];
                    foreach (GroupNode gn in nodes)
                        gn.currentDistance = -1;
                    currentRoot = kvp.Value.groupNode;
                    currentRoot.currentDistance = 0;

                    // Find the distances from the root
#if writeToConsole
                    Console.WriteLine("\n\nGroup {0}. From root ({1})", currentGroup, currentRoot.variableDeclaration);
#endif
                    bfs.Clear();
                    bfs.SearchFrom(currentRoot);
                }
            }
            else
            {
                // TODO: change above to use this method of computing distances
                foreach (KeyValuePair<VariableGroup, GroupMemberWithDistanceCount> kvp in rootOfGroup)
                {
                    currentGroup = kvp.Key;
                    currentRoot = kvp.Value.groupNode;

                    // Attach the distances to the GroupMembers
#if writeToConsole
                    Console.WriteLine("\n\nGroup {0}. From root ({1})", currentGroup, currentRoot.variableDeclaration);
#endif
                    // Find the distances from the root
                    DistanceSearch<GroupNode> distSearch = new DistanceSearch<GroupNode>(factorGraph);
                    //distSearch.Clear();
                    distSearch.SetDistance += delegate(GroupNode gn, int distance)
                        {
                            gn.currentDistance = distance;
                            AttachDistances(gn);
                        };
                    distSearch.SearchFrom(currentRoot);
                }
            }

            //--------------------------------------------
            // Initialise the message path attributes
            //--------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                if (fgn.isVariableFactor) continue;
                foreach (GroupNode vgn in factorGraph.NeighborsOf(fgn))
                    CreateMessagePathAttr(fgn, vgn);
            }

            //--------------------------------------------
            // Now let the algorithm modify message paths,
            // or create default message paths. This needs
            // to be done whether or not there are groups
            //--------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
                algorithm.ModifyFactorAttributes(fgn.factorExpression, context.OutputAttributes);

            //--------------------------------------------
            // Create the channel path attributes
            //--------------------------------------------
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (gn.IsFactorNode) continue;
                CreateChannelPaths(gn);
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif

        // See if two variable declarations share a common group
        private VariableGroup findGroupMatch(IVariableDeclaration ivd1, IVariableDeclaration ivd2)
        {
            IList<GroupMember> gms1 = context.InputAttributes.GetAll<GroupMember>(ivd1);
            IList<GroupMember> gms2 = context.InputAttributes.GetAll<GroupMember>(ivd2);
            foreach (GroupMember gm1 in gms1)
            {
                foreach (GroupMember gm2 in gms2)
                    if (object.ReferenceEquals(gm2.Group, gm1.Group))
                        return gm2.Group;
            }
            return null;
        }

        // See if a variable is in a particular group
        private GroupMember findGroupMatch(VariableGroup vg, IVariableDeclaration ivd)
        {
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(ivd);
            GroupMember match = null;
            foreach (GroupMember gm in gms)
            {
                if (object.ReferenceEquals(gm.Group, vg))
                {
                    match = gm;
                    break;
                }
            }
            return match;
        }

        protected override IVariableDeclaration ConvertVariableDecl(IVariableDeclaration ivd)
        {
            if (CodeRecognizer.IsStochastic(context, ivd))
            {
                GroupNode vgn;
                if (!nodeOfVariable.TryGetValue(ivd, out vgn))
                {
                    vgn = GroupNode.FromVariable(ivd);
                    nodeOfVariable[ivd] = vgn;
                    factorGraph.Nodes.Add(vgn);
                }
                vgn.conditionVar = currentConditionVar;
            }
            return base.ConvertVariableDecl(ivd);
        }

        protected override IStatement ConvertExpressionStatement(IExpressionStatement ies)
        {
            // This bit of code builds the factor graph. We are only interested in factor expressions
            // with or without a LHS

            // Is this from assignment?
            IAssignExpression iae = ies.Expression as IAssignExpression;

            // Get the target if any
            IVariableDeclaration targetVarDecl = null;
            IExpression targetExpression = null;
            if (iae != null)
            {
                targetExpression = iae.Target;
                // The following should return null if the variable is observed (as the targetExpression
                // is an argument reference expression. This situation will then be dealt with
                // as a constraint
                targetVarDecl = Recognizer.GetVariableDeclaration(targetExpression);
                // ignore constants
                if (targetVarDecl != null && !CodeRecognizer.IsStochastic(context, targetVarDecl)) targetVarDecl = null;
            }

            IMethodInvokeExpression factorExpression;
            if (iae == null)
                factorExpression = ies.Expression as IMethodInvokeExpression;
            else
                factorExpression = iae.Expression as IMethodInvokeExpression;

            FactorManager.FactorInfo info = null;

            // Factor information to get field names
            if (factorExpression != null)
                info = CodeRecognizer.GetFactorInfo(context, factorExpression);
            if (factorExpression != null && info != null && CodeRecognizer.IsStochastic(context, factorExpression))
            {
                bool isDeterministic = info.IsDeterministicFactor;
                bool isVariable = context.InputAttributes.Has<IsVariableFactor>(factorExpression);
                bool isGateExit = (info.Method.DeclaringType == typeof (Gate) && info.Method.Name.StartsWith("Exit"));
                bool isGateEnter = (info.Method.DeclaringType == typeof (Gate) && info.Method.Name.StartsWith("Enter"));
                bool isCopy = (info.Method.DeclaringType == typeof (Factor) && info.Method.Name == "Copy");
                bool isCasesCopy = context.InputAttributes.Has<CasesCopy>(factorExpression);
                bool isConstrainEqual = (info.Method.DeclaringType == typeof (Constrain) && info.Method.Name == "Equal");

                // Create and add the factor node
                GroupNode exprNode = GroupNode.FromExpression(factorExpression);
                exprNode.isDeterministic = isDeterministic;
                exprNode.isVariableFactor = isVariable;
                exprNode.isGateExit = isGateExit;
                exprNode.isGateEnter = isGateEnter;
                exprNode.isCopy = isCopy;
                exprNode.isConstrainEqual = isConstrainEqual;
                exprNode.conditionVar = currentConditionVar;
                factorGraph.Nodes.Add(exprNode);
                factorExpressionNodes.Add(exprNode);

                int fieldIndex = 0;
                // If the target variable is not already in the graph, create the node and add it
                GroupNode targetGN = null;
                if (targetVarDecl != null)
                {
                    string tgtArgName = info.ParameterNames[fieldIndex++];
                    if (!nodeOfVariable.TryGetValue(targetVarDecl, out targetGN))
                    {
                        targetGN = GroupNode.FromVariable(targetVarDecl);
                        nodeOfVariable.Add(targetVarDecl, targetGN);
                        factorGraph.Nodes.Add(targetGN);
                    }
                    // Update the factor mapping
                    exprNode.argumentMap.Add(targetGN, tgtArgName);
                    factorGraph.AddEdge(exprNode, targetGN);
                    //factorGraph.AddEdge(targetGN, exprNode);
                    IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(targetVarDecl);
                    foreach (GroupMember gm in gms)
                    {
                        //gm.IsRoot = false; // Do not allow manual setting of root
                        ICollection<GroupNode> nodes;
                        if (!nodesInGroup.TryGetValue(gm.Group, out nodes))
                        {
                            nodes = new Set<GroupNode>();
                            nodesInGroup[gm.Group] = nodes;
                        }
                        if (!nodes.Contains(targetGN))
                            nodes.Add(targetGN);
                    }
                    exprNode.anchorNode = targetGN;
                }

                for (int i = 0; i < factorExpression.Arguments.Count; i++)
                {
                    string srcArgName = info.ParameterNames[fieldIndex++];
                    IExpression arg = factorExpression.Arguments[i];
                    while (arg is IMethodInvokeExpression)
                    {
                        IMethodInvokeExpression imie2 = (IMethodInvokeExpression) arg;
                        if (imie2.Arguments.Count == 0) break;
                        arg = imie2.Arguments[0];
                    }
                    bool isOut = (arg is IAddressOutExpression);
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(arg);
                    if (ivd == null || !CodeRecognizer.IsStochastic(context, ivd))
                        continue;
                    GroupNode sourceGN;
                    if (!nodeOfVariable.TryGetValue(ivd, out sourceGN))
                    {
                        sourceGN = GroupNode.FromVariable(ivd);
                        nodeOfVariable.Add(ivd, sourceGN);
                        factorGraph.Nodes.Add(sourceGN);
                    }
                    // Update the factor mapping
                    exprNode.argumentMap.Add(sourceGN, srcArgName);
                    // Do not create an edge between a GateEnter factor and its first argument ("cases")
                    if (!(isGateEnter && i == 0))
                    {
                        if (isOut) factorGraph.AddEdge(exprNode, sourceGN);
                        else factorGraph.AddEdge(sourceGN, exprNode);
                    }

                    if (exprNode.anchorNode == null)
                        exprNode.anchorNode = sourceGN;
                    IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(ivd);
                    foreach (GroupMember gm in gms)
                    {
                        //gm.IsRoot = false; // Do not allow manual setting of root
                        ICollection<GroupNode> nodes;
                        if (!nodesInGroup.TryGetValue(gm.Group, out nodes))
                        {
                            nodes = new Set<GroupNode>();
                            nodesInGroup[gm.Group] = nodes;
                        }
                        if (!nodes.Contains(sourceGN))
                            nodes.Add(sourceGN);
                    }
                }
            }

            // Call the base class
            ConvertExpression(ies.Expression);
            return ies;
        }

        /// <summary>
        /// Shallow copy of for statement
        /// </summary>
        protected override IStatement ConvertFor(IForStatement ifs)
        {
            // We do not convert the loop counter declaration or increment.  We only convert
            // the loop size which is the right hand size of the loop condition.
            IBinaryExpression ibe = ifs.Condition as IBinaryExpression;
            if (ibe == null)
            {
                Error("For loop conditions must be binary expressions, was :" + ifs.Condition);
            }
            else
            {
                IVariableDeclaration loopVar = CodeRecognizer.Instance.GetVariableDeclaration(ibe.Left);
                if (loopVar == null)
                    Error("For loop conditions have loop counter reference on LHS, was :" + ibe.Left);
                if ((ibe.Right is ILiteralExpression) && 0.Equals(((ILiteralExpression) ibe.Right).Value))
                {
                    // loop of zero length
                    return null;
                }
                ConvertExpression(ibe.Right);
            }
            ConvertBlock(ifs.Body);
            return ifs;
        }

        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            ConvertExpression(ics.Condition);
            IVariableDeclaration oldConditionVar = currentConditionVar;
            if (currentConditionVar == null && CodeRecognizer.IsStochastic(context, ics.Condition))
                currentConditionVar = Recognizer.GetVariableDeclaration(ics.Condition);
            context.SetPrimaryOutput(ics);
            ConvertBlock(ics.Then);
            if (ics.Else != null) ConvertBlock(ics.Else);
            currentConditionVar = oldConditionVar;
            return ics;
        }
    }

    // Wraps group member with distant count
    internal class GroupMemberWithDistanceCount
    {
        public GroupMember groupMember; // Wrapped group member
        public GroupNode groupNode; // Owner

        public VariableGroup group
        {
            get { return groupMember.Group; }
        }

        public int distance;
        public bool cannotBeRoot = false;

        public GroupMemberWithDistanceCount(GroupNode gn, GroupMember gm)
        {
            groupNode = gn;
            groupMember = gm;
            distance = -1;
        }

        public override string ToString()
        {
            return String.Format("Distance {0})", distance);
        }
    }

    // Node in factor graph which carries group information
    internal class GroupNode : DirectedNode<GroupNode>, ICloneable
    {
        /// <summary>
        /// For a factor node, this is always null.
        /// </summary>
        public IVariableDeclaration variableDeclaration;

        /// <summary>
        /// For a node inside a gate, stores the conditionVar.  Otherwise null.
        /// </summary>
        public IVariableDeclaration conditionVar;

        /// <summary>
        /// Stores distance info for each group that this variable is a member of.
        /// </summary>
        public IList<GroupMemberWithDistanceCount> groupMembers;

        /// <summary>
        /// For a variable node, this is always null.
        /// </summary>
        public IMethodInvokeExpression factorExpression;

        public IDictionary<GroupNode, string> argumentMap;
        public bool isDeterministic;
        public bool isVariableFactor;
        public bool isGateExit;
        public bool isGateEnter;
        public bool isCopy;
        public bool isConstrainEqual;
        public GroupNode anchorNode; // Child node if factor, first arg if constraint
        // Following used for path find algorithm
        internal int currentDistance;
        internal GroupNode previousNodeInPath;

        public static GroupNode FromExpression(IMethodInvokeExpression imie)
        {
            GroupNode gn = new GroupNode();
            gn.factorExpression = imie;
            gn.variableDeclaration = null;
            gn.groupMembers = null;
            gn.argumentMap = new Dictionary<GroupNode, string>();
            return gn;
        }

        public static GroupNode FromVariable(IVariableDeclaration ivd)
        {
            GroupNode gn = new GroupNode();
            gn.variableDeclaration = ivd;
            gn.groupMembers = null;
            gn.factorExpression = null;
            gn.argumentMap = null;
            return gn;
        }

        public void AttachGroupMembers(IList<GroupMember> gms)
        {
            groupMembers = new List<GroupMemberWithDistanceCount>();
            foreach (GroupMember gm in gms)
            {
                groupMembers.Add(new GroupMemberWithDistanceCount(this, gm));
            }
        }

        public bool IsFactorNode
        {
            get { return factorExpression != null; }
        }

        public object Clone()
        {
            GroupNode that = new GroupNode();
            that.variableDeclaration = this.variableDeclaration;
            that.groupMembers = this.groupMembers;
            that.factorExpression = this.factorExpression;
            that.argumentMap = this.argumentMap;
            return that;
        }

        public override bool Equals(object obj)
        {
            GroupNode that = (GroupNode) obj;
            if (that == null)
                return false;

            if (factorExpression != null)
                return object.ReferenceEquals(factorExpression, that.factorExpression);
            else
                return object.ReferenceEquals(variableDeclaration, that.variableDeclaration);
        }

        public override int GetHashCode()
        {
            if (factorExpression != null)
                return factorExpression.GetHashCode();
            else
                return variableDeclaration.GetHashCode();
        }

        public override string ToString()
        {
            if (this.factorExpression != null)
                return "Factor (" + this.factorExpression.ToString() + ")";
            else
                return "Variable " + this.variableDeclaration.Name;
        }
    }

    /// <summary>
    /// Inherit parent grouping
    /// </summary>
    internal class InheritParentGrouping
    {
        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Inherits parent grouping";
        }
    }

    /// <summary>
    /// Channel path attribute. Marks all paths that will exist on the channel
    /// </summary>
    internal class ChannelPathAttribute : ICompilerAttribute
    {
        /// <summary>
        ///  The message path
        /// </summary>
        public readonly string Path;

        /// <summary>
        /// Message direction
        /// </summary>
        public readonly MessageDirection Direction;

        /// <summary>
        /// Path attribute comes from a default message attribute
        /// </summary>
        public readonly bool FromDefault;

        public ChannelPathAttribute(string path, MessageDirection direction, bool fromDefault)
        {
            Path = path;
            Direction = direction;
            FromDefault = fromDefault;
        }

        /// <summary>
        /// Equals override
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
                return true;
            ChannelPathAttribute cpa = obj as ChannelPathAttribute;
            if (cpa == null) return false;
            return (Path == cpa.Path && Direction == cpa.Direction && FromDefault == cpa.FromDefault);
        }

        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("ChannelPath {0}_{1}{2}",
                                 Path, (Direction == MessageDirection.Backwards) ? "B" : "F", FromDefault ? " (default)" : "");
        }

        /// <summary>
        /// GetHashCode override
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            if (Path != null)
                return Path.GetHashCode() + Direction.GetHashCode();
            else
                return Direction.GetHashCode();
        }
    }

    /// <summary>
    /// Attribute which is attached to the method invoke expression associated with an
    /// operator call. The attribute specifies a context-specific ('from' to 'to') string
    /// representation (in general a path) of the message expression (for example, the field
    /// name 'Sample' in a DistAndSample message type) 
    /// </summary>
    internal class MessagePathAttribute : ICompilerAttribute
    {
        /// <summary>
        /// The path of the 'from' message
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// The 'from' argument for the message
        /// </summary>
        public string From { get; set; }

        /// <summary>
        /// The 'to' argument for the message
        /// </summary>
        public string To { get; set; }

        /// <summary>
        /// The distance of the 'from' argument from the root of the group
        /// </summary>
        public int FromDistance { get; set; }

        /// <summary>
        /// The distance of the 'to' argument from the root of the group
        /// </summary>
        public int ToDistance { get; set; }

        /// <summary>
        /// Indicates that the message attribute is a default attribute
        /// </summary>
        public bool IsDefault { get; set; }

        /// <summary>
        /// Create a default message path attribute
        /// </summary>
        /// <param name="path">The message path - this is a property name in the message type</param>
        public MessagePathAttribute(string path)
        {
            From = null;
            To = null;
            FromDistance = 0;
            ToDistance = 0;
            Path = path;
            IsDefault = false;
        }

        /// <summary>
        /// Create a default message path attribute associated with a variable group
        /// </summary>
        /// <param name="from">The 'from' argument name</param>
        /// <param name="to">The 'to' argument name</param>
        /// <param name="fromDistance">Distance of from argument to root</param>
        /// <param name="toDistance">Distance of to argument to root</param>
        public MessagePathAttribute(string from, string to, int fromDistance, int toDistance)
        {
            From = from;
            To = to;
            FromDistance = fromDistance;
            ToDistance = toDistance;
            Path = null; // to be set by the algorithm based on TowardsRoot
            IsDefault = false;
        }

        /// <summary>
        /// Create a message path attribute with a specified path
        /// </summary>
        /// <param name="from">The 'from' argument name</param>
        /// <param name="to">The 'to' argument name</param>
        /// <param name="path">path</param>
        /// <param name="isDefault">Whether this MPA is a default MPA</param>
        public MessagePathAttribute(string from, string to, string path, bool isDefault)
        {
            From = from;
            To = to;
            FromDistance = 0;
            ToDistance = 0;
            Path = path;
            IsDefault = isDefault;
        }

        /// <summary>
        /// Whether this attribute is applicable to specified from/to argument names
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        public bool AppliesTo(string from, string to)
        {
            if (From != null && from != null && From != from)
                return false;
            if (To != null && to != null && To != to)
                return false;

            return true;
        }

        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            string fromStr = (From == null) ? "Any" : From;
            string toStr = (To == null) ? "Any" : To;
            string pathStr = String.Format("Path through factor: {0}.{1} to {2}", fromStr, (Path == null) ? "" : Path, toStr);
            string rootStr =
                (FromDistance > ToDistance)
                    ? "towards root"
                    : (FromDistance < ToDistance) ? "away from root" : "";
            return pathStr + " " + rootStr + String.Format(" ({0},{1})", FromDistance, ToDistance);
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Compiler.Graphs;
using Microsoft.ML.Probabilistic.Factors;
using System.Linq;
using Microsoft.ML.Probabilistic.Models.Attributes;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// The group transform deals with all aspects of group handling
    /// It creates groups as necessary for deterministic factors and constraints
    /// and changes the group annotations into MessagePath annotations on factor expressions.
    /// It also creates related annotations (ChannelPath attributes) on variable declarations
    /// so that the message transform knows what type of variables to create.
    /// </summary>
    /// <remarks>
    /// The group transform has the following steps:
    /// 
    /// 1. Builds a bipartite factor graph of factors and variables. This is done using the
    ///    transform framework. This will also create groups for deterministic factors and
    ///    constraints
    ///
    /// 2. For each existing group (i.e. manually specified group) consisting of more than one
    ///    variable expression, picks a variable, and finds the shortest path from that variable
    ///    to all other variables in the group. Add all nodes in the path to the group.
    ///    
    /// 3a. For any deterministic factor which is not a variable factor, creates a group
    ///     for each input argument, and add the output argument (unless such a pair exists)
    /// 3b. Similarly for constraints, where the first argument to the constraint acts as
    ///     the output argument.
    ///     
    /// 4. For each variable factor, if any argument is in a group, ensures that all other arguments
    ///     are in the group.
    ///     
    /// 5. Finds the root of each group. With the current architecture, the root variable cannot
    ///    be on the 'uses' side of any other variable in the group. This is because 'uses' are
    ///    currently treated as a whole in terms of type, and if one of the uses (or anything downstream)
    ///    were picked as the root, then one of the uses would need to be a different type.
    ///    The exception to this is GateExitRandom which is used for variables defined within
    ///    a gate - in this case, the root must be the exit side. 
    ///    
    ///       NOTE: In future, it would be nice to have a factor which allowed one of the uses to be
    ///       treated differently from all the other uses. This factor could then be inserted in situations
    ///       where roots were manually specified the uses side of any variable in the group. This would
    ///       require that the Group transform should go before the Channel transform so that we can
    ///       insert the correct type of variable factor
    ///    
    /// 6. Calculates distances from the root for each group
    ///    
    /// 7. Loops through the factor expressions, and call the algorithm to set the paths.
    ///    for the MessagePath attributes. This is done whether or not the expression
    ///    participates in a group.
    ///
    /// 8. Traverses the factor graph to create the ChannelPath attributes
    /// </remarks>
    internal class GroupTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "GroupTransform"; }
        }

        // The algorithm instance 
        protected IAlgorithm algorithm;

        private VariableGroup currentGroup = null;
        private GroupNode currentRoot = null;
        private IVariableDeclaration currentConditionVar;

        // The factor graph
        private Graph<GroupNode> factorGraph = new Graph<GroupNode>();

        // A dictionary of nodes in the factor graph keyed by variable declaration
        private Dictionary<IVariableDeclaration, GroupNode> nodeOfVariable = new Dictionary<IVariableDeclaration, GroupNode>();

        // List of factor expression nodes
        private List<GroupNode> factorExpressionNodes = new List<GroupNode>();

        // Dictionary mapping variable group to group member root node
        private Dictionary<VariableGroup, GroupMemberWithDistanceCount> rootOfGroup = new Dictionary<VariableGroup, GroupMemberWithDistanceCount>();

        // Dictionary mapping variable group to its GroupNodes
        private Dictionary<VariableGroup, ICollection<GroupNode>> nodesInGroup = new Dictionary<VariableGroup, ICollection<GroupNode>>();

        // The set of automatically generated groups
        private Set<VariableGroup> generatedGroups = new Set<VariableGroup>();

        /// <summary>
        /// Constucts a Group transform
        /// </summary>
        /// <param name="algorithm"></param>
        public GroupTransform(IAlgorithm algorithm)
            : base()
        {
            this.algorithm = algorithm;
        }

        protected override void DoConvertMethodBody(IList<IStatement> outputs, IList<IStatement> inputs)
        {
            base.DoConvertMethodBody(outputs, inputs);
            if (context.Results.IsErrors()) return;
            // Convert variable reference dependencies into statement dependencies.
            PostProcessDependencies();
        }

        // Create any missing groups for deterministic factors
        private void CreateMissingGroups(GroupNode gn)
        {
            if (!gn.IsFactorNode) return;
            if (gn.isVariableFactor) return;
            if (!gn.isDeterministic) return;

            IVariableDeclaration anchorDecl = gn.anchorNode.variableDeclaration;
            int parentIndex = 0;
            foreach (GroupNode vgn in gn.Neighbors)
            {
                if (object.ReferenceEquals(vgn, gn.anchorNode))
                    continue;
                parentIndex++;
                if (gn.isGateExit && parentIndex != 2) continue;
                IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(vgn.variableDeclaration);
                // See if there is a common group between this node and the anchor node.
                // If not, add a group member                    
                if (findGroupMatch(anchorDecl, vgn.variableDeclaration) == null)
                {
                    VariableGroup vg = new VariableGroup();
                    vg.Name = gn.factorExpression.Method.Method.Name + groupCount;
                    groupCount++;
                    generatedGroups.Add(vg);
                    nodesInGroup.Add(vg, new Set<GroupNode>());
                    nodesInGroup[vg].Add(gn.anchorNode);
                    context.OutputAttributes.Add(anchorDecl, new GroupMember(vg, false));
#if writeToConsole
                    Console.WriteLine("Creating group "+vg+" for ("+anchorDecl.Name+","+vgn.variableDeclaration.Name+")");
#endif
                    AddOrMergeGroups(vgn, vg);
                }
            }
        }

        /// <summary>
        /// Used for assigning unique names to groups
        /// </summary>
        private int groupCount;

        // Attach distance counters.
        private void AttachGroupInfo(GroupNode vgn)
        {
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(vgn.variableDeclaration);
            vgn.AttachGroupMembers(gms);
        }

        /// <summary>
        /// Mark distance from current root
        /// </summary>
        /// <param name="edge"></param>
        private void MarkDistanceFromRoot(Edge<GroupNode> edge)
        {
            GroupNode sgn = edge.Source;
            GroupNode tgn = edge.Target;
#if writeToConsole
            Console.WriteLine(sgn+" ("+sgn.currentDistance+") -> "+tgn);
#endif
            tgn.currentDistance = sgn.currentDistance + 1;
        }

        /// <summary>
        /// Attach distances for current group
        /// </summary>
        /// <param name="gn"></param>
        private void AttachDistances(GroupNode gn)
        {
            if (gn.IsFactorNode)
                return;

            foreach (GroupMemberWithDistanceCount tgm in gn.groupMembers)
            {
                if (tgm.group.Equals(currentGroup))
                {
                    tgm.distance = gn.currentDistance;
#if writeToConsole
                    Console.WriteLine("Distance of {0} from root: {1})", gn.variableDeclaration, tgm.distance);
#endif
                }
            }
        }

        // Create message path attributes from a factor to a variable. The paths are filled in by
        // the algorithm.
        private void CreateMessagePathAttr(GroupNode fgn, GroupNode vgn)
        {
            if (vgn.groupMembers == null) return;
            foreach (GroupMemberWithDistanceCount vgm in vgn.groupMembers)
            {
                string toName = fgn.argumentMap[vgn];
                foreach (GroupNode sgn in fgn.Neighbors)
                {
                    string fromName = fgn.argumentMap[sgn];
                    if (toName == fromName)
                        continue;
                    GroupMemberWithDistanceCount sgm = null;
                    foreach (GroupMemberWithDistanceCount gmwdc in sgn.groupMembers)
                        if (gmwdc.group == vgm.group)
                        {
                            sgm = gmwdc;
                            break;
                        }

                    if (sgm == null)
                        continue;
                    context.OutputAttributes.Add(fgn.factorExpression, new MessagePathAttribute(fromName, toName, sgm.distance, vgm.distance));
                }
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

        // Create channel path attributes for a given variable to factor. These are all the
        // messages paths (if any) which are associated with a given channel, and whether
        // backwards or forwards
        // Note: we never need to attach CurrentSample ChannelPaths, since that is the default
        private void CreateChannelPaths(GroupNode vgn)
        {
            if (vgn.IsFactorNode)
                return;

            Set<ChannelPathAttribute> cpas = Set<ChannelPathAttribute>.FromEnumerable(context.OutputAttributes.GetAll<ChannelPathAttribute>(vgn.variableDeclaration));

            // Loop through all attached factors
            int factorCount = 0;
            foreach (GroupNode fgn in vgn.Neighbors)
            {
                if (fgn.isVariableFactor) continue;
                factorCount++;
                // Get the factor node message path attributes
                var mpas = context.OutputAttributes.GetAll<MessagePathAttribute>(fgn.factorExpression);

                bool isOutput = factorGraph.ContainsEdge(fgn, vgn);
                bool hasStochasticSource = false;

                // We are going from this variable to the factor
                string fromName = fgn.argumentMap[vgn];
                // Loop through all the variables attached to this factor
                foreach (GroupNode sgn in fgn.Neighbors)
                {
                    if (sgn == vgn && fgn.Neighbors.Count != 1) continue;
                    string toName = fgn.argumentMap[sgn];
                    // Look for all message paths which match the from/to
                    foreach (MessagePathAttribute mpa in mpas)
                    {
                        if (mpa.AppliesTo(fromName, toName))
                        {
                            ChannelPathAttribute cpa = new ChannelPathAttribute(mpa.Path, isOutput ? MessageDirection.Backwards : MessageDirection.Forwards, mpa.IsDefault);
                            if (!cpas.Contains(cpa))
                            {
                                cpas.Add(cpa);
                                context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                            }
                        }
                        else if (mpa.AppliesTo(toName, fromName))
                        {
                            bool ignoreSource = fgn.isGateExit && IsFirstParent(fgn, sgn);
                            if (mpa.Path == "Distribution" && !ignoreSource) hasStochasticSource = true;
                        }
                    }
                }
                if (false)
                {
                    if (hasStochasticSource || (!fgn.isDeterministic && !(fgn.isGateExit && !isOutput)))
                    {
                        ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", isOutput ? MessageDirection.Forwards : MessageDirection.Backwards, false);
                        if (!cpas.Contains(cpa))
                        {
                            cpas.Add(cpa);
                            context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                        }
                    }
                }
                else
                {
                    if (isOutput && fgn.isDeterministic && !hasStochasticSource)
                    {
                        // a deterministic factor with all deterministic inputs will send a sample to the output variable
                    }
                    else if ((fgn.isGateExit && fromName == "values" && !hasStochasticSource) ||
                             (fgn.isCopy && fromName == "value" && !hasStochasticSource))
                    {
                        // Gate.ExitRandom sends a sample to values
                        // Factor.Copy sends a sample to value
                    }
                    else
                    {
                        // all other factors will send a distribution to the variable
                        ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", isOutput ? MessageDirection.Forwards : MessageDirection.Backwards, false);
                        if (!cpas.Contains(cpa))
                        {
                            cpas.Add(cpa);
                            context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
                        }
                    }
                }
            }
            if (factorCount == 0)
            {
                // vgn must be a marginal channel or an unused uses channel
                ChannelPathAttribute cpa = new ChannelPathAttribute("Distribution", MessageDirection.Backwards, false);
                context.OutputAttributes.Add(vgn.variableDeclaration, cpa);
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif

        // Check if a node is in a group. If no, add it, and add it to the list of nodes
        // for that variable group
        internal void checkAndAddToGroup(GroupNode gn, VariableGroup vg)
        {
            // See if the node is already in the group
            bool found = false;
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                if (object.ReferenceEquals(gm.Group, vg))
                {
                    found = true;
                    break;
                }
            }
            // Not in the group so add it
            if (!found)
            {
                GroupMember gm = new GroupMember(vg, false);
                context.OutputAttributes.Add(gn.variableDeclaration, gm);
                nodesInGroup[vg].Add(gn);
            }
        }

        private void AddOrMergeGroups(GroupNode gn, VariableGroup vg)
        {
            // does the node already belong to any groups?
            VariableGroup existingGroup = null;
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                existingGroup = gm.Group;
                break;
            }
            if (existingGroup == vg) return; // already in this group
            context.OutputAttributes.Add(gn.variableDeclaration, new GroupMember(vg, false));
            nodesInGroup[vg].Add(gn);
            if (existingGroup != null)
            {
                // merge groups
                if (generatedGroups.Contains(vg))
                {
                    MergeGroups(vg, existingGroup);
                }
                else if (generatedGroups.Contains(existingGroup))
                {
                    MergeGroups(existingGroup, vg);
                }
                else
                {
                    Error("Groups " + vg + " and " + existingGroup + " have an invalid overlap.  Try merging them into one group.");
                }
            }
        }

        private void MergeGroups(VariableGroup child, VariableGroup parent)
        {
            if (child == parent) return;
#if writeToConsole
            Console.WriteLine("Merging group "+child+" into group "+parent);
#endif
            ICollection<GroupNode> childNodes = nodesInGroup[child];
            ICollection<GroupNode> parentNodes = nodesInGroup[parent];
            // move all childNodes to the parent group
            foreach (GroupNode gn in childNodes)
            {
                bool alreadyInParentGroup = parentNodes.Contains(gn);
                if (!alreadyInParentGroup) parentNodes.Add(gn);
                if (gn.variableDeclaration == null) continue;
                if (!alreadyInParentGroup) context.InputAttributes.Add(gn.variableDeclaration, new GroupMember(parent, false));
                var newGroups = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration)
                    .Where(gm => gm.Group != child);
                context.InputAttributes.Remove<GroupMember>(gn.variableDeclaration);
                foreach (GroupMember gm in newGroups) context.InputAttributes.Add(gn.variableDeclaration, gm);
            }
            nodesInGroup.Remove(child);
        }

        private IEnumerable<GroupNode> ChildDetFactorsOf(GroupNode gn)
        {
            foreach (GroupNode childNode in gn.Targets)
            {
                foreach (GroupNode gn2 in childNode.Neighbors)
                {
                    if (gn2 == gn) continue;
                    if (!gn2.IsFactorNode || !(gn2.isDeterministic || gn2.isGateExit || gn2.isVariableFactor) || gn2.Targets.Count == 0) continue;
                    yield return gn2;
                }
            }
        }

        private bool IsFirstParent(GroupNode fn, GroupNode vn)
        {
            foreach (GroupNode tn in fn.Sources)
            {
                return (tn == vn);
            }
            return false;
        }

        private IEnumerable<GroupNode> TargetsInGroup(ICollection<GroupNode> nodes, GroupNode gn)
        {
            foreach (GroupNode gn2 in gn.Targets)
            {
                if (gn2.IsFactorNode || nodes.Contains(gn2)) yield return gn2;
            }
        }

        private IEnumerable<GroupNode> NeighborsInGroup(ICollection<GroupNode> nodes, GroupNode gn)
        {
            foreach (GroupNode gn2 in gn.Neighbors)
            {
                if (gn2.IsFactorNode || nodes.Contains(gn2)) yield return gn2;
            }
        }

        private IEnumerable<GroupNode> NeighborsInSameGate(GroupNode gn)
        {
            if (gn.conditionVar != null)
            {
                foreach (GroupNode gn2 in gn.Neighbors)
                {
                    if (gn2.conditionVar == gn.conditionVar) yield return gn2;
                }
            }
        }

        private bool IsDefinitionChannel(IVariableDeclaration ivd)
        {
            ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(ivd);
            return ci != null && ci.IsDef;
        }

        private void WriteGroups(GroupNode gn)
        {
            Console.Write(gn + " groups: ");
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(gn.variableDeclaration);
            foreach (GroupMember gm in gms)
            {
                Console.Write(gm.Group);
                Console.Write(" ");
            }
            Console.WriteLine();
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 162
#endif

        /// <summary>
        /// Post-process dependencies. Converts GroupMember attributes to MessagePath attributes
        /// </summary>
        internal void PostProcessDependencies()
        {
            BreadthFirstSearch<GroupNode> bfs;

#if writeToConsole
            if (false) {
                foreach (GroupNode gn in factorGraph.Nodes) {
                    foreach (GroupNode target in factorGraph.TargetsOf(gn)) {
                        Console.WriteLine(" {0} -> {1}", gn, target);
                    }
                }
                Console.WriteLine();
            }
#endif

            if (true)
            {
                // Check that each group is connected
                ICollection<GroupNode> nodes = null;
                bfs = new BreadthFirstSearch<GroupNode>(gn => NeighborsInGroup(nodes, gn), factorGraph);
                bfs.DiscoverNode += delegate(GroupNode node) { node.currentDistance = 0; };
                foreach (KeyValuePair<VariableGroup, ICollection<GroupNode>> kvp in nodesInGroup)
                {
                    // The variable group
                    VariableGroup vg = kvp.Key;
                    // All the nodes in the factor graph which are currently in this group
                    List<GroupNode> groupNodes = new List<GroupNode>(kvp.Value);
                    // If only 1, then no need to do anything
                    if (groupNodes.Count <= 1)
                        continue;
                    nodes = kvp.Value;
                    // Reset distances
                    foreach (GroupNode gn in nodes)
                    {
                        gn.currentDistance = -1;
                    }

                    bfs.Clear();
                    GroupNode start = groupNodes[0];
                    bfs.SearchFrom(start);

                    // Check that all nodes in group have nonnegative distance
                    foreach (GroupNode gn in nodes)
                    {
                        if (gn.currentDistance < 0)
                        {
                            Error("Group " + vg + " is not connected (could not reach " + gn + " from " + start + ")");
                            return;
                        }
                    }
                }
            }
            if (true)
            {
                // Check that there is no path from a stochastic var to another stochastic var in the same gate
                GroupNode stocVarNode = null;
                var dfsStoc = new DepthFirstSearch<GroupNode>(NeighborsInSameGate, factorGraph);
                dfsStoc.DiscoverNode += delegate(GroupNode node)
                    {
                        if (node != stocVarNode && !node.IsFactorNode && !context.InputAttributes.Has<DerivedVariable>(node.variableDeclaration) &&
                            IsDefinitionChannel(node.variableDeclaration))
                        {
                            Error("Gibbs Sampling does not support two random variables '" + node.variableDeclaration.Name + "' and '" + stocVarNode.variableDeclaration.Name +
                                  "' in the same condition block");
                        }
                    };
                foreach (GroupNode node in factorGraph.Nodes)
                {
                    if (node.IsFactorNode || context.InputAttributes.Has<DerivedVariable>(node.variableDeclaration) || !IsDefinitionChannel(node.variableDeclaration))
                        continue;
                    stocVarNode = node;
                    dfsStoc.SearchFrom(node);
                }
            }

            // Create groups for equality constraints
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (!gn.isConstrainEqual) continue;
                CreateMissingGroups(gn);
            }

            //-----------------------------------------------------
            // Mark all deterministic factors with groups if they
            // are not manually marked
            //-----------------------------------------------------
            DepthFirstSearch<GroupNode> dfs = new DepthFirstSearch<GroupNode>(ChildDetFactorsOf, factorGraph);
            // an exit variable may be the child of multiple factors.  we want to group with the firstParent of only one of them.
            Set<GroupNode> variablesChecked = new Set<GroupNode>();
            dfs.FinishNode += delegate(GroupNode gn)
                {
                    if (gn.isDeterministic || gn.isVariableFactor)
                    {
                        Set<GroupNode> parents = new Set<GroupNode>();
                        int ignoreCount = 0;
                        // for GateExit we want to ignore the first argument
                        if (gn.isGateExit) ignoreCount = 1;
                        GroupNode firstParent = null;
                        foreach (GroupNode vgn in gn.Sources)
                        {
                            if (ignoreCount > 0)
                            {
                                ignoreCount--;
                                continue;
                            }
                            parents.Add(vgn);
                            if (firstParent == null) firstParent = vgn;
                        }
                        foreach (GroupNode childNode in gn.Targets)
                        {
                            if (firstParent != null && !variablesChecked.Contains(childNode))
                            {
                                // check all groups of the child variable
                                List<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(childNode.variableDeclaration);
                                foreach (GroupMember gm in gms)
                                {
                                    ICollection<GroupNode> nodes = nodesInGroup[gm.Group];
                                    // does the group contain any parent?
                                    bool containsAnyParent = nodes.ContainsAny(parents);
                                    if (!containsAnyParent)
                                    {
                                        // add the first parent to the group
#if writeToConsole
                                    Console.WriteLine("adding firstParent "+firstParent+" of "+childNode+" to group "+gm.Group);
#endif
                                        AddOrMergeGroups(firstParent, gm.Group);
                                    }
                                }
                                variablesChecked.Add(childNode);
                            }
                        }
                    }
                    CreateMissingGroups(gn);
                };
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                if (!(fgn.isDeterministic || fgn.isGateExit || fgn.isVariableFactor) || fgn.Targets.Count == 0) continue;
                dfs.SearchFrom(fgn);
            }

            //--------------------------------------------
            // Attach the distance counters to the nodes
            //--------------------------------------------
            foreach (GroupNode vgn in factorGraph.Nodes)
                if (!vgn.IsFactorNode)
                    AttachGroupInfo(vgn);

            //-----------------------------------------------------
            // For each factor with a child node, mark any child variable node
            // group members as 'cannotBeRoot' if there is a parent
            // variable node within the same group (this is overridden if
            // a group has been manually set)
            //-----------------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                foreach (GroupNode childNode in fgn.Targets)
                {
                    foreach (GroupMemberWithDistanceCount gmdc in childNode.groupMembers)
                    {
                        VariableGroup vg = gmdc.group;
                        ICollection<GroupNode> nodes = nodesInGroup[vg];
                        // root must be a parent
                        // Is there a parent variable in the same group?
                        bool foundParent = false;
                        foreach (GroupNode vgn in fgn.Sources)
                        {
                            if (nodes.Contains(vgn))
                            {
                                foundParent = true;
                                break;
                            }
                        }
                        if (foundParent)
                        {
                            // If there is a parent in the same group, then the child cannot be a root
                            gmdc.cannotBeRoot = true;
                        }
                    }
                }
            }

            //---------------------------------------------------
            // Set up the group dictionary to point to the roots
            //---------------------------------------------------
            int grpCount = 0;
            int numGroups = nodesInGroup.Count;
            rootOfGroup.Clear();
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (gn.IsFactorNode) continue;

                foreach (GroupMemberWithDistanceCount gmdc in gn.groupMembers)
                {
                    if (gmdc.cannotBeRoot && !gmdc.groupMember.IsRoot)
                        continue;
                    GroupMember gm = gmdc.groupMember;
                    VariableGroup vg = gm.Group;
                    bool previouslyAssigned = rootOfGroup.ContainsKey(vg);
                    // Manually assigned root overrides 'cannotBeRoot'
                    if ((!previouslyAssigned) || gmdc.groupMember.IsRoot)
                    {
                        if (previouslyAssigned)
                        {
#if writeToConsole
                            Console.WriteLine("Undo {0} as root of {1}", rootOfGroup[vg].groupNode, vg);
#endif
                            rootOfGroup[vg].groupMember.IsRoot = false;
                            rootOfGroup.Remove(vg);
                        }
                        else
                        {
                            grpCount++;
                        }
                        IVariableDeclaration ivd = gmdc.groupNode.variableDeclaration;
                        if (context.InputAttributes.GetAll<GroupMember>(ivd).Count > 1)
                            Error("Variable '" + ivd.Name + "' belongs to multiple groups so it cannot be a root");
#if writeToConsole
                        Console.WriteLine("{0} is root of {1}", gn, vg);
#endif
                        gm.IsRoot = true;
                        rootOfGroup.Add(vg, gmdc);
                    }
                    if (grpCount >= numGroups)
                        break;
                }
            }

            if (rootOfGroup.Count != nodesInGroup.Count)
                Error("Cannot find root for " + (nodesInGroup.Count - rootOfGroup.Count).ToString(CultureInfo.InvariantCulture) + " groups");

            //--------------------------------------------
            // Mark distances for each variable group
            //--------------------------------------------
            if (true)
            {
                ICollection<GroupNode> nodes = null;
                bfs = new BreadthFirstSearch<GroupNode>(gn => NeighborsInGroup(nodes, gn), factorGraph);
                bfs.TreeEdge += MarkDistanceFromRoot;
                bfs.FinishNode += AttachDistances;
                foreach (KeyValuePair<VariableGroup, GroupMemberWithDistanceCount> kvp in rootOfGroup)
                {
                    currentGroup = kvp.Key;
                    nodes = nodesInGroup[currentGroup];
                    foreach (GroupNode gn in nodes)
                        gn.currentDistance = -1;
                    currentRoot = kvp.Value.groupNode;
                    currentRoot.currentDistance = 0;

                    // Find the distances from the root
#if writeToConsole
                    Console.WriteLine("\n\nGroup {0}. From root ({1})", currentGroup, currentRoot.variableDeclaration);
#endif
                    bfs.Clear();
                    bfs.SearchFrom(currentRoot);
                }
            }
            else
            {
                // TODO: change above to use this method of computing distances
                foreach (KeyValuePair<VariableGroup, GroupMemberWithDistanceCount> kvp in rootOfGroup)
                {
                    currentGroup = kvp.Key;
                    currentRoot = kvp.Value.groupNode;

                    // Attach the distances to the GroupMembers
#if writeToConsole
                    Console.WriteLine("\n\nGroup {0}. From root ({1})", currentGroup, currentRoot.variableDeclaration);
#endif
                    // Find the distances from the root
                    DistanceSearch<GroupNode> distSearch = new DistanceSearch<GroupNode>(factorGraph);
                    //distSearch.Clear();
                    distSearch.SetDistance += delegate(GroupNode gn, int distance)
                        {
                            gn.currentDistance = distance;
                            AttachDistances(gn);
                        };
                    distSearch.SearchFrom(currentRoot);
                }
            }

            //--------------------------------------------
            // Initialise the message path attributes
            //--------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
            {
                if (fgn.isVariableFactor) continue;
                foreach (GroupNode vgn in factorGraph.NeighborsOf(fgn))
                    CreateMessagePathAttr(fgn, vgn);
            }

            //--------------------------------------------
            // Now let the algorithm modify message paths,
            // or create default message paths. This needs
            // to be done whether or not there are groups
            //--------------------------------------------
            foreach (GroupNode fgn in factorExpressionNodes)
                algorithm.ModifyFactorAttributes(fgn.factorExpression, context.OutputAttributes);

            //--------------------------------------------
            // Create the channel path attributes
            //--------------------------------------------
            foreach (GroupNode gn in factorGraph.Nodes)
            {
                if (gn.IsFactorNode) continue;
                CreateChannelPaths(gn);
            }
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 162
#endif

        // See if two variable declarations share a common group
        private VariableGroup findGroupMatch(IVariableDeclaration ivd1, IVariableDeclaration ivd2)
        {
            IList<GroupMember> gms1 = context.InputAttributes.GetAll<GroupMember>(ivd1);
            IList<GroupMember> gms2 = context.InputAttributes.GetAll<GroupMember>(ivd2);
            foreach (GroupMember gm1 in gms1)
            {
                foreach (GroupMember gm2 in gms2)
                    if (object.ReferenceEquals(gm2.Group, gm1.Group))
                        return gm2.Group;
            }
            return null;
        }

        // See if a variable is in a particular group
        private GroupMember findGroupMatch(VariableGroup vg, IVariableDeclaration ivd)
        {
            IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(ivd);
            GroupMember match = null;
            foreach (GroupMember gm in gms)
            {
                if (object.ReferenceEquals(gm.Group, vg))
                {
                    match = gm;
                    break;
                }
            }
            return match;
        }

        protected override IVariableDeclaration ConvertVariableDecl(IVariableDeclaration ivd)
        {
            if (CodeRecognizer.IsStochastic(context, ivd))
            {
                GroupNode vgn;
                if (!nodeOfVariable.TryGetValue(ivd, out vgn))
                {
                    vgn = GroupNode.FromVariable(ivd);
                    nodeOfVariable[ivd] = vgn;
                    factorGraph.Nodes.Add(vgn);
                }
                vgn.conditionVar = currentConditionVar;
            }
            return base.ConvertVariableDecl(ivd);
        }

        protected override IStatement ConvertExpressionStatement(IExpressionStatement ies)
        {
            // This bit of code builds the factor graph. We are only interested in factor expressions            // with or without a LHS            // Is this from assignment?

            // Get the target if any
            IVariableDeclaration targetVarDecl = null;
            IExpression targetExpression = null;

            if (ies.Expression is IAssignExpression iae)
            {
                targetExpression = iae.Target;
                // The following should return null if the variable is observed (as the targetExpression
                // is an argument reference expression. This situation will then be dealt with
                // as a constraint
                targetVarDecl = Recognizer.GetVariableDeclaration(targetExpression);
                // ignore constants
                if (targetVarDecl != null && !CodeRecognizer.IsStochastic(context, targetVarDecl)) targetVarDecl = null;
            }

            IMethodInvokeExpression factorExpression;
            if (iae == null)
                factorExpression = ies.Expression as IMethodInvokeExpression;
            else
                factorExpression = iae.Expression as IMethodInvokeExpression;

            FactorManager.FactorInfo info = null;

            // Factor information to get field names
            if (factorExpression != null)
                info = CodeRecognizer.GetFactorInfo(context, factorExpression);
            if (factorExpression != null && info != null && CodeRecognizer.IsStochastic(context, factorExpression))
            {
                bool isDeterministic = info.IsDeterministicFactor;
                bool isVariable = context.InputAttributes.Has<IsVariableFactor>(factorExpression);
                bool isGateExit = (info.Method.DeclaringType == typeof (Gate) && info.Method.Name.StartsWith("Exit"));
                bool isGateEnter = (info.Method.DeclaringType == typeof (Gate) && info.Method.Name.StartsWith("Enter"));
                bool isCopy = (info.Method.DeclaringType == typeof (Factor) && info.Method.Name == "Copy");
                bool isCasesCopy = context.InputAttributes.Has<CasesCopy>(factorExpression);
                bool isConstrainEqual = (info.Method.DeclaringType == typeof (Constrain) && info.Method.Name == "Equal");

                // Create and add the factor node
                GroupNode exprNode = GroupNode.FromExpression(factorExpression);
                exprNode.isDeterministic = isDeterministic;
                exprNode.isVariableFactor = isVariable;
                exprNode.isGateExit = isGateExit;
                exprNode.isGateEnter = isGateEnter;
                exprNode.isCopy = isCopy;
                exprNode.isConstrainEqual = isConstrainEqual;
                exprNode.conditionVar = currentConditionVar;
                factorGraph.Nodes.Add(exprNode);
                factorExpressionNodes.Add(exprNode);

                int fieldIndex = 0;
                // If the target variable is not already in the graph, create the node and add it
                GroupNode targetGN = null;
                if (targetVarDecl != null)
                {
                    string tgtArgName = info.ParameterNames[fieldIndex++];
                    if (!nodeOfVariable.TryGetValue(targetVarDecl, out targetGN))
                    {
                        targetGN = GroupNode.FromVariable(targetVarDecl);
                        nodeOfVariable.Add(targetVarDecl, targetGN);
                        factorGraph.Nodes.Add(targetGN);
                    }
                    // Update the factor mapping
                    exprNode.argumentMap.Add(targetGN, tgtArgName);
                    factorGraph.AddEdge(exprNode, targetGN);
                    //factorGraph.AddEdge(targetGN, exprNode);
                    IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(targetVarDecl);
                    foreach (GroupMember gm in gms)
                    {
                        //gm.IsRoot = false; // Do not allow manual setting of root
                        ICollection<GroupNode> nodes;
                        if (!nodesInGroup.TryGetValue(gm.Group, out nodes))
                        {
                            nodes = new Set<GroupNode>();
                            nodesInGroup[gm.Group] = nodes;
                        }
                        if (!nodes.Contains(targetGN))
                            nodes.Add(targetGN);
                    }
                    exprNode.anchorNode = targetGN;
                }

                for (int i = 0; i < factorExpression.Arguments.Count; i++)
                {
                    string srcArgName = info.ParameterNames[fieldIndex++];
                    IExpression arg = factorExpression.Arguments[i];
                    while (arg is IMethodInvokeExpression)
                    {
                        IMethodInvokeExpression imie2 = (IMethodInvokeExpression) arg;
                        if (imie2.Arguments.Count == 0) break;
                        arg = imie2.Arguments[0];
                    }
                    bool isOut = (arg is IAddressOutExpression);
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(arg);
                    if (ivd == null || !CodeRecognizer.IsStochastic(context, ivd))
                        continue;
                    GroupNode sourceGN;
                    if (!nodeOfVariable.TryGetValue(ivd, out sourceGN))
                    {
                        sourceGN = GroupNode.FromVariable(ivd);
                        nodeOfVariable.Add(ivd, sourceGN);
                        factorGraph.Nodes.Add(sourceGN);
                    }
                    // Update the factor mapping
                    exprNode.argumentMap.Add(sourceGN, srcArgName);
                    // Do not create an edge between a GateEnter factor and its first argument ("cases")
                    if (!(isGateEnter && i == 0))
                    {
                        if (isOut) factorGraph.AddEdge(exprNode, sourceGN);
                        else factorGraph.AddEdge(sourceGN, exprNode);
                    }

                    if (exprNode.anchorNode == null)
                        exprNode.anchorNode = sourceGN;
                    IList<GroupMember> gms = context.InputAttributes.GetAll<GroupMember>(ivd);
                    foreach (GroupMember gm in gms)
                    {
                        //gm.IsRoot = false; // Do not allow manual setting of root
                        ICollection<GroupNode> nodes;
                        if (!nodesInGroup.TryGetValue(gm.Group, out nodes))
                        {
                            nodes = new Set<GroupNode>();
                            nodesInGroup[gm.Group] = nodes;
                        }
                        if (!nodes.Contains(sourceGN))
                            nodes.Add(sourceGN);
                    }
                }
            }

            // Call the base class
            ConvertExpression(ies.Expression);
            return ies;
        }

        /// <summary>
        /// Shallow copy of for statement
        /// </summary>
        protected override IStatement ConvertFor(IForStatement ifs)
        {
            // We do not convert the loop counter declaration or increment.  We only convert
            // the loop size which is the right hand size of the loop condition.
            IBinaryExpression ibe = ifs.Condition as IBinaryExpression;
            if (ibe == null)
            {
                Error("For loop conditions must be binary expressions, was :" + ifs.Condition);
            }
            else
            {
                IVariableDeclaration loopVar = CodeRecognizer.Instance.GetVariableDeclaration(ibe.Left);
                if (loopVar == null)
                    Error("For loop conditions have loop counter reference on LHS, was :" + ibe.Left);
                if ((ibe.Right is ILiteralExpression) && 0.Equals(((ILiteralExpression) ibe.Right).Value))
                {
                    // loop of zero length
                    return null;
                }
                ConvertExpression(ibe.Right);
            }
            ConvertBlock(ifs.Body);
            return ifs;
        }

        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            ConvertExpression(ics.Condition);
            IVariableDeclaration oldConditionVar = currentConditionVar;
            if (currentConditionVar == null && CodeRecognizer.IsStochastic(context, ics.Condition))
                currentConditionVar = Recognizer.GetVariableDeclaration(ics.Condition);
            context.SetPrimaryOutput(ics);
            ConvertBlock(ics.Then);
            if (ics.Else != null) ConvertBlock(ics.Else);
            currentConditionVar = oldConditionVar;
            return ics;
        }
    }

    // Wraps group member with distant count
    internal class GroupMemberWithDistanceCount
    {
        public GroupMember groupMember; // Wrapped group member
        public GroupNode groupNode; // Owner

        public VariableGroup group
        {
            get { return groupMember.Group; }
        }

        public int distance;
        public bool cannotBeRoot = false;

        public GroupMemberWithDistanceCount(GroupNode gn, GroupMember gm)
        {
            groupNode = gn;
            groupMember = gm;
            distance = -1;
        }

        public override string ToString()
        {
            return String.Format("Distance {0})", distance);
        }
    }

    // Node in factor graph which carries group information
    internal class GroupNode : DirectedNode<GroupNode>, ICloneable
    {
        /// <summary>
        /// For a factor node, this is always null.
        /// </summary>
        public IVariableDeclaration variableDeclaration;

        /// <summary>
        /// For a node inside a gate, stores the conditionVar.  Otherwise null.
        /// </summary>
        public IVariableDeclaration conditionVar;

        /// <summary>
        /// Stores distance info for each group that this variable is a member of.
        /// </summary>
        public IList<GroupMemberWithDistanceCount> groupMembers;

        /// <summary>
        /// For a variable node, this is always null.
        /// </summary>
        public IMethodInvokeExpression factorExpression;

        public IDictionary<GroupNode, string> argumentMap;
        public bool isDeterministic;
        public bool isVariableFactor;
        public bool isGateExit;
        public bool isGateEnter;
        public bool isCopy;
        public bool isConstrainEqual;
        public GroupNode anchorNode; // Child node if factor, first arg if constraint
        // Following used for path find algorithm
        internal int currentDistance;
        internal GroupNode previousNodeInPath;

        public static GroupNode FromExpression(IMethodInvokeExpression imie)
        {
            GroupNode gn = new GroupNode();
            gn.factorExpression = imie;
            gn.variableDeclaration = null;
            gn.groupMembers = null;
            gn.argumentMap = new Dictionary<GroupNode, string>();
            return gn;
        }

        public static GroupNode FromVariable(IVariableDeclaration ivd)
        {
            GroupNode gn = new GroupNode();
            gn.variableDeclaration = ivd;
            gn.groupMembers = null;
            gn.factorExpression = null;
            gn.argumentMap = null;
            return gn;
        }

        public void AttachGroupMembers(IList<GroupMember> gms)
        {
            groupMembers = new List<GroupMemberWithDistanceCount>();
            foreach (GroupMember gm in gms)
            {
                groupMembers.Add(new GroupMemberWithDistanceCount(this, gm));
            }
        }

        public bool IsFactorNode
        {
            get { return factorExpression != null; }
        }

        public object Clone()
        {
            GroupNode that = new GroupNode();
            that.variableDeclaration = this.variableDeclaration;
            that.groupMembers = this.groupMembers;
            that.factorExpression = this.factorExpression;
            that.argumentMap = this.argumentMap;
            return that;
        }

        public override bool Equals(object obj)
        {
            GroupNode that = (GroupNode) obj;
            if (that == null)
                return false;

            if (factorExpression != null)
                return object.ReferenceEquals(factorExpression, that.factorExpression);
            else
                return object.ReferenceEquals(variableDeclaration, that.variableDeclaration);
        }

        public override int GetHashCode()
        {
            if (factorExpression != null)
                return factorExpression.GetHashCode();
            else
                return variableDeclaration.GetHashCode();
        }

        public override string ToString()
        {
            if (this.factorExpression != null)
                return "Factor (" + this.factorExpression.ToString() + ")";
            else
                return "Variable " + this.variableDeclaration.Name;
        }
    }

    /// <summary>
    /// Inherit parent grouping
    /// </summary>
    internal class InheritParentGrouping
    {
        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Inherits parent grouping";
        }
    }

    /// <summary>
    /// Channel path attribute. Marks all paths that will exist on the channel
    /// </summary>
    internal class ChannelPathAttribute : ICompilerAttribute
    {
        /// <summary>
        ///  The message path
        /// </summary>
        public readonly string Path;

        /// <summary>
        /// Message direction
        /// </summary>
        public readonly MessageDirection Direction;

        /// <summary>
        /// Path attribute comes from a default message attribute
        /// </summary>
        public readonly bool FromDefault;

        public ChannelPathAttribute(string path, MessageDirection direction, bool fromDefault)
        {
            Path = path;
            Direction = direction;
            FromDefault = fromDefault;
        }

        /// <summary>
        /// Equals override
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
                return true;
            ChannelPathAttribute cpa = obj as ChannelPathAttribute;
            if (cpa == null) return false;
            return (Path == cpa.Path && Direction == cpa.Direction && FromDefault == cpa.FromDefault);
        }

        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("ChannelPath {0}_{1}{2}",
                                 Path, (Direction == MessageDirection.Backwards) ? "B" : "F", FromDefault ? " (default)" : "");
        }

        /// <summary>
        /// GetHashCode override
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            if (Path != null)
                return Path.GetHashCode() + Direction.GetHashCode();
            else
                return Direction.GetHashCode();
        }
    }

    /// <summary>
    /// Attribute which is attached to the method invoke expression associated with an
    /// operator call. The attribute specifies a context-specific ('from' to 'to') string
    /// representation (in general a path) of the message expression (for example, the field
    /// name 'Sample' in a DistAndSample message type) 
    /// </summary>
    internal class MessagePathAttribute : ICompilerAttribute
    {
        /// <summary>
        /// The path of the 'from' message
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// The 'from' argument for the message
        /// </summary>
        public string From { get; set; }

        /// <summary>
        /// The 'to' argument for the message
        /// </summary>
        public string To { get; set; }

        /// <summary>
        /// The distance of the 'from' argument from the root of the group
        /// </summary>
        public int FromDistance { get; set; }

        /// <summary>
        /// The distance of the 'to' argument from the root of the group
        /// </summary>
        public int ToDistance { get; set; }

        /// <summary>
        /// Indicates that the message attribute is a default attribute
        /// </summary>
        public bool IsDefault { get; set; }

        /// <summary>
        /// Create a default message path attribute
        /// </summary>
        /// <param name="path">The message path - this is a property name in the message type</param>
        public MessagePathAttribute(string path)
        {
            From = null;
            To = null;
            FromDistance = 0;
            ToDistance = 0;
            Path = path;
            IsDefault = false;
        }

        /// <summary>
        /// Create a default message path attribute associated with a variable group
        /// </summary>
        /// <param name="from">The 'from' argument name</param>
        /// <param name="to">The 'to' argument name</param>
        /// <param name="fromDistance">Distance of from argument to root</param>
        /// <param name="toDistance">Distance of to argument to root</param>
        public MessagePathAttribute(string from, string to, int fromDistance, int toDistance)
        {
            From = from;
            To = to;
            FromDistance = fromDistance;
            ToDistance = toDistance;
            Path = null; // to be set by the algorithm based on TowardsRoot
            IsDefault = false;
        }

        /// <summary>
        /// Create a message path attribute with a specified path
        /// </summary>
        /// <param name="from">The 'from' argument name</param>
        /// <param name="to">The 'to' argument name</param>
        /// <param name="path">path</param>
        /// <param name="isDefault">Whether this MPA is a default MPA</param>
        public MessagePathAttribute(string from, string to, string path, bool isDefault)
        {
            From = from;
            To = to;
            FromDistance = 0;
            ToDistance = 0;
            Path = path;
            IsDefault = isDefault;
        }

        /// <summary>
        /// Whether this attribute is applicable to specified from/to argument names
        /// </summary>
        /// <param name="from"></param>
        /// <param name="to"></param>
        /// <returns></returns>
        public bool AppliesTo(string from, string to)
        {
            if (From != null && from != null && From != from)
                return false;
            if (To != null && to != null && To != to)
                return false;

            return true;
        }

        /// <summary>
        /// ToString override
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            string fromStr = (From == null) ? "Any" : From;
            string toStr = (To == null) ? "Any" : To;
            string pathStr = String.Format("Path through factor: {0}.{1} to {2}", fromStr, (Path == null) ? "" : Path, toStr);
            string rootStr =
                (FromDistance > ToDistance)
                    ? "towards root"
                    : (FromDistance < ToDistance) ? "away from root" : "";
            return pathStr + " " + rootStr + String.Format(" ({0},{1})", FromDistance, ToDistance);
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs(10,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs(862,17): error CS0165: Use of unassigned local variable 'iae',D:\a\1\s\src\Compiler\Infer\Transforms\GroupTransform.cs(10,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.ML.Probabilistic.Algorithms;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Factors;
using Microsoft.ML.Probabilistic.Factors.Attributes;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Models.Attributes;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Transforms a model specified in terms of channels into the set of message passing
    /// operations required to perform inference in that model.
    /// </summary>
    /// <remarks>
    /// The message passing transform does the following operations:
    ///  - converts channel declarations into pairs of variables for forwards and backwards 
    ///    messages along that channel.
    ///  - initalises message arrays using the appropriate message prototypes
    ///    - message prototypes may be different for backward and forward directions
    ///    - the algorithm determines the message prototypes in a call to GetMessagePrototypes
    ///    - default message prototype is the marginal prototype
    ///  - converts method calls into sets of operator method calls
    ///  - keeps track of all inter-operator dependencies, as these are needed by the scheduler
    /// <para>
    /// Stochastic variables must have ChannelInfo attributes.
    /// </para>
    /// </remarks>
    internal class MessageTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "MessageTransform"; }
        }

        internal static bool UseMessageAnalysis;
        internal static bool debug;
        internal bool InitializeOnSeparateLine;
        protected IAlgorithm algorithm;
        protected FactorManager factorManager;
        protected ModelCompiler compiler;

        internal const string resultName = "result";
        internal const string resultIndexName = "resultIndex";

        /// <summary>
        /// If true, initialize arrays using ArrayHelper.Fill (makes the generated code more compact, but prevents moving some allocations into the Reset() method)
        /// </summary>
        internal static bool UseArrayHelperFill;
        /// <summary>
        /// If true, operators that return their argument are replaced by copy expressions.  Note this is required for certain tests to pass.
        /// </summary>
        private readonly bool UseCopyOperators = true;

        /// <summary>
        /// The set of variables that have at least one definition with a non-unit derivative
        /// </summary>
        protected Set<IVariableDeclaration> hasNonUnitDerivative = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);

        protected Dictionary<IExpression, Type> initialiserType = new Dictionary<IExpression, Type>();

        protected Dictionary<IVariableDeclaration, IVariableDeclaration> derivOfVariable =
            new Dictionary<IVariableDeclaration, IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);

        private static readonly MessageDirection[] directions = { MessageDirection.Forwards, MessageDirection.Backwards };

        /// <summary>
        /// If true, restrictions on derived parents are ignored.
        /// </summary>
        private readonly bool AllowDerivedParents;

        /// <summary>
        /// Results of analysis
        /// </summary>
        private MessageAnalysisTransform analysis;

        /// <summary>
        /// Method declaration used for message tracing
        /// </summary>
        private IMethodDeclaration messageUpdatedMethod;

        public MessageTransform(ModelCompiler compiler, IAlgorithm algorithm, FactorManager factorManager, bool allowDerivedParents)
        {
            this.compiler = compiler;
            this.algorithm = algorithm;
            this.factorManager = factorManager;
            this.AllowDerivedParents = allowDerivedParents;
        }

        public override ITypeDeclaration Transform(ITypeDeclaration itd)
        {
            if (UseMessageAnalysis)
            {
                analysis = new MessageAnalysisTransform(algorithm, factorManager);
                analysis.Context.InputAttributes = context.InputAttributes;
                analysis.Transform(itd);
                context.Results = analysis.Context.Results;
                if (!context.Results.IsSuccess)
                {
                    Error("analysis failed");
                    return itd;
                }
            }
            var td = base.Transform(itd);
            if (messageUpdatedMethod != null)
            {
                // Add method to fire events when a message is updated
                td.Methods.Add(messageUpdatedMethod);
            }

            return td;
        }

        public override void ConvertTypeProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            base.ConvertTypeProperties(td, itd);
            td.Name = td.Name + "_" + algorithm.ShortName;
            if (itd.Documentation != null)
            {
                td.Documentation = itd.Documentation + " using algorithm '" + algorithm.Name + "'";
            }
        }

        protected override IMethodDeclaration ConvertMethod(IMethodDeclaration imd)
        {
            IMethodDeclaration md = base.ConvertMethod(imd);
            context.OutputAttributes.Set(md, new OperatorMethod());
            return md;
        }

        private static bool IsGibbsMarginal(Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(GibbsMarginal<,>));
        }

        public static bool IsPointMass(Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(PointMass<>));
        }

        protected override void DoConvertMethodBody(IList<IStatement> outputs, IList<IStatement> inputs)
        {
            if (UseMessageAnalysis)
            {
                // create factory variables
                foreach (KeyValuePair<IVariableDeclaration, IExpression> entry in analysis.factoryInitExprs)
                {
                    IVariableDeclaration factoryVar = entry.Key;
                    IExpression initExpr = entry.Value;
                    IStatement ist = Builder.AssignStmt(Builder.VarDeclExpr(factoryVar), initExpr);
                    outputs.Add(ist);
                }
            }
            base.DoConvertMethodBody(outputs, inputs);
        }

#if true
        /// <summary>
        /// Only converts the contained statements in a for loop, leaving the initializer,
        /// condition and increment statements unchanged.
        /// </summary>
        protected override IStatement ConvertFor(IForStatement ifs)
        {
            IForStatement fs = Builder.ForStmt();
            context.SetPrimaryOutput(fs);
            fs.Condition = ifs.Condition;
            fs.Increment = ifs.Increment;
            fs.Initializer = ifs.Initializer;
            fs.Body = ConvertBlock(ifs.Body);
            // attributes are not copied
            return fs;
        }
#endif

        /// <summary>
        /// Flatten out and remove if statements.
        /// </summary>
        /// <returns></returns>
        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            if (IsStochasticVariableReference(ics.Condition))
            {
                IBlockStatement bs = ConvertBlock(ics.Then);
                context.AddStatementsBeforeCurrent(bs.Statements);
                return null;
            }
            else
            {
                return base.ConvertCondition(ics);
            }
        }

        /// <summary>
        /// This does the work of constructing all the operator calls for the given factor call
        /// </summary>
        /// <param name="imie">The method invoke expression</param>
        /// <returns></returns>
        protected override IExpression ConvertMethodInvoke(IMethodInvokeExpression imie)
        {
            if (CodeRecognizer.IsInfer(imie)) return ConvertInfer(imie);
            if (CodeRecognizer.IsIsIncreasing(imie)) return imie;
            if (context.FindAncestor<IExpressionStatement>() == null) return imie;
            IExpression expr = imie;
            IAssignExpression iae = context.FindAncestor<IAssignExpression>();
            bool isAssignment = (iae != null);
            IStatement ist = context.FindAncestor<IStatement>();
            bool resultIsObserved = context.InputAttributes.Has<Models.Constraint>(ist);
            bool isVariableFactor = context.InputAttributes.Has<IsVariableFactor>(imie);

            // Find method and extract its factor information
            IAlgorithm alg = algorithm;
            Algorithm algAttr = context.InputAttributes.Get<Algorithm>(imie);
            if (algAttr != null) alg = algAttr.algorithm;

            // Get the meta-data for the factor
            FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, imie);
            if (info == null)
            {
                Error("Factor information could not be found for method: " + imie);
                return imie;
            }
            if (info.IsVoid != !isAssignment)
            {
                if (info.IsVoid) Error("A void function cannot be used in an assignment");
                else if (context.InputStack[context.InputStack.Count - 2].inputElement is IExpressionStatement)
                    Error("The return value of a non-void function must be assigned to a variable");
                else Error("Nested function calls are not allowed. Create a temporary variable for each function result");
                return imie;
            }
            if (iae != null)
            {
                IVariableDeclaration targetVar = Recognizer.GetVariableDeclaration(iae.Target);
                // TODO: this is temporary until full support for UseDerivMessages
                if (targetVar != null && info.IsDeterministicFactor)
                {
                    bool hasUnitDerivative = info.Method.IsDefined(typeof(HasUnitDerivative), true);
                    if (hasUnitDerivative)
                    {
                        // check that all arguments have unit derivative
                        foreach (IExpression arg in imie.Arguments)
                        {
                            IVariableDeclaration argVar = Recognizer.GetVariableDeclaration(arg);
                            if (argVar != null && hasNonUnitDerivative.Contains(argVar))
                            {
                                hasUnitDerivative = false;
                                break;
                            }
                        }
                    }
                    if (!hasUnitDerivative)
                    {
                        hasNonUnitDerivative.Add(targetVar);
                    }
                }
            }

            // Find information about the messages for each argument and work out their types
            Dictionary<string, MessageInfo> msgInfo = new Dictionary<string, MessageInfo>();
            if (debug)
                context.InputAttributes.Set(imie, new MessageInfoDict()
                {
                    msgInfo = msgInfo
                });
            var argumentTypes = new Dictionary<string, Type>();
            var resultTypes = new Dictionary<string, Type>();
            var isStochastic = new Dictionary<string, bool>();
            List<bool> isReturnOrOut = new List<bool>();
            List<bool> argIsConstant = new List<bool>();
            bool resultIsConstant = info.IsDeterministicFactor && !isVariableFactor;
            List<IExpression> arguments = new List<IExpression>();
            if (iae != null)
            {
                IExpression target = iae.Target;
                if (target is IVariableDeclarationExpression)
                {
                    target = Builder.VarRefExpr(Recognizer.GetVariableDeclaration(target));
                }
                isReturnOrOut.Add(!resultIsObserved);
                arguments.Add(target);
            }
            if (!info.Method.IsStatic)
            {
                isReturnOrOut.Add(false);
                arguments.Add(imie.Method.Target);
            }
            foreach (IExpression arg in imie.Arguments)
            {
                bool isOut = (arg is IAddressOutExpression);
                isReturnOrOut.Add(isOut);
                arguments.Add(isOut ? ((IAddressOutExpression)arg).Expression : arg);
            }

            //--------------------------------------------------------
            // Set up the message info for each target field, and record the
            // type of each field
            //--------------------------------------------------------
            for (int i = 0; i < info.ParameterNames.Count; i++)
            {
                string parameterName = info.ParameterNames[i];
                bool isWeaklyTyped = isVariableFactor && parameterName == "init";
                // Create message info. 'isForward' says whether the message
                // out is in the forward or backward direction
                bool isChild = isReturnOrOut[i];
                IExpression channelRef = arguments[i];
                bool isConstant = !CodeRecognizer.IsStochastic(context, channelRef);
                if (!isConstant) resultIsConstant = false;
                argIsConstant.Add(isConstant);
                MessageInfo mi;
                if (isConstant)
                {
                    mi = new MessageInfo
                    {
                        messageFromFactor = isChild ? channelRef : null,
                        messageToFactor = channelRef
                    };
                    if (!isWeaklyTyped)
                    {
                        Type inwardType = mi.messageToFactor.GetExpressionType();
                        argumentTypes[parameterName] = inwardType;
                    }
                }
                else
                {
                    IExpression fwdMsg = GetMessageExpression(channelRef, MessageDirection.Forwards);
                    IExpression bckMsg = GetMessageExpression(channelRef, MessageDirection.Backwards);
                    //if (fwdMsg == null) { Error("forward message is null"); return imie; }
                    //if (bckMsg == null) { Error("backward message is null"); return imie; }
                    if (isChild)
                    {
                        mi = new MessageInfo(this, channelRef)
                        {
                            messageFromFactor = fwdMsg,
                            messageToFactor = bckMsg
                        };
                    }
                    else
                    {
                        mi = new MessageInfo(this, channelRef)
                        {
                            messageFromFactor = bckMsg,
                            messageToFactor = fwdMsg
                        };
                    }
                    if (!isWeaklyTyped)
                    {
                        if (mi.messageToFactor != null)
                        {
                            Type inwardType = mi.messageToFactor.GetExpressionType();
                            if (inwardType == null)
                            {
                                Error("Cannot determine type of " + mi.messageToFactor);
                                return imie;
                            }
                            argumentTypes[parameterName] = inwardType;
                        }
                        if (mi.messageFromFactor != null)
                        {
                            Type outwardType = mi.messageFromFactor.GetExpressionType();
                            argumentTypes["to_" + parameterName] = outwardType;
                            resultTypes[parameterName] = outwardType;
                        }
                    }
                    isStochastic[parameterName] = !mi.hasNonUnitDerivative;
                    if (alg is VariationalMessagePassing vmp && vmp.UseDerivMessages && !isChild && mi.hasNonUnitDerivative && !isVariableFactor)
                    {
                        IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(channelRef);
                        DerivMessage dm = context.InputAttributes.Get<DerivMessage>(ivd);
                        if (dm != null)
                        {
                            IExpression derivArg = Builder.ReplaceExpression(channelRef, Builder.VarRefExpr(ivd), Builder.VarRefExpr(dm.decl));
                            IExpression derivMsg = GetMessageExpression(derivArg, MessageDirection.Forwards);
                            MessageInfo mi2 = new MessageInfo
                            {
                                messageFromFactor = derivMsg,
                                messageToFactor = derivMsg
                            };
                            string derivParameterName = parameterName + "_deriv";
                            msgInfo[derivParameterName] = mi2;
                            Type derivType = derivMsg.GetExpressionType();
                            argumentTypes[derivParameterName] = derivType;
                            resultTypes[derivParameterName] = derivType;
                        }
                    }
                }
                msgInfo[parameterName] = mi;
            }
            if (resultIsConstant && isAssignment && !resultIsObserved)
            {
                // The statement is an assignment between deterministic variables.
                // The factor will be used unchanged.  Check if it copies any of its arguments.
                MessageFcnInfo fninfo = info.GetMessageFcnInfoFromFactor();
                IExpression copyExpr = CheckForCopyOperators(fninfo, imie.Arguments, arguments[0]);
                if (copyExpr != null)
                    return copyExpr;
                return imie;
            }

            // Create operator statements for each non-deterministic argument
            List<ICompilerAttribute> factorAttributes = context.InputAttributes.GetAll<ICompilerAttribute>(imie);

            int initialPriorityListSize = this.factorManager.PriorityList.Count;
            DivideMessages divideMessages = context.InputAttributes.Get<DivideMessages>(imie);
            // Gibbs must never divide messages
            if (algorithm is GibbsSampling)
                divideMessages = new DivideMessages(false);
            if (divideMessages != null)
            {
                if (divideMessages.useDivision)
                {
                    factorManager.GivePriorityTo(typeof(ReplicateOp_Divide));
                }
                else
                {
                    factorManager.GivePriorityTo(typeof(ReplicateOp_NoDivide));
                }
            }
            bool isPointMass = context.InputAttributes.Has<ForwardPointMass>(imie);
            if (isPointMass)
            {
                factorManager.GivePriorityTo(typeof(ReplicatePointOp));
                factorManager.GivePriorityTo(typeof(GetItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetJaggedItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetDeepJaggedItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetItemsFromJaggedPointOp<>));
                factorManager.GivePriorityTo(typeof(GetItemsFromDeepJaggedPointOp<>));
                factorManager.GivePriorityTo(typeof(GetJaggedItemsFromJaggedPointOp<>));
            }

            // send an evidence message to the innermost stochastic condition statement.
            List<IConditionStatement> ifContainers = context.FindAncestors<IConditionStatement>();
            ifContainers.Reverse();
            IConditionStatement ics = null;
            foreach (IConditionStatement ifContainer in ifContainers)
            {
                if (IsStochasticVariableReference(ifContainer.Condition))
                {
                    ics = ifContainer;
                    break;
                }
            }
            if (ics != null)
            {
                // Construct evidence message
                if (isVariableFactor && msgInfo.ContainsKey("Def") &&
                    context.InputAttributes.Has<DoNotSendEvidence>(msgInfo["Def"].channelDecl))
                {
                    Error("Sending evidence from a variable marked with DoNotSendEvidence (" + msgInfo["Def"].channelDecl + ")");
                }
                argumentTypes[resultName] = typeof(double);
                string methodName = alg.GetEvidenceMethodName(factorAttributes);
                IExpression channelRef = ics.Condition;
                MessageInfo mi = new MessageInfo(this, channelRef)
                {
                    messageFromFactor = GetMessageExpression(channelRef, MessageDirection.Backwards)
                };
                string evidenceField = "";
                msgInfo[evidenceField] = mi;
                ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, methodName, evidenceField, argumentTypes, isStochastic, isVariableFactor);
            }
            else if (resultIsConstant)
            {
                if (!isAssignment)
                {
                    // Constrain.Equal(true,false) outside of a conditional statement should be left intact, and marked as an output.
                    context.OutputAttributes.Set(imie, new DeterministicConstraint());
                    return imie;
                }
                else if (resultIsObserved)
                {
                    // a = Not(b)  turns into  ArrayHelper.CheckConstraint("a = Not(b)", LogEvidenceRatio(a,b))  or Constrain.Equal(a,Not(b))
                    Type t = iae.Target.GetExpressionType();
                    var mie = Builder.StaticGenericMethod(new Action<PlaceHolder, PlaceHolder>(Constrain.Equal), new Type[] { t }, iae.Target, imie);
                    context.OutputAttributes.Set(mie, new DeterministicConstraint());
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(mie));
                    return null;
                }
                else
                    return null;
            }

            // Loop over each output argument and construct the operator method
            string operatorSuffix = alg.GetOperatorMethodSuffix(factorAttributes);
            for (int i = 0; i < info.ParameterNames.Count; i++)
            {
                string targetParameter = info.ParameterNames[i];
                MessageInfo mi = msgInfo[targetParameter];
                bool isChild = isReturnOrOut[i];
                // do not generate messages to constant arguments.
                if (argIsConstant[i] && !isChild) continue;
                if (UseMessageAnalysis)
                {
                    AddInitialiserStatement(mi.messageFromFactor, iae ?? (IExpression)imie);
                    if (isChild) AddInitialiserStatement(mi.messageToFactor, null);
                }

                int currentPriorityListSize = this.factorManager.PriorityList.Count;

                Type targetType;
                if (argIsConstant[i])
                    targetType = argumentTypes[targetParameter];
                else
                    targetType = resultTypes[targetParameter];
                argumentTypes[resultName] = targetType;

                // If the target can implement SetToSum exactly, we can use BP gate operators
                // TODO: remove this when the support for auto-generated distribution arrays will be added
                Type targetInnermostElementType = Util.GetInnermostElementType(targetType);
                if (typeof(SettableToWeightedSumExact<>).MakeGenericType(targetInnermostElementType).IsAssignableFrom(targetInnermostElementType))
                {
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterOneOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterPartialOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterPartialTwoOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateExitOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateExitTwoOp));
                }
                else
                {
                    this.factorManager.GivePriorityTo(typeof(GateEnterOneOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterPartialOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterPartialTwoOp));
                    this.factorManager.GivePriorityTo(typeof(GateExitOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateExitTwoOp));
                }

                if (targetInnermostElementType == typeof(StringDistribution))
                {
                    // Don't use ReplicateOp_Divide for StringAutomaton
                    // TODO: replace this workaround with a proper extensibility mechanism
                    this.factorManager.GivePriorityTo(typeof(ReplicateOp_NoDivide));
                }

                // Give priority to operators in GivePriorityTo attributes
                // TODO: can be moved out of the loop when we get rid of the operator lookup based on target type
                List<GivePriorityTo> ops = context.InputAttributes.GetAll<GivePriorityTo>(imie);
                foreach (GivePriorityTo op in ops)
                {
                    this.factorManager.GivePriorityTo(op.Container);
                }

                void action(IStatement st)
                {
                    if (argIsConstant[i]) context.OutputAttributes.Remove<OperatorStatement>(st);
                    context.AddStatementBeforeCurrent(st);
                }
                ForEachOperatorStatement(action, alg, info, msgInfo, operatorSuffix, targetParameter, argumentTypes, isStochastic, isVariableFactor);

                this.factorManager.PriorityList.RemoveRange(0, this.factorManager.PriorityList.Count - currentPriorityListSize);

                if (alg is VariationalMessagePassing vmp && vmp.UseDerivMessages && isChild && mi.hasNonUnitDerivative && !isVariableFactor)
                {
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(arguments[i]);
                    DerivMessage dm = context.InputAttributes.Get<DerivMessage>(ivd);
                    if (dm != null)
                    {
                        ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(dm.decl);
                        IVariableDeclaration derivMsgVar = ctmi.fwd.decl;
                        IVariableDeclaration forwardVar = Recognizer.GetVariableDeclaration(mi.messageFromFactor);
                        MessageInfo mi2 = new MessageInfo
                        {
                            messageFromFactor = Builder.ReplaceExpression(mi.messageFromFactor, Builder.VarRefExpr(forwardVar), Builder.VarRefExpr(derivMsgVar))
                        };
                        string field = "";
                        msgInfo[field] = mi2;
                        string methodName = targetParameter + "Deriv";
                        ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, methodName, field, argumentTypes, isStochastic, isVariableFactor);
                    }
                }
            }
            this.factorManager.PriorityList.RemoveRange(0, this.factorManager.PriorityList.Count - initialPriorityListSize);
            return null;
        }

        private void AddInitialiserStatement(IExpression message, IExpression factor)
        {
            IVariableDeclaration msgVar = Recognizer.GetVariableDeclaration(message);
            KeyValuePair<IVariableDeclaration, IExpression> key = new KeyValuePair<IVariableDeclaration, IExpression>(msgVar, factor);
            if (analysis.messageInitExprs.TryGetValue(key, out IExpression initExpr))
            {
                IExpressionStatement init = Builder.AssignStmt(message, initExpr);
                context.OutputAttributes.Set(init, new Initializer());
                context.AddStatementBeforeCurrent(init);
            }
        }

        /// <summary>
        /// Create an operator statement which computes the message to the specified argument, and invoke an action.
        /// </summary>
        /// <param name="action">Receives the generated statements</param>
        /// <param name="alg">The algorithm</param>
        /// <param name="info">Factor information</param>
        /// <param name="msgInfo">Dictionary of message information.  May be modified with buffers.</param>
        /// <param name="methodSuffix">Suffix for the operator method</param>
        /// <param name="targetParameter">target argument name</param>
        /// <param name="argumentTypes">Argument types for the operator method.  May be modified with buffers.</param>
        /// <param name="isStochastic">Indicates whether each argument is valid for a formal marked with the Stochastic attribute.</param>
        /// <param name="isVariableFactor">Whether this is a variable factor</param>
        /// <param name="isInit">Whether the statement is an initializer</param>
        /// <param name="alternateSuffix"></param>
        /// <returns></returns>
        protected void ForEachOperatorStatement(Action<IStatement> action, IAlgorithm alg, FactorManager.FactorInfo info, Dictionary<string, MessageInfo> msgInfo,
                                                string methodSuffix, string targetParameter, Dictionary<string, Type> argumentTypes, IReadOnlyDictionary<string, bool> isStochastic,
                                                bool isVariableFactor, bool isInit = false, string alternateSuffix = null)
        {
            var customArgumentTypes = new Dictionary<string, Type>(argumentTypes);
            bool useFactor = (targetParameter == info.ParameterNames[0]) && info.OutputIsDeterministic(customArgumentTypes) && !info.IsVoid && !isVariableFactor;

            // For Gibbs, we do not want to allow EP methods which require projection. A crude
            // way of detecting these is to look at the arguments, and reject any method which
            // includes as an argument the incoming message corresponding to the target parameter
            if (alg is GibbsSampling && (!useFactor) && (!isVariableFactor))
                customArgumentTypes[targetParameter] = typeof(PlaceHolder);

            MessageFcnInfo fninfo;
            if (useFactor) fninfo = info.GetMessageFcnInfoFromFactor();
            else
            {
                fninfo = null;
                if (alternateSuffix != null)
                {
                    try
                    {
                        fninfo = info.GetMessageFcnInfo(factorManager, alternateSuffix, targetParameter, customArgumentTypes, isStochastic);
                    }
                    catch (Exception)
                    {
                        fninfo = null;
                    }
                }
                if (fninfo == null)
                {
                    try
                    {
                        fninfo = info.GetMessageFcnInfo(factorManager, methodSuffix, targetParameter, customArgumentTypes, isStochastic);
                    }
                    catch (ArgumentException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (MissingMethodException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (NotSupportedException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (AmbiguousMatchException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    void ErrorNotSupported(Exception ex)
                    {
                        string opErr = "This model is not supported with " + alg.Name + " due to " + info.ToString() +
                                       ". Try using a different algorithm or expressing the model differently";
                        if ((ex is ArgumentException) && (alg is GibbsSampling) && (!isVariableFactor))
                        {
                            Error(opErr + " Gibbs Sampling requires the conditionals to be conjugate", ex);
                        }
                        else
                            Error(opErr, ex);
                    }
                }
            }

            MessageInfo mi = msgInfo[targetParameter];

            if (fninfo.PassResultIndex)
            {
                Type resultType = argumentTypes[resultName];
                customArgumentTypes[resultIndexName] = typeof(int);
                Type resultElementType = Util.GetElementType(resultType);
                customArgumentTypes[resultName] = resultElementType;
                // Get the expressions for all the arguments to the operator
                List<IExpression> args = GetOperatorArguments(alg, info, fninfo, mi, msgInfo, customArgumentTypes, isStochastic, isVariableFactor);
                VariableInformation vi = VariableInformation.GetVariableInformation(context, mi.channelDecl ?? Recognizer.GetVariableDeclaration(mi.messageToFactor));
                int depth = Recognizer.GetIndexingDepth(mi.messageFromFactor);
                vi.DefineIndexVarsUpToDepth(context, depth + 1);
                IVariableDeclaration indexVar = vi.indexVars[depth][0];
                IExpression size = vi.sizes[depth][0];
                if (depth == vi.LiteralIndexingDepth - 1)
                {
                    // generate a separate statement for each array element
                    int sizeAsInt = (int)((ILiteralExpression)size).Value;
                    for (int j = 0; j < sizeAsInt; j++)
                    {
                        // Create the statement which calls the message function
                        IExpression index = Builder.LiteralExpr(j);
                        IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, index, isVariableFactor, isInit, useFactor);
                        action(st);
                    }
                }
                else
                {
                    // generate a loop that fills in all array elements
                    if (Recognizer.GetLoopForVariable(context, indexVar) != null) indexVar = Builder.VarDecl("_" + resultIndexName, typeof(int));
                    IForStatement fs = Builder.ForStmt(indexVar, size);
                    IExpression index = Builder.VarRefExpr(indexVar);
                    IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, index, isVariableFactor, isInit, useFactor);
                    fs.Body.Statements.Add(st);
                    action(fs);
                }
            }
            else
            {
                customArgumentTypes.Remove(resultIndexName);
                // Get the expressions for all the arguments to the operator
                List<IExpression> args = GetOperatorArguments(alg, info, fninfo, mi, msgInfo, customArgumentTypes, isStochastic, isVariableFactor);
                // Create the statement which calls the message function
                IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, null, isVariableFactor, isInit, useFactor);
                action(st);
            }
        }

        /// <summary>
        /// Creates an assignment statement that invokes a message operator.
        /// </summary>
        /// <param name="alg">The inference algorithm</param>
        /// <param name="info">The factor</param>
        /// <param name="fninfo">The message operator</param>
        /// <param name="mi">The target of the message</param>
        /// <param name="targetParameter">The factor parameter receiving the message</param>
        /// <param name="args">The arguments of the message operator</param>
        /// <param name="index">The index argument of the message operator</param>
        /// <param name="isVariableFactor">True if the factor is a variable factor</param>
        /// <param name="isInit">True if the message operator is an initializer.</param>
        /// <param name="useFactor">True if the message operator is the factor itself.</param>
        /// <returns>An assignment statement that invokes the message operator.</returns>
        protected internal IExpressionStatement GetOperatorStatement(
            IAlgorithm alg,
            FactorManager.FactorInfo info,
            MessageFcnInfo fninfo,
            MessageInfo mi,
            string targetParameter,
            List<IExpression> args,
            IExpression index,
            bool isVariableFactor,
            bool isInit,
            bool useFactor)
        {
            List<IExpression> fullArgs = new List<IExpression>();
            if (fninfo.IsIndexedParameter == null) fullArgs.AddRange(args);
            else
            {
                for (int i = 0; i < args.Count; i++)
                {
                    IExpression arg = args[i];
                    if (fninfo.IsIndexedParameter[i]) arg = Builder.ArrayIndex(arg, index);
                    fullArgs.Add(arg);
                }
            }
            IExpression msg = mi.messageFromFactor;
            if (index != null)
            {
                if (fninfo.ResultIndexParameterIndex != fullArgs.Count)
                    Error("'" + resultIndexName + "' is not the 2nd to last argument of " + StringUtil.MethodSignatureToString(fninfo.Method));
                fullArgs.Add(index);
                msg = Builder.ArrayIndex(msg, index);
            }
            if (fninfo.PassResult)
            {
                if (fninfo.ResultParameterIndex != fullArgs.Count)
                    Error("'" + resultName + "' is not the last argument of " + StringUtil.MethodSignatureToString(fninfo.Method));
                fullArgs.Add(msg);
            }
            fullArgs = ConvertArguments(fninfo.Method, fullArgs);
            IExpression operatorMethod = Builder.StaticMethod(fninfo.Method, fullArgs.ToArray());
            if (!context.OutputAttributes.Has<MessageFcnInfo>(fninfo.Method))
                context.OutputAttributes.Set(fninfo.Method, fninfo);

            IExpression copyOperatorMethod = CheckForCopyOperators(fninfo, args, msg);
            if (copyOperatorMethod != null)
            {
                operatorMethod = copyOperatorMethod;
                // this could be removed if Copy has a Trigger attribute
                isVariableFactor = false;
            }

            // Get the quality band of the operator method and attach an attribute
            // Quality bands on the factor itself are optional, and are handled by
            // the general mechanism in IterativeProcessTransform.
            if (!useFactor && (operatorMethod is IMethodInvokeExpression imie))
            {
                var mr = Recognizer.GetMethodReference(imie);
                // Get the quality band of the operator method and attach an attribute
                QualityBand qualityBand = Quality.GetQualityBand(mr.MethodInfo);
                Context.OutputAttributes.Set(imie, new QualityBandCompilerAttribute(qualityBand));
            }

            // Support for the 'TraceMessages' and 'ListenToMessages' attributes
            if (compiler.TraceAllMessages ||
                (mi.channelDecl != null && (context.InputAttributes.Has<TraceMessages>(mi.channelDecl) ||
                                           context.InputAttributes.Has<ListenToMessages>(mi.channelDecl))))
            {
                string msgText = msg.ToString();
                // Look for TraceMessages attribute that matches this message
                var trace = context.InputAttributes.Get<TraceMessages>(mi.channelDecl);
                if (trace?.Containing != null && !msgText.Contains(trace.Containing)) trace = null;

                // Look for ListenToMessages attribute that matches this message
                var listenTo = context.InputAttributes.Get<ListenToMessages>(mi.channelDecl);
                if (listenTo?.Containing != null && !msgText.Contains(listenTo.Containing)) listenTo = null;


                if ((listenTo != null) || (trace != null) || compiler.TraceAllMessages)
                {
                    IExpression textExpr = DebuggingSupport.GetExpressionTextExpression(msg);
                    if (listenTo != null)
                    {
                        if (messageUpdatedMethod == null)
                        {
                            // Generate message updated event on generated class
                            var td = context.FindOutputForAncestor<ITypeDeclaration, ITypeDeclaration>();
                            var messageUpdatedEvent = Builder.EventDecl(DebuggingSupport.MessageEventName,
                                                                        (ITypeReference)Builder.TypeRef(typeof(EventHandler<MessageUpdatedEventArgs>)), td);
                            messageUpdatedEvent.Documentation = "Event that is fired when a message that is being monitored is updated.";
                            td.Events.Add(messageUpdatedEvent);
                            // Build a wrapper function that allows clients to fire the event
                            messageUpdatedMethod = Builder.FireEventDecl(MethodVisibility.Private, "On" + DebuggingSupport.MessageEventName, messageUpdatedEvent);
                        }
                        // Generate code to emit message events
                        var methodRef = new CodeModel.Concrete.XMethodReference(messageUpdatedMethod);
                        var mre = Builder.MethodRefExpr();
                        mre.Method = methodRef;
                        mre.Target = Builder.ThisRefExpr();
                        operatorMethod = Builder.StaticGenericMethod(
                            new Func<PlaceHolder, string, Action<MessageUpdatedEventArgs>, bool, PlaceHolder>(Tracing.FireEvent<PlaceHolder>),
                            new Type[] { fninfo.Method.ReturnType }, operatorMethod, textExpr, mre, Builder.LiteralExpr(trace != null));
                    }
                    else
                    {
                        // Add a call to Tracing.Trace() to cause the message to be written to a TraceWriter
                        operatorMethod = Builder.StaticGenericMethod(new Func<PlaceHolder, string, PlaceHolder>(Tracing.Trace<PlaceHolder>),
                                                                     new Type[] { fninfo.Method.ReturnType }, operatorMethod, textExpr);
                    }
                }
            }

            bool needAllTriggers = false;
            IAssignExpression assignExpr = Builder.AssignExpr(msg, operatorMethod);
            Type lhsType = assignExpr.Target.GetExpressionType();
            Type rhsType = assignExpr.Expression.GetExpressionType();
            if (lhsType == typeof(Bernoulli) && rhsType == typeof(double))
            {
                assignExpr.Expression = Builder.StaticMethod(new Func<double, Bernoulli>(Bernoulli.FromLogOdds), assignExpr.Expression);
            }
            else if (!lhsType.IsAssignableFrom(rhsType))
            {
                // if the lhs and rhs have different types, convert from:
                //   x = f(y);
                // to:
                //   x = SetPoint(x,f(y));
                assignExpr.Expression = SetPointExpression(assignExpr.Target, lhsType, assignExpr.Expression, rhsType);
            }

            string argName = "'" + targetParameter + "'";
            if (targetParameter.Length == 0) argName = "evidence";
            if (mi.channelDecl != null)
                context.OutputAttributes.Set(assignExpr, new DescriptionAttribute("Message to '" + mi.channelDecl.Name + "' from " + info.Method.Name + " factor"));
            var st = Builder.ExprStatement(assignExpr);
            if (fninfo.AllTriggers) needAllTriggers = true;
            else if (alg is VariationalMessagePassing vmp && !isVariableFactor && !vmp.UseDerivMessages && !fninfo.NoTriggers)
            {
                needAllTriggers = true;
            }
            else if (alg is GibbsSampling && !fninfo.IsStochastic)
            {
                // For Gibbs, all factors need triggers. The only edge that should not
                // be triggered is the one drawing samples.
                needAllTriggers = true;
            }
            if (needAllTriggers) context.OutputAttributes.Set(operatorMethod, new AllTriggersAttribute());

            if (isInit)
                context.OutputAttributes.Set(st, new Initializer());
            else
                context.OutputAttributes.Set(st, new OperatorStatement());
            if (fninfo.IsMultiplyAll) context.OutputAttributes.Set(st, new MultiplyAllCompilerAttribute());
            if (fninfo.IsStochastic) context.OutputAttributes.Set(st, new DependsOnIteration());
            if (mi.channelDecl != null)
                context.InputAttributes.CopyObjectAttributesTo<InitialiseBackward>(mi.channelDecl, context.OutputAttributes, st);
            return st;
        }

        /// <summary>
        /// Checks to see if this operator is just copying one of its parameters and hence can be
        /// optimised away.
        /// </summary>
        /// <param name="fninfo">The operator function info</param>
        /// <param name="args">The operator arguments</param>
        /// <param name="msg">The expression for the LHS which will store the result of the operator</param>
        /// <returns>The new expression to compute the result of the operation, or null if the operator is not a copy</returns>
        private IExpression CheckForCopyOperators(MessageFcnInfo fninfo, IList<IExpression> args, IExpression msg)
        {
            if (!UseCopyOperators)
                return null;
            // Find out if the operator is just copying one of its arguments
            int copyArg = fninfo.ReturnedParameterIndex;
            if (copyArg != -1)
            {
                IExpression argToBeCopied = args[copyArg];
                Type resultType = msg.GetExpressionType();
                if (argToBeCopied == null)
                {
                    Error("method argument is null");
                    return null;
                }
                Type sourceType = argToBeCopied.GetExpressionType();
                if (resultType.IsArray)
                {
                    Type eltType = resultType.GetElementType();
                    if (Distribution.IsDistributionType(eltType) && Distribution.IsSettableTo(eltType, argToBeCopied.GetExpressionType()))
                    {
                        if (resultType.GetArrayRank() != 1) Error("array rank > 1 is not supported in this context");
                        return Builder.StaticGenericMethod(new Func<Bernoulli[], Bernoulli[], Bernoulli[]>(ArrayHelper.SetTo),
                                                           new Type[] { eltType }, msg, argToBeCopied);
                    }
                    else
                        return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(Factor.Copy<PlaceHolder>),
                                                           new Type[] { sourceType }, argToBeCopied);
                }
                else
                {
                    // must use IsDistributionType here, not IsSettableTo, because only DistributionTypes are guaranteed to be initialized
                    if (Distribution.IsDistributionType(resultType) && Distribution.IsSettableTo(resultType, argToBeCopied.GetExpressionType()))
                        // TODO: find the appropriate generic type parameter, similar to SetPointExpression
                        return Builder.StaticGenericMethod(new Func<Bernoulli, Bernoulli, Bernoulli>(ArrayHelper.SetTo),
                                                           new Type[] { resultType }, msg, argToBeCopied);
                    else
                        return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(Factor.Copy<PlaceHolder>),
                                                           new Type[] { sourceType }, argToBeCopied);
                }
            }

            // Find out if the operator is copying one of its arguments in every element of the returned value.
            int copyMultipleArg = fninfo.ReturnedInAllElementsParameterIndex;
            if (copyMultipleArg != -1)
            {
                IExpression argToBeCopied = args[copyMultipleArg];
                Type resultType = msg.GetExpressionType();
                if (resultType.IsArray)
                {
                    if (resultType.GetArrayRank() != 1) Error("array rank > 1 is not supported in this context");
                    return Builder.StaticGenericMethod(new Func<double[], double, double[]>(ArrayHelper.SetAllElementsTo),
                                                       new Type[] { argToBeCopied.GetExpressionType() }, msg, argToBeCopied);
                }
                else
                {
                    return Builder.StaticGenericMethod(new Func<Vector, double, Vector>(ArrayHelper.SetAllElementsTo),
                                                       new Type[] { msg.GetExpressionType(), argToBeCopied.GetExpressionType() }, msg, argToBeCopied);
                }
            }

            // Special handling of DiscreteUniform.SampleAverageConditional
            if (fninfo.Method.Equals(new Func<int, Discrete, Discrete>(DiscreteUniform.SampleAverageConditional).Method))
            {
                IExpression size = args[0];
                // check the marginal prototype of the result argument
                IExpression result = msg;
                IVariableDeclaration resultVar = Recognizer.GetVariableDeclaration(result);
                MessageArrayInformation mai = context.InputAttributes.Get<MessageArrayInformation>(resultVar);
                IExpression mpe = mai.marginalPrototypeExpression;
                IExpression prototypeSize = StocAnalysisTransform.GetDiscreteLengthExpression(mpe);
                if (size.Equals(prototypeSize))
                {
                    return MakeUniform(mpe);
                }
            }

            return null;
        }

        /// <summary>
        /// Adds statements that create a buffer for a message operator.
        /// </summary>
        /// <param name="name">Name of the buffer</param>
        /// <param name="type">Type of the buffer</param>
        /// <param name="alg">Inference algorithm</param>
        /// <param name="info">The factor</param>
        /// <param name="fcninfo">The message operator that requested the buffer</param>
        /// <param name="miTgt">The target message that requested the buffer</param>
        /// <param name="msgInfo">Modified to have the buffer</param>
        /// <param name="argumentTypes">Modified to have the buffer</param>
        /// <param name="isStochastic">Indicates whether each argument must be stochastic or not</param>
        /// <param name="isVariableFactor">True if this is a variable factor</param>
        private MessageInfo CreateBuffer(
            string name,
            Type type,
            IAlgorithm alg,
            FactorManager.FactorInfo info,
            MessageFcnInfo fcninfo,
            MessageInfo miTgt,
            Dictionary<string, MessageInfo> msgInfo,
            Dictionary<string, Type> argumentTypes,
            IReadOnlyDictionary<string, bool> isStochastic,
            bool isVariableFactor)
        {
            if (type != null)
                argumentTypes[name] = type;
            else
                argumentTypes.Remove(name);
            Type oldResultType = argumentTypes[resultName];
            Type oldResultIndexType = argumentTypes.ContainsKey(resultIndexName) ? argumentTypes[resultIndexName] : null;
            if (type != null)
                argumentTypes[resultName] = type;
            else
                argumentTypes.Remove(resultName);
            argumentTypes.Remove(resultIndexName);
            MessageFcnInfo fcninfo2 = info.GetMessageFcnInfo(factorManager, "", name, argumentTypes, isStochastic);
            if (type == null)
            {
                if (!fcninfo2.PassResultIndex)
                    type = fcninfo2.Method.ReturnType;
                else
                {
                    // must get buffer type from Init method
                    MessageFcnInfo fcninfoInit = info.GetMessageFcnInfo(factorManager, "Init", name, argumentTypes, isStochastic);
                    if (fcninfoInit.PassResultIndex)
                    {
                        Error("Init method expects resultIndex but this is not supported");
                    }
                    type = fcninfoInit.Method.ReturnType;
                }
                argumentTypes[name] = type;
                argumentTypes[resultName] = type;
            }
            string prefix = miTgt.messageFromFactor.ToString();
            if (true)
            {
                // prefix the buffer name with the name of the first argument of its defining function
                ParameterInfo parameter2 = fcninfo2.Method.GetParameters()[0];
                string factorParameterName2 = fcninfo2.factorEdgeOfParameter[parameter2.Name].ParameterName;
                if (msgInfo.TryGetValue(factorParameterName2, out MessageInfo mi2))
                {
                    prefix = mi2.messageToFactor.ToString();
                }
            }
            prefix = CodeBuilder.MakeValid(prefix);
            IVariableDeclaration bufferDecl = Builder.VarDecl(VariableInformation.GenerateName(context, prefix + "_" + name), type);
            context.OutputAttributes.Set(bufferDecl, new DescriptionAttribute("Buffer for " + StringUtil.EscapeXmlCharacters(StringUtil.MethodFullNameToString(fcninfo.Method))));
            context.OutputAttributes.Set(bufferDecl, new Containers(context));
            IExpression msg = Builder.VarRefExpr(bufferDecl);
            MessageInfo mi = new MessageInfo
            {
                ////channelDecl = miTgt.channelDecl,
                messageFromFactor = msg,
                messageToFactor = msg
            };
            msgInfo[name] = mi;
            string flippedName = FactorManager.FlipCapitalization(name);
            msgInfo[flippedName] = mi;
            // TODO: fix this in cases where buffers form a cycle and therefore need inits
            if (fcninfo2.PassResult || HasParameter(fcninfo2, name) || HasParameter(fcninfo2, flippedName))
            {
                context.AddStatementBeforeCurrent(Builder.ExprStatement(Builder.VarDeclExpr(bufferDecl)));
                ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, "Init", name, argumentTypes, isStochastic, isVariableFactor, true);
            }
            else
            {
                var assignSt = Builder.AssignStmt(Builder.VarDeclExpr(bufferDecl), Builder.DefaultExpr(type));
                context.OutputAttributes.Set(assignSt, new Initializer());
                context.AddStatementBeforeCurrent(assignSt);
                context.OutputAttributes.Set(bufferDecl, new DoesNotHaveInitializer());
            }
            ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, "", name, argumentTypes, isStochastic, isVariableFactor);
            argumentTypes[resultName] = oldResultType;
            if (oldResultIndexType != null)
                argumentTypes[resultIndexName] = oldResultIndexType;
            return mi;
        }

        /// <summary>
        /// Get the operator arguments for a specified operator method
        /// </summary>
        /// <param name="alg">The algorithm</param>
        /// <param name="info">Factor information</param>
        /// <param name="fcninfo">Operator method information</param>
        /// <param name="miTgt">The message info for the target argument</param>
        /// <param name="msgInfo">Message information for each field.  May be modified with buffers.</param>
        /// <param name="argumentTypes">Argument types for the operator method.  May be modified with buffers.</param>
        /// <param name="isStochastic">Whether each argument can be stochastic.</param>
        /// <param name="isVariableFactor">Whether this is a variable factor</param>
        /// <returns></returns>
        protected List<IExpression> GetOperatorArguments(IAlgorithm alg, FactorManager.FactorInfo info, MessageFcnInfo fcninfo,
                                                         MessageInfo miTgt, Dictionary<string, MessageInfo> msgInfo, Dictionary<string, Type> argumentTypes,
                                                         IReadOnlyDictionary<string, bool> isStochastic,
                                                         bool isVariableFactor)
        {
            List<IExpression> args = new List<IExpression>();
            // Get the parameters of the operator method
            ParameterInfo[] parameters = fcninfo.Method.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo parameter = parameters[i];
                if (parameter.Name == resultName || parameter.Name == resultIndexName) continue;
                FactorEdge factorEdge;
                if (!fcninfo.factorEdgeOfParameter.TryGetValue(parameter.Name, out factorEdge))
                {
                    Error("Parameter name '" + parameter.Name + "' is unrecognized in " + StringUtil.MethodFullNameToString(fcninfo.Method));
                    continue;
                }
                string factorParameterName = factorEdge.ParameterName;
                bool isOutgoingMessage = factorEdge.IsOutgoingMessage;
                MessageInfo mi;
                if (!msgInfo.TryGetValue(factorParameterName, out mi))
                {
                    // create a buffer
                    Type bufferType = parameter.ParameterType;
                    if (fcninfo.IsIndexedParameter != null && fcninfo.IsIndexedParameter[i])
                        bufferType = null;
                    try
                    {
                        mi = CreateBuffer(factorParameterName, bufferType, alg, info, fcninfo, miTgt, msgInfo, argumentTypes, isStochastic, isVariableFactor);
                    }
                    catch (Exception ex)
                    {
                        Error("Could not construct operator method", ex);
                        args.Add(null);
                        continue;
                    }
                }
                if (mi.hasNonUnitDerivative)
                {
                    object[] attrs = parameter.GetCustomAttributes(typeof(Stochastic), true);
                    if ((attrs != null) && (attrs.Length > 0))
                    {
                        Error("Argument '" + parameter.Name + "' to operator method '" + StringUtil.MethodFullNameToString(fcninfo.Method) +
                              "' must not be a derived variable.   Set Compiler.AllowDerivedParents = true if you want to risk running inference in this model.");
                    }
                }
                if (isOutgoingMessage && mi.messageFromFactor == null)
                {
                    Error("The operator method requires a message to " + factorParameterName + " but there is no such message");
                }
                IExpression value = isOutgoingMessage ? mi.messageFromFactor : mi.messageToFactor;
                bool isWeaklyTyped = isVariableFactor && parameter.Name == "init";
                if (isWeaklyTyped)
                {
                    value = ConvertInitialiser(value);
                    value = ConvertInitialiser(value, parameter.ParameterType, null, 0, false);
                }
                args.Add(value);
            }
            return args;
        }

        private List<IExpression> ConvertArguments(MethodInfo method, IList<IExpression> args)
        {
            List<IExpression> convertedArgs = new List<IExpression>();
            ParameterInfo[] parameters = method.GetParameters();
            for (int i = 0; i < args.Count; i++)
            {
                IExpression arg = args[i];
                if (arg == null) continue;
                Type argType = arg.GetExpressionType();
                IExpression convertedArg = arg;
                ParameterInfo parameter = parameters[i];
                if (!parameter.ParameterType.IsAssignableFrom(argType))
                {
                    Type distType = parameter.ParameterType;
                    Type domainType = argType;
                    MethodInfo pointMassMethod = FactorManager.GetPointMassMethod(distType, domainType);
                    if (pointMassMethod != null)
                    {
                        convertedArg = Builder.StaticMethod(pointMassMethod, arg);
                    }
                    else
                    {
                        Error("Cannot convert from '" + StringUtil.TypeToString(argType) + "' to '" + StringUtil.TypeToString(distType) + "' for argument of method " +
                              StringUtil.MethodSignatureToString(method));
                    }
                }
                convertedArgs.Add(convertedArg);
            }
            if (convertedArgs.Count != args.Count || convertedArgs.Count != parameters.Length) Error("Some arguments were not converted");
            return convertedArgs;
        }

        private static bool HasBuffer(MessageFcnInfo fcninfo, string name)
        {
            object[] bufferAttrs = fcninfo.Method.DeclaringType.GetCustomAttributes(typeof(BuffersAttribute), true);
            foreach (BuffersAttribute bufferAttr in bufferAttrs)
            {
                foreach (string bufferName in bufferAttr.BufferNames)
                {
                    if (name == bufferName) return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Indicates whether the given factor parameter is an argument of the given message operator.
        /// </summary>
        /// <param name="fcninfo">The message operator</param>
        /// <param name="name">The factor parameter name</param>
        /// <returns>True if the factor parameter is an argument of the message operator</returns>
        /// <exception cref="NotSupportedException">The message operator has an unrecognized argument.</exception>
        private bool HasParameter(MessageFcnInfo fcninfo, string name)
        {
            ParameterInfo[] parameters = fcninfo.Method.GetParameters();
            foreach (ParameterInfo parameter in parameters)
            {
                if (fcninfo.factorEdgeOfParameter.TryGetValue(parameter.Name, out FactorEdge edge)) 
                {
                    if (edge.ParameterName == name) return true;
                }
                else Error("Unrecognized parameter " + parameter.Name + " in method " + StringUtil.MethodSignatureToString(fcninfo.Method));
            }
            return false;
        }

        protected override IExpression ConvertAssign(IAssignExpression iae)
        {
            if (iae.Target is IVariableDeclarationExpression ivde)
            {
                if (IsStochasticVariableReference(ivde))
                {
                    ConvertExpression(iae.Target);
                    IAssignExpression ae2 = Builder.AssignExpr();
                    ae2.Target = Builder.VarRefExpr(ivde.Variable);
                    ae2.Expression = iae.Expression;
                    return ConvertExpression(ae2);
                }
            }

            // This will automatically convert the lhs into a forward message.
            IAssignExpression ae = (IAssignExpression)base.ConvertAssign(iae);
            if (ae == null || ae.Target == null || ae.Expression == null) return null;
            Type lhsType = ae.Target.GetExpressionType();
            Type rhsType = ae.Expression.GetExpressionType();
            if (lhsType == null)
            {
                Error("Cannot determine type of " + ae.Target);
                return null;
            }
            if (!lhsType.IsAssignableFrom(rhsType))
            {
                // if the lhs and rhs have different types, convert from:
                //   x = f(y);
                // to:
                //   x = SetPoint(x,f(y));
                ae.Expression = SetPointExpression(ae.Target, lhsType, ae.Expression, rhsType);
            }
            return ae;
        }

        private IExpression SetPointExpression(IExpression target, Type targetType, IExpression expression, Type expressionType)
        {
            try
            {
                Type hasPoint = targetType.GetInterface(typeof(HasPoint<>).Name);
                expressionType = hasPoint.GetGenericArguments()[0];
                return Builder.StaticGenericMethod(new Func<Bernoulli, bool, Bernoulli>(Distribution.SetPoint),
                                                            new Type[] { targetType, expressionType }, target, expression);
            }
            catch (Exception ex)
            {
                Error("Cannot call SetPoint on " + StringUtil.TypeToString(targetType), ex);
                return expression;
            }
        }

        protected IExpression ConvertInfer(IMethodInvokeExpression imie)
        {
            //IStatement ist = context.FindOutputForAncestor<IStatement, IStatement>();
            IStatement ist = context.FindAncestor<IStatement>();
            context.OutputAttributes.Set(ist, new OperatorStatement());
            object decl = Recognizer.GetDeclaration(imie.Arguments[0]);
            // This will automatically convert the argument into a forward message
            // make a copy if we will modify later
            this.ShallowCopy = (decl != null);
            IMethodInvokeExpression mie = (IMethodInvokeExpression)base.ConvertMethodInvoke(imie);
            this.ShallowCopy = false;
            if (decl != null)
            {
                QueryType query = null;
                if (mie.Arguments.Count >= 3)
                {
                    ExpressionEvaluator eval = new ExpressionEvaluator();
                    query = (QueryType)eval.Evaluate(mie.Arguments[2]);
                }
                ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(decl);
                if (ctmi == null)
                {
                    ctmi = context.InputAttributes.Get<ObservedVariableMessages>(decl)?.ctmi;
                }
                if (ctmi != null)
                {
                    MessageDirection direction = (query == QueryTypes.MarginalDividedByPrior) ? MessageDirection.Backwards : MessageDirection.Forwards;
                    MessageArrayInformation mai = (direction == MessageDirection.Backwards) ? ctmi.bck : ctmi.fwd;
                    mie.Arguments[0] = Builder.VarRefExpr(mai.decl);
                }
                if (mie.Arguments.Count == 1)
                {
                    string varName;
                    if (decl is IParameterDeclaration ipd) varName = ipd.Name;
                    else varName = ((IVariableDeclaration)decl).Name;
                    ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(decl);
                    if (ci != null) varName = ci.varInfo.Name;
                    mie.Arguments.Add(Builder.LiteralExpr(varName));
                }
            }
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(mie.Arguments[0]);
            if (ivd != null && !context.InputAttributes.Has<IsInferred>(ivd))
                context.OutputAttributes.Set(ivd, new IsInferred());
            return mie;
        }

        /// <summary>
        /// Returns true if the supplied expression is stochastic.  
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        protected bool IsStochasticVariableReference(IExpression expr)
        {
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(expr);
            return (ivd != null) && context.InputAttributes.Has<ChannelInfo>(ivd);
        }

        // Create the statements for creating forward and backward message arrays.
        // These are the _F and _B variables in the generated code. The MessageArrayInformation
        // instances record information about these variables 
        private MessageArrayInformation CreateMessageVariable(string name, ChannelInfo channelInfo, ChannelToMessageInfo ctmi, MessageDirection direction,
                                                               ChannelPathAttribute[] cpas)
        {
            string messageName = name + (direction == MessageDirection.Backwards ? "_B" : "_F");
            List<QueryType> qtlist;
            if (channelInfo.decl != null && !context.InputAttributes.Has<IsInferred>(channelInfo.decl)) qtlist = new List<QueryType>();
            else qtlist = context.InputAttributes.GetAll<QueryTypeCompilerAttribute>(channelInfo.varInfo.declaration).Select(attr => attr.QueryType).ToList();
            // Ask the algorithm for the message prototype in this direction
            // Message types may be different in each direction
            VariableInformation vi;
            if (channelInfo.decl != null)
            {
                vi = VariableInformation.GetVariableInformation(context, channelInfo.decl);
            }
            else vi = channelInfo.varInfo;
            if (vi.marginalPrototypeExpression == null)
            {
                try
                {
                    vi.SetMarginalPrototypeFromAttribute(null);
                }
                catch (Exception ex)
                {
                    Error(ex.Message);
                }
            }
            IExpression prototypeExpression = vi.marginalPrototypeExpression;
            IExpression mpe = algorithm.GetMessagePrototype(channelInfo, direction, prototypeExpression, null, qtlist);
            Type innermostType = mpe.GetExpressionType();
            string path = "";
            // Check for any path attributes for the channel
            bool foundOne = false;
            bool foundNonDefault = false;

            foreach (ChannelPathAttribute cpa in cpas)
            {
                if (cpa.Direction != direction)
                    continue;

                // If we've already found a path for this direction
                // and this is default path, continue
                if (foundOne && cpa.FromDefault)
                    continue;

                bool notDefault = !cpa.FromDefault;

                // Flag an error if there are two inconsistent non-default paths
                if (foundNonDefault && notDefault && cpa.Path != path)
                    Error(String.Format("Inconsistent message types for {0}. If you have manually specified groups, try changing the root variable.", messageName));

                if (!foundNonDefault)
                {
                    path = cpa.Path;
                    mpe = algorithm.GetMessagePrototype(channelInfo, direction, prototypeExpression, path, qtlist);
                    innermostType = mpe.GetExpressionType();
                    foundOne = true;
                    foundNonDefault = notDefault;
                }
            }
            // See if this is a distribution
            bool isDistribution = Distribution.IsDistributionType(innermostType) && Distribution.GetDomainType(innermostType).Equals(Distribution.GetDomainType(prototypeExpression.GetExpressionType()));

            // Cache the message type
            bool isGibbsMarginal = false;
            Type messageType;
            if (isDistribution)
                messageType = GetMessageType(channelInfo, innermostType);
            else if (algorithm is GibbsSampling && channelInfo.IsMarginal)
            {
                messageType = innermostType;
                isGibbsMarginal = true;
            }
            else
            {
                messageType = JaggedArray.GetTypes(
                    channelInfo.channelType,
                    JaggedArray.GetInnermostType(channelInfo.channelType),
                    innermostType)[0];
            }
            // Cache the message array information, including the declaration
            MessageArrayInformation mai = new MessageArrayInformation
            {
                // Create the variable declaration of the message array variable
                decl = Builder.VarDecl(messageName, messageType),
                ci = channelInfo,
                isDistribution = isDistribution,
                marginalPrototypeExpression = mpe
            };
            // Attach the message array information as an attribute on the variable declaration
            context.OutputAttributes.Set(mai.decl, mai);
            if (direction == MessageDirection.Backwards)
            {
                ctmi.bck = mai;
            }
            else
            {
                ctmi.fwd = mai;
            }
            VariableInformation messageInfo = VariableInformation.GetVariableInformation(context, mai.decl);
            if (!isGibbsMarginal)
            {
                messageInfo.indexVars = vi.indexVars;
                messageInfo.sizes = vi.sizes;
            }

            if (channelInfo.decl != null)
            {
                // Description of this message array variable - this will eventually get built into a code comment
                DescriptionAttribute da = context.InputAttributes.Get<DescriptionAttribute>(channelInfo.decl);
                if (da != null)
                {
                    string s = "Message";
                    if (mai.decl.VariableType.DotNetType.IsArray) s += "s";
                    bool isFrom = (direction == MessageDirection.Backwards);
                    if (channelInfo.IsDef) isFrom = !isFrom;
                    if (isFrom) s += " from ";
                    else s += " to ";
                    context.OutputAttributes.Set(mai.decl, new DescriptionAttribute(s + da.Description));
                }

                // Propagate InitialiseTo attribute
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(channelInfo.decl);
                if (it != null)
                {
                    if (channelInfo.IsMarginal || direction == MessageDirection.Forwards)
                    {
                        context.OutputAttributes.Set(mai.decl, it);
                    }
                }

                // Propagate InitialiseBackward
                InitialiseBackward ib = context.InputAttributes.Get<InitialiseBackward>(channelInfo.decl);
                if (ib != null)
                {
                    if (direction == MessageDirection.Backwards)
                    {
                        context.OutputAttributes.Set(mai.decl, ib);
                    }
                }

                // Propagate InitialiseBackwardTo
                InitialiseBackwardTo ibt = context.InputAttributes.Get<InitialiseBackwardTo>(channelInfo.decl);
                if (ibt != null)
                {
                    if (direction == MessageDirection.Backwards)
                    {
                        context.OutputAttributes.Set(mai.decl, new InitialiseTo(ibt.initialMessagesExpression));
                    }
                }
            }

            return mai;
        }

        private MessageArrayInformation CreateMessageVariable2(string name, ChannelInfo channelInfo, ChannelToMessageInfo ctmi, MessageDirection direction,
                                                                ChannelPathAttribute[] cpas)
        {
            Dictionary<IVariableDeclaration, IVariableDeclaration> messageVars = (direction == MessageDirection.Forwards) ? analysis.fwdMessageVars : analysis.bckMessageVars;
            IVariableDeclaration messageVar;
            if (!messageVars.TryGetValue(channelInfo.decl, out messageVar)) return null;
            Type messageType = messageVar.VariableType.DotNetType;

            // See if this is a distribution
            bool isDistribution = Distribution.IsDistributionType(messageType);

            // Cache the message array information, including the declaration
            MessageArrayInformation mai = new MessageArrayInformation
            {
                // Create the variable declaration of the message array variable
                decl = messageVar,
                ci = channelInfo,
                isDistribution = isDistribution
            };
            //mai.marginalPrototypeExpression = initExpr;
            // Attach the message array information as an attribute on the variable declaration
            context.OutputAttributes.Set(mai.decl, mai);
            if (direction == MessageDirection.Backwards)
            {
                ctmi.bck = mai;
            }
            else
            {
                ctmi.fwd = mai;
            }

            // Description of this message array variable - this will eventually get built into a code comment
            DescriptionAttribute da = context.InputAttributes.Get<DescriptionAttribute>(channelInfo.decl);
            if (da != null)
            {
                string s = "Message";
                if (mai.decl.VariableType.DotNetType.IsArray) s += "s";
                bool isFrom = (direction == MessageDirection.Backwards);
                if (channelInfo.IsDef) isFrom = !isFrom;
                if (isFrom) s += " from ";
                else s += " to ";
                context.OutputAttributes.Set(mai.decl, new DescriptionAttribute(s + da.Description));
            }

            // Propagate InitialiseTo attribute
            InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(channelInfo.decl);
            if (it != null)
            {
                if (channelInfo.IsMarginal || direction == MessageDirection.Forwards)
                {
                    context.OutputAttributes.Set(mai.decl, it);
                }
            }

            // Propagate InitialiseBackwardTo attribute
            InitialiseBackwardTo ibt = context.InputAttributes.Get<InitialiseBackwardTo>(channelInfo.decl);
            if (ibt != null)
            {
                if (direction == MessageDirection.Backwards)
                {
                    context.OutputAttributes.Set(mai.decl, new InitialiseTo(ibt.initialMessagesExpression));
                }
            }

            return mai;
        }

        /// <summary>
        /// Convert a variable declaration expression. Each channel declaration expression
        /// is converted to a forward and a backward message declaration expression. Message
        /// array information for both directions is recorded
        /// </summary>
        /// <param name="ivde">The channel variable declaration expression</param>
        /// <returns>null</returns>
        protected override IExpression ConvertVariableDeclExpr(IVariableDeclarationExpression ivde)
        {
            IVariableDeclaration ivd = ivde.Variable;
            context.InputAttributes.Remove<Containers>(ivd);
            context.OutputAttributes.Set(ivd, new Containers(context));
            ChannelInfo channelInfo = context.InputAttributes.Get<ChannelInfo>(ivd);
            // If a variable is stochastic it will get turned into channels, so channelInfo==null
            // identifies a non-stochastic variable
            if (channelInfo == null)
            {
                return ivde; // The variable is constant.
            }
            // ChannelToMessageInfo records any info needed to convert channels to messages
            // including references to the forward and backward message array information
            ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
            if (ctmi == null)
            {
                ctmi = new ChannelToMessageInfo();
                // Attach the info to declaration of channel variable
                context.InputAttributes.Set(ivd, ctmi);
            }
            var cpas = context.InputAttributes.GetAll<ChannelPathAttribute>(ivd).ToArray();
            foreach (MessageDirection direction in directions)
            {
                MessageArrayInformation mai = UseMessageAnalysis
                                                  ? CreateMessageVariable2(ivd.Name, channelInfo, ctmi, direction, cpas)
                                                  : CreateMessageVariable(ivd.Name, channelInfo, ctmi, direction, cpas);
                if (mai == null) continue;
                context.OutputAttributes.Set(mai.decl, new Containers(context));
                // Make the declaration expression for the message array variable
                IExpressionStatement stmt = MakeDeclStatement(channelInfo, mai);
                // This will be a declaration expression if this is an array and
                // a declaration with assignment otherwise
                if (InitializeOnSeparateLine && stmt.Expression is IAssignExpression iae)
                {
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(iae.Target));
                    iae.Target = Builder.VarRefExpr(mai.decl);
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(iae));
                }
                else context.AddStatementBeforeCurrent(stmt);
            }
            return null;
        }

        /// <summary>
        /// Make the declaration statement for a message array variable
        /// </summary>
        /// <param name="channelInfo">The channel information</param>
        /// <param name="mai">The information for the message array variable</param>
        /// <returns>An assign expression or a declaration expression</returns>
        protected IExpressionStatement MakeDeclStatement(ChannelInfo channelInfo, MessageArrayInformation mai)
        {
            // Build the declaration expression
            IVariableDeclarationExpression ivde = Builder.VarDeclExpr(mai.decl);
            // Attach the quality band for the declaration expression
            Type msgType = mai.messageArrayType;
            if (Distribution.HasDistributionType(msgType))
            {
                QualityBand qb = Distribution.GetQualityBand(msgType);
                Context.OutputAttributes.Set(ivde, new QualityBandCompilerAttribute(qb));
            }

            VariableInformation channelVarInfo = (channelInfo.decl != null)
                ? context.InputAttributes.Get<VariableInformation>(channelInfo.decl)
                : channelInfo.varInfo;
            // Note: sizes.Count != ArrayDepth in general
            // If this variable has sizes, then it must have array create expressions, which will be handled by DoConvertArray.
            // However, !mai.isDistribution implies DoConvertArray will always have elementInit==null and generates no statements.
            if (channelVarInfo.sizes.Count == 0 || (!mai.isDistribution && !(algorithm is GibbsSampling)))
            {
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                bool userInitialized = (it != null);
                IExpression expr;
                if (it != null)
                {
                    if (IsGibbsMarginal(msgType))
                    {
                        AddGibbsMarginalInitStatements(Builder.VarRefExpr(mai.decl), it.initialMessagesExpression, channelVarInfo);
                        expr = mai.marginalPrototypeExpression;
                    }
                    else
                    {
                        expr = ConvertInitialiser(it.initialMessagesExpression);
                        expr = ConvertInitialiser(expr, msgType, channelVarInfo);
                    }
                }
                else if (!UseMessageAnalysis && mai.isDistribution) expr = MakeUniform(mai.marginalPrototypeExpression);
                else expr = mai.marginalPrototypeExpression;
                if (expr != null)
                {
                    if (!msgType.IsAssignableFrom(expr.GetExpressionType()))
                        Error($"Invalid initializer: {ivde} = {expr}");
                    IExpressionStatement init = Builder.AssignStmt(ivde, expr);
                    context.OutputAttributes.Set(init, new Initializer() { UserInitialized = userInitialized });
                    return init;
                }
            }
            IExpressionStatement declSt = Builder.ExprStatement(ivde);
            context.OutputAttributes.Set(declSt, new Initializer());
            return declSt;
        }

        protected override IExpression ConvertArrayCreate(IArrayCreateExpression iace)
        {
            // Get the index of the assignment expression whose RHS is this array create expression 
            int assignIndex = context.FindAncestorIndex<IAssignExpression>();
            // In MSL, random variable array creation can only occur on the RHS of an assignment.  
            if (assignIndex == context.InputStack.Count - 2)
            {
                IAssignExpression iae = (IAssignExpression)context.GetAncestor(assignIndex);
                IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
                if (ivd != null)
                {
                    ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(ivd);
                    ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
                    if (ctmi != null)
                    {
                        int depth = Recognizer.GetIndexingDepth(iae.Target);
                        foreach (var direction in directions)
                        {
                            CreateArray(direction, iace, iae.Target, depth, ivd, ci, ctmi);
                        }
                        return null;
                    }
                }
            }
            return base.ConvertArrayCreate(iace);
        }

        private void CreateArray(MessageDirection direction, IArrayCreateExpression iace, IExpression lhs, int depth, IVariableDeclaration ivd, ChannelInfo ci, ChannelToMessageInfo ctmi)
        {
            //lhs = Builder.ReplaceVariable(lhs, ivd, mai.decl);
            lhs = GetMessageExpression(lhs, direction);
            IExpression rhs = UseMessageAnalysis
                                  ? DoConvertArray2(direction, ivd, lhs, iace, depth, ctmi)
                                  : DoConvertArray(direction, ivd, lhs, iace, depth, ci, ctmi);
            if (rhs != null)
            {
                IExpressionStatement st = Builder.AssignStmt(lhs, rhs);
                context.OutputAttributes.Set(st.Expression, new DescriptionAttribute("Create array for '" + ci.decl.Name + "' " + direction + " messages."));
                Initializer ia = context.OutputAttributes.Get<Initializer>(rhs);
                if (ia != null)
                {
                    context.OutputAttributes.Remove<Initializer>(rhs);
                    context.OutputAttributes.Set(st, ia);
                }
                context.AddStatementBeforeCurrent(st);
            }
        }

        private IExpression DoConvertArray2(
            MessageDirection direction,
            IVariableDeclaration inputTarget,
            IExpression outputLhs,
            IArrayCreateExpression iace, int depth,
            ChannelToMessageInfo ctmi)
        {
            // mai is also an attribute of outputLhs
            MessageArrayInformation mai = (direction == MessageDirection.Forwards) ? ctmi.fwd : ctmi.bck;
            if (mai == null) return null;
            Type messageType = mai.messageArrayType; // type of the entire message array at the top level

            // arrayType must be a distribution array
            IList<IExpression> args = Builder.ExprCollection();
            //if (ci.ArrayDepth == depth + 1) args.Add(elementInit);
            args.AddRange(iace.Dimensions);
            Type arrayType = messageType; // type of this array
            if (!IsGibbsMarginal(arrayType))
            {
                for (int i = 0; i < depth; i++)
                {
                    arrayType = Util.GetElementType(arrayType);
                }
            }
            return Builder.NewObject(arrayType, args);
        }

        /// <summary>
        /// Construct an array creation expression and insert initialization statements
        /// </summary>
        /// <param name="direction">The message direction</param>
        /// <param name="inputTarget">Declaration of the variable on the LHS</param>
        /// <param name="outputLhs">Expression on the LHS</param>
        /// <param name="iace">Expression on the RHS</param>
        /// <param name="depth">Number of indexing brackets on the LHS</param>
        /// <param name="ci">Attribute of ivd</param>
        /// <param name="ctmi">Attribute of ivd</param>
        /// <returns></returns>
        private IExpression DoConvertArray(
            MessageDirection direction,
            IVariableDeclaration inputTarget,
            IExpression outputLhs,
            IArrayCreateExpression iace, int depth,
            ChannelInfo ci,
            ChannelToMessageInfo ctmi)
        {
            // mai is also an attribute of outputLhs
            MessageArrayInformation mai = (direction == MessageDirection.Forwards) ? ctmi.fwd : ctmi.bck;
            VariableInformation channelVarInfo = context.InputAttributes.Get<VariableInformation>(inputTarget);
            IExpression elementInit;
            Type messageType = mai.messageArrayType; // type of the entire message array at the top level

            IExpression mpe = mai.marginalPrototypeExpression;
            try
            {
                List<IList<IExpression>> indices = Recognizer.GetIndices(outputLhs);
                if (indices.Count > 0)
                {
                    int replaceCount = 0;
                    mpe = channelVarInfo.ReplaceIndexVars(context, mpe, indices, null, ref replaceCount);
                }
                if (mai.isDistribution)
                {
                    elementInit = MakeUniform(mpe);
                }
                else
                {
                    elementInit = null;
                }
            }
            catch (ArgumentException ex)
            {
                Error("Invalid marginal prototype expression: " + mpe, ex);
                return iace;
            }
            if (algorithm is GibbsSampling && ci.IsMarginal)
            {
                if (direction == MessageDirection.Forwards)
                {
                    if (mpe is IObjectCreateExpression ioce && IsGibbsMarginal(messageType))
                    {
                        if (depth > 0) return null;
                        InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                        if (it != null)
                            AddGibbsMarginalInitStatements(Builder.VarRefExpr(mai.decl), it.initialMessagesExpression, channelVarInfo);
                        if (ioce.Arguments[0] is IDefaultExpression)
                        {
                            // replace the first argument of "new GibbsMarginal" with marginal_B
                            IExpression messageExpression = Builder.VarRefExpr(Builder.VarRef(ctmi.bck.decl));
                            ioce.Arguments[0] = messageExpression;
                            IList<IExpression> newArgs = Builder.ExprCollection();
                            newArgs.Add(messageExpression);
                            for (int i = 1; i < ioce.Arguments.Count; i++)
                            {
                                newArgs.Add(ioce.Arguments[i]);
                            }
                            IExpression initExpr = Builder.NewObject(ioce.Type, newArgs);
                            context.OutputAttributes.Set(initExpr, new Initializer());
                            return initExpr;
                        }
                        else return mpe;
                    }
                }
                if (!mai.isDistribution)
                {
                    if (direction == MessageDirection.Forwards && depth == 0) return mpe;
                    else return null;
                }
            }

            bool isInitialiseTo = false;
            // If the user has specified an initializer, use it for elementInit.
            if (!(ci.IsMarginal && algorithm is GibbsSampling))
            {
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                if (it != null)
                {
                    elementInit = it.initialMessagesExpression;
                    isInitialiseTo = true;
                }
                // fall through
            }
            int arrayDepth;
            Type domainType;
            if (elementInit != null)
            {
                if (isInitialiseTo)
                {
                    domainType = GetInitializerDomainType(elementInit, out int minusDepth);
                    Assert.IsTrue(minusDepth >= 0);
                    arrayDepth = Util.GetArrayDepth(ci.channelType, domainType) - minusDepth;
                    bool addBracketsToInitialiser = true;
                    if (addBracketsToInitialiser)
                    {
                        // add brackets to avoid the creation of unnecessary arrays
                        elementInit = AddBracketsToInitialiser(context, elementInit, channelVarInfo, ref arrayDepth, minusDepth);
                    }
                }
                else
                {
                    domainType = Distribution.GetDomainType(elementInit.GetExpressionType());
                    arrayDepth = Util.GetArrayDepth(ci.channelType, domainType);
                }
            }
            else
            {
                Type marginalType = mpe.GetExpressionType();
                // If marginalType is PointMass<innermost channelType>, we want GetDomainType.
                // If marginalType is innermost channelType, we do not want GetDomainType.
                domainType = mai.isDistribution ? Distribution.GetDomainType(marginalType) : marginalType;
                arrayDepth = Util.GetArrayDepth(ci.channelType, domainType);
            }
            bool depthZeroInit = arrayDepth == 0 && depth == 0 && elementInit != null;
            // if arrayDepth < depth+1, then DoConvertArray will have already created an initializer
            if (arrayDepth < depth + 1 && !depthZeroInit) return null;
            Type arrayType = messageType; // type of this array
            if (!IsGibbsMarginal(arrayType))
            {
                for (int i = 0; i < depth; i++)
                {
                    arrayType = Util.GetElementType(arrayType);
                }
            }
            // arrayType is now the message type of the LHS
            if (depthZeroInit)
            {
                if (isInitialiseTo)
                {
                    elementInit = ConvertInitialiser(elementInit);
                    elementInit = ConvertInitialiser(elementInit, arrayType, channelVarInfo, 0, false);
                    elementInit = Builder.StaticGenericMethod(
                        new Func<PlaceHolder, PlaceHolder, PlaceHolder>(ArrayHelper.SetTo<PlaceHolder>),
                        new Type[] { outputLhs.GetExpressionType() }, outputLhs, elementInit);
                    IStatement init = Builder.AssignStmt(outputLhs, elementInit);
                    context.OutputAttributes.Set(init, new Initializer()
                    {
                        UserInitialized = isInitialiseTo
                    });
                    context.AddStatementAfterCurrent(init);
                    // fall through
                }
                else
                {
                    context.OutputAttributes.Set(elementInit, new Initializer()
                    {
                        UserInitialized = isInitialiseTo
                    });
                    return elementInit;
                }
            }
            else if (arrayDepth == depth + 1 && elementInit != null)
            {
                if (isInitialiseTo)
                {
                    elementInit = ConvertInitialiser(elementInit);
                    Type elementType = Util.GetElementType(arrayType);
                    elementInit = ConvertInitialiser(elementInit, elementType, channelVarInfo);
                }
                foreach (IStatement init in FillArray(outputLhs, channelVarInfo, depth, (IReadOnlyList<IExpression>)iace.Dimensions, elementInit))
                {
                    context.OutputAttributes.Set(init, new Initializer() { UserInitialized = isInitialiseTo });
                    context.AddStatementAfterCurrent(init);
                }
                //args.Add(MakeArrayInitDelegate(elementInit, margType, ci.varInfo, iace.Dimensions.Count));
            }
            IExpression arrayCreate = GetArrayCreateExpression(outputLhs, arrayType, iace.Dimensions);
            context.OutputAttributes.Set(arrayCreate, new Initializer() { UserInitialized = isInitialiseTo });
            return arrayCreate;
        }

        internal static IExpression GetArrayCreateExpression(IExpression outputLhs, Type arrayType, IEnumerable<IExpression> dimensions)
        {
            if (arrayType.IsArray)
            {
                Type elementType = arrayType.GetElementType();
                return Builder.ArrayCreateExpr(elementType, dimensions);
            }
            // arrayType must be a distribution array
            IList<IExpression> args = Builder.ExprCollection();
            if (IsFileArray(arrayType))
            {
                bool parentIsDFA = false;
                IArrayIndexerExpression iaieLhs = outputLhs as IArrayIndexerExpression;
                if (iaieLhs != null)
                {
                    Type targetType = iaieLhs.Target.GetExpressionType();
                    parentIsDFA = IsFileArray(targetType);
                }
                if (parentIsDFA)
                {
                    args.Add(iaieLhs.Target);
                    args.AddRange(iaieLhs.Indices);
                }
                else
                {
                    string name = GetName(outputLhs);
                    args.Add(Builder.StaticMethod(new Func<string, string>(FileArray<bool>.GetTempFolder), Builder.LiteralExpr(name)));
                }
            }
            args.AddRange(dimensions);
            return Builder.NewObject(arrayType, args);
        }

        internal static bool IsFileArray(Type type)
        {
            return (type.Name == typeof(DistributionFileArray<,>).Name || type.Name == typeof(FileArray<>).Name);
        }

        internal static string GetName(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie) return GetName(iaie);
            else if (expr is IVariableReferenceExpression ivre) return ivre.Variable.Variable.Name;
            else if (expr is IVariableDeclarationExpression ivde) return ivde.Variable.Name;
            else return CodeBuilder.MakeValid(expr.ToString());
        }

        internal static string GetName(IArrayIndexerExpression iaie)
        {
            string name = GetName(iaie.Target);
            IList<IExpression> bracket = iaie.Indices;
            for (int j = 0; j < bracket.Count; j++)
            {
                name += "_" + GetName(bracket[j]);
            }
            return name;
        }

        private Type GetInitializerDomainType(IExpression initialiser, out int minusDepth)
        {
            if (initialiser is IArrayIndexerExpression iaie)
            {
                Type type = GetInitializerDomainType(iaie.Target, out minusDepth);
                if (minusDepth > 0)
                {
                    minusDepth--;
                    return type;
                }
                else return Util.GetElementType(type);
            }
            else
            {
                if (initialiser is IArrayCreateExpression iace)
                {
                    if (iace.Type.DotNetType.Equals(typeof(PlaceHolder)))
                    {
                        Type type = GetInitializerDomainType(iace.Initializer.Expressions[0], out minusDepth);
                        minusDepth++;
                        return type;
                    }
                }
                Type initType = initialiser.GetExpressionType();
                minusDepth = 0;
                while (Util.IsIList(initType))
                {
                    minusDepth++;
                    initType = Util.GetElementType(initType);
                }
                return Distribution.GetDomainType(initType);
            }
        }

        /// <summary>
        /// Convert a raw initialiser expression (which may not be valid code) into a well-typed expression, possibly with "new PlaceHolder" on the outside.
        /// </summary>
        /// <param name="initialiser"></param>
        /// <returns></returns>
        private IExpression ConvertInitialiser(IExpression initialiser)
        {
            if (initialiserType.TryGetValue(initialiser, out Type type)) return Builder.CastExpr(initialiser, type);
            if (initialiser is IArrayIndexerExpression iaie)
            {
                IExpression target = ConvertInitialiser(iaie.Target);
                if (target is IArrayCreateExpression iace)
                {
                    if (iace.Type.DotNetType.Equals(typeof(PlaceHolder)) && iace.Initializer != null && iace.Initializer.Expressions.Count == 1)
                    {
                        IExpression initExpr = iace.Initializer.Expressions[0];
                        // replace index variables with the given indices
                        for (int dim = 0; dim < iace.Dimensions.Count; dim++)
                        {
                            initExpr = Builder.ReplaceExpression(initExpr, iace.Dimensions[dim], iaie.Indices[dim]);
                        }
                        return initExpr;
                    }
                }
                return Builder.ArrayIndex(target, iaie.Indices);
            }
            else if (initialiser is IArrayCreateExpression iace)
            {
                if (iace.Initializer == null) return initialiser;
                IArrayCreateExpression ace = Builder.ArrayCreateExpr(iace.Type, iace.Dimensions);
                ace.Initializer = Builder.BlockExpr();
                foreach (IExpression expr in iace.Initializer.Expressions)
                {
                    ace.Initializer.Expressions.Add(ConvertInitialiser(expr));
                }
                return ace;
            }
            else return initialiser;
        }

        /// <summary>
        /// Create an initialiser expression with additional indexing brackets
        /// </summary>
        /// <param name="context"></param>
        /// <param name="initialiser"></param>
        /// <param name="varInfo"></param>
        /// <param name="depth">Increased by to the number of brackets added</param>
        /// <param name="numBracketsToAdd">Desired number of brackets to add</param>
        /// <returns></returns>
        private IExpression AddBracketsToInitialiser(BasicTransformContext context, IExpression initialiser, VariableInformation varInfo, ref int depth, int numBracketsToAdd)
        {
            for (int bracket = 0; bracket < numBracketsToAdd; bracket++)
            {
                if (varInfo.sizes.Count < depth + 1) break;
                varInfo.DefineIndexVarsUpToDepth(context, depth + 1);
                var depthCopy = depth;
                IExpression[] indices = Util.ArrayInit(varInfo.indexVars[depth].Length,
                    i => Builder.VarRefExpr(varInfo.indexVars[depthCopy][i]));
                initialiser = Builder.ArrayIndex(initialiser, indices);
                depth++;
            }
            return initialiser;
        }

        /// <summary>
        /// Convert an initialiser expression (which may have "new PlaceHolder" on the outside) into a valid expression of the desired type.
        /// </summary>
        /// <param name="initialiser"></param>
        /// <param name="desiredType"></param>
        /// <param name="varInfo"></param>
        /// <param name="depth"></param>
        /// <param name="makeCopy"></param>
        /// <returns></returns>
        private IExpression ConvertInitialiser(IExpression initialiser, Type desiredType, VariableInformation varInfo, int depth = 0, bool makeCopy = true)
        {
            if (initialiser is IArrayCreateExpression iace)
            {
                if (iace.Initializer != null && iace.Initializer.Expressions.Count == 1)
                {
                    Type desiredElementType = Util.GetElementType(desiredType);
                    IExpression elementInit = ConvertInitialiser(iace.Initializer.Expressions[0], desiredElementType, varInfo, depth + 1);
                    if (desiredType.IsArray)
                    {
                        return GetArrayCreateExpression(desiredType, elementInit, varInfo, depth);
                    }
                    else
                    {
                        return GetDistributionArrayCreateExpression(desiredType, desiredElementType, elementInit, varInfo, depth);
                    }
                }
            }
            Type initType = initialiser.GetExpressionType();
            if (!desiredType.IsAssignableFrom(initType))
            {
                if (initType != null && Distribution.IsDistributionType(initType) && desiredType.IsAssignableFrom(Distribution.GetDomainType(initType)))
                {
                    return GetSamplingExpression(initialiser);
                }
                if (initialiser is IArrayIndexerExpression iaie)
                {
                    Type listType = typeof(IList<>).MakeGenericType(desiredType);
                    IExpression target = ConvertInitialiser(iaie.Target, listType, varInfo, depth - 1, false);
                    initialiser = Builder.ArrayIndex(target, iaie.Indices);
                }
                else if (!initType.IsAssignableFrom(desiredType))
                {
                    throw new InferCompilerException($"Initialiser {initialiser} has type {initType} instead of {desiredType}");
                }
                else
                {
                    initialiserType[initialiser] = desiredType;
                    initialiser = Builder.CastExpr(initialiser, desiredType);
                }
            }
            if (makeCopy && Distribution.IsDistributionType(desiredType))
            {
                initialiser = Builder.StaticGenericMethod(
                    new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeCopy),
                    new Type[] { desiredType },
                    initialiser);
            }
            return initialiser;
        }

        public static IExpression GetDistributionArrayCreateExpression(Type arrayType, Type innermostElementType, IExpression innermostElementInit, VariableInformation varInfo,
                                                                       int depth = 0)
        {
            // new DistributionRefArray<>(sourceArray.Length, index0 => new DistributionArray(sourceArray[index0].Length, ...))
            if (innermostElementType.IsAssignableFrom(arrayType)) return innermostElementInit;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type with innermost element type " + innermostElementType);
            IExpression elementInit = GetDistributionArrayCreateExpression(elementType, innermostElementType, innermostElementInit, varInfo, depth + 1);
            IExpression initDelegate = MakeArrayInitDelegate(elementInit, varInfo.indexVars[depth]);
            Type innerType = elementInit.GetExpressionType();
            Type distributionType = Distribution.MakeDistributionArrayType(innerType, rank);
            IList<IExpression> args = Builder.ExprCollection();
            for (int i = 0; i < rank; i++)
            {
                args.Add(varInfo.sizes[depth][i]);
            }
            args.Add(initDelegate);
            return Builder.NewObject(distributionType, args);
        }

        public static IAnonymousMethodExpression MakeArrayInitDelegate(IExpression elementInit, IVariableDeclaration[] indexVars)
        {
            // result has the form:  
            //   delegate(int index1, int index2) { return elementInit; })
            int rank = indexVars.Length;
            Type[] typeArgs = new Type[rank + 1];
            for (int i = 0; i < rank; i++)
            {
                typeArgs[i] = typeof(int);
            }
            typeArgs[typeArgs.Length - 1] = elementInit.GetExpressionType();
            Type delegateType;
            if (rank == 1) delegateType = typeof(Func<,>);
            else if (rank == 2) delegateType = typeof(Func<,,>);
            else if (rank == 3) delegateType = typeof(Func<,,,>);
            else if (rank == 4) delegateType = typeof(Func<,,,,>);
            else throw new NotImplementedException("Cannot initialize array of rank " + rank);
            IAnonymousMethodExpression iame = Builder.AnonMethodExpr(delegateType.MakeGenericType(typeArgs));
            iame.Body = Builder.BlockStmt();
            for (int i = 0; i < rank; i++)
            {
                IVariableDeclaration indexVar = indexVars[i];
                IParameterDeclaration param = Builder.Param(indexVar.Name, typeof(int));
                iame.Parameters.Add(param);
                int replaceCount = 0;
                elementInit = Builder.ReplaceExpression(elementInit, Builder.VarRefExpr(indexVar), Builder.ParamRef(param), ref replaceCount);
            }
            iame.Body.Statements.Add(Builder.Return(elementInit));
            return iame;
        }

        private IExpression GetSamplingExpression(IExpression distributionExpr)
        {
            Type srcType = distributionExpr.GetExpressionType();
            Type sampleableType = typeof(Sampleable<>).MakeGenericType(Distribution.GetDomainType(srcType));
            MethodInfo smplMthd = sampleableType.GetMethod("Sample", new Type[] { });
            IMethodReferenceExpression imre = Builder.MethodRefExpr();
            if (!sampleableType.IsAssignableFrom(srcType))
            {
                distributionExpr = Builder.CastExpr(distributionExpr, sampleableType);
            }
            imre.Target = distributionExpr;
            imre.Method = Builder.MethodRef(smplMthd);
            IMethodInvokeExpression imie = Builder.MethodInvkExpr();
            imie.Method = imre;
            return imie;
        }

        private void AddGibbsMarginalInitStatements(IExpression gibbsMargExpr, IExpression distExpr, VariableInformation varInfo)
        {
            if (gibbsMargExpr != null && distExpr != null)
            {
                Type gmType = gibbsMargExpr.GetExpressionType();
                IFieldReferenceExpression ipr = Builder.FieldRefExpr(
                    gibbsMargExpr, gmType, "LastConditional");
                Type iprType = ipr.GetExpressionType();
                distExpr = ConvertInitialiser(distExpr);
                distExpr = ConvertInitialiser(distExpr, iprType, varInfo);
                IStatement is1 = Builder.AssignStmt(ipr, distExpr);
                MethodInfo postUpdate = gmType.GetMethod("PostUpdate");
                IMethodReferenceExpression imre = Builder.MethodRefExpr();
                imre.Target = gibbsMargExpr;
                imre.Method = Builder.MethodRef(postUpdate);
                IMethodInvokeExpression imie = Builder.MethodInvkExpr();
                imie.Method = imre;
                IStatement is2 = Builder.ExprStatement(imie);
                IBlockStatement ibs = Builder.BlockStmt();
                context.OutputAttributes.Set(ibs, new Initializer() { UserInitialized = true });
                ibs.Statements.Add(is1);
                ibs.Statements.Add(is2);
                context.AddStatementAfterCurrent(ibs);
            }
        }

        /// <summary>
        /// Constructs statements that initialize the elements of an array in a single indexing bracket.
        /// </summary>
        /// <param name="outputLhs">The array to be initialized.</param>
        /// <param name="varInfo">variable info for the array.</param>
        /// <param name="depth">Number of indexing brackets in <paramref name="outputLhs"/></param>
        /// <param name="dimensions">The dimensions of the array.</param>
        /// <param name="elementInit">An expression for the array elements.  May contain references to the array's index variables, as stored in <paramref name="varInfo"/>.</param>
        /// <returns></returns>
        /// <remarks>
        /// Because elementInit may refer to the array's index variables, the generated loop will use these variables, if they are available in <paramref name="varInfo"/>.
        /// </remarks>
        protected IStatement[] FillArray(IExpression outputLhs, VariableInformation varInfo, int depth, IReadOnlyList<IExpression> dimensions, IExpression elementInit)
        {
            if (outputLhs is IVariableDeclarationExpression ivde) outputLhs = Builder.VarRefExpr(ivde.Variable);
            int indexingDepth = depth;
            if (indexingDepth == varInfo.LiteralIndexingDepth - 1)
            {
                // generate a separate statement for each array element
                if (dimensions.Count != 1) throw new ArgumentException("dimensions.Count != 1", nameof(dimensions));
                int sizeAsInt = (int)((ILiteralExpression)dimensions[0]).Value;
                return Util.ArrayInit(sizeAsInt, j =>
                {
                    IExpression index = Builder.LiteralExpr(j);
                    return Builder.AssignStmt(Builder.ArrayIndex(outputLhs, index), elementInit);
                });
            }
            // output a loop that explicitly initializes the array.
            IExpression[] indices = new IExpression[dimensions.Count];
            IVariableDeclaration[] indexVars = new IVariableDeclaration[indices.Length];
            if (varInfo.indexVars.Count > indexingDepth)
            {
                // this array may contain nulls, for indices that were not variables.
                varInfo.indexVars[indexingDepth].CopyTo(indexVars, 0);
            }
            for (int i = 0; i < indices.Length; i++)
            {
                // the same loop index may appear more than once in varInfo.  in this case, must create new indexVars.
                // this requires GetLoopForVariable to match based on name, since the IVariableDeclaration may not be the same object
                if (indexVars[i] == null || Recognizer.GetLoopForVariable(context, indexVars[i]) != null)
                {
                    indexVars[i] = Builder.VarDecl("_ind" + i, typeof(int));
                }
            }
            for (int i = 0; i < indexVars.Length; i++)
            {
                indices[i] = Builder.VarRefExpr(indexVars[i]);
            }
            IExpression elementLhs = Builder.ArrayIndex(outputLhs, indices);
            // if elementInit is MakeCopy, break into allocation followed by SetTo
            IStatement arrayCreate = null;
            if (varInfo.sizes.Count > indexingDepth + 1 &&
                Recognizer.IsStaticGenericMethod(elementInit, new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeCopy<PlaceHolder>)))
            {
                Type type = elementLhs.GetExpressionType();
                var arrayCreateExpr = GetArrayCreateExpression(elementLhs, type, varInfo.sizes[indexingDepth + 1]);
                arrayCreate = Builder.AssignStmt(elementLhs, arrayCreateExpr);
                elementInit = ((IMethodInvokeExpression)elementInit).Arguments[0];
                elementInit = Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder, PlaceHolder>(ArrayHelper.SetTo),
                    new Type[] { type }, elementLhs, elementInit);
            }
            IStatement ist = Builder.AssignStmt(elementLhs, elementInit);
            var fs = Builder.NestedForStmt(indexVars, dimensions, out IForStatement innerForStatement);
            if (arrayCreate != null)
                innerForStatement.Body.Statements.Add(arrayCreate);
            innerForStatement.Body.Statements.Add(ist);
            return new[] { fs };
        }

        public static IExpression GetArrayCreateExpression(Type arrayType, IExpression elementInit, VariableInformation varInfo, int depth = 0)
        {
            Type elementType = Util.GetElementType(arrayType, out int rank);
            IExpression initDelegate = MakeArrayInitDelegate(elementInit, varInfo.indexVars[depth]);
            IExpression[] args = new IExpression[rank + 1];
            for (int i = 0; i < rank; i++)
            {
                args[i] = varInfo.sizes[depth][i];
            }
            args[rank] = initDelegate;
            if (rank == 1)
            {
                return Builder.StaticGenericMethod(new Func<int, Converter<int, PlaceHolder>, PlaceHolder[]>(Util.ArrayInit<PlaceHolder>), new Type[] { elementType }, args);
            }
            else if (rank == 2)
            {
                return Builder.StaticGenericMethod(new Func<int, int, Func<int, int, PlaceHolder>, PlaceHolder[,]>(Util.ArrayInit<PlaceHolder>), new Type[] { elementType }, args);
            }
            else
                throw new NotImplementedException("rank > 2");
        }

        protected static IExpression MakeUniform(IExpression expression)
        {
            Type type = expression.GetExpressionType();
            if (IsPointMass(type)) return expression;
            if (Quoter.TryQuoteConstructable(null, out IExpression uniformExpr, "IsUniform", type)) return uniformExpr;
            return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeUniform<PlaceHolder>),
                                               new Type[] { type }, expression);
        }

        protected IExpression NewArrayFilled(Type elementType, IList<IExpression> sizes, IExpression elementExpr)
        {
            if (sizes.Count > 2) throw new NotImplementedException("Arrays of more than two dimensions are not yet supported.");
            IExpression[] args = new IExpression[sizes.Count + 1];
            Type[] argTypes = new Type[sizes.Count + 1];
            for (int i = 0; i < sizes.Count; i++)
            {
                args[i] = sizes[i];
                argTypes[i] = typeof(int);
            }
            args[args.Length - 1] = elementExpr;
            argTypes[argTypes.Length - 1] = elementType;
            Type returnType = CodeBuilder.MakeArrayType(elementType, sizes.Count);
            Delegate d;
            if (sizes.Count == 1)
            {
                d = new Func<PlaceHolder[], PlaceHolder, PlaceHolder[]>(ArrayHelper.Fill<PlaceHolder>);
            }
            else
            {
                d = new Func<PlaceHolder[,], PlaceHolder, PlaceHolder[,]>(ArrayHelper.Fill2D<PlaceHolder>);
            }
            return Builder.StaticGenericMethod(d, new Type[] { elementType }, args);
        }

        /// <summary>
        /// The current direction to use when converting variable references.
        /// </summary>
        protected MessageDirection? messageDirection;

        protected IExpression GetMessageExpression(IExpression channelRef, MessageDirection direction)
        {
            messageDirection = direction;
            IExpression expr = ConvertExpression(channelRef);
            messageDirection = null;
            return expr;
        }

        /// <summary>
        /// Converts a variable reference into a message, by replacing it with a reference to
        /// the forward or backward message arrays.  Also retrieves information about the message array.
        /// </summary>
        protected override IExpression ConvertVariableRefExpr(IVariableReferenceExpression ivre)
        {
            IVariableDeclaration ivd = ivre.Variable.Resolve();
            ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
            if (ctmi == null) return ivre;
            MessageArrayInformation mai = (messageDirection == MessageDirection.Backwards) ? ctmi.bck : ctmi.fwd;
            if (mai == null) return null;
            IVariableDeclaration ivd2 = mai.decl;
            IExpression vre = Builder.VarRefExpr(ivd2);
            return vre;
        }

        /// <summary>
        /// Convert an array type into a distribution type.
        /// </summary>
        /// <param name="arrayType">A scalar, array, multidimensional array, or IList type.</param>
        /// <param name="innermostElementType">Type of innermost array element (may be itself an array, if the array is compound).</param>
        /// <param name="newInnermostElementType">Distribution type to use for the innermost array elements.</param>
        /// <param name="useDistributionArrays">Convert outer arrays to DistributionArrays.</param>
        /// <returns>A distribution type with the same structure as <paramref name="arrayType"/> but whose element type is <paramref name="newInnermostElementType"/>.</returns>
        /// <remarks>
        /// Similar to <see cref="Util.ChangeElementTypeAndRank"/> but converts arrays to DistributionArrays.
        /// </remarks>
        public static Type GetDistributionType(Type arrayType, Type innermostElementType, Type newInnermostElementType, bool useDistributionArrays)
        {
            if (innermostElementType.IsAssignableFrom(arrayType)) return newInnermostElementType;
            if (arrayType.IsArray)
            {
                Type elementType = Util.GetElementType(arrayType, out int rank);
                if (elementType == null) throw new ArgumentException(arrayType + " is not an array type with innermost element type " + innermostElementType);
                Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, useDistributionArrays);
                if (useDistributionArrays)
                {
                    return Distribution.MakeDistributionArrayType(innerType, rank);
                }
                else
                {
                    return CodeBuilder.MakeArrayType(innerType, rank);
                }
            }
            else
            {
                return typeof(PointMass<>).MakeGenericType(arrayType);
            }
        }

        /// <summary>
        /// Convert an array type into a distribution type, converting a specified number of inner arrays to DistributionArrays.
        /// </summary>
        /// <param name="arrayType"></param>
        /// <param name="innermostElementType"></param>
        /// <param name="newInnermostElementType"></param>
        /// <param name="depth">The current depth from the declaration type.</param>
        /// <param name="useDistributionArraysDepth">The depth at which to start converting to DistributionArrays.  This can be overridden by <paramref name="useFileArrayAtDepth"/></param>
        /// <param name="useFileArrayAtDepth"></param>
        /// <returns></returns>
        public static Type GetDistributionType(Type arrayType, Type innermostElementType, Type newInnermostElementType, int depth, int useDistributionArraysDepth,
                                               Predicate<int> useFileArrayAtDepth)
        {
            if (innermostElementType.IsAssignableFrom(arrayType)) return newInnermostElementType;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type.");
            if (arrayType.IsAssignableFrom(Util.MakeArrayType(elementType, rank)))
            {
                if (useFileArrayAtDepth(depth))
                {
                    Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, depth + 1, depth, useFileArrayAtDepth);
                    return Distribution.MakeDistributionFileArrayType(innerType, rank);
                }
                else
                {
                    Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, depth + 1, useDistributionArraysDepth, useFileArrayAtDepth);
                    if ((depth >= useDistributionArraysDepth) && (useDistributionArraysDepth >= 0))
                    {
                        return Distribution.MakeDistributionArrayType(innerType, rank);
                    }
                    else
                    {
                        return CodeBuilder.MakeArrayType(innerType, rank);
                    }
                }
            }
            else
            {
                return typeof(PointMass<>).MakeGenericType(arrayType);
            }
        }

        public static Type GetArrayType(Type arrayType, Type innermostElementType, int depth, Predicate<int> useFileArrayAtDepth)
        {
            if (arrayType == innermostElementType) return innermostElementType;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type.");
            Type innerType = GetArrayType(elementType, innermostElementType, depth + 1, useFileArrayAtDepth);
            if (useFileArrayAtDepth(depth))
            {
                return MakeFileArrayType(innerType, rank);
            }
            else
            {
                return CodeBuilder.MakeArrayType(innerType, rank);
            }
        }

        public static Type MakeFileArrayType(Type elementType, int rank)
        {
            if (rank < 1) throw new ArgumentException("rank (" + rank + ") < 1");
            if (rank == 1)
            {
                return typeof(FileArray<>).MakeGenericType(elementType);
            }
            else
            {
                throw new ArgumentException("FileArray rank > 1 not yet implemented");
            }
        }

        public Type GetMessageType(ChannelInfo ci, Type marginalType)
        {
            VariableInformation vi = (ci.decl != null)
                ? VariableInformation.GetVariableInformation(context, ci.decl)
                : ci.varInfo;
            // leading array is [] up to distArraysDepth, then distribution arrays
            int distArraysDepth = System.Math.Max((algorithm is GibbsSampling) ? 0 : vi.DistArrayDepth, vi.LiteralIndexingDepth);            
            bool useFileArrayAtDepth(int depth) => vi.IsPartitionedAtDepth(context, depth);
            for (int depth = 0; depth < distArraysDepth; depth++)
            {
                if (useFileArrayAtDepth(depth))
                {
                    // in order to use DistributionFileArray, the element type must be a distribution type
                    distArraysDepth = depth + 1;
                    break;
                }
            }
            Type domainType = Distribution.GetDomainType(marginalType);
            try
            {
                return GetDistributionType(ci.channelType, domainType, marginalType, 0, distArraysDepth, useFileArrayAtDepth);
            }
            catch(Exception ex)
            {
                Error(ex.Message);
                return ci.channelType;
            }
        }

        /// <summary>
        /// Describes a message in a message-passing program.
        /// </summary>
        /// <remarks>
        /// A message is a channel paired with a direction (either forwards or backwards).
        /// A message can be labelled as an "output" to mean it is the result of inference.
        /// When a random variable has multiple uses, all uses are labelled with the same MessageInfo.
        /// 
        /// If the channel is in a plate, we need to distinguish between the case of one message per each
        /// plate instance versus one message for the entire plate.
        /// 
        /// If the channel is an array type, then there are three possible message types:
        /// 1. If the channel is in a plate, then so is the message.
        /// 2. If the channel is not in a plate, but individual messages are desired for each array element.
        /// If the channel is inside a plate, in which case it stores for an array of distributions.
        /// </remarks>
        public class MessageInfo
        {
            internal IExpression messageFromFactor, messageToFactor;
            internal readonly IVariableDeclaration channelDecl;

            /// <summary>
            /// True if the factor argument is a derived variable with non-unit derivative.
            /// </summary>
            internal readonly bool hasNonUnitDerivative;

            public MessageInfo()
            {
            }

            public MessageInfo(MessageTransform transform, IExpression channelRef)
            {
                IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(channelRef);
                if (ivd == null)
                    return;
                channelDecl = ivd;
                hasNonUnitDerivative = transform.context.InputAttributes.Has<DerivedVariable>(ivd) && transform.hasNonUnitDerivative.Contains(ivd);
                if (transform.AllowDerivedParents)
                    hasNonUnitDerivative = false;
            }

            public override string ToString()
            {
                return $"MessageInfo(messageFromFactor: {messageFromFactor}, messageToFactor: {messageToFactor}, channelDecl: {channelDecl}, hasNonUnitDerivative: {hasNonUnitDerivative})";
            }
        }

        /// <summary>
        /// Set the channelDecl field via the attributes applied to channelRef.
        /// </summary>
        /// <param name="mi">Will be modified</param>
        /// <param name="channelRef">An expression for the channel</param>
        internal void SetChannelInfo(MessageInfo mi, IExpression channelRef)
        {
        }

        private class ChannelToMessageInfo : ICompilerAttribute
        {
            /// <summary>
            /// Declaration of the forward message array/variable
            /// </summary>
            internal MessageArrayInformation fwd;

            /// <summary>
            /// Declaration of the backward message array/variable
            /// </summary>
            internal MessageArrayInformation bck;

            public override string ToString()
            {
                return $"ChannelToMessageInfo fwd = {fwd}, bck = {bck}";
            }
        }

        private class ObservedVariableMessages : ICompilerAttribute
        {
            internal readonly ChannelToMessageInfo ctmi;

            internal ObservedVariableMessages(ChannelToMessageInfo ctmi)
            {
                this.ctmi = ctmi;
            }

            public override string ToString()
            {
                return $"ObservedVariableMessages {ctmi}";
            }
        }

        private class MessageInfoDict : ICompilerAttribute
        {
            public IReadOnlyDictionary<string, MessageInfo> msgInfo;

            public override string ToString()
            {
                return StringUtil.DictionaryToString(msgInfo, " ");
            }
        }
    }

    /// <summary>
    /// Information about either the forwards or backwards message array
    /// </summary>
    internal class MessageArrayInformation : ICompilerAttribute
    {
        internal ChannelInfo ci;
        /// <summary>
        /// Declaration of the message array variable
        /// </summary>
        internal IVariableDeclaration decl;
        internal IExpression marginalPrototypeExpression = null;

        internal Type messageArrayType
        {
            get { return decl.VariableType.DotNetType; }
        }

        /// <summary>
        /// Indicates whether the message is a distribution over the channel.  
        /// (This can only be false when the algorithm overrides GetMessagePrototype.)
        /// </summary>
        internal bool isDistribution = true;

        /// <summary>
        /// Number of times this variable is used as an argument to a message operator.
        /// Only used by AccumulationTransform.
        /// </summary>
        internal int useCount;

        /// <summary>
        /// Set by LoopCuttingTransform, used by AccumulationTransform
        /// </summary>
        internal LoopVarInfo loopVarInfo;

        public override string ToString()
        {
            return $"MessageArrayInformation({decl},useCount={useCount},{ci},{marginalPrototypeExpression})";
        }
    }

    /// <summary>
    /// Enumeration for labelling forward and backward messages.
    /// </summary>
    public enum MessageDirection
    {
        Backwards,
        Forwards
    };

    /// <summary>
    /// Attached to a statement to indicate that it may appear in a while loop, i.e. it updates a message.  A statement without this attribute cannot appear in a while loop.
    /// </summary>
    internal class OperatorStatement : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attribute used to mark methods which contain operator statements (i.e. statements which are to be processed by the scheduler).
    /// </summary>
    internal class OperatorMethod : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attribute used to mark methods which assert deterministic constraints
    /// </summary>
    internal class DeterministicConstraint : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attached to statements to indicate that they will be overwritten by later statements, i.e. this is not the final value of the variable.
    /// </summary>
    internal class Initializer : ICompilerAttribute
    {
        /// <summary>
        /// If true, this statement is initialized by the user.
        /// </summary>
        public bool UserInitialized;

        public override string ToString()
        {
            return "Initializer" + (UserInitialized ? "(UserInitialized)" : "");
        }
    }


    /// <summary>
    /// Attribute used to mark variables that appear as arguments to Infer()
    /// </summary>
    internal class IsInferred : ICompilerAttribute
    {
    }

    /// <summary>
    /// When applied to a variable, indicates that the forward message is always a point mass (but not necessarily constant).
    /// </summary>
    internal class ForwardPointMass : ICompilerAttribute
    {
    }

    /// <summary>
    /// When applied to a method invoke expression, indicates that the execution of this
    /// expression depends on the iteration counter
    /// </summary>
    internal class DependsOnIteration : ICompilerAttribute
    {
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "DependsOnIteration";
        }
    }

    /// <summary>
    /// When attached to a message declaration, indicates that the message has no initializer statement, only update statements.
    /// </summary>
    internal class DoesNotHaveInitializer : ICompilerAttribute
    {
    }

    /// <summary>
    /// A type which can be used as a placeholder in a generic method reference.  It will be replaced
    /// by the dynamically specified type argument provided separately.
    /// </summary>
    internal interface PlaceHolder : IDistribution<object>, SettableToProduct<PlaceHolder>, SettableTo<PlaceHolder>
    {
    }

    internal interface PlaceHolder2 : IDistribution<object>, SettableToProduct<PlaceHolder>
    {
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.ML.Probabilistic.Algorithms;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Factors;
using Microsoft.ML.Probabilistic.Factors.Attributes;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Models.Attributes;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Transforms a model specified in terms of channels into the set of message passing
    /// operations required to perform inference in that model.
    /// </summary>
    /// <remarks>
    /// The message passing transform does the following operations:
    ///  - converts channel declarations into pairs of variables for forwards and backwards 
    ///    messages along that channel.
    ///  - initalises message arrays using the appropriate message prototypes
    ///    - message prototypes may be different for backward and forward directions
    ///    - the algorithm determines the message prototypes in a call to GetMessagePrototypes
    ///    - default message prototype is the marginal prototype
    ///  - converts method calls into sets of operator method calls
    ///  - keeps track of all inter-operator dependencies, as these are needed by the scheduler
    /// <para>
    /// Stochastic variables must have ChannelInfo attributes.
    /// </para>
    /// </remarks>
    internal class MessageTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "MessageTransform"; }
        }

        internal static bool UseMessageAnalysis;
        internal static bool debug;
        internal bool InitializeOnSeparateLine;
        protected IAlgorithm algorithm;
        protected FactorManager factorManager;
        protected ModelCompiler compiler;

        internal const string resultName = "result";
        internal const string resultIndexName = "resultIndex";

        /// <summary>
        /// If true, initialize arrays using ArrayHelper.Fill (makes the generated code more compact, but prevents moving some allocations into the Reset() method)
        /// </summary>
        internal static bool UseArrayHelperFill;
        /// <summary>
        /// If true, operators that return their argument are replaced by copy expressions.  Note this is required for certain tests to pass.
        /// </summary>
        private readonly bool UseCopyOperators = true;

        /// <summary>
        /// The set of variables that have at least one definition with a non-unit derivative
        /// </summary>
        protected Set<IVariableDeclaration> hasNonUnitDerivative = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);

        protected Dictionary<IExpression, Type> initialiserType = new Dictionary<IExpression, Type>();

        protected Dictionary<IVariableDeclaration, IVariableDeclaration> derivOfVariable =
            new Dictionary<IVariableDeclaration, IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);

        private static readonly MessageDirection[] directions = { MessageDirection.Forwards, MessageDirection.Backwards };

        /// <summary>
        /// If true, restrictions on derived parents are ignored.
        /// </summary>
        private readonly bool AllowDerivedParents;

        /// <summary>
        /// Results of analysis
        /// </summary>
        private MessageAnalysisTransform analysis;

        /// <summary>
        /// Method declaration used for message tracing
        /// </summary>
        private IMethodDeclaration messageUpdatedMethod;

        public MessageTransform(ModelCompiler compiler, IAlgorithm algorithm, FactorManager factorManager, bool allowDerivedParents)
        {
            this.compiler = compiler;
            this.algorithm = algorithm;
            this.factorManager = factorManager;
            this.AllowDerivedParents = allowDerivedParents;
        }

        public override ITypeDeclaration Transform(ITypeDeclaration itd)
        {
            if (UseMessageAnalysis)
            {
                analysis = new MessageAnalysisTransform(algorithm, factorManager);
                analysis.Context.InputAttributes = context.InputAttributes;
                analysis.Transform(itd);
                context.Results = analysis.Context.Results;
                if (!context.Results.IsSuccess)
                {
                    Error("analysis failed");
                    return itd;
                }
            }
            var td = base.Transform(itd);
            if (messageUpdatedMethod != null)
            {
                // Add method to fire events when a message is updated
                td.Methods.Add(messageUpdatedMethod);
            }

            return td;
        }

        public override void ConvertTypeProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            base.ConvertTypeProperties(td, itd);
            td.Name = td.Name + "_" + algorithm.ShortName;
            if (itd.Documentation != null)
            {
                td.Documentation = itd.Documentation + " using algorithm '" + algorithm.Name + "'";
            }
        }

        protected override IMethodDeclaration ConvertMethod(IMethodDeclaration imd)
        {
            IMethodDeclaration md = base.ConvertMethod(imd);
            context.OutputAttributes.Set(md, new OperatorMethod());
            return md;
        }

        private static bool IsGibbsMarginal(Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(GibbsMarginal<,>));
        }

        public static bool IsPointMass(Type type)
        {
            return type.IsGenericType && type.GetGenericTypeDefinition().Equals(typeof(PointMass<>));
        }

        protected override void DoConvertMethodBody(IList<IStatement> outputs, IList<IStatement> inputs)
        {
            if (UseMessageAnalysis)
            {
                // create factory variables
                foreach (KeyValuePair<IVariableDeclaration, IExpression> entry in analysis.factoryInitExprs)
                {
                    IVariableDeclaration factoryVar = entry.Key;
                    IExpression initExpr = entry.Value;
                    IStatement ist = Builder.AssignStmt(Builder.VarDeclExpr(factoryVar), initExpr);
                    outputs.Add(ist);
                }
            }
            base.DoConvertMethodBody(outputs, inputs);
        }

#if true
        /// <summary>
        /// Only converts the contained statements in a for loop, leaving the initializer,
        /// condition and increment statements unchanged.
        /// </summary>
        protected override IStatement ConvertFor(IForStatement ifs)
        {
            IForStatement fs = Builder.ForStmt();
            context.SetPrimaryOutput(fs);
            fs.Condition = ifs.Condition;
            fs.Increment = ifs.Increment;
            fs.Initializer = ifs.Initializer;
            fs.Body = ConvertBlock(ifs.Body);
            // attributes are not copied
            return fs;
        }
#endif

        /// <summary>
        /// Flatten out and remove if statements.
        /// </summary>
        /// <returns></returns>
        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            if (IsStochasticVariableReference(ics.Condition))
            {
                IBlockStatement bs = ConvertBlock(ics.Then);
                context.AddStatementsBeforeCurrent(bs.Statements);
                return null;
            }
            else
            {
                return base.ConvertCondition(ics);
            }
        }

        /// <summary>
        /// This does the work of constructing all the operator calls for the given factor call
        /// </summary>
        /// <param name="imie">The method invoke expression</param>
        /// <returns></returns>
        protected override IExpression ConvertMethodInvoke(IMethodInvokeExpression imie)
        {
            if (CodeRecognizer.IsInfer(imie)) return ConvertInfer(imie);
            if (CodeRecognizer.IsIsIncreasing(imie)) return imie;
            if (context.FindAncestor<IExpressionStatement>() == null) return imie;
            IExpression expr = imie;
            IAssignExpression iae = context.FindAncestor<IAssignExpression>();
            bool isAssignment = (iae != null);
            IStatement ist = context.FindAncestor<IStatement>();
            bool resultIsObserved = context.InputAttributes.Has<Models.Constraint>(ist);
            bool isVariableFactor = context.InputAttributes.Has<IsVariableFactor>(imie);

            // Find method and extract its factor information
            IAlgorithm alg = algorithm;
            Algorithm algAttr = context.InputAttributes.Get<Algorithm>(imie);
            if (algAttr != null) alg = algAttr.algorithm;

            // Get the meta-data for the factor
            FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, imie);
            if (info == null)
            {
                Error("Factor information could not be found for method: " + imie);
                return imie;
            }
            if (info.IsVoid != !isAssignment)
            {
                if (info.IsVoid) Error("A void function cannot be used in an assignment");
                else if (context.InputStack[context.InputStack.Count - 2].inputElement is IExpressionStatement)
                    Error("The return value of a non-void function must be assigned to a variable");
                else Error("Nested function calls are not allowed. Create a temporary variable for each function result");
                return imie;
            }
            if (iae != null)
            {
                IVariableDeclaration targetVar = Recognizer.GetVariableDeclaration(iae.Target);
                // TODO: this is temporary until full support for UseDerivMessages
                if (targetVar != null && info.IsDeterministicFactor)
                {
                    bool hasUnitDerivative = info.Method.IsDefined(typeof(HasUnitDerivative), true);
                    if (hasUnitDerivative)
                    {
                        // check that all arguments have unit derivative
                        foreach (IExpression arg in imie.Arguments)
                        {
                            IVariableDeclaration argVar = Recognizer.GetVariableDeclaration(arg);
                            if (argVar != null && hasNonUnitDerivative.Contains(argVar))
                            {
                                hasUnitDerivative = false;
                                break;
                            }
                        }
                    }
                    if (!hasUnitDerivative)
                    {
                        hasNonUnitDerivative.Add(targetVar);
                    }
                }
            }

            // Find information about the messages for each argument and work out their types
            Dictionary<string, MessageInfo> msgInfo = new Dictionary<string, MessageInfo>();
            if (debug)
                context.InputAttributes.Set(imie, new MessageInfoDict()
                {
                    msgInfo = msgInfo
                });
            var argumentTypes = new Dictionary<string, Type>();
            var resultTypes = new Dictionary<string, Type>();
            var isStochastic = new Dictionary<string, bool>();
            List<bool> isReturnOrOut = new List<bool>();
            List<bool> argIsConstant = new List<bool>();
            bool resultIsConstant = info.IsDeterministicFactor && !isVariableFactor;
            List<IExpression> arguments = new List<IExpression>();
            if (iae != null)
            {
                IExpression target = iae.Target;
                if (target is IVariableDeclarationExpression)
                {
                    target = Builder.VarRefExpr(Recognizer.GetVariableDeclaration(target));
                }
                isReturnOrOut.Add(!resultIsObserved);
                arguments.Add(target);
            }
            if (!info.Method.IsStatic)
            {
                isReturnOrOut.Add(false);
                arguments.Add(imie.Method.Target);
            }
            foreach (IExpression arg in imie.Arguments)
            {
                bool isOut = (arg is IAddressOutExpression);
                isReturnOrOut.Add(isOut);
                arguments.Add(isOut ? ((IAddressOutExpression)arg).Expression : arg);
            }

            //--------------------------------------------------------
            // Set up the message info for each target field, and record the
            // type of each field
            //--------------------------------------------------------
            for (int i = 0; i < info.ParameterNames.Count; i++)
            {
                string parameterName = info.ParameterNames[i];
                bool isWeaklyTyped = isVariableFactor && parameterName == "init";
                // Create message info. 'isForward' says whether the message
                // out is in the forward or backward direction
                bool isChild = isReturnOrOut[i];
                IExpression channelRef = arguments[i];
                bool isConstant = !CodeRecognizer.IsStochastic(context, channelRef);
                if (!isConstant) resultIsConstant = false;
                argIsConstant.Add(isConstant);
                MessageInfo mi;
                if (isConstant)
                {
                    mi = new MessageInfo
                    {
                        messageFromFactor = isChild ? channelRef : null,
                        messageToFactor = channelRef
                    };
                    if (!isWeaklyTyped)
                    {
                        Type inwardType = mi.messageToFactor.GetExpressionType();
                        argumentTypes[parameterName] = inwardType;
                    }
                }
                else
                {
                    IExpression fwdMsg = GetMessageExpression(channelRef, MessageDirection.Forwards);
                    IExpression bckMsg = GetMessageExpression(channelRef, MessageDirection.Backwards);
                    //if (fwdMsg == null) { Error("forward message is null"); return imie; }
                    //if (bckMsg == null) { Error("backward message is null"); return imie; }
                    if (isChild)
                    {
                        mi = new MessageInfo(this, channelRef)
                        {
                            messageFromFactor = fwdMsg,
                            messageToFactor = bckMsg
                        };
                    }
                    else
                    {
                        mi = new MessageInfo(this, channelRef)
                        {
                            messageFromFactor = bckMsg,
                            messageToFactor = fwdMsg
                        };
                    }
                    if (!isWeaklyTyped)
                    {
                        if (mi.messageToFactor != null)
                        {
                            Type inwardType = mi.messageToFactor.GetExpressionType();
                            if (inwardType == null)
                            {
                                Error("Cannot determine type of " + mi.messageToFactor);
                                return imie;
                            }
                            argumentTypes[parameterName] = inwardType;
                        }
                        if (mi.messageFromFactor != null)
                        {
                            Type outwardType = mi.messageFromFactor.GetExpressionType();
                            argumentTypes["to_" + parameterName] = outwardType;
                            resultTypes[parameterName] = outwardType;
                        }
                    }
                    isStochastic[parameterName] = !mi.hasNonUnitDerivative;
                    if (alg is VariationalMessagePassing vmp && vmp.UseDerivMessages && !isChild && mi.hasNonUnitDerivative && !isVariableFactor)
                    {
                        IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(channelRef);
                        DerivMessage dm = context.InputAttributes.Get<DerivMessage>(ivd);
                        if (dm != null)
                        {
                            IExpression derivArg = Builder.ReplaceExpression(channelRef, Builder.VarRefExpr(ivd), Builder.VarRefExpr(dm.decl));
                            IExpression derivMsg = GetMessageExpression(derivArg, MessageDirection.Forwards);
                            MessageInfo mi2 = new MessageInfo
                            {
                                messageFromFactor = derivMsg,
                                messageToFactor = derivMsg
                            };
                            string derivParameterName = parameterName + "_deriv";
                            msgInfo[derivParameterName] = mi2;
                            Type derivType = derivMsg.GetExpressionType();
                            argumentTypes[derivParameterName] = derivType;
                            resultTypes[derivParameterName] = derivType;
                        }
                    }
                }
                msgInfo[parameterName] = mi;
            }
            if (resultIsConstant && isAssignment && !resultIsObserved)
            {
                // The statement is an assignment between deterministic variables.
                // The factor will be used unchanged.  Check if it copies any of its arguments.
                MessageFcnInfo fninfo = info.GetMessageFcnInfoFromFactor();
                IExpression copyExpr = CheckForCopyOperators(fninfo, imie.Arguments, arguments[0]);
                if (copyExpr != null)
                    return copyExpr;
                return imie;
            }

            // Create operator statements for each non-deterministic argument
            List<ICompilerAttribute> factorAttributes = context.InputAttributes.GetAll<ICompilerAttribute>(imie);

            int initialPriorityListSize = this.factorManager.PriorityList.Count;
            DivideMessages divideMessages = context.InputAttributes.Get<DivideMessages>(imie);
            // Gibbs must never divide messages
            if (algorithm is GibbsSampling)
                divideMessages = new DivideMessages(false);
            if (divideMessages != null)
            {
                if (divideMessages.useDivision)
                {
                    factorManager.GivePriorityTo(typeof(ReplicateOp_Divide));
                }
                else
                {
                    factorManager.GivePriorityTo(typeof(ReplicateOp_NoDivide));
                }
            }
            bool isPointMass = context.InputAttributes.Has<ForwardPointMass>(imie);
            if (isPointMass)
            {
                factorManager.GivePriorityTo(typeof(ReplicatePointOp));
                factorManager.GivePriorityTo(typeof(GetItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetJaggedItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetDeepJaggedItemsPointOp<>));
                factorManager.GivePriorityTo(typeof(GetItemsFromJaggedPointOp<>));
                factorManager.GivePriorityTo(typeof(GetItemsFromDeepJaggedPointOp<>));
                factorManager.GivePriorityTo(typeof(GetJaggedItemsFromJaggedPointOp<>));
            }

            // send an evidence message to the innermost stochastic condition statement.
            List<IConditionStatement> ifContainers = context.FindAncestors<IConditionStatement>();
            ifContainers.Reverse();
            IConditionStatement ics = null;
            foreach (IConditionStatement ifContainer in ifContainers)
            {
                if (IsStochasticVariableReference(ifContainer.Condition))
                {
                    ics = ifContainer;
                    break;
                }
            }
            if (ics != null)
            {
                // Construct evidence message
                if (isVariableFactor && msgInfo.ContainsKey("Def") &&
                    context.InputAttributes.Has<DoNotSendEvidence>(msgInfo["Def"].channelDecl))
                {
                    Error("Sending evidence from a variable marked with DoNotSendEvidence (" + msgInfo["Def"].channelDecl + ")");
                }
                argumentTypes[resultName] = typeof(double);
                string methodName = alg.GetEvidenceMethodName(factorAttributes);
                IExpression channelRef = ics.Condition;
                MessageInfo mi = new MessageInfo(this, channelRef)
                {
                    messageFromFactor = GetMessageExpression(channelRef, MessageDirection.Backwards)
                };
                string evidenceField = "";
                msgInfo[evidenceField] = mi;
                ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, methodName, evidenceField, argumentTypes, isStochastic, isVariableFactor);
            }
            else if (resultIsConstant)
            {
                if (!isAssignment)
                {
                    // Constrain.Equal(true,false) outside of a conditional statement should be left intact, and marked as an output.
                    context.OutputAttributes.Set(imie, new DeterministicConstraint());
                    return imie;
                }
                else if (resultIsObserved)
                {
                    // a = Not(b)  turns into  ArrayHelper.CheckConstraint("a = Not(b)", LogEvidenceRatio(a,b))  or Constrain.Equal(a,Not(b))
                    Type t = iae.Target.GetExpressionType();
                    var mie = Builder.StaticGenericMethod(new Action<PlaceHolder, PlaceHolder>(Constrain.Equal), new Type[] { t }, iae.Target, imie);
                    context.OutputAttributes.Set(mie, new DeterministicConstraint());
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(mie));
                    return null;
                }
                else
                    return null;
            }

            // Loop over each output argument and construct the operator method
            string operatorSuffix = alg.GetOperatorMethodSuffix(factorAttributes);
            for (int i = 0; i < info.ParameterNames.Count; i++)
            {
                string targetParameter = info.ParameterNames[i];
                MessageInfo mi = msgInfo[targetParameter];
                bool isChild = isReturnOrOut[i];
                // do not generate messages to constant arguments.
                if (argIsConstant[i] && !isChild) continue;
                if (UseMessageAnalysis)
                {
                    AddInitialiserStatement(mi.messageFromFactor, iae ?? (IExpression)imie);
                    if (isChild) AddInitialiserStatement(mi.messageToFactor, null);
                }

                int currentPriorityListSize = this.factorManager.PriorityList.Count;

                Type targetType;
                if (argIsConstant[i])
                    targetType = argumentTypes[targetParameter];
                else
                    targetType = resultTypes[targetParameter];
                argumentTypes[resultName] = targetType;

                // If the target can implement SetToSum exactly, we can use BP gate operators
                // TODO: remove this when the support for auto-generated distribution arrays will be added
                Type targetInnermostElementType = Util.GetInnermostElementType(targetType);
                if (typeof(SettableToWeightedSumExact<>).MakeGenericType(targetInnermostElementType).IsAssignableFrom(targetInnermostElementType))
                {
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterOneOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterPartialOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateEnterPartialTwoOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateExitOp));
                    this.factorManager.GivePriorityTo(typeof(BeliefPropagationGateExitTwoOp));
                }
                else
                {
                    this.factorManager.GivePriorityTo(typeof(GateEnterOneOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterPartialOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateEnterPartialTwoOp));
                    this.factorManager.GivePriorityTo(typeof(GateExitOp<>));
                    this.factorManager.GivePriorityTo(typeof(GateExitTwoOp));
                }

                if (targetInnermostElementType == typeof(StringDistribution))
                {
                    // Don't use ReplicateOp_Divide for StringAutomaton
                    // TODO: replace this workaround with a proper extensibility mechanism
                    this.factorManager.GivePriorityTo(typeof(ReplicateOp_NoDivide));
                }

                // Give priority to operators in GivePriorityTo attributes
                // TODO: can be moved out of the loop when we get rid of the operator lookup based on target type
                List<GivePriorityTo> ops = context.InputAttributes.GetAll<GivePriorityTo>(imie);
                foreach (GivePriorityTo op in ops)
                {
                    this.factorManager.GivePriorityTo(op.Container);
                }

                void action(IStatement st)
                {
                    if (argIsConstant[i]) context.OutputAttributes.Remove<OperatorStatement>(st);
                    context.AddStatementBeforeCurrent(st);
                }
                ForEachOperatorStatement(action, alg, info, msgInfo, operatorSuffix, targetParameter, argumentTypes, isStochastic, isVariableFactor);

                this.factorManager.PriorityList.RemoveRange(0, this.factorManager.PriorityList.Count - currentPriorityListSize);

                if (alg is VariationalMessagePassing vmp && vmp.UseDerivMessages && isChild && mi.hasNonUnitDerivative && !isVariableFactor)
                {
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(arguments[i]);
                    DerivMessage dm = context.InputAttributes.Get<DerivMessage>(ivd);
                    if (dm != null)
                    {
                        ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(dm.decl);
                        IVariableDeclaration derivMsgVar = ctmi.fwd.decl;
                        IVariableDeclaration forwardVar = Recognizer.GetVariableDeclaration(mi.messageFromFactor);
                        MessageInfo mi2 = new MessageInfo
                        {
                            messageFromFactor = Builder.ReplaceExpression(mi.messageFromFactor, Builder.VarRefExpr(forwardVar), Builder.VarRefExpr(derivMsgVar))
                        };
                        string field = "";
                        msgInfo[field] = mi2;
                        string methodName = targetParameter + "Deriv";
                        ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, methodName, field, argumentTypes, isStochastic, isVariableFactor);
                    }
                }
            }
            this.factorManager.PriorityList.RemoveRange(0, this.factorManager.PriorityList.Count - initialPriorityListSize);
            return null;
        }

        private void AddInitialiserStatement(IExpression message, IExpression factor)
        {
            IVariableDeclaration msgVar = Recognizer.GetVariableDeclaration(message);
            KeyValuePair<IVariableDeclaration, IExpression> key = new KeyValuePair<IVariableDeclaration, IExpression>(msgVar, factor);
            if (analysis.messageInitExprs.TryGetValue(key, out IExpression initExpr))
            {
                IExpressionStatement init = Builder.AssignStmt(message, initExpr);
                context.OutputAttributes.Set(init, new Initializer());
                context.AddStatementBeforeCurrent(init);
            }
        }

        /// <summary>
        /// Create an operator statement which computes the message to the specified argument, and invoke an action.
        /// </summary>
        /// <param name="action">Receives the generated statements</param>
        /// <param name="alg">The algorithm</param>
        /// <param name="info">Factor information</param>
        /// <param name="msgInfo">Dictionary of message information.  May be modified with buffers.</param>
        /// <param name="methodSuffix">Suffix for the operator method</param>
        /// <param name="targetParameter">target argument name</param>
        /// <param name="argumentTypes">Argument types for the operator method.  May be modified with buffers.</param>
        /// <param name="isStochastic">Indicates whether each argument is valid for a formal marked with the Stochastic attribute.</param>
        /// <param name="isVariableFactor">Whether this is a variable factor</param>
        /// <param name="isInit">Whether the statement is an initializer</param>
        /// <param name="alternateSuffix"></param>
        /// <returns></returns>
        protected void ForEachOperatorStatement(Action<IStatement> action, IAlgorithm alg, FactorManager.FactorInfo info, Dictionary<string, MessageInfo> msgInfo,
                                                string methodSuffix, string targetParameter, Dictionary<string, Type> argumentTypes, IReadOnlyDictionary<string, bool> isStochastic,
                                                bool isVariableFactor, bool isInit = false, string alternateSuffix = null)
        {
            var customArgumentTypes = new Dictionary<string, Type>(argumentTypes);
            bool useFactor = (targetParameter == info.ParameterNames[0]) && info.OutputIsDeterministic(customArgumentTypes) && !info.IsVoid && !isVariableFactor;

            // For Gibbs, we do not want to allow EP methods which require projection. A crude
            // way of detecting these is to look at the arguments, and reject any method which
            // includes as an argument the incoming message corresponding to the target parameter
            if (alg is GibbsSampling && (!useFactor) && (!isVariableFactor))
                customArgumentTypes[targetParameter] = typeof(PlaceHolder);

            MessageFcnInfo fninfo;
            if (useFactor) fninfo = info.GetMessageFcnInfoFromFactor();
            else
            {
                fninfo = null;
                if (alternateSuffix != null)
                {
                    try
                    {
                        fninfo = info.GetMessageFcnInfo(factorManager, alternateSuffix, targetParameter, customArgumentTypes, isStochastic);
                    }
                    catch (Exception)
                    {
                        fninfo = null;
                    }
                }
                if (fninfo == null)
                {
                    try
                    {
                        fninfo = info.GetMessageFcnInfo(factorManager, methodSuffix, targetParameter, customArgumentTypes, isStochastic);
                    }
                    catch (ArgumentException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (MissingMethodException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (NotSupportedException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    catch (AmbiguousMatchException ex)
                    {
                        ErrorNotSupported(ex);
                        return;
                    }
                    void ErrorNotSupported(Exception ex)
                    {
                        string opErr = "This model is not supported with " + alg.Name + " due to " + info.ToString() +
                                       ". Try using a different algorithm or expressing the model differently";
                        if ((ex is ArgumentException) && (alg is GibbsSampling) && (!isVariableFactor))
                        {
                            Error(opErr + " Gibbs Sampling requires the conditionals to be conjugate", ex);
                        }
                        else
                            Error(opErr, ex);
                    }
                }
            }

            MessageInfo mi = msgInfo[targetParameter];

            if (fninfo.PassResultIndex)
            {
                Type resultType = argumentTypes[resultName];
                customArgumentTypes[resultIndexName] = typeof(int);
                Type resultElementType = Util.GetElementType(resultType);
                customArgumentTypes[resultName] = resultElementType;
                // Get the expressions for all the arguments to the operator
                List<IExpression> args = GetOperatorArguments(alg, info, fninfo, mi, msgInfo, customArgumentTypes, isStochastic, isVariableFactor);
                VariableInformation vi = VariableInformation.GetVariableInformation(context, mi.channelDecl ?? Recognizer.GetVariableDeclaration(mi.messageToFactor));
                int depth = Recognizer.GetIndexingDepth(mi.messageFromFactor);
                vi.DefineIndexVarsUpToDepth(context, depth + 1);
                IVariableDeclaration indexVar = vi.indexVars[depth][0];
                IExpression size = vi.sizes[depth][0];
                if (depth == vi.LiteralIndexingDepth - 1)
                {
                    // generate a separate statement for each array element
                    int sizeAsInt = (int)((ILiteralExpression)size).Value;
                    for (int j = 0; j < sizeAsInt; j++)
                    {
                        // Create the statement which calls the message function
                        IExpression index = Builder.LiteralExpr(j);
                        IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, index, isVariableFactor, isInit, useFactor);
                        action(st);
                    }
                }
                else
                {
                    // generate a loop that fills in all array elements
                    if (Recognizer.GetLoopForVariable(context, indexVar) != null) indexVar = Builder.VarDecl("_" + resultIndexName, typeof(int));
                    IForStatement fs = Builder.ForStmt(indexVar, size);
                    IExpression index = Builder.VarRefExpr(indexVar);
                    IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, index, isVariableFactor, isInit, useFactor);
                    fs.Body.Statements.Add(st);
                    action(fs);
                }
            }
            else
            {
                customArgumentTypes.Remove(resultIndexName);
                // Get the expressions for all the arguments to the operator
                List<IExpression> args = GetOperatorArguments(alg, info, fninfo, mi, msgInfo, customArgumentTypes, isStochastic, isVariableFactor);
                // Create the statement which calls the message function
                IStatement st = GetOperatorStatement(alg, info, fninfo, mi, targetParameter, args, null, isVariableFactor, isInit, useFactor);
                action(st);
            }
        }

        /// <summary>
        /// Creates an assignment statement that invokes a message operator.
        /// </summary>
        /// <param name="alg">The inference algorithm</param>
        /// <param name="info">The factor</param>
        /// <param name="fninfo">The message operator</param>
        /// <param name="mi">The target of the message</param>
        /// <param name="targetParameter">The factor parameter receiving the message</param>
        /// <param name="args">The arguments of the message operator</param>
        /// <param name="index">The index argument of the message operator</param>
        /// <param name="isVariableFactor">True if the factor is a variable factor</param>
        /// <param name="isInit">True if the message operator is an initializer.</param>
        /// <param name="useFactor">True if the message operator is the factor itself.</param>
        /// <returns>An assignment statement that invokes the message operator.</returns>
        protected internal IExpressionStatement GetOperatorStatement(
            IAlgorithm alg,
            FactorManager.FactorInfo info,
            MessageFcnInfo fninfo,
            MessageInfo mi,
            string targetParameter,
            List<IExpression> args,
            IExpression index,
            bool isVariableFactor,
            bool isInit,
            bool useFactor)
        {
            List<IExpression> fullArgs = new List<IExpression>();
            if (fninfo.IsIndexedParameter == null) fullArgs.AddRange(args);
            else
            {
                for (int i = 0; i < args.Count; i++)
                {
                    IExpression arg = args[i];
                    if (fninfo.IsIndexedParameter[i]) arg = Builder.ArrayIndex(arg, index);
                    fullArgs.Add(arg);
                }
            }
            IExpression msg = mi.messageFromFactor;
            if (index != null)
            {
                if (fninfo.ResultIndexParameterIndex != fullArgs.Count)
                    Error("'" + resultIndexName + "' is not the 2nd to last argument of " + StringUtil.MethodSignatureToString(fninfo.Method));
                fullArgs.Add(index);
                msg = Builder.ArrayIndex(msg, index);
            }
            if (fninfo.PassResult)
            {
                if (fninfo.ResultParameterIndex != fullArgs.Count)
                    Error("'" + resultName + "' is not the last argument of " + StringUtil.MethodSignatureToString(fninfo.Method));
                fullArgs.Add(msg);
            }
            fullArgs = ConvertArguments(fninfo.Method, fullArgs);
            IExpression operatorMethod = Builder.StaticMethod(fninfo.Method, fullArgs.ToArray());
            if (!context.OutputAttributes.Has<MessageFcnInfo>(fninfo.Method))
                context.OutputAttributes.Set(fninfo.Method, fninfo);

            IExpression copyOperatorMethod = CheckForCopyOperators(fninfo, args, msg);
            if (copyOperatorMethod != null)
            {
                operatorMethod = copyOperatorMethod;
                // this could be removed if Copy has a Trigger attribute
                isVariableFactor = false;
            }

            // Get the quality band of the operator method and attach an attribute
            // Quality bands on the factor itself are optional, and are handled by
            // the general mechanism in IterativeProcessTransform.
            if (!useFactor && (operatorMethod is IMethodInvokeExpression imie))
            {
                var mr = Recognizer.GetMethodReference(imie);
                // Get the quality band of the operator method and attach an attribute
                QualityBand qualityBand = Quality.GetQualityBand(mr.MethodInfo);
                Context.OutputAttributes.Set(imie, new QualityBandCompilerAttribute(qualityBand));
            }

            // Support for the 'TraceMessages' and 'ListenToMessages' attributes
            if (compiler.TraceAllMessages ||
                (mi.channelDecl != null && (context.InputAttributes.Has<TraceMessages>(mi.channelDecl) ||
                                           context.InputAttributes.Has<ListenToMessages>(mi.channelDecl))))
            {
                string msgText = msg.ToString();
                // Look for TraceMessages attribute that matches this message
                var trace = context.InputAttributes.Get<TraceMessages>(mi.channelDecl);
                if (trace?.Containing != null && !msgText.Contains(trace.Containing)) trace = null;

                // Look for ListenToMessages attribute that matches this message
                var listenTo = context.InputAttributes.Get<ListenToMessages>(mi.channelDecl);
                if (listenTo?.Containing != null && !msgText.Contains(listenTo.Containing)) listenTo = null;


                if ((listenTo != null) || (trace != null) || compiler.TraceAllMessages)
                {
                    IExpression textExpr = DebuggingSupport.GetExpressionTextExpression(msg);
                    if (listenTo != null)
                    {
                        if (messageUpdatedMethod == null)
                        {
                            // Generate message updated event on generated class
                            var td = context.FindOutputForAncestor<ITypeDeclaration, ITypeDeclaration>();
                            var messageUpdatedEvent = Builder.EventDecl(DebuggingSupport.MessageEventName,
                                                                        (ITypeReference)Builder.TypeRef(typeof(EventHandler<MessageUpdatedEventArgs>)), td);
                            messageUpdatedEvent.Documentation = "Event that is fired when a message that is being monitored is updated.";
                            td.Events.Add(messageUpdatedEvent);
                            // Build a wrapper function that allows clients to fire the event
                            messageUpdatedMethod = Builder.FireEventDecl(MethodVisibility.Private, "On" + DebuggingSupport.MessageEventName, messageUpdatedEvent);
                        }
                        // Generate code to emit message events
                        var methodRef = new CodeModel.Concrete.XMethodReference(messageUpdatedMethod);
                        var mre = Builder.MethodRefExpr();
                        mre.Method = methodRef;
                        mre.Target = Builder.ThisRefExpr();
                        operatorMethod = Builder.StaticGenericMethod(
                            new Func<PlaceHolder, string, Action<MessageUpdatedEventArgs>, bool, PlaceHolder>(Tracing.FireEvent<PlaceHolder>),
                            new Type[] { fninfo.Method.ReturnType }, operatorMethod, textExpr, mre, Builder.LiteralExpr(trace != null));
                    }
                    else
                    {
                        // Add a call to Tracing.Trace() to cause the message to be written to a TraceWriter
                        operatorMethod = Builder.StaticGenericMethod(new Func<PlaceHolder, string, PlaceHolder>(Tracing.Trace<PlaceHolder>),
                                                                     new Type[] { fninfo.Method.ReturnType }, operatorMethod, textExpr);
                    }
                }
            }

            bool needAllTriggers = false;
            IAssignExpression assignExpr = Builder.AssignExpr(msg, operatorMethod);
            Type lhsType = assignExpr.Target.GetExpressionType();
            Type rhsType = assignExpr.Expression.GetExpressionType();
            if (lhsType == typeof(Bernoulli) && rhsType == typeof(double))
            {
                assignExpr.Expression = Builder.StaticMethod(new Func<double, Bernoulli>(Bernoulli.FromLogOdds), assignExpr.Expression);
            }
            else if (!lhsType.IsAssignableFrom(rhsType))
            {
                // if the lhs and rhs have different types, convert from:
                //   x = f(y);
                // to:
                //   x = SetPoint(x,f(y));
                assignExpr.Expression = SetPointExpression(assignExpr.Target, lhsType, assignExpr.Expression, rhsType);
            }

            string argName = "'" + targetParameter + "'";
            if (targetParameter.Length == 0) argName = "evidence";
            if (mi.channelDecl != null)
                context.OutputAttributes.Set(assignExpr, new DescriptionAttribute("Message to '" + mi.channelDecl.Name + "' from " + info.Method.Name + " factor"));
            var st = Builder.ExprStatement(assignExpr);
            if (fninfo.AllTriggers) needAllTriggers = true;
            else if (alg is VariationalMessagePassing vmp && !isVariableFactor && !vmp.UseDerivMessages && !fninfo.NoTriggers)
            {
                needAllTriggers = true;
            }
            else if (alg is GibbsSampling && !fninfo.IsStochastic)
            {
                // For Gibbs, all factors need triggers. The only edge that should not
                // be triggered is the one drawing samples.
                needAllTriggers = true;
            }
            if (needAllTriggers) context.OutputAttributes.Set(operatorMethod, new AllTriggersAttribute());

            if (isInit)
                context.OutputAttributes.Set(st, new Initializer());
            else
                context.OutputAttributes.Set(st, new OperatorStatement());
            if (fninfo.IsMultiplyAll) context.OutputAttributes.Set(st, new MultiplyAllCompilerAttribute());
            if (fninfo.IsStochastic) context.OutputAttributes.Set(st, new DependsOnIteration());
            if (mi.channelDecl != null)
                context.InputAttributes.CopyObjectAttributesTo<InitialiseBackward>(mi.channelDecl, context.OutputAttributes, st);
            return st;
        }

        /// <summary>
        /// Checks to see if this operator is just copying one of its parameters and hence can be
        /// optimised away.
        /// </summary>
        /// <param name="fninfo">The operator function info</param>
        /// <param name="args">The operator arguments</param>
        /// <param name="msg">The expression for the LHS which will store the result of the operator</param>
        /// <returns>The new expression to compute the result of the operation, or null if the operator is not a copy</returns>
        private IExpression CheckForCopyOperators(MessageFcnInfo fninfo, IList<IExpression> args, IExpression msg)
        {
            if (!UseCopyOperators)
                return null;
            // Find out if the operator is just copying one of its arguments
            int copyArg = fninfo.ReturnedParameterIndex;
            if (copyArg != -1)
            {
                IExpression argToBeCopied = args[copyArg];
                Type resultType = msg.GetExpressionType();
                if (argToBeCopied == null)
                {
                    Error("method argument is null");
                    return null;
                }
                Type sourceType = argToBeCopied.GetExpressionType();
                if (resultType.IsArray)
                {
                    Type eltType = resultType.GetElementType();
                    if (Distribution.IsDistributionType(eltType) && Distribution.IsSettableTo(eltType, argToBeCopied.GetExpressionType()))
                    {
                        if (resultType.GetArrayRank() != 1) Error("array rank > 1 is not supported in this context");
                        return Builder.StaticGenericMethod(new Func<Bernoulli[], Bernoulli[], Bernoulli[]>(ArrayHelper.SetTo),
                                                           new Type[] { eltType }, msg, argToBeCopied);
                    }
                    else
                        return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(Factor.Copy<PlaceHolder>),
                                                           new Type[] { sourceType }, argToBeCopied);
                }
                else
                {
                    // must use IsDistributionType here, not IsSettableTo, because only DistributionTypes are guaranteed to be initialized
                    if (Distribution.IsDistributionType(resultType) && Distribution.IsSettableTo(resultType, argToBeCopied.GetExpressionType()))
                        // TODO: find the appropriate generic type parameter, similar to SetPointExpression
                        return Builder.StaticGenericMethod(new Func<Bernoulli, Bernoulli, Bernoulli>(ArrayHelper.SetTo),
                                                           new Type[] { resultType }, msg, argToBeCopied);
                    else
                        return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(Factor.Copy<PlaceHolder>),
                                                           new Type[] { sourceType }, argToBeCopied);
                }
            }

            // Find out if the operator is copying one of its arguments in every element of the returned value.
            int copyMultipleArg = fninfo.ReturnedInAllElementsParameterIndex;
            if (copyMultipleArg != -1)
            {
                IExpression argToBeCopied = args[copyMultipleArg];
                Type resultType = msg.GetExpressionType();
                if (resultType.IsArray)
                {
                    if (resultType.GetArrayRank() != 1) Error("array rank > 1 is not supported in this context");
                    return Builder.StaticGenericMethod(new Func<double[], double, double[]>(ArrayHelper.SetAllElementsTo),
                                                       new Type[] { argToBeCopied.GetExpressionType() }, msg, argToBeCopied);
                }
                else
                {
                    return Builder.StaticGenericMethod(new Func<Vector, double, Vector>(ArrayHelper.SetAllElementsTo),
                                                       new Type[] { msg.GetExpressionType(), argToBeCopied.GetExpressionType() }, msg, argToBeCopied);
                }
            }

            // Special handling of DiscreteUniform.SampleAverageConditional
            if (fninfo.Method.Equals(new Func<int, Discrete, Discrete>(DiscreteUniform.SampleAverageConditional).Method))
            {
                IExpression size = args[0];
                // check the marginal prototype of the result argument
                IExpression result = msg;
                IVariableDeclaration resultVar = Recognizer.GetVariableDeclaration(result);
                MessageArrayInformation mai = context.InputAttributes.Get<MessageArrayInformation>(resultVar);
                IExpression mpe = mai.marginalPrototypeExpression;
                IExpression prototypeSize = StocAnalysisTransform.GetDiscreteLengthExpression(mpe);
                if (size.Equals(prototypeSize))
                {
                    return MakeUniform(mpe);
                }
            }

            return null;
        }

        /// <summary>
        /// Adds statements that create a buffer for a message operator.
        /// </summary>
        /// <param name="name">Name of the buffer</param>
        /// <param name="type">Type of the buffer</param>
        /// <param name="alg">Inference algorithm</param>
        /// <param name="info">The factor</param>
        /// <param name="fcninfo">The message operator that requested the buffer</param>
        /// <param name="miTgt">The target message that requested the buffer</param>
        /// <param name="msgInfo">Modified to have the buffer</param>
        /// <param name="argumentTypes">Modified to have the buffer</param>
        /// <param name="isStochastic">Indicates whether each argument must be stochastic or not</param>
        /// <param name="isVariableFactor">True if this is a variable factor</param>
        private MessageInfo CreateBuffer(
            string name,
            Type type,
            IAlgorithm alg,
            FactorManager.FactorInfo info,
            MessageFcnInfo fcninfo,
            MessageInfo miTgt,
            Dictionary<string, MessageInfo> msgInfo,
            Dictionary<string, Type> argumentTypes,
            IReadOnlyDictionary<string, bool> isStochastic,
            bool isVariableFactor)
        {
            if (type != null)
                argumentTypes[name] = type;
            else
                argumentTypes.Remove(name);
            Type oldResultType = argumentTypes[resultName];
            Type oldResultIndexType = argumentTypes.ContainsKey(resultIndexName) ? argumentTypes[resultIndexName] : null;
            if (type != null)
                argumentTypes[resultName] = type;
            else
                argumentTypes.Remove(resultName);
            argumentTypes.Remove(resultIndexName);
            MessageFcnInfo fcninfo2 = info.GetMessageFcnInfo(factorManager, "", name, argumentTypes, isStochastic);
            if (type == null)
            {
                if (!fcninfo2.PassResultIndex)
                    type = fcninfo2.Method.ReturnType;
                else
                {
                    // must get buffer type from Init method
                    MessageFcnInfo fcninfoInit = info.GetMessageFcnInfo(factorManager, "Init", name, argumentTypes, isStochastic);
                    if (fcninfoInit.PassResultIndex)
                    {
                        Error("Init method expects resultIndex but this is not supported");
                    }
                    type = fcninfoInit.Method.ReturnType;
                }
                argumentTypes[name] = type;
                argumentTypes[resultName] = type;
            }
            string prefix = miTgt.messageFromFactor.ToString();
            if (true)
            {
                // prefix the buffer name with the name of the first argument of its defining function
                ParameterInfo parameter2 = fcninfo2.Method.GetParameters()[0];
                string factorParameterName2 = fcninfo2.factorEdgeOfParameter[parameter2.Name].ParameterName;
                if (msgInfo.TryGetValue(factorParameterName2, out MessageInfo mi2))
                {
                    prefix = mi2.messageToFactor.ToString();
                }
            }
            prefix = CodeBuilder.MakeValid(prefix);
            IVariableDeclaration bufferDecl = Builder.VarDecl(VariableInformation.GenerateName(context, prefix + "_" + name), type);
            context.OutputAttributes.Set(bufferDecl, new DescriptionAttribute("Buffer for " + StringUtil.EscapeXmlCharacters(StringUtil.MethodFullNameToString(fcninfo.Method))));
            context.OutputAttributes.Set(bufferDecl, new Containers(context));
            IExpression msg = Builder.VarRefExpr(bufferDecl);
            MessageInfo mi = new MessageInfo
            {
                ////channelDecl = miTgt.channelDecl,
                messageFromFactor = msg,
                messageToFactor = msg
            };
            msgInfo[name] = mi;
            string flippedName = FactorManager.FlipCapitalization(name);
            msgInfo[flippedName] = mi;
            // TODO: fix this in cases where buffers form a cycle and therefore need inits
            if (fcninfo2.PassResult || HasParameter(fcninfo2, name) || HasParameter(fcninfo2, flippedName))
            {
                context.AddStatementBeforeCurrent(Builder.ExprStatement(Builder.VarDeclExpr(bufferDecl)));
                ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, "Init", name, argumentTypes, isStochastic, isVariableFactor, true);
            }
            else
            {
                var assignSt = Builder.AssignStmt(Builder.VarDeclExpr(bufferDecl), Builder.DefaultExpr(type));
                context.OutputAttributes.Set(assignSt, new Initializer());
                context.AddStatementBeforeCurrent(assignSt);
                context.OutputAttributes.Set(bufferDecl, new DoesNotHaveInitializer());
            }
            ForEachOperatorStatement(context.AddStatementBeforeCurrent, alg, info, msgInfo, "", name, argumentTypes, isStochastic, isVariableFactor);
            argumentTypes[resultName] = oldResultType;
            if (oldResultIndexType != null)
                argumentTypes[resultIndexName] = oldResultIndexType;
            return mi;
        }

        /// <summary>
        /// Get the operator arguments for a specified operator method
        /// </summary>
        /// <param name="alg">The algorithm</param>
        /// <param name="info">Factor information</param>
        /// <param name="fcninfo">Operator method information</param>
        /// <param name="miTgt">The message info for the target argument</param>
        /// <param name="msgInfo">Message information for each field.  May be modified with buffers.</param>
        /// <param name="argumentTypes">Argument types for the operator method.  May be modified with buffers.</param>
        /// <param name="isStochastic">Whether each argument can be stochastic.</param>
        /// <param name="isVariableFactor">Whether this is a variable factor</param>
        /// <returns></returns>
        protected List<IExpression> GetOperatorArguments(IAlgorithm alg, FactorManager.FactorInfo info, MessageFcnInfo fcninfo,
                                                         MessageInfo miTgt, Dictionary<string, MessageInfo> msgInfo, Dictionary<string, Type> argumentTypes,
                                                         IReadOnlyDictionary<string, bool> isStochastic,
                                                         bool isVariableFactor)
        {
            List<IExpression> args = new List<IExpression>();
            // Get the parameters of the operator method
            ParameterInfo[] parameters = fcninfo.Method.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                ParameterInfo parameter = parameters[i];
                if (parameter.Name == resultName || parameter.Name == resultIndexName) continue;
                FactorEdge factorEdge;
                if (!fcninfo.factorEdgeOfParameter.TryGetValue(parameter.Name, out factorEdge))
                {
                    Error("Parameter name '" + parameter.Name + "' is unrecognized in " + StringUtil.MethodFullNameToString(fcninfo.Method));
                    continue;
                }
                string factorParameterName = factorEdge.ParameterName;
                bool isOutgoingMessage = factorEdge.IsOutgoingMessage;
                MessageInfo mi;
                if (!msgInfo.TryGetValue(factorParameterName, out mi))
                {
                    // create a buffer
                    Type bufferType = parameter.ParameterType;
                    if (fcninfo.IsIndexedParameter != null && fcninfo.IsIndexedParameter[i])
                        bufferType = null;
                    try
                    {
                        mi = CreateBuffer(factorParameterName, bufferType, alg, info, fcninfo, miTgt, msgInfo, argumentTypes, isStochastic, isVariableFactor);
                    }
                    catch (Exception ex)
                    {
                        Error("Could not construct operator method", ex);
                        args.Add(null);
                        continue;
                    }
                }
                if (mi.hasNonUnitDerivative)
                {
                    object[] attrs = parameter.GetCustomAttributes(typeof(Stochastic), true);
                    if ((attrs != null) && (attrs.Length > 0))
                    {
                        Error("Argument '" + parameter.Name + "' to operator method '" + StringUtil.MethodFullNameToString(fcninfo.Method) +
                              "' must not be a derived variable.   Set Compiler.AllowDerivedParents = true if you want to risk running inference in this model.");
                    }
                }
                if (isOutgoingMessage && mi.messageFromFactor == null)
                {
                    Error("The operator method requires a message to " + factorParameterName + " but there is no such message");
                }
                IExpression value = isOutgoingMessage ? mi.messageFromFactor : mi.messageToFactor;
                bool isWeaklyTyped = isVariableFactor && parameter.Name == "init";
                if (isWeaklyTyped)
                {
                    value = ConvertInitialiser(value);
                    value = ConvertInitialiser(value, parameter.ParameterType, null, 0, false);
                }
                args.Add(value);
            }
            return args;
        }

        private List<IExpression> ConvertArguments(MethodInfo method, IList<IExpression> args)
        {
            List<IExpression> convertedArgs = new List<IExpression>();
            ParameterInfo[] parameters = method.GetParameters();
            for (int i = 0; i < args.Count; i++)
            {
                IExpression arg = args[i];
                if (arg == null) continue;
                Type argType = arg.GetExpressionType();
                IExpression convertedArg = arg;
                ParameterInfo parameter = parameters[i];
                if (!parameter.ParameterType.IsAssignableFrom(argType))
                {
                    Type distType = parameter.ParameterType;
                    Type domainType = argType;
                    MethodInfo pointMassMethod = FactorManager.GetPointMassMethod(distType, domainType);
                    if (pointMassMethod != null)
                    {
                        convertedArg = Builder.StaticMethod(pointMassMethod, arg);
                    }
                    else
                    {
                        Error("Cannot convert from '" + StringUtil.TypeToString(argType) + "' to '" + StringUtil.TypeToString(distType) + "' for argument of method " +
                              StringUtil.MethodSignatureToString(method));
                    }
                }
                convertedArgs.Add(convertedArg);
            }
            if (convertedArgs.Count != args.Count || convertedArgs.Count != parameters.Length) Error("Some arguments were not converted");
            return convertedArgs;
        }

        private static bool HasBuffer(MessageFcnInfo fcninfo, string name)
        {
            object[] bufferAttrs = fcninfo.Method.DeclaringType.GetCustomAttributes(typeof(BuffersAttribute), true);
            foreach (BuffersAttribute bufferAttr in bufferAttrs)
            {
                foreach (string bufferName in bufferAttr.BufferNames)
                {
                    if (name == bufferName) return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Indicates whether the given factor parameter is an argument of the given message operator.
        /// </summary>
        /// <param name="fcninfo">The message operator</param>
        /// <param name="name">The factor parameter name</param>
        /// <returns>True if the factor parameter is an argument of the message operator</returns>
        /// <exception cref="NotSupportedException">The message operator has an unrecognized argument.</exception>
        private bool HasParameter(MessageFcnInfo fcninfo, string name)
        {
            ParameterInfo[] parameters = fcninfo.Method.GetParameters();
            foreach (ParameterInfo parameter in parameters)
            {
                if (fcninfo.factorEdgeOfParameter.TryGetValue(parameter.Name, out FactorEdge edge)) 
                {
                    if (edge.ParameterName == name) return true;
                }
                else Error("Unrecognized parameter " + parameter.Name + " in method " + StringUtil.MethodSignatureToString(fcninfo.Method));
            }
            return false;
        }

        protected override IExpression ConvertAssign(IAssignExpression iae)
        {
            if (iae.Target is IVariableDeclarationExpression ivde)
            {
                if (IsStochasticVariableReference(ivde))
                {
                    ConvertExpression(iae.Target);
                    IAssignExpression ae2 = Builder.AssignExpr();
                    ae2.Target = Builder.VarRefExpr(ivde.Variable);
                    ae2.Expression = iae.Expression;
                    return ConvertExpression(ae2);
                }
            }

            // This will automatically convert the lhs into a forward message.
            IAssignExpression ae = (IAssignExpression)base.ConvertAssign(iae);
            if (ae == null || ae.Target == null || ae.Expression == null) return null;
            Type lhsType = ae.Target.GetExpressionType();
            Type rhsType = ae.Expression.GetExpressionType();
            if (lhsType == null)
            {
                Error("Cannot determine type of " + ae.Target);
                return null;
            }
            if (!lhsType.IsAssignableFrom(rhsType))
            {
                // if the lhs and rhs have different types, convert from:
                //   x = f(y);
                // to:
                //   x = SetPoint(x,f(y));
                ae.Expression = SetPointExpression(ae.Target, lhsType, ae.Expression, rhsType);
            }
            return ae;
        }

        private IExpression SetPointExpression(IExpression target, Type targetType, IExpression expression, Type expressionType)
        {
            try
            {
                Type hasPoint = targetType.GetInterface(typeof(HasPoint<>).Name);
                expressionType = hasPoint.GetGenericArguments()[0];
                return Builder.StaticGenericMethod(new Func<Bernoulli, bool, Bernoulli>(Distribution.SetPoint),
                                                            new Type[] { targetType, expressionType }, target, expression);
            }
            catch (Exception ex)
            {
                Error("Cannot call SetPoint on " + StringUtil.TypeToString(targetType), ex);
                return expression;
            }
        }

        protected IExpression ConvertInfer(IMethodInvokeExpression imie)
        {
            //IStatement ist = context.FindOutputForAncestor<IStatement, IStatement>();
            IStatement ist = context.FindAncestor<IStatement>();
            context.OutputAttributes.Set(ist, new OperatorStatement());
            object decl = Recognizer.GetDeclaration(imie.Arguments[0]);
            // This will automatically convert the argument into a forward message
            // make a copy if we will modify later
            this.ShallowCopy = (decl != null);
            IMethodInvokeExpression mie = (IMethodInvokeExpression)base.ConvertMethodInvoke(imie);
            this.ShallowCopy = false;
            if (decl != null)
            {
                QueryType query = null;
                if (mie.Arguments.Count >= 3)
                {
                    ExpressionEvaluator eval = new ExpressionEvaluator();
                    query = (QueryType)eval.Evaluate(mie.Arguments[2]);
                }
                ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(decl);
                if (ctmi == null)
                {
                    ctmi = context.InputAttributes.Get<ObservedVariableMessages>(decl)?.ctmi;
                }
                if (ctmi != null)
                {
                    MessageDirection direction = (query == QueryTypes.MarginalDividedByPrior) ? MessageDirection.Backwards : MessageDirection.Forwards;
                    MessageArrayInformation mai = (direction == MessageDirection.Backwards) ? ctmi.bck : ctmi.fwd;
                    mie.Arguments[0] = Builder.VarRefExpr(mai.decl);
                }
                if (mie.Arguments.Count == 1)
                {
                    string varName;
                    if (decl is IParameterDeclaration ipd) varName = ipd.Name;
                    else varName = ((IVariableDeclaration)decl).Name;
                    ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(decl);
                    if (ci != null) varName = ci.varInfo.Name;
                    mie.Arguments.Add(Builder.LiteralExpr(varName));
                }
            }
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(mie.Arguments[0]);
            if (ivd != null && !context.InputAttributes.Has<IsInferred>(ivd))
                context.OutputAttributes.Set(ivd, new IsInferred());
            return mie;
        }

        /// <summary>
        /// Returns true if the supplied expression is stochastic.  
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        protected bool IsStochasticVariableReference(IExpression expr)
        {
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(expr);
            return (ivd != null) && context.InputAttributes.Has<ChannelInfo>(ivd);
        }

        // Create the statements for creating forward and backward message arrays.
        // These are the _F and _B variables in the generated code. The MessageArrayInformation
        // instances record information about these variables 
        private MessageArrayInformation CreateMessageVariable(string name, ChannelInfo channelInfo, ChannelToMessageInfo ctmi, MessageDirection direction,
                                                               ChannelPathAttribute[] cpas)
        {
            string messageName = name + (direction == MessageDirection.Backwards ? "_B" : "_F");
            List<QueryType> qtlist;
            if (channelInfo.decl != null && !context.InputAttributes.Has<IsInferred>(channelInfo.decl)) qtlist = new List<QueryType>();
            else qtlist = context.InputAttributes.GetAll<QueryTypeCompilerAttribute>(channelInfo.varInfo.declaration).Select(attr => attr.QueryType).ToList();
            // Ask the algorithm for the message prototype in this direction
            // Message types may be different in each direction
            VariableInformation vi;
            if (channelInfo.decl != null)
            {
                vi = VariableInformation.GetVariableInformation(context, channelInfo.decl);
            }
            else vi = channelInfo.varInfo;
            if (vi.marginalPrototypeExpression == null)
            {
                try
                {
                    vi.SetMarginalPrototypeFromAttribute(null);
                }
                catch (Exception ex)
                {
                    Error(ex.Message);
                }
            }
            IExpression prototypeExpression = vi.marginalPrototypeExpression;
            IExpression mpe = algorithm.GetMessagePrototype(channelInfo, direction, prototypeExpression, null, qtlist);
            Type innermostType = mpe.GetExpressionType();
            string path = "";
            // Check for any path attributes for the channel
            bool foundOne = false;
            bool foundNonDefault = false;

            foreach (ChannelPathAttribute cpa in cpas)
            {
                if (cpa.Direction != direction)
                    continue;

                // If we've already found a path for this direction
                // and this is default path, continue
                if (foundOne && cpa.FromDefault)
                    continue;

                bool notDefault = !cpa.FromDefault;

                // Flag an error if there are two inconsistent non-default paths
                if (foundNonDefault && notDefault && cpa.Path != path)
                    Error(String.Format("Inconsistent message types for {0}. If you have manually specified groups, try changing the root variable.", messageName));

                if (!foundNonDefault)
                {
                    path = cpa.Path;
                    mpe = algorithm.GetMessagePrototype(channelInfo, direction, prototypeExpression, path, qtlist);
                    innermostType = mpe.GetExpressionType();
                    foundOne = true;
                    foundNonDefault = notDefault;
                }
            }
            // See if this is a distribution
            bool isDistribution = Distribution.IsDistributionType(innermostType) && Distribution.GetDomainType(innermostType).Equals(Distribution.GetDomainType(prototypeExpression.GetExpressionType()));

            // Cache the message type
            bool isGibbsMarginal = false;
            Type messageType;
            if (isDistribution)
                messageType = GetMessageType(channelInfo, innermostType);
            else if (algorithm is GibbsSampling && channelInfo.IsMarginal)
            {
                messageType = innermostType;
                isGibbsMarginal = true;
            }
            else
            {
                messageType = JaggedArray.GetTypes(
                    channelInfo.channelType,
                    JaggedArray.GetInnermostType(channelInfo.channelType),
                    innermostType)[0];
            }
            // Cache the message array information, including the declaration
            MessageArrayInformation mai = new MessageArrayInformation
            {
                // Create the variable declaration of the message array variable
                decl = Builder.VarDecl(messageName, messageType),
                ci = channelInfo,
                isDistribution = isDistribution,
                marginalPrototypeExpression = mpe
            };
            // Attach the message array information as an attribute on the variable declaration
            context.OutputAttributes.Set(mai.decl, mai);
            if (direction == MessageDirection.Backwards)
            {
                ctmi.bck = mai;
            }
            else
            {
                ctmi.fwd = mai;
            }
            VariableInformation messageInfo = VariableInformation.GetVariableInformation(context, mai.decl);
            if (!isGibbsMarginal)
            {
                messageInfo.indexVars = vi.indexVars;
                messageInfo.sizes = vi.sizes;
            }

            if (channelInfo.decl != null)
            {
                // Description of this message array variable - this will eventually get built into a code comment
                DescriptionAttribute da = context.InputAttributes.Get<DescriptionAttribute>(channelInfo.decl);
                if (da != null)
                {
                    string s = "Message";
                    if (mai.decl.VariableType.DotNetType.IsArray) s += "s";
                    bool isFrom = (direction == MessageDirection.Backwards);
                    if (channelInfo.IsDef) isFrom = !isFrom;
                    if (isFrom) s += " from ";
                    else s += " to ";
                    context.OutputAttributes.Set(mai.decl, new DescriptionAttribute(s + da.Description));
                }

                // Propagate InitialiseTo attribute
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(channelInfo.decl);
                if (it != null)
                {
                    if (channelInfo.IsMarginal || direction == MessageDirection.Forwards)
                    {
                        context.OutputAttributes.Set(mai.decl, it);
                    }
                }

                // Propagate InitialiseBackward
                InitialiseBackward ib = context.InputAttributes.Get<InitialiseBackward>(channelInfo.decl);
                if (ib != null)
                {
                    if (direction == MessageDirection.Backwards)
                    {
                        context.OutputAttributes.Set(mai.decl, ib);
                    }
                }

                // Propagate InitialiseBackwardTo
                InitialiseBackwardTo ibt = context.InputAttributes.Get<InitialiseBackwardTo>(channelInfo.decl);
                if (ibt != null)
                {
                    if (direction == MessageDirection.Backwards)
                    {
                        context.OutputAttributes.Set(mai.decl, new InitialiseTo(ibt.initialMessagesExpression));
                    }
                }
            }

            return mai;
        }

        private MessageArrayInformation CreateMessageVariable2(string name, ChannelInfo channelInfo, ChannelToMessageInfo ctmi, MessageDirection direction,
                                                                ChannelPathAttribute[] cpas)
        {
            Dictionary<IVariableDeclaration, IVariableDeclaration> messageVars = (direction == MessageDirection.Forwards) ? analysis.fwdMessageVars : analysis.bckMessageVars;
            IVariableDeclaration messageVar;
            if (!messageVars.TryGetValue(channelInfo.decl, out messageVar)) return null;
            Type messageType = messageVar.VariableType.DotNetType;

            // See if this is a distribution
            bool isDistribution = Distribution.IsDistributionType(messageType);

            // Cache the message array information, including the declaration
            MessageArrayInformation mai = new MessageArrayInformation
            {
                // Create the variable declaration of the message array variable
                decl = messageVar,
                ci = channelInfo,
                isDistribution = isDistribution
            };
            //mai.marginalPrototypeExpression = initExpr;
            // Attach the message array information as an attribute on the variable declaration
            context.OutputAttributes.Set(mai.decl, mai);
            if (direction == MessageDirection.Backwards)
            {
                ctmi.bck = mai;
            }
            else
            {
                ctmi.fwd = mai;
            }

            // Description of this message array variable - this will eventually get built into a code comment
            DescriptionAttribute da = context.InputAttributes.Get<DescriptionAttribute>(channelInfo.decl);
            if (da != null)
            {
                string s = "Message";
                if (mai.decl.VariableType.DotNetType.IsArray) s += "s";
                bool isFrom = (direction == MessageDirection.Backwards);
                if (channelInfo.IsDef) isFrom = !isFrom;
                if (isFrom) s += " from ";
                else s += " to ";
                context.OutputAttributes.Set(mai.decl, new DescriptionAttribute(s + da.Description));
            }

            // Propagate InitialiseTo attribute
            InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(channelInfo.decl);
            if (it != null)
            {
                if (channelInfo.IsMarginal || direction == MessageDirection.Forwards)
                {
                    context.OutputAttributes.Set(mai.decl, it);
                }
            }

            // Propagate InitialiseBackwardTo attribute
            InitialiseBackwardTo ibt = context.InputAttributes.Get<InitialiseBackwardTo>(channelInfo.decl);
            if (ibt != null)
            {
                if (direction == MessageDirection.Backwards)
                {
                    context.OutputAttributes.Set(mai.decl, new InitialiseTo(ibt.initialMessagesExpression));
                }
            }

            return mai;
        }

        /// <summary>
        /// Convert a variable declaration expression. Each channel declaration expression
        /// is converted to a forward and a backward message declaration expression. Message
        /// array information for both directions is recorded
        /// </summary>
        /// <param name="ivde">The channel variable declaration expression</param>
        /// <returns>null</returns>
        protected override IExpression ConvertVariableDeclExpr(IVariableDeclarationExpression ivde)
        {
            IVariableDeclaration ivd = ivde.Variable;
            context.InputAttributes.Remove<Containers>(ivd);
            context.OutputAttributes.Set(ivd, new Containers(context));
            ChannelInfo channelInfo = context.InputAttributes.Get<ChannelInfo>(ivd);
            // If a variable is stochastic it will get turned into channels, so channelInfo==null
            // identifies a non-stochastic variable
            if (channelInfo == null)
            {
                return ivde; // The variable is constant.
            }
            // ChannelToMessageInfo records any info needed to convert channels to messages
            // including references to the forward and backward message array information
            ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
            if (ctmi == null)
            {
                ctmi = new ChannelToMessageInfo();
                // Attach the info to declaration of channel variable
                context.InputAttributes.Set(ivd, ctmi);
            }
            var cpas = context.InputAttributes.GetAll<ChannelPathAttribute>(ivd).ToArray();
            foreach (MessageDirection direction in directions)
            {
                MessageArrayInformation mai = UseMessageAnalysis
                                                  ? CreateMessageVariable2(ivd.Name, channelInfo, ctmi, direction, cpas)
                                                  : CreateMessageVariable(ivd.Name, channelInfo, ctmi, direction, cpas);
                if (mai == null) continue;
                context.OutputAttributes.Set(mai.decl, new Containers(context));
                // Make the declaration expression for the message array variable
                IExpressionStatement stmt = MakeDeclStatement(channelInfo, mai);
                // This will be a declaration expression if this is an array and
                // a declaration with assignment otherwise
                if (InitializeOnSeparateLine && stmt.Expression is IAssignExpression iae)
                {
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(iae.Target));
                    iae.Target = Builder.VarRefExpr(mai.decl);
                    context.AddStatementBeforeCurrent(Builder.ExprStatement(iae));
                }
                else context.AddStatementBeforeCurrent(stmt);
            }
            return null;
        }

        /// <summary>
        /// Make the declaration statement for a message array variable
        /// </summary>
        /// <param name="channelInfo">The channel information</param>
        /// <param name="mai">The information for the message array variable</param>
        /// <returns>An assign expression or a declaration expression</returns>
        protected IExpressionStatement MakeDeclStatement(ChannelInfo channelInfo, MessageArrayInformation mai)
        {
            // Build the declaration expression
            IVariableDeclarationExpression ivde = Builder.VarDeclExpr(mai.decl);
            // Attach the quality band for the declaration expression
            Type msgType = mai.messageArrayType;
            if (Distribution.HasDistributionType(msgType))
            {
                QualityBand qb = Distribution.GetQualityBand(msgType);
                Context.OutputAttributes.Set(ivde, new QualityBandCompilerAttribute(qb));
            }

            VariableInformation channelVarInfo = (channelInfo.decl != null)
                ? context.InputAttributes.Get<VariableInformation>(channelInfo.decl)
                : channelInfo.varInfo;
            // Note: sizes.Count != ArrayDepth in general
            // If this variable has sizes, then it must have array create expressions, which will be handled by DoConvertArray.
            // However, !mai.isDistribution implies DoConvertArray will always have elementInit==null and generates no statements.
            if (channelVarInfo.sizes.Count == 0 || (!mai.isDistribution && !(algorithm is GibbsSampling)))
            {
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                bool userInitialized = (it != null);
                IExpression expr;
                if (it != null)
                {
                    if (IsGibbsMarginal(msgType))
                    {
                        AddGibbsMarginalInitStatements(Builder.VarRefExpr(mai.decl), it.initialMessagesExpression, channelVarInfo);
                        expr = mai.marginalPrototypeExpression;
                    }
                    else
                    {
                        expr = ConvertInitialiser(it.initialMessagesExpression);
                        expr = ConvertInitialiser(expr, msgType, channelVarInfo);
                    }
                }
                else if (!UseMessageAnalysis && mai.isDistribution) expr = MakeUniform(mai.marginalPrototypeExpression);
                else expr = mai.marginalPrototypeExpression;
                if (expr != null)
                {
                    if (!msgType.IsAssignableFrom(expr.GetExpressionType()))
                        Error($"Invalid initializer: {ivde} = {expr}");
                    IExpressionStatement init = Builder.AssignStmt(ivde, expr);
                    context.OutputAttributes.Set(init, new Initializer() { UserInitialized = userInitialized });
                    return init;
                }
            }
            IExpressionStatement declSt = Builder.ExprStatement(ivde);
            context.OutputAttributes.Set(declSt, new Initializer());
            return declSt;
        }

        protected override IExpression ConvertArrayCreate(IArrayCreateExpression iace)
        {
            // Get the index of the assignment expression whose RHS is this array create expression 
            int assignIndex = context.FindAncestorIndex<IAssignExpression>();
            // In MSL, random variable array creation can only occur on the RHS of an assignment.  
            if (assignIndex == context.InputStack.Count - 2)
            {
                IAssignExpression iae = (IAssignExpression)context.GetAncestor(assignIndex);
                IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
                if (ivd != null)
                {
                    ChannelInfo ci = context.InputAttributes.Get<ChannelInfo>(ivd);
                    ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
                    if (ctmi != null)
                    {
                        int depth = Recognizer.GetIndexingDepth(iae.Target);
                        foreach (var direction in directions)
                        {
                            CreateArray(direction, iace, iae.Target, depth, ivd, ci, ctmi);
                        }
                        return null;
                    }
                }
            }
            return base.ConvertArrayCreate(iace);
        }

        private void CreateArray(MessageDirection direction, IArrayCreateExpression iace, IExpression lhs, int depth, IVariableDeclaration ivd, ChannelInfo ci, ChannelToMessageInfo ctmi)
        {
            //lhs = Builder.ReplaceVariable(lhs, ivd, mai.decl);
            lhs = GetMessageExpression(lhs, direction);
            IExpression rhs = UseMessageAnalysis
                                  ? DoConvertArray2(direction, ivd, lhs, iace, depth, ctmi)
                                  : DoConvertArray(direction, ivd, lhs, iace, depth, ci, ctmi);
            if (rhs != null)
            {
                IExpressionStatement st = Builder.AssignStmt(lhs, rhs);
                context.OutputAttributes.Set(st.Expression, new DescriptionAttribute("Create array for '" + ci.decl.Name + "' " + direction + " messages."));
                Initializer ia = context.OutputAttributes.Get<Initializer>(rhs);
                if (ia != null)
                {
                    context.OutputAttributes.Remove<Initializer>(rhs);
                    context.OutputAttributes.Set(st, ia);
                }
                context.AddStatementBeforeCurrent(st);
            }
        }

        private IExpression DoConvertArray2(
            MessageDirection direction,
            IVariableDeclaration inputTarget,
            IExpression outputLhs,
            IArrayCreateExpression iace, int depth,
            ChannelToMessageInfo ctmi)
        {
            // mai is also an attribute of outputLhs
            MessageArrayInformation mai = (direction == MessageDirection.Forwards) ? ctmi.fwd : ctmi.bck;
            if (mai == null) return null;
            Type messageType = mai.messageArrayType; // type of the entire message array at the top level

            // arrayType must be a distribution array
            IList<IExpression> args = Builder.ExprCollection();
            //if (ci.ArrayDepth == depth + 1) args.Add(elementInit);
            args.AddRange(iace.Dimensions);
            Type arrayType = messageType; // type of this array
            if (!IsGibbsMarginal(arrayType))
            {
                for (int i = 0; i < depth; i++)
                {
                    arrayType = Util.GetElementType(arrayType);
                }
            }
            return Builder.NewObject(arrayType, args);
        }

        /// <summary>
        /// Construct an array creation expression and insert initialization statements
        /// </summary>
        /// <param name="direction">The message direction</param>
        /// <param name="inputTarget">Declaration of the variable on the LHS</param>
        /// <param name="outputLhs">Expression on the LHS</param>
        /// <param name="iace">Expression on the RHS</param>
        /// <param name="depth">Number of indexing brackets on the LHS</param>
        /// <param name="ci">Attribute of ivd</param>
        /// <param name="ctmi">Attribute of ivd</param>
        /// <returns></returns>
        private IExpression DoConvertArray(
            MessageDirection direction,
            IVariableDeclaration inputTarget,
            IExpression outputLhs,
            IArrayCreateExpression iace, int depth,
            ChannelInfo ci,
            ChannelToMessageInfo ctmi)
        {
            // mai is also an attribute of outputLhs
            MessageArrayInformation mai = (direction == MessageDirection.Forwards) ? ctmi.fwd : ctmi.bck;
            VariableInformation channelVarInfo = context.InputAttributes.Get<VariableInformation>(inputTarget);
            IExpression elementInit;
            Type messageType = mai.messageArrayType; // type of the entire message array at the top level

            IExpression mpe = mai.marginalPrototypeExpression;
            try
            {
                List<IList<IExpression>> indices = Recognizer.GetIndices(outputLhs);
                if (indices.Count > 0)
                {
                    int replaceCount = 0;
                    mpe = channelVarInfo.ReplaceIndexVars(context, mpe, indices, null, ref replaceCount);
                }
                if (mai.isDistribution)
                {
                    elementInit = MakeUniform(mpe);
                }
                else
                {
                    elementInit = null;
                }
            }
            catch (ArgumentException ex)
            {
                Error("Invalid marginal prototype expression: " + mpe, ex);
                return iace;
            }
            if (algorithm is GibbsSampling && ci.IsMarginal)
            {
                if (direction == MessageDirection.Forwards)
                {
                    if (mpe is IObjectCreateExpression ioce && IsGibbsMarginal(messageType))
                    {
                        if (depth > 0) return null;
                        InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                        if (it != null)
                            AddGibbsMarginalInitStatements(Builder.VarRefExpr(mai.decl), it.initialMessagesExpression, channelVarInfo);
                        if (ioce.Arguments[0] is IDefaultExpression)
                        {
                            // replace the first argument of "new GibbsMarginal" with marginal_B
                            IExpression messageExpression = Builder.VarRefExpr(Builder.VarRef(ctmi.bck.decl));
                            ioce.Arguments[0] = messageExpression;
                            IList<IExpression> newArgs = Builder.ExprCollection();
                            newArgs.Add(messageExpression);
                            for (int i = 1; i < ioce.Arguments.Count; i++)
                            {
                                newArgs.Add(ioce.Arguments[i]);
                            }
                            IExpression initExpr = Builder.NewObject(ioce.Type, newArgs);
                            context.OutputAttributes.Set(initExpr, new Initializer());
                            return initExpr;
                        }
                        else return mpe;
                    }
                }
                if (!mai.isDistribution)
                {
                    if (direction == MessageDirection.Forwards && depth == 0) return mpe;
                    else return null;
                }
            }

            bool isInitialiseTo = false;
            // If the user has specified an initializer, use it for elementInit.
            if (!(ci.IsMarginal && algorithm is GibbsSampling))
            {
                InitialiseTo it = context.InputAttributes.Get<InitialiseTo>(mai.decl);
                if (it != null)
                {
                    elementInit = it.initialMessagesExpression;
                    isInitialiseTo = true;
                }
                // fall through
            }
            int arrayDepth;
            Type domainType;
            if (elementInit != null)
            {
                if (isInitialiseTo)
                {
                    domainType = GetInitializerDomainType(elementInit, out int minusDepth);
                    Assert.IsTrue(minusDepth >= 0);
                    arrayDepth = Util.GetArrayDepth(ci.channelType, domainType) - minusDepth;
                    bool addBracketsToInitialiser = true;
                    if (addBracketsToInitialiser)
                    {
                        // add brackets to avoid the creation of unnecessary arrays
                        elementInit = AddBracketsToInitialiser(context, elementInit, channelVarInfo, ref arrayDepth, minusDepth);
                    }
                }
                else
                {
                    domainType = Distribution.GetDomainType(elementInit.GetExpressionType());
                    arrayDepth = Util.GetArrayDepth(ci.channelType, domainType);
                }
            }
            else
            {
                Type marginalType = mpe.GetExpressionType();
                // If marginalType is PointMass<innermost channelType>, we want GetDomainType.
                // If marginalType is innermost channelType, we do not want GetDomainType.
                domainType = mai.isDistribution ? Distribution.GetDomainType(marginalType) : marginalType;
                arrayDepth = Util.GetArrayDepth(ci.channelType, domainType);
            }
            bool depthZeroInit = arrayDepth == 0 && depth == 0 && elementInit != null;
            // if arrayDepth < depth+1, then DoConvertArray will have already created an initializer
            if (arrayDepth < depth + 1 && !depthZeroInit) return null;
            Type arrayType = messageType; // type of this array
            if (!IsGibbsMarginal(arrayType))
            {
                for (int i = 0; i < depth; i++)
                {
                    arrayType = Util.GetElementType(arrayType);
                }
            }
            // arrayType is now the message type of the LHS
            if (depthZeroInit)
            {
                if (isInitialiseTo)
                {
                    elementInit = ConvertInitialiser(elementInit);
                    elementInit = ConvertInitialiser(elementInit, arrayType, channelVarInfo, 0, false);
                    elementInit = Builder.StaticGenericMethod(
                        new Func<PlaceHolder, PlaceHolder, PlaceHolder>(ArrayHelper.SetTo<PlaceHolder>),
                        new Type[] { outputLhs.GetExpressionType() }, outputLhs, elementInit);
                    IStatement init = Builder.AssignStmt(outputLhs, elementInit);
                    context.OutputAttributes.Set(init, new Initializer()
                    {
                        UserInitialized = isInitialiseTo
                    });
                    context.AddStatementAfterCurrent(init);
                    // fall through
                }
                else
                {
                    context.OutputAttributes.Set(elementInit, new Initializer()
                    {
                        UserInitialized = isInitialiseTo
                    });
                    return elementInit;
                }
            }
            else if (arrayDepth == depth + 1 && elementInit != null)
            {
                if (isInitialiseTo)
                {
                    elementInit = ConvertInitialiser(elementInit);
                    Type elementType = Util.GetElementType(arrayType);
                    elementInit = ConvertInitialiser(elementInit, elementType, channelVarInfo);
                }
                foreach (IStatement init in FillArray(outputLhs, channelVarInfo, depth, (IReadOnlyList<IExpression>)iace.Dimensions, elementInit))
                {
                    context.OutputAttributes.Set(init, new Initializer() { UserInitialized = isInitialiseTo });
                    context.AddStatementAfterCurrent(init);
                }
                //args.Add(MakeArrayInitDelegate(elementInit, margType, ci.varInfo, iace.Dimensions.Count));
            }
            IExpression arrayCreate = GetArrayCreateExpression(outputLhs, arrayType, iace.Dimensions);
            context.OutputAttributes.Set(arrayCreate, new Initializer() { UserInitialized = isInitialiseTo });
            return arrayCreate;
        }

        internal static IExpression GetArrayCreateExpression(IExpression outputLhs, Type arrayType, IEnumerable<IExpression> dimensions)
        {
            if (arrayType.IsArray)
            {
                Type elementType = arrayType.GetElementType();
                return Builder.ArrayCreateExpr(elementType, dimensions);
            }
            // arrayType must be a distribution array
            IList<IExpression> args = Builder.ExprCollection();
            if (IsFileArray(arrayType))
            {
                bool parentIsDFA = false;

                if (outputLhs is IArrayIndexerExpression iaieLhs)
                {
                    Type targetType = iaieLhs.Target.GetExpressionType();
                    parentIsDFA = IsFileArray(targetType);
                }
                if (parentIsDFA)
                {
                    args.Add(iaieLhs.Target);
                    args.AddRange(iaieLhs.Indices);
                }
                else
                {
                    string name = GetName(outputLhs);
                    args.Add(Builder.StaticMethod(new Func<string, string>(FileArray<bool>.GetTempFolder), Builder.LiteralExpr(name)));
                }
            }
            args.AddRange(dimensions);
            return Builder.NewObject(arrayType, args);
        }

        internal static bool IsFileArray(Type type)
        {
            return (type.Name == typeof(DistributionFileArray<,>).Name || type.Name == typeof(FileArray<>).Name);
        }

        internal static string GetName(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie) return GetName(iaie);
            else if (expr is IVariableReferenceExpression ivre) return ivre.Variable.Variable.Name;
            else if (expr is IVariableDeclarationExpression ivde) return ivde.Variable.Name;
            else return CodeBuilder.MakeValid(expr.ToString());
        }

        internal static string GetName(IArrayIndexerExpression iaie)
        {
            string name = GetName(iaie.Target);
            IList<IExpression> bracket = iaie.Indices;
            for (int j = 0; j < bracket.Count; j++)
            {
                name += "_" + GetName(bracket[j]);
            }
            return name;
        }

        private Type GetInitializerDomainType(IExpression initialiser, out int minusDepth)
        {
            if (initialiser is IArrayIndexerExpression iaie)
            {
                Type type = GetInitializerDomainType(iaie.Target, out minusDepth);
                if (minusDepth > 0)
                {
                    minusDepth--;
                    return type;
                }
                else return Util.GetElementType(type);
            }
            else
            {
                if (initialiser is IArrayCreateExpression iace)
                {
                    if (iace.Type.DotNetType.Equals(typeof(PlaceHolder)))
                    {
                        Type type = GetInitializerDomainType(iace.Initializer.Expressions[0], out minusDepth);
                        minusDepth++;
                        return type;
                    }
                }
                Type initType = initialiser.GetExpressionType();
                minusDepth = 0;
                while (Util.IsIList(initType))
                {
                    minusDepth++;
                    initType = Util.GetElementType(initType);
                }
                return Distribution.GetDomainType(initType);
            }
        }

        /// <summary>
        /// Convert a raw initialiser expression (which may not be valid code) into a well-typed expression, possibly with "new PlaceHolder" on the outside.
        /// </summary>
        /// <param name="initialiser"></param>
        /// <returns></returns>
        private IExpression ConvertInitialiser(IExpression initialiser)
        {
            if (initialiserType.TryGetValue(initialiser, out Type type)) return Builder.CastExpr(initialiser, type);
            if (initialiser is IArrayIndexerExpression iaie)
            {
                IExpression target = ConvertInitialiser(iaie.Target);
                if (target is IArrayCreateExpression iace)
                {
                    if (iace.Type.DotNetType.Equals(typeof(PlaceHolder)) && iace.Initializer != null && iace.Initializer.Expressions.Count == 1)
                    {
                        IExpression initExpr = iace.Initializer.Expressions[0];
                        // replace index variables with the given indices
                        for (int dim = 0; dim < iace.Dimensions.Count; dim++)
                        {
                            initExpr = Builder.ReplaceExpression(initExpr, iace.Dimensions[dim], iaie.Indices[dim]);
                        }
                        return initExpr;
                    }
                }
                return Builder.ArrayIndex(target, iaie.Indices);
            }
            else if (initialiser is IArrayCreateExpression iace)
            {
                if (iace.Initializer == null) return initialiser;
                IArrayCreateExpression ace = Builder.ArrayCreateExpr(iace.Type, iace.Dimensions);
                ace.Initializer = Builder.BlockExpr();
                foreach (IExpression expr in iace.Initializer.Expressions)
                {
                    ace.Initializer.Expressions.Add(ConvertInitialiser(expr));
                }
                return ace;
            }
            else return initialiser;
        }

        /// <summary>
        /// Create an initialiser expression with additional indexing brackets
        /// </summary>
        /// <param name="context"></param>
        /// <param name="initialiser"></param>
        /// <param name="varInfo"></param>
        /// <param name="depth">Increased by to the number of brackets added</param>
        /// <param name="numBracketsToAdd">Desired number of brackets to add</param>
        /// <returns></returns>
        private IExpression AddBracketsToInitialiser(BasicTransformContext context, IExpression initialiser, VariableInformation varInfo, ref int depth, int numBracketsToAdd)
        {
            for (int bracket = 0; bracket < numBracketsToAdd; bracket++)
            {
                if (varInfo.sizes.Count < depth + 1) break;
                varInfo.DefineIndexVarsUpToDepth(context, depth + 1);
                var depthCopy = depth;
                IExpression[] indices = Util.ArrayInit(varInfo.indexVars[depth].Length,
                    i => Builder.VarRefExpr(varInfo.indexVars[depthCopy][i]));
                initialiser = Builder.ArrayIndex(initialiser, indices);
                depth++;
            }
            return initialiser;
        }

        /// <summary>
        /// Convert an initialiser expression (which may have "new PlaceHolder" on the outside) into a valid expression of the desired type.
        /// </summary>
        /// <param name="initialiser"></param>
        /// <param name="desiredType"></param>
        /// <param name="varInfo"></param>
        /// <param name="depth"></param>
        /// <param name="makeCopy"></param>
        /// <returns></returns>
        private IExpression ConvertInitialiser(IExpression initialiser, Type desiredType, VariableInformation varInfo, int depth = 0, bool makeCopy = true)
        {
            if (initialiser is IArrayCreateExpression iace)
            {
                if (iace.Initializer != null && iace.Initializer.Expressions.Count == 1)
                {
                    Type desiredElementType = Util.GetElementType(desiredType);
                    IExpression elementInit = ConvertInitialiser(iace.Initializer.Expressions[0], desiredElementType, varInfo, depth + 1);
                    if (desiredType.IsArray)
                    {
                        return GetArrayCreateExpression(desiredType, elementInit, varInfo, depth);
                    }
                    else
                    {
                        return GetDistributionArrayCreateExpression(desiredType, desiredElementType, elementInit, varInfo, depth);
                    }
                }
            }
            Type initType = initialiser.GetExpressionType();
            if (!desiredType.IsAssignableFrom(initType))
            {
                if (initType != null && Distribution.IsDistributionType(initType) && desiredType.IsAssignableFrom(Distribution.GetDomainType(initType)))
                {
                    return GetSamplingExpression(initialiser);
                }
                if (initialiser is IArrayIndexerExpression iaie)
                {
                    Type listType = typeof(IList<>).MakeGenericType(desiredType);
                    IExpression target = ConvertInitialiser(iaie.Target, listType, varInfo, depth - 1, false);
                    initialiser = Builder.ArrayIndex(target, iaie.Indices);
                }
                else if (!initType.IsAssignableFrom(desiredType))
                {
                    throw new InferCompilerException($"Initialiser {initialiser} has type {initType} instead of {desiredType}");
                }
                else
                {
                    initialiserType[initialiser] = desiredType;
                    initialiser = Builder.CastExpr(initialiser, desiredType);
                }
            }
            if (makeCopy && Distribution.IsDistributionType(desiredType))
            {
                initialiser = Builder.StaticGenericMethod(
                    new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeCopy),
                    new Type[] { desiredType },
                    initialiser);
            }
            return initialiser;
        }

        public static IExpression GetDistributionArrayCreateExpression(Type arrayType, Type innermostElementType, IExpression innermostElementInit, VariableInformation varInfo,
                                                                       int depth = 0)
        {
            // new DistributionRefArray<>(sourceArray.Length, index0 => new DistributionArray(sourceArray[index0].Length, ...))
            if (innermostElementType.IsAssignableFrom(arrayType)) return innermostElementInit;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type with innermost element type " + innermostElementType);
            IExpression elementInit = GetDistributionArrayCreateExpression(elementType, innermostElementType, innermostElementInit, varInfo, depth + 1);
            IExpression initDelegate = MakeArrayInitDelegate(elementInit, varInfo.indexVars[depth]);
            Type innerType = elementInit.GetExpressionType();
            Type distributionType = Distribution.MakeDistributionArrayType(innerType, rank);
            IList<IExpression> args = Builder.ExprCollection();
            for (int i = 0; i < rank; i++)
            {
                args.Add(varInfo.sizes[depth][i]);
            }
            args.Add(initDelegate);
            return Builder.NewObject(distributionType, args);
        }

        public static IAnonymousMethodExpression MakeArrayInitDelegate(IExpression elementInit, IVariableDeclaration[] indexVars)
        {
            // result has the form:  
            //   delegate(int index1, int index2) { return elementInit; })
            int rank = indexVars.Length;
            Type[] typeArgs = new Type[rank + 1];
            for (int i = 0; i < rank; i++)
            {
                typeArgs[i] = typeof(int);
            }
            typeArgs[typeArgs.Length - 1] = elementInit.GetExpressionType();
            Type delegateType;
            if (rank == 1) delegateType = typeof(Func<,>);
            else if (rank == 2) delegateType = typeof(Func<,,>);
            else if (rank == 3) delegateType = typeof(Func<,,,>);
            else if (rank == 4) delegateType = typeof(Func<,,,,>);
            else throw new NotImplementedException("Cannot initialize array of rank " + rank);
            IAnonymousMethodExpression iame = Builder.AnonMethodExpr(delegateType.MakeGenericType(typeArgs));
            iame.Body = Builder.BlockStmt();
            for (int i = 0; i < rank; i++)
            {
                IVariableDeclaration indexVar = indexVars[i];
                IParameterDeclaration param = Builder.Param(indexVar.Name, typeof(int));
                iame.Parameters.Add(param);
                int replaceCount = 0;
                elementInit = Builder.ReplaceExpression(elementInit, Builder.VarRefExpr(indexVar), Builder.ParamRef(param), ref replaceCount);
            }
            iame.Body.Statements.Add(Builder.Return(elementInit));
            return iame;
        }

        private IExpression GetSamplingExpression(IExpression distributionExpr)
        {
            Type srcType = distributionExpr.GetExpressionType();
            Type sampleableType = typeof(Sampleable<>).MakeGenericType(Distribution.GetDomainType(srcType));
            MethodInfo smplMthd = sampleableType.GetMethod("Sample", new Type[] { });
            IMethodReferenceExpression imre = Builder.MethodRefExpr();
            if (!sampleableType.IsAssignableFrom(srcType))
            {
                distributionExpr = Builder.CastExpr(distributionExpr, sampleableType);
            }
            imre.Target = distributionExpr;
            imre.Method = Builder.MethodRef(smplMthd);
            IMethodInvokeExpression imie = Builder.MethodInvkExpr();
            imie.Method = imre;
            return imie;
        }

        private void AddGibbsMarginalInitStatements(IExpression gibbsMargExpr, IExpression distExpr, VariableInformation varInfo)
        {
            if (gibbsMargExpr != null && distExpr != null)
            {
                Type gmType = gibbsMargExpr.GetExpressionType();
                IFieldReferenceExpression ipr = Builder.FieldRefExpr(
                    gibbsMargExpr, gmType, "LastConditional");
                Type iprType = ipr.GetExpressionType();
                distExpr = ConvertInitialiser(distExpr);
                distExpr = ConvertInitialiser(distExpr, iprType, varInfo);
                IStatement is1 = Builder.AssignStmt(ipr, distExpr);
                MethodInfo postUpdate = gmType.GetMethod("PostUpdate");
                IMethodReferenceExpression imre = Builder.MethodRefExpr();
                imre.Target = gibbsMargExpr;
                imre.Method = Builder.MethodRef(postUpdate);
                IMethodInvokeExpression imie = Builder.MethodInvkExpr();
                imie.Method = imre;
                IStatement is2 = Builder.ExprStatement(imie);
                IBlockStatement ibs = Builder.BlockStmt();
                context.OutputAttributes.Set(ibs, new Initializer() { UserInitialized = true });
                ibs.Statements.Add(is1);
                ibs.Statements.Add(is2);
                context.AddStatementAfterCurrent(ibs);
            }
        }

        /// <summary>
        /// Constructs statements that initialize the elements of an array in a single indexing bracket.
        /// </summary>
        /// <param name="outputLhs">The array to be initialized.</param>
        /// <param name="varInfo">variable info for the array.</param>
        /// <param name="depth">Number of indexing brackets in <paramref name="outputLhs"/></param>
        /// <param name="dimensions">The dimensions of the array.</param>
        /// <param name="elementInit">An expression for the array elements.  May contain references to the array's index variables, as stored in <paramref name="varInfo"/>.</param>
        /// <returns></returns>
        /// <remarks>
        /// Because elementInit may refer to the array's index variables, the generated loop will use these variables, if they are available in <paramref name="varInfo"/>.
        /// </remarks>
        protected IStatement[] FillArray(IExpression outputLhs, VariableInformation varInfo, int depth, IReadOnlyList<IExpression> dimensions, IExpression elementInit)
        {
            if (outputLhs is IVariableDeclarationExpression ivde) outputLhs = Builder.VarRefExpr(ivde.Variable);
            int indexingDepth = depth;
            if (indexingDepth == varInfo.LiteralIndexingDepth - 1)
            {
                // generate a separate statement for each array element
                if (dimensions.Count != 1) throw new ArgumentException("dimensions.Count != 1", nameof(dimensions));
                int sizeAsInt = (int)((ILiteralExpression)dimensions[0]).Value;
                return Util.ArrayInit(sizeAsInt, j =>
                {
                    IExpression index = Builder.LiteralExpr(j);
                    return Builder.AssignStmt(Builder.ArrayIndex(outputLhs, index), elementInit);
                });
            }
            // output a loop that explicitly initializes the array.
            IExpression[] indices = new IExpression[dimensions.Count];
            IVariableDeclaration[] indexVars = new IVariableDeclaration[indices.Length];
            if (varInfo.indexVars.Count > indexingDepth)
            {
                // this array may contain nulls, for indices that were not variables.
                varInfo.indexVars[indexingDepth].CopyTo(indexVars, 0);
            }
            for (int i = 0; i < indices.Length; i++)
            {
                // the same loop index may appear more than once in varInfo.  in this case, must create new indexVars.
                // this requires GetLoopForVariable to match based on name, since the IVariableDeclaration may not be the same object
                if (indexVars[i] == null || Recognizer.GetLoopForVariable(context, indexVars[i]) != null)
                {
                    indexVars[i] = Builder.VarDecl("_ind" + i, typeof(int));
                }
            }
            for (int i = 0; i < indexVars.Length; i++)
            {
                indices[i] = Builder.VarRefExpr(indexVars[i]);
            }
            IExpression elementLhs = Builder.ArrayIndex(outputLhs, indices);
            // if elementInit is MakeCopy, break into allocation followed by SetTo
            IStatement arrayCreate = null;
            if (varInfo.sizes.Count > indexingDepth + 1 &&
                Recognizer.IsStaticGenericMethod(elementInit, new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeCopy<PlaceHolder>)))
            {
                Type type = elementLhs.GetExpressionType();
                var arrayCreateExpr = GetArrayCreateExpression(elementLhs, type, varInfo.sizes[indexingDepth + 1]);
                arrayCreate = Builder.AssignStmt(elementLhs, arrayCreateExpr);
                elementInit = ((IMethodInvokeExpression)elementInit).Arguments[0];
                elementInit = Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder, PlaceHolder>(ArrayHelper.SetTo),
                    new Type[] { type }, elementLhs, elementInit);
            }
            IStatement ist = Builder.AssignStmt(elementLhs, elementInit);
            var fs = Builder.NestedForStmt(indexVars, dimensions, out IForStatement innerForStatement);
            if (arrayCreate != null)
                innerForStatement.Body.Statements.Add(arrayCreate);
            innerForStatement.Body.Statements.Add(ist);
            return new[] { fs };
        }

        public static IExpression GetArrayCreateExpression(Type arrayType, IExpression elementInit, VariableInformation varInfo, int depth = 0)
        {
            Type elementType = Util.GetElementType(arrayType, out int rank);
            IExpression initDelegate = MakeArrayInitDelegate(elementInit, varInfo.indexVars[depth]);
            IExpression[] args = new IExpression[rank + 1];
            for (int i = 0; i < rank; i++)
            {
                args[i] = varInfo.sizes[depth][i];
            }
            args[rank] = initDelegate;
            if (rank == 1)
            {
                return Builder.StaticGenericMethod(new Func<int, Converter<int, PlaceHolder>, PlaceHolder[]>(Util.ArrayInit<PlaceHolder>), new Type[] { elementType }, args);
            }
            else if (rank == 2)
            {
                return Builder.StaticGenericMethod(new Func<int, int, Func<int, int, PlaceHolder>, PlaceHolder[,]>(Util.ArrayInit<PlaceHolder>), new Type[] { elementType }, args);
            }
            else
                throw new NotImplementedException("rank > 2");
        }

        protected static IExpression MakeUniform(IExpression expression)
        {
            Type type = expression.GetExpressionType();
            if (IsPointMass(type)) return expression;
            if (Quoter.TryQuoteConstructable(null, out IExpression uniformExpr, "IsUniform", type)) return uniformExpr;
            return Builder.StaticGenericMethod(new Func<PlaceHolder, PlaceHolder>(ArrayHelper.MakeUniform<PlaceHolder>),
                                               new Type[] { type }, expression);
        }

        protected IExpression NewArrayFilled(Type elementType, IList<IExpression> sizes, IExpression elementExpr)
        {
            if (sizes.Count > 2) throw new NotImplementedException("Arrays of more than two dimensions are not yet supported.");
            IExpression[] args = new IExpression[sizes.Count + 1];
            Type[] argTypes = new Type[sizes.Count + 1];
            for (int i = 0; i < sizes.Count; i++)
            {
                args[i] = sizes[i];
                argTypes[i] = typeof(int);
            }
            args[args.Length - 1] = elementExpr;
            argTypes[argTypes.Length - 1] = elementType;
            Type returnType = CodeBuilder.MakeArrayType(elementType, sizes.Count);
            Delegate d;
            if (sizes.Count == 1)
            {
                d = new Func<PlaceHolder[], PlaceHolder, PlaceHolder[]>(ArrayHelper.Fill<PlaceHolder>);
            }
            else
            {
                d = new Func<PlaceHolder[,], PlaceHolder, PlaceHolder[,]>(ArrayHelper.Fill2D<PlaceHolder>);
            }
            return Builder.StaticGenericMethod(d, new Type[] { elementType }, args);
        }

        /// <summary>
        /// The current direction to use when converting variable references.
        /// </summary>
        protected MessageDirection? messageDirection;

        protected IExpression GetMessageExpression(IExpression channelRef, MessageDirection direction)
        {
            messageDirection = direction;
            IExpression expr = ConvertExpression(channelRef);
            messageDirection = null;
            return expr;
        }

        /// <summary>
        /// Converts a variable reference into a message, by replacing it with a reference to
        /// the forward or backward message arrays.  Also retrieves information about the message array.
        /// </summary>
        protected override IExpression ConvertVariableRefExpr(IVariableReferenceExpression ivre)
        {
            IVariableDeclaration ivd = ivre.Variable.Resolve();
            ChannelToMessageInfo ctmi = context.InputAttributes.Get<ChannelToMessageInfo>(ivd);
            if (ctmi == null) return ivre;
            MessageArrayInformation mai = (messageDirection == MessageDirection.Backwards) ? ctmi.bck : ctmi.fwd;
            if (mai == null) return null;
            IVariableDeclaration ivd2 = mai.decl;
            IExpression vre = Builder.VarRefExpr(ivd2);
            return vre;
        }

        /// <summary>
        /// Convert an array type into a distribution type.
        /// </summary>
        /// <param name="arrayType">A scalar, array, multidimensional array, or IList type.</param>
        /// <param name="innermostElementType">Type of innermost array element (may be itself an array, if the array is compound).</param>
        /// <param name="newInnermostElementType">Distribution type to use for the innermost array elements.</param>
        /// <param name="useDistributionArrays">Convert outer arrays to DistributionArrays.</param>
        /// <returns>A distribution type with the same structure as <paramref name="arrayType"/> but whose element type is <paramref name="newInnermostElementType"/>.</returns>
        /// <remarks>
        /// Similar to <see cref="Util.ChangeElementTypeAndRank"/> but converts arrays to DistributionArrays.
        /// </remarks>
        public static Type GetDistributionType(Type arrayType, Type innermostElementType, Type newInnermostElementType, bool useDistributionArrays)
        {
            if (innermostElementType.IsAssignableFrom(arrayType)) return newInnermostElementType;
            if (arrayType.IsArray)
            {
                Type elementType = Util.GetElementType(arrayType, out int rank);
                if (elementType == null) throw new ArgumentException(arrayType + " is not an array type with innermost element type " + innermostElementType);
                Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, useDistributionArrays);
                if (useDistributionArrays)
                {
                    return Distribution.MakeDistributionArrayType(innerType, rank);
                }
                else
                {
                    return CodeBuilder.MakeArrayType(innerType, rank);
                }
            }
            else
            {
                return typeof(PointMass<>).MakeGenericType(arrayType);
            }
        }

        /// <summary>
        /// Convert an array type into a distribution type, converting a specified number of inner arrays to DistributionArrays.
        /// </summary>
        /// <param name="arrayType"></param>
        /// <param name="innermostElementType"></param>
        /// <param name="newInnermostElementType"></param>
        /// <param name="depth">The current depth from the declaration type.</param>
        /// <param name="useDistributionArraysDepth">The depth at which to start converting to DistributionArrays.  This can be overridden by <paramref name="useFileArrayAtDepth"/></param>
        /// <param name="useFileArrayAtDepth"></param>
        /// <returns></returns>
        public static Type GetDistributionType(Type arrayType, Type innermostElementType, Type newInnermostElementType, int depth, int useDistributionArraysDepth,
                                               Predicate<int> useFileArrayAtDepth)
        {
            if (innermostElementType.IsAssignableFrom(arrayType)) return newInnermostElementType;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type.");
            if (arrayType.IsAssignableFrom(Util.MakeArrayType(elementType, rank)))
            {
                if (useFileArrayAtDepth(depth))
                {
                    Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, depth + 1, depth, useFileArrayAtDepth);
                    return Distribution.MakeDistributionFileArrayType(innerType, rank);
                }
                else
                {
                    Type innerType = GetDistributionType(elementType, innermostElementType, newInnermostElementType, depth + 1, useDistributionArraysDepth, useFileArrayAtDepth);
                    if ((depth >= useDistributionArraysDepth) && (useDistributionArraysDepth >= 0))
                    {
                        return Distribution.MakeDistributionArrayType(innerType, rank);
                    }
                    else
                    {
                        return CodeBuilder.MakeArrayType(innerType, rank);
                    }
                }
            }
            else
            {
                return typeof(PointMass<>).MakeGenericType(arrayType);
            }
        }

        public static Type GetArrayType(Type arrayType, Type innermostElementType, int depth, Predicate<int> useFileArrayAtDepth)
        {
            if (arrayType == innermostElementType) return innermostElementType;
            Type elementType = Util.GetElementType(arrayType, out int rank);
            if (elementType == null) throw new ArgumentException(arrayType + " is not an array type.");
            Type innerType = GetArrayType(elementType, innermostElementType, depth + 1, useFileArrayAtDepth);
            if (useFileArrayAtDepth(depth))
            {
                return MakeFileArrayType(innerType, rank);
            }
            else
            {
                return CodeBuilder.MakeArrayType(innerType, rank);
            }
        }

        public static Type MakeFileArrayType(Type elementType, int rank)
        {
            if (rank < 1) throw new ArgumentException("rank (" + rank + ") < 1");
            if (rank == 1)
            {
                return typeof(FileArray<>).MakeGenericType(elementType);
            }
            else
            {
                throw new ArgumentException("FileArray rank > 1 not yet implemented");
            }
        }

        public Type GetMessageType(ChannelInfo ci, Type marginalType)
        {
            VariableInformation vi = (ci.decl != null)
                ? VariableInformation.GetVariableInformation(context, ci.decl)
                : ci.varInfo;
            // leading array is [] up to distArraysDepth, then distribution arrays
            int distArraysDepth = System.Math.Max((algorithm is GibbsSampling) ? 0 : vi.DistArrayDepth, vi.LiteralIndexingDepth);            
            bool useFileArrayAtDepth(int depth) => vi.IsPartitionedAtDepth(context, depth);
            for (int depth = 0; depth < distArraysDepth; depth++)
            {
                if (useFileArrayAtDepth(depth))
                {
                    // in order to use DistributionFileArray, the element type must be a distribution type
                    distArraysDepth = depth + 1;
                    break;
                }
            }
            Type domainType = Distribution.GetDomainType(marginalType);
            try
            {
                return GetDistributionType(ci.channelType, domainType, marginalType, 0, distArraysDepth, useFileArrayAtDepth);
            }
            catch(Exception ex)
            {
                Error(ex.Message);
                return ci.channelType;
            }
        }

        /// <summary>
        /// Describes a message in a message-passing program.
        /// </summary>
        /// <remarks>
        /// A message is a channel paired with a direction (either forwards or backwards).
        /// A message can be labelled as an "output" to mean it is the result of inference.
        /// When a random variable has multiple uses, all uses are labelled with the same MessageInfo.
        /// 
        /// If the channel is in a plate, we need to distinguish between the case of one message per each
        /// plate instance versus one message for the entire plate.
        /// 
        /// If the channel is an array type, then there are three possible message types:
        /// 1. If the channel is in a plate, then so is the message.
        /// 2. If the channel is not in a plate, but individual messages are desired for each array element.
        /// If the channel is inside a plate, in which case it stores for an array of distributions.
        /// </remarks>
        public class MessageInfo
        {
            internal IExpression messageFromFactor, messageToFactor;
            internal readonly IVariableDeclaration channelDecl;

            /// <summary>
            /// True if the factor argument is a derived variable with non-unit derivative.
            /// </summary>
            internal readonly bool hasNonUnitDerivative;

            public MessageInfo()
            {
            }

            public MessageInfo(MessageTransform transform, IExpression channelRef)
            {
                IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(channelRef);
                if (ivd == null)
                    return;
                channelDecl = ivd;
                hasNonUnitDerivative = transform.context.InputAttributes.Has<DerivedVariable>(ivd) && transform.hasNonUnitDerivative.Contains(ivd);
                if (transform.AllowDerivedParents)
                    hasNonUnitDerivative = false;
            }

            public override string ToString()
            {
                return $"MessageInfo(messageFromFactor: {messageFromFactor}, messageToFactor: {messageToFactor}, channelDecl: {channelDecl}, hasNonUnitDerivative: {hasNonUnitDerivative})";
            }
        }

        /// <summary>
        /// Set the channelDecl field via the attributes applied to channelRef.
        /// </summary>
        /// <param name="mi">Will be modified</param>
        /// <param name="channelRef">An expression for the channel</param>
        internal void SetChannelInfo(MessageInfo mi, IExpression channelRef)
        {
        }

        private class ChannelToMessageInfo : ICompilerAttribute
        {
            /// <summary>
            /// Declaration of the forward message array/variable
            /// </summary>
            internal MessageArrayInformation fwd;

            /// <summary>
            /// Declaration of the backward message array/variable
            /// </summary>
            internal MessageArrayInformation bck;

            public override string ToString()
            {
                return $"ChannelToMessageInfo fwd = {fwd}, bck = {bck}";
            }
        }

        private class ObservedVariableMessages : ICompilerAttribute
        {
            internal readonly ChannelToMessageInfo ctmi;

            internal ObservedVariableMessages(ChannelToMessageInfo ctmi)
            {
                this.ctmi = ctmi;
            }

            public override string ToString()
            {
                return $"ObservedVariableMessages {ctmi}";
            }
        }

        private class MessageInfoDict : ICompilerAttribute
        {
            public IReadOnlyDictionary<string, MessageInfo> msgInfo;

            public override string ToString()
            {
                return StringUtil.DictionaryToString(msgInfo, " ");
            }
        }
    }

    /// <summary>
    /// Information about either the forwards or backwards message array
    /// </summary>
    internal class MessageArrayInformation : ICompilerAttribute
    {
        internal ChannelInfo ci;
        /// <summary>
        /// Declaration of the message array variable
        /// </summary>
        internal IVariableDeclaration decl;
        internal IExpression marginalPrototypeExpression = null;

        internal Type messageArrayType
        {
            get { return decl.VariableType.DotNetType; }
        }

        /// <summary>
        /// Indicates whether the message is a distribution over the channel.  
        /// (This can only be false when the algorithm overrides GetMessagePrototype.)
        /// </summary>
        internal bool isDistribution = true;

        /// <summary>
        /// Number of times this variable is used as an argument to a message operator.
        /// Only used by AccumulationTransform.
        /// </summary>
        internal int useCount;

        /// <summary>
        /// Set by LoopCuttingTransform, used by AccumulationTransform
        /// </summary>
        internal LoopVarInfo loopVarInfo;

        public override string ToString()
        {
            return $"MessageArrayInformation({decl},useCount={useCount},{ci},{marginalPrototypeExpression})";
        }
    }

    /// <summary>
    /// Enumeration for labelling forward and backward messages.
    /// </summary>
    public enum MessageDirection
    {
        Backwards,
        Forwards
    };

    /// <summary>
    /// Attached to a statement to indicate that it may appear in a while loop, i.e. it updates a message.  A statement without this attribute cannot appear in a while loop.
    /// </summary>
    internal class OperatorStatement : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attribute used to mark methods which contain operator statements (i.e. statements which are to be processed by the scheduler).
    /// </summary>
    internal class OperatorMethod : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attribute used to mark methods which assert deterministic constraints
    /// </summary>
    internal class DeterministicConstraint : ICompilerAttribute
    {
    }

    /// <summary>
    /// Attached to statements to indicate that they will be overwritten by later statements, i.e. this is not the final value of the variable.
    /// </summary>
    internal class Initializer : ICompilerAttribute
    {
        /// <summary>
        /// If true, this statement is initialized by the user.
        /// </summary>
        public bool UserInitialized;

        public override string ToString()
        {
            return "Initializer" + (UserInitialized ? "(UserInitialized)" : "");
        }
    }


    /// <summary>
    /// Attribute used to mark variables that appear as arguments to Infer()
    /// </summary>
    internal class IsInferred : ICompilerAttribute
    {
    }

    /// <summary>
    /// When applied to a variable, indicates that the forward message is always a point mass (but not necessarily constant).
    /// </summary>
    internal class ForwardPointMass : ICompilerAttribute
    {
    }

    /// <summary>
    /// When applied to a method invoke expression, indicates that the execution of this
    /// expression depends on the iteration counter
    /// </summary>
    internal class DependsOnIteration : ICompilerAttribute
    {
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "DependsOnIteration";
        }
    }

    /// <summary>
    /// When attached to a message declaration, indicates that the message has no initializer statement, only update statements.
    /// </summary>
    internal class DoesNotHaveInitializer : ICompilerAttribute
    {
    }

    /// <summary>
    /// A type which can be used as a placeholder in a generic method reference.  It will be replaced
    /// by the dynamically specified type argument provided separately.
    /// </summary>
    internal interface PlaceHolder : IDistribution<object>, SettableToProduct<PlaceHolder>, SettableTo<PlaceHolder>
    {
    }

    internal interface PlaceHolder2 : IDistribution<object>, SettableToProduct<PlaceHolder>
    {
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs(18,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs(1953,30): error CS0165: Use of unassigned local variable 'iaieLhs',D:\a\1\s\src\Compiler\Infer\Transforms\MessageTransform.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Data;
using System.Reflection;
using System.Linq;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Models.Attributes;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Transform which:
    ///   Removes all methods other than the one containing the model.
    ///   Calls to InferNet.PreserveWhenCompiled are stripped out.
    ///   Switch cases with value less than zero are stripped out.
    ///   Evaluate some expressions that contain literals.
    ///   Processes and removes any Attrib static calls, replacing them with attributes on the appropriate code elements.
    ///   Replace variables in condition blocks with their conditioned values.
    ///   Attach index variable information to arrays (via VariableInformation attributes).
    ///   Attach Constraint attributes to assignments that are actually constraints.
    /// </summary>
    internal class ModelAnalysisTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "ModelAnalysisTransform"; }
        }

        private ExpressionEvaluator evaluator = new ExpressionEvaluator();
        private List<ConditionBinding> conditionContext = new List<ConditionBinding>();
        /// <summary>
        /// Used to track recursive calls to ConvertArrayCreate
        /// </summary>
        private bool convertingArrayCreate;
        private Stack<IStatement> arrayCreateStmts = new Stack<IStatement>();

        /// <summary>
        /// Used to generate unique class names
        /// </summary>
        private static readonly Set<string> compiledClassNames = new Set<string>();
        private static readonly object compiledClassNamesLock = new object();

        /// <summary>
        /// Number of variables marked for inference
        /// </summary>
        private int inferCount = 0;

        public override void ConvertTypeProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            base.ConvertTypeProperties(td, itd);
            // Set td.Name to a valid identifier that is unique from all previously generated classes, by adding an index as appropriate.
            string baseName = td.Name;
            int count = 0;
            lock (compiledClassNamesLock)
            {
                while (compiledClassNames.Contains(td.Namespace + "." + td.Name))
                {
                    td.Name = baseName + count;
                    count++;
                }
                compiledClassNames.Add(td.Namespace + "." + td.Name);
            }
        }

        protected override void ConvertNestedTypes(ITypeDeclaration td, ITypeDeclaration itd)
        {
            // remove all nested types            
        }

        protected override void ConvertProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            // remove all properties
        }

        /// <summary>
        /// Analyses the method specified in MethodToTransform, if any.  Otherwise analyses all methods.
        /// </summary>
        /// <param name="imd"></param>
        /// <returns></returns>
        protected override IMethodDeclaration ConvertMethod(IMethodDeclaration imd)
        {
            IMethodDeclaration imd2 = base.ConvertMethod(imd);
            ITypeDeclaration td = context.FindOutputForAncestor<ITypeDeclaration, ITypeDeclaration>();
            //td.Documentation = "model '"+imd.Name+"'";
            if (inferCount == 0)
            {
                Error("No variables were marked for inference, please mark some variables with InferNet.Infer(var).");
            }
            return imd2;
        }

        protected override IStatement ConvertSwitch(ISwitchStatement iss)
        {
            ISwitchStatement ss = Builder.SwitchStmt();
            context.SetPrimaryOutput(ss);
            ss.Expression = ConvertExpression(iss.Expression);
            foreach (ISwitchCase isc in iss.Cases)
            {
                if (isc is IConditionCase)
                {
                    IExpression cond = ((IConditionCase) isc).Condition;
                    ILiteralExpression ile = cond as ILiteralExpression;
                    if ((ile != null) && (ile.Value is int) && ((int) ile.Value < 0)) continue;
                }
                ConvertSwitchCase(ss.Cases, isc);
            }
            return ss;
        }

        protected override IExpression ConvertAssign(IAssignExpression iae)
        {
            IParameterDeclaration ipd = null;
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
            object decl = ivd;
            if (ivd == null)
            {
                ipd = Recognizer.GetParameterDeclaration(iae.Target);
                if (ipd == null)
                    return base.ConvertAssign(iae);
                decl = ipd;
            }
            if (iae.Target is IArrayIndexerExpression)
            {
                // Gather index variables from the left-hand side of the assignment
                VariableInformation vi = VariableInformation.GetVariableInformation(context, decl);
                try
                {
                    List<IVariableDeclaration[]> indVars = new List<IVariableDeclaration[]>();
                    Recognizer.AddIndexers(context, indVars, iae.Target);
                    int depth = Recognizer.GetIndexingDepth(iae.Target);
                    // if this statement is actually a constraint, then we don't need to enforce matching of index variables
                    bool isConstraint = context.InputAttributes.Has<Models.Constraint>(context.FindAncestor<IStatement>());
                    for (int i = 0; i < depth; i++)
                    {
                        vi.SetIndexVariablesAtDepth(i, indVars[i], allowMismatch: isConstraint);
                    }
                }
                catch (Exception ex)
                {
                    Error(ex.Message, ex);
                }
            }
            IAssignExpression ae = (IAssignExpression) base.ConvertAssign(iae);
            if (ipd == null)
            {
                // assignment to a local variable
                if (ae.Expression is IMethodInvokeExpression)
                {
                    IMethodInvokeExpression imie = (IMethodInvokeExpression)ae.Expression;
                    // this unfortunately duplicates some of the work done by SetStoch and IsStoch.
                    FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, imie);
                    if (info != null && info.IsDeterministicFactor && !context.InputAttributes.Has<DerivedVariable>(ivd))
                    {
                        context.InputAttributes.Set(ivd, new DerivedVariable());
                    }
                }
                if (ae.Expression is ILiteralExpression)
                {
                    bool isLoopInitializer = (Recognizer.GetAncestorIndexOfLoopBeingInitialized(context) != -1);
                    if (!isLoopInitializer)
                    {
                        Type valueType = ae.Expression.GetExpressionType();
                        if (Quoter.ShouldInlineType(valueType))
                        {
                            // inline all future occurrences of this variable with the rhs expression
                            conditionContext.Add(new ConditionBinding(ae.Target, ae.Expression));
                        }
                    }
                }
            }
            else
            {
                // assignment to a method parameter
                IStatement ist = context.FindAncestor<IStatement>();
                if (!context.InputAttributes.Has<Models.Constraint>(ist))
                {
                    // mark this statement as a constraint
                    context.OutputAttributes.Set(ist, new Models.Constraint());
                }
            }
            // a FactorAlgorithm attribute on a variable turns into an Algorithm attribute on its right hand side.
            var attr = context.InputAttributes.Get<FactorAlgorithm>(decl);
            if (attr != null)
            {
                context.OutputAttributes.Set(ae.Expression, new Algorithm(attr.algorithm));
            }
            context.InputAttributes.CopyObjectAttributesTo<GivePriorityTo>(decl, context.OutputAttributes, ae.Expression);
            return ae;
        }

        protected override IExpression ConvertMethodInvoke(IMethodInvokeExpression imie)
        {
            if (Recognizer.IsStaticGenericMethod(imie, new Func<PlaceHolder, ICompilerAttribute, PlaceHolder>(Attrib.Var)))
            {
                IVariableReferenceExpression ivre = imie.Arguments[0] as IVariableReferenceExpression;
                IVariableDeclaration target = ivre.Variable.Resolve();
                IExpression expr = CodeRecognizer.RemoveCast(imie.Arguments[1]);
                AddAttribute(target, expr);
                return null;
            }
            else if (Recognizer.IsStaticMethod(imie, new Action<object, object>(Attrib.InitialiseTo)))
            {
                IVariableReferenceExpression ivre = CodeRecognizer.RemoveCast(imie.Arguments[0]) as IVariableReferenceExpression;
                IVariableDeclaration target = ivre.Variable.Resolve();
                context.OutputAttributes.Set(target, new InitialiseTo(imie.Arguments[1]));
                return null;
            }
            else if (CodeRecognizer.IsInfer(imie))
            {
                inferCount++;
                object decl = Recognizer.GetDeclaration(imie.Arguments[0]);
                if (decl != null && !context.InputAttributes.Has<IsInferred>(decl))
                    context.InputAttributes.Set(decl, new IsInferred());
                // the arguments must not be substituted for their values, so we don't call ConvertExpression
                List<IExpression> newArgs = new List<IExpression>();
                foreach (var arg in imie.Arguments)
                {
                    newArgs.Add(CodeRecognizer.RemoveCast(arg));
                }
                IMethodInvokeExpression mie = Builder.MethodInvkExpr();
                mie.Method = imie.Method;
                mie.Arguments.AddRange(newArgs);
                context.InputAttributes.CopyObjectAttributesTo(imie, context.OutputAttributes, mie);
                return mie;                
            }
            IExpression converted = base.ConvertMethodInvoke(imie);
            if (converted is IMethodInvokeExpression)
            {
                var mie = (IMethodInvokeExpression)converted;
                bool isAnd = Recognizer.IsStaticMethod(converted, new Func<bool, bool, bool>(Factors.Factor.And));
                bool isOr = Recognizer.IsStaticMethod(converted, new Func<bool, bool, bool>(Factors.Factor.Or));
                bool anyArgumentIsLiteral = mie.Arguments.Any(arg => arg is ILiteralExpression);
                if (anyArgumentIsLiteral)
                {
                    if (isAnd)
                    {
                        if (mie.Arguments.Any(arg => arg is ILiteralExpression && ((ILiteralExpression)arg).Value.Equals(false)))
                            return Builder.LiteralExpr(false);
                        // any remaining literals must be true, and therefore can be ignored.
                        var reducedArguments = mie.Arguments.Where(arg => !(arg is ILiteralExpression));
                        if (reducedArguments.Count() == 1) return reducedArguments.First();
                        else return Builder.LiteralExpr(true);
                    }
                    else if (isOr)
                    {
                        if (mie.Arguments.Any(arg => arg is ILiteralExpression && ((ILiteralExpression)arg).Value.Equals(true)))
                            return Builder.LiteralExpr(true);
                        // any remaining literals must be false, and therefore can be ignored.
                        var reducedArguments = mie.Arguments.Where(arg => !(arg is ILiteralExpression));
                        if (reducedArguments.Count() == 1) return reducedArguments.First();
                        else return Builder.LiteralExpr(false);
                    }
                    else if (Recognizer.IsStaticMethod(converted, new Func<bool, bool>(Factors.Factor.Not)))
                    {
                        bool allArgumentsAreLiteral = mie.Arguments.All(arg => arg is ILiteralExpression);
                        if (allArgumentsAreLiteral)
                        {
                            return Builder.LiteralExpr(evaluator.Evaluate(mie));
                        }
                    }
                }
                foreach (IExpression arg in mie.Arguments)
                {
                    if (arg is IAddressOutExpression)
                    {
                        IAddressOutExpression iaoe = (IAddressOutExpression)arg;
                        IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iaoe.Expression);
                        if (ivd != null)
                        {
                            FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, mie);
                            if (info != null && info.IsDeterministicFactor && !context.InputAttributes.Has<DerivedVariable>(ivd))
                            {
                                context.InputAttributes.Set(ivd, new DerivedVariable());
                            }
                        }
                    }
                }
            }
            return converted;
        }

        protected override IExpression ConvertCastExpr(ICastExpression ice)
        {
            return CodeRecognizer.RemoveCast(base.ConvertCastExpr(ice));
        }

        private void AddAttribute(object target, IExpression attrExpr)
        {
            try
            {
                ICompilerAttribute value = evaluator.Evaluate(attrExpr) as ICompilerAttribute;
                if (value == null)
                {
                    throw new InvalidExpressionException("Expression must evaluate to an ICompilerAttribute");
                }
                // TODO: Fix this temporary hack to allow quoting of this expression later
                if (value is MarginalPrototype)
                {
                    ((MarginalPrototype) value).prototypeExpression = ((IObjectCreateExpression) attrExpr).Arguments[0];
                }
                object[] auas = value.GetType().GetCustomAttributes(typeof (AttributeUsageAttribute), true);
                if (auas.Length > 0)
                {
                    AttributeUsageAttribute aua = (AttributeUsageAttribute) auas[0];
                    if (!aua.AllowMultiple) Context.InputAttributes.RemoveOfType(target, value.GetType());
                }
                Context.InputAttributes.Set(target, value);
            }
            catch (Exception ex)
            {
                Error("Could not evaluate attribute " + attrExpr, ex);
            }
        }

        protected override IExpression ConvertArrayCreate(IArrayCreateExpression iace)
        {
            IArrayCreateExpression ace = (IArrayCreateExpression) base.ConvertArrayCreate(iace);
            IAssignExpression iae = context.FindAncestor<IAssignExpression>();
            if (iae == null) return ace;
            if (iae.Expression != iace) return ace;
            if (iace.Initializer != null)
            {
                var exprs = iace.Initializer.Expressions;
                bool expandInitializer = !AllElementsAreLiteral(exprs);
                if (expandInitializer)
                {
                    // convert the initializer to a list of assignment statements to literal indices
                    bool wasConvertingArrayCreate = convertingArrayCreate;
                    if (!wasConvertingArrayCreate)
                        arrayCreateStmts.Clear();
                    convertingArrayCreate = true;
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
                    // Sets the size of this variable at this array depth
                    int depth = Recognizer.GetIndexingDepth(iae.Target);
                    IExpression[] dimExprs = new IExpression[ace.Dimensions.Count];
                    for (int i = 0; i < dimExprs.Length; i++)
                        dimExprs[i] = ace.Dimensions[i];
                    List<IList<IExpression>> indices = Recognizer.GetIndices(iae.Target);
                    // for a multi-dimensional array, exprs will contain IBlockExpressions
                    // dimExprs must be ILiteralExpressions
                    int[] dims = Util.ArrayInit(dimExprs.Length, i => (int)((ILiteralExpression)dimExprs[i]).Value);
                    int[] strides = StringUtil.ArrayStrides(dims);
                    int elementCount = strides[0] * dims[0];
                    var target = Builder.JaggedArrayIndex(Builder.VarRefExpr(ivd), indices);
                    int[] mIndex = new int[dims.Length];
                    for (int linearIndex = elementCount - 1; linearIndex >= 0; linearIndex--)
                    {
                        StringUtil.LinearIndexToMultidimensionalIndex(linearIndex, strides, mIndex);
                        var indexExprs = Util.ArrayInit(mIndex.Length, i => Builder.LiteralExpr(mIndex[i]));
                        var lhs = Builder.ArrayIndex(target, indexExprs);
                        var expr = GetInitializerElement(exprs, mIndex);
                        var assignStmt = Builder.AssignStmt(lhs, expr);
                        var st = ConvertStatement(assignStmt);
                        arrayCreateStmts.Push(st);
                    }
                    ace.Initializer = null;
                    convertingArrayCreate = wasConvertingArrayCreate;
                    if (!wasConvertingArrayCreate)
                    {
                        context.AddStatementsAfterCurrent(arrayCreateStmts);
                    }
                }
            }
            return ace;
        }

        protected static bool AllElementsAreLiteral(IList<IExpression> exprs)
        {
            foreach (var expr in exprs)
            {
                if (expr is IBlockExpression)
                {
                    IBlockExpression ibe = (IBlockExpression)expr;
                    if (!AllElementsAreLiteral(ibe.Expressions))
                        return false;
                }
                else if(!(expr is ILiteralExpression))
                {
                    return false;
                }
            }
            return true;
        }

        protected static IExpression GetInitializerElement(IList<IExpression> exprs, int[] mIndex, int dim = 0)
        {
            var expr = exprs[mIndex[dim]];
            if (dim == mIndex.Length - 1)
            {
                return expr;
            }
            else
            {
                var blockExpr = (IBlockExpression)expr;
                return GetInitializerElement(blockExpr.Expressions, mIndex, dim + 1);
            }
        }

        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            IConditionStatement cs = Builder.CondStmt();
            cs.Condition = ConvertExpression(ics.Condition);
            if (cs.Condition is ILiteralExpression)
            {
                bool value = (bool) ((ILiteralExpression) cs.Condition).Value;
                if (value)
                {
                    if (ics.Then != null)
                    {
                        foreach (IStatement st in ics.Then.Statements)
                        {
                            IStatement ist = ConvertStatement(st);
                            if (ist != null) context.AddStatementBeforeCurrent(ist);
                        }
                    }
                }
                else
                {
                    if (ics.Else != null)
                    {
                        foreach (IStatement st in ics.Else.Statements)
                        {
                            IStatement ist = ConvertStatement(st);
                            if (ist != null) context.AddStatementBeforeCurrent(ist);
                        }
                    }
                }
                return null;
            }
            context.SetPrimaryOutput(cs);
            IForStatement loop;
            ConditionBinding binding = GateTransform.GetConditionBinding(cs.Condition, context, out loop);
            int startIndex = conditionContext.Count;
            conditionContext.Add(binding);
            cs.Then = ConvertBlock(ics.Then);
            if (ics.Else != null)
            {
                conditionContext.RemoveRange(startIndex, conditionContext.Count - startIndex);
                binding = binding.FlipCondition();
                conditionContext.Add(binding);
                cs.Else = ConvertBlock(ics.Else);
            }
            conditionContext.RemoveRange(startIndex, conditionContext.Count - startIndex);
            if (cs.Then.Statements.Count == 0 && (cs.Else == null || cs.Else.Statements.Count == 0)) return null;
            return cs;
        }

        protected override IExpression DoConvertExpression(IExpression expr)
        {
            expr = base.DoConvertExpression(expr);
            if (expr != null)
            {
                foreach (ConditionBinding ci in conditionContext)
                {
                    // each lhs has already been replaced, so we only need to compare for equality
                    if (expr.Equals(ci.lhs)) return ci.rhs;
                }
            }
            return expr;
        }

        protected override IExpression ConvertUnary(IUnaryExpression iue)
        {
            iue = (IUnaryExpression)base.ConvertUnary(iue);
            if (iue.Operator == UnaryOperator.BooleanNot)
            {
                if (iue.Expression is ILiteralExpression)
                {
                    ILiteralExpression expr = (ILiteralExpression)iue.Expression;
                    if (expr.Value is bool)
                    {
                        return Builder.LiteralExpr(!(bool)expr.Value);
                    }
                }
                else if (iue.Expression is IUnaryExpression)
                {
                    IUnaryExpression iue2 = (IUnaryExpression)iue.Expression;
                    if (iue2.Operator == UnaryOperator.BooleanNot) // double negation
                        return iue2.Expression;
                }
                else if (iue.Expression is IBinaryExpression)
                {
                    IBinaryExpression ibe = (IBinaryExpression)iue.Expression;
                    BinaryOperator negatedOp;
                    if (Recognizer.TryNegateOperator(ibe.Operator, out negatedOp))
                    {
                        // replace !(i==0) with (i != 0)
                        return Builder.BinaryExpr(ibe.Left, negatedOp, ibe.Right);
                    }
                }
            }
            return iue;
        }

        protected override IExpression ConvertBinary(IBinaryExpression ibe)
        {
            ibe = (IBinaryExpression) base.ConvertBinary(ibe);
            if (ibe.Left is ILiteralExpression && ibe.Right is ILiteralExpression)
            {
                try
                {
                    return Builder.LiteralExpr(evaluator.Evaluate(ibe));
                }
                catch
                {
                }
            }
            return ibe;
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Data;
using System.Reflection;
using System.Linq;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Models.Attributes;

namespace Microsoft.ML.Probabilistic.Compiler.Transforms
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Transform which:
    ///   Removes all methods other than the one containing the model.
    ///   Calls to InferNet.PreserveWhenCompiled are stripped out.
    ///   Switch cases with value less than zero are stripped out.
    ///   Evaluate some expressions that contain literals.
    ///   Processes and removes any Attrib static calls, replacing them with attributes on the appropriate code elements.
    ///   Replace variables in condition blocks with their conditioned values.
    ///   Attach index variable information to arrays (via VariableInformation attributes).
    ///   Attach Constraint attributes to assignments that are actually constraints.
    /// </summary>
    internal class ModelAnalysisTransform : ShallowCopyTransform
    {
        public override string Name
        {
            get { return "ModelAnalysisTransform"; }
        }

        private ExpressionEvaluator evaluator = new ExpressionEvaluator();
        private List<ConditionBinding> conditionContext = new List<ConditionBinding>();
        /// <summary>
        /// Used to track recursive calls to ConvertArrayCreate
        /// </summary>
        private bool convertingArrayCreate;
        private Stack<IStatement> arrayCreateStmts = new Stack<IStatement>();

        /// <summary>
        /// Used to generate unique class names
        /// </summary>
        private static readonly Set<string> compiledClassNames = new Set<string>();
        private static readonly object compiledClassNamesLock = new object();

        /// <summary>
        /// Number of variables marked for inference
        /// </summary>
        private int inferCount = 0;

        public override void ConvertTypeProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            base.ConvertTypeProperties(td, itd);
            // Set td.Name to a valid identifier that is unique from all previously generated classes, by adding an index as appropriate.
            string baseName = td.Name;
            int count = 0;
            lock (compiledClassNamesLock)
            {
                while (compiledClassNames.Contains(td.Namespace + "." + td.Name))
                {
                    td.Name = baseName + count;
                    count++;
                }
                compiledClassNames.Add(td.Namespace + "." + td.Name);
            }
        }

        protected override void ConvertNestedTypes(ITypeDeclaration td, ITypeDeclaration itd)
        {
            // remove all nested types            
        }

        protected override void ConvertProperties(ITypeDeclaration td, ITypeDeclaration itd)
        {
            // remove all properties
        }

        /// <summary>
        /// Analyses the method specified in MethodToTransform, if any.  Otherwise analyses all methods.
        /// </summary>
        /// <param name="imd"></param>
        /// <returns></returns>
        protected override IMethodDeclaration ConvertMethod(IMethodDeclaration imd)
        {
            IMethodDeclaration imd2 = base.ConvertMethod(imd);
            ITypeDeclaration td = context.FindOutputForAncestor<ITypeDeclaration, ITypeDeclaration>();
            //td.Documentation = "model '"+imd.Name+"'";
            if (inferCount == 0)
            {
                Error("No variables were marked for inference, please mark some variables with InferNet.Infer(var).");
            }
            return imd2;
        }

        protected override IStatement ConvertSwitch(ISwitchStatement iss)
        {
            ISwitchStatement ss = Builder.SwitchStmt();
            context.SetPrimaryOutput(ss);
            ss.Expression = ConvertExpression(iss.Expression);
            foreach (ISwitchCase isc in iss.Cases)
            {
                if (isc is IConditionCase iConditionCase)
                {
                    IExpression cond = iConditionCase.Condition;
                    ILiteralExpression ile = cond as ILiteralExpression;
                    if ((ile != null) && (ile.Value is int) && ((int) ile.Value < 0)) continue;
                }
                ConvertSwitchCase(ss.Cases, isc);
            }
            return ss;
        }

        protected override IExpression ConvertAssign(IAssignExpression iae)
        {
            IParameterDeclaration ipd = null;
            IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
            object decl = ivd;
            if (ivd == null)
            {
                ipd = Recognizer.GetParameterDeclaration(iae.Target);
                if (ipd == null)
                    return base.ConvertAssign(iae);
                decl = ipd;
            }
            if (iae.Target is IArrayIndexerExpression)
            {
                // Gather index variables from the left-hand side of the assignment
                VariableInformation vi = VariableInformation.GetVariableInformation(context, decl);
                try
                {
                    List<IVariableDeclaration[]> indVars = new List<IVariableDeclaration[]>();
                    Recognizer.AddIndexers(context, indVars, iae.Target);
                    int depth = Recognizer.GetIndexingDepth(iae.Target);
                    // if this statement is actually a constraint, then we don't need to enforce matching of index variables
                    bool isConstraint = context.InputAttributes.Has<Models.Constraint>(context.FindAncestor<IStatement>());
                    for (int i = 0; i < depth; i++)
                    {
                        vi.SetIndexVariablesAtDepth(i, indVars[i], allowMismatch: isConstraint);
                    }
                }
                catch (Exception ex)
                {
                    Error(ex.Message, ex);
                }
            }
            IAssignExpression ae = (IAssignExpression) base.ConvertAssign(iae);
            if (ipd == null)
            {
                // assignment to a local variable
                if (ae.Expression is IMethodInvokeExpression)
                {
                    IMethodInvokeExpression imie = (IMethodInvokeExpression)ae.Expression;
                    // this unfortunately duplicates some of the work done by SetStoch and IsStoch.
                    FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, imie);
                    if (info != null && info.IsDeterministicFactor && !context.InputAttributes.Has<DerivedVariable>(ivd))
                    {
                        context.InputAttributes.Set(ivd, new DerivedVariable());
                    }
                }
                if (ae.Expression is ILiteralExpression)
                {
                    bool isLoopInitializer = (Recognizer.GetAncestorIndexOfLoopBeingInitialized(context) != -1);
                    if (!isLoopInitializer)
                    {
                        Type valueType = ae.Expression.GetExpressionType();
                        if (Quoter.ShouldInlineType(valueType))
                        {
                            // inline all future occurrences of this variable with the rhs expression
                            conditionContext.Add(new ConditionBinding(ae.Target, ae.Expression));
                        }
                    }
                }
            }
            else
            {
                // assignment to a method parameter
                IStatement ist = context.FindAncestor<IStatement>();
                if (!context.InputAttributes.Has<Models.Constraint>(ist))
                {
                    // mark this statement as a constraint
                    context.OutputAttributes.Set(ist, new Models.Constraint());
                }
            }
            // a FactorAlgorithm attribute on a variable turns into an Algorithm attribute on its right hand side.
            var attr = context.InputAttributes.Get<FactorAlgorithm>(decl);
            if (attr != null)
            {
                context.OutputAttributes.Set(ae.Expression, new Algorithm(attr.algorithm));
            }
            context.InputAttributes.CopyObjectAttributesTo<GivePriorityTo>(decl, context.OutputAttributes, ae.Expression);
            return ae;
        }

        protected override IExpression ConvertMethodInvoke(IMethodInvokeExpression imie)
        {
            if (Recognizer.IsStaticGenericMethod(imie, new Func<PlaceHolder, ICompilerAttribute, PlaceHolder>(Attrib.Var)))
            {
                IVariableReferenceExpression ivre = imie.Arguments[0] as IVariableReferenceExpression;
                IVariableDeclaration target = ivre.Variable.Resolve();
                IExpression expr = CodeRecognizer.RemoveCast(imie.Arguments[1]);
                AddAttribute(target, expr);
                return null;
            }
            else if (Recognizer.IsStaticMethod(imie, new Action<object, object>(Attrib.InitialiseTo)))
            {
                IVariableReferenceExpression ivre = CodeRecognizer.RemoveCast(imie.Arguments[0]) as IVariableReferenceExpression;
                IVariableDeclaration target = ivre.Variable.Resolve();
                context.OutputAttributes.Set(target, new InitialiseTo(imie.Arguments[1]));
                return null;
            }
            else if (CodeRecognizer.IsInfer(imie))
            {
                inferCount++;
                object decl = Recognizer.GetDeclaration(imie.Arguments[0]);
                if (decl != null && !context.InputAttributes.Has<IsInferred>(decl))
                    context.InputAttributes.Set(decl, new IsInferred());
                // the arguments must not be substituted for their values, so we don't call ConvertExpression
                List<IExpression> newArgs = new List<IExpression>();
                foreach (var arg in imie.Arguments)
                {
                    newArgs.Add(CodeRecognizer.RemoveCast(arg));
                }
                IMethodInvokeExpression mie = Builder.MethodInvkExpr();
                mie.Method = imie.Method;
                mie.Arguments.AddRange(newArgs);
                context.InputAttributes.CopyObjectAttributesTo(imie, context.OutputAttributes, mie);
                return mie;                
            }
            IExpression converted = base.ConvertMethodInvoke(imie);
            if (converted is IMethodInvokeExpression mie)
            {
                bool isAnd = Recognizer.IsStaticMethod(converted, new Func<bool, bool, bool>(Factors.Factor.And));
                bool isOr = Recognizer.IsStaticMethod(converted, new Func<bool, bool, bool>(Factors.Factor.Or));
                bool anyArgumentIsLiteral = mie.Arguments.Any(arg => arg is ILiteralExpression);
                if (anyArgumentIsLiteral)
                {
                    if (isAnd)
                    {
                        if (mie.Arguments.Any(arg => arg is ILiteralExpression && ((ILiteralExpression)arg).Value.Equals(false)))
                            return Builder.LiteralExpr(false);
                        // any remaining literals must be true, and therefore can be ignored.
                        var reducedArguments = mie.Arguments.Where(arg => !(arg is ILiteralExpression));
                        if (reducedArguments.Count() == 1) return reducedArguments.First();
                        else return Builder.LiteralExpr(true);
                    }
                    else if (isOr)
                    {
                        if (mie.Arguments.Any(arg => arg is ILiteralExpression && ((ILiteralExpression)arg).Value.Equals(true)))
                            return Builder.LiteralExpr(true);
                        // any remaining literals must be false, and therefore can be ignored.
                        var reducedArguments = mie.Arguments.Where(arg => !(arg is ILiteralExpression));
                        if (reducedArguments.Count() == 1) return reducedArguments.First();
                        else return Builder.LiteralExpr(false);
                    }
                    else if (Recognizer.IsStaticMethod(converted, new Func<bool, bool>(Factors.Factor.Not)))
                    {
                        bool allArgumentsAreLiteral = mie.Arguments.All(arg => arg is ILiteralExpression);
                        if (allArgumentsAreLiteral)
                        {
                            return Builder.LiteralExpr(evaluator.Evaluate(mie));
                        }
                    }
                }
                foreach (IExpression arg in mie.Arguments)
                {
                    if (arg is IAddressOutExpression iaoe)
                    {
                        IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iaoe.Expression);
                        if (ivd != null)
                        {
                            FactorManager.FactorInfo info = CodeRecognizer.GetFactorInfo(context, mie);
                            if (info != null && info.IsDeterministicFactor && !context.InputAttributes.Has<DerivedVariable>(ivd))
                            {
                                context.InputAttributes.Set(ivd, new DerivedVariable());
                            }
                        }
                    }
                }
            }
            return converted;
        }

        protected override IExpression ConvertCastExpr(ICastExpression ice)
        {
            return CodeRecognizer.RemoveCast(base.ConvertCastExpr(ice));
        }

        private void AddAttribute(object target, IExpression attrExpr)
        {
            try
            {
                ICompilerAttribute value = evaluator.Evaluate(attrExpr) as ICompilerAttribute;
                if (value == null)
                {
                    throw new InvalidExpressionException("Expression must evaluate to an ICompilerAttribute");
                }
                // TODO: Fix this temporary hack to allow quoting of this expression later
                if (value is MarginalPrototype marginalPrototype)
                {
                    marginalPrototype.prototypeExpression = ((IObjectCreateExpression) attrExpr).Arguments[0];
                }
                object[] auas = value.GetType().GetCustomAttributes(typeof (AttributeUsageAttribute), true);
                if (auas.Length > 0)
                {
                    AttributeUsageAttribute aua = (AttributeUsageAttribute) auas[0];
                    if (!aua.AllowMultiple) Context.InputAttributes.RemoveOfType(target, value.GetType());
                }
                Context.InputAttributes.Set(target, value);
            }
            catch (Exception ex)
            {
                Error("Could not evaluate attribute " + attrExpr, ex);
            }
        }

        protected override IExpression ConvertArrayCreate(IArrayCreateExpression iace)
        {
            IArrayCreateExpression ace = (IArrayCreateExpression) base.ConvertArrayCreate(iace);
            IAssignExpression iae = context.FindAncestor<IAssignExpression>();
            if (iae == null) return ace;
            if (iae.Expression != iace) return ace;
            if (iace.Initializer != null)
            {
                var exprs = iace.Initializer.Expressions;
                bool expandInitializer = !AllElementsAreLiteral(exprs);
                if (expandInitializer)
                {
                    // convert the initializer to a list of assignment statements to literal indices
                    bool wasConvertingArrayCreate = convertingArrayCreate;
                    if (!wasConvertingArrayCreate)
                        arrayCreateStmts.Clear();
                    convertingArrayCreate = true;
                    IVariableDeclaration ivd = Recognizer.GetVariableDeclaration(iae.Target);
                    // Sets the size of this variable at this array depth
                    int depth = Recognizer.GetIndexingDepth(iae.Target);
                    IExpression[] dimExprs = new IExpression[ace.Dimensions.Count];
                    for (int i = 0; i < dimExprs.Length; i++)
                        dimExprs[i] = ace.Dimensions[i];
                    List<IList<IExpression>> indices = Recognizer.GetIndices(iae.Target);
                    // for a multi-dimensional array, exprs will contain IBlockExpressions
                    // dimExprs must be ILiteralExpressions
                    int[] dims = Util.ArrayInit(dimExprs.Length, i => (int)((ILiteralExpression)dimExprs[i]).Value);
                    int[] strides = StringUtil.ArrayStrides(dims);
                    int elementCount = strides[0] * dims[0];
                    var target = Builder.JaggedArrayIndex(Builder.VarRefExpr(ivd), indices);
                    int[] mIndex = new int[dims.Length];
                    for (int linearIndex = elementCount - 1; linearIndex >= 0; linearIndex--)
                    {
                        StringUtil.LinearIndexToMultidimensionalIndex(linearIndex, strides, mIndex);
                        var indexExprs = Util.ArrayInit(mIndex.Length, i => Builder.LiteralExpr(mIndex[i]));
                        var lhs = Builder.ArrayIndex(target, indexExprs);
                        var expr = GetInitializerElement(exprs, mIndex);
                        var assignStmt = Builder.AssignStmt(lhs, expr);
                        var st = ConvertStatement(assignStmt);
                        arrayCreateStmts.Push(st);
                    }
                    ace.Initializer = null;
                    convertingArrayCreate = wasConvertingArrayCreate;
                    if (!wasConvertingArrayCreate)
                    {
                        context.AddStatementsAfterCurrent(arrayCreateStmts);
                    }
                }
            }
            return ace;
        }

        protected static bool AllElementsAreLiteral(IList<IExpression> exprs)
        {
            foreach (var expr in exprs)
            {
                if (expr is IBlockExpression ibe)
                {
                    if (!AllElementsAreLiteral(ibe.Expressions))
                        return false;
                }
                else if(!(expr is ILiteralExpression))
                {
                    return false;
                }
            }
            return true;
        }

        protected static IExpression GetInitializerElement(IList<IExpression> exprs, int[] mIndex, int dim = 0)
        {
            var expr = exprs[mIndex[dim]];
            if (dim == mIndex.Length - 1)
            {
                return expr;
            }
            else
            {
                var blockExpr = (IBlockExpression)expr;
                return GetInitializerElement(blockExpr.Expressions, mIndex, dim + 1);
            }
        }

        protected override IStatement ConvertCondition(IConditionStatement ics)
        {
            IConditionStatement cs = Builder.CondStmt();
            cs.Condition = ConvertExpression(ics.Condition);
            if (cs.Condition is ILiteralExpression)
            {
                bool value = (bool) ((ILiteralExpression) cs.Condition).Value;
                if (value)
                {
                    if (ics.Then != null)
                    {
                        foreach (IStatement st in ics.Then.Statements)
                        {
                            IStatement ist = ConvertStatement(st);
                            if (ist != null) context.AddStatementBeforeCurrent(ist);
                        }
                    }
                }
                else
                {
                    if (ics.Else != null)
                    {
                        foreach (IStatement st in ics.Else.Statements)
                        {
                            IStatement ist = ConvertStatement(st);
                            if (ist != null) context.AddStatementBeforeCurrent(ist);
                        }
                    }
                }
                return null;
            }
            context.SetPrimaryOutput(cs);
            IForStatement loop;
            ConditionBinding binding = GateTransform.GetConditionBinding(cs.Condition, context, out loop);
            int startIndex = conditionContext.Count;
            conditionContext.Add(binding);
            cs.Then = ConvertBlock(ics.Then);
            if (ics.Else != null)
            {
                conditionContext.RemoveRange(startIndex, conditionContext.Count - startIndex);
                binding = binding.FlipCondition();
                conditionContext.Add(binding);
                cs.Else = ConvertBlock(ics.Else);
            }
            conditionContext.RemoveRange(startIndex, conditionContext.Count - startIndex);
            if (cs.Then.Statements.Count == 0 && (cs.Else == null || cs.Else.Statements.Count == 0)) return null;
            return cs;
        }

        protected override IExpression DoConvertExpression(IExpression expr)
        {
            expr = base.DoConvertExpression(expr);
            if (expr != null)
            {
                foreach (ConditionBinding ci in conditionContext)
                {
                    // each lhs has already been replaced, so we only need to compare for equality
                    if (expr.Equals(ci.lhs)) return ci.rhs;
                }
            }
            return expr;
        }

        protected override IExpression ConvertUnary(IUnaryExpression iue)
        {
            iue = (IUnaryExpression)base.ConvertUnary(iue);
            if (iue.Operator == UnaryOperator.BooleanNot)
            {
                if (iue.Expression is ILiteralExpression)
                {
                    ILiteralExpression expr = (ILiteralExpression)iue.Expression;
                    if (expr.Value is bool)
                    {
                        return Builder.LiteralExpr(!(bool)expr.Value);
                    }
                }
                else if (iue.Expression is IUnaryExpression)
                {
                    IUnaryExpression iue2 = (IUnaryExpression)iue.Expression;
                    if (iue2.Operator == UnaryOperator.BooleanNot) // double negation
                        return iue2.Expression;
                }
                else if (iue.Expression is IBinaryExpression)
                {
                    IBinaryExpression ibe = (IBinaryExpression)iue.Expression;
                    BinaryOperator negatedOp;
                    if (Recognizer.TryNegateOperator(ibe.Operator, out negatedOp))
                    {
                        // replace !(i==0) with (i != 0)
                        return Builder.BinaryExpr(ibe.Left, negatedOp, ibe.Right);
                    }
                }
            }
            return iue;
        }

        protected override IExpression ConvertBinary(IBinaryExpression ibe)
        {
            ibe = (IBinaryExpression) base.ConvertBinary(ibe);
            if (ibe.Left is ILiteralExpression && ibe.Right is ILiteralExpression)
            {
                try
                {
                    return Builder.LiteralExpr(evaluator.Evaluate(ibe));
                }
                catch
                {
                }
            }
            return ibe;
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs(8,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs(12,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs(232,41): error CS0136: A local or parameter named 'mie' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs(12,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\Compiler\Infer\Transforms\ModelAnalysisTransform.cs(8,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 8 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Transforms;
using System.Linq;
using Microsoft.ML.Probabilistic.Factors;

namespace Microsoft.ML.Probabilistic.Compiler
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Helper class for recognizing patterns in code which is to be transformed.
    /// </summary>
    public class CodeRecognizer
    {
        public static readonly CodeRecognizer Instance = new CodeRecognizer();

        private CodeRecognizer()
        {
        }

        /// <summary>
        /// Helps build class declarations
        /// </summary>
        private static readonly CodeBuilder Builder = CodeBuilder.Instance;

        /// <summary>
        /// True if expr is a MethodInvokeExpression on any static method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public bool IsStaticMethod(IExpression expr, Type type)
        {
            return (GetStaticMethodOfType(expr, type) != null);
        }

        /// <summary>
        /// True if expr is a MethodInvokeExpression on any overload of the named static method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public bool IsStaticMethod(IExpression expr, Type type, string methodName)
        {
            string s = GetStaticMethodOfType(expr, type);
            return methodName.Equals(s);
        }

        public bool IsStaticMethod(IExpression expr, Delegate method)
        {
            return IsStaticMethod(expr, method.Method);
        }

        public bool IsStaticMethod(IExpression expr, MethodInfo method)
        {
            IMethodReference imr = GetMethodReference(expr);
            if (imr == null)
                return false;
            return method.Equals(imr.MethodInfo);
        }

        /// <summary>
        /// True if imie is a MethodInvokeExpression on any overload of the named static generic method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public bool IsStaticGenericMethod(IExpression expr, Type type, string methodName)
        {
            if (!(expr is IMethodInvokeExpression))
                return false;
            IMethodInvokeExpression imie = (IMethodInvokeExpression)expr;
            if (!(imie.Method is IMethodReferenceExpression))
                return false;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)imie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return false;
            ITypeReference itr = ((ITypeReferenceExpression)imre.Target).Type;
            if (itr.Namespace != type.Namespace)
                return false;
            if (itr.GenericType is ITypeReference)
                itr = itr.GenericType;
            if (itr.DotNetType.Name != type.Name)
                return false;
            return (imie.Method.Method.Name == methodName);
        }

        public bool IsStaticGenericMethod(IExpression expr, Delegate method)
        {
            MethodInfo methodInfo = method.Method;
            return IsStaticGenericMethod(expr, methodInfo.DeclaringType, methodInfo.Name);
        }

        public string GetStaticMethodOfType(IExpression expr, Type type)
        {
            if (!(expr is IMethodInvokeExpression))
                return null;
            IMethodInvokeExpression mie = (IMethodInvokeExpression)expr;
            if (!(mie.Method is IMethodReferenceExpression))
                return null;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)mie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return null;
            ITypeReferenceExpression itre = (ITypeReferenceExpression)imre.Target;
            if (!IsTypeReferenceTo(itre, type))
                return null;
            return imre.Method.Name;
        }

        public ITypeReference GetStaticMethodType(IExpression expr)
        {
            if (!(expr is IMethodInvokeExpression))
                return null;
            IMethodInvokeExpression mie = (IMethodInvokeExpression)expr;
            if (!(mie.Method is IMethodReferenceExpression))
                return null;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)mie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return null;
            ITypeReferenceExpression itre = (ITypeReferenceExpression)imre.Target;
            return itre.Type;
        }

        public IMethodReference GetMethodReference(IExpression expr)
        {
            if (!(expr is IMethodInvokeExpression mie))
                return null;
            if (!(mie.Method is IMethodReferenceExpression imre))
                return null;
            return imre.Method;
        }

        public bool IsBeingDeclared(BasicTransformContext context)
        {
            object parent = context.GetAncestor(context.InputStack.Count - 2);
            return (parent is IVariableDeclarationExpression);
        }

        public bool IsBeingIndexed(BasicTransformContext context)
        {
            object parent = context.GetAncestor(context.InputStack.Count - 2);
            return (parent is IArrayIndexerExpression);
        }

        /// <summary>
        /// Returns true if the expression is being mutated in the given context.  For example, this will
        /// be true if the expression is the LHS of an assignment, or the argument to an 'out' parameter.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        public bool IsBeingMutated(BasicTransformContext context, IExpression expr)
        {
            int methodIndex = context.FindAncestorIndex<IMethodInvokeExpression>();
            if (methodIndex != -1)
            {
                if (context.GetAncestor(methodIndex + 1) is IAddressOutExpression iaoe)
                    return IsPartOf(iaoe.Expression, expr);
                else
                    return false;
            }
            return IsOnLHSOfAssignment(context, expr);
        }

        public Bounds GetBounds(IExpression expr, IReadOnlyDictionary<IVariableDeclaration, Bounds> bounds)
        {
            if (expr is IVariableReferenceExpression && bounds != null)
            {
                IVariableDeclaration ivd = GetVariableDeclaration(expr);
                Bounds b;
                if (bounds.TryGetValue(ivd, out b))
                    return b;
            }
            else if (expr is IBinaryExpression ibe)
            {
                Bounds left = GetBounds(ibe.Left, bounds);
                Bounds right = GetBounds(ibe.Right, bounds);
                if (left != null && right != null)
                {
                    if (ibe.Operator == BinaryOperator.Add)
                    {
                        return new Bounds()
                        {
                            lowerBound = left.lowerBound + right.lowerBound,
                            upperBound = left.upperBound + right.upperBound
                        };
                    }
                    else if (ibe.Operator == BinaryOperator.Subtract)
                    {
                        return new Bounds()
                        {
                            lowerBound = left.lowerBound - right.upperBound,
                            upperBound = left.upperBound - right.lowerBound
                        };
                    }
                }
            }
            else if (expr is ILiteralExpression ile)
            {
                if (ile.Value is int value)
                {
                    return new Bounds()
                    {
                        lowerBound = value,
                        upperBound = value
                    };
                }
            }
            return null;
        }

        private IVariableDeclaration GetOffsetVariable(IExpression expr)
        {
            int offset;
            return GetOffsetVariable(expr, out offset);
        }

        private IVariableDeclaration GetOffsetVariable(IExpression expr, out int offset)
        {
            offset = 0;
            if (expr is IVariableReferenceExpression)
            {
                return GetVariableDeclaration(expr);
            }
            else if (expr is IBinaryExpression indexBinaryExpr)
            {
                ILiteralExpression offsetExpr = indexBinaryExpr.Right as ILiteralExpression;
                if (indexBinaryExpr.Left is IVariableReferenceExpression ivre && offsetExpr != null && offsetExpr.Value is int)
                {
                    offset = (int)offsetExpr.Value;
                    if (indexBinaryExpr.Operator == BinaryOperator.Subtract)
                    {
                        offset = -offset;
                    }
                    else if (indexBinaryExpr.Operator == BinaryOperator.Add)
                    {
                        // do nothing
                    }
                    else
                    {
                        return null;
                    }
                    return GetVariableDeclaration(ivre);
                }
            }
            return null;
        }

        /// <summary>
        /// Reflection cache
        /// </summary>
        readonly MethodInfo AnyIndexMethod = new Func<int>(GateAnalysisTransform.AnyIndex).Method;

        // helper for MutatingFirstAffectsSecond
        // offsets and extraIndices only need to be modified on a match (though they can be modified in any case)
        private bool IndicesOverlap(IList<IExpression> mutated_indices, IList<IExpression> affected_indices, bool mutatesWithinOnly,
                                    IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInMutated,
                                    IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInAffected,
                                    OffsetInfo offsets,
                                    ICollection<IVariableDeclaration> extraIndices,
                                    ICollection<IVariableDeclaration> matchedIndices)
        {
            // if mutatesWithinOnly = false, then return false on mismatched literals
            // if mutatesWithinOnly = true, then return false also if mutated index is wildcard and affected index is literal
            // if one index is an offset of the other and non-literal, return true but add entry to offsets dictionary
            if (mutated_indices.Count != affected_indices.Count)
                throw new ArgumentException("Mismatched array rank");
            for (int i = 0; i < mutated_indices.Count; i++)
            {
                IExpression mutated_index = mutated_indices[i];
                IExpression affected_index = affected_indices[i];
                if (mutated_index.Equals(affected_index))
                {
                    IVariableDeclaration mutatedVar = GetOffsetVariable(mutated_index);
                    if (mutatedVar != null) matchedIndices.Add(mutatedVar);
                    continue;
                }
                if (IsStaticMethod(affected_index, AnyIndexMethod))
                    continue;
                if (affected_index is ILiteralExpression)
                {
                    if (mutated_index is ILiteralExpression)
                    {
                        // if we reach this point, they don't match
                        return false;
                    }
                    else
                    {
                        if (mutatesWithinOnly)
                            return false; // mutated_index is more general
                        int affected_value = (int)((ILiteralExpression)affected_index).Value;
                        Bounds mutatedBounds = GetBounds(mutated_index, boundsInMutated);
                        if (mutatedBounds != null)
                        {
                            if (!mutatedBounds.Contains(affected_value))
                                return false;
                        }
                        if (offsets != null)
                        {
                            // if affected=v (when i=j) and mutated=i-k, then we write to v on iter v+k, and read on iter j, so offset is v+k-j
                            // offset = (loop counter of write) - (loop counter of read)
                            Bounds affectedBounds = GetBounds(mutated_index, boundsInAffected);
                            if (affectedBounds != null)
                            {
                                // affectedBounds = [jLower-k, jUpper-k]
                                int minOffset = affected_value - affectedBounds.upperBound;
                                int maxOffset = affected_value - affectedBounds.lowerBound;
                                if (System.Math.Sign(minOffset) != System.Math.Sign(maxOffset))
                                    throw new Exception("Inconsistent offset between array indexer expressions: " + mutated_index + " and " + affected_index);
                                int offset = (minOffset > 0) ? minOffset : maxOffset;
                                if (offset != 0)
                                {
                                    IVariableDeclaration loopVar = GetOffsetVariable(mutated_index);
                                    offsets.Add(loopVar, offset, true);
                                }
                            }
                            else if (extraIndices != null)
                            {
                                IVariableDeclaration loopVar = GetOffsetVariable(mutated_index);
                                if (loopVar != null && !matchedIndices.Contains(loopVar))
                                    extraIndices.Add(loopVar);
                            }
                        }
                    }
                }
                else if (mutatesWithinOnly)
                    return false;  // expressions are incomparable
                else if (mutated_index is ILiteralExpression)
                {
                    int mutated_value = (int)((ILiteralExpression)mutated_index).Value;
                    Bounds affectedBounds = GetBounds(affected_index, boundsInAffected);
                    if (affectedBounds != null)
                    {
                        if (!affectedBounds.Contains(mutated_value))
                            return false;
                    }
                    if (offsets != null)
                    {
                        // if affected=i-k and mutated=v (when i=j), then we write to v on iter j, and read on iter v+k, so offset is j-v-k
                        // offset = (loop counter of write) - (loop counter of read)
                        Bounds mutatedBounds = GetBounds(affected_index, boundsInMutated);
                        if (mutatedBounds != null)
                        {
                            // mutatedBounds = [jLower-k, jUpper-k]
                            int minOffset = mutatedBounds.lowerBound - mutated_value;
                            int maxOffset = mutatedBounds.upperBound - mutated_value;
                            if (System.Math.Sign(minOffset) != System.Math.Sign(maxOffset))
                                throw new Exception("Inconsistent offset between array indexer expressions: " + mutated_index + " and " + affected_index);
                            int offset = (minOffset > 0) ? minOffset : maxOffset;
                            if (offset != 0)
                            {
                                IVariableDeclaration affectedVar = GetOffsetVariable(affected_index);
                                offsets.Add(affectedVar, offset, true);
                            }
                        }
                    }
                }
                else if (offsets != null || extraIndices != null)
                {
                    // neither affected nor mutated is literal
                    // check for offsetting
                    int mutated_offset, affected_offset;
                    IVariableDeclaration mutatedVar = GetOffsetVariable(mutated_index, out mutated_offset);
                    IVariableDeclaration affectedVar = GetOffsetVariable(affected_index, out affected_offset);
                    if (mutatedVar != null)
                    {
                        if (mutatedVar.Equals(affectedVar))
                        {
                            // mutated has the form [t + mutated_offset]
                            // affected has the form [t + affected_offset]
                            int offset = 0;
                            offset += affected_offset;
                            offset -= mutated_offset;
                            if (offset != 0)
                            {
                                bool isAvailable;
                                if (offset < 0)
                                {
                                    // TODO: make use of bounds
                                    // forward loop from 0 to size-1
                                    // we want to know if the first affected element will be mutated at an earlier time.
                                    // if affected_offset <= 0 then first affected is element 0 at time = -affected_offset.
                                    // if mutated_offset <= 0 then element 0 is mutated at time = -mutated_offset.
                                    // therefore available when -mutated_offset < -affected_offset, i.e. mutated_offset > affected_offset
                                    // which is always true.
                                    // if mutated_offset > 0 then element 0 is never mutated so not available.
                                    // if affected_offset > 0 then first affected is affected_offset at time 0 so not available.
                                    isAvailable = (affected_offset <= 0) && (mutated_offset <= 0);
                                }
                                else
                                {
                                    // backward loop from size-1 to 0
                                    // we want to know if the last affected element mutated will be mutated at a later time.
                                    // if affected_offset >= 0 then last affected is element size-1 at time = size-1 - affected_offset.
                                    // if mutated_offset >= 0 then this element is mutated at time = size-1 - mutated_offset.
                                    // therefore available when mutated_offset < affected_offset which is always true.
                                    // if mutated_offset < 0 then element size-1 is never mutated so not available.
                                    // if affected_offset < 0 then last affected is (size-1+affected_offset) at last time so not available.
                                    //isAvailable = (affected_offset >= 0); // TODO
                                    isAvailable = (affected_offset >= 0) && (mutated_offset >= 0);
                                }
                                offsets.Add(mutatedVar, offset, isAvailable);
                            }
                            matchedIndices.Add(mutatedVar);
                        }
                        else
                        {
                            // affected and mutated use two different loop variables.
                            // we cannot merge on either of these loops.
                            if(!matchedIndices.Contains(mutatedVar))
                                extraIndices.Add(mutatedVar);
                            if (affectedVar != null)
                                extraIndices.Add(affectedVar);
                        }
                    }
                    else
                    {
                        foreach(var v in GetVariables(mutated_index))
                        {
                            if(!matchedIndices.Contains(v))
                                extraIndices.Add(v);
                        }
                        if (affectedVar != null)
                            extraIndices.Add(affectedVar);
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Reflection cache
        /// </summary>
        readonly MethodInfo AnyMethod = new Func<object[], object>(FactorManager.Any).Method;

        /// <summary>
        /// Returns true if mutating the first expression would affect the value of the second.
        /// For example, if the first expression is 'x' and the second is 'x[1]' the answer is true.
        /// If the first expression is 'x[0]' and the second is 'x[1]' the answer is false.
        /// 
        /// If 'mutatesWithinOnly' is true, the result will only be true if the first expression mutates
        /// all or part of the second, but nothing else.  For example, if the first is 'x[0]' and the second is 'x'
        /// the result is true but not if the first is 'x' and the second 'x[0]'. 
        /// </summary>
        /// <param name="context">The context</param>
        /// <param name="mutated">The mutating expression</param>
        /// <param name="affected">The possibly affected expression</param>
        /// <param name="mutatesWithinOnly">See summary</param>
        /// <param name="mutatedStatement">Bindings on the index variables in mutated</param>
        /// <param name="affectedStatement">Bindings on the index variables in affected</param>
        /// <param name="boundsInMutated">Lower bounds on the index variables in mutated</param>
        /// <param name="boundsInAffected">Lower bounds on the index variables in affected</param>
        /// <param name="offsets">Modified to contain indexing offsets necessary for a match</param>
        /// <param name="extraIndices">Modified to contain loop indices in mutated that must be iterated to cover affected (i.e. loops that cannot be merged)</param>
        /// <returns></returns>
        internal bool MutatingFirstAffectsSecond(
            BasicTransformContext context,
            IExpression mutated,
            IExpression affected,
            bool mutatesWithinOnly,
            IStatement mutatedStatement = null,
            IStatement affectedStatement = null,
            IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInMutated = null,
            IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInAffected = null,
            OffsetInfo offsets = null,
            ICollection<IVariableDeclaration> extraIndices = null)
        {
            // if mutated has the special form Any(expr,expr,...) then check if all sub-expressions change affected
            if (IsStaticMethod(mutated, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)mutated;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (!MutatingFirstAffectsSecond(context, arg, affected, mutatesWithinOnly, mutatedStatement, affectedStatement, boundsInMutated, boundsInAffected, offsets, extraIndices))
                        return false;
                }
                return (imie.Arguments.Count > 0);
            }
            // if affected has the special form Any(expr,expr,...) then check if mutated changes any sub-expressions
            if (IsStaticMethod(affected, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)affected;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (MutatingFirstAffectsSecond(context, mutated, arg, mutatesWithinOnly, mutatedStatement, affectedStatement, boundsInMutated, boundsInAffected, offsets, extraIndices))
                        return true;
                }
                return false;
            }
            if(affectedStatement != null && mutatedStatement != null)
            {
                Set<IVariableDeclaration> localVarsInMutated = new Set<IVariableDeclaration>();
                var bindingsInMutated = GetBindings(mutatedStatement, localVarsInMutated);
                var bindingsInAffected = GetBindings(affectedStatement, null);
                if (!MutatingFirstAffectsSecond(mutated, affected, bindingsInMutated, bindingsInAffected, localVarsInMutated.Contains))
                    return false;
            }
            // Algorithm:
            // Examine the prefixes of the two expressions from left to right.
            // If the innermost targets don't match, return false.
            // If the prefixes have non-overlapping array indices, return false.
            // If the prefixes are incomparable, e.g. property versus field, return !mutatesWithinOnly (to be conservative)
            // If mutatesWithinOnly=true, return false unless we are sure.
            // If mutatesWithinOnly=false, return true unless we are sure.
            List<IExpression> mutatedPrefixes = GetAllPrefixes(mutated);
            List<IExpression> affectedPrefixes = GetAllPrefixes(affected);
            if (!mutatedPrefixes[0].Equals(affectedPrefixes[0]))
                return false;
            if (mutatesWithinOnly && affectedPrefixes.Count > mutatedPrefixes.Count)
                return false;
            int count = System.Math.Min(mutatedPrefixes.Count, affectedPrefixes.Count);
            Set<IVariableDeclaration> matchedIndices = new Set<IVariableDeclaration>();
            for (int i = 1; i < count; i++)
            {
                bool lastBracket = (i == affectedPrefixes.Count - 1);
                IExpression mutatedPrefix = mutatedPrefixes[i];
                IExpression affectedPrefix = affectedPrefixes[i];
                if (mutatedPrefix is IArrayIndexerExpression mutated_iaie)
                {
                    if (affectedPrefix is IArrayIndexerExpression affected_iaie)
                    {
                        try
                        {
                            if (!IndicesOverlap(mutated_iaie.Indices, affected_iaie.Indices, mutatesWithinOnly && lastBracket, boundsInMutated, boundsInAffected, offsets, extraIndices, matchedIndices))
                                return false;
                        }
                        catch (Exception ex)
                        {
                            throw new Exception($"Exception while comparing expressions '{mutated}' and '{affected}': {ex.Message}", ex);
                        }
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IPropertyIndexerExpression mutated_ipie)
                {
                    if (affectedPrefix is IPropertyIndexerExpression affected_ipie)
                    {
                        if (!IndicesOverlap(mutated_ipie.Indices, affected_ipie.Indices, mutatesWithinOnly && lastBracket, boundsInMutated, boundsInAffected, offsets, extraIndices, matchedIndices))
                            return false;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IPropertyReferenceExpression mutated_ipre)
                {
                    if (affectedPrefix is IPropertyReferenceExpression affected_ipre)
                    {
                        if (!mutated_ipre.Property.Equals(affected_ipre.Property))
                            return !mutatesWithinOnly;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IFieldReferenceExpression mutated_ifre)
                {
                    if (affectedPrefix is IFieldReferenceExpression affected_ifre)
                    {
                        if (!mutated_ifre.Field.Equals(affected_ifre.Field))
                            return !mutatesWithinOnly;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else
                    throw new Exception("Unhandled expression type: " + mutatedPrefix);
            }
            if (extraIndices != null && mutatedPrefixes.Count > count)
            {
                // add extra indices in mutated to extraIndices
                // if mutated = array[i][j] and affected = array[i] then j is extra index
                // but if mutated = array[i][i] and affected = array[i] then i is not an extra index
                Containers containers = Containers.GetContainersNeededForExpression(context, affected);
                Set<IVariableDeclaration> loopVars = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
                foreach (IStatement container in containers.inputs)
                {
                    if (container is IForStatement ifs)
                    {
                        loopVars.Add(LoopVariable(ifs));
                    }
                }
                for (int i = count; i < mutatedPrefixes.Count; i++)
                {
                    IExpression mutatedPrefix = mutatedPrefixes[i];
                    if (mutatedPrefix is IArrayIndexerExpression mutated_iaie)
                    {
                        foreach (IExpression index in mutated_iaie.Indices)
                        {
                            foreach (var v in GetVariables(index))
                            {
                                if (!loopVars.Contains(v))
                                    extraIndices.Add(v);
                            }
                        }
                    }
                }
            }
            return true;
        }

        internal bool MutatingFirstAffectsSecond(
            IExpression mutated,
            IExpression affected,
            IReadOnlyCollection<ConditionBinding> bindingsInMutated,
            IReadOnlyCollection<ConditionBinding> bindingsInAffected,
            Func<IVariableDeclaration,bool> isLocalVarInMutated)
        {
            // if mutated has the special form Any(expr,expr,...) then check if all sub-expressions change affected
            if (IsStaticMethod(mutated, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)mutated;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (!MutatingFirstAffectsSecond(arg, affected, bindingsInMutated, bindingsInAffected, isLocalVarInMutated))
                        return false;
                }
                return (imie.Arguments.Count > 0);
            }
            // if affected has the special form Any(expr,expr,...) then check if mutated changes any sub-expressions
            if (IsStaticMethod(affected, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)affected;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (MutatingFirstAffectsSecond(mutated, arg, bindingsInMutated, bindingsInAffected, isLocalVarInMutated))
                        return true;
                }
                return false;
            }

            return !AreDisjoint(mutated, bindingsInMutated, affected, bindingsInAffected, isLocalVarInMutated);
        }

        /// <summary>
        /// Augment the bindings with the minimal conditions necessary for the two expressions to overlap
        /// </summary>
        /// <param name="e1"></param>
        /// <param name="e2"></param>
        /// <param name="bindings1">Bindings for e1</param>
        /// <param name="bindings2">Bindings for e2</param>
        /// <returns>True if overlap conditions could be found, false if the expressions cannot overlap</returns>
        internal bool AddIndexBindings(IExpression e1, IExpression e2, ICollection<ConditionBinding> bindings1, ICollection<ConditionBinding> bindings2)
        {
            int tempCount = 0;
            List<IExpression> prefixes1 = GetAllPrefixes(e1);
            List<IExpression> prefixes2 = GetAllPrefixes(e2);
            if (!prefixes1[0].Equals(prefixes2[0]))
                return false;
            int count = System.Math.Min(prefixes1.Count, prefixes2.Count);
            for (int i = 1; i < count; i++)
            {
                IExpression prefix1 = prefixes1[i];
                IExpression prefix2 = prefixes2[i];
                if (prefix1 is IArrayIndexerExpression iaie1)
                {
                    if (prefix2 is IArrayIndexerExpression iaie2)
                    {
                        if (iaie1.Indices.Count != iaie2.Indices.Count)
                            break;
                        for (int j = 0; j < iaie1.Indices.Count; j++)
                        {
                            IExpression index1 = iaie1.Indices[j];
                            IExpression index2 = iaie2.Indices[j];
                            if (index1 is ILiteralExpression && index2 is ILiteralExpression)
                            {
                                if (!index1.Equals(index2))
                                    return false;
                            }
                            else
                            {
                                // add a condition for the indices to be equal
                                AddBinding(index1, index2, bindings1, bindings2, tempCount++);
                            }
                        }
                    }
                    else
                        break;
                }
                else if (prefix1 is IPropertyIndexerExpression ipie1)
                {
                    if (prefix2 is IPropertyIndexerExpression ipie2)
                    {
                        if (ipie1.Indices.Count != ipie2.Indices.Count)
                            break;
                        for (int j = 0; j < ipie1.Indices.Count; j++)
                        {
                            IExpression index1 = ipie1.Indices[j];
                            IExpression index2 = ipie2.Indices[j];
                            if (index1 is ILiteralExpression && index2 is ILiteralExpression)
                            {
                                if (!index1.Equals(index2))
                                    return false;
                            }
                            else
                            {
                                // add a condition for the indices to be equal
                                AddBinding(index1, index2, bindings1, bindings2, tempCount++);
                            }
                        }
                    }
                    else
                        break;
                }
                else if (prefix1 is IPropertyReferenceExpression ipre1)
                {
                    if (prefix2 is IPropertyReferenceExpression ipre2)
                    {
                        // we assume that mutating one property does not affect another.
                        if (!ipre1.Property.Equals(ipre2.Property))
                            break;
                    }
                    else
                        break;
                }
                else if (prefix1 is IFieldReferenceExpression ifre1)
                {
                    if (prefix2 is IFieldReferenceExpression ifre2)
                    {
                        if (!ifre1.Field.Equals(ifre2.Field))
                            break;
                    }
                    else
                        break;
                }
                else
                    throw new Exception("Unhandled expression type: " + prefix1);
            }
            return true;
        }

        /// <summary>
        /// Augment both bindings to ensure that (index1 == index2)
        /// </summary>
        /// <param name="index1"></param>
        /// <param name="index2"></param>
        /// <param name="bindings1"></param>
        /// <param name="bindings2"></param>
        /// <param name="tempCount">A counter for numbering temporary variables</param>
        private static void AddBinding(IExpression index1, IExpression index2, ICollection<ConditionBinding> bindings1, ICollection<ConditionBinding> bindings2,
                                       int tempCount)
        {
            if (index1 is ILiteralExpression)
            {
                bindings2.Add(new ConditionBinding(index2, index1));
            }
            else if (index2 is ILiteralExpression)
            {
                bindings1.Add(new ConditionBinding(index1, index2));
            }
            else
            {
                Type exprType = index1.GetExpressionType();
                IVariableDeclaration tempVar = Builder.VarDecl("_t" + tempCount, exprType);
                IExpression tempRef = Builder.VarRefExpr(tempVar);
                bindings1.Add(new ConditionBinding(index1, tempRef));
                bindings2.Add(new ConditionBinding(tempRef, index2));
            }
        }

        /// <summary>
        /// Returns true if the expressions access distinct array elements or have disjoint condition contexts
        /// </summary>
        /// <param name="expr1"></param>
        /// <param name="ebBinding"></param>
        /// <param name="expr2"></param>
        /// <param name="eb2Binding"></param>
        /// <param name="isLoopVar"></param>
        /// <returns></returns>
        internal bool AreDisjoint(
            IExpression expr1,
            IReadOnlyCollection<ConditionBinding> ebBinding,
            IExpression expr2,
            IReadOnlyCollection<ConditionBinding> eb2Binding,
            Func<IVariableDeclaration,bool> isLoopVar)
        {
            var bindings1 = new Set<ConditionBinding>();
            bindings1.AddRange(ebBinding);
            var bindings2 = new Set<ConditionBinding>();
            bindings2.AddRange(eb2Binding);
            // augment the two bindings to make the expressions overlap
            bool match = AddIndexBindings(expr1, expr2, bindings1, bindings2);
            if (!match)
                return true;
            // remove loop vars from bindings1 (see InferTests.ConstrainBetweenTest3)
            var bindings1Reduced = RemoveLoopVars(bindings1, isLoopVar);
            if (bindings1Reduced == null)
                return true;
            bindings2.AddRange(bindings1Reduced);
            // bindings2 is now the combined set of conditions.  If we find a contradiction, the uses are disjoint.
            var bindings2Reduced = FindContradiction(bindings2, expr => !(expr is ILiteralExpression));
            return (bindings2Reduced == null);
        }

        internal IReadOnlyCollection<ConditionBinding> RemoveLoopVars(IReadOnlyCollection<ConditionBinding> bindings, Func<IVariableDeclaration,bool> isLoopVar)
        {
            return FindContradiction(bindings, expr => ContainsLoopVars(expr, isLoopVar));
        }

        /// <summary>
        /// Find a contradiction in a set of conditions, i.e. prove there is no satisfying assignment
        /// </summary>
        /// <param name="bindings">A set of conditions.  Not modified.</param>
        /// <param name="predicate">Indicates the bindings to eliminate.  If null, all bindings are eliminated.</param>
        /// <returns>null if inconsistent, otherwise a reduced list of bindings where none satisfy the predicate</returns>
        internal IReadOnlyCollection<ConditionBinding> FindContradiction(IReadOnlyCollection<ConditionBinding> bindings, Predicate<IExpression> predicate = null)
        {
            while (bindings.Count > 0)
            {
                // find the binding with minimum depth
                ConditionBinding currentBinding = null;
                IExpression exprFind = null;
                IExpression exprReplace = null;
                int minDepth = int.MaxValue;
                foreach (ConditionBinding binding in bindings)
                {
                    if (!IsValid(binding))
                        return null;
                    bool containsLhs = (predicate == null) ? true : predicate(binding.lhs);
                    if (containsLhs)
                    {
                        int depthLhs = GetExpressionDepth(binding.lhs);
                        if (depthLhs < minDepth)
                        {
                            minDepth = depthLhs;
                            currentBinding = binding;
                            exprFind = binding.lhs;
                            exprReplace = binding.rhs;
                        }
                    }
                    bool containsRhs = (predicate == null) ? true : predicate(binding.rhs);
                    if (containsRhs)
                    {
                        int depthRhs = GetExpressionDepth(binding.rhs);
                        if (depthRhs < minDepth)
                        {
                            minDepth = depthRhs;
                            currentBinding = binding;
                            exprFind = binding.rhs;
                            exprReplace = binding.lhs;
                        }
                    }
                }
                if (currentBinding == null)
                    return bindings;
                // apply the binding
                var newBindings = new Set<ConditionBinding>();
                foreach (ConditionBinding binding in bindings)
                {
                    if (object.ReferenceEquals(binding, currentBinding))
                        continue;
                    // could skip cases where we know exprFind will not appear, e.g. exprs not satisfying the predicate
                    // or whose depth is too small.
                    IExpression newLhs = Builder.ReplaceExpression(binding.lhs, exprFind, exprReplace);
                    IExpression newRhs = Builder.ReplaceExpression(binding.rhs, exprFind, exprReplace);
                    newBindings.Add(new ConditionBinding(newLhs, newRhs));
                }
                bindings = newBindings;
            }
            return bindings;
        }

        private static int GetExpressionDepth(IExpression expr)
        {
            if (expr == null)
                return 0;
            else if (expr is IArrayIndexerExpression iaie)
            {
                int maxDepth = GetExpressionDepth(iaie.Target);
                foreach (IExpression index in iaie.Indices)
                {
                    int depth = GetExpressionDepth(index);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IMethodReferenceExpression imre)
            {
                return GetExpressionDepth(imre.Target);
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                int maxDepth = GetExpressionDepth(imie.Method);
                foreach (IExpression arg in imie.Arguments)
                {
                    int depth = GetExpressionDepth(arg);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IBinaryExpression ibe)
            {
                return 1 + System.Math.Max(GetExpressionDepth(ibe.Left), GetExpressionDepth(ibe.Right));
            }
            else if (expr is IUnaryExpression iue)
            {
                return 1 + GetExpressionDepth(iue.Expression);
            }
            else if (expr is IPropertyReferenceExpression ipre)
            {
                return 1 + GetExpressionDepth(ipre.Target);
            }
            else if (expr is IPropertyIndexerExpression ipie)
            {
                int maxDepth = GetExpressionDepth(ipie.Target);
                foreach (IExpression index in ipie.Indices)
                {
                    int depth = GetExpressionDepth(index);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IObjectCreateExpression ioce)
            {
                int maxDepth = GetExpressionDepth(ioce.Initializer);
                foreach (IExpression arg in ioce.Arguments)
                {
                    int depth = GetExpressionDepth(arg);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IAssignExpression iae)
            {
                return 1 + System.Math.Max(GetExpressionDepth(iae.Target), GetExpressionDepth(iae.Expression));
            }
            else if (expr is IVariableReferenceExpression || expr is ILiteralExpression || expr is IArgumentReferenceExpression || expr is ITypeReferenceExpression
                || expr is IVariableDeclarationExpression || expr is IArrayCreateExpression)
            {
                return 1;
            }
            else
                throw new NotImplementedException();
        }

        private bool ContainsLoopVars(IExpression expr, Func<IVariableDeclaration,bool> isLoopVar)
        {
            return GetVariables(expr).Any(isLoopVar);
        }

        private bool IsValid(ConditionBinding binding)
        {
            object value;
            if (TryEvaluate<object>(binding.GetExpression(), null, out value))
                return (bool)value;
            else
                return true;
        }

        private IEnumerable<IExpression> GetSummands(IExpression expr)
        {
            if (expr is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.Add)
                {
                    foreach (var summand in GetSummands(ibe.Left))
                        yield return summand;
                    foreach (var summand in GetSummands(ibe.Right))
                        yield return summand;
                }
                else if (ibe.Operator == BinaryOperator.Subtract)
                {
                    foreach (var summand in GetSummands(ibe.Left))
                        yield return summand;
                    foreach (var summand in GetSummands(ibe.Right))
                        yield return Negate(summand);
                }
                else
                    yield return expr;
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                if (IsStaticMethod(imie, new Func<int, int, int>(ML.Probabilistic.Factors.Factor.Plus)))
                {
                    foreach (var arg in imie.Arguments)
                    {
                        foreach (var summand in GetSummands(arg))
                            yield return summand;
                    }
                }
                else if (IsStaticMethod(imie, new Func<int, int, int>(ML.Probabilistic.Factors.Factor.Difference)))
                {
                    foreach (var summand in GetSummands(imie.Arguments[0]))
                        yield return summand;
                    foreach (var summand in GetSummands(imie.Arguments[1]))
                        yield return Negate(summand);
                }
                else
                    yield return expr;
            }
            else
                yield return expr;
        }

        private IExpression Negate(IExpression expr)
        {
            if (expr is IMethodInvokeExpression imie)
            {
                if (IsStaticMethod(imie, new Func<int, int>(ML.Probabilistic.Factors.Factor.Negate)))
                {
                    return imie.Arguments[0];
                }
            }
            if (expr is IUnaryExpression iue)
            {
                if (iue.Operator == UnaryOperator.Negate)
                {
                    return iue.Expression;
                }
            }
            bool useOperator = true;
            if (useOperator)
                return Builder.UnaryExpr(UnaryOperator.Negate, expr);
            else
                return Builder.StaticMethod(new Func<int, int>(ML.Probabilistic.Factors.Factor.Negate), expr);
        }

        public bool TryEvaluate<T>(IExpression expr, IDictionary<IVariableDeclaration, T> bindings, out T value)
        {
            if (expr is IVariableReferenceExpression && bindings != null)
            {
                IVariableDeclaration ivd = GetVariableDeclaration(expr);
                return bindings.TryGetValue(ivd, out value);
            }
            else if (expr is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.ValueInequality ||
                    ibe.Operator == BinaryOperator.IdentityInequality ||
                    ibe.Operator == BinaryOperator.GreaterThan ||
                    ibe.Operator == BinaryOperator.LessThan)
                {
                    if (ibe.Left.Equals(ibe.Right))
                    {
                        value = (T)(object)false;
                        return true;
                    }
                }
                else if (ibe.Operator == BinaryOperator.IdentityEquality || ibe.Operator == BinaryOperator.ValueEquality)
                {
                    if (ibe.Left.Equals(ibe.Right))
                    {
                        value = (T)(object)true;
                        return true;
                    }
                    if (ibe.Left.GetExpressionType().Equals(typeof(int)))
                    {
                        List<IExpression> summandsLeft = GetSummands(ibe.Left).ToList();
                        List<IExpression> summandsRight = new List<IExpression>();
                        bool foundMatch = false;
                        // Cancel identical expressions on both sides of the equality.
                        foreach (var summand in GetSummands(ibe.Right))
                        {
                            if (summandsLeft.Contains(summand))
                            {
                                foundMatch = true;
                                summandsLeft.Remove(summand);
                            }
                            else
                                summandsRight.Add(summand);
                        }
                        if (foundMatch)
                        {
                            if (summandsLeft.Count == 0)
                                summandsLeft.Add(Builder.LiteralExpr(0));
                            if (summandsRight.Count == 0)
                                summandsRight.Add(Builder.LiteralExpr(0));
                            if (summandsLeft.Count == 1 && summandsRight.Count == 1)
                            {
                                ibe = Builder.BinaryExpr(summandsLeft[0], ibe.Operator, summandsRight[0]);
                                // fall through
                            }
                        }
                    }
                }
                T left, right;
                if (TryEvaluate(ibe.Left, bindings, out left) && TryEvaluate(ibe.Right, bindings, out right))
                {
                    // must use runtime type here, not T
                    Type type = left.GetType();
                    value = (T)Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, ExpressionEvaluator.binaryOperatorNames[(int)ibe.Operator], left, right);
                    return true;
                }
            }
            else if (expr is IUnaryExpression iue)
            {
                T target;
                if (TryEvaluate(iue.Expression, bindings, out target))
                {
                    // must use runtime type here, not T
                    Type type = target.GetType();
                    value = (T)Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, ExpressionEvaluator.unaryOperatorNames[(int)iue.Operator], target);
                    return true;
                }
            }
            else if (expr is ILiteralExpression ile)
            {
                if (ile.Value is T)
                {
                    value = (T)ile.Value;
                    return true;
                }
            }
            value = default(T);
            return false;
        }

        /// <summary>
        /// Returns true if expr is on the left hand side of the innermost assignment statement in the context stack.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        public bool IsOnLHSOfAssignment(BasicTransformContext context, IExpression expr)
        {
            int assignIndex = context.FindAncestorIndex<IAssignExpression>();
            if (assignIndex == -1)
                return false;
            IAssignExpression iae = context.GetAncestor(assignIndex) as IAssignExpression;
            if (!(iae.Target == context.GetAncestor(assignIndex + 1)))
                return false;
            return IsPartOf(iae.Target, expr);
        }

        public int GetAncestorIndexOfLoopBeingInitialized(BasicTransformContext context)
        {
            int forIndex = context.FindAncestorIndex<IForStatement>();
            if (forIndex == -1)
                return -1;
            IForStatement forStmt = (IForStatement)context.GetAncestor(forIndex);
            if (context.InputStack.Count > forIndex + 1 && context.InputStack[forIndex + 1].inputElement.Equals(forStmt.Initializer))
            {
                return forIndex;
            }
            else
                return -1;
        }

        public bool IsBeingAllocated(BasicTransformContext context, IExpression expr)
        {
            if (IsOnLHSOfAssignment(context, expr))
            {
                IAssignExpression iae = context.FindAncestor<IAssignExpression>();
                if (iae.Expression is IArrayCreateExpression)
                    return true;
            }
            return false;
        }

        public bool IsTypeReferenceTo(ITypeReferenceExpression itre, Type type)
        {
            return itre.Type.DotNetType == type;
        }

        public bool IsLiteral(IExpression expr, object val)
        {
            if (expr is ILiteralExpression)
            {
                return ((ILiteralExpression)expr).Value.Equals(val);
            }
            return false;
        }

        public T GetLiteral<T>(IExpression expr)
        {
            if (expr is ILiteralExpression)
            {
                return (T)((ILiteralExpression)expr).Value;
            }
            return default(T);
        }

        public IVariableDeclaration LoopVariable(IForStatement ifs)
        {
            IStatement ist = ifs.Initializer;
            if (ist is IBlockStatement)
            {
                if (((IBlockStatement)ist).Statements.Count != 1)
                    throw new NotSupportedException("For statement has multi-statement initializer:" + ifs);
                ist = ((IBlockStatement)ist).Statements[0];
            }
            IExpressionStatement init = (IExpressionStatement)ist;
            IAssignExpression iae = (IAssignExpression)init.Expression;
            IVariableDeclaration ivd = GetVariableDeclaration(iae.Target);
            return ivd;
        }

        public IExpression LoopSizeExpression(IForStatement loop)
        {
            if (loop.Condition is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.LessThan)
                {
                    return ibe.Right;
                }
                else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                {
                    var start = LoopStartExpression(loop);
                    if (start is IBinaryExpression ibe2)
                    {
                        if (ibe2.Operator == BinaryOperator.Subtract)
                        {
                            return ibe2.Left;
                        }
                    }
                }
                throw new ArgumentException("Unrecognized loop syntax");
            }
            else
            {
                throw new ArgumentException("Loop condition is not a BinaryExpression");
            }
        }

        public IStatement LoopBreakStatement(IForStatement loop)
        {
            return Builder.AssignStmt(Builder.VarRefExpr(LoopVariable(loop)), LoopBreakExpression(loop));
        }

        private IExpression LoopBreakExpression(IForStatement loop)
        {
            if (loop.Condition is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.LessThan)
                    return Builder.BinaryExpr(BinaryOperator.Subtract, ibe.Right, Builder.LiteralExpr(1));
                else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                    return ibe.Right;
                else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                    return ibe.Right;
                else if (ibe.Operator == BinaryOperator.GreaterThan)
                    return Builder.BinaryExpr(BinaryOperator.Add, ibe.Right, Builder.LiteralExpr(1));
                else
                    throw new ArgumentException($"Unrecognized loop condition: {ibe}");
            }
            else
            {
                throw new ArgumentException("Loop condition is not a BinaryExpression");
            }
        }

        public IExpression LoopStartExpression(IForStatement loop)
        {
            if (loop.Initializer is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    return iae.Expression;
                }
            }
            throw new ArgumentException("Loop initializer is not an assignment");
        }

        public class Bounds
        {
            public int lowerBound = int.MinValue, upperBound = int.MaxValue;

            public bool Contains(int value)
            {
                return (value >= lowerBound) && (value <= upperBound);
            }

            public override string ToString()
            {
                return String.Format("[{0},{1}]", lowerBound, upperBound);
            }
        }

        public void AddLoopBounds(Dictionary<IVariableDeclaration, Bounds> bounds, IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                IVariableDeclaration loopVar = LoopVariable(ifs);
                Bounds b;
                if (!bounds.TryGetValue(loopVar, out b))
                {
                    b = new Bounds();
                    bounds[loopVar] = b;
                }
                IExpression start = LoopStartExpression(ifs);
                if (start is ILiteralExpression)
                {
                    int startValue = (int)((ILiteralExpression)start).Value;
                    b.lowerBound = System.Math.Max(b.lowerBound, startValue);
                }
                IExpression size = LoopSizeExpression(ifs);
                if (size is ILiteralExpression)
                {
                    int endValue = (int)((ILiteralExpression)size).Value - 1;
                    b.upperBound = System.Math.Min(b.upperBound, endValue);
                }
                if (ifs.Body.Statements.Count == 1)
                    AddLoopBounds(bounds, ifs.Body.Statements[0]);
            }
            else if (ist is IConditionStatement ics)
            {
                IExpression condition = ics.Condition;
                if (condition is IBinaryExpression ibe)
                {
                    if (ibe.Left is IVariableReferenceExpression)
                    {
                        IVariableDeclaration loopVar = GetVariableDeclaration(ibe.Left);
                        Bounds b;
                        if (!bounds.TryGetValue(loopVar, out b))
                        {
                            b = new Bounds();
                            bounds[loopVar] = b;
                        }
                        if (ibe.Left.GetExpressionType().Equals(typeof(int)) && ibe.Right is ILiteralExpression)
                        {
                            int value = (int)((ILiteralExpression)ibe.Right).Value;
                            if (ibe.Operator == BinaryOperator.GreaterThan)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value + 1);
                            }
                            else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThan)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value - 1);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueEquality)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueInequality)
                            {
                                if (b.lowerBound == value)
                                    b.lowerBound++;
                                if (b.upperBound == value)
                                    b.upperBound--;
                            }
                        }
                    }
                    if (ibe.Right is IVariableReferenceExpression)
                    {
                        IVariableDeclaration loopVar = GetVariableDeclaration(ibe.Right);
                        Bounds b;
                        if (!bounds.TryGetValue(loopVar, out b))
                        {
                            b = new Bounds();
                            bounds[loopVar] = b;
                        }
                        if (ibe.Right.GetExpressionType().Equals(typeof(int)) && ibe.Left is ILiteralExpression)
                        {
                            int value = (int)((ILiteralExpression)ibe.Left).Value;
                            if (ibe.Operator == BinaryOperator.GreaterThan)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value - 1);
                            }
                            else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThan)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value + 1);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueEquality)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueInequality)
                            {
                                if (b.lowerBound == value)
                                    b.lowerBound++;
                                if (b.upperBound == value)
                                    b.upperBound--;
                            }
                        }
                    }
                }
                if (ics.Then.Statements.Count == 1)
                    AddLoopBounds(bounds, ics.Then.Statements[0]);
            }
        }

        internal Set<ConditionBinding> GetBindings(IStatement stmt)
        {
            var bounds = new Dictionary<IVariableDeclaration, Bounds>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
            AddLoopBounds(bounds, stmt);
            var bindings = new Set<ConditionBinding>();
            foreach (var entry in bounds)
            {
                var b = entry.Value;
                if (b.lowerBound == b.upperBound)
                {
                    var binding = new ConditionBinding(Builder.VarRefExpr(entry.Key), Builder.LiteralExpr(b.lowerBound));
                    bindings.Add(binding);
                }
            }
            return bindings;
        }

        internal Set<ConditionBinding> GetBindings(IStatement ist, Set<IVariableDeclaration> localVars)
        {
            Set<ConditionBinding> bindings = new Set<ConditionBinding>();
            while (true)
            {
                if (ist is IForStatement ifs)
                {
                    IVariableDeclaration loopVar = LoopVariable(ifs);
                    if (localVars != null)
                        localVars.Add(loopVar);
                    IExpression start = LoopStartExpression(ifs);
                    if (IsForwardLoop(ifs))
                    {
                        bindings.Add(new ConditionBinding(Builder.BinaryExpr(Builder.VarRefExpr(loopVar), BinaryOperator.GreaterThanOrEqual, start)));
                    }
                    bindings.Add(new ConditionBinding(ifs.Condition));
                    if (ifs.Body.Statements.Count == 1)
                        ist = ifs.Body.Statements[0];
                    else
                        break;
                }
                else if (ist is IConditionStatement ics)
                {
                    bindings.Add(new ConditionBinding(ics.Condition));
                    if (ics.Then.Statements.Count == 1)
                        ist = ics.Then.Statements[0];
                    else
                        break;
                }
                else
                    break;
            }
            return bindings;
        }

        /// <summary>
        /// Returns true if any of the reference expressions refer to the specified index variable.
        /// </summary>
        /// <param name="refs"></param>
        /// <param name="indexVar"></param>
        /// <returns></returns>
        public bool IsIndexedBy(List<IVariableReferenceExpression> refs, IVariableDeclaration indexVar)
        {
            foreach (IArrayIndexerExpression iaie in refs)
            {
                foreach (IExpression indExpr in iaie.Indices)
                {
                    IVariableDeclaration ivd2 = ((IVariableReferenceExpression)indExpr).Variable.Resolve();
                    if (indexVar.Equals(ivd2))
                        return true;
                }
            }
            return false;
        }

        public IExpression StripIndexers(IExpression expr)
        {
            return StripIndexers(expr, false);
        }

        public IExpression StripIndexers(IExpression expr, bool varsOnly)
        {
            if (!(expr is IArrayIndexerExpression iaie))
                return expr;
            if ((!(iaie.Indices[0] is IVariableReferenceExpression)) && varsOnly)
                return expr;
            return StripIndexers(iaie.Target, varsOnly);
        }

        public IExpression StripFieldsAndProperties(IExpression expr)
        {
            if (expr is IPropertyReferenceExpression ipre)
                return ipre.Target;
            else if (expr is IFieldReferenceExpression ifre)
                return ifre.Target;
            else
                return expr;
        }

        public bool IsNewObject(IExpression expr, Type type)
        {
            if (!(expr is IObjectCreateExpression ioce))
                return false;
            Type t = Builder.ToType(ioce.Type);
            return t.Equals(type);
        }

        /// <summary>
        /// Returns true if the first expression is equal to, or a subarray or element of the second expression.
        /// For example, x, x[0], x[0][0] are all subarrays of x, but x[1] is not part of x[0].
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="arrayExpr"></param>
        /// <returns></returns>
        public bool IsPartOf(IExpression expr, IExpression arrayExpr)
        {
            while (true)
            {
                if (arrayExpr.Equals(expr))
                    return true;
                if (expr is IArrayIndexerExpression iaie)
                    expr = iaie.Target;
                else
                {
                    IExpression oldexpr = expr;
                    expr = StripFieldsAndProperties(expr);
                    if (object.ReferenceEquals(oldexpr, expr))
                        return false;
                }
            }
        }

        /// <summary>
        /// Extracts the declaration of the parameter reference from a, possibly indexed, argument reference expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IParameterDeclaration GetParameterDeclaration(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IArgumentReferenceExpression iare)
                return iare.Parameter.Resolve();
            else
                return null;
        }

        /// <summary>
        /// Extracts the field reference from a, possibly indexed, field reference expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IFieldReference GetFieldReference(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IFieldReferenceExpression ifre)
                return ifre.Field;
            else
                return null;
        }

        /// <summary>
        /// Extracts the variable declaration from a, possibly indexed, reference or declaration expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IVariableDeclaration GetVariableDeclaration(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IVariableReferenceExpression ivre)
                return ivre.Variable.Resolve();
            else if (expr is IVariableDeclarationExpression ivde)
                return ivde.Variable;
            else
                return null;
        }

        /// <summary>
        /// Extracts the variable or parameter declaration from a, possibly indexed, reference or declaration expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public object GetDeclaration(IExpression expr)
        {
            object decl = GetVariableDeclaration(expr);
            if (decl != null)
                return decl;
            decl = GetParameterDeclaration(expr);
            if (decl != null)
                return decl;
            return GetFieldReference(expr);
        }

        public object GetArrayDeclaration(IExpression expr)
        {
            expr = StripIndexers(expr);
            if (expr is IVariableReferenceExpression ivre)
                return ivre.Variable.Resolve();
            else if (expr is IVariableDeclarationExpression ivde)
                return ivde.Variable;
            else if (expr is IArgumentReferenceExpression iare)
                return iare.Parameter.Resolve();
            else if (expr is IFieldReferenceExpression ifre)
                return ifre.Field.Resolve();
            else if (expr is IPropertyReferenceExpression ipre)
                return ipre.Property.Resolve();
            else
                return null;
        }

        /// <summary>
        /// Get the innermost target of an expression, e.g. x[0].field[1].method(y) returns 'x'
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IExpression GetTarget(IExpression expr)
        {
            IExpression target = null;
            ForEachPrefix(expr, prefix =>
            {
                if (target == null) target = prefix;
            });
            return target;
        }

        /// <summary>
        /// Get a list of prefixes of the given expression, starting from the innermost target, up to and including the given expression.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public List<IExpression> GetAllPrefixes(IExpression expr)
        {
            List<IExpression> result = new List<IExpression>();
            ForEachPrefix(expr, result.Add);
            return result;
        }

        private void ForEachPrefix(IExpression expr, Action<IExpression> action)
        {
            // This method must be kept consistent with GetTargets.
            if (expr is IArrayIndexerExpression iaie)
                ForEachPrefix(iaie.Target, action);
            else if (expr is IAddressOutExpression iaoe)
                ForEachPrefix(iaoe.Expression, action);
            else if (expr is IPropertyReferenceExpression ipre)
                ForEachPrefix(ipre.Target, action);
            else if (expr is IFieldReferenceExpression ifre)
            {
                IExpression target = ifre.Target;
                if (!(target is IThisReferenceExpression))
                    ForEachPrefix(target, action);
            }
            else if (expr is ICastExpression ice)
                ForEachPrefix(ice.Expression, action);
            else if (expr is IPropertyIndexerExpression ipie)
                ForEachPrefix(ipie.Target, action);
            else if (expr is IEventReferenceExpression iere)
                ForEachPrefix(iere.Target, action);
            else if (expr is IUnaryExpression iue)
                ForEachPrefix(iue.Expression, action);
            else if (expr is IAddressReferenceExpression iare)
                ForEachPrefix(iare.Expression, action);
            else if (expr is IMethodInvokeExpression imie)
                ForEachPrefix(imie.Method, action);
            else if (expr is IMethodReferenceExpression imre)
                ForEachPrefix(imre.Target, action);
            else if (expr is IDelegateInvokeExpression idie)
                ForEachPrefix(idie.Target, action);
            action(expr);
        }

        /// <summary>
        /// Get all variable references in an expression.  The same variable may appear more than once.
        /// </summary>
        /// <param name="expr">Any expression</param>
        /// <returns></returns>
        public IEnumerable<IVariableDeclaration> GetVariables(IExpression expr)
        {
            foreach(var decl in GetVariablesAndParameters(expr))
            {
                if (decl is IVariableDeclaration ivd)
                    yield return ivd;
            }
        }

        /// <summary>
        /// Get all variable and parameter references in an expression.  The same variable may appear more than once.
        /// </summary>
        /// <param name="expr">Any expression</param>
        /// <returns></returns>
        public IEnumerable<object> GetVariablesAndParameters(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in iaie.Indices)
                {
                    foreach (var decl in GetVariablesAndParameters(index))
                    {
                        yield return decl;
                    }
                }
                foreach (var decl in GetVariablesAndParameters(iaie.Target))
                    yield return decl;
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                foreach (IExpression arg in imie.Arguments)
                {
                    foreach (var decl in GetVariablesAndParameters(arg))
                        yield return decl;
                }
            }
            else if (expr is IBinaryExpression ibe)
            {
                foreach (var decl in GetVariablesAndParameters(ibe.Left))
                    yield return decl;
                foreach (var decl in GetVariablesAndParameters(ibe.Right))
                    yield return decl;
            }
            else if (expr is IUnaryExpression iue)
            {
                foreach (var decl in GetVariablesAndParameters(iue.Expression))
                    yield return decl;
            }
            else if (expr is IPropertyIndexerExpression ipie)
            {
                foreach (IExpression index in ipie.Indices)
                    foreach (var decl in GetVariablesAndParameters(index))
                        yield return decl;
                foreach (var decl in GetVariablesAndParameters(ipie.Target))
                    yield return decl;
            }
            else if (expr is IObjectCreateExpression ioce)
            {
                foreach (IExpression arg in ioce.Arguments)
                    foreach (var decl in GetVariablesAndParameters(arg))
                        yield return decl;
            }
            else if (expr is IAssignExpression iae)
            {
                foreach (var decl in GetVariablesAndParameters(iae.Expression))
                    yield return decl;
                foreach (var decl in GetVariablesAndParameters(iae.Target))
                    yield return decl;
            }
            else
            {
                object decl = GetDeclaration(expr);
                if (decl != null)
                    yield return decl;
            }
        }

        public IEnumerable<IArgumentReferenceExpression> GetArgumentReferenceExpressions(IExpression expr)
        {
            if (expr is IArgumentReferenceExpression are)
                yield return are;
            else if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in iaie.Indices)
                    foreach (var iare in GetArgumentReferenceExpressions(index))
                        yield return iare;
                foreach (var iare in GetArgumentReferenceExpressions(iaie.Target))
                    yield return iare;
            }
            else if (expr is IUnaryExpression iue)
            {
                foreach (var iare in GetArgumentReferenceExpressions(iue.Expression))
                    yield return iare;
            }
            else if (expr is IBinaryExpression ibe)
            {
                foreach (var iare in GetArgumentReferenceExpressions(ibe.Left))
                    yield return iare;
                foreach (var iare in GetArgumentReferenceExpressions(ibe.Right))
                    yield return iare;
            }
        }

        public IEnumerable<IExpression> GetConditionAndTargetIndexExpressions(IStatement stmt)
        {
            if (stmt is IConditionStatement ics)
            {
                yield return ics.Condition;
                foreach (var expr in GetConditionAndTargetIndexExpressions(ics.Then))
                    yield return expr;
            }
            else if (stmt is IForStatement ifs)
            {
                foreach (var expr in GetConditionAndTargetIndexExpressions(ifs.Body))
                    yield return expr;
            }
            else if (stmt is IBlockStatement ibs)
            {
                foreach (IStatement ist in ibs.Statements)
                {
                    foreach (var expr in GetConditionAndTargetIndexExpressions(ist))
                        yield return expr;
                }
            }
            else if (stmt is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    // target indices are considered "conditions" for this purpose
                    foreach (var index in GetFlattenedIndices(iae.Target))
                        yield return index;
                }
            }
        }

        /// <summary>
        /// Get every expression on the lhs of an assignment.
        /// </summary>
        /// <param name="ist"></param>
        public IEnumerable<IExpression> GetTargets(IStatement ist)
        {
            if (ist is IExpressionStatement ies)
            {
                IExpression expr = ies.Expression;
                if (expr is IAssignExpression)
                {
                    IAssignExpression iae = (IAssignExpression)ies.Expression;
                    yield return iae.Target;
                }
                else if (expr is IVariableDeclarationExpression)
                {
                    yield return expr;
                }
            }
            else if (ist is IConditionStatement ics)
            {
                foreach (IStatement st in ics.Then.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
            else if (ist is IForStatement ifs)
            {
                foreach (IStatement st in ifs.Body.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
            else if (ist is IWhileStatement iws)
            {
                foreach (IStatement st in iws.Body.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
        }

        /// <summary>
        /// Apply action to every variable on the lhs of an assignment.
        /// </summary>
        /// <param name="ist"></param>
        public IEnumerable<IVariableDeclaration> GetTargetVariables(IStatement ist)
        {
            foreach (IExpression target in GetTargets(ist))
            {
                IVariableDeclaration ivd = GetVariableDeclaration(target);
                if (ivd != null)
                    yield return ivd;
            }
        }

        /// <summary>
        /// Extracts the variable declaration from a declaration statement.
        /// Returns null if the statement is not a declaration statement.
        /// </summary>
        /// <param name="ist"></param>
        /// <returns></returns>
        public IVariableDeclaration GetVariableDeclaration(IStatement ist)
        {
            if (ist is IExpressionStatement ies)
            {
                if (ies.Expression is IVariableDeclarationExpression ivde)
                    return ivde.Variable;
                else if (ies.Expression is IAssignExpression iae)
                {
                    if (iae.Target is IVariableDeclarationExpression ivde2)
                        return ivde2.Variable;
                }
            }
            return null;
        }

        /// <summary>
        /// Returns the number of indexing brackets at the end of expr (zero if none)
        /// </summary>
        /// <param name="iexpr"></param>
        /// <returns></returns>
        public int GetIndexingDepth(IExpression iexpr)
        {
            if (iexpr is IArrayIndexerExpression iaie)
                return 1 + GetIndexingDepth(iaie.Target);
            else
                return 0;
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 429
#endif

        /// <summary>
        /// Add the declarations of all loop variables in expr to indVars.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="indVars"></param>
        /// <param name="expr"></param>
        public void AddIndexers(BasicTransformContext context, List<IVariableDeclaration[]> indVars, IExpression expr)
        {
            if (expr is IVariableReferenceExpression)
                return;
            if (expr is IVariableDeclarationExpression)
                return;
            if (expr is IArgumentReferenceExpression)
                return;
            if (expr is IArrayIndexerExpression iaie)
            {
                IVariableDeclaration[] vars = new IVariableDeclaration[iaie.Indices.Count];
                for (int i = 0; i < vars.Length; i++)
                {
                    IVariableDeclaration ivd = GetVariableDeclaration(iaie.Indices[i]);
                    if (ivd != null && GetLoopForVariable(context, ivd) != null)
                        vars[i] = ivd;
                }
                AddIndexers(context, indVars, iaie.Target);
                indVars.Add(vars);
                return;
            }
            throw new NotImplementedException("Unsupported expression type in AddIndexers(): " + expr.GetType());
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 429
#endif

        private IEnumerable<IExpression> GetFlattenedIndices(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in GetFlattenedIndices(iaie.Target))
                    yield return index;
                foreach (IExpression index in iaie.Indices)
                    yield return index;
            }
        }

        /// <summary>
        /// Get a list of all index expressions at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
        public List<IList<IExpression>> GetIndices(IExpression expr)
        {
            IExpression target;
            return GetIndices(expr, out target);
        }

        /// <summary>
        /// Get a list of all index expressions at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="target">On exit, the innermost expression being indexed, i.e. the array variable</param>
        /// <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
        public List<IList<IExpression>> GetIndices(IExpression expr, out IExpression target)
        {
            List<IList<IExpression>> indices = new List<IList<IExpression>>();
            target = ForEachIndexingBracket(expr, indices.Add);
            return indices;
        }

        /// <summary>
        /// Apply action to all indexing brackets at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr">The expression</param>
        /// <param name="action"></param>
        /// <returns>The innermost expression</returns>
        private IExpression ForEachIndexingBracket(IExpression expr, Action<IList<IExpression>> action)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                var target = ForEachIndexingBracket(iaie.Target, action);
                action(iaie.Indices);
                return target;
            }
            else
                return expr;
        }

        /// <summary>
        /// Remove the last index from an expression
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IExpression RemoveLastIndex(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                if (iaie.Target is IArrayIndexerExpression)
                {
                    IArrayIndexerExpression aie = Builder.ArrayIndxrExpr();
                    aie.Indices.AddRange(iaie.Indices);
                    aie.Target = RemoveLastIndex(iaie.Target);
                    return aie;
                }
                else return iaie.Target;
            }
            else
            {
                return expr;
            }
        }

        /// <summary>
        /// Returns the for statement associated with the specified loop counter or null if none
        /// </summary>
        /// <param name="context"></param>
        /// <param name="loopRef"></param>
        /// <returns></returns>
        internal IForStatement GetLoopForVariable(BasicTransformContext context, IVariableReferenceExpression loopRef)
        {
            return GetLoopForVariable(context, GetVariableDeclaration(loopRef));
        }

        internal IForStatement GetLoopForVariable(BasicTransformContext context, IVariableDeclaration ivd, object excludeAncestor = null)
        {
            foreach (TransformInfo ti in context.InputStack)
            {
                if (ti.inputElement == excludeAncestor)
                    break;
                if (ti.inputElement is IForStatement loop)
                {
                    IVariableDeclaration loopVd = LoopVariable(loop);
                    if (ivd.Name == loopVd.Name)
                        return loop;
                }
            }
            return null;
        }

        public bool IsForwardLoop(IForStatement ifs)
        {
            if (ifs.Increment is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    if (ChannelTransform.RemoveCast(iae.Expression) is IBinaryExpression ibe)
                    {
                        if (ibe.Operator == BinaryOperator.Add)
                        {
                            if (ibe.Right is ILiteralExpression ile)
                            {
                                if (ile.Value is int)
                                    return ((int)ile.Value >= 0);
                            }
                        }
                        else if (ibe.Operator == BinaryOperator.Subtract)
                        {
                            if (ibe.Right is ILiteralExpression ile)
                            {
                                if (ile.Value is int)
                                    return ((int)ile.Value < 0);
                            }
                        }
                    }
                }
                else if (ies.Expression is IUnaryExpression iue)
                {
                    return (iue.Operator == UnaryOperator.PostIncrement) || (iue.Operator == UnaryOperator.PreIncrement);
                }
            }
            throw new Exception("Unexpected loop increment");
        }


        // Convert a for loop of the form:
        //    for (int i = 0; i < N; i++) { ... }
        // to
        //    for (int i = N - 1; i >= 0; i--) { ... }
        // and vice versa.
        public void ReverseLoopDirection(IForStatement loop)
        {
            // For now, make strong assumption that the for loop is of standard form:
            //   for (<var> = <literal>; <var> <comp> <literal>; <var> <increment/decrement>)
            if (!(loop.Condition is IBinaryExpression))
                throw new ArgumentException("Loop condition is not a binary expression: " + loop.Condition);
            IBinaryExpression condition = (IBinaryExpression)loop.Condition;
            IExpressionStatement increment = (IExpressionStatement)loop.Increment;
            if (!(increment.Expression is IUnaryExpression))
            {
                throw new ArgumentException("Cannot reverse a for loop with increment: " + increment);
            }
            IUnaryExpression incrementExpr = (IUnaryExpression)increment.Expression;
            UnaryOperator unaryOp;
            if (incrementExpr.Operator == UnaryOperator.PostIncrement || incrementExpr.Operator == UnaryOperator.PreIncrement)
                unaryOp = UnaryOperator.PostDecrement;
            else if (incrementExpr.Operator == UnaryOperator.PostDecrement || incrementExpr.Operator == UnaryOperator.PreDecrement)
                unaryOp = UnaryOperator.PostIncrement;
            else
            {
                throw new ArgumentException("Cannot reverse a for loop with increment operator " + incrementExpr.Operator.ToString());
            }
            loop.Increment = Builder.ExprStatement(Builder.UnaryExpr(unaryOp, incrementExpr.Expression));
            if (!condition.Left.Equals(incrementExpr.Expression))
                throw new ArgumentException("Loop condition does not have loop variable on the left");
            IExpressionStatement initializer = (IExpressionStatement)loop.Initializer;
            IAssignExpression initAssignExpr = (IAssignExpression)initializer.Expression;
            IExpression initializationExpression = initAssignExpr.Expression;

            if (condition.Operator == BinaryOperator.LessThan)
            {
                // Construct a new binary expression that takes the old condition RHS and subtracts one.
                // This becomes the new initializer.
                IBinaryExpression newInitializationExpression = Builder.BinaryExpr(condition.Right, BinaryOperator.Subtract, Builder.LiteralExpr(1));
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, newInitializationExpression);
            }
            else if (condition.Operator == BinaryOperator.LessThanOrEqual ||
                condition.Operator == BinaryOperator.GreaterThanOrEqual)
            {
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, condition.Right);
            }
            else if (condition.Operator == BinaryOperator.GreaterThan)
            {
                IBinaryExpression newInitializationExpression = Builder.BinaryExpr(condition.Right, BinaryOperator.Add, Builder.LiteralExpr(1));
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, newInitializationExpression);
            }
            else
            {
                throw new ArgumentException("Loop condition is not reversible: " + condition);
            }
            if (condition.Operator == BinaryOperator.LessThan ||
                condition.Operator == BinaryOperator.LessThanOrEqual)
            {
                loop.Condition = Builder.BinaryExpr(condition.Left, BinaryOperator.GreaterThanOrEqual, initializationExpression);
            }
            else
            {
                IBinaryExpression ibe = (IBinaryExpression)initializationExpression;
                if (ibe.Operator != BinaryOperator.Subtract ||
                   !ibe.Right.Equals(Builder.LiteralExpr(1)))
                    throw new ArgumentException("Initializer expression is not a subtraction: " + initializationExpression);
                loop.Condition = Builder.BinaryExpr(condition.Left, BinaryOperator.LessThan, ibe.Left);
            }
        }

        /// <summary>
        /// Returns the number of nested for loops in the deepest part of the statement.
        /// </summary>
        /// <param name="ist"></param>
        /// <returns></returns>
        public int ForLoopDepth(IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                return 1 + ForLoopDepth(ifs.Body);
            }
            else if (ist is IBlockStatement ibs)
            {
                int maxLoopDepth = 0;
                foreach (var st in ibs.Statements)
                {
                    int stDepth = ForLoopDepth(st);
                    if (stDepth > maxLoopDepth)
                    {
                        maxLoopDepth = stDepth;
                    }
                }
                return maxLoopDepth;
            }
            else if (ist is IConditionStatement ics)
            {
                return ForLoopDepth(ics.Then);
            }
            else
            {
                return 0;
            }
        }


        public IExpressionStatement FirstExpressionStatement(IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                foreach (var st in ifs.Body.Statements)
                {
                    if (!(st is ICommentStatement))
                    {
                        return FirstExpressionStatement(st);
                    }
                }
            }
            else if (ist is IConditionStatement ics)
            {
                foreach (var st in ics.Then.Statements)
                {
                    if (!(st is ICommentStatement))
                    {
                        return FirstExpressionStatement(st);
                    }
                }
            }
            else if (ist is IExpressionStatement ies)
            {
                return ies;
            }
            return null;
            //throw new Exception("Didn't find expression statement");
        }

        // Convert < to >=, <= to >, == to !=, etc.
        public bool TryNegateOperator(BinaryOperator op, out BinaryOperator negatedOp)
        {
            BinaryOperator[,] pairs = new BinaryOperator[,] {
            { BinaryOperator.LessThanOrEqual, BinaryOperator.GreaterThan },
            { BinaryOperator.GreaterThanOrEqual, BinaryOperator.LessThan },
            { BinaryOperator.ValueEquality, BinaryOperator.ValueInequality },
            { BinaryOperator.IdentityEquality, BinaryOperator.IdentityInequality }
        };

            for (int i = 0; i < pairs.GetLength(0); i++)
            {
                if (op == pairs[i, 0])
                {
                    negatedOp = pairs[i, 1];
                    return true;
                }
                else if (op == pairs[i, 1])
                {
                    negatedOp = pairs[i, 0];
                    return true;
                }
            }
            negatedOp = default(BinaryOperator);
            return false;
        }

        /// <summary>
        /// Returns true if any of the expression are stochastic.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="iec"></param>
        /// <returns></returns>
        internal static bool IsAnyStochastic(BasicTransformContext context, IList<IExpression> iec)
        {
            foreach (IExpression expr in iec) if (IsStochastic(context, expr)) return true;
            return false;
        }

        /// <summary>
        /// Returns true if the expression is stochastic.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        internal static bool IsStochastic(BasicTransformContext context, IExpression expr)
        {
            if (expr is ILiteralExpression) return false;
            if (expr is IDefaultExpression) return false;
            if (expr is IMethodInvokeExpression imie)
            {
                bool stochArgs = IsAnyStochastic(context, imie.Arguments);
                bool stochFactor = false;
                FactorManager.FactorInfo info = GetFactorInfo(context, imie);
                if (info != null) stochFactor = !info.IsDeterministicFactor;
                bool st = stochArgs || stochFactor;
                //if (st) context.OutputAttributes.Set(imie, new Stochastic()); // for IfCuttingTransform
                return st;
            }
            if (expr is IArgumentReferenceExpression) return false;
            if (expr is IPropertyReferenceExpression ipre) return IsStochastic(context, ipre.Target);
            if (expr is IFieldReferenceExpression ifre) return IsStochastic(context, ifre.Target);
            if (expr is IArrayCreateExpression) return false;
            if (expr is IObjectCreateExpression ioce)
            {
                return IsAnyStochastic(context, ioce.Arguments);
            }
            if (expr is IUnaryExpression iue)
            {
                return IsStochastic(context, iue.Expression);
            }
            if (expr is IBinaryExpression ibe)
            {
                return IsStochastic(context, ibe.Left) || IsStochastic(context, ibe.Right);
            }
            if (expr is IArrayIndexerExpression iaie)
            {
                return IsStochastic(context, iaie.Target) || IsAnyStochastic(context, iaie.Indices);
            }
            if (expr is ICastExpression) return IsStochastic(context, ((ICastExpression)expr).Expression);
            if (expr is ICheckedExpression) return IsStochastic(context, ((ICheckedExpression)expr).Expression);
            if (expr is IPropertyIndexerExpression ipie)
            {
                return IsStochastic(context, ipie.Target) || IsAnyStochastic(context, ipie.Indices);
            }
            if (expr is IAddressDereferenceExpression) return false;
            if (expr is IAddressOutExpression iaoe) return IsStochastic(context, iaoe.Expression);
            if (expr is ILambdaExpression) return false; // todo: stochastic case?
            if (expr is IAnonymousMethodExpression) return false;
            if (expr is ITypeOfExpression) return false;

            IVariableDeclaration ivd = Instance.GetVariableDeclaration(expr);
            if (ivd == null)
            {
                context.Error("Could not find stochasticity of expression of type " + expr.GetType().Name + ": " + expr);
                return false;
            }
            return IsStochastic(context, ivd);
        }

        internal static bool IsStochastic(BasicTransformContext context, IVariableDeclaration ivd)
        {
            VariableInformation vi = VariableInformation.GetVariableInformation(context, ivd);
            return vi.IsStochastic;
        }

        internal static bool IsInfer(IExpression expr)
        {
            return Instance.IsStaticMethod(expr, new Action<object>(InferNet.Infer)) ||
                   Instance.IsStaticMethod(expr, new Action<object, string>(InferNet.Infer)) ||
                   Instance.IsStaticMethod(expr, new Action<object, string, QueryType>(InferNet.Infer));
        }

        internal static bool IsIsIncreasing(IExpression expr)
        {
            return Instance.IsStaticMethod(expr, new Func<int,bool>(InferNet.IsIncreasing));
        }

        internal static FactorManager.FactorInfo GetFactorInfo(BasicTransformContext context, IMethodInvokeExpression imie)
        {
            if (!context.InputAttributes.Has<FactorManager.FactorInfo>(imie))
            {
                if (Instance.IsStaticMethod(imie, typeof(InferNet))) return null;
                MethodInfo methodInfo = (MethodInfo)Builder.ToMethodThrows(imie.Method.Method);
                if (methodInfo == null) return null;
                FactorManager.FactorInfo info = FactorManager.GetFactorInfo(methodInfo);
                context.InputAttributes.Set(imie, info);
            }
            return context.InputAttributes.Get<FactorManager.FactorInfo>(imie);
        }

        /// <summary>
        /// Removes a cast when it is safe to do so.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        internal static IExpression RemoveCast(IExpression expr)
        {
            // used to remove spurious casts
            if (expr is ICastExpression ice)
            {
                if (expr.GetExpressionType().IsAssignableFrom(ice.Expression.GetExpressionType()))
                {
                    return ice.Expression;
                }
            }
            return expr;
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.ML.Probabilistic.Compiler.Attributes;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.Transforms;
using System.Linq;
using Microsoft.ML.Probabilistic.Factors;

namespace Microsoft.ML.Probabilistic.Compiler
{
#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning disable 1591
#endif

    /// <summary>
    /// Helper class for recognizing patterns in code which is to be transformed.
    /// </summary>
    public class CodeRecognizer
    {
        public static readonly CodeRecognizer Instance = new CodeRecognizer();

        private CodeRecognizer()
        {
        }

        /// <summary>
        /// Helps build class declarations
        /// </summary>
        private static readonly CodeBuilder Builder = CodeBuilder.Instance;

        /// <summary>
        /// True if expr is a MethodInvokeExpression on any static method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        public bool IsStaticMethod(IExpression expr, Type type)
        {
            return (GetStaticMethodOfType(expr, type) != null);
        }

        /// <summary>
        /// True if expr is a MethodInvokeExpression on any overload of the named static method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public bool IsStaticMethod(IExpression expr, Type type, string methodName)
        {
            string s = GetStaticMethodOfType(expr, type);
            return methodName.Equals(s);
        }

        public bool IsStaticMethod(IExpression expr, Delegate method)
        {
            return IsStaticMethod(expr, method.Method);
        }

        public bool IsStaticMethod(IExpression expr, MethodInfo method)
        {
            IMethodReference imr = GetMethodReference(expr);
            if (imr == null)
                return false;
            return method.Equals(imr.MethodInfo);
        }

        /// <summary>
        /// True if imie is a MethodInvokeExpression on any overload of the named static generic method of type.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="type"></param>
        /// <param name="methodName"></param>
        /// <returns></returns>
        public bool IsStaticGenericMethod(IExpression expr, Type type, string methodName)
        {
            if (!(expr is IMethodInvokeExpression))
                return false;
            IMethodInvokeExpression imie = (IMethodInvokeExpression)expr;
            if (!(imie.Method is IMethodReferenceExpression))
                return false;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)imie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return false;
            ITypeReference itr = ((ITypeReferenceExpression)imre.Target).Type;
            if (itr.Namespace != type.Namespace)
                return false;
            if (itr.GenericType is ITypeReference)
                itr = itr.GenericType;
            if (itr.DotNetType.Name != type.Name)
                return false;
            return (imie.Method.Method.Name == methodName);
        }

        public bool IsStaticGenericMethod(IExpression expr, Delegate method)
        {
            MethodInfo methodInfo = method.Method;
            return IsStaticGenericMethod(expr, methodInfo.DeclaringType, methodInfo.Name);
        }

        public string GetStaticMethodOfType(IExpression expr, Type type)
        {
            if (!(expr is IMethodInvokeExpression))
                return null;
            IMethodInvokeExpression mie = (IMethodInvokeExpression)expr;
            if (!(mie.Method is IMethodReferenceExpression))
                return null;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)mie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return null;
            ITypeReferenceExpression itre = (ITypeReferenceExpression)imre.Target;
            if (!IsTypeReferenceTo(itre, type))
                return null;
            return imre.Method.Name;
        }

        public ITypeReference GetStaticMethodType(IExpression expr)
        {
            if (!(expr is IMethodInvokeExpression))
                return null;
            IMethodInvokeExpression mie = (IMethodInvokeExpression)expr;
            if (!(mie.Method is IMethodReferenceExpression))
                return null;
            IMethodReferenceExpression imre = (IMethodReferenceExpression)mie.Method;
            if (!(imre.Target is ITypeReferenceExpression))
                return null;
            ITypeReferenceExpression itre = (ITypeReferenceExpression)imre.Target;
            return itre.Type;
        }

        public IMethodReference GetMethodReference(IExpression expr)
        {
            if (!(expr is IMethodInvokeExpression mie))
                return null;
            if (!(mie.Method is IMethodReferenceExpression imre))
                return null;
            return imre.Method;
        }

        public bool IsBeingDeclared(BasicTransformContext context)
        {
            object parent = context.GetAncestor(context.InputStack.Count - 2);
            return (parent is IVariableDeclarationExpression);
        }

        public bool IsBeingIndexed(BasicTransformContext context)
        {
            object parent = context.GetAncestor(context.InputStack.Count - 2);
            return (parent is IArrayIndexerExpression);
        }

        /// <summary>
        /// Returns true if the expression is being mutated in the given context.  For example, this will
        /// be true if the expression is the LHS of an assignment, or the argument to an 'out' parameter.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        public bool IsBeingMutated(BasicTransformContext context, IExpression expr)
        {
            int methodIndex = context.FindAncestorIndex<IMethodInvokeExpression>();
            if (methodIndex != -1)
            {
                if (context.GetAncestor(methodIndex + 1) is IAddressOutExpression iaoe)
                    return IsPartOf(iaoe.Expression, expr);
                else
                    return false;
            }
            return IsOnLHSOfAssignment(context, expr);
        }

        public Bounds GetBounds(IExpression expr, IReadOnlyDictionary<IVariableDeclaration, Bounds> bounds)
        {
            if (expr is IVariableReferenceExpression && bounds != null)
            {
                IVariableDeclaration ivd = GetVariableDeclaration(expr);
                Bounds b;
                if (bounds.TryGetValue(ivd, out b))
                    return b;
            }
            else if (expr is IBinaryExpression ibe)
            {
                Bounds left = GetBounds(ibe.Left, bounds);
                Bounds right = GetBounds(ibe.Right, bounds);
                if (left != null && right != null)
                {
                    if (ibe.Operator == BinaryOperator.Add)
                    {
                        return new Bounds()
                        {
                            lowerBound = left.lowerBound + right.lowerBound,
                            upperBound = left.upperBound + right.upperBound
                        };
                    }
                    else if (ibe.Operator == BinaryOperator.Subtract)
                    {
                        return new Bounds()
                        {
                            lowerBound = left.lowerBound - right.upperBound,
                            upperBound = left.upperBound - right.lowerBound
                        };
                    }
                }
            }
            else if (expr is ILiteralExpression ile)
            {
                if (ile.Value is int value)
                {
                    return new Bounds()
                    {
                        lowerBound = value,
                        upperBound = value
                    };
                }
            }
            return null;
        }

        private IVariableDeclaration GetOffsetVariable(IExpression expr)
        {
            int offset;
            return GetOffsetVariable(expr, out offset);
        }

        private IVariableDeclaration GetOffsetVariable(IExpression expr, out int offset)
        {
            offset = 0;
            if (expr is IVariableReferenceExpression)
            {
                return GetVariableDeclaration(expr);
            }
            else if (expr is IBinaryExpression indexBinaryExpr)
            {
                ILiteralExpression offsetExpr = indexBinaryExpr.Right as ILiteralExpression;
                if (indexBinaryExpr.Left is IVariableReferenceExpression ivre && offsetExpr != null && offsetExpr.Value is int)
                {
                    offset = (int)offsetExpr.Value;
                    if (indexBinaryExpr.Operator == BinaryOperator.Subtract)
                    {
                        offset = -offset;
                    }
                    else if (indexBinaryExpr.Operator == BinaryOperator.Add)
                    {
                        // do nothing
                    }
                    else
                    {
                        return null;
                    }
                    return GetVariableDeclaration(ivre);
                }
            }
            return null;
        }

        /// <summary>
        /// Reflection cache
        /// </summary>
        readonly MethodInfo AnyIndexMethod = new Func<int>(GateAnalysisTransform.AnyIndex).Method;

        // helper for MutatingFirstAffectsSecond
        // offsets and extraIndices only need to be modified on a match (though they can be modified in any case)
        private bool IndicesOverlap(IList<IExpression> mutated_indices, IList<IExpression> affected_indices, bool mutatesWithinOnly,
                                    IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInMutated,
                                    IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInAffected,
                                    OffsetInfo offsets,
                                    ICollection<IVariableDeclaration> extraIndices,
                                    ICollection<IVariableDeclaration> matchedIndices)
        {
            // if mutatesWithinOnly = false, then return false on mismatched literals
            // if mutatesWithinOnly = true, then return false also if mutated index is wildcard and affected index is literal
            // if one index is an offset of the other and non-literal, return true but add entry to offsets dictionary
            if (mutated_indices.Count != affected_indices.Count)
                throw new ArgumentException("Mismatched array rank");
            for (int i = 0; i < mutated_indices.Count; i++)
            {
                IExpression mutated_index = mutated_indices[i];
                IExpression affected_index = affected_indices[i];
                if (mutated_index.Equals(affected_index))
                {
                    IVariableDeclaration mutatedVar = GetOffsetVariable(mutated_index);
                    if (mutatedVar != null) matchedIndices.Add(mutatedVar);
                    continue;
                }
                if (IsStaticMethod(affected_index, AnyIndexMethod))
                    continue;
                if (affected_index is ILiteralExpression iLiteralExpression)
                {
                    if (mutated_index is ILiteralExpression)
                    {
                        // if we reach this point, they don't match
                        return false;
                    }
                    else
                    {
                        if (mutatesWithinOnly)
                            return false; // mutated_index is more general
                        int affected_value = (int)iLiteralExpression.Value;
                        Bounds mutatedBounds = GetBounds(mutated_index, boundsInMutated);
                        if (mutatedBounds != null)
                        {
                            if (!mutatedBounds.Contains(affected_value))
                                return false;
                        }
                        if (offsets != null)
                        {
                            // if affected=v (when i=j) and mutated=i-k, then we write to v on iter v+k, and read on iter j, so offset is v+k-j
                            // offset = (loop counter of write) - (loop counter of read)
                            Bounds affectedBounds = GetBounds(mutated_index, boundsInAffected);
                            if (affectedBounds != null)
                            {
                                // affectedBounds = [jLower-k, jUpper-k]
                                int minOffset = affected_value - affectedBounds.upperBound;
                                int maxOffset = affected_value - affectedBounds.lowerBound;
                                if (System.Math.Sign(minOffset) != System.Math.Sign(maxOffset))
                                    throw new Exception("Inconsistent offset between array indexer expressions: " + mutated_index + " and " + affected_index);
                                int offset = (minOffset > 0) ? minOffset : maxOffset;
                                if (offset != 0)
                                {
                                    IVariableDeclaration loopVar = GetOffsetVariable(mutated_index);
                                    offsets.Add(loopVar, offset, true);
                                }
                            }
                            else if (extraIndices != null)
                            {
                                IVariableDeclaration loopVar = GetOffsetVariable(mutated_index);
                                if (loopVar != null && !matchedIndices.Contains(loopVar))
                                    extraIndices.Add(loopVar);
                            }
                        }
                    }
                }
                else if (mutatesWithinOnly)
                    return false;  // expressions are incomparable
                else if (mutated_index is ILiteralExpression iLiteralExpression)
                {
                    int mutated_value = (int)iLiteralExpression.Value;
                    Bounds affectedBounds = GetBounds(affected_index, boundsInAffected);
                    if (affectedBounds != null)
                    {
                        if (!affectedBounds.Contains(mutated_value))
                            return false;
                    }
                    if (offsets != null)
                    {
                        // if affected=i-k and mutated=v (when i=j), then we write to v on iter j, and read on iter v+k, so offset is j-v-k
                        // offset = (loop counter of write) - (loop counter of read)
                        Bounds mutatedBounds = GetBounds(affected_index, boundsInMutated);
                        if (mutatedBounds != null)
                        {
                            // mutatedBounds = [jLower-k, jUpper-k]
                            int minOffset = mutatedBounds.lowerBound - mutated_value;
                            int maxOffset = mutatedBounds.upperBound - mutated_value;
                            if (System.Math.Sign(minOffset) != System.Math.Sign(maxOffset))
                                throw new Exception("Inconsistent offset between array indexer expressions: " + mutated_index + " and " + affected_index);
                            int offset = (minOffset > 0) ? minOffset : maxOffset;
                            if (offset != 0)
                            {
                                IVariableDeclaration affectedVar = GetOffsetVariable(affected_index);
                                offsets.Add(affectedVar, offset, true);
                            }
                        }
                    }
                }
                else if (offsets != null || extraIndices != null)
                {
                    // neither affected nor mutated is literal
                    // check for offsetting
                    int mutated_offset, affected_offset;
                    IVariableDeclaration mutatedVar = GetOffsetVariable(mutated_index, out mutated_offset);
                    IVariableDeclaration affectedVar = GetOffsetVariable(affected_index, out affected_offset);
                    if (mutatedVar != null)
                    {
                        if (mutatedVar.Equals(affectedVar))
                        {
                            // mutated has the form [t + mutated_offset]
                            // affected has the form [t + affected_offset]
                            int offset = 0;
                            offset += affected_offset;
                            offset -= mutated_offset;
                            if (offset != 0)
                            {
                                bool isAvailable;
                                if (offset < 0)
                                {
                                    // TODO: make use of bounds
                                    // forward loop from 0 to size-1
                                    // we want to know if the first affected element will be mutated at an earlier time.
                                    // if affected_offset <= 0 then first affected is element 0 at time = -affected_offset.
                                    // if mutated_offset <= 0 then element 0 is mutated at time = -mutated_offset.
                                    // therefore available when -mutated_offset < -affected_offset, i.e. mutated_offset > affected_offset
                                    // which is always true.
                                    // if mutated_offset > 0 then element 0 is never mutated so not available.
                                    // if affected_offset > 0 then first affected is affected_offset at time 0 so not available.
                                    isAvailable = (affected_offset <= 0) && (mutated_offset <= 0);
                                }
                                else
                                {
                                    // backward loop from size-1 to 0
                                    // we want to know if the last affected element mutated will be mutated at a later time.
                                    // if affected_offset >= 0 then last affected is element size-1 at time = size-1 - affected_offset.
                                    // if mutated_offset >= 0 then this element is mutated at time = size-1 - mutated_offset.
                                    // therefore available when mutated_offset < affected_offset which is always true.
                                    // if mutated_offset < 0 then element size-1 is never mutated so not available.
                                    // if affected_offset < 0 then last affected is (size-1+affected_offset) at last time so not available.
                                    //isAvailable = (affected_offset >= 0); // TODO
                                    isAvailable = (affected_offset >= 0) && (mutated_offset >= 0);
                                }
                                offsets.Add(mutatedVar, offset, isAvailable);
                            }
                            matchedIndices.Add(mutatedVar);
                        }
                        else
                        {
                            // affected and mutated use two different loop variables.
                            // we cannot merge on either of these loops.
                            if(!matchedIndices.Contains(mutatedVar))
                                extraIndices.Add(mutatedVar);
                            if (affectedVar != null)
                                extraIndices.Add(affectedVar);
                        }
                    }
                    else
                    {
                        foreach(var v in GetVariables(mutated_index))
                        {
                            if(!matchedIndices.Contains(v))
                                extraIndices.Add(v);
                        }
                        if (affectedVar != null)
                            extraIndices.Add(affectedVar);
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Reflection cache
        /// </summary>
        readonly MethodInfo AnyMethod = new Func<object[], object>(FactorManager.Any).Method;

        /// <summary>
        /// Returns true if mutating the first expression would affect the value of the second.
        /// For example, if the first expression is 'x' and the second is 'x[1]' the answer is true.
        /// If the first expression is 'x[0]' and the second is 'x[1]' the answer is false.
        /// 
        /// If 'mutatesWithinOnly' is true, the result will only be true if the first expression mutates
        /// all or part of the second, but nothing else.  For example, if the first is 'x[0]' and the second is 'x'
        /// the result is true but not if the first is 'x' and the second 'x[0]'. 
        /// </summary>
        /// <param name="context">The context</param>
        /// <param name="mutated">The mutating expression</param>
        /// <param name="affected">The possibly affected expression</param>
        /// <param name="mutatesWithinOnly">See summary</param>
        /// <param name="mutatedStatement">Bindings on the index variables in mutated</param>
        /// <param name="affectedStatement">Bindings on the index variables in affected</param>
        /// <param name="boundsInMutated">Lower bounds on the index variables in mutated</param>
        /// <param name="boundsInAffected">Lower bounds on the index variables in affected</param>
        /// <param name="offsets">Modified to contain indexing offsets necessary for a match</param>
        /// <param name="extraIndices">Modified to contain loop indices in mutated that must be iterated to cover affected (i.e. loops that cannot be merged)</param>
        /// <returns></returns>
        internal bool MutatingFirstAffectsSecond(
            BasicTransformContext context,
            IExpression mutated,
            IExpression affected,
            bool mutatesWithinOnly,
            IStatement mutatedStatement = null,
            IStatement affectedStatement = null,
            IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInMutated = null,
            IReadOnlyDictionary<IVariableDeclaration, Bounds> boundsInAffected = null,
            OffsetInfo offsets = null,
            ICollection<IVariableDeclaration> extraIndices = null)
        {
            // if mutated has the special form Any(expr,expr,...) then check if all sub-expressions change affected
            if (IsStaticMethod(mutated, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)mutated;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (!MutatingFirstAffectsSecond(context, arg, affected, mutatesWithinOnly, mutatedStatement, affectedStatement, boundsInMutated, boundsInAffected, offsets, extraIndices))
                        return false;
                }
                return (imie.Arguments.Count > 0);
            }
            // if affected has the special form Any(expr,expr,...) then check if mutated changes any sub-expressions
            if (IsStaticMethod(affected, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)affected;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (MutatingFirstAffectsSecond(context, mutated, arg, mutatesWithinOnly, mutatedStatement, affectedStatement, boundsInMutated, boundsInAffected, offsets, extraIndices))
                        return true;
                }
                return false;
            }
            if(affectedStatement != null && mutatedStatement != null)
            {
                Set<IVariableDeclaration> localVarsInMutated = new Set<IVariableDeclaration>();
                var bindingsInMutated = GetBindings(mutatedStatement, localVarsInMutated);
                var bindingsInAffected = GetBindings(affectedStatement, null);
                if (!MutatingFirstAffectsSecond(mutated, affected, bindingsInMutated, bindingsInAffected, localVarsInMutated.Contains))
                    return false;
            }
            // Algorithm:
            // Examine the prefixes of the two expressions from left to right.
            // If the innermost targets don't match, return false.
            // If the prefixes have non-overlapping array indices, return false.
            // If the prefixes are incomparable, e.g. property versus field, return !mutatesWithinOnly (to be conservative)
            // If mutatesWithinOnly=true, return false unless we are sure.
            // If mutatesWithinOnly=false, return true unless we are sure.
            List<IExpression> mutatedPrefixes = GetAllPrefixes(mutated);
            List<IExpression> affectedPrefixes = GetAllPrefixes(affected);
            if (!mutatedPrefixes[0].Equals(affectedPrefixes[0]))
                return false;
            if (mutatesWithinOnly && affectedPrefixes.Count > mutatedPrefixes.Count)
                return false;
            int count = System.Math.Min(mutatedPrefixes.Count, affectedPrefixes.Count);
            Set<IVariableDeclaration> matchedIndices = new Set<IVariableDeclaration>();
            for (int i = 1; i < count; i++)
            {
                bool lastBracket = (i == affectedPrefixes.Count - 1);
                IExpression mutatedPrefix = mutatedPrefixes[i];
                IExpression affectedPrefix = affectedPrefixes[i];
                if (mutatedPrefix is IArrayIndexerExpression mutated_iaie)
                {
                    if (affectedPrefix is IArrayIndexerExpression affected_iaie)
                    {
                        try
                        {
                            if (!IndicesOverlap(mutated_iaie.Indices, affected_iaie.Indices, mutatesWithinOnly && lastBracket, boundsInMutated, boundsInAffected, offsets, extraIndices, matchedIndices))
                                return false;
                        }
                        catch (Exception ex)
                        {
                            throw new Exception($"Exception while comparing expressions '{mutated}' and '{affected}': {ex.Message}", ex);
                        }
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IPropertyIndexerExpression mutated_ipie)
                {
                    if (affectedPrefix is IPropertyIndexerExpression affected_ipie)
                    {
                        if (!IndicesOverlap(mutated_ipie.Indices, affected_ipie.Indices, mutatesWithinOnly && lastBracket, boundsInMutated, boundsInAffected, offsets, extraIndices, matchedIndices))
                            return false;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IPropertyReferenceExpression mutated_ipre)
                {
                    if (affectedPrefix is IPropertyReferenceExpression affected_ipre)
                    {
                        if (!mutated_ipre.Property.Equals(affected_ipre.Property))
                            return !mutatesWithinOnly;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else if (mutatedPrefix is IFieldReferenceExpression mutated_ifre)
                {
                    if (affectedPrefix is IFieldReferenceExpression affected_ifre)
                    {
                        if (!mutated_ifre.Field.Equals(affected_ifre.Field))
                            return !mutatesWithinOnly;
                    }
                    else
                        return !mutatesWithinOnly;
                }
                else
                    throw new Exception("Unhandled expression type: " + mutatedPrefix);
            }
            if (extraIndices != null && mutatedPrefixes.Count > count)
            {
                // add extra indices in mutated to extraIndices
                // if mutated = array[i][j] and affected = array[i] then j is extra index
                // but if mutated = array[i][i] and affected = array[i] then i is not an extra index
                Containers containers = Containers.GetContainersNeededForExpression(context, affected);
                Set<IVariableDeclaration> loopVars = new Set<IVariableDeclaration>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
                foreach (IStatement container in containers.inputs)
                {
                    if (container is IForStatement ifs)
                    {
                        loopVars.Add(LoopVariable(ifs));
                    }
                }
                for (int i = count; i < mutatedPrefixes.Count; i++)
                {
                    IExpression mutatedPrefix = mutatedPrefixes[i];
                    if (mutatedPrefix is IArrayIndexerExpression mutated_iaie)
                    {
                        foreach (IExpression index in mutated_iaie.Indices)
                        {
                            foreach (var v in GetVariables(index))
                            {
                                if (!loopVars.Contains(v))
                                    extraIndices.Add(v);
                            }
                        }
                    }
                }
            }
            return true;
        }

        internal bool MutatingFirstAffectsSecond(
            IExpression mutated,
            IExpression affected,
            IReadOnlyCollection<ConditionBinding> bindingsInMutated,
            IReadOnlyCollection<ConditionBinding> bindingsInAffected,
            Func<IVariableDeclaration,bool> isLocalVarInMutated)
        {
            // if mutated has the special form Any(expr,expr,...) then check if all sub-expressions change affected
            if (IsStaticMethod(mutated, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)mutated;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (!MutatingFirstAffectsSecond(arg, affected, bindingsInMutated, bindingsInAffected, isLocalVarInMutated))
                        return false;
                }
                return (imie.Arguments.Count > 0);
            }
            // if affected has the special form Any(expr,expr,...) then check if mutated changes any sub-expressions
            if (IsStaticMethod(affected, AnyMethod))
            {
                IMethodInvokeExpression imie = (IMethodInvokeExpression)affected;
                foreach (IExpression arg in imie.Arguments)
                {
                    // TODO: what if offsets/extraIndices do not agree?
                    if (MutatingFirstAffectsSecond(mutated, arg, bindingsInMutated, bindingsInAffected, isLocalVarInMutated))
                        return true;
                }
                return false;
            }

            return !AreDisjoint(mutated, bindingsInMutated, affected, bindingsInAffected, isLocalVarInMutated);
        }

        /// <summary>
        /// Augment the bindings with the minimal conditions necessary for the two expressions to overlap
        /// </summary>
        /// <param name="e1"></param>
        /// <param name="e2"></param>
        /// <param name="bindings1">Bindings for e1</param>
        /// <param name="bindings2">Bindings for e2</param>
        /// <returns>True if overlap conditions could be found, false if the expressions cannot overlap</returns>
        internal bool AddIndexBindings(IExpression e1, IExpression e2, ICollection<ConditionBinding> bindings1, ICollection<ConditionBinding> bindings2)
        {
            int tempCount = 0;
            List<IExpression> prefixes1 = GetAllPrefixes(e1);
            List<IExpression> prefixes2 = GetAllPrefixes(e2);
            if (!prefixes1[0].Equals(prefixes2[0]))
                return false;
            int count = System.Math.Min(prefixes1.Count, prefixes2.Count);
            for (int i = 1; i < count; i++)
            {
                IExpression prefix1 = prefixes1[i];
                IExpression prefix2 = prefixes2[i];
                if (prefix1 is IArrayIndexerExpression iaie1)
                {
                    if (prefix2 is IArrayIndexerExpression iaie2)
                    {
                        if (iaie1.Indices.Count != iaie2.Indices.Count)
                            break;
                        for (int j = 0; j < iaie1.Indices.Count; j++)
                        {
                            IExpression index1 = iaie1.Indices[j];
                            IExpression index2 = iaie2.Indices[j];
                            if (index1 is ILiteralExpression && index2 is ILiteralExpression)
                            {
                                if (!index1.Equals(index2))
                                    return false;
                            }
                            else
                            {
                                // add a condition for the indices to be equal
                                AddBinding(index1, index2, bindings1, bindings2, tempCount++);
                            }
                        }
                    }
                    else
                        break;
                }
                else if (prefix1 is IPropertyIndexerExpression ipie1)
                {
                    if (prefix2 is IPropertyIndexerExpression ipie2)
                    {
                        if (ipie1.Indices.Count != ipie2.Indices.Count)
                            break;
                        for (int j = 0; j < ipie1.Indices.Count; j++)
                        {
                            IExpression index1 = ipie1.Indices[j];
                            IExpression index2 = ipie2.Indices[j];
                            if (index1 is ILiteralExpression && index2 is ILiteralExpression)
                            {
                                if (!index1.Equals(index2))
                                    return false;
                            }
                            else
                            {
                                // add a condition for the indices to be equal
                                AddBinding(index1, index2, bindings1, bindings2, tempCount++);
                            }
                        }
                    }
                    else
                        break;
                }
                else if (prefix1 is IPropertyReferenceExpression ipre1)
                {
                    if (prefix2 is IPropertyReferenceExpression ipre2)
                    {
                        // we assume that mutating one property does not affect another.
                        if (!ipre1.Property.Equals(ipre2.Property))
                            break;
                    }
                    else
                        break;
                }
                else if (prefix1 is IFieldReferenceExpression ifre1)
                {
                    if (prefix2 is IFieldReferenceExpression ifre2)
                    {
                        if (!ifre1.Field.Equals(ifre2.Field))
                            break;
                    }
                    else
                        break;
                }
                else
                    throw new Exception("Unhandled expression type: " + prefix1);
            }
            return true;
        }

        /// <summary>
        /// Augment both bindings to ensure that (index1 == index2)
        /// </summary>
        /// <param name="index1"></param>
        /// <param name="index2"></param>
        /// <param name="bindings1"></param>
        /// <param name="bindings2"></param>
        /// <param name="tempCount">A counter for numbering temporary variables</param>
        private static void AddBinding(IExpression index1, IExpression index2, ICollection<ConditionBinding> bindings1, ICollection<ConditionBinding> bindings2,
                                       int tempCount)
        {
            if (index1 is ILiteralExpression)
            {
                bindings2.Add(new ConditionBinding(index2, index1));
            }
            else if (index2 is ILiteralExpression)
            {
                bindings1.Add(new ConditionBinding(index1, index2));
            }
            else
            {
                Type exprType = index1.GetExpressionType();
                IVariableDeclaration tempVar = Builder.VarDecl("_t" + tempCount, exprType);
                IExpression tempRef = Builder.VarRefExpr(tempVar);
                bindings1.Add(new ConditionBinding(index1, tempRef));
                bindings2.Add(new ConditionBinding(tempRef, index2));
            }
        }

        /// <summary>
        /// Returns true if the expressions access distinct array elements or have disjoint condition contexts
        /// </summary>
        /// <param name="expr1"></param>
        /// <param name="ebBinding"></param>
        /// <param name="expr2"></param>
        /// <param name="eb2Binding"></param>
        /// <param name="isLoopVar"></param>
        /// <returns></returns>
        internal bool AreDisjoint(
            IExpression expr1,
            IReadOnlyCollection<ConditionBinding> ebBinding,
            IExpression expr2,
            IReadOnlyCollection<ConditionBinding> eb2Binding,
            Func<IVariableDeclaration,bool> isLoopVar)
        {
            var bindings1 = new Set<ConditionBinding>();
            bindings1.AddRange(ebBinding);
            var bindings2 = new Set<ConditionBinding>();
            bindings2.AddRange(eb2Binding);
            // augment the two bindings to make the expressions overlap
            bool match = AddIndexBindings(expr1, expr2, bindings1, bindings2);
            if (!match)
                return true;
            // remove loop vars from bindings1 (see InferTests.ConstrainBetweenTest3)
            var bindings1Reduced = RemoveLoopVars(bindings1, isLoopVar);
            if (bindings1Reduced == null)
                return true;
            bindings2.AddRange(bindings1Reduced);
            // bindings2 is now the combined set of conditions.  If we find a contradiction, the uses are disjoint.
            var bindings2Reduced = FindContradiction(bindings2, expr => !(expr is ILiteralExpression));
            return (bindings2Reduced == null);
        }

        internal IReadOnlyCollection<ConditionBinding> RemoveLoopVars(IReadOnlyCollection<ConditionBinding> bindings, Func<IVariableDeclaration,bool> isLoopVar)
        {
            return FindContradiction(bindings, expr => ContainsLoopVars(expr, isLoopVar));
        }

        /// <summary>
        /// Find a contradiction in a set of conditions, i.e. prove there is no satisfying assignment
        /// </summary>
        /// <param name="bindings">A set of conditions.  Not modified.</param>
        /// <param name="predicate">Indicates the bindings to eliminate.  If null, all bindings are eliminated.</param>
        /// <returns>null if inconsistent, otherwise a reduced list of bindings where none satisfy the predicate</returns>
        internal IReadOnlyCollection<ConditionBinding> FindContradiction(IReadOnlyCollection<ConditionBinding> bindings, Predicate<IExpression> predicate = null)
        {
            while (bindings.Count > 0)
            {
                // find the binding with minimum depth
                ConditionBinding currentBinding = null;
                IExpression exprFind = null;
                IExpression exprReplace = null;
                int minDepth = int.MaxValue;
                foreach (ConditionBinding binding in bindings)
                {
                    if (!IsValid(binding))
                        return null;
                    bool containsLhs = (predicate == null) ? true : predicate(binding.lhs);
                    if (containsLhs)
                    {
                        int depthLhs = GetExpressionDepth(binding.lhs);
                        if (depthLhs < minDepth)
                        {
                            minDepth = depthLhs;
                            currentBinding = binding;
                            exprFind = binding.lhs;
                            exprReplace = binding.rhs;
                        }
                    }
                    bool containsRhs = (predicate == null) ? true : predicate(binding.rhs);
                    if (containsRhs)
                    {
                        int depthRhs = GetExpressionDepth(binding.rhs);
                        if (depthRhs < minDepth)
                        {
                            minDepth = depthRhs;
                            currentBinding = binding;
                            exprFind = binding.rhs;
                            exprReplace = binding.lhs;
                        }
                    }
                }
                if (currentBinding == null)
                    return bindings;
                // apply the binding
                var newBindings = new Set<ConditionBinding>();
                foreach (ConditionBinding binding in bindings)
                {
                    if (object.ReferenceEquals(binding, currentBinding))
                        continue;
                    // could skip cases where we know exprFind will not appear, e.g. exprs not satisfying the predicate
                    // or whose depth is too small.
                    IExpression newLhs = Builder.ReplaceExpression(binding.lhs, exprFind, exprReplace);
                    IExpression newRhs = Builder.ReplaceExpression(binding.rhs, exprFind, exprReplace);
                    newBindings.Add(new ConditionBinding(newLhs, newRhs));
                }
                bindings = newBindings;
            }
            return bindings;
        }

        private static int GetExpressionDepth(IExpression expr)
        {
            if (expr == null)
                return 0;
            else if (expr is IArrayIndexerExpression iaie)
            {
                int maxDepth = GetExpressionDepth(iaie.Target);
                foreach (IExpression index in iaie.Indices)
                {
                    int depth = GetExpressionDepth(index);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IMethodReferenceExpression imre)
            {
                return GetExpressionDepth(imre.Target);
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                int maxDepth = GetExpressionDepth(imie.Method);
                foreach (IExpression arg in imie.Arguments)
                {
                    int depth = GetExpressionDepth(arg);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IBinaryExpression ibe)
            {
                return 1 + System.Math.Max(GetExpressionDepth(ibe.Left), GetExpressionDepth(ibe.Right));
            }
            else if (expr is IUnaryExpression iue)
            {
                return 1 + GetExpressionDepth(iue.Expression);
            }
            else if (expr is IPropertyReferenceExpression ipre)
            {
                return 1 + GetExpressionDepth(ipre.Target);
            }
            else if (expr is IPropertyIndexerExpression ipie)
            {
                int maxDepth = GetExpressionDepth(ipie.Target);
                foreach (IExpression index in ipie.Indices)
                {
                    int depth = GetExpressionDepth(index);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IObjectCreateExpression ioce)
            {
                int maxDepth = GetExpressionDepth(ioce.Initializer);
                foreach (IExpression arg in ioce.Arguments)
                {
                    int depth = GetExpressionDepth(arg);
                    if (depth > maxDepth)
                        maxDepth = depth;
                }
                return 1 + maxDepth;
            }
            else if (expr is IAssignExpression iae)
            {
                return 1 + System.Math.Max(GetExpressionDepth(iae.Target), GetExpressionDepth(iae.Expression));
            }
            else if (expr is IVariableReferenceExpression || expr is ILiteralExpression || expr is IArgumentReferenceExpression || expr is ITypeReferenceExpression
                || expr is IVariableDeclarationExpression || expr is IArrayCreateExpression)
            {
                return 1;
            }
            else
                throw new NotImplementedException();
        }

        private bool ContainsLoopVars(IExpression expr, Func<IVariableDeclaration,bool> isLoopVar)
        {
            return GetVariables(expr).Any(isLoopVar);
        }

        private bool IsValid(ConditionBinding binding)
        {
            object value;
            if (TryEvaluate<object>(binding.GetExpression(), null, out value))
                return (bool)value;
            else
                return true;
        }

        private IEnumerable<IExpression> GetSummands(IExpression expr)
        {
            if (expr is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.Add)
                {
                    foreach (var summand in GetSummands(ibe.Left))
                        yield return summand;
                    foreach (var summand in GetSummands(ibe.Right))
                        yield return summand;
                }
                else if (ibe.Operator == BinaryOperator.Subtract)
                {
                    foreach (var summand in GetSummands(ibe.Left))
                        yield return summand;
                    foreach (var summand in GetSummands(ibe.Right))
                        yield return Negate(summand);
                }
                else
                    yield return expr;
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                if (IsStaticMethod(imie, new Func<int, int, int>(ML.Probabilistic.Factors.Factor.Plus)))
                {
                    foreach (var arg in imie.Arguments)
                    {
                        foreach (var summand in GetSummands(arg))
                            yield return summand;
                    }
                }
                else if (IsStaticMethod(imie, new Func<int, int, int>(ML.Probabilistic.Factors.Factor.Difference)))
                {
                    foreach (var summand in GetSummands(imie.Arguments[0]))
                        yield return summand;
                    foreach (var summand in GetSummands(imie.Arguments[1]))
                        yield return Negate(summand);
                }
                else
                    yield return expr;
            }
            else
                yield return expr;
        }

        private IExpression Negate(IExpression expr)
        {
            if (expr is IMethodInvokeExpression imie)
            {
                if (IsStaticMethod(imie, new Func<int, int>(ML.Probabilistic.Factors.Factor.Negate)))
                {
                    return imie.Arguments[0];
                }
            }
            if (expr is IUnaryExpression iue)
            {
                if (iue.Operator == UnaryOperator.Negate)
                {
                    return iue.Expression;
                }
            }
            bool useOperator = true;
            if (useOperator)
                return Builder.UnaryExpr(UnaryOperator.Negate, expr);
            else
                return Builder.StaticMethod(new Func<int, int>(ML.Probabilistic.Factors.Factor.Negate), expr);
        }

        public bool TryEvaluate<T>(IExpression expr, IDictionary<IVariableDeclaration, T> bindings, out T value)
        {
            if (expr is IVariableReferenceExpression && bindings != null)
            {
                IVariableDeclaration ivd = GetVariableDeclaration(expr);
                return bindings.TryGetValue(ivd, out value);
            }
            else if (expr is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.ValueInequality ||
                    ibe.Operator == BinaryOperator.IdentityInequality ||
                    ibe.Operator == BinaryOperator.GreaterThan ||
                    ibe.Operator == BinaryOperator.LessThan)
                {
                    if (ibe.Left.Equals(ibe.Right))
                    {
                        value = (T)(object)false;
                        return true;
                    }
                }
                else if (ibe.Operator == BinaryOperator.IdentityEquality || ibe.Operator == BinaryOperator.ValueEquality)
                {
                    if (ibe.Left.Equals(ibe.Right))
                    {
                        value = (T)(object)true;
                        return true;
                    }
                    if (ibe.Left.GetExpressionType().Equals(typeof(int)))
                    {
                        List<IExpression> summandsLeft = GetSummands(ibe.Left).ToList();
                        List<IExpression> summandsRight = new List<IExpression>();
                        bool foundMatch = false;
                        // Cancel identical expressions on both sides of the equality.
                        foreach (var summand in GetSummands(ibe.Right))
                        {
                            if (summandsLeft.Contains(summand))
                            {
                                foundMatch = true;
                                summandsLeft.Remove(summand);
                            }
                            else
                                summandsRight.Add(summand);
                        }
                        if (foundMatch)
                        {
                            if (summandsLeft.Count == 0)
                                summandsLeft.Add(Builder.LiteralExpr(0));
                            if (summandsRight.Count == 0)
                                summandsRight.Add(Builder.LiteralExpr(0));
                            if (summandsLeft.Count == 1 && summandsRight.Count == 1)
                            {
                                ibe = Builder.BinaryExpr(summandsLeft[0], ibe.Operator, summandsRight[0]);
                                // fall through
                            }
                        }
                    }
                }
                T left, right;
                if (TryEvaluate(ibe.Left, bindings, out left) && TryEvaluate(ibe.Right, bindings, out right))
                {
                    // must use runtime type here, not T
                    Type type = left.GetType();
                    value = (T)Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, ExpressionEvaluator.binaryOperatorNames[(int)ibe.Operator], left, right);
                    return true;
                }
            }
            else if (expr is IUnaryExpression iue)
            {
                T target;
                if (TryEvaluate(iue.Expression, bindings, out target))
                {
                    // must use runtime type here, not T
                    Type type = target.GetType();
                    value = (T)Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(type, ExpressionEvaluator.unaryOperatorNames[(int)iue.Operator], target);
                    return true;
                }
            }
            else if (expr is ILiteralExpression ile)
            {
                if (ile.Value is T)
                {
                    value = (T)ile.Value;
                    return true;
                }
            }
            value = default(T);
            return false;
        }

        /// <summary>
        /// Returns true if expr is on the left hand side of the innermost assignment statement in the context stack.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        public bool IsOnLHSOfAssignment(BasicTransformContext context, IExpression expr)
        {
            int assignIndex = context.FindAncestorIndex<IAssignExpression>();
            if (assignIndex == -1)
                return false;
            IAssignExpression iae = context.GetAncestor(assignIndex) as IAssignExpression;
            if (!(iae.Target == context.GetAncestor(assignIndex + 1)))
                return false;
            return IsPartOf(iae.Target, expr);
        }

        public int GetAncestorIndexOfLoopBeingInitialized(BasicTransformContext context)
        {
            int forIndex = context.FindAncestorIndex<IForStatement>();
            if (forIndex == -1)
                return -1;
            IForStatement forStmt = (IForStatement)context.GetAncestor(forIndex);
            if (context.InputStack.Count > forIndex + 1 && context.InputStack[forIndex + 1].inputElement.Equals(forStmt.Initializer))
            {
                return forIndex;
            }
            else
                return -1;
        }

        public bool IsBeingAllocated(BasicTransformContext context, IExpression expr)
        {
            if (IsOnLHSOfAssignment(context, expr))
            {
                IAssignExpression iae = context.FindAncestor<IAssignExpression>();
                if (iae.Expression is IArrayCreateExpression)
                    return true;
            }
            return false;
        }

        public bool IsTypeReferenceTo(ITypeReferenceExpression itre, Type type)
        {
            return itre.Type.DotNetType == type;
        }

        public bool IsLiteral(IExpression expr, object val)
        {
            if (expr is ILiteralExpression iLiteralExpression)
            {
                return iLiteralExpression.Value.Equals(val);
            }
            return false;
        }

        public T GetLiteral<T>(IExpression expr)
        {
            if (expr is ILiteralExpression iLiteralExpression)
            {
                return (T)iLiteralExpression.Value;
            }
            return default(T);
        }

        public IVariableDeclaration LoopVariable(IForStatement ifs)
        {
            IStatement ist = ifs.Initializer;
            if (ist is IBlockStatement iBlockStatement)
            {
                if (iBlockStatement.Statements.Count != 1)
                    throw new NotSupportedException("For statement has multi-statement initializer:" + ifs);
                ist = ((IBlockStatement)ist).Statements[0];
            }
            IExpressionStatement init = (IExpressionStatement)ist;
            IAssignExpression iae = (IAssignExpression)init.Expression;
            IVariableDeclaration ivd = GetVariableDeclaration(iae.Target);
            return ivd;
        }

        public IExpression LoopSizeExpression(IForStatement loop)
        {
            if (loop.Condition is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.LessThan)
                {
                    return ibe.Right;
                }
                else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                {
                    var start = LoopStartExpression(loop);
                    if (start is IBinaryExpression ibe2)
                    {
                        if (ibe2.Operator == BinaryOperator.Subtract)
                        {
                            return ibe2.Left;
                        }
                    }
                }
                throw new ArgumentException("Unrecognized loop syntax");
            }
            else
            {
                throw new ArgumentException("Loop condition is not a BinaryExpression");
            }
        }

        public IStatement LoopBreakStatement(IForStatement loop)
        {
            return Builder.AssignStmt(Builder.VarRefExpr(LoopVariable(loop)), LoopBreakExpression(loop));
        }

        private IExpression LoopBreakExpression(IForStatement loop)
        {
            if (loop.Condition is IBinaryExpression ibe)
            {
                if (ibe.Operator == BinaryOperator.LessThan)
                    return Builder.BinaryExpr(BinaryOperator.Subtract, ibe.Right, Builder.LiteralExpr(1));
                else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                    return ibe.Right;
                else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                    return ibe.Right;
                else if (ibe.Operator == BinaryOperator.GreaterThan)
                    return Builder.BinaryExpr(BinaryOperator.Add, ibe.Right, Builder.LiteralExpr(1));
                else
                    throw new ArgumentException($"Unrecognized loop condition: {ibe}");
            }
            else
            {
                throw new ArgumentException("Loop condition is not a BinaryExpression");
            }
        }

        public IExpression LoopStartExpression(IForStatement loop)
        {
            if (loop.Initializer is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    return iae.Expression;
                }
            }
            throw new ArgumentException("Loop initializer is not an assignment");
        }

        public class Bounds
        {
            public int lowerBound = int.MinValue, upperBound = int.MaxValue;

            public bool Contains(int value)
            {
                return (value >= lowerBound) && (value <= upperBound);
            }

            public override string ToString()
            {
                return String.Format("[{0},{1}]", lowerBound, upperBound);
            }
        }

        public void AddLoopBounds(Dictionary<IVariableDeclaration, Bounds> bounds, IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                IVariableDeclaration loopVar = LoopVariable(ifs);
                Bounds b;
                if (!bounds.TryGetValue(loopVar, out b))
                {
                    b = new Bounds();
                    bounds[loopVar] = b;
                }
                IExpression start = LoopStartExpression(ifs);
                if (start is ILiteralExpression iLiteralExpression)
                {
                    int startValue = (int)iLiteralExpression.Value;
                    b.lowerBound = System.Math.Max(b.lowerBound, startValue);
                }
                IExpression size = LoopSizeExpression(ifs);
                if (size is ILiteralExpression iLiteralExpression)
                {
                    int endValue = (int)iLiteralExpression.Value - 1;
                    b.upperBound = System.Math.Min(b.upperBound, endValue);
                }
                if (ifs.Body.Statements.Count == 1)
                    AddLoopBounds(bounds, ifs.Body.Statements[0]);
            }
            else if (ist is IConditionStatement ics)
            {
                IExpression condition = ics.Condition;
                if (condition is IBinaryExpression ibe)
                {
                    if (ibe.Left is IVariableReferenceExpression)
                    {
                        IVariableDeclaration loopVar = GetVariableDeclaration(ibe.Left);
                        Bounds b;
                        if (!bounds.TryGetValue(loopVar, out b))
                        {
                            b = new Bounds();
                            bounds[loopVar] = b;
                        }
                        if (ibe.Left.GetExpressionType().Equals(typeof(int)) && ibe.Right is ILiteralExpression)
                        {
                            int value = (int)((ILiteralExpression)ibe.Right).Value;
                            if (ibe.Operator == BinaryOperator.GreaterThan)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value + 1);
                            }
                            else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThan)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value - 1);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueEquality)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueInequality)
                            {
                                if (b.lowerBound == value)
                                    b.lowerBound++;
                                if (b.upperBound == value)
                                    b.upperBound--;
                            }
                        }
                    }
                    if (ibe.Right is IVariableReferenceExpression)
                    {
                        IVariableDeclaration loopVar = GetVariableDeclaration(ibe.Right);
                        Bounds b;
                        if (!bounds.TryGetValue(loopVar, out b))
                        {
                            b = new Bounds();
                            bounds[loopVar] = b;
                        }
                        if (ibe.Right.GetExpressionType().Equals(typeof(int)) && ibe.Left is ILiteralExpression)
                        {
                            int value = (int)((ILiteralExpression)ibe.Left).Value;
                            if (ibe.Operator == BinaryOperator.GreaterThan)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value - 1);
                            }
                            else if (ibe.Operator == BinaryOperator.GreaterThanOrEqual)
                            {
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThanOrEqual)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.LessThan)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value + 1);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueEquality)
                            {
                                b.lowerBound = System.Math.Max(b.lowerBound, value);
                                b.upperBound = System.Math.Min(b.upperBound, value);
                            }
                            else if (ibe.Operator == BinaryOperator.ValueInequality)
                            {
                                if (b.lowerBound == value)
                                    b.lowerBound++;
                                if (b.upperBound == value)
                                    b.upperBound--;
                            }
                        }
                    }
                }
                if (ics.Then.Statements.Count == 1)
                    AddLoopBounds(bounds, ics.Then.Statements[0]);
            }
        }

        internal Set<ConditionBinding> GetBindings(IStatement stmt)
        {
            var bounds = new Dictionary<IVariableDeclaration, Bounds>(ReferenceEqualityComparer<IVariableDeclaration>.Instance);
            AddLoopBounds(bounds, stmt);
            var bindings = new Set<ConditionBinding>();
            foreach (var entry in bounds)
            {
                var b = entry.Value;
                if (b.lowerBound == b.upperBound)
                {
                    var binding = new ConditionBinding(Builder.VarRefExpr(entry.Key), Builder.LiteralExpr(b.lowerBound));
                    bindings.Add(binding);
                }
            }
            return bindings;
        }

        internal Set<ConditionBinding> GetBindings(IStatement ist, Set<IVariableDeclaration> localVars)
        {
            Set<ConditionBinding> bindings = new Set<ConditionBinding>();
            while (true)
            {
                if (ist is IForStatement ifs)
                {
                    IVariableDeclaration loopVar = LoopVariable(ifs);
                    if (localVars != null)
                        localVars.Add(loopVar);
                    IExpression start = LoopStartExpression(ifs);
                    if (IsForwardLoop(ifs))
                    {
                        bindings.Add(new ConditionBinding(Builder.BinaryExpr(Builder.VarRefExpr(loopVar), BinaryOperator.GreaterThanOrEqual, start)));
                    }
                    bindings.Add(new ConditionBinding(ifs.Condition));
                    if (ifs.Body.Statements.Count == 1)
                        ist = ifs.Body.Statements[0];
                    else
                        break;
                }
                else if (ist is IConditionStatement ics)
                {
                    bindings.Add(new ConditionBinding(ics.Condition));
                    if (ics.Then.Statements.Count == 1)
                        ist = ics.Then.Statements[0];
                    else
                        break;
                }
                else
                    break;
            }
            return bindings;
        }

        /// <summary>
        /// Returns true if any of the reference expressions refer to the specified index variable.
        /// </summary>
        /// <param name="refs"></param>
        /// <param name="indexVar"></param>
        /// <returns></returns>
        public bool IsIndexedBy(List<IVariableReferenceExpression> refs, IVariableDeclaration indexVar)
        {
            foreach (IArrayIndexerExpression iaie in refs)
            {
                foreach (IExpression indExpr in iaie.Indices)
                {
                    IVariableDeclaration ivd2 = ((IVariableReferenceExpression)indExpr).Variable.Resolve();
                    if (indexVar.Equals(ivd2))
                        return true;
                }
            }
            return false;
        }

        public IExpression StripIndexers(IExpression expr)
        {
            return StripIndexers(expr, false);
        }

        public IExpression StripIndexers(IExpression expr, bool varsOnly)
        {
            if (!(expr is IArrayIndexerExpression iaie))
                return expr;
            if ((!(iaie.Indices[0] is IVariableReferenceExpression)) && varsOnly)
                return expr;
            return StripIndexers(iaie.Target, varsOnly);
        }

        public IExpression StripFieldsAndProperties(IExpression expr)
        {
            if (expr is IPropertyReferenceExpression ipre)
                return ipre.Target;
            else if (expr is IFieldReferenceExpression ifre)
                return ifre.Target;
            else
                return expr;
        }

        public bool IsNewObject(IExpression expr, Type type)
        {
            if (!(expr is IObjectCreateExpression ioce))
                return false;
            Type t = Builder.ToType(ioce.Type);
            return t.Equals(type);
        }

        /// <summary>
        /// Returns true if the first expression is equal to, or a subarray or element of the second expression.
        /// For example, x, x[0], x[0][0] are all subarrays of x, but x[1] is not part of x[0].
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="arrayExpr"></param>
        /// <returns></returns>
        public bool IsPartOf(IExpression expr, IExpression arrayExpr)
        {
            while (true)
            {
                if (arrayExpr.Equals(expr))
                    return true;
                if (expr is IArrayIndexerExpression iaie)
                    expr = iaie.Target;
                else
                {
                    IExpression oldexpr = expr;
                    expr = StripFieldsAndProperties(expr);
                    if (object.ReferenceEquals(oldexpr, expr))
                        return false;
                }
            }
        }

        /// <summary>
        /// Extracts the declaration of the parameter reference from a, possibly indexed, argument reference expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IParameterDeclaration GetParameterDeclaration(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IArgumentReferenceExpression iare)
                return iare.Parameter.Resolve();
            else
                return null;
        }

        /// <summary>
        /// Extracts the field reference from a, possibly indexed, field reference expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IFieldReference GetFieldReference(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IFieldReferenceExpression ifre)
                return ifre.Field;
            else
                return null;
        }

        /// <summary>
        /// Extracts the variable declaration from a, possibly indexed, reference or declaration expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IVariableDeclaration GetVariableDeclaration(IExpression expr)
        {
            expr = GetTarget(expr);
            if (expr is IVariableReferenceExpression ivre)
                return ivre.Variable.Resolve();
            else if (expr is IVariableDeclarationExpression ivde)
                return ivde.Variable;
            else
                return null;
        }

        /// <summary>
        /// Extracts the variable or parameter declaration from a, possibly indexed, reference or declaration expression.
        /// Returns null if the expression is not either of these.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public object GetDeclaration(IExpression expr)
        {
            object decl = GetVariableDeclaration(expr);
            if (decl != null)
                return decl;
            decl = GetParameterDeclaration(expr);
            if (decl != null)
                return decl;
            return GetFieldReference(expr);
        }

        public object GetArrayDeclaration(IExpression expr)
        {
            expr = StripIndexers(expr);
            if (expr is IVariableReferenceExpression ivre)
                return ivre.Variable.Resolve();
            else if (expr is IVariableDeclarationExpression ivde)
                return ivde.Variable;
            else if (expr is IArgumentReferenceExpression iare)
                return iare.Parameter.Resolve();
            else if (expr is IFieldReferenceExpression ifre)
                return ifre.Field.Resolve();
            else if (expr is IPropertyReferenceExpression ipre)
                return ipre.Property.Resolve();
            else
                return null;
        }

        /// <summary>
        /// Get the innermost target of an expression, e.g. x[0].field[1].method(y) returns 'x'
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IExpression GetTarget(IExpression expr)
        {
            IExpression target = null;
            ForEachPrefix(expr, prefix =>
            {
                if (target == null) target = prefix;
            });
            return target;
        }

        /// <summary>
        /// Get a list of prefixes of the given expression, starting from the innermost target, up to and including the given expression.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public List<IExpression> GetAllPrefixes(IExpression expr)
        {
            List<IExpression> result = new List<IExpression>();
            ForEachPrefix(expr, result.Add);
            return result;
        }

        private void ForEachPrefix(IExpression expr, Action<IExpression> action)
        {
            // This method must be kept consistent with GetTargets.
            if (expr is IArrayIndexerExpression iaie)
                ForEachPrefix(iaie.Target, action);
            else if (expr is IAddressOutExpression iaoe)
                ForEachPrefix(iaoe.Expression, action);
            else if (expr is IPropertyReferenceExpression ipre)
                ForEachPrefix(ipre.Target, action);
            else if (expr is IFieldReferenceExpression ifre)
            {
                IExpression target = ifre.Target;
                if (!(target is IThisReferenceExpression))
                    ForEachPrefix(target, action);
            }
            else if (expr is ICastExpression ice)
                ForEachPrefix(ice.Expression, action);
            else if (expr is IPropertyIndexerExpression ipie)
                ForEachPrefix(ipie.Target, action);
            else if (expr is IEventReferenceExpression iere)
                ForEachPrefix(iere.Target, action);
            else if (expr is IUnaryExpression iue)
                ForEachPrefix(iue.Expression, action);
            else if (expr is IAddressReferenceExpression iare)
                ForEachPrefix(iare.Expression, action);
            else if (expr is IMethodInvokeExpression imie)
                ForEachPrefix(imie.Method, action);
            else if (expr is IMethodReferenceExpression imre)
                ForEachPrefix(imre.Target, action);
            else if (expr is IDelegateInvokeExpression idie)
                ForEachPrefix(idie.Target, action);
            action(expr);
        }

        /// <summary>
        /// Get all variable references in an expression.  The same variable may appear more than once.
        /// </summary>
        /// <param name="expr">Any expression</param>
        /// <returns></returns>
        public IEnumerable<IVariableDeclaration> GetVariables(IExpression expr)
        {
            foreach(var decl in GetVariablesAndParameters(expr))
            {
                if (decl is IVariableDeclaration ivd)
                    yield return ivd;
            }
        }

        /// <summary>
        /// Get all variable and parameter references in an expression.  The same variable may appear more than once.
        /// </summary>
        /// <param name="expr">Any expression</param>
        /// <returns></returns>
        public IEnumerable<object> GetVariablesAndParameters(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in iaie.Indices)
                {
                    foreach (var decl in GetVariablesAndParameters(index))
                    {
                        yield return decl;
                    }
                }
                foreach (var decl in GetVariablesAndParameters(iaie.Target))
                    yield return decl;
            }
            else if (expr is IMethodInvokeExpression imie)
            {
                foreach (IExpression arg in imie.Arguments)
                {
                    foreach (var decl in GetVariablesAndParameters(arg))
                        yield return decl;
                }
            }
            else if (expr is IBinaryExpression ibe)
            {
                foreach (var decl in GetVariablesAndParameters(ibe.Left))
                    yield return decl;
                foreach (var decl in GetVariablesAndParameters(ibe.Right))
                    yield return decl;
            }
            else if (expr is IUnaryExpression iue)
            {
                foreach (var decl in GetVariablesAndParameters(iue.Expression))
                    yield return decl;
            }
            else if (expr is IPropertyIndexerExpression ipie)
            {
                foreach (IExpression index in ipie.Indices)
                    foreach (var decl in GetVariablesAndParameters(index))
                        yield return decl;
                foreach (var decl in GetVariablesAndParameters(ipie.Target))
                    yield return decl;
            }
            else if (expr is IObjectCreateExpression ioce)
            {
                foreach (IExpression arg in ioce.Arguments)
                    foreach (var decl in GetVariablesAndParameters(arg))
                        yield return decl;
            }
            else if (expr is IAssignExpression iae)
            {
                foreach (var decl in GetVariablesAndParameters(iae.Expression))
                    yield return decl;
                foreach (var decl in GetVariablesAndParameters(iae.Target))
                    yield return decl;
            }
            else
            {
                object decl = GetDeclaration(expr);
                if (decl != null)
                    yield return decl;
            }
        }

        public IEnumerable<IArgumentReferenceExpression> GetArgumentReferenceExpressions(IExpression expr)
        {
            if (expr is IArgumentReferenceExpression are)
                yield return are;
            else if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in iaie.Indices)
                    foreach (var iare in GetArgumentReferenceExpressions(index))
                        yield return iare;
                foreach (var iare in GetArgumentReferenceExpressions(iaie.Target))
                    yield return iare;
            }
            else if (expr is IUnaryExpression iue)
            {
                foreach (var iare in GetArgumentReferenceExpressions(iue.Expression))
                    yield return iare;
            }
            else if (expr is IBinaryExpression ibe)
            {
                foreach (var iare in GetArgumentReferenceExpressions(ibe.Left))
                    yield return iare;
                foreach (var iare in GetArgumentReferenceExpressions(ibe.Right))
                    yield return iare;
            }
        }

        public IEnumerable<IExpression> GetConditionAndTargetIndexExpressions(IStatement stmt)
        {
            if (stmt is IConditionStatement ics)
            {
                yield return ics.Condition;
                foreach (var expr in GetConditionAndTargetIndexExpressions(ics.Then))
                    yield return expr;
            }
            else if (stmt is IForStatement ifs)
            {
                foreach (var expr in GetConditionAndTargetIndexExpressions(ifs.Body))
                    yield return expr;
            }
            else if (stmt is IBlockStatement ibs)
            {
                foreach (IStatement ist in ibs.Statements)
                {
                    foreach (var expr in GetConditionAndTargetIndexExpressions(ist))
                        yield return expr;
                }
            }
            else if (stmt is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    // target indices are considered "conditions" for this purpose
                    foreach (var index in GetFlattenedIndices(iae.Target))
                        yield return index;
                }
            }
        }

        /// <summary>
        /// Get every expression on the lhs of an assignment.
        /// </summary>
        /// <param name="ist"></param>
        public IEnumerable<IExpression> GetTargets(IStatement ist)
        {
            if (ist is IExpressionStatement ies)
            {
                IExpression expr = ies.Expression;
                if (expr is IAssignExpression)
                {
                    IAssignExpression iae = (IAssignExpression)ies.Expression;
                    yield return iae.Target;
                }
                else if (expr is IVariableDeclarationExpression)
                {
                    yield return expr;
                }
            }
            else if (ist is IConditionStatement ics)
            {
                foreach (IStatement st in ics.Then.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
            else if (ist is IForStatement ifs)
            {
                foreach (IStatement st in ifs.Body.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
            else if (ist is IWhileStatement iws)
            {
                foreach (IStatement st in iws.Body.Statements)
                {
                    foreach (var expr in GetTargets(st))
                        yield return expr;
                }
            }
        }

        /// <summary>
        /// Apply action to every variable on the lhs of an assignment.
        /// </summary>
        /// <param name="ist"></param>
        public IEnumerable<IVariableDeclaration> GetTargetVariables(IStatement ist)
        {
            foreach (IExpression target in GetTargets(ist))
            {
                IVariableDeclaration ivd = GetVariableDeclaration(target);
                if (ivd != null)
                    yield return ivd;
            }
        }

        /// <summary>
        /// Extracts the variable declaration from a declaration statement.
        /// Returns null if the statement is not a declaration statement.
        /// </summary>
        /// <param name="ist"></param>
        /// <returns></returns>
        public IVariableDeclaration GetVariableDeclaration(IStatement ist)
        {
            if (ist is IExpressionStatement ies)
            {
                if (ies.Expression is IVariableDeclarationExpression ivde)
                    return ivde.Variable;
                else if (ies.Expression is IAssignExpression iae)
                {
                    if (iae.Target is IVariableDeclarationExpression ivde2)
                        return ivde2.Variable;
                }
            }
            return null;
        }

        /// <summary>
        /// Returns the number of indexing brackets at the end of expr (zero if none)
        /// </summary>
        /// <param name="iexpr"></param>
        /// <returns></returns>
        public int GetIndexingDepth(IExpression iexpr)
        {
            if (iexpr is IArrayIndexerExpression iaie)
                return 1 + GetIndexingDepth(iaie.Target);
            else
                return 0;
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning disable 429
#endif

        /// <summary>
        /// Add the declarations of all loop variables in expr to indVars.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="indVars"></param>
        /// <param name="expr"></param>
        public void AddIndexers(BasicTransformContext context, List<IVariableDeclaration[]> indVars, IExpression expr)
        {
            if (expr is IVariableReferenceExpression)
                return;
            if (expr is IVariableDeclarationExpression)
                return;
            if (expr is IArgumentReferenceExpression)
                return;
            if (expr is IArrayIndexerExpression iaie)
            {
                IVariableDeclaration[] vars = new IVariableDeclaration[iaie.Indices.Count];
                for (int i = 0; i < vars.Length; i++)
                {
                    IVariableDeclaration ivd = GetVariableDeclaration(iaie.Indices[i]);
                    if (ivd != null && GetLoopForVariable(context, ivd) != null)
                        vars[i] = ivd;
                }
                AddIndexers(context, indVars, iaie.Target);
                indVars.Add(vars);
                return;
            }
            throw new NotImplementedException("Unsupported expression type in AddIndexers(): " + expr.GetType());
        }

#if SUPPRESS_UNREACHABLE_CODE_WARNINGS
#pragma warning restore 429
#endif

        private IEnumerable<IExpression> GetFlattenedIndices(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                foreach (IExpression index in GetFlattenedIndices(iaie.Target))
                    yield return index;
                foreach (IExpression index in iaie.Indices)
                    yield return index;
            }
        }

        /// <summary>
        /// Get a list of all index expressions at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
        public List<IList<IExpression>> GetIndices(IExpression expr)
        {
            IExpression target;
            return GetIndices(expr, out target);
        }

        /// <summary>
        /// Get a list of all index expressions at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr"></param>
        /// <param name="target">On exit, the innermost expression being indexed, i.e. the array variable</param>
        /// <returns>A list of indexing brackets, where each bracket is a collection of index expressions</returns>
        public List<IList<IExpression>> GetIndices(IExpression expr, out IExpression target)
        {
            List<IList<IExpression>> indices = new List<IList<IExpression>>();
            target = ForEachIndexingBracket(expr, indices.Add);
            return indices;
        }

        /// <summary>
        /// Apply action to all indexing brackets at the end of expr, innermost first.
        /// </summary>
        /// <param name="expr">The expression</param>
        /// <param name="action"></param>
        /// <returns>The innermost expression</returns>
        private IExpression ForEachIndexingBracket(IExpression expr, Action<IList<IExpression>> action)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                var target = ForEachIndexingBracket(iaie.Target, action);
                action(iaie.Indices);
                return target;
            }
            else
                return expr;
        }

        /// <summary>
        /// Remove the last index from an expression
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        public IExpression RemoveLastIndex(IExpression expr)
        {
            if (expr is IArrayIndexerExpression iaie)
            {
                if (iaie.Target is IArrayIndexerExpression)
                {
                    IArrayIndexerExpression aie = Builder.ArrayIndxrExpr();
                    aie.Indices.AddRange(iaie.Indices);
                    aie.Target = RemoveLastIndex(iaie.Target);
                    return aie;
                }
                else return iaie.Target;
            }
            else
            {
                return expr;
            }
        }

        /// <summary>
        /// Returns the for statement associated with the specified loop counter or null if none
        /// </summary>
        /// <param name="context"></param>
        /// <param name="loopRef"></param>
        /// <returns></returns>
        internal IForStatement GetLoopForVariable(BasicTransformContext context, IVariableReferenceExpression loopRef)
        {
            return GetLoopForVariable(context, GetVariableDeclaration(loopRef));
        }

        internal IForStatement GetLoopForVariable(BasicTransformContext context, IVariableDeclaration ivd, object excludeAncestor = null)
        {
            foreach (TransformInfo ti in context.InputStack)
            {
                if (ti.inputElement == excludeAncestor)
                    break;
                if (ti.inputElement is IForStatement loop)
                {
                    IVariableDeclaration loopVd = LoopVariable(loop);
                    if (ivd.Name == loopVd.Name)
                        return loop;
                }
            }
            return null;
        }

        public bool IsForwardLoop(IForStatement ifs)
        {
            if (ifs.Increment is IExpressionStatement ies)
            {
                if (ies.Expression is IAssignExpression iae)
                {
                    if (ChannelTransform.RemoveCast(iae.Expression) is IBinaryExpression ibe)
                    {
                        if (ibe.Operator == BinaryOperator.Add)
                        {
                            if (ibe.Right is ILiteralExpression ile)
                            {
                                if (ile.Value is int)
                                    return ((int)ile.Value >= 0);
                            }
                        }
                        else if (ibe.Operator == BinaryOperator.Subtract)
                        {
                            if (ibe.Right is ILiteralExpression ile)
                            {
                                if (ile.Value is int)
                                    return ((int)ile.Value < 0);
                            }
                        }
                    }
                }
                else if (ies.Expression is IUnaryExpression iue)
                {
                    return (iue.Operator == UnaryOperator.PostIncrement) || (iue.Operator == UnaryOperator.PreIncrement);
                }
            }
            throw new Exception("Unexpected loop increment");
        }


        // Convert a for loop of the form:
        //    for (int i = 0; i < N; i++) { ... }
        // to
        //    for (int i = N - 1; i >= 0; i--) { ... }
        // and vice versa.
        public void ReverseLoopDirection(IForStatement loop)
        {
            // For now, make strong assumption that the for loop is of standard form:
            //   for (<var> = <literal>; <var> <comp> <literal>; <var> <increment/decrement>)
            if (!(loop.Condition is IBinaryExpression))
                throw new ArgumentException("Loop condition is not a binary expression: " + loop.Condition);
            IBinaryExpression condition = (IBinaryExpression)loop.Condition;
            IExpressionStatement increment = (IExpressionStatement)loop.Increment;
            if (!(increment.Expression is IUnaryExpression))
            {
                throw new ArgumentException("Cannot reverse a for loop with increment: " + increment);
            }
            IUnaryExpression incrementExpr = (IUnaryExpression)increment.Expression;
            UnaryOperator unaryOp;
            if (incrementExpr.Operator == UnaryOperator.PostIncrement || incrementExpr.Operator == UnaryOperator.PreIncrement)
                unaryOp = UnaryOperator.PostDecrement;
            else if (incrementExpr.Operator == UnaryOperator.PostDecrement || incrementExpr.Operator == UnaryOperator.PreDecrement)
                unaryOp = UnaryOperator.PostIncrement;
            else
            {
                throw new ArgumentException("Cannot reverse a for loop with increment operator " + incrementExpr.Operator.ToString());
            }
            loop.Increment = Builder.ExprStatement(Builder.UnaryExpr(unaryOp, incrementExpr.Expression));
            if (!condition.Left.Equals(incrementExpr.Expression))
                throw new ArgumentException("Loop condition does not have loop variable on the left");
            IExpressionStatement initializer = (IExpressionStatement)loop.Initializer;
            IAssignExpression initAssignExpr = (IAssignExpression)initializer.Expression;
            IExpression initializationExpression = initAssignExpr.Expression;

            if (condition.Operator == BinaryOperator.LessThan)
            {
                // Construct a new binary expression that takes the old condition RHS and subtracts one.
                // This becomes the new initializer.
                IBinaryExpression newInitializationExpression = Builder.BinaryExpr(condition.Right, BinaryOperator.Subtract, Builder.LiteralExpr(1));
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, newInitializationExpression);
            }
            else if (condition.Operator == BinaryOperator.LessThanOrEqual ||
                condition.Operator == BinaryOperator.GreaterThanOrEqual)
            {
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, condition.Right);
            }
            else if (condition.Operator == BinaryOperator.GreaterThan)
            {
                IBinaryExpression newInitializationExpression = Builder.BinaryExpr(condition.Right, BinaryOperator.Add, Builder.LiteralExpr(1));
                loop.Initializer = Builder.AssignStmt(initAssignExpr.Target, newInitializationExpression);
            }
            else
            {
                throw new ArgumentException("Loop condition is not reversible: " + condition);
            }
            if (condition.Operator == BinaryOperator.LessThan ||
                condition.Operator == BinaryOperator.LessThanOrEqual)
            {
                loop.Condition = Builder.BinaryExpr(condition.Left, BinaryOperator.GreaterThanOrEqual, initializationExpression);
            }
            else
            {
                IBinaryExpression ibe = (IBinaryExpression)initializationExpression;
                if (ibe.Operator != BinaryOperator.Subtract ||
                   !ibe.Right.Equals(Builder.LiteralExpr(1)))
                    throw new ArgumentException("Initializer expression is not a subtraction: " + initializationExpression);
                loop.Condition = Builder.BinaryExpr(condition.Left, BinaryOperator.LessThan, ibe.Left);
            }
        }

        /// <summary>
        /// Returns the number of nested for loops in the deepest part of the statement.
        /// </summary>
        /// <param name="ist"></param>
        /// <returns></returns>
        public int ForLoopDepth(IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                return 1 + ForLoopDepth(ifs.Body);
            }
            else if (ist is IBlockStatement ibs)
            {
                int maxLoopDepth = 0;
                foreach (var st in ibs.Statements)
                {
                    int stDepth = ForLoopDepth(st);
                    if (stDepth > maxLoopDepth)
                    {
                        maxLoopDepth = stDepth;
                    }
                }
                return maxLoopDepth;
            }
            else if (ist is IConditionStatement ics)
            {
                return ForLoopDepth(ics.Then);
            }
            else
            {
                return 0;
            }
        }


        public IExpressionStatement FirstExpressionStatement(IStatement ist)
        {
            if (ist is IForStatement ifs)
            {
                foreach (var st in ifs.Body.Statements)
                {
                    if (!(st is ICommentStatement))
                    {
                        return FirstExpressionStatement(st);
                    }
                }
            }
            else if (ist is IConditionStatement ics)
            {
                foreach (var st in ics.Then.Statements)
                {
                    if (!(st is ICommentStatement))
                    {
                        return FirstExpressionStatement(st);
                    }
                }
            }
            else if (ist is IExpressionStatement ies)
            {
                return ies;
            }
            return null;
            //throw new Exception("Didn't find expression statement");
        }

        // Convert < to >=, <= to >, == to !=, etc.
        public bool TryNegateOperator(BinaryOperator op, out BinaryOperator negatedOp)
        {
            BinaryOperator[,] pairs = new BinaryOperator[,] {
            { BinaryOperator.LessThanOrEqual, BinaryOperator.GreaterThan },
            { BinaryOperator.GreaterThanOrEqual, BinaryOperator.LessThan },
            { BinaryOperator.ValueEquality, BinaryOperator.ValueInequality },
            { BinaryOperator.IdentityEquality, BinaryOperator.IdentityInequality }
        };

            for (int i = 0; i < pairs.GetLength(0); i++)
            {
                if (op == pairs[i, 0])
                {
                    negatedOp = pairs[i, 1];
                    return true;
                }
                else if (op == pairs[i, 1])
                {
                    negatedOp = pairs[i, 0];
                    return true;
                }
            }
            negatedOp = default(BinaryOperator);
            return false;
        }

        /// <summary>
        /// Returns true if any of the expression are stochastic.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="iec"></param>
        /// <returns></returns>
        internal static bool IsAnyStochastic(BasicTransformContext context, IList<IExpression> iec)
        {
            foreach (IExpression expr in iec) if (IsStochastic(context, expr)) return true;
            return false;
        }

        /// <summary>
        /// Returns true if the expression is stochastic.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="expr"></param>
        /// <returns></returns>
        internal static bool IsStochastic(BasicTransformContext context, IExpression expr)
        {
            if (expr is ILiteralExpression) return false;
            if (expr is IDefaultExpression) return false;
            if (expr is IMethodInvokeExpression imie)
            {
                bool stochArgs = IsAnyStochastic(context, imie.Arguments);
                bool stochFactor = false;
                FactorManager.FactorInfo info = GetFactorInfo(context, imie);
                if (info != null) stochFactor = !info.IsDeterministicFactor;
                bool st = stochArgs || stochFactor;
                //if (st) context.OutputAttributes.Set(imie, new Stochastic()); // for IfCuttingTransform
                return st;
            }
            if (expr is IArgumentReferenceExpression) return false;
            if (expr is IPropertyReferenceExpression ipre) return IsStochastic(context, ipre.Target);
            if (expr is IFieldReferenceExpression ifre) return IsStochastic(context, ifre.Target);
            if (expr is IArrayCreateExpression) return false;
            if (expr is IObjectCreateExpression ioce)
            {
                return IsAnyStochastic(context, ioce.Arguments);
            }
            if (expr is IUnaryExpression iue)
            {
                return IsStochastic(context, iue.Expression);
            }
            if (expr is IBinaryExpression ibe)
            {
                return IsStochastic(context, ibe.Left) || IsStochastic(context, ibe.Right);
            }
            if (expr is IArrayIndexerExpression iaie)
            {
                return IsStochastic(context, iaie.Target) || IsAnyStochastic(context, iaie.Indices);
            }
            if (expr is ICastExpression iCastExpression) return IsStochastic(context, iCastExpression.Expression);
            if (expr is ICheckedExpression iCheckedExpression) return IsStochastic(context, iCheckedExpression.Expression);
            if (expr is IPropertyIndexerExpression ipie)
            {
                return IsStochastic(context, ipie.Target) || IsAnyStochastic(context, ipie.Indices);
            }
            if (expr is IAddressDereferenceExpression) return false;
            if (expr is IAddressOutExpression iaoe) return IsStochastic(context, iaoe.Expression);
            if (expr is ILambdaExpression) return false; // todo: stochastic case?
            if (expr is IAnonymousMethodExpression) return false;
            if (expr is ITypeOfExpression) return false;

            IVariableDeclaration ivd = Instance.GetVariableDeclaration(expr);
            if (ivd == null)
            {
                context.Error("Could not find stochasticity of expression of type " + expr.GetType().Name + ": " + expr);
                return false;
            }
            return IsStochastic(context, ivd);
        }

        internal static bool IsStochastic(BasicTransformContext context, IVariableDeclaration ivd)
        {
            VariableInformation vi = VariableInformation.GetVariableInformation(context, ivd);
            return vi.IsStochastic;
        }

        internal static bool IsInfer(IExpression expr)
        {
            return Instance.IsStaticMethod(expr, new Action<object>(InferNet.Infer)) ||
                   Instance.IsStaticMethod(expr, new Action<object, string>(InferNet.Infer)) ||
                   Instance.IsStaticMethod(expr, new Action<object, string, QueryType>(InferNet.Infer));
        }

        internal static bool IsIsIncreasing(IExpression expr)
        {
            return Instance.IsStaticMethod(expr, new Func<int,bool>(InferNet.IsIncreasing));
        }

        internal static FactorManager.FactorInfo GetFactorInfo(BasicTransformContext context, IMethodInvokeExpression imie)
        {
            if (!context.InputAttributes.Has<FactorManager.FactorInfo>(imie))
            {
                if (Instance.IsStaticMethod(imie, typeof(InferNet))) return null;
                MethodInfo methodInfo = (MethodInfo)Builder.ToMethodThrows(imie.Method.Method);
                if (methodInfo == null) return null;
                FactorManager.FactorInfo info = FactorManager.GetFactorInfo(methodInfo);
                context.InputAttributes.Set(imie, info);
            }
            return context.InputAttributes.Get<FactorManager.FactorInfo>(imie);
        }

        /// <summary>
        /// Removes a cast when it is safe to do so.
        /// </summary>
        /// <param name="expr"></param>
        /// <returns></returns>
        internal static IExpression RemoveCast(IExpression expr)
        {
            // used to remove spurious casts
            if (expr is ICastExpression ice)
            {
                if (expr.GetExpressionType().IsAssignableFrom(ice.Expression.GetExpressionType()))
                {
                    return ice.Expression;
                }
            }
            return expr;
        }
    }

#if SUPPRESS_XMLDOC_WARNINGS
#pragma warning restore 1591
#endif
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs(10,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs(342,62): error CS0136: A local or parameter named 'iLiteralExpression' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs(1306,48): error CS0128: A local variable or function named 'iLiteralExpression' is already defined in this scope,D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs(1308,41): error CS0165: Use of unassigned local variable 'iLiteralExpression',D:\a\1\s\src\Compiler\TransformFramework\CodeRecognizer.cs(10,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Serialization;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace Microsoft.ML.Probabilistic.Compiler
{
    /// <summary>
    /// Provides static methods for quoting objects into instances of the code model.
    /// </summary>
    public static class Quoter
    {
        /// <summary>
        /// Helps build expressions
        /// </summary>
        private static CodeBuilder Builder = CodeBuilder.Instance;

        /// <summary>
        /// Quotes the object and returns the quoted expression.
        /// </summary>
        /// <param name="value">The object to quote</param>
        /// <returns>An expression which would evaluate to the supplied value.</returns>
        public static IExpression Quote(object value)
        {
            if (value == null) return Builder.LiteralExpr(value);
            IExpression expr = null;

            if (TryQuoteConstructable(value, out expr)) return expr;

            if (value is Microsoft.ML.Probabilistic.Distributions.Kernels.NNKernel)
            {
                // todo: change this to use ConstructionAttribute
                Microsoft.ML.Probabilistic.Distributions.Kernels.NNKernel g = (Microsoft.ML.Probabilistic.Distributions.Kernels.NNKernel) value;
                expr = Builder.NewObject(value.GetType(), Quote(g.GetLogWeightVariances()), Quote(g.GetLogBiasWeightVariance()));
            }
            else if (value is Array)
            {
                expr = QuoteArray((Array) value);
            }
            else if (value is ConvertibleToArray)
            {
                expr = Builder.NewObject(value.GetType(), QuoteArray(((ConvertibleToArray) value).ToArray()));
            }
            else if (value is IList)
            {
                expr = QuoteList((IList) value);
            }
            else if (value is IDictionary)
            {
                expr = QuoteDictionary((IDictionary) value);
            }
            else if (value is Enum)
            {
                expr = Builder.LiteralExpr(value);
            }
            else if (value is PropertyInfo)
            {
                expr = QuotePropertyInfo((PropertyInfo) value);
            }
            else if (value is System.Linq.Expressions.Expression)
            {
                var expconv = new Microsoft.ML.Probabilistic.Compiler.Transforms.LinqExpressionTransform();
                expr = expconv.Convert((System.Linq.Expressions.Expression) value);
            }
            else if (value is DateTime)
            {
                DateTime dt = (DateTime) value;
                var args = new List<int> {dt.Year, dt.Month, dt.Day};
                if ((dt.Hour != 0) || (dt.Minute != 0) || (dt.Second != 0) || (dt.Millisecond != 0))
                {
                    args.Add(dt.Hour);
                    args.Add(dt.Minute);
                    args.Add(dt.Second);
                    if (dt.Millisecond != 0) args.Add(dt.Millisecond);
                }
                var argsArray = new IExpression[args.Count];
                for (int i = 0; i < args.Count; i++) argsArray[i] = Builder.LiteralExpr(args[i]);
                expr = Builder.NewObject(typeof (DateTime), argsArray);
            }
            else
            {
                Type t = value.GetType();
                if (t.IsGenericType)
                {
                    Type gt = t.GetGenericTypeDefinition();
                    if (gt.Equals(typeof (List<>)))
                    {
                        expr = (IExpression) Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(typeof (Quoter), "QuoteList", value);
                    }
                    else if (gt == typeof (GibbsMarginal<,>))
                    {
                        expr = (IExpression) Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(typeof (Quoter), "QuoteGibbsEstimator", value);
                    }
                }
                else
                    // See if this is an estimator
                    expr = QuoteEstimator(value);
                if (expr == null) expr = ExpressionEvaluator.Quote(value);
            }

            if (expr == null)
                throw new NotImplementedException("Cannot quote '" + value + "' - consider adding a ConstructionAttribute to the appropriate constructor of type " +
                                                  value.GetType() + ".");
            return expr;
        }

        /// <summary>
        /// Trys to quote an object using any Construction attributes that it is
        /// annotated with.
        /// </summary>
        /// <remarks>
        /// This method can be used to quote a different object that the one passed in, by using
        /// 'useWhenOverride'.  For example, setting it to 'IsUniform' will mean that the value will
        /// be quoted as if 'IsUniform' were true.  In general, this will result in quoting the closest
        /// value that meets the specified condition.
        /// </remarks>
        /// <param name="value">The value to quote</param>
        /// <param name="expr">The quoted expression or null if quoting failed</param>
        /// <param name="useWhenOverride">Overrides which construction attribute to use, to quote
        /// <param name="valueType">The type of the value to quote or null to use value.GetType()</param>
        /// the object passed in modified to have the condition be true</param>
        /// <returns>True if the quoting succeeded</returns>
        internal static bool TryQuoteConstructable(object value, out IExpression expr, string useWhenOverride = null, Type valueType = null)
        {
            if (valueType == null) valueType = value.GetType();
            // Automated quoting using the 'Construction' attribute
            var cas = ConstructionAttribute.GetConstructionAttribute(valueType);
            expr = null;
            foreach (var ca in cas)
            {
                if (useWhenOverride == null)
                {
                    if (!ca.IsApplicable(value)) continue;
                }
                else
                {
                    if (!Equals(ca.UseWhen, useWhenOverride)) continue;
                }
                IExpression[] pars = new IExpression[ca.Params == null ? 0 : ca.Params.Length];

                // If we don't have an object instance, we cannot quote
                // construction methods that take parameters.
                if ((pars.Length > 0) && (value == null)) return false;

                for (int i = 0; i < pars.Length; i++)
                {
                    Type type;
                    object paramValue = ca.GetParamValue(i, value, out type);
                    // Use default(T) instead of null, so that type information is preserved.
                    pars[i] = (paramValue == null) ? Builder.DefaultExpr(type) : Quote(paramValue);
                }
                if (ca.TargetMember is ConstructorInfo)
                {
                    // We need to use a constructor
                    expr = Builder.NewObject(value.GetType(), pars);
                }
                else
                {
                    // We need to use a factory method
                    expr = Builder.StaticMethod((MethodInfo) ca.TargetMember, pars);
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// When quoting objects whose types are not public, the quoted expression
        /// must have a different type.  If the passed in type is not public, this method 
        /// returns the public type that it will be quoted as.  If it is public, the type
        /// argument will be returned as is.
        /// </summary>
        /// <param name="tp"></param>
        /// <returns></returns>
        internal static Type GetPublicType(Type tp)
        {
            if (typeof (PropertyInfo).IsAssignableFrom(tp)) return typeof (PropertyInfo);
            return tp;
        }

        /// <summary>
        /// Whether constants of this type should be inlined as literals, rather that
        /// put in a single place.
        /// </summary>
        /// <param name="tp"></param>
        /// <returns></returns>
        internal static bool ShouldInlineType(Type tp)
        {
            return (tp.IsPrimitive || tp.IsEnum || tp == typeof (string));
        }

        private static IExpression QuotePropertyInfo(PropertyInfo propertyInfo)
        {
            // Make a typeof() expression
            var typeOfExpr = Builder.TypeOf(Builder.TypeRef(propertyInfo.DeclaringType));
            // Call GetProperty() on it, passing in the name
            var getProp = Builder.Method(typeOfExpr, typeof (Type).GetMethod("GetProperty", new Type[] {typeof (string)}), Builder.LiteralExpr(propertyInfo.Name));
            return getProp;
        }

        public static IExpression QuoteDictionary(IDictionary dictionary)
        {
            var newDict = Builder.NewObject(dictionary.GetType());
            var init = Builder.BlockExpr();
            foreach (DictionaryEntry entry in dictionary)
            {
                var entryBlock = Builder.BlockExpr();
                entryBlock.Expressions.Add(Quote(entry.Key));
                entryBlock.Expressions.Add(Quote(entry.Value));
                init.Expressions.Add(entryBlock);
            }
            newDict.Initializer = init;
            return newDict;
        }

        public static IExpression QuoteList(IList list)
        {
            var newList = Builder.NewObject(list.GetType());
            var be = Builder.BlockExpr();
            foreach (var obj in list)
            {
                be.Expressions.Add(Quote(obj));
            }
            if (be.Expressions.Count > 0)
            {
                newList.Initializer = be;
            }
            return newList;
        }

        public static IExpression[] QuoteItems<T>(ICollection<T> list)
        {
            IExpression[] result = new IExpression[list.Count];
            int i = 0;
            foreach (T item in list)
            {
                result[i++] = Quote(item);
            }
            return result;
        }

        // copied from ExpressionEvaluator.cs
        public static IExpression QuoteArray(Array array)
        {
            IArrayCreateExpression ace = Builder.ArrayCreateExpr(array.GetType().GetElementType());
            for (int i = 0; i < array.Rank; i++) ace.Dimensions.Add(Builder.LiteralExpr(array.GetLength(i)));
            ace.Initializer = Builder.BlockExpr();
            if (array.Rank == 1)
            {
                foreach (object obj in array)
                {
                    IExpression objExpr = Quote(obj);
                    if (objExpr == null) return null;
                    ace.Initializer.Expressions.Add(objExpr);
                }
                return ace;
            }
            if (array.Rank == 2)
            {
                for (int i = 0; i < array.GetLength(0); i++)
                {
                    IBlockExpression be = Builder.BlockExpr();
                    ace.Initializer.Expressions.Add(be);
                    for (int j = 0; j < array.GetLength(1); j++)
                    {
                        IExpression objExpr = Quote(array.GetValue(i, j));
                        if (objExpr == null) return null;
                        be.Expressions.Add(objExpr);
                    }
                }
                return ace;
            }
            return null;
        }

        // Quote an estimator expression
        public static IExpression QuoteEstimator(object value)
        {
            // todo: remove and use Construction attributes
            IExpression expr = null;
            if (value is BernoulliEstimator)
            {
                BernoulliEstimator g = (BernoulliEstimator) value;
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is DirichletEstimator)
            {
                DirichletEstimator g = (DirichletEstimator) value;
                expr = Builder.NewObject(value.GetType(), Quote((g.Dimension)));
            }
            else if (value is DiscreteEstimator)
            {
                DiscreteEstimator g = (DiscreteEstimator) value;
                expr = Builder.NewObject(value.GetType(), Quote((g.Dimension)));
            }
            else if (value is GammaEstimator)
            {
                GammaEstimator g = (GammaEstimator) value;
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is GaussianEstimator)
            {
                GaussianEstimator g = (GaussianEstimator) value;
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is VectorGaussianEstimator)
            {
                VectorGaussianEstimator g = (VectorGaussianEstimator) value;
                expr = Builder.NewObject(value.GetType(), Quote(g.Dimension));
            }
            else if (value is WishartEstimator)
            {
                WishartEstimator g = (WishartEstimator) value;
                expr = Builder.NewObject(value.GetType(), Quote(g.Dimension));
            }

            return expr;
        }
    }
}
---- Transformed Tree ----
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Serialization;
using Microsoft.ML.Probabilistic.Utilities;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace Microsoft.ML.Probabilistic.Compiler
{
    /// <summary>
    /// Provides static methods for quoting objects into instances of the code model.
    /// </summary>
    public static class Quoter
    {
        /// <summary>
        /// Helps build expressions
        /// </summary>
        private static CodeBuilder Builder = CodeBuilder.Instance;

        /// <summary>
        /// Quotes the object and returns the quoted expression.
        /// </summary>
        /// <param name="value">The object to quote</param>
        /// <returns>An expression which would evaluate to the supplied value.</returns>
        public static IExpression Quote(object value)
        {
            if (value == null) return Builder.LiteralExpr(value);
            IExpression expr = null;

            if (TryQuoteConstructable(value, out expr)) return expr;

            if (value is Microsoft.ML.Probabilistic.Distributions.Kernels.NNKernel g)
            {
                // todo: change this to use ConstructionAttribute
                expr = Builder.NewObject(value.GetType(), Quote(g.GetLogWeightVariances()), Quote(g.GetLogBiasWeightVariance()));
            }
            else if (value is Array array)
            {
                expr = QuoteArray(array);
            }
            else if (value is ConvertibleToArray convertibleToArray)
            {
                expr = Builder.NewObject(value.GetType(), QuoteArray(convertibleToArray.ToArray()));
            }
            else if (value is IList iList)
            {
                expr = QuoteList(iList);
            }
            else if (value is IDictionary iDictionary)
            {
                expr = QuoteDictionary(iDictionary);
            }
            else if (value is Enum)
            {
                expr = Builder.LiteralExpr(value);
            }
            else if (value is PropertyInfo propertyInfo)
            {
                expr = QuotePropertyInfo(propertyInfo);
            }
            else if (value is System.Linq.Expressions.Expression expression)
            {
                var expconv = new Microsoft.ML.Probabilistic.Compiler.Transforms.LinqExpressionTransform();
                expr = expconv.Convert(expression);
            }
            else if (value is DateTime dt)
            {
                var args = new List<int> {dt.Year, dt.Month, dt.Day};
                if ((dt.Hour != 0) || (dt.Minute != 0) || (dt.Second != 0) || (dt.Millisecond != 0))
                {
                    args.Add(dt.Hour);
                    args.Add(dt.Minute);
                    args.Add(dt.Second);
                    if (dt.Millisecond != 0) args.Add(dt.Millisecond);
                }
                var argsArray = new IExpression[args.Count];
                for (int i = 0; i < args.Count; i++) argsArray[i] = Builder.LiteralExpr(args[i]);
                expr = Builder.NewObject(typeof (DateTime), argsArray);
            }
            else
            {
                Type t = value.GetType();
                if (t.IsGenericType)
                {
                    Type gt = t.GetGenericTypeDefinition();
                    if (gt.Equals(typeof (List<>)))
                    {
                        expr = (IExpression) Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(typeof (Quoter), "QuoteList", value);
                    }
                    else if (gt == typeof (GibbsMarginal<,>))
                    {
                        expr = (IExpression) Microsoft.ML.Probabilistic.Compiler.Reflection.Invoker.InvokeStatic(typeof (Quoter), "QuoteGibbsEstimator", value);
                    }
                }
                else
                    // See if this is an estimator
                    expr = QuoteEstimator(value);
                if (expr == null) expr = ExpressionEvaluator.Quote(value);
            }

            if (expr == null)
                throw new NotImplementedException("Cannot quote '" + value + "' - consider adding a ConstructionAttribute to the appropriate constructor of type " +
                                                  value.GetType() + ".");
            return expr;
        }

        /// <summary>
        /// Trys to quote an object using any Construction attributes that it is
        /// annotated with.
        /// </summary>
        /// <remarks>
        /// This method can be used to quote a different object that the one passed in, by using
        /// 'useWhenOverride'.  For example, setting it to 'IsUniform' will mean that the value will
        /// be quoted as if 'IsUniform' were true.  In general, this will result in quoting the closest
        /// value that meets the specified condition.
        /// </remarks>
        /// <param name="value">The value to quote</param>
        /// <param name="expr">The quoted expression or null if quoting failed</param>
        /// <param name="useWhenOverride">Overrides which construction attribute to use, to quote
        /// <param name="valueType">The type of the value to quote or null to use value.GetType()</param>
        /// the object passed in modified to have the condition be true</param>
        /// <returns>True if the quoting succeeded</returns>
        internal static bool TryQuoteConstructable(object value, out IExpression expr, string useWhenOverride = null, Type valueType = null)
        {
            if (valueType == null) valueType = value.GetType();
            // Automated quoting using the 'Construction' attribute
            var cas = ConstructionAttribute.GetConstructionAttribute(valueType);
            expr = null;
            foreach (var ca in cas)
            {
                if (useWhenOverride == null)
                {
                    if (!ca.IsApplicable(value)) continue;
                }
                else
                {
                    if (!Equals(ca.UseWhen, useWhenOverride)) continue;
                }
                IExpression[] pars = new IExpression[ca.Params == null ? 0 : ca.Params.Length];

                // If we don't have an object instance, we cannot quote
                // construction methods that take parameters.
                if ((pars.Length > 0) && (value == null)) return false;

                for (int i = 0; i < pars.Length; i++)
                {
                    Type type;
                    object paramValue = ca.GetParamValue(i, value, out type);
                    // Use default(T) instead of null, so that type information is preserved.
                    pars[i] = (paramValue == null) ? Builder.DefaultExpr(type) : Quote(paramValue);
                }
                if (ca.TargetMember is ConstructorInfo)
                {
                    // We need to use a constructor
                    expr = Builder.NewObject(value.GetType(), pars);
                }
                else
                {
                    // We need to use a factory method
                    expr = Builder.StaticMethod((MethodInfo) ca.TargetMember, pars);
                }
                return true;
            }
            return false;
        }

        /// <summary>
        /// When quoting objects whose types are not public, the quoted expression
        /// must have a different type.  If the passed in type is not public, this method 
        /// returns the public type that it will be quoted as.  If it is public, the type
        /// argument will be returned as is.
        /// </summary>
        /// <param name="tp"></param>
        /// <returns></returns>
        internal static Type GetPublicType(Type tp)
        {
            if (typeof (PropertyInfo).IsAssignableFrom(tp)) return typeof (PropertyInfo);
            return tp;
        }

        /// <summary>
        /// Whether constants of this type should be inlined as literals, rather that
        /// put in a single place.
        /// </summary>
        /// <param name="tp"></param>
        /// <returns></returns>
        internal static bool ShouldInlineType(Type tp)
        {
            return (tp.IsPrimitive || tp.IsEnum || tp == typeof (string));
        }

        private static IExpression QuotePropertyInfo(PropertyInfo propertyInfo)
        {
            // Make a typeof() expression
            var typeOfExpr = Builder.TypeOf(Builder.TypeRef(propertyInfo.DeclaringType));
            // Call GetProperty() on it, passing in the name
            var getProp = Builder.Method(typeOfExpr, typeof (Type).GetMethod("GetProperty", new Type[] {typeof (string)}), Builder.LiteralExpr(propertyInfo.Name));
            return getProp;
        }

        public static IExpression QuoteDictionary(IDictionary dictionary)
        {
            var newDict = Builder.NewObject(dictionary.GetType());
            var init = Builder.BlockExpr();
            foreach (DictionaryEntry entry in dictionary)
            {
                var entryBlock = Builder.BlockExpr();
                entryBlock.Expressions.Add(Quote(entry.Key));
                entryBlock.Expressions.Add(Quote(entry.Value));
                init.Expressions.Add(entryBlock);
            }
            newDict.Initializer = init;
            return newDict;
        }

        public static IExpression QuoteList(IList list)
        {
            var newList = Builder.NewObject(list.GetType());
            var be = Builder.BlockExpr();
            foreach (var obj in list)
            {
                be.Expressions.Add(Quote(obj));
            }
            if (be.Expressions.Count > 0)
            {
                newList.Initializer = be;
            }
            return newList;
        }

        public static IExpression[] QuoteItems<T>(ICollection<T> list)
        {
            IExpression[] result = new IExpression[list.Count];
            int i = 0;
            foreach (T item in list)
            {
                result[i++] = Quote(item);
            }
            return result;
        }

        // copied from ExpressionEvaluator.cs
        public static IExpression QuoteArray(Array array)
        {
            IArrayCreateExpression ace = Builder.ArrayCreateExpr(array.GetType().GetElementType());
            for (int i = 0; i < array.Rank; i++) ace.Dimensions.Add(Builder.LiteralExpr(array.GetLength(i)));
            ace.Initializer = Builder.BlockExpr();
            if (array.Rank == 1)
            {
                foreach (object obj in array)
                {
                    IExpression objExpr = Quote(obj);
                    if (objExpr == null) return null;
                    ace.Initializer.Expressions.Add(objExpr);
                }
                return ace;
            }
            if (array.Rank == 2)
            {
                for (int i = 0; i < array.GetLength(0); i++)
                {
                    IBlockExpression be = Builder.BlockExpr();
                    ace.Initializer.Expressions.Add(be);
                    for (int j = 0; j < array.GetLength(1); j++)
                    {
                        IExpression objExpr = Quote(array.GetValue(i, j));
                        if (objExpr == null) return null;
                        be.Expressions.Add(objExpr);
                    }
                }
                return ace;
            }
            return null;
        }

        // Quote an estimator expression
        public static IExpression QuoteEstimator(object value)
        {
            // todo: remove and use Construction attributes
            IExpression expr = null;
            if (value is BernoulliEstimator g)
            {
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is DirichletEstimator g)
            {
                expr = Builder.NewObject(value.GetType(), Quote((g.Dimension)));
            }
            else if (value is DiscreteEstimator g)
            {
                expr = Builder.NewObject(value.GetType(), Quote((g.Dimension)));
            }
            else if (value is GammaEstimator g)
            {
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is GaussianEstimator g)
            {
                expr = Builder.NewObject(value.GetType());
            }
            else if (value is VectorGaussianEstimator g)
            {
                expr = Builder.NewObject(value.GetType(), Quote(g.Dimension));
            }
            else if (value is WishartEstimator g)
            {
                expr = Builder.NewObject(value.GetType(), Quote(g.Dimension));
            }

            return expr;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(8,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(292,50): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(296,49): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(300,46): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(304,49): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(308,55): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(312,48): error CS0136: A local or parameter named 'g' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\Compiler\TransformFramework\Quoter.cs(8,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 10 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;

namespace Microsoft.ML.Probabilistic.Compiler
{
    public class MethodBodySynthesizer
    {
        private static CodeBuilder Builder = CodeBuilder.Instance;

        private SemanticModel model;
        private IType declaringType;
        private Dictionary<string, ITypeDeclaration> typeDecls;

        private MethodBodySynthesizer(SemanticModel model, IType declaringType, Dictionary<string, ITypeDeclaration> typeDecls)
        {
            this.model = model;
            this.declaringType = declaringType;
            this.typeDecls = typeDecls;
        }

        public static void SynthesizeBody(IMethodDeclaration methodDecl, MethodDeclarationSyntax methodSyntax, SemanticModel model, Dictionary<string, ITypeDeclaration> typeDecls)
        {
            var synthesizer = new MethodBodySynthesizer(model, methodDecl.DeclaringType, typeDecls);
            synthesizer.SynthesizeBody(methodDecl, methodSyntax);
        }

        private void SynthesizeBody(IMethodDeclaration methodDecl, MethodDeclarationSyntax methodSyntax)
        {
            pdCache.Clear();
            vdCache.Clear();
            foreach (var paramDecl in methodDecl.Parameters)
            {
                pdCache[paramDecl.Name] = paramDecl;
            }
            if (methodSyntax.Body != null)
                methodDecl.Body = ConvertBlock(methodSyntax.Body);
            pdCache.Clear();
            vdCache.Clear();
        }

        private IType ConvertTypeReference(ITypeSymbol typeSymbol)
        {
            return TypeSymbolConverter.ConvertTypeReference(typeSymbol, model.Compilation.Assembly, declaringType.DotNetType.Assembly);
        }

        private Type ConvertTypeSymbolToType(ITypeSymbol typeSymbol)
        {
            return TypeSymbolConverter.ConvertTypeSymbolToType(typeSymbol, model.Compilation.Assembly, declaringType.DotNetType.Assembly);
        }

        private IBlockStatement ConvertBlock(BlockSyntax block)
        {
            var bs = Builder.BlockStmt();
            foreach (var st in block.Statements)
            {
                var st2 = ConvertStatement(st);
                if (st2 != null) bs.Statements.Add(st2);
            }
            return bs;
        }

        private IBlockStatement ConvertBlock(StatementSyntax statement)
        {
            if (statement is BlockSyntax)
            {
                return ConvertBlock((BlockSyntax)statement);
            }
            var bs = Builder.BlockStmt();
            var st2 = ConvertStatement(statement);
            bs.Statements.Add(st2);
            return bs;
        }

        private IStatement ConvertStatement(StatementSyntax statement)
        {
            if (statement is LocalDeclarationStatementSyntax)
            {
                return ConvertLocalDeclarationStatement((LocalDeclarationStatementSyntax)statement);
            }
            if (statement is ExpressionStatementSyntax)
            {
                return ConvertExpressionStatement((ExpressionStatementSyntax)statement);
            }
            if (statement is IfStatementSyntax)
            {
                return ConvertIfStatement((IfStatementSyntax)statement);
            }
            if (statement is ForStatementSyntax)
            {
                return ConvertForStatement((ForStatementSyntax)statement);
            }
            if (statement is BlockSyntax)
            {
                return ConvertBlock((BlockSyntax)statement);
            }
            if (statement is UsingStatementSyntax)
            {
                return ConvertUsingStatement((UsingStatementSyntax)statement);
            }
            if (statement is EmptyStatementSyntax)
            {
                return new XBlockStatement();
            }
            if (statement is TryStatementSyntax)
            {
                throw new NotSupportedException("Unsupported statement type: " + statement);
            }
            if (statement is ThrowStatementSyntax)
            {
                var tts = (ThrowStatementSyntax)statement;
                return Builder.ThrowStmt(ConvertExpression(tts.Expression));
            }
            if (statement is ReturnStatementSyntax)
            {
                return ConvertReturnStatement((ReturnStatementSyntax)statement);
            }
            throw new NotSupportedException("Unsupported statement type: " + statement);
        }

        private IMethodReturnStatement ConvertReturnStatement(ReturnStatementSyntax rss)
        {
            var mrs = Builder.MethodRtrnStmt();
            mrs.Expression = ConvertExpression(rss.Expression);
            return mrs;
        }

        private IStatement ConvertUsingStatement(UsingStatementSyntax usingStatement)
        {
            var ixst = new XUsingStatement();
            ixst.Expression = usingStatement.Declaration != null ?
                ConvertVariableDeclaration(usingStatement.Declaration) :
                ConvertExpression(usingStatement.Expression);
            ixst.Body = ConvertBlock(usingStatement.Statement);
            return ixst;
        }

        private IStatement ConvertForStatement(ForStatementSyntax forStatement)
        {
            var variableDecl = ConvertVariableDeclaration(forStatement.Declaration);
            var forStmt = new XForStatement();
            forStmt.Body = ConvertBlock(forStatement.Statement);
            forStmt.Condition = ConvertExpression(forStatement.Condition);
            var incrementors = forStatement.Incrementors.Select(i => ConvertExpression(i)).ToList();
            var initializers = forStatement.Initializers.Select(i => ConvertExpression(i)).ToList();
            forStmt.Increment = new XExpressionStatement { Expression = incrementors.Single() };
            forStmt.Initializer = new XExpressionStatement { Expression = variableDecl };
            // TODO complete this
            return forStmt;
        }

        private IStatement ConvertIfStatement(IfStatementSyntax ifStatement)
        {
            var condition = ConvertExpression(ifStatement.Condition);
            var statement = ConvertBlock(ifStatement.Statement);
            if (ifStatement.Else == null || ifStatement.Else.Statement == null)
            {
                return Builder.CondStmt(condition, statement);
            }
            var elseStmt = ConvertBlock(ifStatement.Else.Statement);
            return Builder.CondStmt(condition, statement, elseStmt);
        }

        private IStatement ConvertExpressionStatement(ExpressionStatementSyntax expressionStatement)
        {
            var expr = ConvertExpression(expressionStatement.Expression);
            return Builder.ExprStatement(expr);
        }

        private IStatement ConvertLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement)
        {
            var es = Builder.ExprStatement();
            es.Expression = ConvertVariableDeclaration(localDeclarationStatement.Declaration);
            return es;
        }

        private IExpression ConvertVariableDeclaration(VariableDeclarationSyntax variableDeclaration)
        {
            if (variableDeclaration.Variables.Count != 1) throw new NotSupportedException("Multiple variable declarations not supported");
            var variableDeclarator = variableDeclaration.Variables.First();
            var vd = Builder.VarDecl();
            vd.Name = variableDeclarator.Identifier.ValueText;
            vd.VariableType = ConvertTypeReference(model.GetTypeInfo(variableDeclaration.Type).Type);
            vdCache[vd.Name] = vd;
            var vde = Builder.VarDeclExpr(vd);
            if (variableDeclarator.Initializer != null)
            {
                return Builder.AssignExpr(vde, ConvertExpression(variableDeclarator.Initializer.Value));
            }
            return vde;
        }

        private IExpression ConvertExpression(ExpressionSyntax expression)
        {
            if (expression is InvocationExpressionSyntax)
            {
                return ConvertInvocation((InvocationExpressionSyntax)expression);
            }
            if (expression is LiteralExpressionSyntax)
            {
                return ConvertLiteral((LiteralExpressionSyntax)expression);
            }
            if (expression is MemberAccessExpressionSyntax)
            {
                return ConvertMemberAccess((MemberAccessExpressionSyntax)expression);
            }
            if (expression is IdentifierNameSyntax)
            {
                return ConvertIdentifierName((IdentifierNameSyntax)expression);
            }
            if (expression is BinaryExpressionSyntax)
            {
                return ConvertBinary((BinaryExpressionSyntax)expression);
            }
            if (expression is ObjectCreationExpressionSyntax)
            {
                return ConvertCreation((ObjectCreationExpressionSyntax)expression);
            }
            if (expression is ElementAccessExpressionSyntax)
            {
                return ConvertElementAccess((ElementAccessExpressionSyntax)expression);
            }
            if (expression is ArrayCreationExpressionSyntax)
            {
                return ConvertArrayCreation((ArrayCreationExpressionSyntax)expression);
            }
            if (expression is ParenthesizedExpressionSyntax)
            {
                var pes = (ParenthesizedExpressionSyntax)expression;
                return ConvertExpression(pes.Expression);
            }
            if (expression is GenericNameSyntax)
            {
                var genericNameSyntax = (GenericNameSyntax)expression;
                var typeSymbol = model.GetTypeInfo(genericNameSyntax).Type;
                var typeReferenceExpression = new XTypeReferenceExpression();
                // TODO why is the horrible cast required?
                typeReferenceExpression.Type = (ITypeReference)ConvertTypeReference(typeSymbol);
                return typeReferenceExpression;
            }
            if (expression is ConditionalExpressionSyntax)
            {
                return ConvertConditionalExpression((ConditionalExpressionSyntax)expression);
            }
            if (expression is CastExpressionSyntax)
            {
                var castExpressionSyntax = (CastExpressionSyntax)expression;
                var typeSymbol = model.GetTypeInfo(castExpressionSyntax).Type;
                var castExpression = new XCastExpression();
                castExpression.Expression = ConvertExpression(castExpressionSyntax.Expression);
                castExpression.TargetType = ConvertTypeReference(typeSymbol);
                return castExpression;
            }
            if (expression is PostfixUnaryExpressionSyntax)
            {
                var syntax = (PostfixUnaryExpressionSyntax)expression;
                var ixe = new XUnaryExpression();
                ixe.Expression = ConvertExpression(syntax.Operand);
                switch (syntax.Kind())
                {
                    // TODO complete this list and factor out
                    case SyntaxKind.PostIncrementExpression:
                        ixe.Operator = UnaryOperator.PostIncrement;
                        break;
                    case SyntaxKind.PostDecrementExpression:
                        ixe.Operator = UnaryOperator.PostDecrement;
                        break;
                    default:
                        throw new NotSupportedException("Operator " + syntax.OperatorToken.RawKind);
                }
                return ixe;
            }
            if (expression is PrefixUnaryExpressionSyntax)
            {
                var syntax = (PrefixUnaryExpressionSyntax)expression;
                var ixe = new XUnaryExpression();
                ixe.Expression = ConvertExpression(syntax.Operand);
                switch (syntax.Kind())
                {
                    // TODO complete this list and factor out
                    case SyntaxKind.LogicalNotExpression:
                        ixe.Operator = UnaryOperator.BooleanNot;
                        break;
                    case SyntaxKind.UnaryMinusExpression:
                        if (syntax.Operand is LiteralExpressionSyntax)
                        {
                            var les = (LiteralExpressionSyntax)syntax.Operand;
                            if (les.Token.IsKind(SyntaxKind.NumericLiteralToken))
                            {
                                var typeInfo = model.GetTypeInfo(syntax);
                                var val = les.Token.Value;
                                var newType = ConvertTypeReference(typeInfo.ConvertedType).DotNetType;
                                val = Convert.ChangeType(val, newType);
                                ixe.Expression = Builder.LiteralExpr(val);
                            }
                        }
                        ixe.Operator = UnaryOperator.Negate;
                        break;
                    default:
                        throw new NotSupportedException("Operator " + syntax.Kind());
                }
                return ixe;
            }
            if (expression is InitializerExpressionSyntax)
            {
                var syntax = (InitializerExpressionSyntax)expression;
                var exprs = syntax.Expressions.Select(expr => ConvertExpression(expr)).ToList();
                var block = new XBlockExpression();
                block.Expressions.AddRange(exprs);
                return block;
            }
            if (expression is TypeOfExpressionSyntax)
            {
                var syntax = (TypeOfExpressionSyntax)expression;
                var expr = Builder.TypeOfExpr();
                var typeSymbol = model.GetTypeInfo(syntax.Type).Type;
                expr.Type = ConvertTypeReference(typeSymbol);
                return expr;
            }
            if (expression is TypeSyntax)
            {
                var typeSymbol = model.GetTypeInfo(expression).Type;
                return Builder.TypeRefExpr(ConvertTypeReference(typeSymbol));
            }
            if (expression is AssignmentExpressionSyntax assgnExpr)
            {
                var expr = Builder.AssignExpr();
                expr.Target = ConvertExpression(assgnExpr.Left);
                expr.Expression = ConvertExpression(assgnExpr.Right);
                return expr;
            }
            if (expression is CheckedExpressionSyntax checkedExpr)
            {
                var expr = Builder.CheckedExpr();
                expr.Expression = ConvertExpression(checkedExpr.Expression);
                return expr;
            }
            throw new NotSupportedException("Unsupported expression type: " + expression);
        }

        private IExpression ConvertConditionalExpression(ConditionalExpressionSyntax conditionalExpression)
        {
            var ixe = new XConditionExpression();
            ixe.Condition = ConvertExpression(conditionalExpression.Condition);
            ixe.Else = ConvertExpression(conditionalExpression.WhenFalse);
            ixe.Then = ConvertExpression(conditionalExpression.WhenTrue);
            return ixe;
        }

        private IExpression ConvertArrayCreation(ArrayCreationExpressionSyntax creationExpression)
        {
            var ixe = new XArrayCreateExpression();
            var arrayType = (IArrayTypeSymbol)model.GetTypeInfo(creationExpression).Type;
            ixe.Type = ConvertTypeReference(arrayType.ElementType);

            if (creationExpression.Initializer == null)
            {
                foreach (var size in creationExpression.Type.RankSpecifiers.First().Sizes)
                {
                    ixe.Dimensions.Add(ConvertExpression(size));
                }
                return ixe;
            }

            var arrayInitSyntax = creationExpression.Initializer;
            while (arrayInitSyntax != null)
            {
                ixe.Dimensions.Add(new XLiteralExpression { Value = arrayInitSyntax.Expressions.Count });
                if (arrayInitSyntax.Expressions.Count == 0) break;
                var firstExpr = arrayInitSyntax.Expressions.First();
                arrayInitSyntax = firstExpr as InitializerExpressionSyntax;
            }
            var initializers = creationExpression.Initializer.Expressions.Select(expr => ConvertExpression(expr)).ToList();
            ixe.Initializer = new XBlockExpression();
            ixe.Initializer.Expressions.AddRange(initializers);
            return ixe;
        }

        private IExpression ConvertElementAccess(ElementAccessExpressionSyntax accessExpression)
        {
            var ixe = new XArrayIndexerExpression();
            foreach (var indx in accessExpression.ArgumentList.Arguments)
            {
                ixe.Indices.Add(ConvertExpression(indx.Expression));
            }
            ixe.Target = ConvertExpression(accessExpression.Expression);
            return ixe;
        }

        private IExpression ConvertCreation(ObjectCreationExpressionSyntax creationExpression)
        {
            var symbol = (IMethodSymbol)model.GetSymbolInfo(creationExpression).Symbol;
            if (symbol == null)
            {
                throw new Exception("Could not bind");
            }

            var type = ConvertTypeReference(symbol.ContainingType);
            var args = creationExpression.ArgumentList != null ?
                creationExpression.ArgumentList.Arguments.Select(arg => ConvertExpression(arg.Expression)).ToArray() :
                null;

            var objCreateExpr = Builder.ObjCreateExpr();
            objCreateExpr.Type = type;
            if (args != null)
            {
                objCreateExpr.Arguments.AddRange(args);
            }

            // TODO probably need to worry about param arrays and emit explicit array creation here
            var paramTypes = symbol.Parameters.Select(p => ConvertTypeSymbolToType(p.Type)).ToArray();
            var dotNetType = ConvertTypeSymbolToType(symbol.ContainingType);
            objCreateExpr.Constructor = Builder.ConstructorRef(dotNetType, paramTypes);

            return objCreateExpr;
        }

        private IExpression ConvertBinary(BinaryExpressionSyntax binaryExpression)
        {
            var left = ConvertExpression(binaryExpression.Left);
            var right = ConvertExpression(binaryExpression.Right);
            switch (binaryExpression.Kind())
            {
                case SyntaxKind.SimpleAssignmentExpression:
                    return Builder.AssignExpr(left, right);
                case SyntaxKind.AddAssignmentExpression:
                    return Builder.AssignExpr(left, Builder.BinaryExpr(BinaryOperator.Add, left, right));
                default:
                    return Builder.BinaryExpr(left, ConvertOperator(binaryExpression.Kind()), right);
            }
        }

        private BinaryOperator ConvertOperator(SyntaxKind kind)
        {
            switch (kind)
            {
                case SyntaxKind.EqualsExpression:
                    // TODO value or identity equality?
                    return BinaryOperator.ValueEquality;
                case SyntaxKind.AddExpression:
                    return BinaryOperator.Add;
                case SyntaxKind.SubtractExpression:
                    return BinaryOperator.Subtract;
                case SyntaxKind.MultiplyExpression:
                    return BinaryOperator.Multiply;
                case SyntaxKind.DivideExpression:
                    return BinaryOperator.Divide;
                case SyntaxKind.LessThanExpression:
                    return BinaryOperator.LessThan;
                case SyntaxKind.GreaterThanExpression:
                    return BinaryOperator.GreaterThan;
                case SyntaxKind.LessThanOrEqualExpression:
                    return BinaryOperator.LessThanOrEqual;
                case SyntaxKind.GreaterThanOrEqualExpression:
                    return BinaryOperator.GreaterThanOrEqual;
                case SyntaxKind.BitwiseAndExpression:
                    return BinaryOperator.BitwiseAnd;
                case SyntaxKind.BitwiseOrExpression:
                    return BinaryOperator.BitwiseOr;
                case SyntaxKind.LogicalOrExpression:
                    return BinaryOperator.BooleanOr;
                case SyntaxKind.LogicalAndExpression:
                    return BinaryOperator.BooleanAnd;
                default:
                    throw new NotSupportedException("Unsupported operator: " + kind);
            }
        }

        private IExpression ConvertIdentifierName(IdentifierNameSyntax identifierName)
        {
            var info = model.GetSymbolInfo(identifierName);
            var symbol = info.Symbol;
            if (symbol is ITypeSymbol)
            {
                var tre = Builder.TypeRefExpr();
                tre.Type = (ITypeReference)ConvertTypeReference((ITypeSymbol)symbol);
                return tre;
            }
            if (symbol is ILocalSymbol)
            {
                var varDecl = GetVarDecl((ILocalSymbol)symbol);
                var vre = Builder.VarRefExpr(varDecl);
                return vre;
            }
            if (symbol is IParameterSymbol)
            {
                var paramDecl = GetParamDecl((IParameterSymbol)symbol);
                var vre = Builder.ParamRef(paramDecl);
                return vre;
            }
            if (symbol is IMethodSymbol)
            {
                var methodDecl = GetMethodRef((IMethodSymbol)symbol);
                var mre = Builder.MethodRefExpr();
                mre.Method = methodDecl;
                // TODO get the correct target
                mre.Target = Builder.ThisRefExpr();
                return mre;
            }
            if (symbol is IPropertySymbol)
            {
                var propertyDecl = GetPropertyRef((IPropertySymbol)symbol);
                var pre = Builder.PropRefExpr();
                pre.Property = propertyDecl;
                // TODO get the correct target
                pre.Target = Builder.ThisRefExpr();
                return pre;
            }
            throw new NotSupportedException("Unsupported identifier type: " + identifierName);
        }

        private IMethodDeclaration GetMethodRef(IMethodSymbol methodSymbol)
        {
            ITypeDeclaration typeDecl;
            if (typeDecls.TryGetValue(methodSymbol.ContainingType.ToDisplayString(), out typeDecl))
            {
                // TODO hadle overloads
                return typeDecl.Methods.Single(md => md.Name == methodSymbol.Name);
            }

            // TODO construct method ref
            throw new NotSupportedException();
        }

        private IPropertyDeclaration GetPropertyRef(IPropertySymbol propertySymbol)
        {
            // If the prop is on a type that we have a type decl for then return the prop decl
            // else construct and return a prop ref

            ITypeDeclaration typeDecl;
            if (typeDecls.TryGetValue(propertySymbol.ContainingType.ToDisplayString(), out typeDecl))
            {
                return typeDecl.Properties.Single(pd => pd.Name == propertySymbol.Name);
            }

            // TODO construct prop ref
            throw new NotSupportedException();
        }

        Dictionary<string, IVariableDeclaration> vdCache = new Dictionary<string, IVariableDeclaration>();
        private IVariableDeclaration GetVarDecl(ILocalSymbol local)
        {
            // TODO: do this properly
            if (!vdCache.ContainsKey(local.Name))
            {
                throw new Exception("Unknown variable: " + local.Name);
            }
            return vdCache[local.Name];
        }

        Dictionary<string, IParameterDeclaration> pdCache = new Dictionary<string, IParameterDeclaration>();
        private IParameterDeclaration GetParamDecl(IParameterSymbol paramSymbol)
        {
            // TODO: do this properly
            if (!pdCache.ContainsKey(paramSymbol.Name))
            {
                throw new Exception("Unknown parameter: " + paramSymbol.Name);
            }
            return pdCache[paramSymbol.Name];
        }

        private IExpression ConvertMemberAccess(MemberAccessExpressionSyntax memberAccess)
        {
            var symbol = model.GetSymbolInfo(memberAccess.Name).Symbol;
            if (symbol == null)
            {
                throw new NotSupportedException("Couldn't resolve?");
            }

            if (symbol is IMethodSymbol)
            {
                return ConvertMethodReference((IMethodSymbol)symbol, memberAccess);
            }
            if (symbol is IPropertySymbol)
            {
                return ConvertPropertyReference((IPropertySymbol)symbol, memberAccess);
            }
            if (symbol is IFieldSymbol)
            {
                return ConvertFieldReference((IFieldSymbol)symbol, memberAccess);
            }
            if (symbol is INamedTypeSymbol)
            {
                return ConvertNamedType((INamedTypeSymbol)symbol, memberAccess);
            }

            throw new NotSupportedException("Unknown symbol");
        }

        private IExpression ConvertNamedType(INamedTypeSymbol symbol, MemberAccessExpressionSyntax memberAccess)
        {
            var typeRef = (ITypeReference)ConvertTypeReference(symbol);
            return new XTypeReferenceExpression
            {
                Type = typeRef
            };
        }

        private IExpression ConvertFieldReference(IFieldSymbol fieldSymbol, MemberAccessExpressionSyntax memberAccess)
        {
            var fieldRef = new XFieldReference();
            fieldRef.Name = fieldSymbol.Name;
            fieldRef.DeclaringType = ConvertTypeReference(fieldSymbol.ContainingType);
            fieldRef.FieldType = ConvertTypeReference(fieldSymbol.Type);
            // TODO: do this properly
            //fieldRef.MethodInfo = Builder.ToMethodThrows(fieldRef);

            return new XFieldReferenceExpression
            {
                Field = fieldRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IExpression ConvertPropertyReference(IPropertySymbol propSymbol, MemberAccessExpressionSyntax memberAccess)
        {
            var propRef = new XPropertyReference();
            propRef.Name = propSymbol.Name;
            propRef.DeclaringType = ConvertTypeReference(propSymbol.ContainingType);
            propRef.PropertyType = ConvertTypeReference(propSymbol.Type);
            // TODO: do this properly

            return new XPropertyReferenceExpression
            {
                Property = propRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IExpression ConvertMethodReference(IMethodSymbol symbol, MemberAccessExpressionSyntax memberAccess)
        {
            var methodRef = Builder.MethodRef();
            methodRef.Name = symbol.Name;
            methodRef.DeclaringType = ConvertTypeReference(symbol.ContainingType);
            var parTypes = new List<Type>();
            foreach (var par in symbol.Parameters)
            {
                var parameterDecl = ConvertParameter(par);
                methodRef.Parameters.Add(parameterDecl);
                parTypes.Add(Builder.ToType(parameterDecl.ParameterType));
            }
            methodRef.ReturnType = Builder.MethodReturnType(ConvertTypeReference(symbol.ReturnType));
            // TODO genericMethod
            if (symbol.IsGenericMethod)
            {
                var typeArgs = symbol.TypeArguments.Select(ts => ConvertTypeReference(ts)).ToList();
                methodRef.GenericArguments.AddRange(typeArgs);
            }
            // TODO: do this properly
            //methodRef.MethodInfo = Builder.ToType(methodRef.DeclaringType).GetMethod(methodRef.Name, parTypes.ToArray());
            methodRef.MethodInfo = Builder.ToMethodThrows(methodRef);

            return new XMethodReferenceExpression
            {
                Method = methodRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IParameterDeclaration ConvertParameter(IParameterSymbol par)
        {
            var pd = Builder.ParamDecl();
            pd.Name = par.Name;
            pd.ParameterType = ConvertTypeReference(par.Type);
            // TODO: attributes
            return pd;
        }

        private IExpression ConvertLiteral(LiteralExpressionSyntax literalExpression)
        {
            return ConvertConstantExpr(literalExpression);
        }

        private IExpression ConvertConstantExpr(ExpressionSyntax expression)
        {
            var value = model.GetConstantValue(expression);
            var ti = model.GetTypeInfo(expression);
            var val = value.Value;
            if (expression.IsKind(SyntaxKind.NumericLiteralExpression))
            {
                var newType = ConvertTypeReference(ti.ConvertedType).DotNetType;
                val = Convert.ChangeType(val, newType);
            }
            return Builder.LiteralExpr(val);
        }

        private IExpression ConvertInvocation(InvocationExpressionSyntax invocationExpression)
        {
            var c = model.GetConstantValue(invocationExpression);
            if (c.HasValue)
            {
                // compile time constant
                // including nameof(thing)
                return ConvertConstantExpr(invocationExpression);
            }

            var imie = Builder.MethodInvkExpr();
            var methodExpression = invocationExpression.Expression;
            var argumentList = invocationExpression.ArgumentList.Arguments;
            var convertedArgs = argumentList.Select(arg => ConvertExpression(arg.Expression)).ToArray();

            if (argumentList.Any(arg => arg.NameColon != null))
            {
                throw new NotSupportedException("No support yet for named parameters");
            }

            List<IExpression> paramsParameters = null;
            IArrayTypeSymbol paramsType = null;
            var methodSymbol = model.GetSymbolInfo(invocationExpression).Symbol as IMethodSymbol;
            if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
            {
                var lastParam = methodSymbol.Parameters.Last();
                paramsType = lastParam.Type as IArrayTypeSymbol;
                if (lastParam.IsParams && paramsType != null)
                {
                    if (argumentList.Count() == methodSymbol.Parameters.Count())
                    {
                        // one element or array supplied?
                        var ti = model.GetTypeInfo(argumentList.Last().Expression);
                        if (ti.Type is IArrayTypeSymbol == false)
                        {
                            paramsParameters = new List<IExpression>(new[] { convertedArgs.Last() });
                        }
                    }
                    else
                    {
                        paramsParameters = convertedArgs.Skip(methodSymbol.Parameters.Length - 1).ToList();
                    }
                }
            }

            if (paramsParameters != null)
            {
                var ixe = new XArrayCreateExpression();
                ixe.Type = ConvertTypeReference(paramsType.ElementType);
                ixe.Dimensions.Add(new XLiteralExpression { Value = paramsParameters.Count });
                ixe.Initializer = new XBlockExpression();
                ixe.Initializer.Expressions.AddRange(paramsParameters);

                var normalParameterCount = argumentList.Count - paramsParameters.Count;
                imie.Arguments.AddRange(convertedArgs.Take(normalParameterCount));
                imie.Arguments.Add(ixe);
            }
            else
            {
                imie.Arguments.AddRange(convertedArgs);
            }

            imie.Method = (IMethodReferenceExpression)ConvertExpression(methodExpression);
            return imie;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.ML.Probabilistic.Collections;
using Microsoft.ML.Probabilistic.Compiler.CodeModel.Concrete;
using Microsoft.ML.Probabilistic.Compiler.CodeModel;

namespace Microsoft.ML.Probabilistic.Compiler
{
    public class MethodBodySynthesizer
    {
        private static CodeBuilder Builder = CodeBuilder.Instance;

        private SemanticModel model;
        private IType declaringType;
        private Dictionary<string, ITypeDeclaration> typeDecls;

        private MethodBodySynthesizer(SemanticModel model, IType declaringType, Dictionary<string, ITypeDeclaration> typeDecls)
        {
            this.model = model;
            this.declaringType = declaringType;
            this.typeDecls = typeDecls;
        }

        public static void SynthesizeBody(IMethodDeclaration methodDecl, MethodDeclarationSyntax methodSyntax, SemanticModel model, Dictionary<string, ITypeDeclaration> typeDecls)
        {
            var synthesizer = new MethodBodySynthesizer(model, methodDecl.DeclaringType, typeDecls);
            synthesizer.SynthesizeBody(methodDecl, methodSyntax);
        }

        private void SynthesizeBody(IMethodDeclaration methodDecl, MethodDeclarationSyntax methodSyntax)
        {
            pdCache.Clear();
            vdCache.Clear();
            foreach (var paramDecl in methodDecl.Parameters)
            {
                pdCache[paramDecl.Name] = paramDecl;
            }
            if (methodSyntax.Body != null)
                methodDecl.Body = ConvertBlock(methodSyntax.Body);
            pdCache.Clear();
            vdCache.Clear();
        }

        private IType ConvertTypeReference(ITypeSymbol typeSymbol)
        {
            return TypeSymbolConverter.ConvertTypeReference(typeSymbol, model.Compilation.Assembly, declaringType.DotNetType.Assembly);
        }

        private Type ConvertTypeSymbolToType(ITypeSymbol typeSymbol)
        {
            return TypeSymbolConverter.ConvertTypeSymbolToType(typeSymbol, model.Compilation.Assembly, declaringType.DotNetType.Assembly);
        }

        private IBlockStatement ConvertBlock(BlockSyntax block)
        {
            var bs = Builder.BlockStmt();
            foreach (var st in block.Statements)
            {
                var st2 = ConvertStatement(st);
                if (st2 != null) bs.Statements.Add(st2);
            }
            return bs;
        }

        private IBlockStatement ConvertBlock(StatementSyntax statement)
        {
            if (statement is BlockSyntax blockSyntax)
            {
                return ConvertBlock(blockSyntax);
            }
            var bs = Builder.BlockStmt();
            var st2 = ConvertStatement(statement);
            bs.Statements.Add(st2);
            return bs;
        }

        private IStatement ConvertStatement(StatementSyntax statement)
        {
            if (statement is LocalDeclarationStatementSyntax localDeclarationStatementSyntax)
            {
                return ConvertLocalDeclarationStatement(localDeclarationStatementSyntax);
            }
            if (statement is ExpressionStatementSyntax expressionStatementSyntax)
            {
                return ConvertExpressionStatement(expressionStatementSyntax);
            }
            if (statement is IfStatementSyntax ifStatementSyntax)
            {
                return ConvertIfStatement(ifStatementSyntax);
            }
            if (statement is ForStatementSyntax forStatementSyntax)
            {
                return ConvertForStatement(forStatementSyntax);
            }
            if (statement is BlockSyntax blockSyntax)
            {
                return ConvertBlock(blockSyntax);
            }
            if (statement is UsingStatementSyntax usingStatementSyntax)
            {
                return ConvertUsingStatement(usingStatementSyntax);
            }
            if (statement is EmptyStatementSyntax)
            {
                return new XBlockStatement();
            }
            if (statement is TryStatementSyntax)
            {
                throw new NotSupportedException("Unsupported statement type: " + statement);
            }
            if (statement is ThrowStatementSyntax tts)
            {
                return Builder.ThrowStmt(ConvertExpression(tts.Expression));
            }
            if (statement is ReturnStatementSyntax returnStatementSyntax)
            {
                return ConvertReturnStatement(returnStatementSyntax);
            }
            throw new NotSupportedException("Unsupported statement type: " + statement);
        }

        private IMethodReturnStatement ConvertReturnStatement(ReturnStatementSyntax rss)
        {
            var mrs = Builder.MethodRtrnStmt();
            mrs.Expression = ConvertExpression(rss.Expression);
            return mrs;
        }

        private IStatement ConvertUsingStatement(UsingStatementSyntax usingStatement)
        {
            var ixst = new XUsingStatement();
            ixst.Expression = usingStatement.Declaration != null ?
                ConvertVariableDeclaration(usingStatement.Declaration) :
                ConvertExpression(usingStatement.Expression);
            ixst.Body = ConvertBlock(usingStatement.Statement);
            return ixst;
        }

        private IStatement ConvertForStatement(ForStatementSyntax forStatement)
        {
            var variableDecl = ConvertVariableDeclaration(forStatement.Declaration);
            var forStmt = new XForStatement();
            forStmt.Body = ConvertBlock(forStatement.Statement);
            forStmt.Condition = ConvertExpression(forStatement.Condition);
            var incrementors = forStatement.Incrementors.Select(i => ConvertExpression(i)).ToList();
            var initializers = forStatement.Initializers.Select(i => ConvertExpression(i)).ToList();
            forStmt.Increment = new XExpressionStatement { Expression = incrementors.Single() };
            forStmt.Initializer = new XExpressionStatement { Expression = variableDecl };
            // TODO complete this
            return forStmt;
        }

        private IStatement ConvertIfStatement(IfStatementSyntax ifStatement)
        {
            var condition = ConvertExpression(ifStatement.Condition);
            var statement = ConvertBlock(ifStatement.Statement);
            if (ifStatement.Else == null || ifStatement.Else.Statement == null)
            {
                return Builder.CondStmt(condition, statement);
            }
            var elseStmt = ConvertBlock(ifStatement.Else.Statement);
            return Builder.CondStmt(condition, statement, elseStmt);
        }

        private IStatement ConvertExpressionStatement(ExpressionStatementSyntax expressionStatement)
        {
            var expr = ConvertExpression(expressionStatement.Expression);
            return Builder.ExprStatement(expr);
        }

        private IStatement ConvertLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement)
        {
            var es = Builder.ExprStatement();
            es.Expression = ConvertVariableDeclaration(localDeclarationStatement.Declaration);
            return es;
        }

        private IExpression ConvertVariableDeclaration(VariableDeclarationSyntax variableDeclaration)
        {
            if (variableDeclaration.Variables.Count != 1) throw new NotSupportedException("Multiple variable declarations not supported");
            var variableDeclarator = variableDeclaration.Variables.First();
            var vd = Builder.VarDecl();
            vd.Name = variableDeclarator.Identifier.ValueText;
            vd.VariableType = ConvertTypeReference(model.GetTypeInfo(variableDeclaration.Type).Type);
            vdCache[vd.Name] = vd;
            var vde = Builder.VarDeclExpr(vd);
            if (variableDeclarator.Initializer != null)
            {
                return Builder.AssignExpr(vde, ConvertExpression(variableDeclarator.Initializer.Value));
            }
            return vde;
        }

        private IExpression ConvertExpression(ExpressionSyntax expression)
        {
            if (expression is InvocationExpressionSyntax invocationExpressionSyntax)
            {
                return ConvertInvocation(invocationExpressionSyntax);
            }
            if (expression is LiteralExpressionSyntax literalExpressionSyntax)
            {
                return ConvertLiteral(literalExpressionSyntax);
            }
            if (expression is MemberAccessExpressionSyntax memberAccessExpressionSyntax)
            {
                return ConvertMemberAccess(memberAccessExpressionSyntax);
            }
            if (expression is IdentifierNameSyntax identifierNameSyntax)
            {
                return ConvertIdentifierName(identifierNameSyntax);
            }
            if (expression is BinaryExpressionSyntax binaryExpressionSyntax)
            {
                return ConvertBinary(binaryExpressionSyntax);
            }
            if (expression is ObjectCreationExpressionSyntax objectCreationExpressionSyntax)
            {
                return ConvertCreation(objectCreationExpressionSyntax);
            }
            if (expression is ElementAccessExpressionSyntax elementAccessExpressionSyntax)
            {
                return ConvertElementAccess(elementAccessExpressionSyntax);
            }
            if (expression is ArrayCreationExpressionSyntax arrayCreationExpressionSyntax)
            {
                return ConvertArrayCreation(arrayCreationExpressionSyntax);
            }
            if (expression is ParenthesizedExpressionSyntax pes)
            {
                return ConvertExpression(pes.Expression);
            }
            if (expression is GenericNameSyntax genericNameSyntax)
            {
                var typeSymbol = model.GetTypeInfo(genericNameSyntax).Type;
                var typeReferenceExpression = new XTypeReferenceExpression();
                // TODO why is the horrible cast required?
                typeReferenceExpression.Type = (ITypeReference)ConvertTypeReference(typeSymbol);
                return typeReferenceExpression;
            }
            if (expression is ConditionalExpressionSyntax conditionalExpressionSyntax)
            {
                return ConvertConditionalExpression(conditionalExpressionSyntax);
            }
            if (expression is CastExpressionSyntax castExpressionSyntax)
            {
                var typeSymbol = model.GetTypeInfo(castExpressionSyntax).Type;
                var castExpression = new XCastExpression();
                castExpression.Expression = ConvertExpression(castExpressionSyntax.Expression);
                castExpression.TargetType = ConvertTypeReference(typeSymbol);
                return castExpression;
            }
            if (expression is PostfixUnaryExpressionSyntax syntax)
            {
                var ixe = new XUnaryExpression();
                ixe.Expression = ConvertExpression(syntax.Operand);
                switch (syntax.Kind())
                {
                    // TODO complete this list and factor out
                    case SyntaxKind.PostIncrementExpression:
                        ixe.Operator = UnaryOperator.PostIncrement;
                        break;
                    case SyntaxKind.PostDecrementExpression:
                        ixe.Operator = UnaryOperator.PostDecrement;
                        break;
                    default:
                        throw new NotSupportedException("Operator " + syntax.OperatorToken.RawKind);
                }
                return ixe;
            }
            if (expression is PrefixUnaryExpressionSyntax syntax)
            {
                var ixe = new XUnaryExpression();
                ixe.Expression = ConvertExpression(syntax.Operand);
                switch (syntax.Kind())
                {
                    // TODO complete this list and factor out
                    case SyntaxKind.LogicalNotExpression:
                        ixe.Operator = UnaryOperator.BooleanNot;
                        break;
                    case SyntaxKind.UnaryMinusExpression:
                        if (syntax.Operand is LiteralExpressionSyntax)
                        {
                            var les = (LiteralExpressionSyntax)syntax.Operand;
                            if (les.Token.IsKind(SyntaxKind.NumericLiteralToken))
                            {
                                var typeInfo = model.GetTypeInfo(syntax);
                                var val = les.Token.Value;
                                var newType = ConvertTypeReference(typeInfo.ConvertedType).DotNetType;
                                val = Convert.ChangeType(val, newType);
                                ixe.Expression = Builder.LiteralExpr(val);
                            }
                        }
                        ixe.Operator = UnaryOperator.Negate;
                        break;
                    default:
                        throw new NotSupportedException("Operator " + syntax.Kind());
                }
                return ixe;
            }
            if (expression is InitializerExpressionSyntax syntax)
            {
                var exprs = syntax.Expressions.Select(expr => ConvertExpression(expr)).ToList();
                var block = new XBlockExpression();
                block.Expressions.AddRange(exprs);
                return block;
            }
            if (expression is TypeOfExpressionSyntax syntax)
            {
                var expr = Builder.TypeOfExpr();
                var typeSymbol = model.GetTypeInfo(syntax.Type).Type;
                expr.Type = ConvertTypeReference(typeSymbol);
                return expr;
            }
            if (expression is TypeSyntax)
            {
                var typeSymbol = model.GetTypeInfo(expression).Type;
                return Builder.TypeRefExpr(ConvertTypeReference(typeSymbol));
            }
            if (expression is AssignmentExpressionSyntax assgnExpr)
            {
                var expr = Builder.AssignExpr();
                expr.Target = ConvertExpression(assgnExpr.Left);
                expr.Expression = ConvertExpression(assgnExpr.Right);
                return expr;
            }
            if (expression is CheckedExpressionSyntax checkedExpr)
            {
                var expr = Builder.CheckedExpr();
                expr.Expression = ConvertExpression(checkedExpr.Expression);
                return expr;
            }
            throw new NotSupportedException("Unsupported expression type: " + expression);
        }

        private IExpression ConvertConditionalExpression(ConditionalExpressionSyntax conditionalExpression)
        {
            var ixe = new XConditionExpression();
            ixe.Condition = ConvertExpression(conditionalExpression.Condition);
            ixe.Else = ConvertExpression(conditionalExpression.WhenFalse);
            ixe.Then = ConvertExpression(conditionalExpression.WhenTrue);
            return ixe;
        }

        private IExpression ConvertArrayCreation(ArrayCreationExpressionSyntax creationExpression)
        {
            var ixe = new XArrayCreateExpression();
            var arrayType = (IArrayTypeSymbol)model.GetTypeInfo(creationExpression).Type;
            ixe.Type = ConvertTypeReference(arrayType.ElementType);

            if (creationExpression.Initializer == null)
            {
                foreach (var size in creationExpression.Type.RankSpecifiers.First().Sizes)
                {
                    ixe.Dimensions.Add(ConvertExpression(size));
                }
                return ixe;
            }

            var arrayInitSyntax = creationExpression.Initializer;
            while (arrayInitSyntax != null)
            {
                ixe.Dimensions.Add(new XLiteralExpression { Value = arrayInitSyntax.Expressions.Count });
                if (arrayInitSyntax.Expressions.Count == 0) break;
                var firstExpr = arrayInitSyntax.Expressions.First();
                arrayInitSyntax = firstExpr as InitializerExpressionSyntax;
            }
            var initializers = creationExpression.Initializer.Expressions.Select(expr => ConvertExpression(expr)).ToList();
            ixe.Initializer = new XBlockExpression();
            ixe.Initializer.Expressions.AddRange(initializers);
            return ixe;
        }

        private IExpression ConvertElementAccess(ElementAccessExpressionSyntax accessExpression)
        {
            var ixe = new XArrayIndexerExpression();
            foreach (var indx in accessExpression.ArgumentList.Arguments)
            {
                ixe.Indices.Add(ConvertExpression(indx.Expression));
            }
            ixe.Target = ConvertExpression(accessExpression.Expression);
            return ixe;
        }

        private IExpression ConvertCreation(ObjectCreationExpressionSyntax creationExpression)
        {
            var symbol = (IMethodSymbol)model.GetSymbolInfo(creationExpression).Symbol;
            if (symbol == null)
            {
                throw new Exception("Could not bind");
            }

            var type = ConvertTypeReference(symbol.ContainingType);
            var args = creationExpression.ArgumentList != null ?
                creationExpression.ArgumentList.Arguments.Select(arg => ConvertExpression(arg.Expression)).ToArray() :
                null;

            var objCreateExpr = Builder.ObjCreateExpr();
            objCreateExpr.Type = type;
            if (args != null)
            {
                objCreateExpr.Arguments.AddRange(args);
            }

            // TODO probably need to worry about param arrays and emit explicit array creation here
            var paramTypes = symbol.Parameters.Select(p => ConvertTypeSymbolToType(p.Type)).ToArray();
            var dotNetType = ConvertTypeSymbolToType(symbol.ContainingType);
            objCreateExpr.Constructor = Builder.ConstructorRef(dotNetType, paramTypes);

            return objCreateExpr;
        }

        private IExpression ConvertBinary(BinaryExpressionSyntax binaryExpression)
        {
            var left = ConvertExpression(binaryExpression.Left);
            var right = ConvertExpression(binaryExpression.Right);
            switch (binaryExpression.Kind())
            {
                case SyntaxKind.SimpleAssignmentExpression:
                    return Builder.AssignExpr(left, right);
                case SyntaxKind.AddAssignmentExpression:
                    return Builder.AssignExpr(left, Builder.BinaryExpr(BinaryOperator.Add, left, right));
                default:
                    return Builder.BinaryExpr(left, ConvertOperator(binaryExpression.Kind()), right);
            }
        }

        private BinaryOperator ConvertOperator(SyntaxKind kind)
        {
            switch (kind)
            {
                case SyntaxKind.EqualsExpression:
                    // TODO value or identity equality?
                    return BinaryOperator.ValueEquality;
                case SyntaxKind.AddExpression:
                    return BinaryOperator.Add;
                case SyntaxKind.SubtractExpression:
                    return BinaryOperator.Subtract;
                case SyntaxKind.MultiplyExpression:
                    return BinaryOperator.Multiply;
                case SyntaxKind.DivideExpression:
                    return BinaryOperator.Divide;
                case SyntaxKind.LessThanExpression:
                    return BinaryOperator.LessThan;
                case SyntaxKind.GreaterThanExpression:
                    return BinaryOperator.GreaterThan;
                case SyntaxKind.LessThanOrEqualExpression:
                    return BinaryOperator.LessThanOrEqual;
                case SyntaxKind.GreaterThanOrEqualExpression:
                    return BinaryOperator.GreaterThanOrEqual;
                case SyntaxKind.BitwiseAndExpression:
                    return BinaryOperator.BitwiseAnd;
                case SyntaxKind.BitwiseOrExpression:
                    return BinaryOperator.BitwiseOr;
                case SyntaxKind.LogicalOrExpression:
                    return BinaryOperator.BooleanOr;
                case SyntaxKind.LogicalAndExpression:
                    return BinaryOperator.BooleanAnd;
                default:
                    throw new NotSupportedException("Unsupported operator: " + kind);
            }
        }

        private IExpression ConvertIdentifierName(IdentifierNameSyntax identifierName)
        {
            var info = model.GetSymbolInfo(identifierName);
            var symbol = info.Symbol;
            if (symbol is ITypeSymbol iTypeSymbol)
            {
                var tre = Builder.TypeRefExpr();
                tre.Type = (ITypeReference)ConvertTypeReference(iTypeSymbol);
                return tre;
            }
            if (symbol is ILocalSymbol iLocalSymbol)
            {
                var varDecl = GetVarDecl(iLocalSymbol);
                var vre = Builder.VarRefExpr(varDecl);
                return vre;
            }
            if (symbol is IParameterSymbol iParameterSymbol)
            {
                var paramDecl = GetParamDecl(iParameterSymbol);
                var vre = Builder.ParamRef(paramDecl);
                return vre;
            }
            if (symbol is IMethodSymbol iMethodSymbol)
            {
                var methodDecl = GetMethodRef(iMethodSymbol);
                var mre = Builder.MethodRefExpr();
                mre.Method = methodDecl;
                // TODO get the correct target
                mre.Target = Builder.ThisRefExpr();
                return mre;
            }
            if (symbol is IPropertySymbol iPropertySymbol)
            {
                var propertyDecl = GetPropertyRef(iPropertySymbol);
                var pre = Builder.PropRefExpr();
                pre.Property = propertyDecl;
                // TODO get the correct target
                pre.Target = Builder.ThisRefExpr();
                return pre;
            }
            throw new NotSupportedException("Unsupported identifier type: " + identifierName);
        }

        private IMethodDeclaration GetMethodRef(IMethodSymbol methodSymbol)
        {
            ITypeDeclaration typeDecl;
            if (typeDecls.TryGetValue(methodSymbol.ContainingType.ToDisplayString(), out typeDecl))
            {
                // TODO hadle overloads
                return typeDecl.Methods.Single(md => md.Name == methodSymbol.Name);
            }

            // TODO construct method ref
            throw new NotSupportedException();
        }

        private IPropertyDeclaration GetPropertyRef(IPropertySymbol propertySymbol)
        {
            // If the prop is on a type that we have a type decl for then return the prop decl
            // else construct and return a prop ref

            ITypeDeclaration typeDecl;
            if (typeDecls.TryGetValue(propertySymbol.ContainingType.ToDisplayString(), out typeDecl))
            {
                return typeDecl.Properties.Single(pd => pd.Name == propertySymbol.Name);
            }

            // TODO construct prop ref
            throw new NotSupportedException();
        }

        Dictionary<string, IVariableDeclaration> vdCache = new Dictionary<string, IVariableDeclaration>();
        private IVariableDeclaration GetVarDecl(ILocalSymbol local)
        {
            // TODO: do this properly
            if (!vdCache.ContainsKey(local.Name))
            {
                throw new Exception("Unknown variable: " + local.Name);
            }
            return vdCache[local.Name];
        }

        Dictionary<string, IParameterDeclaration> pdCache = new Dictionary<string, IParameterDeclaration>();
        private IParameterDeclaration GetParamDecl(IParameterSymbol paramSymbol)
        {
            // TODO: do this properly
            if (!pdCache.ContainsKey(paramSymbol.Name))
            {
                throw new Exception("Unknown parameter: " + paramSymbol.Name);
            }
            return pdCache[paramSymbol.Name];
        }

        private IExpression ConvertMemberAccess(MemberAccessExpressionSyntax memberAccess)
        {
            var symbol = model.GetSymbolInfo(memberAccess.Name).Symbol;
            if (symbol == null)
            {
                throw new NotSupportedException("Couldn't resolve?");
            }

            if (symbol is IMethodSymbol iMethodSymbol)
            {
                return ConvertMethodReference(iMethodSymbol, memberAccess);
            }
            if (symbol is IPropertySymbol iPropertySymbol)
            {
                return ConvertPropertyReference(iPropertySymbol, memberAccess);
            }
            if (symbol is IFieldSymbol iFieldSymbol)
            {
                return ConvertFieldReference(iFieldSymbol, memberAccess);
            }
            if (symbol is INamedTypeSymbol iNamedTypeSymbol)
            {
                return ConvertNamedType(iNamedTypeSymbol, memberAccess);
            }

            throw new NotSupportedException("Unknown symbol");
        }

        private IExpression ConvertNamedType(INamedTypeSymbol symbol, MemberAccessExpressionSyntax memberAccess)
        {
            var typeRef = (ITypeReference)ConvertTypeReference(symbol);
            return new XTypeReferenceExpression
            {
                Type = typeRef
            };
        }

        private IExpression ConvertFieldReference(IFieldSymbol fieldSymbol, MemberAccessExpressionSyntax memberAccess)
        {
            var fieldRef = new XFieldReference();
            fieldRef.Name = fieldSymbol.Name;
            fieldRef.DeclaringType = ConvertTypeReference(fieldSymbol.ContainingType);
            fieldRef.FieldType = ConvertTypeReference(fieldSymbol.Type);
            // TODO: do this properly
            //fieldRef.MethodInfo = Builder.ToMethodThrows(fieldRef);

            return new XFieldReferenceExpression
            {
                Field = fieldRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IExpression ConvertPropertyReference(IPropertySymbol propSymbol, MemberAccessExpressionSyntax memberAccess)
        {
            var propRef = new XPropertyReference();
            propRef.Name = propSymbol.Name;
            propRef.DeclaringType = ConvertTypeReference(propSymbol.ContainingType);
            propRef.PropertyType = ConvertTypeReference(propSymbol.Type);
            // TODO: do this properly

            return new XPropertyReferenceExpression
            {
                Property = propRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IExpression ConvertMethodReference(IMethodSymbol symbol, MemberAccessExpressionSyntax memberAccess)
        {
            var methodRef = Builder.MethodRef();
            methodRef.Name = symbol.Name;
            methodRef.DeclaringType = ConvertTypeReference(symbol.ContainingType);
            var parTypes = new List<Type>();
            foreach (var par in symbol.Parameters)
            {
                var parameterDecl = ConvertParameter(par);
                methodRef.Parameters.Add(parameterDecl);
                parTypes.Add(Builder.ToType(parameterDecl.ParameterType));
            }
            methodRef.ReturnType = Builder.MethodReturnType(ConvertTypeReference(symbol.ReturnType));
            // TODO genericMethod
            if (symbol.IsGenericMethod)
            {
                var typeArgs = symbol.TypeArguments.Select(ts => ConvertTypeReference(ts)).ToList();
                methodRef.GenericArguments.AddRange(typeArgs);
            }
            // TODO: do this properly
            //methodRef.MethodInfo = Builder.ToType(methodRef.DeclaringType).GetMethod(methodRef.Name, parTypes.ToArray());
            methodRef.MethodInfo = Builder.ToMethodThrows(methodRef);

            return new XMethodReferenceExpression
            {
                Method = methodRef,
                Target = ConvertExpression(memberAccess.Expression)
            };
        }

        private IParameterDeclaration ConvertParameter(IParameterSymbol par)
        {
            var pd = Builder.ParamDecl();
            pd.Name = par.Name;
            pd.ParameterType = ConvertTypeReference(par.Type);
            // TODO: attributes
            return pd;
        }

        private IExpression ConvertLiteral(LiteralExpressionSyntax literalExpression)
        {
            return ConvertConstantExpr(literalExpression);
        }

        private IExpression ConvertConstantExpr(ExpressionSyntax expression)
        {
            var value = model.GetConstantValue(expression);
            var ti = model.GetTypeInfo(expression);
            var val = value.Value;
            if (expression.IsKind(SyntaxKind.NumericLiteralExpression))
            {
                var newType = ConvertTypeReference(ti.ConvertedType).DotNetType;
                val = Convert.ChangeType(val, newType);
            }
            return Builder.LiteralExpr(val);
        }

        private IExpression ConvertInvocation(InvocationExpressionSyntax invocationExpression)
        {
            var c = model.GetConstantValue(invocationExpression);
            if (c.HasValue)
            {
                // compile time constant
                // including nameof(thing)
                return ConvertConstantExpr(invocationExpression);
            }

            var imie = Builder.MethodInvkExpr();
            var methodExpression = invocationExpression.Expression;
            var argumentList = invocationExpression.ArgumentList.Arguments;
            var convertedArgs = argumentList.Select(arg => ConvertExpression(arg.Expression)).ToArray();

            if (argumentList.Any(arg => arg.NameColon != null))
            {
                throw new NotSupportedException("No support yet for named parameters");
            }

            List<IExpression> paramsParameters = null;
            IArrayTypeSymbol paramsType = null;
            var methodSymbol = model.GetSymbolInfo(invocationExpression).Symbol as IMethodSymbol;
            if (methodSymbol != null && methodSymbol.Parameters.Length > 0)
            {
                var lastParam = methodSymbol.Parameters.Last();
                paramsType = lastParam.Type as IArrayTypeSymbol;
                if (lastParam.IsParams && paramsType != null)
                {
                    if (argumentList.Count() == methodSymbol.Parameters.Count())
                    {
                        // one element or array supplied?
                        var ti = model.GetTypeInfo(argumentList.Last().Expression);
                        if (ti.Type is IArrayTypeSymbol == false)
                        {
                            paramsParameters = new List<IExpression>(new[] { convertedArgs.Last() });
                        }
                    }
                    else
                    {
                        paramsParameters = convertedArgs.Skip(methodSymbol.Parameters.Length - 1).ToList();
                    }
                }
            }

            if (paramsParameters != null)
            {
                var ixe = new XArrayCreateExpression();
                ixe.Type = ConvertTypeReference(paramsType.ElementType);
                ixe.Dimensions.Add(new XLiteralExpression { Value = paramsParameters.Count });
                ixe.Initializer = new XBlockExpression();
                ixe.Initializer.Expressions.AddRange(paramsParameters);

                var normalParameterCount = argumentList.Count - paramsParameters.Count;
                imie.Arguments.AddRange(convertedArgs.Take(normalParameterCount));
                imie.Arguments.Add(ixe);
            }
            else
            {
                imie.Arguments.AddRange(convertedArgs);
            }

            imie.Method = (IMethodReferenceExpression)ConvertExpression(methodExpression);
            return imie;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(278,59): error CS0128: A local variable or function named 'syntax' is already defined in this scope,D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(308,59): error CS0128: A local variable or function named 'syntax' is already defined in this scope,D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(310,36): error CS1061: 'PostfixUnaryExpressionSyntax' does not contain a definition for 'Expressions' and no accessible extension method 'Expressions' accepting a first argument of type 'PostfixUnaryExpressionSyntax' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(315,54): error CS0128: A local variable or function named 'syntax' is already defined in this scope,D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(318,59): error CS1061: 'PostfixUnaryExpressionSyntax' does not contain a definition for 'Type' and no accessible extension method 'Type' accepting a first argument of type 'PostfixUnaryExpressionSyntax' could be found (are you missing a using directive or an assembly reference?),D:\a\1\s\src\Csoft\MethodBodySynthesizer.cs(281,52): error CS0165: Use of unassigned local variable 'syntax'
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Examples\Crowdsourcing\Results.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;

namespace Crowdsourcing
{
    /// <summary>
    /// Results class containing posteriors and predictions.
    /// </summary>
    public class Results
    {
        /// <summary>
        /// The posterior of the true label for each task.
        /// </summary>
        public Dictionary<string, Discrete> TrueLabel
        {
            get;
            private set;
        }

        /// <summary>
        /// The predicted label for each task when doing simulations from the current
        /// model state. It avoids overwriting the true label posterior.
        /// </summary>
        public Dictionary<string, Discrete> LookAheadTrueLabel
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for the true label variable.
        /// </summary>
        public Dictionary<string, Discrete> TrueLabelConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// The probabilities that generate the true label of all the tasks.
        /// </summary>
        public Dirichlet BackgroundLabelProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior of the confusion matrix of each worker.
        /// </summary>
        public Dictionary<string, Dirichlet[]> WorkerConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The look-ahead posterior of the confusion matrix of each worker obtained after simulating
        /// a new label in look-ahead run mode.
        /// </summary>
        public Dictionary<string, Dirichlet[]> LookAheadWorkerConfusionMatrix
        {
            get;
            private set;
        }


        /// <summary>
        /// The predictive probabilities of the labels produced by each worker.
        /// </summary>
        public Dictionary<string, Dictionary<string, Discrete>> WorkerPrediction
        {
            get;
            private set;
        }

        /// <summary>
        /// The community membership probabilities of each worker.
        /// </summary>
        public Dictionary<string, Discrete> WorkerCommunity
        {
            get;
            private set;
        }

        /// <summary>
        /// The confusion matrix of each community.
        /// </summary>
        public Dirichlet[][] CommunityConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The score matrix of each community.
        /// </summary>
        public VectorGaussian[][] CommunityScoreMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for worker confusion matrices
        /// int the community model.
        /// </summary>
        public Dictionary<string, VectorGaussian[]> WorkerScoreMatrixConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// The probabilities that generate the community memberships of all the workers.
        /// </summary>
        public Dirichlet CommunityProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for community membership.
        /// int the community model.
        /// </summary>
        public Dictionary<string, Discrete> CommunityConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// Model evidence.
        /// </summary>
        public Bernoulli ModelEvidence
        {
            get;
            private set;
        }

        /// <summary>
        /// The data mapping.
        /// </summary>
        public DataMapping Mapping
        {
            get;
            private set;
        }

        /// <summary>
        /// The gold labels of each task. The gold label type is nullable to
        /// support the (usual) situation where the is no labels.
        /// </summary>
        public Dictionary<string, int?> GoldLabels
        {
            get;
            private set;
        }

        /// <summary>
        /// The accuracy of the current true label predictions.
        /// </summary>
        public double Accuracy
        {
            get;
            private set;
        }

        /// <summary>
        /// The negative log probability density (NLPD) scores of the current true label predictions.
        /// </summary>
        public double NegativeLogProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The average recall of the current true label predictions.
        /// </summary>
        public double AvgRecall
        {
            get;
            private set;
        }

        /// <summary>
        /// The confusion matrix of the predicted true labels against the gold labels
        /// The rows are the gold labels and the columns are the predicted labels.
        /// </summary>
        public double[,] ModelConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// Flags whether the model instance is CBCC (true) or BCC (false).
        /// </summary>
        public bool IsCommunityModel
        {
            get;
            private set;
        }

        /// <summary>
        /// The number of communities.
        /// </summary>
        public int CommunityCount
        {
            get;
            private set;
        }

        /// <summary>
        /// Runs the majority vote method on the data.
        /// </summary>
        /// <param name="data">The data</param>
        /// <param name="calculateAccuracy">Compute the accuracy (true).</param>
        /// <param name="useVoteDistribution">The true label is sampled from the vote distribution (true) or it is
        /// taken as the mode of the vote counts (false).
        /// In the latter case, ties are broken by sampling from the most voted classes.</param>
        /// <returns>The updated results</returns>
        public Results RunMajorityVote(IList<Datum> data, bool calculateAccuracy, bool useVoteDistribution)
        {
            var dataMapping = new DataMapping(data);
            Mapping = dataMapping;
            GoldLabels = Mapping.GetGoldLabelsPerTaskId();
            var inferredLabels = useVoteDistribution ? dataMapping.GetVoteDistribPerTaskIndex() : dataMapping.GetMajorityVotesPerTaskIndex().Select(mv => mv == null ? (Discrete)null : Discrete.PointMass(mv.Value, dataMapping.LabelCount)).ToArray();
            TrueLabel = inferredLabels.Select((lab, i) => new
            {
                key = dataMapping.TaskIndexToId[i],
                val = lab
            }).ToDictionary(a => a.key, a => a.val);

            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }
            return this;
        }

        /// <summary>
        /// Run Dawid-Skene on the data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="calculateAccuracy">Whether to calculate accuracy</param>
        /// <returns>A results instance</returns>
        public Results RunDawidSkene(IList<Datum> data, bool calculateAccuracy)
        {
            // If you want to run Dawid-Skene code, download his code, integrate it into
            // the project, and change false to true below.
#if false
            var dataMapping = new DataMapping(data);
            Mapping = dataMapping;
            var labelings = data.Select(d => new Labeling(d.WorkerId, d.TaskId, d.WorkerLabel.ToString(), d.GoldLabel.ToString())).ToList();
            DawidSkene ds = new DawidSkene(labelings, null, null);
            // The labels may be in a different order from our data labeling - we need to create a map.
            int[] labelIndexMap = new int[dataMapping.LabelCount];
            var dwLabels = ds.classes.Keys.ToArray();
            for (int i = 0; i < dataMapping.LabelCount; i++)
            {
                labelIndexMap[i] = Array.IndexOf(dwLabels, (i + dataMapping.LabelMin).ToString());
            }

            GoldLabels = Mapping.GetGoldLabelsPerTaskId().
                ToDictionary(kvp => kvp.Key, kvp => kvp.Value == null ? (int?)null : (int?)labelIndexMap[kvp.Value.Value]);

            ds.Estimate(10);

            var inferredLabels = ds.GetObjectClassProbabilities().Select(r => new Discrete(r)).ToArray();
            TrueLabel = inferredLabels.Select((lab, i) => new
            {
                key = dataMapping.TaskIndexToId[i],
                val = lab
            }).ToDictionary(a => a.key, a => a.val);

            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }

            return this;
#else
            throw new ApplicationException("To support Dawid-Skene, you must link to the C# version of their code");
#endif
        }

        /// <summary>
        /// The different modes in which the model can be run.
        /// </summary>
        public enum RunMode
        {
            /// <summary>
            /// Clears all posteriors
            /// </summary>
            ClearResults,
            /// <summary>
            /// Training from a batch of data - uses initial priors.
            /// </summary>
            BatchTraining,
            /// <summary>
            /// Online training from a batch of data - uses previous posteriors as priors.
            /// </summary>
            OnlineTraining,
            /// <summary>
            /// Online training where we don't update the posteriors
            /// </summary>
            LookAheadExperiment,
            /// <summary>
            /// Use communities as workers in a BCC
            /// </summary>
            LoadAndUseCommunityPriors,
            /// <summary>
            /// Prediction of worker labels
            /// </summary>
            Prediction,
        };

        /// <summary>
        /// The structure with the model parameters.
        /// </summary>
        [Serializable]
        public struct NonTaskWorkerParameters
        {
            public Dirichlet BackgroundLabelProb;
            public Dirichlet CommunityProb;
            public VectorGaussian[][] CommunityScoreMatrix;
        }

        /// <summary>
        /// Runs the BCC or CBCC model.
        /// </summary>
        /// <param name="modelName">The model name.</param>
        /// <param name="data">The data that will be used for this run.</param>
        /// <param name="fullData">The full data set of data.</param>
        /// <param name="model">The model instance (BCC or CBCC).</param>
        /// <param name="mode">The mode (for example training, prediction, etc.).</param>
        /// <param name="calculateAccuracy">Whether to calculate accuracy.</param>
        /// <param name="numCommunities">The number of communities (community model only).</param>
        /// <param name="serialize">Whether to serialize all posteriors.</param>
        /// <param name="serializeCommunityPosteriors">Whether to serialize community posteriors.</param>
        public void RunBCC(string modelName, IList<Datum> data, IList<Datum> fullData, BCC model, RunMode mode, bool calculateAccuracy, int numCommunities = -1, bool serialize = false, bool serializeCommunityPosteriors = false)
        {
            CommunityModel communityModel = model as CommunityModel;
            IsCommunityModel = communityModel != null;

            if (this.Mapping == null)
            {
                this.Mapping = new DataMapping(fullData, numCommunities);
                this.GoldLabels = this.Mapping.GetGoldLabelsPerTaskId();
            }

            /// A new model is created if the label count or the task count has changed
            bool createModel = (Mapping.LabelCount != model.LabelCount) || (Mapping.TaskCount != model.TaskCount);

            if (IsCommunityModel)
            {

                /// Creates a new CBCC model instance
                CommunityCount = numCommunities;
                createModel = createModel || (numCommunities != communityModel.CommunityCount);
                if (createModel)
                {
                    communityModel.CreateModel(Mapping.TaskCount, Mapping.LabelCount, numCommunities);
                }

            }
            else if (createModel)
            {
                /// Creates a new BCC model instance
                model.CreateModel(Mapping.TaskCount, Mapping.LabelCount);
            }

            /// Selects the prior according to the run mode
            BCC.Posteriors priors = null;
            switch (mode)
            {
                /// Use existing priors
                case RunMode.OnlineTraining:
                case RunMode.LookAheadExperiment:
                case RunMode.Prediction:
                    priors = ToPriors();
                    break;
                default:

                    /// Use default priors
                    ClearResults();
                    if (mode == RunMode.LoadAndUseCommunityPriors && IsCommunityModel)
                    {
                        priors = DeserializeCommunityPosteriors(modelName, numCommunities);
                    }
                    break;
            }

            /// Get data to observe
            var labelsPerWorkerIndex = Mapping.GetLabelsPerWorkerIndex(data);
            if (mode == RunMode.Prediction)
            {
                /// Signal prediction mode by setting all labels to null
                labelsPerWorkerIndex = labelsPerWorkerIndex.Select(arr => (int[])null).ToArray();
            }

            /// Run model inference
            BCC.Posteriors posteriors = model.Infer(
                Mapping.GetTaskIndicesPerWorkerIndex(data),
                labelsPerWorkerIndex, priors);
            UpdateResults(posteriors, mode);

            /// Compute accuracy
            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }

            /// Serialize parameters
            if (serialize)
            {
                using (FileStream stream = new FileStream(modelName + ".xml", FileMode.Create))
                {
                    var serializer = new System.Xml.Serialization.XmlSerializer(IsCommunityModel ? typeof(CommunityModel.Posteriors) : typeof(BCC.Posteriors));
                    serializer.Serialize(stream, posteriors);
                }
            }

            if (serializeCommunityPosteriors && IsCommunityModel)
            {
                SerializeCommunityPosteriors(modelName);
            }
        }

        /// <summary>
        /// Serializes the posteriors on an xml file.
        /// </summary>
        /// <param name="modelName">The model name.</param>
        void SerializeCommunityPosteriors(string modelName)
        {
            NonTaskWorkerParameters ntwp = new NonTaskWorkerParameters();
            ntwp.BackgroundLabelProb = BackgroundLabelProb;
            ntwp.CommunityProb = CommunityProb;
            ntwp.CommunityScoreMatrix = CommunityScoreMatrix;
            using (FileStream stream = new FileStream(modelName + "CommunityPriors.xml", FileMode.Create))
            {
                var serializer = new System.Xml.Serialization.XmlSerializer(typeof(NonTaskWorkerParameters));
                serializer.Serialize(stream, ntwp);
            }
        }

        /// <summary>
        /// Deserializes the parameters of CBCC from an xml file (used in the LoadAndUseCommunityPriors mode).
        /// </summary>
        /// <param name="modelName">The model name.</param>
        /// <param name="numCommunities">The number of communities.</param>
        /// <returns></returns>
        CommunityModel.Posteriors DeserializeCommunityPosteriors(string modelName, int numCommunities)
        {
            CommunityModel.Posteriors cbccPriors = new CommunityModel.Posteriors();
            using (FileStream stream = new FileStream(modelName + "CommunityPriors.xml", FileMode.Open))
            {
                var serializer = new System.Xml.Serialization.XmlSerializer(typeof(NonTaskWorkerParameters));
                var ntwp = (NonTaskWorkerParameters)serializer.Deserialize(stream);

                if (ntwp.BackgroundLabelProb.Dimension != Mapping.LabelCount)
                {
                    throw new ApplicationException("Unexpected number of labels");
                }

                BackgroundLabelProb = ntwp.BackgroundLabelProb;
                cbccPriors.BackgroundLabelProb = ntwp.BackgroundLabelProb;
                if (ntwp.CommunityScoreMatrix.Length != numCommunities)
                {
                    throw new ApplicationException("Unexpected number of communities");
                }

                if (ntwp.CommunityScoreMatrix[0][0].Dimension != Mapping.LabelCount)
                {
                    throw new ApplicationException("Unexpected number of labels");
                }

                CommunityScoreMatrix = ntwp.CommunityScoreMatrix;
                cbccPriors.CommunityScoreMatrix = ntwp.CommunityScoreMatrix;

                if (ntwp.CommunityProb.Dimension != numCommunities)
                {
                    throw new ApplicationException("Unexpected number of communities");
                }

                CommunityProb = ntwp.CommunityProb;
                cbccPriors.CommunityProb = ntwp.CommunityProb;
            }

            return cbccPriors;
        }

        /// <summary>
        /// Resets all the parameters to the default values.
        /// </summary>
        void ClearResults()
        {
            BackgroundLabelProb = Dirichlet.Uniform(Mapping.LabelCount);
            WorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            WorkerPrediction = new Dictionary<string, Dictionary<String, Discrete>>();
            WorkerCommunity = new Dictionary<string, Discrete>();
            TrueLabel = new Dictionary<string, Discrete>();
            TrueLabelConstraint = new Dictionary<string, Discrete>();
            CommunityConfusionMatrix = null;
            WorkerScoreMatrixConstraint = new Dictionary<string, VectorGaussian[]>();
            CommunityProb = null;
            CommunityScoreMatrix = null;
            CommunityConstraint = new Dictionary<string, Discrete>();
            LookAheadTrueLabel = new Dictionary<string, Discrete>();
            LookAheadWorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            ModelEvidence = new Bernoulli(0.5);
        }

        /// <summary>
        /// Updates the results of with the new posteriors.
        /// </summary>
        /// <param name="posteriors">The posteriors.</param>
        /// <param name="mode">The mode (for example training, prediction, etc.).</param>
        void UpdateResults(BCC.Posteriors posteriors, RunMode mode)
        {

            /// In the lookAheadExperiment mode, update only the LookAhead results
            if (mode == RunMode.LookAheadExperiment)
            {
                for (int t = 0; t < posteriors.TrueLabel.Length; t++)
                {
                    LookAheadTrueLabel[Mapping.TaskIndexToId[t]] = posteriors.TrueLabel[t];
                }
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    LookAheadWorkerConfusionMatrix[Mapping.WorkerIndexToId[w]] = posteriors.WorkerConfusionMatrix[w];
                }
            }

            /// In the prediction mode, update only the worker prediction results
            else if (mode == RunMode.Prediction)
            {
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    WorkerPrediction[Mapping.WorkerIndexToId[w]] = new Dictionary<string, Discrete>();
                    for (int tw = 0; tw < posteriors.WorkerPrediction[w].Length; tw++)
                    {
                        WorkerPrediction[Mapping.WorkerIndexToId[w]][Mapping.TaskIndexToId[tw]] = posteriors.WorkerPrediction[w][tw];
                    }
                }
            }
            else
            {
                /// In the all other modes, update all the results
                CommunityModel.Posteriors communityPosteriors = posteriors as CommunityModel.Posteriors;
                bool isCommunityModel = communityPosteriors != null;
                BackgroundLabelProb = posteriors.BackgroundLabelProb;
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    WorkerConfusionMatrix[Mapping.WorkerIndexToId[w]] = posteriors.WorkerConfusionMatrix[w];
                }
                for (int t = 0; t < posteriors.TrueLabel.Length; t++)
                {
                    TrueLabel[Mapping.TaskIndexToId[t]] = posteriors.TrueLabel[t];
                }
                for (int t = 0; t < posteriors.TrueLabelConstraint.Length; t++)
                {
                    TrueLabelConstraint[Mapping.TaskIndexToId[t]] = posteriors.TrueLabelConstraint[t];
                }

                if (isCommunityModel)
                {
                    CommunityConfusionMatrix = communityPosteriors.CommunityConfusionMatrix;
                    for (int w = 0; w < communityPosteriors.WorkerScoreMatrixConstraint.Length; w++)
                    {
                        WorkerScoreMatrixConstraint[Mapping.WorkerIndexToId[w]] = communityPosteriors.WorkerScoreMatrixConstraint[w];
                        CommunityConstraint[Mapping.WorkerIndexToId[w]] = communityPosteriors.WorkerCommunityConstraint[w];
                        WorkerCommunity[Mapping.WorkerIndexToId[w]] = communityPosteriors.Community[w];
                    }

                    CommunityProb = communityPosteriors.CommunityProb;
                    CommunityScoreMatrix = communityPosteriors.CommunityScoreMatrix;
                }

                this.ModelEvidence = posteriors.Evidence;
            }
        }

        /// <summary>
        /// Loads the priors of BCC and CBCC.
        /// </summary>
        /// <returns>A BCC posterior instance with the loaded priors.</returns>
        BCC.Posteriors ToPriors()
        {
            int numClasses = Mapping.LabelCount;
            int numTasks = Mapping.TaskCount;
            int numWorkers = Mapping.WorkerCount;
            CommunityModel.Posteriors cbccPriors = new CommunityModel.Posteriors();
            BCC.Posteriors priors = IsCommunityModel ? cbccPriors : new BCC.Posteriors();

            /// Loads the prior of the background probabilities of the tasks
            priors.BackgroundLabelProb = BackgroundLabelProb;

            /// Loads the prior of the confusion matrix of each worker
            priors.WorkerConfusionMatrix = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (WorkerConfusionMatrix.ContainsKey(wid))
                        return Util.ArrayInit(numClasses, lab => WorkerConfusionMatrix[wid][lab]);
                    else
                        return Util.ArrayInit(numClasses, lab => Dirichlet.Uniform(numClasses));
                });

            /// Loads the true label constraint of each task
            priors.TrueLabelConstraint = Util.ArrayInit(numTasks,
                t =>
                {
                    string tid = Mapping.TaskIndexToId[t];
                    if (TrueLabelConstraint.ContainsKey(tid))
                        return TrueLabelConstraint[Mapping.TaskIndexToId[t]];
                    else
                        return Discrete.Uniform(numClasses);
                });

            /// Loads the priors of the parameters of CBCC
            if (IsCommunityModel)
            {
                cbccPriors.CommunityConfusionMatrix = CommunityConfusionMatrix;
                cbccPriors.WorkerScoreMatrixConstraint = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (WorkerScoreMatrixConstraint.ContainsKey(wid))
                        return Util.ArrayInit(numClasses, lab => WorkerScoreMatrixConstraint[wid][lab]);
                    else
                        return Util.ArrayInit(numClasses, lab => VectorGaussian.Uniform(numClasses));
                });
                cbccPriors.CommunityProb = CommunityProb;
                cbccPriors.CommunityScoreMatrix = CommunityScoreMatrix;
                cbccPriors.WorkerCommunityConstraint = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (CommunityConstraint.ContainsKey(wid))
                        return CommunityConstraint[wid];
                    else
                        return Discrete.Uniform(CommunityCount);
                });
            }

            priors.Evidence = ModelEvidence;

            return priors;
        }

        /// <summary>
        /// Updates the accuracy using the current results.
        /// </summary>
        private void UpdateAccuracy()
        {
            double nlpdThreshold = -Math.Log(0.001);
            int labelCount = TrueLabel.First(kvp => kvp.Value != null).Value.Dimension;
            var confusionMatrix = Util.ArrayInit(labelCount, labelCount, (i, j) => 0.0);
            int correct = 0;
            double logProb = 0.0;

            int goldX = 0;
            foreach (var kvp in GoldLabels)
            {
                if (kvp.Value == null)
                    continue;

                // We have a gold label
                goldX++;

                var trueLabel = TrueLabel[kvp.Key];
                if (trueLabel == null)
                    continue;  // No inferred label

                var probs = trueLabel.GetProbs();
                var max = probs.Max();
                var predictedLabels = probs.Select((p, i) => new
                {
                    prob = p,
                    idx = i
                }).Where(a => a.prob == max).Select(a => a.idx).ToArray();
                int predictedLabel = predictedLabels.Length == 1 ? predictedLabels[0] : predictedLabels[Rand.Int(predictedLabels.Length)];
                int goldLabel = kvp.Value.Value;

                confusionMatrix[goldLabel, predictedLabel] = confusionMatrix[goldLabel, predictedLabel] + 1.0;

                if (goldLabel == predictedLabel)
                    correct++;

                var nlp = -trueLabel.GetLogProb(goldLabel);
                if (nlp > nlpdThreshold)
                    nlp = nlpdThreshold;
                logProb += nlp;
            }

            Accuracy = correct / (double)goldX;
            NegativeLogProb = logProb / (double)goldX;
            ModelConfusionMatrix = confusionMatrix;

            // Compute average recall
            double sumRec = 0;
            for (int i = 0; i < labelCount; i++)
            {
                double classSum = 0;
                for (int j = 0; j < labelCount; j++)
                {
                    classSum += confusionMatrix[i, j];
                }

                sumRec += confusionMatrix[i, i] / classSum;
            }
            AvgRecall = sumRec / labelCount;
        }

        /// <summary>
        /// Writes out the mean of an uncertain confusion matrix to a StreamWriter.
        /// The confusion matrix is passed as an of Dirichlets, one for each row
        /// of the confusion matrix (as given by the posteriors from the model).
        /// </summary>
        /// <param name="writer">A| StreamWriter instance.</param>
        /// <param name="worker">The worker id.</param>
        /// <param name="confusionMatrix">The confusion matrix</param>
        private static void WriteConfusionMatrix(StreamWriter writer, string worker, Dirichlet[] confusionMatrix)
        {
            int labelCount = confusionMatrix.Length;
            var meanConfusionMatrix = confusionMatrix.Select(cm => cm.GetMean()).ToArray();
            var printableConfusionMatrix = Util.ArrayInit(labelCount, labelCount, (i, j) => meanConfusionMatrix[i][j]);
            WriteWorkerConfusionMatrix(writer, worker, printableConfusionMatrix);
        }

        /// <summary>
        /// Writes the a confusion matrix to a stream writer.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="worker">The worker id.</param>
        /// <param name="confusionMatrix">The confusion matrix.</param>
        private static void WriteWorkerConfusionMatrix(StreamWriter writer, string worker, double[,] confusionMatrix)
        {
            int labelCount = confusionMatrix.GetLength(0);
            writer.WriteLine(worker);
            for (int j = 0; j < labelCount; j++)
                writer.Write(",{0}", j);
            writer.WriteLine();

            for (int i = 0; i < labelCount; i++)
            {
                writer.Write(i);
                for (int j = 0; j < labelCount; j++)
                    writer.Write(",{0:0.0000}", confusionMatrix[i, j]);

                writer.WriteLine();
            }
        }

        /// <summary>
        /// Writes various results to a StreamWriter.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="writeCommunityParameters">Set true to write community parameters.</param>
        /// <param name="writeWorkerParameters">Set true to write worker parameters.</param>
        /// <param name="writeWorkerCommunities">Set true to write worker communities.</param>
        public void WriteResults(StreamWriter writer, bool writeCommunityParameters, bool writeWorkerParameters, bool writeWorkerCommunities)
        {
            this.WriteAccuracy(writer);

            if (writeCommunityParameters && this.CommunityConfusionMatrix != null)
            {
                for (int communityIndex = 0; communityIndex < this.CommunityConfusionMatrix.Length; communityIndex++)
                {
                    WriteConfusionMatrix(writer, "Community" + communityIndex, this.CommunityConfusionMatrix[communityIndex]);
                }
            }

            if (writeWorkerParameters && this.WorkerConfusionMatrix != null)
            {
                foreach (var kvp in this.WorkerConfusionMatrix)
                {
                    WriteConfusionMatrix(writer, kvp.Key, kvp.Value);
                }
            }

            if (writeWorkerCommunities && this.WorkerCommunity != null)
            {
                foreach (var kvp in this.WorkerCommunity)
                {
                    writer.WriteLine(string.Format("{0}:\t{1}", kvp.Key, kvp.Value));
                }
            }

            writer.WriteLine("Log Evidence = {0:0.0000}", ModelEvidence.LogOdds);
        }

        /// <summary>
        /// Writes the accuracy results on the StreamWriter.
        /// </summary>
        /// <param name="writer">The StreamWriter.</param>
        public void WriteAccuracy(StreamWriter writer)
        {
            writer.WriteLine("Accuracy = {0:0.000}", this.Accuracy);
            writer.WriteLine("Mean negative log prob density = {0:0.000}", this.NegativeLogProb);
            WriteWorkerConfusionMatrix(writer, "Model confusion matrix", this.ModelConfusionMatrix);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;

namespace Crowdsourcing
{
    /// <summary>
    /// Results class containing posteriors and predictions.
    /// </summary>
    public class Results
    {
        /// <summary>
        /// The posterior of the true label for each task.
        /// </summary>
        public Dictionary<string, Discrete> TrueLabel
        {
            get;
            private set;
        }

        /// <summary>
        /// The predicted label for each task when doing simulations from the current
        /// model state. It avoids overwriting the true label posterior.
        /// </summary>
        public Dictionary<string, Discrete> LookAheadTrueLabel
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for the true label variable.
        /// </summary>
        public Dictionary<string, Discrete> TrueLabelConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// The probabilities that generate the true label of all the tasks.
        /// </summary>
        public Dirichlet BackgroundLabelProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior of the confusion matrix of each worker.
        /// </summary>
        public Dictionary<string, Dirichlet[]> WorkerConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The look-ahead posterior of the confusion matrix of each worker obtained after simulating
        /// a new label in look-ahead run mode.
        /// </summary>
        public Dictionary<string, Dirichlet[]> LookAheadWorkerConfusionMatrix
        {
            get;
            private set;
        }


        /// <summary>
        /// The predictive probabilities of the labels produced by each worker.
        /// </summary>
        public Dictionary<string, Dictionary<string, Discrete>> WorkerPrediction
        {
            get;
            private set;
        }

        /// <summary>
        /// The community membership probabilities of each worker.
        /// </summary>
        public Dictionary<string, Discrete> WorkerCommunity
        {
            get;
            private set;
        }

        /// <summary>
        /// The confusion matrix of each community.
        /// </summary>
        public Dirichlet[][] CommunityConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The score matrix of each community.
        /// </summary>
        public VectorGaussian[][] CommunityScoreMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for worker confusion matrices
        /// int the community model.
        /// </summary>
        public Dictionary<string, VectorGaussian[]> WorkerScoreMatrixConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// The probabilities that generate the community memberships of all the workers.
        /// </summary>
        public Dirichlet CommunityProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The posterior for the constraint that allows online learning for community membership.
        /// int the community model.
        /// </summary>
        public Dictionary<string, Discrete> CommunityConstraint
        {
            get;
            private set;
        }

        /// <summary>
        /// Model evidence.
        /// </summary>
        public Bernoulli ModelEvidence
        {
            get;
            private set;
        }

        /// <summary>
        /// The data mapping.
        /// </summary>
        public DataMapping Mapping
        {
            get;
            private set;
        }

        /// <summary>
        /// The gold labels of each task. The gold label type is nullable to
        /// support the (usual) situation where the is no labels.
        /// </summary>
        public Dictionary<string, int?> GoldLabels
        {
            get;
            private set;
        }

        /// <summary>
        /// The accuracy of the current true label predictions.
        /// </summary>
        public double Accuracy
        {
            get;
            private set;
        }

        /// <summary>
        /// The negative log probability density (NLPD) scores of the current true label predictions.
        /// </summary>
        public double NegativeLogProb
        {
            get;
            private set;
        }

        /// <summary>
        /// The average recall of the current true label predictions.
        /// </summary>
        public double AvgRecall
        {
            get;
            private set;
        }

        /// <summary>
        /// The confusion matrix of the predicted true labels against the gold labels
        /// The rows are the gold labels and the columns are the predicted labels.
        /// </summary>
        public double[,] ModelConfusionMatrix
        {
            get;
            private set;
        }

        /// <summary>
        /// Flags whether the model instance is CBCC (true) or BCC (false).
        /// </summary>
        public bool IsCommunityModel
        {
            get;
            private set;
        }

        /// <summary>
        /// The number of communities.
        /// </summary>
        public int CommunityCount
        {
            get;
            private set;
        }

        /// <summary>
        /// Runs the majority vote method on the data.
        /// </summary>
        /// <param name="data">The data</param>
        /// <param name="calculateAccuracy">Compute the accuracy (true).</param>
        /// <param name="useVoteDistribution">The true label is sampled from the vote distribution (true) or it is
        /// taken as the mode of the vote counts (false).
        /// In the latter case, ties are broken by sampling from the most voted classes.</param>
        /// <returns>The updated results</returns>
        public Results RunMajorityVote(IList<Datum> data, bool calculateAccuracy, bool useVoteDistribution)
        {
            var dataMapping = new DataMapping(data);
            Mapping = dataMapping;
            GoldLabels = Mapping.GetGoldLabelsPerTaskId();
            var inferredLabels = useVoteDistribution ? dataMapping.GetVoteDistribPerTaskIndex() : dataMapping.GetMajorityVotesPerTaskIndex().Select(mv => mv == null ? (Discrete)null : Discrete.PointMass(mv.Value, dataMapping.LabelCount)).ToArray();
            TrueLabel = inferredLabels.Select((lab, i) => new
            {
                key = dataMapping.TaskIndexToId[i],
                val = lab
            }).ToDictionary(a => a.key, a => a.val);

            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }
            return this;
        }

        /// <summary>
        /// Run Dawid-Skene on the data.
        /// </summary>
        /// <param name="data">The data.</param>
        /// <param name="calculateAccuracy">Whether to calculate accuracy</param>
        /// <returns>A results instance</returns>
        public Results RunDawidSkene(IList<Datum> data, bool calculateAccuracy)
        {
            // If you want to run Dawid-Skene code, download his code, integrate it into
            // the project, and change false to true below.
#if false
            var dataMapping = new DataMapping(data);
            Mapping = dataMapping;
            var labelings = data.Select(d => new Labeling(d.WorkerId, d.TaskId, d.WorkerLabel.ToString(), d.GoldLabel.ToString())).ToList();
            DawidSkene ds = new DawidSkene(labelings, null, null);
            // The labels may be in a different order from our data labeling - we need to create a map.
            int[] labelIndexMap = new int[dataMapping.LabelCount];
            var dwLabels = ds.classes.Keys.ToArray();
            for (int i = 0; i < dataMapping.LabelCount; i++)
            {
                labelIndexMap[i] = Array.IndexOf(dwLabels, (i + dataMapping.LabelMin).ToString());
            }

            GoldLabels = Mapping.GetGoldLabelsPerTaskId().
                ToDictionary(kvp => kvp.Key, kvp => kvp.Value == null ? (int?)null : (int?)labelIndexMap[kvp.Value.Value]);

            ds.Estimate(10);

            var inferredLabels = ds.GetObjectClassProbabilities().Select(r => new Discrete(r)).ToArray();
            TrueLabel = inferredLabels.Select((lab, i) => new
            {
                key = dataMapping.TaskIndexToId[i],
                val = lab
            }).ToDictionary(a => a.key, a => a.val);

            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }

            return this;
#else
            throw new ApplicationException("To support Dawid-Skene, you must link to the C# version of their code");
#endif
        }

        /// <summary>
        /// The different modes in which the model can be run.
        /// </summary>
        public enum RunMode
        {
            /// <summary>
            /// Clears all posteriors
            /// </summary>
            ClearResults,
            /// <summary>
            /// Training from a batch of data - uses initial priors.
            /// </summary>
            BatchTraining,
            /// <summary>
            /// Online training from a batch of data - uses previous posteriors as priors.
            /// </summary>
            OnlineTraining,
            /// <summary>
            /// Online training where we don't update the posteriors
            /// </summary>
            LookAheadExperiment,
            /// <summary>
            /// Use communities as workers in a BCC
            /// </summary>
            LoadAndUseCommunityPriors,
            /// <summary>
            /// Prediction of worker labels
            /// </summary>
            Prediction,
        };

        /// <summary>
        /// The structure with the model parameters.
        /// </summary>
        [Serializable]
        public struct NonTaskWorkerParameters
        {
            public Dirichlet BackgroundLabelProb;
            public Dirichlet CommunityProb;
            public VectorGaussian[][] CommunityScoreMatrix;
        }

        /// <summary>
        /// Runs the BCC or CBCC model.
        /// </summary>
        /// <param name="modelName">The model name.</param>
        /// <param name="data">The data that will be used for this run.</param>
        /// <param name="fullData">The full data set of data.</param>
        /// <param name="model">The model instance (BCC or CBCC).</param>
        /// <param name="mode">The mode (for example training, prediction, etc.).</param>
        /// <param name="calculateAccuracy">Whether to calculate accuracy.</param>
        /// <param name="numCommunities">The number of communities (community model only).</param>
        /// <param name="serialize">Whether to serialize all posteriors.</param>
        /// <param name="serializeCommunityPosteriors">Whether to serialize community posteriors.</param>
        public void RunBCC(string modelName, IList<Datum> data, IList<Datum> fullData, BCC model, RunMode mode, bool calculateAccuracy, int numCommunities = -1, bool serialize = false, bool serializeCommunityPosteriors = false)
        {
            CommunityModel communityModel = model as CommunityModel;
            IsCommunityModel = communityModel != null;

            if (this.Mapping == null)
            {
                this.Mapping = new DataMapping(fullData, numCommunities);
                this.GoldLabels = this.Mapping.GetGoldLabelsPerTaskId();
            }

            /// A new model is created if the label count or the task count has changed
            bool createModel = (Mapping.LabelCount != model.LabelCount) || (Mapping.TaskCount != model.TaskCount);

            if (IsCommunityModel)
            {

                /// Creates a new CBCC model instance
                CommunityCount = numCommunities;
                createModel = createModel || (numCommunities != communityModel.CommunityCount);
                if (createModel)
                {
                    communityModel.CreateModel(Mapping.TaskCount, Mapping.LabelCount, numCommunities);
                }

            }
            else if (createModel)
            {
                /// Creates a new BCC model instance
                model.CreateModel(Mapping.TaskCount, Mapping.LabelCount);
            }

            /// Selects the prior according to the run mode
            BCC.Posteriors priors = null;
            switch (mode)
            {
                /// Use existing priors
                case RunMode.OnlineTraining:
                case RunMode.LookAheadExperiment:
                case RunMode.Prediction:
                    priors = ToPriors();
                    break;
                default:

                    /// Use default priors
                    ClearResults();
                    if (mode == RunMode.LoadAndUseCommunityPriors && IsCommunityModel)
                    {
                        priors = DeserializeCommunityPosteriors(modelName, numCommunities);
                    }
                    break;
            }

            /// Get data to observe
            var labelsPerWorkerIndex = Mapping.GetLabelsPerWorkerIndex(data);
            if (mode == RunMode.Prediction)
            {
                /// Signal prediction mode by setting all labels to null
                labelsPerWorkerIndex = labelsPerWorkerIndex.Select(arr => (int[])null).ToArray();
            }

            /// Run model inference
            BCC.Posteriors posteriors = model.Infer(
                Mapping.GetTaskIndicesPerWorkerIndex(data),
                labelsPerWorkerIndex, priors);
            UpdateResults(posteriors, mode);

            /// Compute accuracy
            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }

            /// Serialize parameters
            if (serialize)
            {
                using (FileStream stream = new FileStream(modelName + ".xml", FileMode.Create))
                {
                    var serializer = new System.Xml.Serialization.XmlSerializer(IsCommunityModel ? typeof(CommunityModel.Posteriors) : typeof(BCC.Posteriors));
                    serializer.Serialize(stream, posteriors);
                }
            }

            if (serializeCommunityPosteriors && IsCommunityModel)
            {
                SerializeCommunityPosteriors(modelName);
            }
        }

        /// <summary>
        /// Serializes the posteriors on an xml file.
        /// </summary>
        /// <param name="modelName">The model name.</param>
        void SerializeCommunityPosteriors(string modelName)
        {
            NonTaskWorkerParameters ntwp = new NonTaskWorkerParameters();
            ntwp.BackgroundLabelProb = BackgroundLabelProb;
            ntwp.CommunityProb = CommunityProb;
            ntwp.CommunityScoreMatrix = CommunityScoreMatrix;
            using (FileStream stream = new FileStream(modelName + "CommunityPriors.xml", FileMode.Create))
            {
                var serializer = new System.Xml.Serialization.XmlSerializer(typeof(NonTaskWorkerParameters));
                serializer.Serialize(stream, ntwp);
            }
        }

        /// <summary>
        /// Deserializes the parameters of CBCC from an xml file (used in the LoadAndUseCommunityPriors mode).
        /// </summary>
        /// <param name="modelName">The model name.</param>
        /// <param name="numCommunities">The number of communities.</param>
        /// <returns></returns>
        CommunityModel.Posteriors DeserializeCommunityPosteriors(string modelName, int numCommunities)
        {
            CommunityModel.Posteriors cbccPriors = new CommunityModel.Posteriors();
            using (FileStream stream = new FileStream(modelName + "CommunityPriors.xml", FileMode.Open))
            {
                var serializer = new System.Xml.Serialization.XmlSerializer(typeof(NonTaskWorkerParameters));
                var ntwp = (NonTaskWorkerParameters)serializer.Deserialize(stream);

                if (ntwp.BackgroundLabelProb.Dimension != Mapping.LabelCount)
                {
                    throw new ApplicationException("Unexpected number of labels");
                }

                BackgroundLabelProb = ntwp.BackgroundLabelProb;
                cbccPriors.BackgroundLabelProb = ntwp.BackgroundLabelProb;
                if (ntwp.CommunityScoreMatrix.Length != numCommunities)
                {
                    throw new ApplicationException("Unexpected number of communities");
                }

                if (ntwp.CommunityScoreMatrix[0][0].Dimension != Mapping.LabelCount)
                {
                    throw new ApplicationException("Unexpected number of labels");
                }

                CommunityScoreMatrix = ntwp.CommunityScoreMatrix;
                cbccPriors.CommunityScoreMatrix = ntwp.CommunityScoreMatrix;

                if (ntwp.CommunityProb.Dimension != numCommunities)
                {
                    throw new ApplicationException("Unexpected number of communities");
                }

                CommunityProb = ntwp.CommunityProb;
                cbccPriors.CommunityProb = ntwp.CommunityProb;
            }

            return cbccPriors;
        }

        /// <summary>
        /// Resets all the parameters to the default values.
        /// </summary>
        void ClearResults()
        {
            BackgroundLabelProb = Dirichlet.Uniform(Mapping.LabelCount);
            WorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            WorkerPrediction = new Dictionary<string, Dictionary<String, Discrete>>();
            WorkerCommunity = new Dictionary<string, Discrete>();
            TrueLabel = new Dictionary<string, Discrete>();
            TrueLabelConstraint = new Dictionary<string, Discrete>();
            CommunityConfusionMatrix = null;
            WorkerScoreMatrixConstraint = new Dictionary<string, VectorGaussian[]>();
            CommunityProb = null;
            CommunityScoreMatrix = null;
            CommunityConstraint = new Dictionary<string, Discrete>();
            LookAheadTrueLabel = new Dictionary<string, Discrete>();
            LookAheadWorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            ModelEvidence = new Bernoulli(0.5);
        }

        /// <summary>
        /// Updates the results of with the new posteriors.
        /// </summary>
        /// <param name="posteriors">The posteriors.</param>
        /// <param name="mode">The mode (for example training, prediction, etc.).</param>
        void UpdateResults(BCC.Posteriors posteriors, RunMode mode)
        {

            /// In the lookAheadExperiment mode, update only the LookAhead results
            if (mode == RunMode.LookAheadExperiment)
            {
                for (int t = 0; t < posteriors.TrueLabel.Length; t++)
                {
                    LookAheadTrueLabel[Mapping.TaskIndexToId[t]] = posteriors.TrueLabel[t];
                }
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    LookAheadWorkerConfusionMatrix[Mapping.WorkerIndexToId[w]] = posteriors.WorkerConfusionMatrix[w];
                }
            }

            /// In the prediction mode, update only the worker prediction results
            else if (mode == RunMode.Prediction)
            {
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    WorkerPrediction[Mapping.WorkerIndexToId[w]] = new Dictionary<string, Discrete>();
                    for (int tw = 0; tw < posteriors.WorkerPrediction[w].Length; tw++)
                    {
                        WorkerPrediction[Mapping.WorkerIndexToId[w]][Mapping.TaskIndexToId[tw]] = posteriors.WorkerPrediction[w][tw];
                    }
                }
            }
            else
            {
                bool isCommunityModel = posteriors is CommunityModel.Posteriors communityPosteriors;
                BackgroundLabelProb = posteriors.BackgroundLabelProb;
                for (int w = 0; w < posteriors.WorkerConfusionMatrix.Length; w++)
                {
                    WorkerConfusionMatrix[Mapping.WorkerIndexToId[w]] = posteriors.WorkerConfusionMatrix[w];
                }
                for (int t = 0; t < posteriors.TrueLabel.Length; t++)
                {
                    TrueLabel[Mapping.TaskIndexToId[t]] = posteriors.TrueLabel[t];
                }
                for (int t = 0; t < posteriors.TrueLabelConstraint.Length; t++)
                {
                    TrueLabelConstraint[Mapping.TaskIndexToId[t]] = posteriors.TrueLabelConstraint[t];
                }

                if (isCommunityModel)
                {
                    CommunityConfusionMatrix = communityPosteriors.CommunityConfusionMatrix;
                    for (int w = 0; w < communityPosteriors.WorkerScoreMatrixConstraint.Length; w++)
                    {
                        WorkerScoreMatrixConstraint[Mapping.WorkerIndexToId[w]] = communityPosteriors.WorkerScoreMatrixConstraint[w];
                        CommunityConstraint[Mapping.WorkerIndexToId[w]] = communityPosteriors.WorkerCommunityConstraint[w];
                        WorkerCommunity[Mapping.WorkerIndexToId[w]] = communityPosteriors.Community[w];
                    }

                    CommunityProb = communityPosteriors.CommunityProb;
                    CommunityScoreMatrix = communityPosteriors.CommunityScoreMatrix;
                }

                this.ModelEvidence = posteriors.Evidence;
            }
        }

        /// <summary>
        /// Loads the priors of BCC and CBCC.
        /// </summary>
        /// <returns>A BCC posterior instance with the loaded priors.</returns>
        BCC.Posteriors ToPriors()
        {
            int numClasses = Mapping.LabelCount;
            int numTasks = Mapping.TaskCount;
            int numWorkers = Mapping.WorkerCount;
            CommunityModel.Posteriors cbccPriors = new CommunityModel.Posteriors();
            BCC.Posteriors priors = IsCommunityModel ? cbccPriors : new BCC.Posteriors();

            /// Loads the prior of the background probabilities of the tasks
            priors.BackgroundLabelProb = BackgroundLabelProb;

            /// Loads the prior of the confusion matrix of each worker
            priors.WorkerConfusionMatrix = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (WorkerConfusionMatrix.ContainsKey(wid))
                        return Util.ArrayInit(numClasses, lab => WorkerConfusionMatrix[wid][lab]);
                    else
                        return Util.ArrayInit(numClasses, lab => Dirichlet.Uniform(numClasses));
                });

            /// Loads the true label constraint of each task
            priors.TrueLabelConstraint = Util.ArrayInit(numTasks,
                t =>
                {
                    string tid = Mapping.TaskIndexToId[t];
                    if (TrueLabelConstraint.ContainsKey(tid))
                        return TrueLabelConstraint[Mapping.TaskIndexToId[t]];
                    else
                        return Discrete.Uniform(numClasses);
                });

            /// Loads the priors of the parameters of CBCC
            if (IsCommunityModel)
            {
                cbccPriors.CommunityConfusionMatrix = CommunityConfusionMatrix;
                cbccPriors.WorkerScoreMatrixConstraint = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (WorkerScoreMatrixConstraint.ContainsKey(wid))
                        return Util.ArrayInit(numClasses, lab => WorkerScoreMatrixConstraint[wid][lab]);
                    else
                        return Util.ArrayInit(numClasses, lab => VectorGaussian.Uniform(numClasses));
                });
                cbccPriors.CommunityProb = CommunityProb;
                cbccPriors.CommunityScoreMatrix = CommunityScoreMatrix;
                cbccPriors.WorkerCommunityConstraint = Util.ArrayInit(numWorkers,
                w =>
                {
                    string wid = Mapping.WorkerIndexToId[w];
                    if (CommunityConstraint.ContainsKey(wid))
                        return CommunityConstraint[wid];
                    else
                        return Discrete.Uniform(CommunityCount);
                });
            }

            priors.Evidence = ModelEvidence;

            return priors;
        }

        /// <summary>
        /// Updates the accuracy using the current results.
        /// </summary>
        private void UpdateAccuracy()
        {
            double nlpdThreshold = -Math.Log(0.001);
            int labelCount = TrueLabel.First(kvp => kvp.Value != null).Value.Dimension;
            var confusionMatrix = Util.ArrayInit(labelCount, labelCount, (i, j) => 0.0);
            int correct = 0;
            double logProb = 0.0;

            int goldX = 0;
            foreach (var kvp in GoldLabels)
            {
                if (kvp.Value == null)
                    continue;

                // We have a gold label
                goldX++;

                var trueLabel = TrueLabel[kvp.Key];
                if (trueLabel == null)
                    continue;  // No inferred label

                var probs = trueLabel.GetProbs();
                var max = probs.Max();
                var predictedLabels = probs.Select((p, i) => new
                {
                    prob = p,
                    idx = i
                }).Where(a => a.prob == max).Select(a => a.idx).ToArray();
                int predictedLabel = predictedLabels.Length == 1 ? predictedLabels[0] : predictedLabels[Rand.Int(predictedLabels.Length)];
                int goldLabel = kvp.Value.Value;

                confusionMatrix[goldLabel, predictedLabel] = confusionMatrix[goldLabel, predictedLabel] + 1.0;

                if (goldLabel == predictedLabel)
                    correct++;

                var nlp = -trueLabel.GetLogProb(goldLabel);
                if (nlp > nlpdThreshold)
                    nlp = nlpdThreshold;
                logProb += nlp;
            }

            Accuracy = correct / (double)goldX;
            NegativeLogProb = logProb / (double)goldX;
            ModelConfusionMatrix = confusionMatrix;

            // Compute average recall
            double sumRec = 0;
            for (int i = 0; i < labelCount; i++)
            {
                double classSum = 0;
                for (int j = 0; j < labelCount; j++)
                {
                    classSum += confusionMatrix[i, j];
                }

                sumRec += confusionMatrix[i, i] / classSum;
            }
            AvgRecall = sumRec / labelCount;
        }

        /// <summary>
        /// Writes out the mean of an uncertain confusion matrix to a StreamWriter.
        /// The confusion matrix is passed as an of Dirichlets, one for each row
        /// of the confusion matrix (as given by the posteriors from the model).
        /// </summary>
        /// <param name="writer">A| StreamWriter instance.</param>
        /// <param name="worker">The worker id.</param>
        /// <param name="confusionMatrix">The confusion matrix</param>
        private static void WriteConfusionMatrix(StreamWriter writer, string worker, Dirichlet[] confusionMatrix)
        {
            int labelCount = confusionMatrix.Length;
            var meanConfusionMatrix = confusionMatrix.Select(cm => cm.GetMean()).ToArray();
            var printableConfusionMatrix = Util.ArrayInit(labelCount, labelCount, (i, j) => meanConfusionMatrix[i][j]);
            WriteWorkerConfusionMatrix(writer, worker, printableConfusionMatrix);
        }

        /// <summary>
        /// Writes the a confusion matrix to a stream writer.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="worker">The worker id.</param>
        /// <param name="confusionMatrix">The confusion matrix.</param>
        private static void WriteWorkerConfusionMatrix(StreamWriter writer, string worker, double[,] confusionMatrix)
        {
            int labelCount = confusionMatrix.GetLength(0);
            writer.WriteLine(worker);
            for (int j = 0; j < labelCount; j++)
                writer.Write(",{0}", j);
            writer.WriteLine();

            for (int i = 0; i < labelCount; i++)
            {
                writer.Write(i);
                for (int j = 0; j < labelCount; j++)
                    writer.Write(",{0:0.0000}", confusionMatrix[i, j]);

                writer.WriteLine();
            }
        }

        /// <summary>
        /// Writes various results to a StreamWriter.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="writeCommunityParameters">Set true to write community parameters.</param>
        /// <param name="writeWorkerParameters">Set true to write worker parameters.</param>
        /// <param name="writeWorkerCommunities">Set true to write worker communities.</param>
        public void WriteResults(StreamWriter writer, bool writeCommunityParameters, bool writeWorkerParameters, bool writeWorkerCommunities)
        {
            this.WriteAccuracy(writer);

            if (writeCommunityParameters && this.CommunityConfusionMatrix != null)
            {
                for (int communityIndex = 0; communityIndex < this.CommunityConfusionMatrix.Length; communityIndex++)
                {
                    WriteConfusionMatrix(writer, "Community" + communityIndex, this.CommunityConfusionMatrix[communityIndex]);
                }
            }

            if (writeWorkerParameters && this.WorkerConfusionMatrix != null)
            {
                foreach (var kvp in this.WorkerConfusionMatrix)
                {
                    WriteConfusionMatrix(writer, kvp.Key, kvp.Value);
                }
            }

            if (writeWorkerCommunities && this.WorkerCommunity != null)
            {
                foreach (var kvp in this.WorkerCommunity)
                {
                    writer.WriteLine(string.Format("{0}:\t{1}", kvp.Key, kvp.Value));
                }
            }

            writer.WriteLine("Log Evidence = {0:0.0000}", ModelEvidence.LogOdds);
        }

        /// <summary>
        /// Writes the accuracy results on the StreamWriter.
        /// </summary>
        /// <param name="writer">The StreamWriter.</param>
        public void WriteAccuracy(StreamWriter writer)
        {
            writer.WriteLine("Accuracy = {0:0.000}", this.Accuracy);
            writer.WriteLine("Mean negative log prob density = {0:0.000}", this.NegativeLogProb);
            WriteWorkerConfusionMatrix(writer, "Model confusion matrix", this.ModelConfusionMatrix);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Examples\Crowdsourcing\Results.cs(578,48): error CS0165: Use of unassigned local variable 'communityPosteriors'
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\Examples\CrowdsourcingWithWords\ResultsWords.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace CrowdsourcingWithWords
{
    /// <summary>
    /// Results class containing posteriors and predictions of BCCWords.
    /// </summary>
    public class ResultsWords : Results
    {
        /// <summary>
        /// The posterior of the word probabilities for each true label.
        /// </summary>
        public Dirichlet[] ProbWords
        {
            get;
            private set;
        }

        /// <summary>
        /// The vocabulary
        /// </summary>
        public List<string> Vocabulary
        {
            get;
            set;
        }

        /// <summary>
        /// Creates an object for storing the inference results of BCCWords
        /// </summary>
        /// <param name="data">The data</param>
        /// <param name="vocabulary">The vocabulary</param>
        public ResultsWords(IList<Datum> data, List<string> vocabulary)
        {
            if (vocabulary == null)
            {
                // Build vocabulary
                Console.Write("Building vocabulary...");
                Stopwatch stopwatch = new Stopwatch();
                stopwatch.Start();
                string[] corpus = data.Select(d => d.BodyText).Distinct().ToArray();
                Vocabulary = BuildVocabularyFromCorpus(corpus);
                Console.WriteLine("done. Elapsed time: {0}", stopwatch.Elapsed);
            }

            // Build data mapping
            Vocabulary = vocabulary;
            this.Mapping = new DataMappingWords(data, vocabulary);
            this.GoldLabels = Mapping.GetGoldLabelsPerTaskId();
        }

        /// <summary>
        /// Runs the majority vote method on the data.
        /// </summary>
        /// <param name="modelName"></param>
        /// <param name="data">The data</param>
        /// <param name="mode"></param>
        /// <param name="calculateAccuracy">Compute the accuracy (true).</param>
        /// <param name="fullData"></param>
        /// <param name="model"></param>
        /// <param name="useMajorityVote"></param>
        /// <param name="useRandomLabel"></param>
        /// <returns>The updated results</returns>
        public void RunBCCWords(string modelName,
            IList<Datum> data,
            IList<Datum> fullData,
            BCCWords model,
            RunMode mode,
            bool calculateAccuracy,
            bool useMajorityVote = false,
            bool useRandomLabel = false)
        {
            DataMappingWords MappingWords = null;
            if (FullMapping == null)
                FullMapping = new DataMapping(fullData);

            if (Mapping == null)
            {
                // Build vocabulary
                Console.Write("Building vocabulary...");
                Stopwatch stopwatch = new Stopwatch();
                stopwatch.Start();
                string[] corpus = data.Select(d => d.BodyText).Distinct().ToArray();
                Vocabulary = BuildVocabularyFromCorpus(corpus);
                Console.WriteLine("done. Elapsed time: {0}", stopwatch.Elapsed);

                // Build data mapping
                this.Mapping = new DataMappingWords(data, MappingWords.Vocabulary);
                MappingWords = Mapping as DataMappingWords;
                this.GoldLabels = MappingWords.GetGoldLabelsPerTaskId();
            }

            MappingWords = Mapping as DataMappingWords;
            int[] trueLabels = null;
            if (useMajorityVote)
            {
                if (MappingWords != null)
                {
                    var majorityLabel = MappingWords.GetMajorityVotesPerTaskId(data);
                    trueLabels = Util.ArrayInit(FullMapping.TaskCount, i => majorityLabel.ContainsKey(Mapping.TaskIndexToId[i]) ? (int)majorityLabel[Mapping.TaskIndexToId[i]] : Rand.Int(Mapping.LabelMin, Mapping.LabelMax + 1));
                    data = MappingWords.BuildDataFromAssignedLabels(majorityLabel, data);
                }
            }

            if (useRandomLabel)
            {
                var randomLabels = MappingWords.GetRandomLabelPerTaskId(data);
                data = MappingWords.BuildDataFromAssignedLabels(randomLabels, data);
            }

            var labelsPerWorkerIndex = MappingWords.GetLabelsPerWorkerIndex(data);
            var taskIndicesPerWorkerIndex = MappingWords.GetTaskIndicesPerWorkerIndex(data);

            // Create model
            ClearResults();
            model.CreateModel(MappingWords.TaskCount, MappingWords.LabelCount, MappingWords.WordCount);

            // Run model inference
            BCCWordsPosteriors posteriors = model.InferPosteriors(labelsPerWorkerIndex, taskIndicesPerWorkerIndex, MappingWords.WordIndicesPerTaskIndex, MappingWords.WordCountsPerTaskIndex, trueLabels);

            // Update results
            UpdateResults(posteriors, mode);

            // Compute accuracy
            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }
        }

		protected override void UpdateResults(BCCPosteriors posteriors, RunMode mode)
		{
			base.UpdateResults(posteriors, mode);
			var wordsPosteriors = posteriors as BCCWordsPosteriors;
			if (wordsPosteriors?.ProbWordPosterior != null)
			{
				this.ProbWords = wordsPosteriors.ProbWordPosterior;
			}
		}

		/// <summary>
		/// Select high TFIDF terms
		/// </summary>
		/// <param name="corpus">array of terms</param>
		/// <param name="tfidf_threshold">TFIDF threshold</param>
		/// <returns></returns>
		private static List<string> BuildVocabularyFromCorpus(string[] corpus, double tfidf_threshold = 0.8)
        {
            List<string> vocabulary;
            double[][] inputs = TFIDFClass.Transform(corpus, out vocabulary, 0);
            inputs = TFIDFClass.Normalize(inputs);

            // Select high TF_IDF terms
            List<string> vocabularyTfidf = new List<string>();
            for (int index = 0; index < inputs.Length; index++)
            {
                var sortedTerms = inputs[index].Select((x, i) => new KeyValuePair<string, double>(vocabulary[i], x)).OrderByDescending(x => x.Value).ToList();
                vocabularyTfidf.AddRange(sortedTerms.Where(entry => entry.Value > tfidf_threshold).Select(k => k.Key).ToList());
            }
			var filteredVocabulary = vocabularyTfidf.Distinct().ToList();
	        return filteredVocabulary.Count>=10 ? filteredVocabulary : vocabulary;
		}

        protected override void ClearResults()
        {
            BackgroundLabelProb = Dirichlet.Uniform(Mapping.LabelCount);
            WorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            WorkerPrediction = new Dictionary<string, Dictionary<String, Discrete>>();
            WorkerCommunity = new Dictionary<string, Discrete>();
            TrueLabel = new Dictionary<string, Discrete>();
            PredictedLabel = new Dictionary<string, int?>();
            TrueLabelConstraint = new Dictionary<string, Discrete>();
            CommunityConfusionMatrix = null;
            WorkerScoreMatrixConstraint = new Dictionary<string, VectorGaussian[]>();
            CommunityProb = null;
            CommunityScoreMatrix = null;
            CommunityConstraint = new Dictionary<string, Discrete>();
            LookAheadTrueLabel = new Dictionary<string, Discrete>();
            LookAheadWorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            ModelEvidence = new Bernoulli(0.5);
            ProbWords = null;
        }

        /// <summary>
        /// Writes various results to a StreamWriter.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="writeCommunityParameters">Set true to write community parameters.</param>
        /// <param name="writeWorkerParameters">Set true to write worker parameters.</param>
        /// <param name="writeWorkerCommunities">Set true to write worker communities.</param>
        /// <param name="writeProbWords">Set true to write word probabilities</param>
        /// <param name="topWords">Number of words to select</param>
        public void WriteResults(StreamWriter writer, bool writeCommunityParameters, bool writeWorkerParameters, bool writeWorkerCommunities, bool writeProbWords, int topWords = 30)
        {
            base.WriteResults(writer, writeCommunityParameters, writeWorkerCommunities, writeWorkerCommunities);
            DataMappingWords MappingWords = Mapping as DataMappingWords;
            if (writeProbWords && this.ProbWords != null)
            {
                int NumClasses = ProbWords.Length;
				var classifiedWords = new Dictionary<string, KeyValuePair<string, double>>();
                for (int c = 0; c < NumClasses; c++)
                {
	                string className = string.Empty;
	                if (MappingWords != null)
	                {
		                if (MappingWords.WorkerCount > 100) // Assume it's CF
						{
			                className = MappingWords.CFLabelName[c];
		                }
		                else
		                {
							className = MappingWords.SPLabelName[c];
						}
		                writer.WriteLine($"Class {className}");
	                }

                    Vector probs = ProbWords[c].GetMean();
                    var probsDictionary = probs.Select((value, index) => new KeyValuePair<string, double>(MappingWords.Vocabulary[index], Math.Log(value))).OrderByDescending(x => x.Value).ToArray();
	                topWords = Math.Min(topWords, probsDictionary.Length);
                    for (int w = 0; w < topWords; w++)
                    {
                        writer.WriteLine($"\t{probsDictionary[w].Key}: \t{probsDictionary[w].Value:0.000}");
	                    if (!string.IsNullOrEmpty(className))
	                    {
		                    KeyValuePair<string, double> classifiedWord ;
		                    if (!classifiedWords.TryGetValue(probsDictionary[w].Key,out classifiedWord)
								|| classifiedWord.Value< probsDictionary[w].Value)
		                    {
			                    classifiedWords[probsDictionary[w].Key] = new KeyValuePair<string, double>(className, probsDictionary[w].Value);
		                    }
	                    }
                    }
                }
	            writer.WriteLine();
				writer.WriteLine($"Main classes:");
				foreach (var wordByClass in classifiedWords.GroupBy(classified=>classified.Value.Key))
	            {
		            writer.WriteLine($"Class {wordByClass.Key}:");
		            foreach (var word in wordByClass.OrderByDescending(w=>w.Value.Value))
		            {
			            writer.WriteLine($"\t{word.Key}");
					}
					
				}
            }
        }

        /// <summary>
        /// Build a vocabulary of terms for a subset of text snippets extracted from the data
        /// </summary>
        /// <param name="data">the data</param>
        /// <returns></returns>
        public static List<string> BuildVocabularyOnSubdata(List<Datum> data)
        {
            Console.WriteLine("Building vocabulary");
            var subData = data.Where((k, i) => i < 20000).ToList();
            string[] corpus = subData.Select(d => d.BodyText).Distinct().ToArray();
            var vocabularyOnSubData = BuildVocabularyFromCorpus(corpus);
            if (vocabularyOnSubData.Count > 300)
                return vocabularyOnSubData.GetRange(0, 300);
            else
                return vocabularyOnSubData;
        }
    }
}

---- Transformed Tree ----
using Microsoft.ML.Probabilistic.Distributions;
using Microsoft.ML.Probabilistic.Math;
using Microsoft.ML.Probabilistic.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace CrowdsourcingWithWords
{
    /// <summary>
    /// Results class containing posteriors and predictions of BCCWords.
    /// </summary>
    public class ResultsWords : Results
    {
        /// <summary>
        /// The posterior of the word probabilities for each true label.
        /// </summary>
        public Dirichlet[] ProbWords
        {
            get;
            private set;
        }

        /// <summary>
        /// The vocabulary
        /// </summary>
        public List<string> Vocabulary
        {
            get;
            set;
        }

        /// <summary>
        /// Creates an object for storing the inference results of BCCWords
        /// </summary>
        /// <param name="data">The data</param>
        /// <param name="vocabulary">The vocabulary</param>
        public ResultsWords(IList<Datum> data, List<string> vocabulary)
        {
            if (vocabulary == null)
            {
                // Build vocabulary
                Console.Write("Building vocabulary...");
                Stopwatch stopwatch = new Stopwatch();
                stopwatch.Start();
                string[] corpus = data.Select(d => d.BodyText).Distinct().ToArray();
                Vocabulary = BuildVocabularyFromCorpus(corpus);
                Console.WriteLine("done. Elapsed time: {0}", stopwatch.Elapsed);
            }

            // Build data mapping
            Vocabulary = vocabulary;
            this.Mapping = new DataMappingWords(data, vocabulary);
            this.GoldLabels = Mapping.GetGoldLabelsPerTaskId();
        }

        /// <summary>
        /// Runs the majority vote method on the data.
        /// </summary>
        /// <param name="modelName"></param>
        /// <param name="data">The data</param>
        /// <param name="mode"></param>
        /// <param name="calculateAccuracy">Compute the accuracy (true).</param>
        /// <param name="fullData"></param>
        /// <param name="model"></param>
        /// <param name="useMajorityVote"></param>
        /// <param name="useRandomLabel"></param>
        /// <returns>The updated results</returns>
        public void RunBCCWords(string modelName,
            IList<Datum> data,
            IList<Datum> fullData,
            BCCWords model,
            RunMode mode,
            bool calculateAccuracy,
            bool useMajorityVote = false,
            bool useRandomLabel = false)
        {
            DataMappingWords MappingWords = null;
            if (FullMapping == null)
                FullMapping = new DataMapping(fullData);

            if (Mapping == null)
            {
                // Build vocabulary
                Console.Write("Building vocabulary...");
                Stopwatch stopwatch = new Stopwatch();
                stopwatch.Start();
                string[] corpus = data.Select(d => d.BodyText).Distinct().ToArray();
                Vocabulary = BuildVocabularyFromCorpus(corpus);
                Console.WriteLine("done. Elapsed time: {0}", stopwatch.Elapsed);

                // Build data mapping
                this.Mapping = new DataMappingWords(data, MappingWords.Vocabulary);
                MappingWords = Mapping as DataMappingWords;
                this.GoldLabels = MappingWords.GetGoldLabelsPerTaskId();
            }

            MappingWords = Mapping as DataMappingWords;
            int[] trueLabels = null;
            if (useMajorityVote)
            {
                if (MappingWords != null)
                {
                    var majorityLabel = MappingWords.GetMajorityVotesPerTaskId(data);
                    trueLabels = Util.ArrayInit(FullMapping.TaskCount, i => majorityLabel.ContainsKey(Mapping.TaskIndexToId[i]) ? (int)majorityLabel[Mapping.TaskIndexToId[i]] : Rand.Int(Mapping.LabelMin, Mapping.LabelMax + 1));
                    data = MappingWords.BuildDataFromAssignedLabels(majorityLabel, data);
                }
            }

            if (useRandomLabel)
            {
                var randomLabels = MappingWords.GetRandomLabelPerTaskId(data);
                data = MappingWords.BuildDataFromAssignedLabels(randomLabels, data);
            }

            var labelsPerWorkerIndex = MappingWords.GetLabelsPerWorkerIndex(data);
            var taskIndicesPerWorkerIndex = MappingWords.GetTaskIndicesPerWorkerIndex(data);

            // Create model
            ClearResults();
            model.CreateModel(MappingWords.TaskCount, MappingWords.LabelCount, MappingWords.WordCount);

            // Run model inference
            BCCWordsPosteriors posteriors = model.InferPosteriors(labelsPerWorkerIndex, taskIndicesPerWorkerIndex, MappingWords.WordIndicesPerTaskIndex, MappingWords.WordCountsPerTaskIndex, trueLabels);

            // Update results
            UpdateResults(posteriors, mode);

            // Compute accuracy
            if (calculateAccuracy)
            {
                UpdateAccuracy();
            }
        }

		protected override void UpdateResults(BCCPosteriors posteriors, RunMode mode)
		{
			base.UpdateResults(posteriors, mode);
			var wordsPosteriors = posteriors as BCCWordsPosteriors;
			if (wordsPosteriors?.ProbWordPosterior != null)
			{
				this.ProbWords = wordsPosteriors.ProbWordPosterior;
			}
		}

		/// <summary>
		/// Select high TFIDF terms
		/// </summary>
		/// <param name="corpus">array of terms</param>
		/// <param name="tfidf_threshold">TFIDF threshold</param>
		/// <returns></returns>
		private static List<string> BuildVocabularyFromCorpus(string[] corpus, double tfidf_threshold = 0.8)
        {
            List<string> vocabulary;
            double[][] inputs = TFIDFClass.Transform(corpus, out vocabulary, 0);
            inputs = TFIDFClass.Normalize(inputs);

            // Select high TF_IDF terms
            List<string> vocabularyTfidf = new List<string>();
            for (int index = 0; index < inputs.Length; index++)
            {
                var sortedTerms = inputs[index].Select((x, i) => new KeyValuePair<string, double>(vocabulary[i], x)).OrderByDescending(x => x.Value).ToList();
                vocabularyTfidf.AddRange(sortedTerms.Where(entry => entry.Value > tfidf_threshold).Select(k => k.Key).ToList());
            }
			var filteredVocabulary = vocabularyTfidf.Distinct().ToList();
	        return filteredVocabulary.Count>=10 ? filteredVocabulary : vocabulary;
		}

        protected override void ClearResults()
        {
            BackgroundLabelProb = Dirichlet.Uniform(Mapping.LabelCount);
            WorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            WorkerPrediction = new Dictionary<string, Dictionary<String, Discrete>>();
            WorkerCommunity = new Dictionary<string, Discrete>();
            TrueLabel = new Dictionary<string, Discrete>();
            PredictedLabel = new Dictionary<string, int?>();
            TrueLabelConstraint = new Dictionary<string, Discrete>();
            CommunityConfusionMatrix = null;
            WorkerScoreMatrixConstraint = new Dictionary<string, VectorGaussian[]>();
            CommunityProb = null;
            CommunityScoreMatrix = null;
            CommunityConstraint = new Dictionary<string, Discrete>();
            LookAheadTrueLabel = new Dictionary<string, Discrete>();
            LookAheadWorkerConfusionMatrix = new Dictionary<string, Dirichlet[]>();
            ModelEvidence = new Bernoulli(0.5);
            ProbWords = null;
        }

        /// <summary>
        /// Writes various results to a StreamWriter.
        /// </summary>
        /// <param name="writer">A StreamWriter instance.</param>
        /// <param name="writeCommunityParameters">Set true to write community parameters.</param>
        /// <param name="writeWorkerParameters">Set true to write worker parameters.</param>
        /// <param name="writeWorkerCommunities">Set true to write worker communities.</param>
        /// <param name="writeProbWords">Set true to write word probabilities</param>
        /// <param name="topWords">Number of words to select</param>
        public void WriteResults(StreamWriter writer, bool writeCommunityParameters, bool writeWorkerParameters, bool writeWorkerCommunities, bool writeProbWords, int topWords = 30)
        {
            base.WriteResults(writer, writeCommunityParameters, writeWorkerCommunities, writeWorkerCommunities);
            if (writeProbWords && this.ProbWords != null)
            {
                int NumClasses = ProbWords.Length;
				var classifiedWords = new Dictionary<string, KeyValuePair<string, double>>();
                for (int c = 0; c < NumClasses; c++)
                {
	                string className = string.Empty;

	                if (Mapping is DataMappingWords MappingWords)
	                {
		                if (MappingWords.WorkerCount > 100) // Assume it's CF
						{
			                className = MappingWords.CFLabelName[c];
		                }
		                else
		                {
							className = MappingWords.SPLabelName[c];
						}
		                writer.WriteLine($"Class {className}");
	                }

                    Vector probs = ProbWords[c].GetMean();
                    var probsDictionary = probs.Select((value, index) => new KeyValuePair<string, double>(MappingWords.Vocabulary[index], Math.Log(value))).OrderByDescending(x => x.Value).ToArray();
	                topWords = Math.Min(topWords, probsDictionary.Length);
                    for (int w = 0; w < topWords; w++)
                    {
                        writer.WriteLine($"\t{probsDictionary[w].Key}: \t{probsDictionary[w].Value:0.000}");
	                    if (!string.IsNullOrEmpty(className))
	                    {
		                    KeyValuePair<string, double> classifiedWord ;
		                    if (!classifiedWords.TryGetValue(probsDictionary[w].Key,out classifiedWord)
								|| classifiedWord.Value< probsDictionary[w].Value)
		                    {
			                    classifiedWords[probsDictionary[w].Key] = new KeyValuePair<string, double>(className, probsDictionary[w].Value);
		                    }
	                    }
                    }
                }
	            writer.WriteLine();
				writer.WriteLine($"Main classes:");
				foreach (var wordByClass in classifiedWords.GroupBy(classified=>classified.Value.Key))
	            {
		            writer.WriteLine($"Class {wordByClass.Key}:");
		            foreach (var word in wordByClass.OrderByDescending(w=>w.Value.Value))
		            {
			            writer.WriteLine($"\t{word.Key}");
					}
					
				}
            }
        }

        /// <summary>
        /// Build a vocabulary of terms for a subset of text snippets extracted from the data
        /// </summary>
        /// <param name="data">the data</param>
        /// <returns></returns>
        public static List<string> BuildVocabularyOnSubdata(List<Datum> data)
        {
            Console.WriteLine("Building vocabulary");
            var subData = data.Where((k, i) => i < 20000).ToList();
            string[] corpus = subData.Select(d => d.BodyText).Distinct().ToArray();
            var vocabularyOnSubData = BuildVocabularyFromCorpus(corpus);
            if (vocabularyOnSubData.Count > 300)
                return vocabularyOnSubData.GetRange(0, 300);
            else
                return vocabularyOnSubData;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\Examples\CrowdsourcingWithWords\ResultsWords.cs(229,107): error CS0165: Use of unassigned local variable 'MappingWords'
######################################################################


