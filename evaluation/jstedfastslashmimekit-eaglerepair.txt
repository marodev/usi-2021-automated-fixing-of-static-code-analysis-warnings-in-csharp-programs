Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: MimeKit(net45)
    #1 Path: D:\a\1\s\MimeKit\ContentType.cs, Line: 235, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #2 Path: D:\a\1\s\MimeKit\Cryptography\ArcSigner.cs, Line: 416, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\MimeKit\Cryptography\ArcSigner.cs, Line: 449, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\MimeKit\Cryptography\AsymmetricAlgorithmExtensions.cs, Line: 173, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #5 Path: D:\a\1\s\MimeKit\Cryptography\AsymmetricAlgorithmExtensions.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #6 Path: D:\a\1\s\MimeKit\Cryptography\AsymmetricAlgorithmExtensions.cs, Line: 341, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #7 Path: D:\a\1\s\MimeKit\Cryptography\AsymmetricAlgorithmExtensions.cs, Line: 370, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #8 Path: D:\a\1\s\MimeKit\Cryptography\BouncyCastleSecureMimeContext.cs, Line: 1122, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #9 Path: D:\a\1\s\MimeKit\Cryptography\DkimSigner.cs, Line: 359, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #10 Path: D:\a\1\s\MimeKit\Cryptography\DkimSigner.cs, Line: 444, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #11 Path: D:\a\1\s\MimeKit\Cryptography\DkimSignerBase.cs, Line: 175, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #12 Path: D:\a\1\s\MimeKit\Cryptography\DkimSignerBase.cs, Line: 214, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #13 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifier.cs, Line: 73, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #14 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #15 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #16 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 214, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 220, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #18 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 224, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #19 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 227, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #20 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 230, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #21 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #22 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 239, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #23 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 242, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #24 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 246, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #25 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 257, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #26 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #27 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 271, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #28 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 278, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 289, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 392, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #32 Path: D:\a\1\s\MimeKit\Cryptography\DkimVerifierBase.cs, Line: 486, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #33 Path: D:\a\1\s\MimeKit\Cryptography\MultipartEncrypted.cs, Line: 1047, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #34 Path: D:\a\1\s\MimeKit\Cryptography\MultipartEncrypted.cs, Line: 1146, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\MimeKit\Cryptography\MultipartEncrypted.cs, Line: 1164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\MimeKit\Cryptography\MultipartSigned.cs, Line: 427, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #37 Path: D:\a\1\s\MimeKit\Cryptography\MultipartSigned.cs, Line: 429, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\MimeKit\Cryptography\MultipartSigned.cs, Line: 493, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #39 Path: D:\a\1\s\MimeKit\Cryptography\MultipartSigned.cs, Line: 495, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #40 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 1004, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 1145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 1653, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #43 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #44 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 31, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #45 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 697, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpContextBase.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #47 Path: D:\a\1\s\MimeKit\Cryptography\OpenPgpDigitalSignature.cs, Line: 141, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeContext.cs, Line: 226, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeContext.cs, Line: 228, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeContext.cs, Line: 308, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #51 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeContext.cs, Line: 310, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #52 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeDigitalSignature.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: D:\a\1\s\MimeKit\Cryptography\SecureMimeDigitalSignature.cs, Line: 255, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #54 Path: D:\a\1\s\MimeKit\Cryptography\SqlCertificateDatabase.cs, Line: 274, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #55 Path: D:\a\1\s\MimeKit\Cryptography\SqlCertificateDatabase.cs, Line: 289, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: D:\a\1\s\MimeKit\Cryptography\SqlCertificateDatabase.cs, Line: 309, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #57 Path: D:\a\1\s\MimeKit\Cryptography\SqlCertificateDatabase.cs, Line: 470, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\MimeKit\Cryptography\SqlCertificateDatabase.cs, Line: 524, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\MimeKit\Cryptography\SqliteCertificateDatabase.cs, Line: 314, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #60 Path: D:\a\1\s\MimeKit\Cryptography\SQLServerCertificateDatabase.cs, Line: 145, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #61 Path: D:\a\1\s\MimeKit\Cryptography\TemporarySecureMimeContext.cs, Line: 253, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\MimeKit\Cryptography\TemporarySecureMimeContext.cs, Line: 320, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 181, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #64 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #65 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 315, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #66 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 321, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #67 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 420, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #68 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 423, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #69 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 434, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #70 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 437, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #71 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeContext.cs, Line: 874, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #72 Path: D:\a\1\s\MimeKit\Cryptography\WindowsSecureMimeDigitalSignature.cs, Line: 204, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #73 Path: D:\a\1\s\MimeKit\Cryptography\X509CertificateDatabase.cs, Line: 504, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #74 Path: D:\a\1\s\MimeKit\Cryptography\X509CertificateDatabase.cs, Line: 529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #75 Path: D:\a\1\s\MimeKit\HeaderList.cs, Line: 713, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #76 Path: D:\a\1\s\MimeKit\IO\FilteredStream.cs, Line: 336, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #77 Path: D:\a\1\s\MimeKit\IO\FilteredStream.cs, Line: 530, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #78 Path: D:\a\1\s\MimeKit\IO\FilteredStream.cs, Line: 686, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\MimeKit\MessagePart.cs, Line: 229, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #80 Path: D:\a\1\s\MimeKit\MimeContent.cs, Line: 205, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\MimeKit\MimeContent.cs, Line: 214, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\MimeKit\MimeEntity.cs, Line: 1613, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #83 Path: D:\a\1\s\MimeKit\MimeEntity.cs, Line: 1665, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #84 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 1115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #85 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 2024, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #86 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 2092, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #87 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 2996, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #88 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #89 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 819, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #91 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 915, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #92 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 923, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #93 Path: D:\a\1\s\MimeKit\MimeMessage.cs, Line: 937, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #94 Path: D:\a\1\s\MimeKit\MimeParser.cs, Line: 583, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #95 Path: D:\a\1\s\MimeKit\MimePart.cs, Line: 574, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #96 Path: D:\a\1\s\MimeKit\MimePart.cs, Line: 579, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #97 Path: D:\a\1\s\MimeKit\MimePart.cs, Line: 603, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\MimeKit\MimePart.cs, Line: 663, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #99 Path: D:\a\1\s\MimeKit\Multipart.cs, Line: 453, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #100 Path: D:\a\1\s\MimeKit\Multipart.cs, Line: 483, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #101 Path: D:\a\1\s\MimeKit\Multipart.cs, Line: 561, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #102 Path: D:\a\1\s\MimeKit\MultipartRelated.cs, Line: 97, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #103 Path: D:\a\1\s\MimeKit\ParserOptions.cs, Line: 309, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #104 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 530, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #105 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 561, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #106 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 595, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #107 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 625, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 721, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #109 Path: D:\a\1\s\MimeKit\Text\HtmlWriter.cs, Line: 751, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #110 Path: D:\a\1\s\MimeKit\Tnef\TnefPropertyReader.cs, Line: 1564, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #111 Path: D:\a\1\s\MimeKit\Tnef\TnefPropertyTag.cs, Line: 5724, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #112 Path: D:\a\1\s\MimeKit\Utils\CharsetUtils.cs, Line: 335, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: D:\a\1\s\MimeKit\Utils\CharsetUtils.cs, Line: 348, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #114 Path: D:\a\1\s\MimeKit\Utils\CharsetUtils.cs, Line: 353, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Mono.Data.Sqlite
    #115 Path: D:\a\1\s\Mono.Data.Sqlite\SQLite3.cs, Line: 306, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #116 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteCommand.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #117 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnection.cs, Line: 475, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #118 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnectionPool.cs, Line: 103, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #119 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnectionPool.cs, Line: 138, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #120 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnectionPool.cs, Line: 185, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #121 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnectionPool.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #122 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteConnectionStringBuilder.cs, Line: 489, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #123 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteDataAdapter.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteDataAdapter.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteFunction.cs, Line: 240, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #126 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteFunction.cs, Line: 352, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #127 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteKeyReader.cs, Line: 293, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #128 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteKeyReader.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #129 Path: D:\a\1\s\Mono.Data.Sqlite\SQLiteStatement.cs, Line: 128, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: UnitTests
    #130 Path: D:\a\1\s\UnitTests\Cryptography\DkimPublicKeyLocator.cs, Line: 59, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #131 Path: D:\a\1\s\UnitTests\Cryptography\SecureMimeDigitalCertificateTests.cs, Line: 64, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #132 Path: D:\a\1\s\UnitTests\Cryptography\SecureMimeTests.cs, Line: 25, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #133 Path: D:\a\1\s\UnitTests\Cryptography\SecureMimeTests.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #134 Path: D:\a\1\s\UnitTests\Cryptography\SecureMimeTests.cs, Line: 84, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #135 Path: D:\a\1\s\UnitTests\HeaderTests.cs, Line: 168, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #136 Path: D:\a\1\s\UnitTests\HtmlPreviewVisitor.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #137 Path: D:\a\1\s\UnitTests\MimeParserTests.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #138 Path: D:\a\1\s\UnitTests\MimeParserTests.cs, Line: 534, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #139 Path: D:\a\1\s\UnitTests\MimePartTests.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #140 Path: D:\a\1\s\UnitTests\MultipartRelatedTests.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R9: 75
R8: 36
R5: 18
R7: 6
R2: 5

--- Summary ---
Fixed ReSharper issues: 135
Fixed SonarQube issues: 18
Total fixed issues: 140

Finished in: 27 s

######################################################################
Nr: 1 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\MimeKit\AsyncMimeParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Threading.Tasks;

using MimeKit.IO;
using MimeKit.Utils;

namespace MimeKit {
	public partial class MimeParser
	{
		async Task<int> ReadAheadAsync (int atleast, int save, CancellationToken cancellationToken)
		{
			int left, start, end;

			if (!AlignReadAheadBuffer (atleast, save, out left, out start, out end))
				return left;

			int nread = await stream.ReadAsync (input, start, end - start, cancellationToken).ConfigureAwait (false);

			if (nread > 0) {
				inputEnd += nread;
				position += nread;
			} else {
				eos = true;
			}

			return inputEnd - inputIndex;
		}

		async Task<bool> StepByteOrderMarkAsync (CancellationToken cancellationToken)
		{
			int bomIndex = 0;

			do {
				var available = await ReadAheadAsync (ReadAheadSize, 0, cancellationToken).ConfigureAwait (false);

				if (available <= 0) {
					// failed to read any data... EOF
					inputIndex = inputEnd;
					return false;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						StepByteOrderMark (inbuf, ref bomIndex);
					}
				}
			} while (inputIndex == inputEnd);

			return bomIndex == 0 || bomIndex == UTF8ByteOrderMark.Length;
		}

		async Task StepMboxMarkerAsync (CancellationToken cancellationToken)
		{
			bool complete;
			int left = 0;

			mboxMarkerLength = 0;

			do {
				var available = await ReadAheadAsync (Math.Max (ReadAheadSize, left), 0, cancellationToken).ConfigureAwait (false);

				if (available <= left) {
					// failed to find a From line; EOF reached
					state = MimeParserState.Error;
					inputIndex = inputEnd;
					return;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						complete = StepMboxMarker (inbuf, ref left);
					}
				}
			} while (!complete);

			state = MimeParserState.MessageHeaders;
		}

		async Task StepHeadersAsync (CancellationToken cancellationToken)
		{
			bool scanningFieldName = true;
			bool checkFolded = false;
			bool midline = false;
			bool blank = false;
			bool valid = true;
			int left = 0;

			headerBlockBegin = GetOffset (inputIndex);
			boundary = BoundaryType.None;
			ResetRawHeaderData ();
			headers.Clear ();

			await ReadAheadAsync (Math.Max (ReadAheadSize, left), 0, cancellationToken).ConfigureAwait (false);

			do {
				unsafe {
					fixed (byte *inbuf = input) {
						if (!StepHeaders (inbuf, ref scanningFieldName, ref checkFolded, ref midline, ref blank, ref valid, ref left))
							break;
					}
				}

				var available = await ReadAheadAsync (left + 1, 0, cancellationToken).ConfigureAwait (false);

				if (available == left) {
					// EOF reached before we reached the end of the headers...
					if (scanningFieldName && left > 0) {
						// EOF reached right in the middle of a header field name. Throw an error.
						//
						// See private email from Feb 8, 2018 which contained a sample message w/o
						// any breaks between the header and message body. The file also did not
						// end with a newline sequence.
						state = MimeParserState.Error;
					} else {
						// EOF reached somewhere in the middle of the value.
						//
						// Append whatever data we've got left and pretend we found the end
						// of the header value (and the header block).
						//
						// For more details, see https://github.com/jstedfast/MimeKit/pull/51
						// and https://github.com/jstedfast/MimeKit/issues/348
						if (left > 0) {
							AppendRawHeaderData (inputIndex, left);
							inputIndex = inputEnd;
						}

						ParseAndAppendHeader ();

						state = MimeParserState.Content;
					}
					break;
				}
			} while (true);

			headerBlockEnd = GetOffset (inputIndex);
		}

		async Task<bool> SkipLineAsync (bool consumeNewLine, CancellationToken cancellationToken)
		{
			do {
				unsafe {
					fixed (byte* inbuf = input) {
						if (SkipLine (inbuf, consumeNewLine))
							return true;
					}
				}

				if (await ReadAheadAsync (ReadAheadSize, 1, cancellationToken).ConfigureAwait (false) <= 0)
					return false;
			} while (true);
		}

		async Task<MimeParserState> StepAsync (CancellationToken cancellationToken)
		{
			switch (state) {
			case MimeParserState.Initialized:
				if (!await StepByteOrderMarkAsync (cancellationToken).ConfigureAwait (false)) {
					state = MimeParserState.Eos;
					break;
				}

				state = format == MimeFormat.Mbox ? MimeParserState.MboxMarker : MimeParserState.MessageHeaders;
				break;
			case MimeParserState.MboxMarker:
				await StepMboxMarkerAsync (cancellationToken).ConfigureAwait (false);
				break;
			case MimeParserState.MessageHeaders:
			case MimeParserState.Headers:
				await StepHeadersAsync (cancellationToken).ConfigureAwait (false);
				toplevel = false;
				break;
			}

			return state;
		}

		async Task<ScanContentResult> ScanContentAsync (Stream content, bool trimNewLine, CancellationToken cancellationToken)
		{
			int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());
			int contentIndex = inputIndex;
			var formats = new bool[2];
			bool midline = false;
			int nleft;

			do {
				if (contentIndex < inputIndex)
					content.Write (input, contentIndex, inputIndex - contentIndex);

				nleft = inputEnd - inputIndex;
				if (await ReadAheadAsync (atleast, 2, cancellationToken).ConfigureAwait (false) <= 0) {
					boundary = BoundaryType.Eos;
					contentIndex = inputIndex;
					break;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						ScanContent (inbuf, ref contentIndex, ref nleft, ref midline, ref formats);
					}
				}
			} while (boundary == BoundaryType.None);

			if (contentIndex < inputIndex)
				content.Write (input, contentIndex, inputIndex - contentIndex);

			var isEmpty = content.Length == 0;

			if (boundary != BoundaryType.Eos && trimNewLine) {
				// the last \r\n belongs to the boundary
				if (content.Length > 0) {
					if (input[inputIndex - 2] == (byte) '\r')
						content.SetLength (content.Length - 2);
					else
						content.SetLength (content.Length - 1);
				}
			}

			return new ScanContentResult (formats, isEmpty);
		}

		async Task ConstructMimePartAsync (MimePart part, MimeEntityEndEventArgs args, CancellationToken cancellationToken)
		{
			long endOffset, beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			ScanContentResult result;
			Stream content;

			if (persistent) {
				using (var measured = new MeasuringStream ()) {
					result = await ScanContentAsync (measured, true, cancellationToken).ConfigureAwait (false);
					endOffset = beginOffset + measured.Length;
				}

				content = new BoundStream (stream, beginOffset, endOffset, true);
			} else {
				content = new MemoryBlockStream ();

				try {
					result = await ScanContentAsync (content, true, cancellationToken).ConfigureAwait (false);
					content.Seek (0, SeekOrigin.Begin);
				} catch {
					content.Dispose ();
					throw;
				}

				endOffset = beginOffset + content.Length;
			}

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			if (!result.IsEmpty)
				part.Content = new MimeContent (content, part.ContentTransferEncoding) { NewLineFormat = result.Format };
			else
				content.Dispose ();
		}

		async Task ConstructMessagePartAsync (MessagePart rfc822, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;

			if (bounds.Count > 0) {
				int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());

				if (await ReadAheadAsync (atleast, 0, cancellationToken).ConfigureAwait (false) <= 0) {
					boundary = BoundaryType.Eos;
					return;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						byte* start = inbuf + inputIndex;
						byte* inend = inbuf + inputEnd;
						byte* inptr = start;

						*inend = (byte) '\n';

						while (*inptr != (byte) '\n')
							inptr++;

						boundary = CheckBoundary (inputIndex, start, (int) (inptr - start));

						switch (boundary) {
						case BoundaryType.ImmediateEndBoundary:
						case BoundaryType.ImmediateBoundary:
						case BoundaryType.ParentBoundary:
							return;
						case BoundaryType.ParentEndBoundary:
							// ignore "From " boundaries, broken mailers tend to include these...
							if (!IsMboxMarker (start)) {
								return;
							}
							break;
						}
					}
				}
			}

			// parse the headers...
			state = MimeParserState.MessageHeaders;
			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error) {
				// Note: this either means that StepHeaders() found the end of the stream
				// or an invalid header field name at the start of the message headers,
				// which likely means that this is not a valid MIME stream?
				boundary = BoundaryType.Eos;
				return;
			}

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message, rfc822) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (preHeaderBuffer.Length > 0) {
				message.MboxMarker = new byte[preHeaderLength];
				Buffer.BlockCopy (preHeaderBuffer, 0, message.MboxMarker, 0, preHeaderLength);
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, depth);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart)
				await ConstructMultipartAsync ((Multipart) entity, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart)
				await ConstructMessagePartAsync ((MessagePart) entity, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			rfc822.Message = message;

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
		}

		async Task MultipartScanPreambleAsync (Multipart multipart, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartPreambleBegin (multipart, offset);
				await ScanContentAsync (memory, false, cancellationToken).ConfigureAwait (false);
				multipart.RawPreamble = memory.ToArray ();
				//OnMultipartPreambleEnd (multipart, offset + memory.Length);
			}
		}

		async Task MultipartScanEpilogueAsync (Multipart multipart, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartEpilogueBegin (multipart, offset);
				var result = await ScanContentAsync (memory, true, cancellationToken).ConfigureAwait (false);
				multipart.RawEpilogue = result.IsEmpty ? null : memory.ToArray ();
				//OnMultipartEpilogueEnd (multipart, offset + memory.Length);
			}
		}

		async Task MultipartScanSubpartsAsync (Multipart multipart, int depth, CancellationToken cancellationToken)
		{
			//var beginOffset = GetOffset (inputIndex);

			do {
				//OnMultipartBoundaryBegin (multipart, beginOffset);

				// skip over the boundary marker
				if (!await SkipLineAsync (true, cancellationToken).ConfigureAwait (false)) {
					//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));
					boundary = BoundaryType.Eos;
					return;
				}

				//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));

				var beginLineNumber = lineNumber;

				// parse the headers
				state = MimeParserState.Headers;
				if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error) {
					boundary = BoundaryType.Eos;
					return;
				}

				if (state == MimeParserState.Boundary) {
					if (headers.Count == 0) {
						if (boundary == BoundaryType.ImmediateBoundary) {
							//beginOffset = GetOffset (inputIndex);
							continue;
						}
						return;
					}

					// This part has no content, but that will be handled in ConstructMultipartAsync()
					// or ConstructMimePartAsync().
				}

				//if (state == ParserState.Complete && headers.Count == 0)
				//	return BoundaryType.EndBoundary;

				var type = GetContentType (multipart.ContentType);
				var entity = options.CreateEntity (type, headers, false, depth);
				var entityArgs = new MimeEntityEndEventArgs (entity, multipart) {
					HeadersEndOffset = headerBlockEnd,
					BeginOffset = headerBlockBegin,
					LineNumber = beginLineNumber
				};

				OnMimeEntityBegin (entityArgs);

				if (entity is Multipart)
					await ConstructMultipartAsync ((Multipart) entity, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
				else if (entity is MessagePart)
					await ConstructMessagePartAsync ((MessagePart) entity, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
				else
					await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

				var endOffset = GetEndOffset (inputIndex);
				entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
				entityArgs.EndOffset = endOffset;

				OnMimeEntityEnd (entityArgs);

				//beginOffset = endOffset;
				multipart.Add (entity);
			} while (boundary == BoundaryType.ImmediateBoundary);
		}

		async Task ConstructMultipartAsync (Multipart multipart, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			var marker = multipart.Boundary;
			long endOffset;

			if (marker == null) {
#if DEBUG
				Debug.WriteLine ("Multipart without a boundary encountered!");
#endif

				// Note: this will scan all content into the preamble...
				await MultipartScanPreambleAsync (multipart, cancellationToken).ConfigureAwait (false);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			PushBoundary (marker);

			await MultipartScanPreambleAsync (multipart, cancellationToken).ConfigureAwait (false);
			if (boundary == BoundaryType.ImmediateBoundary)
				await MultipartScanSubpartsAsync (multipart, depth, cancellationToken).ConfigureAwait (false);

			if (boundary == BoundaryType.ImmediateEndBoundary) {
				//OnMultipartEndBoundaryBegin (multipart, GetEndOffset (inputIndex));

				// consume the end boundary and read the epilogue (if there is one)
				multipart.WriteEndBoundary = true;
				await SkipLineAsync (false, cancellationToken).ConfigureAwait (false);
				PopBoundary ();

				//OnMultipartEndBoundaryEnd (multipart, GetOffset (inputIndex));

				await MultipartScanEpilogueAsync (multipart, cancellationToken).ConfigureAwait (false);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			endOffset = GetEndOffset (inputIndex);
			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			multipart.WriteEndBoundary = false;

			// We either found the end of the stream or we found a parent's boundary
			PopBoundary ();

			unsafe {
				fixed (byte* inbuf = input) {
					if (boundary == BoundaryType.ParentEndBoundary && FoundImmediateBoundary (inbuf, true))
						boundary = BoundaryType.ImmediateEndBoundary;
					else if (boundary == BoundaryType.ParentBoundary && FoundImmediateBoundary (inbuf, false))
						boundary = BoundaryType.ImmediateBoundary;
				}
			}
		}

		/// <summary>
		/// Asynchronously parses a list of headers from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a list of headers from the stream.
		/// </remarks>
		/// <returns>The parsed list of headers.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the headers.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<HeaderList> ParseHeadersAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			state = MimeParserState.Headers;
			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse headers.");

			state = eos ? MimeParserState.Eos : MimeParserState.Complete;

			var parsed = new HeaderList (options);
			foreach (var header in headers)
				parsed.Add (header);

			return parsed;
		}

		/// <summary>
		/// Asynchronously parses an entity from the stream.
		/// </summary>
		/// <remarks>
		/// Parses an entity from the stream.
		/// </remarks>
		/// <returns>The parsed entity.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the entity.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<MimeEntity> ParseEntityAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			var beginLineNumber = lineNumber;

			state = MimeParserState.Headers;
			toplevel = true;

			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse entity headers.");

			var type = GetContentType (null);

			// Note: we pass 'false' as the 'toplevel' argument here because
			// we want the entity to consume all of the headers.
			var entity = options.CreateEntity (type, headers, false, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			if (entity is Multipart)
				await ConstructMultipartAsync ((Multipart) entity, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart)
				await ConstructMessagePartAsync ((MessagePart) entity, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			var endOffset = GetEndOffset (inputIndex);
			entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos)
				state = MimeParserState.Complete;
			else
				state = MimeParserState.Eos;

			OnMimeEntityEnd (entityArgs);

			return entity;
		}

		/// <summary>
		/// Asynchronously parses a message from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a message from the stream.
		/// </remarks>
		/// <returns>The parsed message.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the message.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<MimeMessage> ParseMessageAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			// scan the from-line if we are parsing an mbox
			while (state != MimeParserState.MessageHeaders) {
				switch (await StepAsync (cancellationToken).ConfigureAwait (false)) {
				case MimeParserState.Error:
					throw new FormatException ("Failed to find mbox From marker.");
				case MimeParserState.Eos:
					throw new FormatException ("End of stream.");
				}
			}

			toplevel = true;

			// parse the headers
			var beginLineNumber = lineNumber;
			if (state < MimeParserState.Content && await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse message headers.");

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (format == MimeFormat.Mbox && options.RespectContentLength) {
				contentEnd = 0;

				for (int i = 0; i < headers.Count; i++) {
					if (headers[i].Id != HeaderId.ContentLength)
						continue;

					var value = headers[i].RawValue;
					int index = 0;

					if (!ParseUtils.SkipWhiteSpace (value, ref index, value.Length))
						continue;

					if (!ParseUtils.TryParseInt32 (value, ref index, value.Length, out int length))
						continue;

					contentEnd = GetOffset (inputIndex) + length;
					break;
				}
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart)
				await ConstructMultipartAsync ((Multipart) entity, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart)
				await ConstructMessagePartAsync ((MessagePart) entity, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos) {
				if (format == MimeFormat.Mbox)
					state = MimeParserState.MboxMarker;
				else
					state = MimeParserState.Complete;
			} else {
				state = MimeParserState.Eos;
			}

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			return message;
		}
	}
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Threading;
using System.Diagnostics;
using System.Threading.Tasks;

using MimeKit.IO;
using MimeKit.Utils;

namespace MimeKit {
	public partial class MimeParser
	{
		async Task<int> ReadAheadAsync (int atleast, int save, CancellationToken cancellationToken)
		{
			int left, start, end;

			if (!AlignReadAheadBuffer (atleast, save, out left, out start, out end))
				return left;

			int nread = await stream.ReadAsync (input, start, end - start, cancellationToken).ConfigureAwait (false);

			if (nread > 0) {
				inputEnd += nread;
				position += nread;
			} else {
				eos = true;
			}

			return inputEnd - inputIndex;
		}

		async Task<bool> StepByteOrderMarkAsync (CancellationToken cancellationToken)
		{
			int bomIndex = 0;

			do {
				var available = await ReadAheadAsync (ReadAheadSize, 0, cancellationToken).ConfigureAwait (false);

				if (available <= 0) {
					// failed to read any data... EOF
					inputIndex = inputEnd;
					return false;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						StepByteOrderMark (inbuf, ref bomIndex);
					}
				}
			} while (inputIndex == inputEnd);

			return bomIndex == 0 || bomIndex == UTF8ByteOrderMark.Length;
		}

		async Task StepMboxMarkerAsync (CancellationToken cancellationToken)
		{
			bool complete;
			int left = 0;

			mboxMarkerLength = 0;

			do {
				var available = await ReadAheadAsync (Math.Max (ReadAheadSize, left), 0, cancellationToken).ConfigureAwait (false);

				if (available <= left) {
					// failed to find a From line; EOF reached
					state = MimeParserState.Error;
					inputIndex = inputEnd;
					return;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						complete = StepMboxMarker (inbuf, ref left);
					}
				}
			} while (!complete);

			state = MimeParserState.MessageHeaders;
		}

		async Task StepHeadersAsync (CancellationToken cancellationToken)
		{
			bool scanningFieldName = true;
			bool checkFolded = false;
			bool midline = false;
			bool blank = false;
			bool valid = true;
			int left = 0;

			headerBlockBegin = GetOffset (inputIndex);
			boundary = BoundaryType.None;
			ResetRawHeaderData ();
			headers.Clear ();

			await ReadAheadAsync (Math.Max (ReadAheadSize, left), 0, cancellationToken).ConfigureAwait (false);

			do {
				unsafe {
					fixed (byte *inbuf = input) {
						if (!StepHeaders (inbuf, ref scanningFieldName, ref checkFolded, ref midline, ref blank, ref valid, ref left))
							break;
					}
				}

				var available = await ReadAheadAsync (left + 1, 0, cancellationToken).ConfigureAwait (false);

				if (available == left) {
					// EOF reached before we reached the end of the headers...
					if (scanningFieldName && left > 0) {
						// EOF reached right in the middle of a header field name. Throw an error.
						//
						// See private email from Feb 8, 2018 which contained a sample message w/o
						// any breaks between the header and message body. The file also did not
						// end with a newline sequence.
						state = MimeParserState.Error;
					} else {
						// EOF reached somewhere in the middle of the value.
						//
						// Append whatever data we've got left and pretend we found the end
						// of the header value (and the header block).
						//
						// For more details, see https://github.com/jstedfast/MimeKit/pull/51
						// and https://github.com/jstedfast/MimeKit/issues/348
						if (left > 0) {
							AppendRawHeaderData (inputIndex, left);
							inputIndex = inputEnd;
						}

						ParseAndAppendHeader ();

						state = MimeParserState.Content;
					}
					break;
				}
			} while (true);

			headerBlockEnd = GetOffset (inputIndex);
		}

		async Task<bool> SkipLineAsync (bool consumeNewLine, CancellationToken cancellationToken)
		{
			do {
				unsafe {
					fixed (byte* inbuf = input) {
						if (SkipLine (inbuf, consumeNewLine))
							return true;
					}
				}

				if (await ReadAheadAsync (ReadAheadSize, 1, cancellationToken).ConfigureAwait (false) <= 0)
					return false;
			} while (true);
		}

		async Task<MimeParserState> StepAsync (CancellationToken cancellationToken)
		{
			switch (state) {
			case MimeParserState.Initialized:
				if (!await StepByteOrderMarkAsync (cancellationToken).ConfigureAwait (false)) {
					state = MimeParserState.Eos;
					break;
				}

				state = format == MimeFormat.Mbox ? MimeParserState.MboxMarker : MimeParserState.MessageHeaders;
				break;
			case MimeParserState.MboxMarker:
				await StepMboxMarkerAsync (cancellationToken).ConfigureAwait (false);
				break;
			case MimeParserState.MessageHeaders:
			case MimeParserState.Headers:
				await StepHeadersAsync (cancellationToken).ConfigureAwait (false);
				toplevel = false;
				break;
			}

			return state;
		}

		async Task<ScanContentResult> ScanContentAsync (Stream content, bool trimNewLine, CancellationToken cancellationToken)
		{
			int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());
			int contentIndex = inputIndex;
			var formats = new bool[2];
			bool midline = false;
			int nleft;

			do {
				if (contentIndex < inputIndex)
					content.Write (input, contentIndex, inputIndex - contentIndex);

				nleft = inputEnd - inputIndex;
				if (await ReadAheadAsync (atleast, 2, cancellationToken).ConfigureAwait (false) <= 0) {
					boundary = BoundaryType.Eos;
					contentIndex = inputIndex;
					break;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						ScanContent (inbuf, ref contentIndex, ref nleft, ref midline, ref formats);
					}
				}
			} while (boundary == BoundaryType.None);

			if (contentIndex < inputIndex)
				content.Write (input, contentIndex, inputIndex - contentIndex);

			var isEmpty = content.Length == 0;

			if (boundary != BoundaryType.Eos && trimNewLine) {
				// the last \r\n belongs to the boundary
				if (content.Length > 0) {
					if (input[inputIndex - 2] == (byte) '\r')
						content.SetLength (content.Length - 2);
					else
						content.SetLength (content.Length - 1);
				}
			}

			return new ScanContentResult (formats, isEmpty);
		}

		async Task ConstructMimePartAsync (MimePart part, MimeEntityEndEventArgs args, CancellationToken cancellationToken)
		{
			long endOffset, beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			ScanContentResult result;
			Stream content;

			if (persistent) {
				using (var measured = new MeasuringStream ()) {
					result = await ScanContentAsync (measured, true, cancellationToken).ConfigureAwait (false);
					endOffset = beginOffset + measured.Length;
				}

				content = new BoundStream (stream, beginOffset, endOffset, true);
			} else {
				content = new MemoryBlockStream ();

				try {
					result = await ScanContentAsync (content, true, cancellationToken).ConfigureAwait (false);
					content.Seek (0, SeekOrigin.Begin);
				} catch {
					content.Dispose ();
					throw;
				}

				endOffset = beginOffset + content.Length;
			}

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			if (!result.IsEmpty)
				part.Content = new MimeContent (content, part.ContentTransferEncoding) { NewLineFormat = result.Format };
			else
				content.Dispose ();
		}

		async Task ConstructMessagePartAsync (MessagePart rfc822, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;

			if (bounds.Count > 0) {
				int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());

				if (await ReadAheadAsync (atleast, 0, cancellationToken).ConfigureAwait (false) <= 0) {
					boundary = BoundaryType.Eos;
					return;
				}

				unsafe {
					fixed (byte* inbuf = input) {
						byte* start = inbuf + inputIndex;
						byte* inend = inbuf + inputEnd;
						byte* inptr = start;

						*inend = (byte) '\n';

						while (*inptr != (byte) '\n')
							inptr++;

						boundary = CheckBoundary (inputIndex, start, (int) (inptr - start));

						switch (boundary) {
						case BoundaryType.ImmediateEndBoundary:
						case BoundaryType.ImmediateBoundary:
						case BoundaryType.ParentBoundary:
							return;
						case BoundaryType.ParentEndBoundary:
							// ignore "From " boundaries, broken mailers tend to include these...
							if (!IsMboxMarker (start)) {
								return;
							}
							break;
						}
					}
				}
			}

			// parse the headers...
			state = MimeParserState.MessageHeaders;
			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error) {
				// Note: this either means that StepHeaders() found the end of the stream
				// or an invalid header field name at the start of the message headers,
				// which likely means that this is not a valid MIME stream?
				boundary = BoundaryType.Eos;
				return;
			}

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message, rfc822) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (preHeaderBuffer.Length > 0) {
				message.MboxMarker = new byte[preHeaderLength];
				Buffer.BlockCopy (preHeaderBuffer, 0, message.MboxMarker, 0, preHeaderLength);
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, depth);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart multipart)
				await ConstructMultipartAsync (multipart, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart messagePart)
				await ConstructMessagePartAsync (messagePart, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			rfc822.Message = message;

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
		}

		async Task MultipartScanPreambleAsync (Multipart multipart, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartPreambleBegin (multipart, offset);
				await ScanContentAsync (memory, false, cancellationToken).ConfigureAwait (false);
				multipart.RawPreamble = memory.ToArray ();
				//OnMultipartPreambleEnd (multipart, offset + memory.Length);
			}
		}

		async Task MultipartScanEpilogueAsync (Multipart multipart, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartEpilogueBegin (multipart, offset);
				var result = await ScanContentAsync (memory, true, cancellationToken).ConfigureAwait (false);
				multipart.RawEpilogue = result.IsEmpty ? null : memory.ToArray ();
				//OnMultipartEpilogueEnd (multipart, offset + memory.Length);
			}
		}

		async Task MultipartScanSubpartsAsync (Multipart multipart, int depth, CancellationToken cancellationToken)
		{
			//var beginOffset = GetOffset (inputIndex);

			do {
				//OnMultipartBoundaryBegin (multipart, beginOffset);

				// skip over the boundary marker
				if (!await SkipLineAsync (true, cancellationToken).ConfigureAwait (false)) {
					//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));
					boundary = BoundaryType.Eos;
					return;
				}

				//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));

				var beginLineNumber = lineNumber;

				// parse the headers
				state = MimeParserState.Headers;
				if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error) {
					boundary = BoundaryType.Eos;
					return;
				}

				if (state == MimeParserState.Boundary) {
					if (headers.Count == 0) {
						if (boundary == BoundaryType.ImmediateBoundary) {
							//beginOffset = GetOffset (inputIndex);
							continue;
						}
						return;
					}

					// This part has no content, but that will be handled in ConstructMultipartAsync()
					// or ConstructMimePartAsync().
				}

				//if (state == ParserState.Complete && headers.Count == 0)
				//	return BoundaryType.EndBoundary;

				var type = GetContentType (multipart.ContentType);
				var entity = options.CreateEntity (type, headers, false, depth);
				var entityArgs = new MimeEntityEndEventArgs (entity, multipart) {
					HeadersEndOffset = headerBlockEnd,
					BeginOffset = headerBlockBegin,
					LineNumber = beginLineNumber
				};

				OnMimeEntityBegin (entityArgs);

				if (entity is Multipart multipart)
					await ConstructMultipartAsync (multipart, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
				else if (entity is MessagePart messagePart)
					await ConstructMessagePartAsync (messagePart, entityArgs, depth + 1, cancellationToken).ConfigureAwait (false);
				else
					await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

				var endOffset = GetEndOffset (inputIndex);
				entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
				entityArgs.EndOffset = endOffset;

				OnMimeEntityEnd (entityArgs);

				//beginOffset = endOffset;
				multipart.Add (entity);
			} while (boundary == BoundaryType.ImmediateBoundary);
		}

		async Task ConstructMultipartAsync (Multipart multipart, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			var marker = multipart.Boundary;
			long endOffset;

			if (marker == null) {
#if DEBUG
				Debug.WriteLine ("Multipart without a boundary encountered!");
#endif

				// Note: this will scan all content into the preamble...
				await MultipartScanPreambleAsync (multipart, cancellationToken).ConfigureAwait (false);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			PushBoundary (marker);

			await MultipartScanPreambleAsync (multipart, cancellationToken).ConfigureAwait (false);
			if (boundary == BoundaryType.ImmediateBoundary)
				await MultipartScanSubpartsAsync (multipart, depth, cancellationToken).ConfigureAwait (false);

			if (boundary == BoundaryType.ImmediateEndBoundary) {
				//OnMultipartEndBoundaryBegin (multipart, GetEndOffset (inputIndex));

				// consume the end boundary and read the epilogue (if there is one)
				multipart.WriteEndBoundary = true;
				await SkipLineAsync (false, cancellationToken).ConfigureAwait (false);
				PopBoundary ();

				//OnMultipartEndBoundaryEnd (multipart, GetOffset (inputIndex));

				await MultipartScanEpilogueAsync (multipart, cancellationToken).ConfigureAwait (false);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			endOffset = GetEndOffset (inputIndex);
			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			multipart.WriteEndBoundary = false;

			// We either found the end of the stream or we found a parent's boundary
			PopBoundary ();

			unsafe {
				fixed (byte* inbuf = input) {
					if (boundary == BoundaryType.ParentEndBoundary && FoundImmediateBoundary (inbuf, true))
						boundary = BoundaryType.ImmediateEndBoundary;
					else if (boundary == BoundaryType.ParentBoundary && FoundImmediateBoundary (inbuf, false))
						boundary = BoundaryType.ImmediateBoundary;
				}
			}
		}

		/// <summary>
		/// Asynchronously parses a list of headers from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a list of headers from the stream.
		/// </remarks>
		/// <returns>The parsed list of headers.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the headers.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<HeaderList> ParseHeadersAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			state = MimeParserState.Headers;
			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse headers.");

			state = eos ? MimeParserState.Eos : MimeParserState.Complete;

			var parsed = new HeaderList (options);
			foreach (var header in headers)
				parsed.Add (header);

			return parsed;
		}

		/// <summary>
		/// Asynchronously parses an entity from the stream.
		/// </summary>
		/// <remarks>
		/// Parses an entity from the stream.
		/// </remarks>
		/// <returns>The parsed entity.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the entity.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<MimeEntity> ParseEntityAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			var beginLineNumber = lineNumber;

			state = MimeParserState.Headers;
			toplevel = true;

			if (await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse entity headers.");

			var type = GetContentType (null);

			// Note: we pass 'false' as the 'toplevel' argument here because
			// we want the entity to consume all of the headers.
			var entity = options.CreateEntity (type, headers, false, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			if (entity is Multipart multipart)
				await ConstructMultipartAsync (multipart, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart messagePart)
				await ConstructMessagePartAsync (messagePart, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			var endOffset = GetEndOffset (inputIndex);
			entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos)
				state = MimeParserState.Complete;
			else
				state = MimeParserState.Eos;

			OnMimeEntityEnd (entityArgs);

			return entity;
		}

		/// <summary>
		/// Asynchronously parses a message from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a message from the stream.
		/// </remarks>
		/// <returns>The parsed message.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the message.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public async Task<MimeMessage> ParseMessageAsync (CancellationToken cancellationToken = default (CancellationToken))
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			// scan the from-line if we are parsing an mbox
			while (state != MimeParserState.MessageHeaders) {
				switch (await StepAsync (cancellationToken).ConfigureAwait (false)) {
				case MimeParserState.Error:
					throw new FormatException ("Failed to find mbox From marker.");
				case MimeParserState.Eos:
					throw new FormatException ("End of stream.");
				}
			}

			toplevel = true;

			// parse the headers
			var beginLineNumber = lineNumber;
			if (state < MimeParserState.Content && await StepAsync (cancellationToken).ConfigureAwait (false) == MimeParserState.Error)
				throw new FormatException ("Failed to parse message headers.");

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (format == MimeFormat.Mbox && options.RespectContentLength) {
				contentEnd = 0;

				for (int i = 0; i < headers.Count; i++) {
					if (headers[i].Id != HeaderId.ContentLength)
						continue;

					var value = headers[i].RawValue;
					int index = 0;

					if (!ParseUtils.SkipWhiteSpace (value, ref index, value.Length))
						continue;

					if (!ParseUtils.TryParseInt32 (value, ref index, value.Length, out int length))
						continue;

					contentEnd = GetOffset (inputIndex) + length;
					break;
				}
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart multipart)
				await ConstructMultipartAsync (multipart, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else if (entity is MessagePart messagePart)
				await ConstructMessagePartAsync (messagePart, entityArgs, 0, cancellationToken).ConfigureAwait (false);
			else
				await ConstructMimePartAsync ((MimePart) entity, entityArgs, cancellationToken).ConfigureAwait (false);

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos) {
				if (format == MimeFormat.Mbox)
					state = MimeParserState.MboxMarker;
				else
					state = MimeParserState.Complete;
			} else {
				state = MimeParserState.Eos;
			}

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			return message;
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\AsyncMimeParser.cs(448,32): error CS0841: Cannot use local variable 'multipart' before it is declared,D:\a\1\s\MimeKit\AsyncMimeParser.cs(450,58): error CS0841: Cannot use local variable 'multipart' before it is declared,D:\a\1\s\MimeKit\AsyncMimeParser.cs(458,29): error CS0136: A local or parameter named 'multipart' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MimeKit\InternetAddress.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Text;
using System.Globalization;
using System.Collections.Generic;

using MimeKit.Utils;

namespace MimeKit {
	/// <summary>
	/// An abstract internet address, as specified by rfc0822.
	/// </summary>
	/// <remarks>
	/// <para>A <see cref="InternetAddress"/> can be any type of address defined by the
	/// original Internet Message specification.</para>
	/// <para>There are effectively two (2) types of addresses: mailboxes and groups.</para>
	/// <para>Mailbox addresses are what are most commonly known as email addresses and are
	/// represented by the <see cref="MailboxAddress"/> class.</para>
	/// <para>Group addresses are themselves lists of addresses and are represented by the
	/// <see cref="GroupAddress"/> class. While rare, it is still important to handle these
	/// types of addresses. They typically only contain mailbox addresses, but may also
	/// contain other group addresses.</para>
	/// </remarks>
	public abstract class InternetAddress : IComparable<InternetAddress>, IEquatable<InternetAddress>
	{
		const string AtomSpecials = "()<>@,;:\\\".[]";
		Encoding encoding;
		string name;

		/// <summary>
		/// Initialize a new instance of the <see cref="InternetAddress"/> class.
		/// </summary>
		/// <remarks>
		/// Initializes the <see cref="Encoding"/> and <see cref="Name"/> properties of the internet address.
		/// </remarks>
		/// <param name="encoding">The character encoding to be used for encoding the name.</param>
		/// <param name="name">The name of the mailbox or group.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="encoding"/> is <c>null</c>.
		/// </exception>
		protected InternetAddress (Encoding encoding, string name)
		{
			if (encoding == null)
				throw new ArgumentNullException (nameof (encoding));

			Encoding = encoding;
			Name = name;
		}

		/// <summary>
		/// Get or set the character encoding to use when encoding the name of the address.
		/// </summary>
		/// <remarks>
		/// The character encoding is used to convert the <see cref="Name"/> property, if it is set,
		/// to a stream of bytes when encoding the internet address for transport.
		/// </remarks>
		/// <value>The character encoding.</value>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		public Encoding Encoding {
			get { return encoding; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				if (value == encoding)
					return;

				encoding = value;
				OnChanged ();
			}
		}

		/// <summary>
		/// Get or set the display name of the address.
		/// </summary>
		/// <remarks>
		/// A name is optional and is typically set to the name of the person
		/// or group that own the internet address.
		/// </remarks>
		/// <value>The name of the address.</value>
		public string Name {
			get { return name; }
			set {
				if (value == name)
					return;

				name = value;
				OnChanged ();
			}
		}

		/// <summary>
		/// Clone the address.
		/// </summary>
		/// <remarks>
		/// Clones the address.
		/// </remarks>
		/// <returns>The cloned address.</returns>
		public abstract InternetAddress Clone ();

		#region IComparable implementation

		/// <summary>
		/// Compares two internet addresses.
		/// </summary>
		/// <remarks>
		/// Compares two internet addresses for the purpose of sorting.
		/// </remarks>
		/// <returns>The sort order of the current internet address compared to the other internet address.</returns>
		/// <param name="other">The internet address to compare to.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="other"/> is <c>null</c>.
		/// </exception>
		public int CompareTo (InternetAddress other)
		{
			int rv;

			if (other == null)
				throw new ArgumentNullException (nameof (other));

			if ((rv = string.Compare (Name, other.Name, StringComparison.OrdinalIgnoreCase)) != 0)
				return rv;

			var otherMailbox = other as MailboxAddress;
			var mailbox = this as MailboxAddress;

			if (mailbox != null && otherMailbox != null) {
				string otherAddress = otherMailbox.Address;
				int otherAt = otherAddress.IndexOf ('@');
				string address = mailbox.Address;
				int at = address.IndexOf ('@');

				if (at != -1 && otherAt != -1) {
					int length = Math.Min (address.Length - (at + 1), otherAddress.Length - (otherAt + 1));

					rv = string.Compare (address, at + 1, otherAddress, otherAt + 1, length, StringComparison.OrdinalIgnoreCase);
				}

				if (rv == 0) {
					string otherUser = otherAt != -1 ? otherAddress.Substring (0, otherAt) : otherAddress;
					string user = at != -1 ? address.Substring (0, at) : address;

					rv = string.Compare (user, otherUser, StringComparison.OrdinalIgnoreCase);
				}

				return rv;
			}

			// sort mailbox addresses before group addresses
			if (mailbox != null && otherMailbox == null)
				return -1;

			if (mailbox == null && otherMailbox != null)
				return 1;

			return 0;
		}

		#endregion

		#region IEquatable implementation

		/// <summary>
		/// Determines whether the specified <see cref="InternetAddress"/> is equal to the current <see cref="InternetAddress"/>.
		/// </summary>
		/// <remarks>
		/// Compares two internet addresses to determine if they are identical or not.
		/// </remarks>
		/// <param name="other">The <see cref="InternetAddress"/> to compare with the current <see cref="InternetAddress"/>.</param>
		/// <returns><c>true</c> if the specified <see cref="InternetAddress"/> is equal to the current
		/// <see cref="InternetAddress"/>; otherwise, <c>false</c>.</returns>
		public abstract bool Equals (InternetAddress other);

		#endregion

		/// <summary>
		/// Determine whether the specified object is equal to the current object.
		/// </summary>
		/// <remarks>
		/// The type of comparison between the current instance and the <paramref name="obj"/> parameter depends on whether
		/// the current instance is a reference type or a value type.
		/// </remarks>
		/// <param name="obj">The object to compare with the current object.</param>
		/// <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c>.</returns>
		public override bool Equals (object obj)
		{
			return Equals (obj as InternetAddress);
		}

		/// <summary>
		/// Return the hash code for this instance.
		/// </summary>
		/// <remarks>
		/// Returns the hash code for this instance.
		/// </remarks>
		/// <returns>A hash code for the current object.</returns>
		public override int GetHashCode ()
		{
			return ToString ().GetHashCode ();
		}

		internal static string EncodeInternationalizedPhrase (string phrase)
		{
			for (int i = 0; i < phrase.Length; i++) {
				if (AtomSpecials.IndexOf (phrase[i]) != -1)
					return MimeUtils.Quote (phrase);
			}

			return phrase;
		}

		internal abstract void Encode (FormatOptions options, StringBuilder builder, bool firstToken, ref int lineLength);

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string, optionally encoding it for transport.
		/// </summary>
		/// <remarks>
		/// <para>If the <paramref name="encode"/> parameter is <c>true</c>, then this method will return
		/// an encoded version of the internet address according to the rules described in rfc2047.</para>
		/// <para>However, if the <paramref name="encode"/> parameter is <c>false</c>, then this method will
		/// return a string suitable only for display purposes.</para>
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The formatting options.</param>
		/// <param name="encode">If set to <c>true</c>, the <see cref="InternetAddress"/> will be encoded.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="options"/> is <c>null</c>.
		/// </exception>
		public abstract string ToString (FormatOptions options, bool encode);

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string, optionally encoding it for transport.
		/// </summary>
		/// <remarks>
		/// <para>If the <paramref name="encode"/> parameter is <c>true</c>, then this method will return
		/// an encoded version of the internet address according to the rules described in rfc2047.</para>
		/// <para>However, if the <paramref name="encode"/> parameter is <c>false</c>, then this method will
		/// return a string suitable only for display purposes.</para>
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		/// <param name="encode">If set to <c>true</c>, the <see cref="InternetAddress"/> will be encoded.</param>
		public string ToString (bool encode)
		{
			return ToString (FormatOptions.Default, encode);
		}

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string suitable for display.
		/// </summary>
		/// <remarks>
		/// The string returned by this method is suitable only for display purposes.
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		public override string ToString ()
		{
			return ToString (FormatOptions.Default, false);
		}

		internal event EventHandler Changed;

		/// <summary>
		/// Raise the internal changed event used by <see cref="MimeMessage"/> to keep headers in sync.
		/// </summary>
		/// <remarks>
		/// This method is called whenever a property of the internet address is changed.
		/// </remarks>
		protected virtual void OnChanged ()
		{
			if (Changed != null)
				Changed (this, EventArgs.Empty);
		}

		internal static bool TryParseLocalPart (byte[] text, ref int index, int endIndex, bool skipTrailingCfws, bool throwOnError, out string localpart)
		{
			var token = new StringBuilder ();
			int startIndex = index;

			localpart = null;

			do {
				if (!text[index].IsAtom () && text[index] != '"') {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid local-part at offset {0}", startIndex), startIndex, index);

					return false;
				}

				int start = index;
				if (!ParseUtils.SkipWord (text, ref index, endIndex, throwOnError))
					return false;

				try {
					token.Append (CharsetUtils.UTF8.GetString (text, start, index - start));
				} catch (DecoderFallbackException) {
					try {
						token.Append (CharsetUtils.Latin1.GetString (text, start, index - start));
					} catch (DecoderFallbackException ex) {
						if (throwOnError)
							throw new ParseException ("Internationalized local-part tokens may only contain UTF-8 characters.", start, start, ex);

						return false;
					}
				}

				int cfws = index;
				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex || text[index] != (byte) '.') {
					if (!skipTrailingCfws)
						index = cfws;
					break;
				}

				token.Append ('.');
				index++;

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete local-part at offset {0}", startIndex), startIndex, index);

					return false;
				}
			} while (true);

			localpart = token.ToString ();

			if (ParseUtils.IsIdnEncoded (localpart))
				localpart = ParseUtils.IdnDecode (localpart);

			return true;
		}

		static readonly byte[] CommaGreaterThanOrSemiColon = { (byte) ',', (byte) '>', (byte) ';' };

		internal static bool TryParseAddrspec (byte[] text, ref int index, int endIndex, byte[] sentinels, bool throwOnError, out string addrspec, out int at)
		{
			int startIndex = index;
			string localpart;

			addrspec = null;
			at = -1;

			if (!TryParseLocalPart (text, ref index, endIndex, true, throwOnError, out localpart))
				return false;

			if (index >= endIndex || ParseUtils.IsSentinel (text[index], sentinels)) {
				addrspec = localpart;
				return true;
			}

			if (text[index] != (byte) '@') {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			index++;
			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			string domain;
			if (!ParseUtils.TryParseDomain (text, ref index, endIndex, sentinels, throwOnError, out domain))
				return false;

			if (ParseUtils.IsIdnEncoded (domain))
				domain = ParseUtils.IdnDecode (domain);

			addrspec = localpart + "@" + domain;
			at = localpart.Length;

			return true;
		}

		internal static bool TryParseMailbox (ParserOptions options, byte[] text, int startIndex, ref int index, int endIndex, string name, int codepage, bool throwOnError, out InternetAddress address)
		{
			DomainList route = null;
			Encoding encoding;

			try {
				encoding = Encoding.GetEncoding (codepage);
			} catch {
				encoding = Encoding.UTF8;
			}

			address = null;

			// skip over the '<'
			index++;

			// Note: check for excessive angle brackets like the example described in section 7.1.2 of rfc7103...
			if (index < endIndex && text[index] == (byte) '<') {
				if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Excessive angle brackets at offset {0}", index), startIndex, index);

					return false;
				}

				do {
					index++;
				} while (index < endIndex && text[index] == '<');
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete mailbox at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (text[index] == (byte) '@') {
				// Note: we always pass 'false' as the throwOnError argument here so that we can throw a more informative exception on error
				if (!DomainList.TryParse (text, ref index, endIndex, false, out route)) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid route in mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (index >= endIndex || text[index] != (byte) ':') {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete route in mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}

				// skip over ':'
				index++;

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}
			}

			// Note: The only syntactically correct sentinel token here is the '>', but alas... to deal with the first example
			// in section 7.1.5 of rfc7103, we need to at least handle ',' as a sentinel and might as well handle ';' as well
			// in case the mailbox is within a group address.
			//
			// Example: <third@example.net, fourth@example.net>
			string addrspec;
			int at;

			if (!TryParseAddrspec (text, ref index, endIndex, CommaGreaterThanOrSemiColon, throwOnError, out addrspec, out at))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex || text[index] != (byte) '>') {
				if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected end of mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}
			} else {
				// skip over the '>'
				index++;

				// Note: check for excessive angle brackets like the example described in section 7.1.2 of rfc7103...
				if (index < endIndex && text[index] == (byte) '>') {
					if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Excessive angle brackets at offset {0}", index), startIndex, index);

						return false;
					}

					do {
						index++;
					} while (index < endIndex && text[index] == '>');
				}
			}

			if (route != null)
				address = new MailboxAddress (encoding, name, route, addrspec, at);
			else
				address = new MailboxAddress (encoding, name, addrspec, at);

			return true;
		}

		static bool TryParseGroup (ParserOptions options, byte[] text, int startIndex, ref int index, int endIndex, int groupDepth, string name, int codepage, bool throwOnError, out InternetAddress address)
		{
			List<InternetAddress> members;
			Encoding encoding;

			try {
				encoding = Encoding.GetEncoding (codepage);
			} catch {
				encoding = Encoding.UTF8;
			}

			address = null;

			// skip over the ':'
			index++;

			while (index < endIndex && (text[index] == ':' || text[index].IsBlank ()))
				index++;

			if (InternetAddressList.TryParse (options, text, ref index, endIndex, true, groupDepth, throwOnError, out members))
				address = new GroupAddress (encoding, name, members);
			else
				address = new GroupAddress (encoding, name);

			if (index >= endIndex || text[index] != (byte) ';') {
				if (throwOnError && options.AddressParserComplianceMode == RfcComplianceMode.Strict)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Expected to find ';' at offset {0}", index), startIndex, index);

				while (index < endIndex && text[index] != (byte) ';')
					index++;
			} else {
				index++;
			}

			return true;
		}

		[Flags]
		internal enum AddressParserFlags {
			AllowMailboxAddress = 1 << 0,
			AllowGroupAddress   = 1 << 1,
			ThrowOnError        = 1 << 2,

			TryParse            = AllowMailboxAddress | AllowGroupAddress,
			Parse               = TryParse | ThrowOnError
		}

		internal static bool TryParse (ParserOptions options, byte[] text, ref int index, int endIndex, int groupDepth, AddressParserFlags flags, out InternetAddress address)
		{
			bool strict = options.AddressParserComplianceMode == RfcComplianceMode.Strict;
			bool throwOnError = (flags & AddressParserFlags.ThrowOnError) != 0;
			int minWordCount = options.AllowUnquotedCommasInAddresses ? 0 : 1;

			address = null;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index == endIndex) {
				if (throwOnError)
					throw new ParseException ("No address found.", index, index);

				return false;
			}

			// keep track of the start & length of the phrase
			bool trimLeadingQuote = false;
			int startIndex = index;
			int length = 0;
			int words = 0;

			while (index < endIndex) {
				if (strict) {
					if (!ParseUtils.SkipWord (text, ref index, endIndex, throwOnError))
						break;
				} else if (text[index] == (byte) '"') {
					int qstringIndex = index;

					if (!ParseUtils.SkipQuoted (text, ref index, endIndex, false)) {
						index = qstringIndex + 1;

						ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

						if (!ParseUtils.SkipPhraseAtom (text, ref index, endIndex)) {
							if (throwOnError)
								throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete quoted-string token at offset {0}", qstringIndex), qstringIndex, endIndex);

							break;
						}

						if (startIndex == qstringIndex)
							trimLeadingQuote = true;
					}
				} else {
					if (!ParseUtils.SkipPhraseAtom (text, ref index, endIndex))
						break;
				}

				length = index - startIndex;

				do {
					if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
						return false;

					// Note: some clients don't quote dots in the name
					if (index >= endIndex || text[index] != (byte) '.')
						break;

					index++;

					length = index - startIndex;
				} while (true);

				words++;

				// Note: some clients don't quote commas in the name
				if (index < endIndex && text[index] == ',' && words > minWordCount) {
					index++;

					length = index - startIndex;

					if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
						return false;
				}
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			// specials    =  "(" / ")" / "<" / ">" / "@"  ; Must be in quoted-
			//             /  "," / ";" / ":" / "\" / <">  ;  string, to use
			//             /  "." / "[" / "]"              ;  within a word.

			if (index >= endIndex || text[index] == (byte) ',' || text[index] == (byte) '>' || text[index] == ';') {
				// we've completely gobbled up an addr-spec w/o a domain
				byte sentinel = index < endIndex ? text[index] : (byte) ',';
				string name, addrspec;

				if ((flags & AddressParserFlags.AllowMailboxAddress) == 0) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Addr-spec token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (!options.AllowAddressesWithoutDomain) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				// rewind back to the beginning of the local-part
				index = startIndex;

				if (!TryParseLocalPart (text, ref index, endIndex, false, throwOnError, out addrspec))
					return false;

				ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

				if (index < endIndex && text[index] == '(') {
					int comment = index + 1;

					// Note: this can't fail because it has already been skipped in TryParseLocalPart() above.
					ParseUtils.SkipComment (text, ref index, endIndex);

					name = Rfc2047.DecodePhrase (options, text, comment, (index - 1) - comment).Trim ();

					ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError);
				} else {
					name = string.Empty;
				}

				if (index < endIndex && text[index] == (byte) '>') {
					if (strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '>' token at offset {0}", index), startIndex, index);

						return false;
					}

					index++;
				}

				if (index < endIndex && text[index] != sentinel) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), startIndex, index);

					return false;
				}

				address = new MailboxAddress (Encoding.UTF8, name, addrspec, -1);

				return true;
			}

			if (text[index] == (byte) ':') {
				// rfc2822 group address
				int nameIndex = startIndex;
				int codepage = -1;
				string name;

				if ((flags & AddressParserFlags.AllowGroupAddress) == 0) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Group address token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (groupDepth >= options.MaxAddressGroupDepth) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Exceeded maximum rfc822 group depth at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (trimLeadingQuote) {
					nameIndex++;
					length--;
				}

				if (length > 0) {
					name = Rfc2047.DecodePhrase (options, text, nameIndex, length, out codepage);
				} else {
					name = string.Empty;
				}

				if (codepage == -1)
					codepage = 65001;

				return TryParseGroup (options, text, startIndex, ref index, endIndex, groupDepth + 1, MimeUtils.Unquote (name), codepage, throwOnError, out address);
			}

			if ((flags & AddressParserFlags.AllowMailboxAddress) == 0) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Mailbox address token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (text[index] == (byte) '@') {
				// we're either in the middle of an addr-spec token or we completely gobbled up an addr-spec w/o a domain
				string name, addrspec;
				int at;

				// rewind back to the beginning of the local-part
				index = startIndex;

				if (!TryParseAddrspec (text, ref index, endIndex, CommaGreaterThanOrSemiColon, throwOnError, out addrspec, out at))
					return false;

				ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

				if (index < endIndex && text[index] == '(') {
					int comment = index;

					if (!ParseUtils.SkipComment (text, ref index, endIndex)) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete comment token at offset {0}", comment), comment, index);

						return false;
					}

					comment++;

					name = Rfc2047.DecodePhrase (options, text, comment, (index - 1) - comment).Trim ();
				} else {
					name = string.Empty;
				}

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					address = new MailboxAddress (Encoding.UTF8, name, addrspec, at);
					return true;
				}

				if (text[index] == (byte) '<') {
					// We have an address like "user@example.com <user@example.com>"; i.e. the name is an unquoted string with an '@'.
					if (strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '<' token at offset {0}", index), startIndex, index);

						return false;
					}

					int nameEndIndex = index;
					while (nameEndIndex > startIndex && text[nameEndIndex - 1].IsWhitespace ())
						nameEndIndex--;

					length = nameEndIndex - startIndex;

					// fall through to the rfc822 angle-addr token case...
				} else {
					// Note: since there was no '<', there should not be a '>'... but we handle it anyway in order to
					// deal with the second Unbalanced Angle Brackets example in section 7.1.3: second@example.org>
					if (text[index] == (byte) '>') {
						if (strict) {
							if (throwOnError)
								throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '>' token at offset {0}", index), startIndex, index);

							return false;
						}

						index++;
					}

					address = new MailboxAddress (Encoding.UTF8, name, addrspec, at);

					return true;
				}
			}

			if (text[index] == (byte) '<') {
				// rfc2822 angle-addr token
				int nameIndex = startIndex;
				int codepage = -1;
				string name;

				if (trimLeadingQuote) {
					nameIndex++;
					length--;
				}

				if (length > 0) {
					name = Rfc2047.DecodePhrase (options, text, nameIndex, length, out codepage);
				} else {
					name = string.Empty;
				}

				if (codepage == -1)
					codepage = 65001;

				return TryParseMailbox (options, text, startIndex, ref index, endIndex, MimeUtils.Unquote (name), codepage, throwOnError, out address);
			}

			if (throwOnError)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid address token at offset {0}", startIndex), startIndex, index);

			return false;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, int startIndex, int length, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex, length);

			int endIndex = startIndex + length;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false)) {
				address = null;
				return false;
			}

			if (index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		public static bool TryParse (byte[] buffer, int startIndex, int length, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, startIndex, length, out address);
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, int startIndex, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex);

			int endIndex = buffer.Length;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		public static bool TryParse (byte[] buffer, int startIndex, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, startIndex, out address);
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer);

			int endIndex = buffer.Length;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (byte[] buffer, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, out address);
		}

		/// <summary>
		/// Try to parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="text">The text.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (ParserOptions options, string text, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, text);

			var buffer = Encoding.UTF8.GetBytes (text);
			int endIndex = buffer.Length;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="text">The text.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (string text, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, text, out address);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer, int startIndex, int length)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex, length);

			int endIndex = startIndex + length;
			InternetAddress address;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", startIndex, startIndex);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer, int startIndex, int length)
		{
			return Parse (ParserOptions.Default, buffer, startIndex, length);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/>is out of range.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer, int startIndex)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex);

			int endIndex = buffer.Length;
			InternetAddress address;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", startIndex, startIndex);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer, int startIndex)
		{
			return Parse (ParserOptions.Default, buffer, startIndex);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer)
		{
			ParseUtils.ValidateArguments (options, buffer);

			int endIndex = buffer.Length;
			InternetAddress address;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", 0, 0);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer)
		{
			return Parse (ParserOptions.Default, buffer);
		}

		/// <summary>
		/// Parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="text">The text.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="text"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="text"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, string text)
		{
			ParseUtils.ValidateArguments (options, text);

			var buffer = Encoding.UTF8.GetBytes (text);
			int endIndex = buffer.Length;
			InternetAddress address;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", 0, 0);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="text">The text.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="text"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (string text)
		{
			return Parse (ParserOptions.Default, text);
		}
	}
}

---- Transformed Tree ----
using System;
using System.Text;
using System.Globalization;
using System.Collections.Generic;

using MimeKit.Utils;

namespace MimeKit {
	/// <summary>
	/// An abstract internet address, as specified by rfc0822.
	/// </summary>
	/// <remarks>
	/// <para>A <see cref="InternetAddress"/> can be any type of address defined by the
	/// original Internet Message specification.</para>
	/// <para>There are effectively two (2) types of addresses: mailboxes and groups.</para>
	/// <para>Mailbox addresses are what are most commonly known as email addresses and are
	/// represented by the <see cref="MailboxAddress"/> class.</para>
	/// <para>Group addresses are themselves lists of addresses and are represented by the
	/// <see cref="GroupAddress"/> class. While rare, it is still important to handle these
	/// types of addresses. They typically only contain mailbox addresses, but may also
	/// contain other group addresses.</para>
	/// </remarks>
	public abstract class InternetAddress : IComparable<InternetAddress>, IEquatable<InternetAddress>
	{
		const string AtomSpecials = "()<>@,;:\\\".[]";
		Encoding encoding;
		string name;

		/// <summary>
		/// Initialize a new instance of the <see cref="InternetAddress"/> class.
		/// </summary>
		/// <remarks>
		/// Initializes the <see cref="Encoding"/> and <see cref="Name"/> properties of the internet address.
		/// </remarks>
		/// <param name="encoding">The character encoding to be used for encoding the name.</param>
		/// <param name="name">The name of the mailbox or group.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="encoding"/> is <c>null</c>.
		/// </exception>
		protected InternetAddress (Encoding encoding, string name)
		{
			if (encoding == null)
				throw new ArgumentNullException (nameof (encoding));

			Encoding = encoding;
			Name = name;
		}

		/// <summary>
		/// Get or set the character encoding to use when encoding the name of the address.
		/// </summary>
		/// <remarks>
		/// The character encoding is used to convert the <see cref="Name"/> property, if it is set,
		/// to a stream of bytes when encoding the internet address for transport.
		/// </remarks>
		/// <value>The character encoding.</value>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		public Encoding Encoding {
			get { return encoding; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				if (value == encoding)
					return;

				encoding = value;
				OnChanged ();
			}
		}

		/// <summary>
		/// Get or set the display name of the address.
		/// </summary>
		/// <remarks>
		/// A name is optional and is typically set to the name of the person
		/// or group that own the internet address.
		/// </remarks>
		/// <value>The name of the address.</value>
		public string Name {
			get { return name; }
			set {
				if (value == name)
					return;

				name = value;
				OnChanged ();
			}
		}

		/// <summary>
		/// Clone the address.
		/// </summary>
		/// <remarks>
		/// Clones the address.
		/// </remarks>
		/// <returns>The cloned address.</returns>
		public abstract InternetAddress Clone ();

		#region IComparable implementation

		/// <summary>
		/// Compares two internet addresses.
		/// </summary>
		/// <remarks>
		/// Compares two internet addresses for the purpose of sorting.
		/// </remarks>
		/// <returns>The sort order of the current internet address compared to the other internet address.</returns>
		/// <param name="other">The internet address to compare to.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="other"/> is <c>null</c>.
		/// </exception>
		public int CompareTo (InternetAddress other)
		{
			int rv;

			if (other == null)
				throw new ArgumentNullException (nameof (other));

			if ((rv = string.Compare (Name, other.Name, StringComparison.OrdinalIgnoreCase)) != 0)
				return rv;

			if (this is MailboxAddress mailbox && other is MailboxAddress otherMailbox) {
				string otherAddress = otherMailbox.Address;
				int otherAt = otherAddress.IndexOf ('@');
				string address = mailbox.Address;
				int at = address.IndexOf ('@');

				if (at != -1 && otherAt != -1) {
					int length = Math.Min (address.Length - (at + 1), otherAddress.Length - (otherAt + 1));

					rv = string.Compare (address, at + 1, otherAddress, otherAt + 1, length, StringComparison.OrdinalIgnoreCase);
				}

				if (rv == 0) {
					string otherUser = otherAt != -1 ? otherAddress.Substring (0, otherAt) : otherAddress;
					string user = at != -1 ? address.Substring (0, at) : address;

					rv = string.Compare (user, otherUser, StringComparison.OrdinalIgnoreCase);
				}

				return rv;
			}

			// sort mailbox addresses before group addresses
			if (this is MailboxAddress mailbox && otherMailbox == null)
				return -1;

			if (mailbox == null && other is MailboxAddress otherMailbox)
				return 1;

			return 0;
		}

		#endregion

		#region IEquatable implementation

		/// <summary>
		/// Determines whether the specified <see cref="InternetAddress"/> is equal to the current <see cref="InternetAddress"/>.
		/// </summary>
		/// <remarks>
		/// Compares two internet addresses to determine if they are identical or not.
		/// </remarks>
		/// <param name="other">The <see cref="InternetAddress"/> to compare with the current <see cref="InternetAddress"/>.</param>
		/// <returns><c>true</c> if the specified <see cref="InternetAddress"/> is equal to the current
		/// <see cref="InternetAddress"/>; otherwise, <c>false</c>.</returns>
		public abstract bool Equals (InternetAddress other);

		#endregion

		/// <summary>
		/// Determine whether the specified object is equal to the current object.
		/// </summary>
		/// <remarks>
		/// The type of comparison between the current instance and the <paramref name="obj"/> parameter depends on whether
		/// the current instance is a reference type or a value type.
		/// </remarks>
		/// <param name="obj">The object to compare with the current object.</param>
		/// <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c>.</returns>
		public override bool Equals (object obj)
		{
			return Equals (obj as InternetAddress);
		}

		/// <summary>
		/// Return the hash code for this instance.
		/// </summary>
		/// <remarks>
		/// Returns the hash code for this instance.
		/// </remarks>
		/// <returns>A hash code for the current object.</returns>
		public override int GetHashCode ()
		{
			return ToString ().GetHashCode ();
		}

		internal static string EncodeInternationalizedPhrase (string phrase)
		{
			for (int i = 0; i < phrase.Length; i++) {
				if (AtomSpecials.IndexOf (phrase[i]) != -1)
					return MimeUtils.Quote (phrase);
			}

			return phrase;
		}

		internal abstract void Encode (FormatOptions options, StringBuilder builder, bool firstToken, ref int lineLength);

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string, optionally encoding it for transport.
		/// </summary>
		/// <remarks>
		/// <para>If the <paramref name="encode"/> parameter is <c>true</c>, then this method will return
		/// an encoded version of the internet address according to the rules described in rfc2047.</para>
		/// <para>However, if the <paramref name="encode"/> parameter is <c>false</c>, then this method will
		/// return a string suitable only for display purposes.</para>
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The formatting options.</param>
		/// <param name="encode">If set to <c>true</c>, the <see cref="InternetAddress"/> will be encoded.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="options"/> is <c>null</c>.
		/// </exception>
		public abstract string ToString (FormatOptions options, bool encode);

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string, optionally encoding it for transport.
		/// </summary>
		/// <remarks>
		/// <para>If the <paramref name="encode"/> parameter is <c>true</c>, then this method will return
		/// an encoded version of the internet address according to the rules described in rfc2047.</para>
		/// <para>However, if the <paramref name="encode"/> parameter is <c>false</c>, then this method will
		/// return a string suitable only for display purposes.</para>
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		/// <param name="encode">If set to <c>true</c>, the <see cref="InternetAddress"/> will be encoded.</param>
		public string ToString (bool encode)
		{
			return ToString (FormatOptions.Default, encode);
		}

		/// <summary>
		/// Serialize an <see cref="InternetAddress"/> to a string suitable for display.
		/// </summary>
		/// <remarks>
		/// The string returned by this method is suitable only for display purposes.
		/// </remarks>
		/// <returns>A string representing the <see cref="InternetAddress"/>.</returns>
		public override string ToString ()
		{
			return ToString (FormatOptions.Default, false);
		}

		internal event EventHandler Changed;

		/// <summary>
		/// Raise the internal changed event used by <see cref="MimeMessage"/> to keep headers in sync.
		/// </summary>
		/// <remarks>
		/// This method is called whenever a property of the internet address is changed.
		/// </remarks>
		protected virtual void OnChanged ()
		{
			if (Changed != null)
				Changed (this, EventArgs.Empty);
		}

		internal static bool TryParseLocalPart (byte[] text, ref int index, int endIndex, bool skipTrailingCfws, bool throwOnError, out string localpart)
		{
			var token = new StringBuilder ();
			int startIndex = index;

			localpart = null;

			do {
				if (!text[index].IsAtom () && text[index] != '"') {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid local-part at offset {0}", startIndex), startIndex, index);

					return false;
				}

				int start = index;
				if (!ParseUtils.SkipWord (text, ref index, endIndex, throwOnError))
					return false;

				try {
					token.Append (CharsetUtils.UTF8.GetString (text, start, index - start));
				} catch (DecoderFallbackException) {
					try {
						token.Append (CharsetUtils.Latin1.GetString (text, start, index - start));
					} catch (DecoderFallbackException ex) {
						if (throwOnError)
							throw new ParseException ("Internationalized local-part tokens may only contain UTF-8 characters.", start, start, ex);

						return false;
					}
				}

				int cfws = index;
				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex || text[index] != (byte) '.') {
					if (!skipTrailingCfws)
						index = cfws;
					break;
				}

				token.Append ('.');
				index++;

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete local-part at offset {0}", startIndex), startIndex, index);

					return false;
				}
			} while (true);

			localpart = token.ToString ();

			if (ParseUtils.IsIdnEncoded (localpart))
				localpart = ParseUtils.IdnDecode (localpart);

			return true;
		}

		static readonly byte[] CommaGreaterThanOrSemiColon = { (byte) ',', (byte) '>', (byte) ';' };

		internal static bool TryParseAddrspec (byte[] text, ref int index, int endIndex, byte[] sentinels, bool throwOnError, out string addrspec, out int at)
		{
			int startIndex = index;
			string localpart;

			addrspec = null;
			at = -1;

			if (!TryParseLocalPart (text, ref index, endIndex, true, throwOnError, out localpart))
				return false;

			if (index >= endIndex || ParseUtils.IsSentinel (text[index], sentinels)) {
				addrspec = localpart;
				return true;
			}

			if (text[index] != (byte) '@') {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			index++;
			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			string domain;
			if (!ParseUtils.TryParseDomain (text, ref index, endIndex, sentinels, throwOnError, out domain))
				return false;

			if (ParseUtils.IsIdnEncoded (domain))
				domain = ParseUtils.IdnDecode (domain);

			addrspec = localpart + "@" + domain;
			at = localpart.Length;

			return true;
		}

		internal static bool TryParseMailbox (ParserOptions options, byte[] text, int startIndex, ref int index, int endIndex, string name, int codepage, bool throwOnError, out InternetAddress address)
		{
			DomainList route = null;
			Encoding encoding;

			try {
				encoding = Encoding.GetEncoding (codepage);
			} catch {
				encoding = Encoding.UTF8;
			}

			address = null;

			// skip over the '<'
			index++;

			// Note: check for excessive angle brackets like the example described in section 7.1.2 of rfc7103...
			if (index < endIndex && text[index] == (byte) '<') {
				if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Excessive angle brackets at offset {0}", index), startIndex, index);

					return false;
				}

				do {
					index++;
				} while (index < endIndex && text[index] == '<');
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete mailbox at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (text[index] == (byte) '@') {
				// Note: we always pass 'false' as the throwOnError argument here so that we can throw a more informative exception on error
				if (!DomainList.TryParse (text, ref index, endIndex, false, out route)) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid route in mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (index >= endIndex || text[index] != (byte) ':') {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete route in mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}

				// skip over ':'
				index++;

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}
			}

			// Note: The only syntactically correct sentinel token here is the '>', but alas... to deal with the first example
			// in section 7.1.5 of rfc7103, we need to at least handle ',' as a sentinel and might as well handle ';' as well
			// in case the mailbox is within a group address.
			//
			// Example: <third@example.net, fourth@example.net>
			string addrspec;
			int at;

			if (!TryParseAddrspec (text, ref index, endIndex, CommaGreaterThanOrSemiColon, throwOnError, out addrspec, out at))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index >= endIndex || text[index] != (byte) '>') {
				if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected end of mailbox at offset {0}", startIndex), startIndex, index);

					return false;
				}
			} else {
				// skip over the '>'
				index++;

				// Note: check for excessive angle brackets like the example described in section 7.1.2 of rfc7103...
				if (index < endIndex && text[index] == (byte) '>') {
					if (options.AddressParserComplianceMode == RfcComplianceMode.Strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Excessive angle brackets at offset {0}", index), startIndex, index);

						return false;
					}

					do {
						index++;
					} while (index < endIndex && text[index] == '>');
				}
			}

			if (route != null)
				address = new MailboxAddress (encoding, name, route, addrspec, at);
			else
				address = new MailboxAddress (encoding, name, addrspec, at);

			return true;
		}

		static bool TryParseGroup (ParserOptions options, byte[] text, int startIndex, ref int index, int endIndex, int groupDepth, string name, int codepage, bool throwOnError, out InternetAddress address)
		{
			List<InternetAddress> members;
			Encoding encoding;

			try {
				encoding = Encoding.GetEncoding (codepage);
			} catch {
				encoding = Encoding.UTF8;
			}

			address = null;

			// skip over the ':'
			index++;

			while (index < endIndex && (text[index] == ':' || text[index].IsBlank ()))
				index++;

			if (InternetAddressList.TryParse (options, text, ref index, endIndex, true, groupDepth, throwOnError, out members))
				address = new GroupAddress (encoding, name, members);
			else
				address = new GroupAddress (encoding, name);

			if (index >= endIndex || text[index] != (byte) ';') {
				if (throwOnError && options.AddressParserComplianceMode == RfcComplianceMode.Strict)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Expected to find ';' at offset {0}", index), startIndex, index);

				while (index < endIndex && text[index] != (byte) ';')
					index++;
			} else {
				index++;
			}

			return true;
		}

		[Flags]
		internal enum AddressParserFlags {
			AllowMailboxAddress = 1 << 0,
			AllowGroupAddress   = 1 << 1,
			ThrowOnError        = 1 << 2,

			TryParse            = AllowMailboxAddress | AllowGroupAddress,
			Parse               = TryParse | ThrowOnError
		}

		internal static bool TryParse (ParserOptions options, byte[] text, ref int index, int endIndex, int groupDepth, AddressParserFlags flags, out InternetAddress address)
		{
			bool strict = options.AddressParserComplianceMode == RfcComplianceMode.Strict;
			bool throwOnError = (flags & AddressParserFlags.ThrowOnError) != 0;
			int minWordCount = options.AllowUnquotedCommasInAddresses ? 0 : 1;

			address = null;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			if (index == endIndex) {
				if (throwOnError)
					throw new ParseException ("No address found.", index, index);

				return false;
			}

			// keep track of the start & length of the phrase
			bool trimLeadingQuote = false;
			int startIndex = index;
			int length = 0;
			int words = 0;

			while (index < endIndex) {
				if (strict) {
					if (!ParseUtils.SkipWord (text, ref index, endIndex, throwOnError))
						break;
				} else if (text[index] == (byte) '"') {
					int qstringIndex = index;

					if (!ParseUtils.SkipQuoted (text, ref index, endIndex, false)) {
						index = qstringIndex + 1;

						ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

						if (!ParseUtils.SkipPhraseAtom (text, ref index, endIndex)) {
							if (throwOnError)
								throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete quoted-string token at offset {0}", qstringIndex), qstringIndex, endIndex);

							break;
						}

						if (startIndex == qstringIndex)
							trimLeadingQuote = true;
					}
				} else {
					if (!ParseUtils.SkipPhraseAtom (text, ref index, endIndex))
						break;
				}

				length = index - startIndex;

				do {
					if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
						return false;

					// Note: some clients don't quote dots in the name
					if (index >= endIndex || text[index] != (byte) '.')
						break;

					index++;

					length = index - startIndex;
				} while (true);

				words++;

				// Note: some clients don't quote commas in the name
				if (index < endIndex && text[index] == ',' && words > minWordCount) {
					index++;

					length = index - startIndex;

					if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
						return false;
				}
			}

			if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
				return false;

			// specials    =  "(" / ")" / "<" / ">" / "@"  ; Must be in quoted-
			//             /  "," / ";" / ":" / "\" / <">  ;  string, to use
			//             /  "." / "[" / "]"              ;  within a word.

			if (index >= endIndex || text[index] == (byte) ',' || text[index] == (byte) '>' || text[index] == ';') {
				// we've completely gobbled up an addr-spec w/o a domain
				byte sentinel = index < endIndex ? text[index] : (byte) ',';
				string name, addrspec;

				if ((flags & AddressParserFlags.AllowMailboxAddress) == 0) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Addr-spec token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (!options.AllowAddressesWithoutDomain) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete addr-spec token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				// rewind back to the beginning of the local-part
				index = startIndex;

				if (!TryParseLocalPart (text, ref index, endIndex, false, throwOnError, out addrspec))
					return false;

				ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

				if (index < endIndex && text[index] == '(') {
					int comment = index + 1;

					// Note: this can't fail because it has already been skipped in TryParseLocalPart() above.
					ParseUtils.SkipComment (text, ref index, endIndex);

					name = Rfc2047.DecodePhrase (options, text, comment, (index - 1) - comment).Trim ();

					ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError);
				} else {
					name = string.Empty;
				}

				if (index < endIndex && text[index] == (byte) '>') {
					if (strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '>' token at offset {0}", index), startIndex, index);

						return false;
					}

					index++;
				}

				if (index < endIndex && text[index] != sentinel) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), startIndex, index);

					return false;
				}

				address = new MailboxAddress (Encoding.UTF8, name, addrspec, -1);

				return true;
			}

			if (text[index] == (byte) ':') {
				// rfc2822 group address
				int nameIndex = startIndex;
				int codepage = -1;
				string name;

				if ((flags & AddressParserFlags.AllowGroupAddress) == 0) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Group address token at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (groupDepth >= options.MaxAddressGroupDepth) {
					if (throwOnError)
						throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Exceeded maximum rfc822 group depth at offset {0}", startIndex), startIndex, index);

					return false;
				}

				if (trimLeadingQuote) {
					nameIndex++;
					length--;
				}

				if (length > 0) {
					name = Rfc2047.DecodePhrase (options, text, nameIndex, length, out codepage);
				} else {
					name = string.Empty;
				}

				if (codepage == -1)
					codepage = 65001;

				return TryParseGroup (options, text, startIndex, ref index, endIndex, groupDepth + 1, MimeUtils.Unquote (name), codepage, throwOnError, out address);
			}

			if ((flags & AddressParserFlags.AllowMailboxAddress) == 0) {
				if (throwOnError)
					throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Mailbox address token at offset {0}", startIndex), startIndex, index);

				return false;
			}

			if (text[index] == (byte) '@') {
				// we're either in the middle of an addr-spec token or we completely gobbled up an addr-spec w/o a domain
				string name, addrspec;
				int at;

				// rewind back to the beginning of the local-part
				index = startIndex;

				if (!TryParseAddrspec (text, ref index, endIndex, CommaGreaterThanOrSemiColon, throwOnError, out addrspec, out at))
					return false;

				ParseUtils.SkipWhiteSpace (text, ref index, endIndex);

				if (index < endIndex && text[index] == '(') {
					int comment = index;

					if (!ParseUtils.SkipComment (text, ref index, endIndex)) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Incomplete comment token at offset {0}", comment), comment, index);

						return false;
					}

					comment++;

					name = Rfc2047.DecodePhrase (options, text, comment, (index - 1) - comment).Trim ();
				} else {
					name = string.Empty;
				}

				if (!ParseUtils.SkipCommentsAndWhiteSpace (text, ref index, endIndex, throwOnError))
					return false;

				if (index >= endIndex) {
					address = new MailboxAddress (Encoding.UTF8, name, addrspec, at);
					return true;
				}

				if (text[index] == (byte) '<') {
					// We have an address like "user@example.com <user@example.com>"; i.e. the name is an unquoted string with an '@'.
					if (strict) {
						if (throwOnError)
							throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '<' token at offset {0}", index), startIndex, index);

						return false;
					}

					int nameEndIndex = index;
					while (nameEndIndex > startIndex && text[nameEndIndex - 1].IsWhitespace ())
						nameEndIndex--;

					length = nameEndIndex - startIndex;

					// fall through to the rfc822 angle-addr token case...
				} else {
					// Note: since there was no '<', there should not be a '>'... but we handle it anyway in order to
					// deal with the second Unbalanced Angle Brackets example in section 7.1.3: second@example.org>
					if (text[index] == (byte) '>') {
						if (strict) {
							if (throwOnError)
								throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected '>' token at offset {0}", index), startIndex, index);

							return false;
						}

						index++;
					}

					address = new MailboxAddress (Encoding.UTF8, name, addrspec, at);

					return true;
				}
			}

			if (text[index] == (byte) '<') {
				// rfc2822 angle-addr token
				int nameIndex = startIndex;
				int codepage = -1;
				string name;

				if (trimLeadingQuote) {
					nameIndex++;
					length--;
				}

				if (length > 0) {
					name = Rfc2047.DecodePhrase (options, text, nameIndex, length, out codepage);
				} else {
					name = string.Empty;
				}

				if (codepage == -1)
					codepage = 65001;

				return TryParseMailbox (options, text, startIndex, ref index, endIndex, MimeUtils.Unquote (name), codepage, throwOnError, out address);
			}

			if (throwOnError)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Invalid address token at offset {0}", startIndex), startIndex, index);

			return false;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, int startIndex, int length, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex, length);

			int endIndex = startIndex + length;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false)) {
				address = null;
				return false;
			}

			if (index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		public static bool TryParse (byte[] buffer, int startIndex, int length, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, startIndex, length, out address);
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, int startIndex, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex);

			int endIndex = buffer.Length;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		public static bool TryParse (byte[] buffer, int startIndex, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, startIndex, out address);
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		public static bool TryParse (ParserOptions options, byte[] buffer, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, buffer);

			int endIndex = buffer.Length;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (byte[] buffer, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, buffer, out address);
		}

		/// <summary>
		/// Try to parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="text">The text.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (ParserOptions options, string text, out InternetAddress address)
		{
			ParseUtils.ValidateArguments (options, text);

			var buffer = Encoding.UTF8.GetBytes (text);
			int endIndex = buffer.Length;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.TryParse, out address))
				return false;

			if (!ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, false) || index != endIndex) {
				address = null;
				return false;
			}

			return true;
		}

		/// <summary>
		/// Try to parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns><c>true</c>, if the address was successfully parsed, <c>false</c> otherwise.</returns>
		/// <param name="text">The text.</param>
		/// <param name="address">The parsed address.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		public static bool TryParse (string text, out InternetAddress address)
		{
			return TryParse (ParserOptions.Default, text, out address);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer, int startIndex, int length)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex, length);

			int endIndex = startIndex + length;
			InternetAddress address;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", startIndex, startIndex);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <param name="length">The number of bytes in the input buffer to parse.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> and <paramref name="length"/> do not specify
		/// a valid range in the byte array.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer, int startIndex, int length)
		{
			return Parse (ParserOptions.Default, buffer, startIndex, length);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/>is out of range.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer, int startIndex)
		{
			ParseUtils.ValidateArguments (options, buffer, startIndex);

			int endIndex = buffer.Length;
			InternetAddress address;
			int index = startIndex;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", startIndex, startIndex);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <param name="startIndex">The starting index of the input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="startIndex"/> is out of range.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer, int startIndex)
		{
			return Parse (ParserOptions.Default, buffer, startIndex);
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="buffer">The input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="buffer"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, byte[] buffer)
		{
			ParseUtils.ValidateArguments (options, buffer);

			int endIndex = buffer.Length;
			InternetAddress address;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", 0, 0);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given input buffer into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the buffer contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="buffer">The input buffer.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="buffer"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="buffer"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (byte[] buffer)
		{
			return Parse (ParserOptions.Default, buffer);
		}

		/// <summary>
		/// Parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="options">The parser options to use.</param>
		/// <param name="text">The text.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="text"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="text"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (ParserOptions options, string text)
		{
			ParseUtils.ValidateArguments (options, text);

			var buffer = Encoding.UTF8.GetBytes (text);
			int endIndex = buffer.Length;
			InternetAddress address;
			int index = 0;

			if (!TryParse (options, buffer, ref index, endIndex, 0, AddressParserFlags.Parse, out address))
				throw new ParseException ("No address found.", 0, 0);

			ParseUtils.SkipCommentsAndWhiteSpace (buffer, ref index, endIndex, true);

			if (index != endIndex)
				throw new ParseException (string.Format (CultureInfo.InvariantCulture, "Unexpected token at offset {0}", index), index, index);

			return address;
		}

		/// <summary>
		/// Parse the given text into a new <see cref="InternetAddress"/> instance.
		/// </summary>
		/// <remarks>
		/// Parses a single <see cref="MailboxAddress"/> or <see cref="GroupAddress"/>. If the text contains
		/// more data, then parsing will fail.
		/// </remarks>
		/// <returns>The parsed <see cref="InternetAddress"/>.</returns>
		/// <param name="text">The text.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="text"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="MimeKit.ParseException">
		/// <paramref name="text"/> could not be parsed.
		/// </exception>
		public static InternetAddress Parse (string text)
		{
			return Parse (ParserOptions.Default, text);
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\InternetAddress.cs(174,31): error CS0128: A local variable or function named 'mailbox' is already defined in this scope,D:\a\1\s\MimeKit\InternetAddress.cs(177,51): error CS0128: A local variable or function named 'otherMailbox' is already defined in this scope,D:\a\1\s\MimeKit\InternetAddress.cs(174,42): error CS0165: Use of unassigned local variable 'otherMailbox',D:\a\1\s\MimeKit\InternetAddress.cs(177,8): error CS0165: Use of unassigned local variable 'mailbox'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MimeKit\MimeIterator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace MimeKit {
	/// <summary>
	/// An iterator for a MIME tree structure.
	/// </summary>
	/// <remarks>
	/// Walks the MIME tree structure of a <see cref="MimeMessage"/> in depth-first order.
	/// </remarks>
	/// <example>
	/// <code language="c#" source="Examples\MimeIterator.cs" />
	/// </example>
	public class MimeIterator : IEnumerator<MimeEntity>
	{
		class MimeNode
		{
			public readonly MimeEntity Entity;
			public readonly bool Indexed;

			public MimeNode (MimeEntity entity, bool indexed)
			{
				Entity = entity;
				Indexed = indexed;
			}
		}

		readonly Stack<MimeNode> stack = new Stack<MimeNode> ();
		readonly List<int> path = new List<int> ();
		bool moveFirst = true;
		MimeEntity current;
		int index = -1;

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeIterator"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MimeIterator"/> for the specified message.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <param name="message">The message.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="message"/> is <c>null</c>.
		/// </exception>
		public MimeIterator (MimeMessage message)
		{
			if (message == null)
				throw new ArgumentNullException (nameof (message));

			Message = message;
		}

		/// <summary>
		/// Releases unmanaged resources and performs other cleanup operations before
		/// the <see cref="MimeIterator"/> is reclaimed by garbage collection.
		/// </summary>
		/// <remarks>
		/// Releases unmanaged resources and performs other cleanup operations before
		/// the <see cref="MimeIterator"/> is reclaimed by garbage collection.
		/// </remarks>
		~MimeIterator ()
		{
			Dispose (false);
		}

		/// <summary>
		/// Gets the top-level message.
		/// </summary>
		/// <remarks>
		/// Gets the top-level message.
		/// </remarks>
		/// <value>The message.</value>
		public MimeMessage Message {
			get; private set;
		}

		/// <summary>
		/// Gets the parent of the current entity.
		/// </summary>
		/// <remarks>
		/// <para>After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Parent property;
		/// otherwise, Parent throws a <see cref="System.InvalidOperationException"/>. Parent
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.</para>
		/// <para>If the current entity is the top-level entity of the message, then the parent
		/// will be <c>null</c>; otherwise the parent will be either be a
		/// <see cref="MessagePart"/> or a <see cref="Multipart"/>.</para>
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <value>The parent entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public MimeEntity Parent {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return stack.Count > 0 ? stack.Peek ().Entity : null;
			}
		}

		/// <summary>
		/// Gets the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Current property;
		/// otherwise, Current throws a <see cref="System.InvalidOperationException"/>. Current
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <value>The current entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public MimeEntity Current {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return current;
			}
		}

		/// <summary>
		/// Gets the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Current property;
		/// otherwise, Current throws a <see cref="System.InvalidOperationException"/>. Current
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <value>The current entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		object IEnumerator.Current {
			get { return Current; }
		}

		/// <summary>
		/// Gets the path specifier for the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the PathSpecifier property;
		/// otherwise, PathSpecifier throws a <see cref="System.InvalidOperationException"/>.
		/// PathSpecifier also throws a <see cref="System.InvalidOperationException"/> if the
		/// last call to <see cref="MoveNext()"/> returned false, which indicates the end of
		/// the message.
		/// </remarks>
		/// <value>The path specifier.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public string PathSpecifier {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				var specifier = new StringBuilder ();

				for (int i = 0; i < path.Count; i++)
					specifier.AppendFormat ("{0}.", path[i] + 1);

				specifier.AppendFormat ("{0}", index + 1);

				return specifier.ToString ();
			}
		}

		/// <summary>
		/// Gets the depth of the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Depth property;
		/// otherwise, Depth throws a <see cref="System.InvalidOperationException"/>. Depth
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <value>The depth.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public int Depth {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return stack.Count;
			}
		}

		void Push (MimeEntity entity)
		{
			if (index != -1)
				path.Add (index);

			stack.Push (new MimeNode (entity, index != -1));
		}

		bool Pop ()
		{
			if (stack.Count == 0)
				return false;

			var node = stack.Pop ();

			if (node.Indexed) {
				index = path[path.Count - 1];
				path.RemoveAt (path.Count - 1);
			}

			current = node.Entity;

			return true;
		}

		/// <summary>
		/// Advances the iterator to the next depth-first entity of the tree structure.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// an iterator is positioned before the first entity of the message, and the first
		/// call to the MoveNext method moves the iterator to the first entity of the message.
		/// If MoveNext advances beyond the last entity of the message, MoveNext returns false.
		/// When the iterator is at this position, subsequent calls to MoveNext also return
		/// false until <see cref="Reset()"/> is called.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <returns><c>true</c> if the iterator was successfully advanced to the next entity; otherwise, <c>false</c>.</returns>
		public bool MoveNext ()
		{
			if (moveFirst) {
				current = Message.Body;
				moveFirst = false;

				return current != null;
			}

			var message_part = current as MessagePart;
			var multipart = current as Multipart;

			if (message_part != null) {
				current = message_part.Message != null ? message_part.Message.Body : null;

				if (current != null) {
					Push (message_part);
					index = current is Multipart ? -1 : 0;
					return true;
				}
			}

			if (multipart != null) {
				if (multipart.Count > 0) {
					Push (current);
					current = multipart[0];
					index = 0;
					return true;
				}
			}

			// find the next sibling
			while (stack.Count > 0) {
				multipart = stack.Peek ().Entity as Multipart;

				if (multipart != null) {
					// advance to the next part in the multipart...
					if (multipart.Count > ++index) {
						current = multipart[index];
						return true;
					}
				}

				if (!Pop ())
					break;
			}

			current = null;
			index = -1;

			return false;
		}

		static int[] Parse (string pathSpecifier)
		{
			var path = pathSpecifier.Split ('.');
			var indexes = new int[path.Length];
			int index;

			for (int i = 0; i < path.Length; i++) {
				if (!int.TryParse (path[i], out index) || index < 0)
					throw new FormatException ("Invalid path specifier format.");

				indexes[i] = index - 1;
			}

			return indexes;
		}

		/// <summary>
		/// Advances to the entity specified by the path specifier.
		/// </summary>
		/// <remarks>
		/// <para>Advances the iterator to the entity specified by the path specifier which
		/// must be in the same format as returned by <see cref="PathSpecifier"/>.</para>
		/// <para>If the iterator has already advanced beyond the entity at the specified
		/// path, the iterator will <see cref="Reset()"/> and advance as normal.</para>
		/// </remarks>
		/// <returns><c>true</c> if advancing to the specified entity was successful; otherwise, <c>false</c>.</returns>
		/// <param name="pathSpecifier">The path specifier.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="pathSpecifier"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="pathSpecifier"/> is empty.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// <paramref name="pathSpecifier"/> is in an invalid format.
		/// </exception>
		public bool MoveTo (string pathSpecifier)
		{
			if (pathSpecifier == null)
				throw new ArgumentNullException (nameof (pathSpecifier));

			if (pathSpecifier.Length == 0)
				throw new ArgumentException ("The path specifier cannot be empty.", nameof (pathSpecifier));

			var indexes = Parse (pathSpecifier);
			int i;

			// OPTIMIZATION: only reset the iterator if we are jumping to a previous part
			for (i = 0; i < Math.Min (indexes.Length, path.Count); i++) {
				if (indexes[i] < path[i]) {
					Reset ();
					break;
				}
			}

			if (!moveFirst && indexes.Length < path.Count)
				Reset ();

			if (moveFirst && !MoveNext ())
				return false;

			do {
				if (path.Count + 1 == indexes.Length) {
					for (i = 0; i < path.Count; i++) {
						if (indexes[i] != path[i])
							break;
					}

					if (i == path.Count && indexes[i] == index)
						return true;
				}
			} while (MoveNext ());

			return false;
		}

		/// <summary>
		/// Resets the iterator to its initial state.
		/// </summary>
		/// <remarks>
		/// Resets the iterator to its initial state.
		/// </remarks>
		public void Reset ()
		{
			moveFirst = true;
			current = null;
			stack.Clear ();
			path.Clear ();
			index = -1;
		}

		/// <summary>
		/// Releases the unmanaged resources used by the <see cref="MimeIterator"/> and
		/// optionally releases the managed resources.
		/// </summary>
		/// <remarks>
		/// Releases the unmanaged resources used by the <see cref="MimeIterator"/> and
		/// optionally releases the managed resources.
		/// </remarks>
		/// <param name="disposing"><c>true</c> to release both managed and unmanaged resources;
		/// <c>false</c> to release only the unmanaged resources.</param>
		protected virtual void Dispose (bool disposing)
		{
		}

		/// <summary>
		/// Releases all resources used by the <see cref="MimeIterator"/> object.
		/// </summary>
		/// <remarks>Call <see cref="Dispose()"/> when you are finished using the <see cref="MimeIterator"/>. The
		/// <see cref="Dispose()"/> method leaves the <see cref="MimeIterator"/> in an unusable state. After
		/// calling <see cref="Dispose()"/>, you must release all references to the <see cref="MimeIterator"/> so
		/// the garbage collector can reclaim the memory that the <see cref="MimeIterator"/> was occupying.</remarks>
		public void Dispose ()
		{
			Dispose (true);
			GC.SuppressFinalize (this);
		}
	}
}

---- Transformed Tree ----
using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace MimeKit {
	/// <summary>
	/// An iterator for a MIME tree structure.
	/// </summary>
	/// <remarks>
	/// Walks the MIME tree structure of a <see cref="MimeMessage"/> in depth-first order.
	/// </remarks>
	/// <example>
	/// <code language="c#" source="Examples\MimeIterator.cs" />
	/// </example>
	public class MimeIterator : IEnumerator<MimeEntity>
	{
		class MimeNode
		{
			public readonly MimeEntity Entity;
			public readonly bool Indexed;

			public MimeNode (MimeEntity entity, bool indexed)
			{
				Entity = entity;
				Indexed = indexed;
			}
		}

		readonly Stack<MimeNode> stack = new Stack<MimeNode> ();
		readonly List<int> path = new List<int> ();
		bool moveFirst = true;
		MimeEntity current;
		int index = -1;

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeIterator"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MimeIterator"/> for the specified message.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <param name="message">The message.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="message"/> is <c>null</c>.
		/// </exception>
		public MimeIterator (MimeMessage message)
		{
			if (message == null)
				throw new ArgumentNullException (nameof (message));

			Message = message;
		}

		/// <summary>
		/// Releases unmanaged resources and performs other cleanup operations before
		/// the <see cref="MimeIterator"/> is reclaimed by garbage collection.
		/// </summary>
		/// <remarks>
		/// Releases unmanaged resources and performs other cleanup operations before
		/// the <see cref="MimeIterator"/> is reclaimed by garbage collection.
		/// </remarks>
		~MimeIterator ()
		{
			Dispose (false);
		}

		/// <summary>
		/// Gets the top-level message.
		/// </summary>
		/// <remarks>
		/// Gets the top-level message.
		/// </remarks>
		/// <value>The message.</value>
		public MimeMessage Message {
			get; private set;
		}

		/// <summary>
		/// Gets the parent of the current entity.
		/// </summary>
		/// <remarks>
		/// <para>After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Parent property;
		/// otherwise, Parent throws a <see cref="System.InvalidOperationException"/>. Parent
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.</para>
		/// <para>If the current entity is the top-level entity of the message, then the parent
		/// will be <c>null</c>; otherwise the parent will be either be a
		/// <see cref="MessagePart"/> or a <see cref="Multipart"/>.</para>
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <value>The parent entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public MimeEntity Parent {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return stack.Count > 0 ? stack.Peek ().Entity : null;
			}
		}

		/// <summary>
		/// Gets the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Current property;
		/// otherwise, Current throws a <see cref="System.InvalidOperationException"/>. Current
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <value>The current entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public MimeEntity Current {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return current;
			}
		}

		/// <summary>
		/// Gets the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Current property;
		/// otherwise, Current throws a <see cref="System.InvalidOperationException"/>. Current
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <value>The current entity.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		object IEnumerator.Current {
			get { return Current; }
		}

		/// <summary>
		/// Gets the path specifier for the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the PathSpecifier property;
		/// otherwise, PathSpecifier throws a <see cref="System.InvalidOperationException"/>.
		/// PathSpecifier also throws a <see cref="System.InvalidOperationException"/> if the
		/// last call to <see cref="MoveNext()"/> returned false, which indicates the end of
		/// the message.
		/// </remarks>
		/// <value>The path specifier.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public string PathSpecifier {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				var specifier = new StringBuilder ();

				for (int i = 0; i < path.Count; i++)
					specifier.AppendFormat ("{0}.", path[i] + 1);

				specifier.AppendFormat ("{0}", index + 1);

				return specifier.ToString ();
			}
		}

		/// <summary>
		/// Gets the depth of the current entity.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// the <see cref="MoveNext()"/> method must be called to advance the iterator to the
		/// first entity of the message before reading the value of the Depth property;
		/// otherwise, Depth throws a <see cref="System.InvalidOperationException"/>. Depth
		/// also throws a <see cref="System.InvalidOperationException"/> if the last call to
		/// <see cref="MoveNext()"/> returned false, which indicates the end of the message.
		/// </remarks>
		/// <value>The depth.</value>
		/// <exception cref="System.InvalidOperationException">
		/// Either <see cref="MoveNext()"/> has not been called or <see cref="MoveNext()"/>
		/// has moved beyond the end of the message.
		/// </exception>
		public int Depth {
			get {
				if (current == null)
					throw new InvalidOperationException ();

				return stack.Count;
			}
		}

		void Push (MimeEntity entity)
		{
			if (index != -1)
				path.Add (index);

			stack.Push (new MimeNode (entity, index != -1));
		}

		bool Pop ()
		{
			if (stack.Count == 0)
				return false;

			var node = stack.Pop ();

			if (node.Indexed) {
				index = path[path.Count - 1];
				path.RemoveAt (path.Count - 1);
			}

			current = node.Entity;

			return true;
		}

		/// <summary>
		/// Advances the iterator to the next depth-first entity of the tree structure.
		/// </summary>
		/// <remarks>
		/// After an iterator is created or after the <see cref="Reset()"/> method is called,
		/// an iterator is positioned before the first entity of the message, and the first
		/// call to the MoveNext method moves the iterator to the first entity of the message.
		/// If MoveNext advances beyond the last entity of the message, MoveNext returns false.
		/// When the iterator is at this position, subsequent calls to MoveNext also return
		/// false until <see cref="Reset()"/> is called.
		/// </remarks>
		/// <example>
		/// <code language="c#" source="Examples\MimeIterator.cs" />
		/// </example>
		/// <returns><c>true</c> if the iterator was successfully advanced to the next entity; otherwise, <c>false</c>.</returns>
		public bool MoveNext ()
		{
			if (moveFirst) {
				current = Message.Body;
				moveFirst = false;

				return current != null;
			}

			if (current is MessagePart message_part) {
				current = message_part.Message != null ? message_part.Message.Body : null;

				if (current != null) {
					Push (message_part);
					index = current is Multipart ? -1 : 0;
					return true;
				}
			}

			if (current is Multipart multipart) {
				if (multipart.Count > 0) {
					Push (current);
					current = multipart[0];
					index = 0;
					return true;
				}
			}

			// find the next sibling
			while (stack.Count > 0) {
				multipart = stack.Peek ().Entity as Multipart;

				if (current is Multipart multipart) {
					// advance to the next part in the multipart...
					if (multipart.Count > ++index) {
						current = multipart[index];
						return true;
					}
				}

				if (!Pop ())
					break;
			}

			current = null;
			index = -1;

			return false;
		}

		static int[] Parse (string pathSpecifier)
		{
			var path = pathSpecifier.Split ('.');
			var indexes = new int[path.Length];
			int index;

			for (int i = 0; i < path.Length; i++) {
				if (!int.TryParse (path[i], out index) || index < 0)
					throw new FormatException ("Invalid path specifier format.");

				indexes[i] = index - 1;
			}

			return indexes;
		}

		/// <summary>
		/// Advances to the entity specified by the path specifier.
		/// </summary>
		/// <remarks>
		/// <para>Advances the iterator to the entity specified by the path specifier which
		/// must be in the same format as returned by <see cref="PathSpecifier"/>.</para>
		/// <para>If the iterator has already advanced beyond the entity at the specified
		/// path, the iterator will <see cref="Reset()"/> and advance as normal.</para>
		/// </remarks>
		/// <returns><c>true</c> if advancing to the specified entity was successful; otherwise, <c>false</c>.</returns>
		/// <param name="pathSpecifier">The path specifier.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="pathSpecifier"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="pathSpecifier"/> is empty.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// <paramref name="pathSpecifier"/> is in an invalid format.
		/// </exception>
		public bool MoveTo (string pathSpecifier)
		{
			if (pathSpecifier == null)
				throw new ArgumentNullException (nameof (pathSpecifier));

			if (pathSpecifier.Length == 0)
				throw new ArgumentException ("The path specifier cannot be empty.", nameof (pathSpecifier));

			var indexes = Parse (pathSpecifier);
			int i;

			// OPTIMIZATION: only reset the iterator if we are jumping to a previous part
			for (i = 0; i < Math.Min (indexes.Length, path.Count); i++) {
				if (indexes[i] < path[i]) {
					Reset ();
					break;
				}
			}

			if (!moveFirst && indexes.Length < path.Count)
				Reset ();

			if (moveFirst && !MoveNext ())
				return false;

			do {
				if (path.Count + 1 == indexes.Length) {
					for (i = 0; i < path.Count; i++) {
						if (indexes[i] != path[i])
							break;
					}

					if (i == path.Count && indexes[i] == index)
						return true;
				}
			} while (MoveNext ());

			return false;
		}

		/// <summary>
		/// Resets the iterator to its initial state.
		/// </summary>
		/// <remarks>
		/// Resets the iterator to its initial state.
		/// </remarks>
		public void Reset ()
		{
			moveFirst = true;
			current = null;
			stack.Clear ();
			path.Clear ();
			index = -1;
		}

		/// <summary>
		/// Releases the unmanaged resources used by the <see cref="MimeIterator"/> and
		/// optionally releases the managed resources.
		/// </summary>
		/// <remarks>
		/// Releases the unmanaged resources used by the <see cref="MimeIterator"/> and
		/// optionally releases the managed resources.
		/// </remarks>
		/// <param name="disposing"><c>true</c> to release both managed and unmanaged resources;
		/// <c>false</c> to release only the unmanaged resources.</param>
		protected virtual void Dispose (bool disposing)
		{
		}

		/// <summary>
		/// Releases all resources used by the <see cref="MimeIterator"/> object.
		/// </summary>
		/// <remarks>Call <see cref="Dispose()"/> when you are finished using the <see cref="MimeIterator"/>. The
		/// <see cref="Dispose()"/> method leaves the <see cref="MimeIterator"/> in an unusable state. After
		/// calling <see cref="Dispose()"/>, you must release all references to the <see cref="MimeIterator"/> so
		/// the garbage collector can reclaim the memory that the <see cref="MimeIterator"/> was occupying.</remarks>
		public void Dispose ()
		{
			Dispose (true);
			GC.SuppressFinalize (this);
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\MimeIterator.cs(314,5): error CS0841: Cannot use local variable 'multipart' before it is declared,D:\a\1\s\MimeKit\MimeIterator.cs(316,30): error CS0136: A local or parameter named 'multipart' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\MimeKit\MimeParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;

using MimeKit.IO;
using MimeKit.Utils;

namespace MimeKit {
	enum BoundaryType
	{
		None,
		Eos,
		ImmediateBoundary,
		ImmediateEndBoundary,
		ParentBoundary,
		ParentEndBoundary,
	}

	class Boundary
	{
		public static readonly byte[] MboxFrom = Encoding.ASCII.GetBytes ("From ");

		public byte[] Marker { get; private set; }
		public int FinalLength { get { return Marker.Length; } }
		public int Length { get; private set; }
		public int MaxLength { get; private set; }

		public Boundary (string boundary, int currentMaxLength)
		{
			Marker = Encoding.UTF8.GetBytes ("--" + boundary + "--");
			Length = Marker.Length - 2;

			MaxLength = Math.Max (currentMaxLength, Marker.Length);
		}

		Boundary ()
		{
		}

		public static Boundary CreateMboxBoundary ()
		{
			var boundary = new Boundary ();
			boundary.Marker = MboxFrom;
			boundary.MaxLength = 5;
			boundary.Length = 5;
			return boundary;
		}

#if DEBUG_PARSER
		public override string ToString ()
		{
			return Encoding.UTF8.GetString (Marker, 0, Marker.Length);
		}
#endif
	}

	enum MimeParserState : sbyte
	{
		Error = -1,
		Initialized,
		MboxMarker,
		MessageHeaders,
		Headers,
		Content,
		Boundary,
		Complete,
		Eos
	}

	/// <summary>
	/// A MIME message and entity parser.
	/// </summary>
	/// <remarks>
	/// A MIME parser is used to parse <see cref="MimeMessage"/> and
	/// <see cref="MimeEntity"/> objects from arbitrary streams.
	/// </remarks>
	public partial class MimeParser : IEnumerable<MimeMessage>
	{
		static readonly byte[] UTF8ByteOrderMark = { 0xEF, 0xBB, 0xBF };
		const int ReadAheadSize = 128;
		const int BlockSize = 4096;
		const int PadSize = 4;

		// I/O buffering
		readonly byte[] input = new byte[ReadAheadSize + BlockSize + PadSize];
		const int inputStart = ReadAheadSize;
		int inputIndex = ReadAheadSize;
		int inputEnd = ReadAheadSize;

		// mbox From-line state
		byte[] mboxMarkerBuffer;
		long mboxMarkerOffset;
		int mboxMarkerLength;

		// message/rfc822 mbox markers (shouldn't exist, but sometimes do)
		byte[] preHeaderBuffer = new byte[128];
		int preHeaderLength;

		// header buffer
		byte[] headerBuffer = new byte[512];
		long headerOffset;
		int headerIndex;

		readonly List<Boundary> bounds = new List<Boundary> ();
		readonly List<Header> headers = new List<Header> ();

		MimeParserState state;
		BoundaryType boundary;
		MimeFormat format;
		bool persistent;
		bool toplevel;
		bool eos;

		ParserOptions options; // FIXME: might be better if devs passed ParserOptions into the Parse*() methods rather than .ctor and/or SetStream()
		long headerBlockBegin;
		long headerBlockEnd;
		long contentEnd;

		long prevLineBeginOffset;
		long lineBeginOffset;
		int lineNumber;

		Stream stream;
		long position;

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public MimeParser (Stream stream, MimeFormat format, bool persistent = false) : this (ParserOptions.Default, stream, format, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public MimeParser (Stream stream, bool persistent = false) : this (ParserOptions.Default, stream, MimeFormat.Default, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public MimeParser (ParserOptions options, Stream stream, bool persistent = false) : this (options, stream, MimeFormat.Default, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public MimeParser (ParserOptions options, Stream stream, MimeFormat format, bool persistent = false)
		{
			SetStream (options, stream, format, persistent);
		}

		/// <summary>
		/// Gets a value indicating whether the parser has reached the end of the input stream.
		/// </summary>
		/// <remarks>
		/// Gets a value indicating whether the parser has reached the end of the input stream.
		/// </remarks>
		/// <value><c>true</c> if this parser has reached the end of the input stream;
		/// otherwise, <c>false</c>.</value>
		public bool IsEndOfStream {
			get { return state == MimeParserState.Eos; }
		}

		/// <summary>
		/// Gets the current position of the parser within the stream.
		/// </summary>
		/// <remarks>
		/// Gets the current position of the parser within the stream.
		/// </remarks>
		/// <value>The stream offset.</value>
		public long Position {
			get { return GetOffset (inputIndex); }
		}

		/// <summary>
		/// Gets the most recent mbox marker offset.
		/// </summary>
		/// <remarks>
		/// Gets the most recent mbox marker offset.
		/// </remarks>
		/// <value>The mbox marker offset.</value>
		public long MboxMarkerOffset {
			get { return mboxMarkerOffset; }
		}

		/// <summary>
		/// Gets the most recent mbox marker.
		/// </summary>
		/// <remarks>
		/// Gets the most recent mbox marker.
		/// </remarks>
		/// <value>The mbox marker.</value>
		public string MboxMarker {
			get { return Encoding.UTF8.GetString (mboxMarkerBuffer, 0, mboxMarkerLength); }
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public void SetStream (ParserOptions options, Stream stream, MimeFormat format, bool persistent = false)
		{
			if (options == null)
				throw new ArgumentNullException (nameof (options));

			if (stream == null)
				throw new ArgumentNullException (nameof (stream));

			this.persistent = persistent && stream.CanSeek;
			this.options = options.Clone ();
			this.format = format;
			this.stream = stream;

			inputIndex = inputStart;
			inputEnd = inputStart;

			mboxMarkerOffset = 0;
			mboxMarkerLength = 0;
			headerBlockBegin = 0;
			headerBlockEnd = 0;
			lineNumber = 1;
			contentEnd = 0;

			position = stream.CanSeek ? stream.Position : 0;
			prevLineBeginOffset = position;
			lineBeginOffset = position;
			preHeaderLength = 0;
			headers.Clear ();
			headerOffset = 0;
			headerIndex = 0;
			toplevel = false;
			eos = false;

			bounds.Clear ();
			if (format == MimeFormat.Mbox) {
				bounds.Add (Boundary.CreateMboxBoundary ());

				if (mboxMarkerBuffer == null)
					mboxMarkerBuffer = new byte[ReadAheadSize];
			}

			state = MimeParserState.Initialized;
			boundary = BoundaryType.None;
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public void SetStream (ParserOptions options, Stream stream, bool persistent = false)
		{
			SetStream (options, stream, MimeFormat.Default, persistent);
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public void SetStream (Stream stream, MimeFormat format, bool persistent = false)
		{
			SetStream (ParserOptions.Default, stream, format, persistent);
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public void SetStream (Stream stream, bool persistent = false)
		{
			SetStream (ParserOptions.Default, stream, MimeFormat.Default, persistent);
		}

		/// <summary>
		/// An event signifying the beginning of a new <see cref="MimeMessage"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the beginning of a new <see cref="MimeMessage"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeMessageBeginEventArgs> MimeMessageBegin;

		/// <summary>
		/// Invoked when the parser begins parsing a <see cref="MimeMessage"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser begins parsing a <see cref="MimeMessage"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeMessageBegin (MimeMessageBeginEventArgs args)
		{
			MimeMessageBegin?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the end of a <see cref="MimeMessage"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the end of a <see cref="MimeMessage"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeMessageEndEventArgs> MimeMessageEnd;

		/// <summary>
		/// Invoked when the parser has completed parsing a <see cref="MimeMessage"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser has completed parsing a <see cref="MimeMessage"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeMessageEnd (MimeMessageEndEventArgs args)
		{
			MimeMessageEnd?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the beginning of a new <see cref="MimeEntity"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the beginning of a new <see cref="MimeEntity"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeEntityBeginEventArgs> MimeEntityBegin;

		/// <summary>
		/// Invoked when the parser begins parsing a <see cref="MimeEntity"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser begins parsing a <see cref="MimeEntity"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeEntityBegin (MimeEntityBeginEventArgs args)
		{
			MimeEntityBegin?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the end of a <see cref="MimeEntity"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the end of a <see cref="MimeEntity"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeEntityEndEventArgs> MimeEntityEnd;

		/// <summary>
		/// Invoked when the parser has completed parsing a <see cref="MimeEntity"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser has completed parsing a <see cref="MimeEntity"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeEntityEnd (MimeEntityEndEventArgs args)
		{
			MimeEntityEnd?.Invoke (this, args);
		}

#if DEBUG_PARSER
		static string ConvertToCString (byte[] buffer, int startIndex, int length)
		{
			var cstr = new StringBuilder ();
			cstr.AppendCString (buffer, startIndex, length);
			return cstr.ToString ();
		}
#endif

		static int NextAllocSize (int need)
		{
			return (need + 63) & ~63;
		}

		bool AlignReadAheadBuffer (int atleast, int save, out int left, out int start, out int end)
		{
			left = inputEnd - inputIndex;
			start = inputStart;
			end = inputEnd;

			if (left >= atleast || eos)
				return false;

			left += save;

			if (left > 0) {
				int index = inputIndex - save;

				// attempt to align the end of the remaining input with ReadAheadSize
				if (index >= start) {
					start -= Math.Min (ReadAheadSize, left);
					Buffer.BlockCopy (input, index, input, start, left);
					index = start;
					start += left;
				} else if (index > 0) {
					int shift = Math.Min (index, end - start);
					Buffer.BlockCopy (input, index, input, index - shift, left);
					index -= shift;
					start = index + left;
				} else {
					// we can't shift...
					start = end;
				}

				inputIndex = index + save;
				inputEnd = start;
			} else {
				inputIndex = start;
				inputEnd = start;
			}

			end = input.Length - PadSize;

			return true;
		}

		int ReadAhead (int atleast, int save, CancellationToken cancellationToken)
		{
			int nread, left, start, end;

			if (!AlignReadAheadBuffer (atleast, save, out left, out start, out end))
				return left;

			// use the cancellable stream interface if available...
			var cancellable = stream as ICancellableStream;
			if (cancellable != null) {
				nread = cancellable.Read (input, start, end - start, cancellationToken);
			} else {
				cancellationToken.ThrowIfCancellationRequested ();
				nread = stream.Read (input, start, end - start);
			}

			if (nread > 0) {
				inputEnd += nread;
				position += nread;
			} else {
				eos = true;
			}

			return inputEnd - inputIndex;
		}

		long GetOffset (int index)
		{
			if (position == -1)
				return -1;

			return position - (inputEnd - index);
		}

		long GetEndOffset (int index)
		{
			if (boundary != BoundaryType.Eos && index > 1 && input[index - 1] == (byte) '\n') {
				index--;

				if (index > 1 && input[index - 1] == (byte) '\r')
					index--;
			}

			return GetOffset (index);
		}

		int GetLineCount (int beginLineNumber, long beginOffset, long endOffset)
		{
			var lines = lineNumber - beginLineNumber;

			if (lineBeginOffset >= beginOffset && endOffset > lineBeginOffset)
				lines++;

			if (boundary != BoundaryType.Eos && endOffset == prevLineBeginOffset)
				lines--;

			return lines;
		}

		static unsafe bool CStringsEqual (byte* str1, byte* str2, int length)
		{
			byte* se = str1 + length;
			byte* s1 = str1;
			byte* s2 = str2;

			while (s1 < se) {
				if (*s1++ != *s2++)
					return false;
			}

			return true;
		}

		unsafe void StepByteOrderMark (byte* inbuf, ref int bomIndex)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			while (inptr < inend && bomIndex < UTF8ByteOrderMark.Length && *inptr == UTF8ByteOrderMark[bomIndex]) {
				bomIndex++;
				inptr++;
			}

			inputIndex = (int) (inptr - inbuf);
		}

		unsafe bool StepByteOrderMark (byte* inbuf, CancellationToken cancellationToken)
		{
			int bomIndex = 0;

			do {
				var available = ReadAhead (ReadAheadSize, 0, cancellationToken);

				if (available <= 0) {
					// failed to read any data... EOF
					inputIndex = inputEnd;
					return false;
				}

				StepByteOrderMark (inbuf, ref bomIndex);
			} while (inputIndex == inputEnd);

			return bomIndex == 0 || bomIndex == UTF8ByteOrderMark.Length;
		}

		static unsafe bool IsMboxMarker (byte* text, bool allowMunged = false)
		{
#if COMPARE_QWORD
			const ulong FromMask = 0x000000FFFFFFFFFF;
			const ulong From     = 0x000000206D6F7246;
			ulong* qword = (ulong*) text;

			return (*qword & FromMask) == From;
#else
			byte* inptr = text;

			if (allowMunged && *inptr == (byte) '>')
				inptr++;

			return *inptr++ == (byte) 'F' && *inptr++ == (byte) 'r' && *inptr++ == (byte) 'o' && *inptr++ == (byte) 'm' && *inptr == (byte) ' ';
#endif
		}

		unsafe bool StepMboxMarker (byte *inbuf, ref int left)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			*inend = (byte) '\n';

			while (inptr < inend) {
				int startIndex = inputIndex;
				byte* start = inptr;

				// scan for the end of the line
				while (*inptr != (byte) '\n')
					inptr++;

				var markerLength = (int) (inptr - start);

				if (inptr > start && *(inptr - 1) == (byte) '\r')
					markerLength--;

				// consume the '\n'
				inptr++;

				var lineLength = (int) (inptr - start);

				if (inptr >= inend) {
					// we don't have enough input data
					left = lineLength;
					return false;
				}

				inputIndex += lineLength;
				prevLineBeginOffset = lineBeginOffset;
				lineBeginOffset = GetOffset (inputIndex);
				lineNumber++;

				if (markerLength >= 5 && IsMboxMarker (start)) {
					mboxMarkerOffset = GetOffset (startIndex);
					mboxMarkerLength = markerLength;

					if (mboxMarkerBuffer.Length < mboxMarkerLength)
						Array.Resize (ref mboxMarkerBuffer, mboxMarkerLength);

					Buffer.BlockCopy (input, startIndex, mboxMarkerBuffer, 0, markerLength);

					return true;
				}
			}

			left = 0;

			return false;
		}

		unsafe void StepMboxMarker (byte* inbuf, CancellationToken cancellationToken)
		{
			bool complete;
			int left = 0;

			mboxMarkerLength = 0;

			do {
				var available = ReadAhead (Math.Max (ReadAheadSize, left), 0, cancellationToken);

				if (available <= left) {
					// failed to find a From line; EOF reached
					state = MimeParserState.Error;
					inputIndex = inputEnd;
					return;
				}

				complete = StepMboxMarker (inbuf, ref left);
			} while (!complete);

			state = MimeParserState.MessageHeaders;
		}

		void AppendRawHeaderData (int startIndex, int length)
		{
			int left = headerBuffer.Length - headerIndex;

			if (left < length)
				Array.Resize (ref headerBuffer, NextAllocSize (headerIndex + length));

			Buffer.BlockCopy (input, startIndex, headerBuffer, headerIndex, length);
			headerIndex += length;
		}

		void ResetRawHeaderData ()
		{
			preHeaderLength = 0;
			headerIndex = 0;
		}

		unsafe void ParseAndAppendHeader ()
		{
			if (headerIndex == 0)
				return;

			fixed (byte* buf = headerBuffer) {
				if (Header.TryParse (options, buf, headerIndex, false, out var header)) {
					header.Offset = headerOffset;
					headers.Add (header);
					headerIndex = 0;
				}
			}
		}

		static bool IsControl (byte c)
		{
			return c.IsCtrl ();
		}

		static bool IsBlank (byte c)
		{
			return c.IsBlank ();
		}

		static unsafe bool IsEoln (byte *text)
		{
			if (*text == (byte) '\r')
				text++;

			return *text == (byte) '\n';
		}

		unsafe bool StepHeaders (byte* inbuf, ref bool scanningFieldName, ref bool checkFolded, ref bool midline,
		                         ref bool blank, ref bool valid, ref int left)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			bool needInput = false;
			long length;
			bool eoln;

			*inend = (byte) '\n';

			while (inptr < inend) {
				byte* start = inptr;

				// if we are scanning a new line, check for a folded header
				if (!midline && checkFolded && !IsBlank (*inptr)) {
					ParseAndAppendHeader ();

					headerOffset = GetOffset ((int) (inptr - inbuf));
					scanningFieldName = true;
					checkFolded = false;
					blank = false;
					valid = true;
				}

				eoln = IsEoln (inptr);
				if (scanningFieldName && !eoln) {
					// scan and validate the field name
					if (*inptr != (byte) ':') {
						*inend = (byte) ':';

						while (*inptr != (byte) ':') {
							// Blank spaces are allowed between the field name and
							// the ':', but field names themselves are not allowed
							// to contain spaces.
							if (IsBlank (*inptr)) {
								blank = true;
							} else if (blank || IsControl (*inptr)) {
								valid = false;
								break;
							}

							inptr++;
						}

						if (inptr == inend) {
							// we don't have enough input data; restore state back to the beginning of the line
							left = (int) (inend - start);
							inputIndex = (int) (start - inbuf);
							needInput = true;
							break;
						}

						*inend = (byte) '\n';
					} else {
						valid = false;
					}

					if (!valid) {
						length = inptr - start;

						if (format == MimeFormat.Mbox && inputIndex >= contentEnd && length >= 5 && IsMboxMarker (start)) {
							// we've found the start of the next message...
							inputIndex = (int) (start - inbuf);
							state = MimeParserState.Complete;
							headerIndex = 0;
							return false;
						}

						if (headers.Count == 0) {
							if (state == MimeParserState.MessageHeaders) {
								// ignore From-lines that might appear at the start of a message
								if (toplevel && (length < 5 || !IsMboxMarker (start, true))) {
									// not a From-line...
									inputIndex = (int) (start - inbuf);
									state = MimeParserState.Error;
									headerIndex = 0;
									return false;
								}
							} else if (toplevel && state == MimeParserState.Headers) {
								inputIndex = (int) (start - inbuf);
								state = MimeParserState.Error;
								headerIndex = 0;
								return false;
							}
						}
					}
				}

				scanningFieldName = false;

				while (*inptr != (byte) '\n')
					inptr++;

				if (inptr == inend) {
					// we didn't manage to slurp up a full line, save what we have and refill our input buffer
					length = inptr - start;

					if (inptr > start) {
						// Note: if the last byte we got was a '\r', rewind a byte
						inptr--;
						if (*inptr == (byte) '\r')
							length--;
						else
							inptr++;
					}

					if (length > 0) {
						AppendRawHeaderData ((int) (start - inbuf), (int) length);
						midline = true;
					}

					inputIndex = (int) (inptr - inbuf);
					left = (int) (inend - inptr);
					needInput = true;
					break;
				}

				prevLineBeginOffset = lineBeginOffset;
				lineBeginOffset = GetOffset ((int) (inptr - inbuf) + 1);
				lineNumber++;

				// check to see if we've reached the end of the headers
				if (!midline && IsEoln (start)) {
					inputIndex = (int) (inptr - inbuf) + 1;
					state = MimeParserState.Content;
					ParseAndAppendHeader ();
					headerIndex = 0;
					return false;
				}

				length = (inptr + 1) - start;

				if ((boundary = CheckBoundary ((int) (start - inbuf), start, (int) length)) != BoundaryType.None) {
					inputIndex = (int) (start - inbuf);
					state = MimeParserState.Boundary;
					headerIndex = 0;
					return false;
				}

				if (!valid && headers.Count == 0) {
					if (length > 0 && preHeaderLength == 0) {
						if (inptr[-1] == (byte) '\r')
							length--;
						length--;

						preHeaderLength = (int) length;

						if (preHeaderLength > preHeaderBuffer.Length)
							Array.Resize (ref preHeaderBuffer, NextAllocSize (preHeaderLength));

						Buffer.BlockCopy (input, (int) (start - inbuf), preHeaderBuffer, 0, preHeaderLength);
					}
					scanningFieldName = true;
					checkFolded = false;
					blank = false;
					valid = true;
				} else {
					AppendRawHeaderData ((int) (start - inbuf), (int) length);
					checkFolded = true;
				}

				midline = false;
				inptr++;
			}

			if (!needInput) {
				inputIndex = (int) (inptr - inbuf);
				left = (int) (inend - inptr);
			}

			return true;
		}

		unsafe void StepHeaders (byte* inbuf, CancellationToken cancellationToken)
		{
			bool scanningFieldName = true;
			bool checkFolded = false;
			bool midline = false;
			bool blank = false;
			bool valid = true;
			int left = 0;

			headerBlockBegin = GetOffset (inputIndex);
			boundary = BoundaryType.None;
			ResetRawHeaderData ();
			headers.Clear ();

			ReadAhead (ReadAheadSize, 0, cancellationToken);

			do {
				if (!StepHeaders (inbuf, ref scanningFieldName, ref checkFolded, ref midline, ref blank, ref valid, ref left))
					break;

				var available = ReadAhead (left + 1, 0, cancellationToken);

				if (available == left) {
					// EOF reached before we reached the end of the headers...
					if (scanningFieldName && left > 0) {
						// EOF reached right in the middle of a header field name. Throw an error.
						//
						// See private email from Feb 8, 2018 which contained a sample message w/o
						// any breaks between the header and message body. The file also did not
						// end with a newline sequence.
						state = MimeParserState.Error;
					} else {
						// EOF reached somewhere in the middle of the value.
						//
						// Append whatever data we've got left and pretend we found the end
						// of the header value (and the header block).
						//
						// For more details, see https://github.com/jstedfast/MimeKit/pull/51
						// and https://github.com/jstedfast/MimeKit/issues/348
						if (left > 0) {
							AppendRawHeaderData (inputIndex, left);
							inputIndex = inputEnd;
						}

						ParseAndAppendHeader ();

						state = MimeParserState.Content;
					}
					break;
				}
			} while (true);

			headerBlockEnd = GetOffset (inputIndex);
		}

		unsafe bool SkipLine (byte* inbuf, bool consumeNewLine)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			*inend = (byte) '\n';

			while (*inptr != (byte) '\n')
				inptr++;

			if (inptr < inend) {
				inputIndex = (int) (inptr - inbuf);

				if (consumeNewLine) {
					inputIndex++;
					lineNumber++;
					prevLineBeginOffset = lineBeginOffset;
					lineBeginOffset = GetOffset (inputIndex);
				} else if (*(inptr - 1) == (byte) '\r') {
					inputIndex--;
				}

				return true;
			}

			inputIndex = inputEnd;

			return false;
		}

		unsafe bool SkipLine (byte* inbuf, bool consumeNewLine, CancellationToken cancellationToken)
		{
			do {
				if (SkipLine (inbuf, consumeNewLine))
					return true;

				if (ReadAhead (ReadAheadSize, 1, cancellationToken) <= 0)
					return false;
			} while (true);
		}

		unsafe MimeParserState Step (byte* inbuf, CancellationToken cancellationToken)
		{
			switch (state) {
			case MimeParserState.Initialized:
				if (!StepByteOrderMark (inbuf, cancellationToken)) {
					state = MimeParserState.Eos;
					break;
				}

				state = format == MimeFormat.Mbox ? MimeParserState.MboxMarker : MimeParserState.MessageHeaders;
				break;
			case MimeParserState.MboxMarker:
				StepMboxMarker (inbuf, cancellationToken);
				break;
			case MimeParserState.MessageHeaders:
			case MimeParserState.Headers:
				StepHeaders (inbuf, cancellationToken);
				toplevel = false;
				break;
			}

			return state;
		}

		ContentType GetContentType (ContentType parent)
		{
			for (int i = 0; i < headers.Count; i++) {
				if (!headers[i].Field.Equals ("Content-Type", StringComparison.OrdinalIgnoreCase))
					continue;

				var rawValue = headers[i].RawValue;
				int index = 0;

				if (!ContentType.TryParse (options, rawValue, ref index, rawValue.Length, false, out var type) && type == null) {
					// if 'type' is null, then it means that even the mime-type was unintelligible
					type = new ContentType ("application", "octet-stream");

					// attempt to recover any parameters...
					while (index < rawValue.Length && rawValue[index] != ';')
						index++;

					if (++index < rawValue.Length) {
						if (ParameterList.TryParse (options, rawValue, ref index, rawValue.Length, false, out var parameters))
							type.Parameters = parameters;
					}
				}

				return type;
			}

			if (parent == null || !parent.IsMimeType ("multipart", "digest"))
				return new ContentType ("text", "plain");

			return new ContentType ("message", "rfc822");
		}

		unsafe bool IsPossibleBoundary (byte* text, int length)
		{
			if (length < 2)
				return false;

			if (*text == (byte) '-' && *(text + 1) == (byte) '-')
				return true;

			if (format == MimeFormat.Mbox && length >= 5 && IsMboxMarker (text))
				return true;

			return false;
		}

		static unsafe bool IsBoundary (byte* text, int length, byte[] boundary, int boundaryLength)
		{
			if (boundaryLength > length)
				return false;

			fixed (byte* boundaryptr = boundary) {
				// make sure that the text matches the boundary
				if (!CStringsEqual (text, boundaryptr, boundaryLength))
					return false;

				// if this is an mbox marker, we're done
				if (IsMboxMarker (text))
					return true;

				// the boundary may optionally be followed by lwsp
				byte* inptr = text + boundaryLength;
				byte* inend = text + length;

				while (inptr < inend) {
					if (!(*inptr).IsWhitespace ())
						return false;

					inptr++;
				}
			}

			return true;
		}

		unsafe BoundaryType CheckBoundary (int startIndex, byte* start, int length)
		{
			int count = bounds.Count;

			if (!IsPossibleBoundary (start, length))
				return BoundaryType.None;

			if (contentEnd > 0) {
				// We'll need to special-case checking for the mbox From-marker when respecting Content-Length
				count--;
			}

			for (int i = 0; i < count; i++) {
				var boundary = bounds[i];

				if (IsBoundary (start, length, boundary.Marker, boundary.FinalLength))
					return i == 0 ? BoundaryType.ImmediateEndBoundary : BoundaryType.ParentEndBoundary;

				if (IsBoundary (start, length, boundary.Marker, boundary.Length))
					return i == 0 ? BoundaryType.ImmediateBoundary : BoundaryType.ParentBoundary;
			}

			if (contentEnd > 0) {
				// now it is time to check the mbox From-marker for the Content-Length case
				long curOffset = GetOffset (startIndex);
				var boundary = bounds[count];

				if (curOffset >= contentEnd && IsBoundary (start, length, boundary.Marker, boundary.Length))
					return BoundaryType.ImmediateEndBoundary;
			}

			return BoundaryType.None;
		}

		unsafe bool FoundImmediateBoundary (byte* inbuf, bool final)
		{
			int boundaryLength = final ? bounds[0].FinalLength : bounds[0].Length;
			byte* start = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			byte *inptr = start;

			*inend = (byte) '\n';

			while (*inptr != (byte) '\n')
				inptr++;

			return IsBoundary (start, (int) (inptr - start), bounds[0].Marker, boundaryLength);
		}

		int GetMaxBoundaryLength ()
		{
			return bounds.Count > 0 ? bounds[0].MaxLength + 2 : 0;
		}

		unsafe void ScanContent (byte* inbuf, ref int contentIndex, ref int nleft, ref bool midline, ref bool[] formats)
		{
			int length = inputEnd - inputIndex;
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			int startIndex = inputIndex;

			contentIndex = inputIndex;

			if (midline && length == nleft)
				boundary = BoundaryType.Eos;

			*inend = (byte) '\n';

			while (inptr < inend) {
				// Note: we can always depend on byte[] arrays being 4-byte aligned on 32bit and 64bit architectures
				int alignment = (startIndex + 3) & ~3;
				byte* aligned = inbuf + alignment;
				byte* start = inptr;
				byte c = *aligned;
				uint mask;

				*aligned = (byte) '\n';
				while (*inptr != (byte) '\n')
					inptr++;
				*aligned = c;

				if (inptr == aligned && c != (byte) '\n') {
					// -funroll-loops, yippee ki-yay.
					uint* dword = (uint*) inptr;

					do {
						mask = *dword++ ^ 0x0A0A0A0A;
						mask = ((mask - 0x01010101) & (~mask & 0x80808080));
					} while (mask == 0);

					inptr = (byte*) (dword - 1);
					while (*inptr != (byte) '\n')
						inptr++;
				}

				length = (int) (inptr - start);

				if (inptr < inend) {
					if ((boundary = CheckBoundary (startIndex, start, length)) != BoundaryType.None)
						break;

					if (length > 0 && *(inptr - 1) == (byte) '\r')
						formats[(int) NewLineFormat.Dos] = true;
					else
						formats[(int) NewLineFormat.Unix] = true;

					lineNumber++;
					length++;
					inptr++;

					prevLineBeginOffset = lineBeginOffset;
					lineBeginOffset = GetOffset ((int) (inptr - inbuf));
				} else {
					// didn't find the end of the line...
					midline = true;

					if (boundary == BoundaryType.None) {
						// not enough to tell if we found a boundary
						break;
					}

					if ((boundary = CheckBoundary (startIndex, start, length)) != BoundaryType.None)
						break;
				}

				startIndex += length;
			}

			inputIndex = startIndex;
		}

		class ScanContentResult
		{
			public readonly NewLineFormat? Format;
			public readonly bool IsEmpty;

			public ScanContentResult (bool[] formats, bool isEmpty)
			{
				if (formats[(int) NewLineFormat.Unix] && formats[(int) NewLineFormat.Dos])
					Format = NewLineFormat.Mixed;
				else if (formats[(int) NewLineFormat.Unix])
					Format = NewLineFormat.Unix;
				else if (formats[(int) NewLineFormat.Dos])
					Format = NewLineFormat.Dos;
				else
					Format = null;
				IsEmpty = isEmpty;
			}
		}

		unsafe ScanContentResult ScanContent (byte* inbuf, Stream content, bool trimNewLine, CancellationToken cancellationToken)
		{
			int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());
			int contentIndex = inputIndex;
			var formats = new bool[2];
			bool midline = false;
			int nleft;

			do {
				if (contentIndex < inputIndex)
					content.Write (input, contentIndex, inputIndex - contentIndex);

				nleft = inputEnd - inputIndex;
				if (ReadAhead (atleast, 2, cancellationToken) <= 0) {
					boundary = BoundaryType.Eos;
					contentIndex = inputIndex;
					break;
				}

				ScanContent (inbuf, ref contentIndex, ref nleft, ref midline, ref formats);
			} while (boundary == BoundaryType.None);

			if (contentIndex < inputIndex)
				content.Write (input, contentIndex, inputIndex - contentIndex);

			var isEmpty = content.Length == 0;

			if (boundary != BoundaryType.Eos && trimNewLine) {
				// the last \r\n belongs to the boundary
				if (content.Length > 0) {
					if (input[inputIndex - 2] == (byte) '\r')
						content.SetLength (content.Length - 2);
					else
						content.SetLength (content.Length - 1);
				}
			}

			return new ScanContentResult (formats, isEmpty);
		}

		unsafe void ConstructMimePart (MimePart part, MimeEntityEndEventArgs args, byte* inbuf, CancellationToken cancellationToken)
		{
			long endOffset, beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			ScanContentResult result;
			Stream content;

			if (persistent) {
				using (var measured = new MeasuringStream ()) {
					result = ScanContent (inbuf, measured, true, cancellationToken);
					endOffset = beginOffset + measured.Length;
				}

				content = new BoundStream (stream, beginOffset, endOffset, true);
			} else {
				content = new MemoryBlockStream ();

				try {
					result = ScanContent (inbuf, content, true, cancellationToken);
					content.Seek (0, SeekOrigin.Begin);
				} catch {
					content.Dispose ();
					throw;
				}

				endOffset = beginOffset + content.Length;
			}

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			if (!result.IsEmpty)
				part.Content = new MimeContent (content, part.ContentTransferEncoding) { NewLineFormat = result.Format };
			else
				content.Dispose ();
		}

		unsafe void ConstructMessagePart (MessagePart rfc822, MimeEntityEndEventArgs args, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;

			if (bounds.Count > 0) {
				int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());

				if (ReadAhead (atleast, 0, cancellationToken) <= 0) {
					boundary = BoundaryType.Eos;
					return;
				}

				byte* start = inbuf + inputIndex;
				byte* inend = inbuf + inputEnd;
				byte* inptr = start;

				*inend = (byte) '\n';

				while (*inptr != (byte) '\n')
					inptr++;

				boundary = CheckBoundary (inputIndex, start, (int) (inptr - start));

				switch (boundary) {
				case BoundaryType.ImmediateEndBoundary:
				case BoundaryType.ImmediateBoundary:
				case BoundaryType.ParentBoundary:
					return;
				case BoundaryType.ParentEndBoundary:
					// ignore "From " boundaries, broken mailers tend to include these...
					if (!IsMboxMarker (start)) {
						return;
					}
					break;
				}
			}

			// parse the headers...
			state = MimeParserState.MessageHeaders;
			if (Step (inbuf, cancellationToken) == MimeParserState.Error) {
				// Note: this either means that StepHeaders() found the end of the stream
				// or an invalid header field name at the start of the message headers,
				// which likely means that this is not a valid MIME stream?
				boundary = BoundaryType.Eos;
				return;
			}

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message, rfc822) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (preHeaderBuffer.Length > 0) {
				message.MboxMarker = new byte[preHeaderLength];
				Buffer.BlockCopy (preHeaderBuffer, 0, message.MboxMarker, 0, preHeaderLength);
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, depth);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart)
				ConstructMultipart ((Multipart) entity, entityArgs, inbuf, depth + 1, cancellationToken);
			else if (entity is MessagePart)
				ConstructMessagePart ((MessagePart) entity, entityArgs, inbuf, depth + 1, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			rfc822.Message = message;

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min(entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
		}

		unsafe void MultipartScanPreamble (Multipart multipart, byte* inbuf, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartPreambleBegin (multipart, offset);
				ScanContent (inbuf, memory, false, cancellationToken);
				multipart.RawPreamble = memory.ToArray ();
				//OnMultipartPreambleEnd (multipart, offset + memory.Length);
			}
		}

		unsafe void MultipartScanEpilogue (Multipart multipart, byte* inbuf, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartEpilogueBegin (multipart, offset);
				var result = ScanContent (inbuf, memory, true, cancellationToken);
				multipart.RawEpilogue = result.IsEmpty ? null : memory.ToArray ();
				//OnMultipartEpilogueEnd (multipart, offset + memory.Length);
			}
		}

		unsafe void MultipartScanSubparts (Multipart multipart, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			//var beginOffset = GetOffset (inputIndex);

			do {
				//OnMultipartBoundaryBegin (multipart, beginOffset);

				// skip over the boundary marker
				if (!SkipLine (inbuf, true, cancellationToken)) {
					//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));
					boundary = BoundaryType.Eos;
					return;
				}

				//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));

				var beginLineNumber = lineNumber;

				// parse the headers
				state = MimeParserState.Headers;
				if (Step (inbuf, cancellationToken) == MimeParserState.Error) {
					boundary = BoundaryType.Eos;
					return;
				}

				if (state == MimeParserState.Boundary) {
					if (headers.Count == 0) {
						if (boundary == BoundaryType.ImmediateBoundary) {
							//beginOffset = GetOffset (inputIndex);
							continue;
						}
						return;
					}

					// This part has no content, but that will be handled in ConstructMultipart()
					// or ConstructMimePart().
				}

				//if (state == ParserState.Complete && headers.Count == 0)
				//	return BoundaryType.EndBoundary;

				var type = GetContentType (multipart.ContentType);
				var entity = options.CreateEntity (type, headers, false, depth);
				var entityArgs = new MimeEntityEndEventArgs (entity, multipart) {
					HeadersEndOffset = headerBlockEnd,
					BeginOffset = headerBlockBegin,
					LineNumber = beginLineNumber
				};

				OnMimeEntityBegin (entityArgs);

				if (entity is Multipart)
					ConstructMultipart ((Multipart) entity, entityArgs, inbuf, depth + 1, cancellationToken);
				else if (entity is MessagePart)
					ConstructMessagePart ((MessagePart) entity, entityArgs, inbuf, depth + 1, cancellationToken);
				else
					ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

				var endOffset = GetEndOffset (inputIndex);
				entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
				entityArgs.EndOffset = endOffset;

				OnMimeEntityEnd (entityArgs);

				//beginOffset = endOffset;
				multipart.Add (entity);
			} while (boundary == BoundaryType.ImmediateBoundary);
		}

		void PushBoundary (string boundary)
		{
			if (bounds.Count > 0)
				bounds.Insert (0, new Boundary (boundary, bounds[0].MaxLength));
			else
				bounds.Add (new Boundary (boundary, 0));
		}

		void PopBoundary ()
		{
			bounds.RemoveAt (0);
		}

		unsafe void ConstructMultipart (Multipart multipart, MimeEntityEndEventArgs args, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			var marker = multipart.Boundary;
			long endOffset;

			if (marker == null) {
#if DEBUG
				Debug.WriteLine ("Multipart without a boundary encountered!");
#endif

				// Note: this will scan all content into the preamble...
				MultipartScanPreamble (multipart, inbuf, cancellationToken);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			PushBoundary (marker);

			MultipartScanPreamble (multipart, inbuf, cancellationToken);
			if (boundary == BoundaryType.ImmediateBoundary)
				MultipartScanSubparts (multipart, inbuf, depth, cancellationToken);

			if (boundary == BoundaryType.ImmediateEndBoundary) {
				//OnMultipartEndBoundaryBegin (multipart, GetEndOffset (inputIndex));

				// consume the end boundary and read the epilogue (if there is one)
				multipart.WriteEndBoundary = true;
				SkipLine (inbuf, false, cancellationToken);
				PopBoundary ();

				//OnMultipartEndBoundaryEnd (multipart, GetOffset (inputIndex));

				MultipartScanEpilogue (multipart, inbuf, cancellationToken);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			endOffset = GetEndOffset (inputIndex);
			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			multipart.WriteEndBoundary = false;

			// We either found the end of the stream or we found a parent's boundary
			PopBoundary ();

			if (boundary == BoundaryType.ParentEndBoundary && FoundImmediateBoundary (inbuf, true))
				boundary = BoundaryType.ImmediateEndBoundary;
			else if (boundary == BoundaryType.ParentBoundary && FoundImmediateBoundary (inbuf, false))
				boundary = BoundaryType.ImmediateBoundary;
		}

		unsafe HeaderList ParseHeaders (byte* inbuf, CancellationToken cancellationToken)
		{
			state = MimeParserState.Headers;
			if (Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse headers.");

			state = eos ? MimeParserState.Eos : MimeParserState.Complete;

			var parsed = new HeaderList (options);
			foreach (var header in headers)
				parsed.Add (header);

			return parsed;
		}

		/// <summary>
		/// Parses a list of headers from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a list of headers from the stream.
		/// </remarks>
		/// <returns>The parsed list of headers.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the headers.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public HeaderList ParseHeaders (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseHeaders (inbuf, cancellationToken);
				}
			}
		}

		unsafe MimeEntity ParseEntity (byte* inbuf, CancellationToken cancellationToken)
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			var beginLineNumber = lineNumber;

			state = MimeParserState.Headers;
			toplevel = true;

			if (Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse entity headers.");

			var type = GetContentType (null);

			// Note: we pass 'false' as the 'toplevel' argument here because
			// we want the entity to consume all of the headers.
			var entity = options.CreateEntity (type, headers, false, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			if (entity is Multipart)
				ConstructMultipart ((Multipart) entity, entityArgs, inbuf, 0, cancellationToken);
			else if (entity is MessagePart)
				ConstructMessagePart ((MessagePart) entity, entityArgs, inbuf, 0, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			var endOffset = GetEndOffset (inputIndex);
			entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos)
				state = MimeParserState.Complete;
			else
				state = MimeParserState.Eos;

			OnMimeEntityEnd (entityArgs);

			return entity;
		}

		/// <summary>
		/// Parses an entity from the stream.
		/// </summary>
		/// <remarks>
		/// Parses an entity from the stream.
		/// </remarks>
		/// <returns>The parsed entity.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the entity.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public MimeEntity ParseEntity (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseEntity (inbuf, cancellationToken);
				}
			}
		}

		unsafe MimeMessage ParseMessage (byte* inbuf, CancellationToken cancellationToken)
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			// scan the from-line if we are parsing an mbox
			while (state != MimeParserState.MessageHeaders) {
				switch (Step (inbuf, cancellationToken)) {
				case MimeParserState.Error:
					throw new FormatException ("Failed to find mbox From marker.");
				case MimeParserState.Eos:
					throw new FormatException ("End of stream.");
				}
			}

			toplevel = true;

			// parse the headers
			var beginLineNumber = lineNumber;
			if (state < MimeParserState.Content && Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse message headers.");

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			contentEnd = 0;
			if (format == MimeFormat.Mbox && options.RespectContentLength) {
				for (int i = 0; i < headers.Count; i++) {
					if (headers[i].Id != HeaderId.ContentLength)
						continue;

					var value = headers[i].RawValue;
					int index = 0;

					if (!ParseUtils.SkipWhiteSpace (value, ref index, value.Length))
						continue;

					if (!ParseUtils.TryParseInt32 (value, ref index, value.Length, out int length))
						continue;

					contentEnd = GetOffset (inputIndex) + length;
					break;
				}
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart multipart)
				ConstructMultipart (multipart, entityArgs, inbuf, 0, cancellationToken);
			else if (entity is MessagePart rfc822)
				ConstructMessagePart (rfc822, entityArgs, inbuf, 0, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos) {
				if (format == MimeFormat.Mbox)
					state = MimeParserState.MboxMarker;
				else
					state = MimeParserState.Complete;
			} else {
				state = MimeParserState.Eos;
			}

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			return message;
		}

		/// <summary>
		/// Parses a message from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a message from the stream.
		/// </remarks>
		/// <returns>The parsed message.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the message.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public MimeMessage ParseMessage (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseMessage (inbuf, cancellationToken);
				}
			}
		}

		#region IEnumerable implementation

		/// <summary>
		/// Enumerates the messages in the stream.
		/// </summary>
		/// <remarks>
		/// This is mostly useful when parsing mbox-formatted streams.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		public IEnumerator<MimeMessage> GetEnumerator ()
		{
			while (!IsEndOfStream)
				yield return ParseMessage ();

			yield break;
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Enumerates the messages in the stream.
		/// </summary>
		/// <remarks>
		/// This is mostly useful when parsing mbox-formatted streams.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator ()
		{
			return GetEnumerator ();
		}

		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;

using MimeKit.IO;
using MimeKit.Utils;

namespace MimeKit {
	enum BoundaryType
	{
		None,
		Eos,
		ImmediateBoundary,
		ImmediateEndBoundary,
		ParentBoundary,
		ParentEndBoundary,
	}

	class Boundary
	{
		public static readonly byte[] MboxFrom = Encoding.ASCII.GetBytes ("From ");

		public byte[] Marker { get; private set; }
		public int FinalLength { get { return Marker.Length; } }
		public int Length { get; private set; }
		public int MaxLength { get; private set; }

		public Boundary (string boundary, int currentMaxLength)
		{
			Marker = Encoding.UTF8.GetBytes ("--" + boundary + "--");
			Length = Marker.Length - 2;

			MaxLength = Math.Max (currentMaxLength, Marker.Length);
		}

		Boundary ()
		{
		}

		public static Boundary CreateMboxBoundary ()
		{
			var boundary = new Boundary ();
			boundary.Marker = MboxFrom;
			boundary.MaxLength = 5;
			boundary.Length = 5;
			return boundary;
		}

#if DEBUG_PARSER
		public override string ToString ()
		{
			return Encoding.UTF8.GetString (Marker, 0, Marker.Length);
		}
#endif
	}

	enum MimeParserState : sbyte
	{
		Error = -1,
		Initialized,
		MboxMarker,
		MessageHeaders,
		Headers,
		Content,
		Boundary,
		Complete,
		Eos
	}

	/// <summary>
	/// A MIME message and entity parser.
	/// </summary>
	/// <remarks>
	/// A MIME parser is used to parse <see cref="MimeMessage"/> and
	/// <see cref="MimeEntity"/> objects from arbitrary streams.
	/// </remarks>
	public partial class MimeParser : IEnumerable<MimeMessage>
	{
		static readonly byte[] UTF8ByteOrderMark = { 0xEF, 0xBB, 0xBF };
		const int ReadAheadSize = 128;
		const int BlockSize = 4096;
		const int PadSize = 4;

		// I/O buffering
		readonly byte[] input = new byte[ReadAheadSize + BlockSize + PadSize];
		const int inputStart = ReadAheadSize;
		int inputIndex = ReadAheadSize;
		int inputEnd = ReadAheadSize;

		// mbox From-line state
		byte[] mboxMarkerBuffer;
		long mboxMarkerOffset;
		int mboxMarkerLength;

		// message/rfc822 mbox markers (shouldn't exist, but sometimes do)
		byte[] preHeaderBuffer = new byte[128];
		int preHeaderLength;

		// header buffer
		byte[] headerBuffer = new byte[512];
		long headerOffset;
		int headerIndex;

		readonly List<Boundary> bounds = new List<Boundary> ();
		readonly List<Header> headers = new List<Header> ();

		MimeParserState state;
		BoundaryType boundary;
		MimeFormat format;
		bool persistent;
		bool toplevel;
		bool eos;

		ParserOptions options; // FIXME: might be better if devs passed ParserOptions into the Parse*() methods rather than .ctor and/or SetStream()
		long headerBlockBegin;
		long headerBlockEnd;
		long contentEnd;

		long prevLineBeginOffset;
		long lineBeginOffset;
		int lineNumber;

		Stream stream;
		long position;

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public MimeParser (Stream stream, MimeFormat format, bool persistent = false) : this (ParserOptions.Default, stream, format, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public MimeParser (Stream stream, bool persistent = false) : this (ParserOptions.Default, stream, MimeFormat.Default, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public MimeParser (ParserOptions options, Stream stream, bool persistent = false) : this (options, stream, MimeFormat.Default, persistent)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MimeParser"/> class.
		/// </summary>
		/// <remarks>
		/// <para>Creates a new <see cref="MimeParser"/> that will parse the specified stream.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public MimeParser (ParserOptions options, Stream stream, MimeFormat format, bool persistent = false)
		{
			SetStream (options, stream, format, persistent);
		}

		/// <summary>
		/// Gets a value indicating whether the parser has reached the end of the input stream.
		/// </summary>
		/// <remarks>
		/// Gets a value indicating whether the parser has reached the end of the input stream.
		/// </remarks>
		/// <value><c>true</c> if this parser has reached the end of the input stream;
		/// otherwise, <c>false</c>.</value>
		public bool IsEndOfStream {
			get { return state == MimeParserState.Eos; }
		}

		/// <summary>
		/// Gets the current position of the parser within the stream.
		/// </summary>
		/// <remarks>
		/// Gets the current position of the parser within the stream.
		/// </remarks>
		/// <value>The stream offset.</value>
		public long Position {
			get { return GetOffset (inputIndex); }
		}

		/// <summary>
		/// Gets the most recent mbox marker offset.
		/// </summary>
		/// <remarks>
		/// Gets the most recent mbox marker offset.
		/// </remarks>
		/// <value>The mbox marker offset.</value>
		public long MboxMarkerOffset {
			get { return mboxMarkerOffset; }
		}

		/// <summary>
		/// Gets the most recent mbox marker.
		/// </summary>
		/// <remarks>
		/// Gets the most recent mbox marker.
		/// </remarks>
		/// <value>The mbox marker.</value>
		public string MboxMarker {
			get { return Encoding.UTF8.GetString (mboxMarkerBuffer, 0, mboxMarkerLength); }
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public void SetStream (ParserOptions options, Stream stream, MimeFormat format, bool persistent = false)
		{
			if (options == null)
				throw new ArgumentNullException (nameof (options));

			if (stream == null)
				throw new ArgumentNullException (nameof (stream));

			this.persistent = persistent && stream.CanSeek;
			this.options = options.Clone ();
			this.format = format;
			this.stream = stream;

			inputIndex = inputStart;
			inputEnd = inputStart;

			mboxMarkerOffset = 0;
			mboxMarkerLength = 0;
			headerBlockBegin = 0;
			headerBlockEnd = 0;
			lineNumber = 1;
			contentEnd = 0;

			position = stream.CanSeek ? stream.Position : 0;
			prevLineBeginOffset = position;
			lineBeginOffset = position;
			preHeaderLength = 0;
			headers.Clear ();
			headerOffset = 0;
			headerIndex = 0;
			toplevel = false;
			eos = false;

			bounds.Clear ();
			if (format == MimeFormat.Mbox) {
				bounds.Add (Boundary.CreateMboxBoundary ());

				if (mboxMarkerBuffer == null)
					mboxMarkerBuffer = new byte[ReadAheadSize];
			}

			state = MimeParserState.Initialized;
			boundary = BoundaryType.None;
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="options">The parser options.</param>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		public void SetStream (ParserOptions options, Stream stream, bool persistent = false)
		{
			SetStream (options, stream, MimeFormat.Default, persistent);
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="format">The format of the stream.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public void SetStream (Stream stream, MimeFormat format, bool persistent = false)
		{
			SetStream (ParserOptions.Default, stream, format, persistent);
		}

		/// <summary>
		/// Sets the stream to parse.
		/// </summary>
		/// <remarks>
		/// <para>Sets the stream to parse.</para>
		/// <para>If <paramref name="persistent"/> is <c>true</c> and <paramref name="stream"/> is seekable, then
		/// the <see cref="MimeParser"/> will not copy the content of <see cref="MimePart"/>s into memory. Instead,
		/// it will use a <see cref="BoundStream"/> to reference a substream of <paramref name="stream"/>.
		/// This has the potential to not only save memory usage, but also improve <see cref="MimeParser"/>
		/// performance.</para>
		/// <para>It should be noted, however, that disposing <paramref name="stream"/> will make it impossible
		/// for <see cref="MimeContent"/> to read the content.</para>
		/// </remarks>
		/// <param name="stream">The stream to parse.</param>
		/// <param name="persistent"><c>true</c> if the stream is persistent; otherwise <c>false</c>.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="stream"/> is <c>null</c>.
		/// </exception>
		public void SetStream (Stream stream, bool persistent = false)
		{
			SetStream (ParserOptions.Default, stream, MimeFormat.Default, persistent);
		}

		/// <summary>
		/// An event signifying the beginning of a new <see cref="MimeMessage"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the beginning of a new <see cref="MimeMessage"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeMessageBeginEventArgs> MimeMessageBegin;

		/// <summary>
		/// Invoked when the parser begins parsing a <see cref="MimeMessage"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser begins parsing a <see cref="MimeMessage"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeMessageBegin (MimeMessageBeginEventArgs args)
		{
			MimeMessageBegin?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the end of a <see cref="MimeMessage"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the end of a <see cref="MimeMessage"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeMessageEndEventArgs> MimeMessageEnd;

		/// <summary>
		/// Invoked when the parser has completed parsing a <see cref="MimeMessage"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser has completed parsing a <see cref="MimeMessage"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeMessageEnd (MimeMessageEndEventArgs args)
		{
			MimeMessageEnd?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the beginning of a new <see cref="MimeEntity"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the beginning of a new <see cref="MimeEntity"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeEntityBeginEventArgs> MimeEntityBegin;

		/// <summary>
		/// Invoked when the parser begins parsing a <see cref="MimeEntity"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser begins parsing a <see cref="MimeEntity"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeEntityBegin (MimeEntityBeginEventArgs args)
		{
			MimeEntityBegin?.Invoke (this, args);
		}

		/// <summary>
		/// An event signifying the end of a <see cref="MimeEntity"/> has been encountered.
		/// </summary>
		/// <remarks>
		/// An event signifying the end of a <see cref="MimeEntity"/> has been encountered.
		/// </remarks>
		public event EventHandler<MimeEntityEndEventArgs> MimeEntityEnd;

		/// <summary>
		/// Invoked when the parser has completed parsing a <see cref="MimeEntity"/>.
		/// </summary>
		/// <remarks>
		/// Invoked when the parser has completed parsing a <see cref="MimeEntity"/>.
		/// </remarks>
		/// <param name="args">The parsed state.</param>
		protected virtual void OnMimeEntityEnd (MimeEntityEndEventArgs args)
		{
			MimeEntityEnd?.Invoke (this, args);
		}

#if DEBUG_PARSER
		static string ConvertToCString (byte[] buffer, int startIndex, int length)
		{
			var cstr = new StringBuilder ();
			cstr.AppendCString (buffer, startIndex, length);
			return cstr.ToString ();
		}
#endif

		static int NextAllocSize (int need)
		{
			return (need + 63) & ~63;
		}

		bool AlignReadAheadBuffer (int atleast, int save, out int left, out int start, out int end)
		{
			left = inputEnd - inputIndex;
			start = inputStart;
			end = inputEnd;

			if (left >= atleast || eos)
				return false;

			left += save;

			if (left > 0) {
				int index = inputIndex - save;

				// attempt to align the end of the remaining input with ReadAheadSize
				if (index >= start) {
					start -= Math.Min (ReadAheadSize, left);
					Buffer.BlockCopy (input, index, input, start, left);
					index = start;
					start += left;
				} else if (index > 0) {
					int shift = Math.Min (index, end - start);
					Buffer.BlockCopy (input, index, input, index - shift, left);
					index -= shift;
					start = index + left;
				} else {
					// we can't shift...
					start = end;
				}

				inputIndex = index + save;
				inputEnd = start;
			} else {
				inputIndex = start;
				inputEnd = start;
			}

			end = input.Length - PadSize;

			return true;
		}

		int ReadAhead (int atleast, int save, CancellationToken cancellationToken)
		{
			int nread, left, start, end;

			if (!AlignReadAheadBuffer (atleast, save, out left, out start, out end))
				return left;

			// use the cancellable stream interface if available...
			var cancellable = stream as ICancellableStream;
			if (cancellable != null) {
				nread = cancellable.Read (input, start, end - start, cancellationToken);
			} else {
				cancellationToken.ThrowIfCancellationRequested ();
				nread = stream.Read (input, start, end - start);
			}

			if (nread > 0) {
				inputEnd += nread;
				position += nread;
			} else {
				eos = true;
			}

			return inputEnd - inputIndex;
		}

		long GetOffset (int index)
		{
			if (position == -1)
				return -1;

			return position - (inputEnd - index);
		}

		long GetEndOffset (int index)
		{
			if (boundary != BoundaryType.Eos && index > 1 && input[index - 1] == (byte) '\n') {
				index--;

				if (index > 1 && input[index - 1] == (byte) '\r')
					index--;
			}

			return GetOffset (index);
		}

		int GetLineCount (int beginLineNumber, long beginOffset, long endOffset)
		{
			var lines = lineNumber - beginLineNumber;

			if (lineBeginOffset >= beginOffset && endOffset > lineBeginOffset)
				lines++;

			if (boundary != BoundaryType.Eos && endOffset == prevLineBeginOffset)
				lines--;

			return lines;
		}

		static unsafe bool CStringsEqual (byte* str1, byte* str2, int length)
		{
			byte* se = str1 + length;
			byte* s1 = str1;
			byte* s2 = str2;

			while (s1 < se) {
				if (*s1++ != *s2++)
					return false;
			}

			return true;
		}

		unsafe void StepByteOrderMark (byte* inbuf, ref int bomIndex)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			while (inptr < inend && bomIndex < UTF8ByteOrderMark.Length && *inptr == UTF8ByteOrderMark[bomIndex]) {
				bomIndex++;
				inptr++;
			}

			inputIndex = (int) (inptr - inbuf);
		}

		unsafe bool StepByteOrderMark (byte* inbuf, CancellationToken cancellationToken)
		{
			int bomIndex = 0;

			do {
				var available = ReadAhead (ReadAheadSize, 0, cancellationToken);

				if (available <= 0) {
					// failed to read any data... EOF
					inputIndex = inputEnd;
					return false;
				}

				StepByteOrderMark (inbuf, ref bomIndex);
			} while (inputIndex == inputEnd);

			return bomIndex == 0 || bomIndex == UTF8ByteOrderMark.Length;
		}

		static unsafe bool IsMboxMarker (byte* text, bool allowMunged = false)
		{
#if COMPARE_QWORD
			const ulong FromMask = 0x000000FFFFFFFFFF;
			const ulong From     = 0x000000206D6F7246;
			ulong* qword = (ulong*) text;

			return (*qword & FromMask) == From;
#else
			byte* inptr = text;

			if (allowMunged && *inptr == (byte) '>')
				inptr++;

			return *inptr++ == (byte) 'F' && *inptr++ == (byte) 'r' && *inptr++ == (byte) 'o' && *inptr++ == (byte) 'm' && *inptr == (byte) ' ';
#endif
		}

		unsafe bool StepMboxMarker (byte *inbuf, ref int left)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			*inend = (byte) '\n';

			while (inptr < inend) {
				int startIndex = inputIndex;
				byte* start = inptr;

				// scan for the end of the line
				while (*inptr != (byte) '\n')
					inptr++;

				var markerLength = (int) (inptr - start);

				if (inptr > start && *(inptr - 1) == (byte) '\r')
					markerLength--;

				// consume the '\n'
				inptr++;

				var lineLength = (int) (inptr - start);

				if (inptr >= inend) {
					// we don't have enough input data
					left = lineLength;
					return false;
				}

				inputIndex += lineLength;
				prevLineBeginOffset = lineBeginOffset;
				lineBeginOffset = GetOffset (inputIndex);
				lineNumber++;

				if (markerLength >= 5 && IsMboxMarker (start)) {
					mboxMarkerOffset = GetOffset (startIndex);
					mboxMarkerLength = markerLength;

					if (mboxMarkerBuffer.Length < mboxMarkerLength)
						Array.Resize (ref mboxMarkerBuffer, mboxMarkerLength);

					Buffer.BlockCopy (input, startIndex, mboxMarkerBuffer, 0, markerLength);

					return true;
				}
			}

			left = 0;

			return false;
		}

		unsafe void StepMboxMarker (byte* inbuf, CancellationToken cancellationToken)
		{
			bool complete;
			int left = 0;

			mboxMarkerLength = 0;

			do {
				var available = ReadAhead (Math.Max (ReadAheadSize, left), 0, cancellationToken);

				if (available <= left) {
					// failed to find a From line; EOF reached
					state = MimeParserState.Error;
					inputIndex = inputEnd;
					return;
				}

				complete = StepMboxMarker (inbuf, ref left);
			} while (!complete);

			state = MimeParserState.MessageHeaders;
		}

		void AppendRawHeaderData (int startIndex, int length)
		{
			int left = headerBuffer.Length - headerIndex;

			if (left < length)
				Array.Resize (ref headerBuffer, NextAllocSize (headerIndex + length));

			Buffer.BlockCopy (input, startIndex, headerBuffer, headerIndex, length);
			headerIndex += length;
		}

		void ResetRawHeaderData ()
		{
			preHeaderLength = 0;
			headerIndex = 0;
		}

		unsafe void ParseAndAppendHeader ()
		{
			if (headerIndex == 0)
				return;

			fixed (byte* buf = headerBuffer) {
				if (Header.TryParse (options, buf, headerIndex, false, out var header)) {
					header.Offset = headerOffset;
					headers.Add (header);
					headerIndex = 0;
				}
			}
		}

		static bool IsControl (byte c)
		{
			return c.IsCtrl ();
		}

		static bool IsBlank (byte c)
		{
			return c.IsBlank ();
		}

		static unsafe bool IsEoln (byte *text)
		{
			if (*text == (byte) '\r')
				text++;

			return *text == (byte) '\n';
		}

		unsafe bool StepHeaders (byte* inbuf, ref bool scanningFieldName, ref bool checkFolded, ref bool midline,
		                         ref bool blank, ref bool valid, ref int left)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			bool needInput = false;
			long length;
			bool eoln;

			*inend = (byte) '\n';

			while (inptr < inend) {
				byte* start = inptr;

				// if we are scanning a new line, check for a folded header
				if (!midline && checkFolded && !IsBlank (*inptr)) {
					ParseAndAppendHeader ();

					headerOffset = GetOffset ((int) (inptr - inbuf));
					scanningFieldName = true;
					checkFolded = false;
					blank = false;
					valid = true;
				}

				eoln = IsEoln (inptr);
				if (scanningFieldName && !eoln) {
					// scan and validate the field name
					if (*inptr != (byte) ':') {
						*inend = (byte) ':';

						while (*inptr != (byte) ':') {
							// Blank spaces are allowed between the field name and
							// the ':', but field names themselves are not allowed
							// to contain spaces.
							if (IsBlank (*inptr)) {
								blank = true;
							} else if (blank || IsControl (*inptr)) {
								valid = false;
								break;
							}

							inptr++;
						}

						if (inptr == inend) {
							// we don't have enough input data; restore state back to the beginning of the line
							left = (int) (inend - start);
							inputIndex = (int) (start - inbuf);
							needInput = true;
							break;
						}

						*inend = (byte) '\n';
					} else {
						valid = false;
					}

					if (!valid) {
						length = inptr - start;

						if (format == MimeFormat.Mbox && inputIndex >= contentEnd && length >= 5 && IsMboxMarker (start)) {
							// we've found the start of the next message...
							inputIndex = (int) (start - inbuf);
							state = MimeParserState.Complete;
							headerIndex = 0;
							return false;
						}

						if (headers.Count == 0) {
							if (state == MimeParserState.MessageHeaders) {
								// ignore From-lines that might appear at the start of a message
								if (toplevel && (length < 5 || !IsMboxMarker (start, true))) {
									// not a From-line...
									inputIndex = (int) (start - inbuf);
									state = MimeParserState.Error;
									headerIndex = 0;
									return false;
								}
							} else if (toplevel && state == MimeParserState.Headers) {
								inputIndex = (int) (start - inbuf);
								state = MimeParserState.Error;
								headerIndex = 0;
								return false;
							}
						}
					}
				}

				scanningFieldName = false;

				while (*inptr != (byte) '\n')
					inptr++;

				if (inptr == inend) {
					// we didn't manage to slurp up a full line, save what we have and refill our input buffer
					length = inptr - start;

					if (inptr > start) {
						// Note: if the last byte we got was a '\r', rewind a byte
						inptr--;
						if (*inptr == (byte) '\r')
							length--;
						else
							inptr++;
					}

					if (length > 0) {
						AppendRawHeaderData ((int) (start - inbuf), (int) length);
						midline = true;
					}

					inputIndex = (int) (inptr - inbuf);
					left = (int) (inend - inptr);
					needInput = true;
					break;
				}

				prevLineBeginOffset = lineBeginOffset;
				lineBeginOffset = GetOffset ((int) (inptr - inbuf) + 1);
				lineNumber++;

				// check to see if we've reached the end of the headers
				if (!midline && IsEoln (start)) {
					inputIndex = (int) (inptr - inbuf) + 1;
					state = MimeParserState.Content;
					ParseAndAppendHeader ();
					headerIndex = 0;
					return false;
				}

				length = (inptr + 1) - start;

				if ((boundary = CheckBoundary ((int) (start - inbuf), start, (int) length)) != BoundaryType.None) {
					inputIndex = (int) (start - inbuf);
					state = MimeParserState.Boundary;
					headerIndex = 0;
					return false;
				}

				if (!valid && headers.Count == 0) {
					if (length > 0 && preHeaderLength == 0) {
						if (inptr[-1] == (byte) '\r')
							length--;
						length--;

						preHeaderLength = (int) length;

						if (preHeaderLength > preHeaderBuffer.Length)
							Array.Resize (ref preHeaderBuffer, NextAllocSize (preHeaderLength));

						Buffer.BlockCopy (input, (int) (start - inbuf), preHeaderBuffer, 0, preHeaderLength);
					}
					scanningFieldName = true;
					checkFolded = false;
					blank = false;
					valid = true;
				} else {
					AppendRawHeaderData ((int) (start - inbuf), (int) length);
					checkFolded = true;
				}

				midline = false;
				inptr++;
			}

			if (!needInput) {
				inputIndex = (int) (inptr - inbuf);
				left = (int) (inend - inptr);
			}

			return true;
		}

		unsafe void StepHeaders (byte* inbuf, CancellationToken cancellationToken)
		{
			bool scanningFieldName = true;
			bool checkFolded = false;
			bool midline = false;
			bool blank = false;
			bool valid = true;
			int left = 0;

			headerBlockBegin = GetOffset (inputIndex);
			boundary = BoundaryType.None;
			ResetRawHeaderData ();
			headers.Clear ();

			ReadAhead (ReadAheadSize, 0, cancellationToken);

			do {
				if (!StepHeaders (inbuf, ref scanningFieldName, ref checkFolded, ref midline, ref blank, ref valid, ref left))
					break;

				var available = ReadAhead (left + 1, 0, cancellationToken);

				if (available == left) {
					// EOF reached before we reached the end of the headers...
					if (scanningFieldName && left > 0) {
						// EOF reached right in the middle of a header field name. Throw an error.
						//
						// See private email from Feb 8, 2018 which contained a sample message w/o
						// any breaks between the header and message body. The file also did not
						// end with a newline sequence.
						state = MimeParserState.Error;
					} else {
						// EOF reached somewhere in the middle of the value.
						//
						// Append whatever data we've got left and pretend we found the end
						// of the header value (and the header block).
						//
						// For more details, see https://github.com/jstedfast/MimeKit/pull/51
						// and https://github.com/jstedfast/MimeKit/issues/348
						if (left > 0) {
							AppendRawHeaderData (inputIndex, left);
							inputIndex = inputEnd;
						}

						ParseAndAppendHeader ();

						state = MimeParserState.Content;
					}
					break;
				}
			} while (true);

			headerBlockEnd = GetOffset (inputIndex);
		}

		unsafe bool SkipLine (byte* inbuf, bool consumeNewLine)
		{
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;

			*inend = (byte) '\n';

			while (*inptr != (byte) '\n')
				inptr++;

			if (inptr < inend) {
				inputIndex = (int) (inptr - inbuf);

				if (consumeNewLine) {
					inputIndex++;
					lineNumber++;
					prevLineBeginOffset = lineBeginOffset;
					lineBeginOffset = GetOffset (inputIndex);
				} else if (*(inptr - 1) == (byte) '\r') {
					inputIndex--;
				}

				return true;
			}

			inputIndex = inputEnd;

			return false;
		}

		unsafe bool SkipLine (byte* inbuf, bool consumeNewLine, CancellationToken cancellationToken)
		{
			do {
				if (SkipLine (inbuf, consumeNewLine))
					return true;

				if (ReadAhead (ReadAheadSize, 1, cancellationToken) <= 0)
					return false;
			} while (true);
		}

		unsafe MimeParserState Step (byte* inbuf, CancellationToken cancellationToken)
		{
			switch (state) {
			case MimeParserState.Initialized:
				if (!StepByteOrderMark (inbuf, cancellationToken)) {
					state = MimeParserState.Eos;
					break;
				}

				state = format == MimeFormat.Mbox ? MimeParserState.MboxMarker : MimeParserState.MessageHeaders;
				break;
			case MimeParserState.MboxMarker:
				StepMboxMarker (inbuf, cancellationToken);
				break;
			case MimeParserState.MessageHeaders:
			case MimeParserState.Headers:
				StepHeaders (inbuf, cancellationToken);
				toplevel = false;
				break;
			}

			return state;
		}

		ContentType GetContentType (ContentType parent)
		{
			for (int i = 0; i < headers.Count; i++) {
				if (!headers[i].Field.Equals ("Content-Type", StringComparison.OrdinalIgnoreCase))
					continue;

				var rawValue = headers[i].RawValue;
				int index = 0;

				if (!ContentType.TryParse (options, rawValue, ref index, rawValue.Length, false, out var type) && type == null) {
					// if 'type' is null, then it means that even the mime-type was unintelligible
					type = new ContentType ("application", "octet-stream");

					// attempt to recover any parameters...
					while (index < rawValue.Length && rawValue[index] != ';')
						index++;

					if (++index < rawValue.Length) {
						if (ParameterList.TryParse (options, rawValue, ref index, rawValue.Length, false, out var parameters))
							type.Parameters = parameters;
					}
				}

				return type;
			}

			if (parent == null || !parent.IsMimeType ("multipart", "digest"))
				return new ContentType ("text", "plain");

			return new ContentType ("message", "rfc822");
		}

		unsafe bool IsPossibleBoundary (byte* text, int length)
		{
			if (length < 2)
				return false;

			if (*text == (byte) '-' && *(text + 1) == (byte) '-')
				return true;

			if (format == MimeFormat.Mbox && length >= 5 && IsMboxMarker (text))
				return true;

			return false;
		}

		static unsafe bool IsBoundary (byte* text, int length, byte[] boundary, int boundaryLength)
		{
			if (boundaryLength > length)
				return false;

			fixed (byte* boundaryptr = boundary) {
				// make sure that the text matches the boundary
				if (!CStringsEqual (text, boundaryptr, boundaryLength))
					return false;

				// if this is an mbox marker, we're done
				if (IsMboxMarker (text))
					return true;

				// the boundary may optionally be followed by lwsp
				byte* inptr = text + boundaryLength;
				byte* inend = text + length;

				while (inptr < inend) {
					if (!(*inptr).IsWhitespace ())
						return false;

					inptr++;
				}
			}

			return true;
		}

		unsafe BoundaryType CheckBoundary (int startIndex, byte* start, int length)
		{
			int count = bounds.Count;

			if (!IsPossibleBoundary (start, length))
				return BoundaryType.None;

			if (contentEnd > 0) {
				// We'll need to special-case checking for the mbox From-marker when respecting Content-Length
				count--;
			}

			for (int i = 0; i < count; i++) {
				var boundary = bounds[i];

				if (IsBoundary (start, length, boundary.Marker, boundary.FinalLength))
					return i == 0 ? BoundaryType.ImmediateEndBoundary : BoundaryType.ParentEndBoundary;

				if (IsBoundary (start, length, boundary.Marker, boundary.Length))
					return i == 0 ? BoundaryType.ImmediateBoundary : BoundaryType.ParentBoundary;
			}

			if (contentEnd > 0) {
				// now it is time to check the mbox From-marker for the Content-Length case
				long curOffset = GetOffset (startIndex);
				var boundary = bounds[count];

				if (curOffset >= contentEnd && IsBoundary (start, length, boundary.Marker, boundary.Length))
					return BoundaryType.ImmediateEndBoundary;
			}

			return BoundaryType.None;
		}

		unsafe bool FoundImmediateBoundary (byte* inbuf, bool final)
		{
			int boundaryLength = final ? bounds[0].FinalLength : bounds[0].Length;
			byte* start = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			byte *inptr = start;

			*inend = (byte) '\n';

			while (*inptr != (byte) '\n')
				inptr++;

			return IsBoundary (start, (int) (inptr - start), bounds[0].Marker, boundaryLength);
		}

		int GetMaxBoundaryLength ()
		{
			return bounds.Count > 0 ? bounds[0].MaxLength + 2 : 0;
		}

		unsafe void ScanContent (byte* inbuf, ref int contentIndex, ref int nleft, ref bool midline, ref bool[] formats)
		{
			int length = inputEnd - inputIndex;
			byte* inptr = inbuf + inputIndex;
			byte* inend = inbuf + inputEnd;
			int startIndex = inputIndex;

			contentIndex = inputIndex;

			if (midline && length == nleft)
				boundary = BoundaryType.Eos;

			*inend = (byte) '\n';

			while (inptr < inend) {
				// Note: we can always depend on byte[] arrays being 4-byte aligned on 32bit and 64bit architectures
				int alignment = (startIndex + 3) & ~3;
				byte* aligned = inbuf + alignment;
				byte* start = inptr;
				byte c = *aligned;
				uint mask;

				*aligned = (byte) '\n';
				while (*inptr != (byte) '\n')
					inptr++;
				*aligned = c;

				if (inptr == aligned && c != (byte) '\n') {
					// -funroll-loops, yippee ki-yay.
					uint* dword = (uint*) inptr;

					do {
						mask = *dword++ ^ 0x0A0A0A0A;
						mask = ((mask - 0x01010101) & (~mask & 0x80808080));
					} while (mask == 0);

					inptr = (byte*) (dword - 1);
					while (*inptr != (byte) '\n')
						inptr++;
				}

				length = (int) (inptr - start);

				if (inptr < inend) {
					if ((boundary = CheckBoundary (startIndex, start, length)) != BoundaryType.None)
						break;

					if (length > 0 && *(inptr - 1) == (byte) '\r')
						formats[(int) NewLineFormat.Dos] = true;
					else
						formats[(int) NewLineFormat.Unix] = true;

					lineNumber++;
					length++;
					inptr++;

					prevLineBeginOffset = lineBeginOffset;
					lineBeginOffset = GetOffset ((int) (inptr - inbuf));
				} else {
					// didn't find the end of the line...
					midline = true;

					if (boundary == BoundaryType.None) {
						// not enough to tell if we found a boundary
						break;
					}

					if ((boundary = CheckBoundary (startIndex, start, length)) != BoundaryType.None)
						break;
				}

				startIndex += length;
			}

			inputIndex = startIndex;
		}

		class ScanContentResult
		{
			public readonly NewLineFormat? Format;
			public readonly bool IsEmpty;

			public ScanContentResult (bool[] formats, bool isEmpty)
			{
				if (formats[(int) NewLineFormat.Unix] && formats[(int) NewLineFormat.Dos])
					Format = NewLineFormat.Mixed;
				else if (formats[(int) NewLineFormat.Unix])
					Format = NewLineFormat.Unix;
				else if (formats[(int) NewLineFormat.Dos])
					Format = NewLineFormat.Dos;
				else
					Format = null;
				IsEmpty = isEmpty;
			}
		}

		unsafe ScanContentResult ScanContent (byte* inbuf, Stream content, bool trimNewLine, CancellationToken cancellationToken)
		{
			int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());
			int contentIndex = inputIndex;
			var formats = new bool[2];
			bool midline = false;
			int nleft;

			do {
				if (contentIndex < inputIndex)
					content.Write (input, contentIndex, inputIndex - contentIndex);

				nleft = inputEnd - inputIndex;
				if (ReadAhead (atleast, 2, cancellationToken) <= 0) {
					boundary = BoundaryType.Eos;
					contentIndex = inputIndex;
					break;
				}

				ScanContent (inbuf, ref contentIndex, ref nleft, ref midline, ref formats);
			} while (boundary == BoundaryType.None);

			if (contentIndex < inputIndex)
				content.Write (input, contentIndex, inputIndex - contentIndex);

			var isEmpty = content.Length == 0;

			if (boundary != BoundaryType.Eos && trimNewLine) {
				// the last \r\n belongs to the boundary
				if (content.Length > 0) {
					if (input[inputIndex - 2] == (byte) '\r')
						content.SetLength (content.Length - 2);
					else
						content.SetLength (content.Length - 1);
				}
			}

			return new ScanContentResult (formats, isEmpty);
		}

		unsafe void ConstructMimePart (MimePart part, MimeEntityEndEventArgs args, byte* inbuf, CancellationToken cancellationToken)
		{
			long endOffset, beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			ScanContentResult result;
			Stream content;

			if (persistent) {
				using (var measured = new MeasuringStream ()) {
					result = ScanContent (inbuf, measured, true, cancellationToken);
					endOffset = beginOffset + measured.Length;
				}

				content = new BoundStream (stream, beginOffset, endOffset, true);
			} else {
				content = new MemoryBlockStream ();

				try {
					result = ScanContent (inbuf, content, true, cancellationToken);
					content.Seek (0, SeekOrigin.Begin);
				} catch {
					content.Dispose ();
					throw;
				}

				endOffset = beginOffset + content.Length;
			}

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			if (!result.IsEmpty)
				part.Content = new MimeContent (content, part.ContentTransferEncoding) { NewLineFormat = result.Format };
			else
				content.Dispose ();
		}

		unsafe void ConstructMessagePart (MessagePart rfc822, MimeEntityEndEventArgs args, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;

			if (bounds.Count > 0) {
				int atleast = Math.Max (ReadAheadSize, GetMaxBoundaryLength ());

				if (ReadAhead (atleast, 0, cancellationToken) <= 0) {
					boundary = BoundaryType.Eos;
					return;
				}

				byte* start = inbuf + inputIndex;
				byte* inend = inbuf + inputEnd;
				byte* inptr = start;

				*inend = (byte) '\n';

				while (*inptr != (byte) '\n')
					inptr++;

				boundary = CheckBoundary (inputIndex, start, (int) (inptr - start));

				switch (boundary) {
				case BoundaryType.ImmediateEndBoundary:
				case BoundaryType.ImmediateBoundary:
				case BoundaryType.ParentBoundary:
					return;
				case BoundaryType.ParentEndBoundary:
					// ignore "From " boundaries, broken mailers tend to include these...
					if (!IsMboxMarker (start)) {
						return;
					}
					break;
				}
			}

			// parse the headers...
			state = MimeParserState.MessageHeaders;
			if (Step (inbuf, cancellationToken) == MimeParserState.Error) {
				// Note: this either means that StepHeaders() found the end of the stream
				// or an invalid header field name at the start of the message headers,
				// which likely means that this is not a valid MIME stream?
				boundary = BoundaryType.Eos;
				return;
			}

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message, rfc822) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			if (preHeaderBuffer.Length > 0) {
				message.MboxMarker = new byte[preHeaderLength];
				Buffer.BlockCopy (preHeaderBuffer, 0, message.MboxMarker, 0, preHeaderLength);
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, depth);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart multipart)
				ConstructMultipart (multipart, entityArgs, inbuf, depth + 1, cancellationToken);
			else if (entity is MessagePart messagePart)
				ConstructMessagePart (messagePart, entityArgs, inbuf, depth + 1, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			rfc822.Message = message;

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min(entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
		}

		unsafe void MultipartScanPreamble (Multipart multipart, byte* inbuf, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartPreambleBegin (multipart, offset);
				ScanContent (inbuf, memory, false, cancellationToken);
				multipart.RawPreamble = memory.ToArray ();
				//OnMultipartPreambleEnd (multipart, offset + memory.Length);
			}
		}

		unsafe void MultipartScanEpilogue (Multipart multipart, byte* inbuf, CancellationToken cancellationToken)
		{
			using (var memory = new MemoryStream ()) {
				long offset = GetOffset (inputIndex);

				//OnMultipartEpilogueBegin (multipart, offset);
				var result = ScanContent (inbuf, memory, true, cancellationToken);
				multipart.RawEpilogue = result.IsEmpty ? null : memory.ToArray ();
				//OnMultipartEpilogueEnd (multipart, offset + memory.Length);
			}
		}

		unsafe void MultipartScanSubparts (Multipart multipart, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			//var beginOffset = GetOffset (inputIndex);

			do {
				//OnMultipartBoundaryBegin (multipart, beginOffset);

				// skip over the boundary marker
				if (!SkipLine (inbuf, true, cancellationToken)) {
					//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));
					boundary = BoundaryType.Eos;
					return;
				}

				//OnMultipartBoundaryEnd (multipart, GetOffset (inputIndex));

				var beginLineNumber = lineNumber;

				// parse the headers
				state = MimeParserState.Headers;
				if (Step (inbuf, cancellationToken) == MimeParserState.Error) {
					boundary = BoundaryType.Eos;
					return;
				}

				if (state == MimeParserState.Boundary) {
					if (headers.Count == 0) {
						if (boundary == BoundaryType.ImmediateBoundary) {
							//beginOffset = GetOffset (inputIndex);
							continue;
						}
						return;
					}

					// This part has no content, but that will be handled in ConstructMultipart()
					// or ConstructMimePart().
				}

				//if (state == ParserState.Complete && headers.Count == 0)
				//	return BoundaryType.EndBoundary;

				var type = GetContentType (multipart.ContentType);
				var entity = options.CreateEntity (type, headers, false, depth);
				var entityArgs = new MimeEntityEndEventArgs (entity, multipart) {
					HeadersEndOffset = headerBlockEnd,
					BeginOffset = headerBlockBegin,
					LineNumber = beginLineNumber
				};

				OnMimeEntityBegin (entityArgs);

				if (entity is Multipart multipart)
					ConstructMultipart (multipart, entityArgs, inbuf, depth + 1, cancellationToken);
				else if (entity is MessagePart messagePart)
					ConstructMessagePart (messagePart, entityArgs, inbuf, depth + 1, cancellationToken);
				else
					ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

				var endOffset = GetEndOffset (inputIndex);
				entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
				entityArgs.EndOffset = endOffset;

				OnMimeEntityEnd (entityArgs);

				//beginOffset = endOffset;
				multipart.Add (entity);
			} while (boundary == BoundaryType.ImmediateBoundary);
		}

		void PushBoundary (string boundary)
		{
			if (bounds.Count > 0)
				bounds.Insert (0, new Boundary (boundary, bounds[0].MaxLength));
			else
				bounds.Add (new Boundary (boundary, 0));
		}

		void PopBoundary ()
		{
			bounds.RemoveAt (0);
		}

		unsafe void ConstructMultipart (Multipart multipart, MimeEntityEndEventArgs args, byte* inbuf, int depth, CancellationToken cancellationToken)
		{
			var beginOffset = GetOffset (inputIndex);
			var beginLineNumber = lineNumber;
			var marker = multipart.Boundary;
			long endOffset;

			if (marker == null) {
#if DEBUG
				Debug.WriteLine ("Multipart without a boundary encountered!");
#endif

				// Note: this will scan all content into the preamble...
				MultipartScanPreamble (multipart, inbuf, cancellationToken);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			PushBoundary (marker);

			MultipartScanPreamble (multipart, inbuf, cancellationToken);
			if (boundary == BoundaryType.ImmediateBoundary)
				MultipartScanSubparts (multipart, inbuf, depth, cancellationToken);

			if (boundary == BoundaryType.ImmediateEndBoundary) {
				//OnMultipartEndBoundaryBegin (multipart, GetEndOffset (inputIndex));

				// consume the end boundary and read the epilogue (if there is one)
				multipart.WriteEndBoundary = true;
				SkipLine (inbuf, false, cancellationToken);
				PopBoundary ();

				//OnMultipartEndBoundaryEnd (multipart, GetOffset (inputIndex));

				MultipartScanEpilogue (multipart, inbuf, cancellationToken);

				endOffset = GetEndOffset (inputIndex);
				args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);
				return;
			}

			endOffset = GetEndOffset (inputIndex);
			args.Lines = GetLineCount (beginLineNumber, beginOffset, endOffset);

			multipart.WriteEndBoundary = false;

			// We either found the end of the stream or we found a parent's boundary
			PopBoundary ();

			if (boundary == BoundaryType.ParentEndBoundary && FoundImmediateBoundary (inbuf, true))
				boundary = BoundaryType.ImmediateEndBoundary;
			else if (boundary == BoundaryType.ParentBoundary && FoundImmediateBoundary (inbuf, false))
				boundary = BoundaryType.ImmediateBoundary;
		}

		unsafe HeaderList ParseHeaders (byte* inbuf, CancellationToken cancellationToken)
		{
			state = MimeParserState.Headers;
			if (Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse headers.");

			state = eos ? MimeParserState.Eos : MimeParserState.Complete;

			var parsed = new HeaderList (options);
			foreach (var header in headers)
				parsed.Add (header);

			return parsed;
		}

		/// <summary>
		/// Parses a list of headers from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a list of headers from the stream.
		/// </remarks>
		/// <returns>The parsed list of headers.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the headers.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public HeaderList ParseHeaders (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseHeaders (inbuf, cancellationToken);
				}
			}
		}

		unsafe MimeEntity ParseEntity (byte* inbuf, CancellationToken cancellationToken)
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			var beginLineNumber = lineNumber;

			state = MimeParserState.Headers;
			toplevel = true;

			if (Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse entity headers.");

			var type = GetContentType (null);

			// Note: we pass 'false' as the 'toplevel' argument here because
			// we want the entity to consume all of the headers.
			var entity = options.CreateEntity (type, headers, false, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			if (entity is Multipart multipart)
				ConstructMultipart (multipart, entityArgs, inbuf, 0, cancellationToken);
			else if (entity is MessagePart messagePart)
				ConstructMessagePart (messagePart, entityArgs, inbuf, 0, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			var endOffset = GetEndOffset (inputIndex);
			entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos)
				state = MimeParserState.Complete;
			else
				state = MimeParserState.Eos;

			OnMimeEntityEnd (entityArgs);

			return entity;
		}

		/// <summary>
		/// Parses an entity from the stream.
		/// </summary>
		/// <remarks>
		/// Parses an entity from the stream.
		/// </remarks>
		/// <returns>The parsed entity.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the entity.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public MimeEntity ParseEntity (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseEntity (inbuf, cancellationToken);
				}
			}
		}

		unsafe MimeMessage ParseMessage (byte* inbuf, CancellationToken cancellationToken)
		{
			// Note: if a previously parsed MimePart's content has been read,
			// then the stream position will have moved and will need to be
			// reset.
			if (persistent && stream.Position != position)
				stream.Seek (position, SeekOrigin.Begin);

			// scan the from-line if we are parsing an mbox
			while (state != MimeParserState.MessageHeaders) {
				switch (Step (inbuf, cancellationToken)) {
				case MimeParserState.Error:
					throw new FormatException ("Failed to find mbox From marker.");
				case MimeParserState.Eos:
					throw new FormatException ("End of stream.");
				}
			}

			toplevel = true;

			// parse the headers
			var beginLineNumber = lineNumber;
			if (state < MimeParserState.Content && Step (inbuf, cancellationToken) == MimeParserState.Error)
				throw new FormatException ("Failed to parse message headers.");

			var message = new MimeMessage (options, headers, RfcComplianceMode.Loose);
			var messageArgs = new MimeMessageEndEventArgs (message) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeMessageBegin (messageArgs);

			contentEnd = 0;
			if (format == MimeFormat.Mbox && options.RespectContentLength) {
				for (int i = 0; i < headers.Count; i++) {
					if (headers[i].Id != HeaderId.ContentLength)
						continue;

					var value = headers[i].RawValue;
					int index = 0;

					if (!ParseUtils.SkipWhiteSpace (value, ref index, value.Length))
						continue;

					if (!ParseUtils.TryParseInt32 (value, ref index, value.Length, out int length))
						continue;

					contentEnd = GetOffset (inputIndex) + length;
					break;
				}
			}

			var type = GetContentType (null);
			var entity = options.CreateEntity (type, headers, true, 0);
			var entityArgs = new MimeEntityEndEventArgs (entity) {
				HeadersEndOffset = headerBlockEnd,
				BeginOffset = headerBlockBegin,
				LineNumber = beginLineNumber
			};

			OnMimeEntityBegin (entityArgs);

			message.Body = entity;

			if (entity is Multipart multipart)
				ConstructMultipart (multipart, entityArgs, inbuf, 0, cancellationToken);
			else if (entity is MessagePart rfc822)
				ConstructMessagePart (rfc822, entityArgs, inbuf, 0, cancellationToken);
			else
				ConstructMimePart ((MimePart) entity, entityArgs, inbuf, cancellationToken);

			var endOffset = GetEndOffset (inputIndex);
			messageArgs.HeadersEndOffset = entityArgs.HeadersEndOffset = Math.Min (entityArgs.HeadersEndOffset, endOffset);
			messageArgs.EndOffset = entityArgs.EndOffset = endOffset;

			if (boundary != BoundaryType.Eos) {
				if (format == MimeFormat.Mbox)
					state = MimeParserState.MboxMarker;
				else
					state = MimeParserState.Complete;
			} else {
				state = MimeParserState.Eos;
			}

			OnMimeEntityEnd (entityArgs);
			OnMimeMessageEnd (messageArgs);

			return message;
		}

		/// <summary>
		/// Parses a message from the stream.
		/// </summary>
		/// <remarks>
		/// Parses a message from the stream.
		/// </remarks>
		/// <returns>The parsed message.</returns>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.FormatException">
		/// There was an error parsing the message.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public MimeMessage ParseMessage (CancellationToken cancellationToken = default (CancellationToken))
		{
			unsafe {
				fixed (byte* inbuf = input) {
					return ParseMessage (inbuf, cancellationToken);
				}
			}
		}

		#region IEnumerable implementation

		/// <summary>
		/// Enumerates the messages in the stream.
		/// </summary>
		/// <remarks>
		/// This is mostly useful when parsing mbox-formatted streams.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		public IEnumerator<MimeMessage> GetEnumerator ()
		{
			while (!IsEndOfStream)
				yield return ParseMessage ();

			yield break;
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Enumerates the messages in the stream.
		/// </summary>
		/// <remarks>
		/// This is mostly useful when parsing mbox-formatted streams.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator ()
		{
			return GetEnumerator ();
		}

		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\MimeParser.cs(1576,32): error CS0841: Cannot use local variable 'multipart' before it is declared,D:\a\1\s\MimeKit\MimeParser.cs(1578,58): error CS0841: Cannot use local variable 'multipart' before it is declared,D:\a\1\s\MimeKit\MimeParser.cs(1586,29): error CS0136: A local or parameter named 'multipart' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MimeKit\Multipart.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Collections;
using System.Threading.Tasks;
using System.Collections.Generic;

using MimeKit.IO;
using MimeKit.Utils;
using MimeKit.Encodings;

namespace MimeKit {
	/// <summary>
	/// A multipart MIME entity which may contain a collection of MIME entities.
	/// </summary>
	/// <remarks>
	/// <para>All multipart MIME entities will have a Content-Type with a media type of <c>"multipart"</c>.
	/// The most common multipart MIME entity used in email is the <c>"multipart/mixed"</c> entity.</para>
	/// <para>Four (4) initial subtypes were defined in the original MIME specifications: mixed, alternative,
	/// digest, and parallel.</para>
	/// <para>The "multipart/mixed" type is a sort of general-purpose container. When used in email, the
	/// first entity is typically the "body" of the message while additional entities are most often
	/// file attachments.</para>
	/// <para>Speaking of message "bodies", the "multipart/alternative" type is used to offer a list of
	/// alternative formats for the main body of the message (usually they will be "text/plain" and
	/// "text/html"). These alternatives are in order of increasing faithfulness to the original document
	/// (in other words, the last entity will be in a format that, when rendered, will most closely match
	/// what the sending client's WYSISYG editor produced).</para>
	/// <para>The "multipart/digest" type will typically contain a digest of MIME messages and is most
	/// commonly used by mailing-list software.</para>
	/// <para>The "multipart/parallel" type contains entities that are all meant to be shown (or heard)
	/// in parallel.</para>
	/// <para>Another commonly used type is the "multipart/related" type which contains, as one might expect,
	/// inter-related MIME parts which typically reference each other via URIs based on the Content-Id and/or
	/// Content-Location headers.</para>
	/// </remarks>
	public class Multipart : MimeEntity, ICollection<MimeEntity>, IList<MimeEntity>
	{
		readonly List<MimeEntity> children;
		string preamble, epilogue;

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// This constructor is used by <see cref="MimeParser"/>.
		/// </remarks>
		/// <param name="args">Information used by the constructor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		public Multipart (MimeEntityConstructorArgs args) : base (args)
		{
			children = new List<MimeEntity> ();
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with the specified subtype.
		/// </remarks>
		/// <param name="subtype">The multipart media sub-type.</param>
		/// <param name="args">An array of initialization parameters: headers and MIME entities.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="subtype"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="args"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="args"/> contains one or more arguments of an unknown type.
		/// </exception>
		public Multipart (string subtype, params object[] args) : this (subtype)
		{
			if (args == null)
				throw new ArgumentNullException (nameof (args));

			foreach (object obj in args) {
				if (obj == null || TryInit (obj))
					continue;

				if (obj is MimeEntity entity) {
					Add (entity);
					continue;
				}

				throw new ArgumentException ("Unknown initialization parameter: " + obj.GetType ());
			}
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with the specified subtype.
		/// </remarks>
		/// <param name="subtype">The multipart media sub-type.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="subtype"/> is <c>null</c>.
		/// </exception>
		public Multipart (string subtype) : base ("multipart", subtype)
		{
			ContentType.Boundary = GenerateBoundary ();
			children = new List<MimeEntity> ();
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with a ContentType of multipart/mixed.
		/// </remarks>
		public Multipart () : this ("mixed")
		{
		}

		static string GenerateBoundary ()
		{
			var base64 = new Base64Encoder (true);
			var digest = new byte[16];
			var buf = new byte[24];
			int length;

			MimeUtils.GetRandomBytes (digest);

			length = base64.Flush (digest, 0, digest.Length, buf);

			return "=-" + Encoding.ASCII.GetString (buf, 0, length);
		}

		/// <summary>
		/// Get or set the boundary.
		/// </summary>
		/// <remarks>
		/// Gets or sets the boundary parameter on the Content-Type header.
		/// </remarks>
		/// <value>The boundary.</value>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		public string Boundary {
			get { return ContentType.Boundary; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				if (Boundary == value)
					return;

				ContentType.Boundary = value.Trim ();
			}
		}

		internal byte[] RawPreamble {
			get; set;
		}

		/// <summary>
		/// Get or set the preamble.
		/// </summary>
		/// <remarks>
		/// A multipart preamble appears before the first child entity of the
		/// multipart and is typically used only in the top-level multipart
		/// of the message to specify that the message is in MIME format and
		/// therefore requires a MIME compliant email application to render
		/// it correctly.
		/// </remarks>
		/// <value>The preamble.</value>
		public string Preamble {
			get {
				if (preamble == null && RawPreamble != null)
					preamble = CharsetUtils.ConvertToUnicode (Headers.Options, RawPreamble, 0, RawPreamble.Length);

				return preamble;
			}
			set {
				if (Preamble == value)
					return;

				if (value != null) {
					var folded = FoldPreambleOrEpilogue (FormatOptions.Default, value, false);
					RawPreamble = Encoding.UTF8.GetBytes (folded);
					preamble = folded;
				} else {
					RawPreamble = null;
					preamble = null;
				}

				WriteEndBoundary = true;
			}
		}

		internal byte[] RawEpilogue {
			get; set;
		}

		/// <summary>
		/// Get or set the epilogue.
		/// </summary>
		/// <remarks>
		/// A multipart epiloque is the text that appears after the closing boundary
		/// of the multipart and is typically either empty or a single new line
		/// character sequence.
		/// </remarks>
		/// <value>The epilogue.</value>
		public string Epilogue {
			get {
				if (epilogue == null && RawEpilogue != null) {
					int index = 0;

					// Note: In practice, the RawEpilogue contains the CRLF belonging to the end-boundary, but
					// for sanity, we pretend that it doesn't.
					if ((RawEpilogue.Length > 1 && RawEpilogue[0] == (byte) '\r' && RawEpilogue[1] == (byte) '\n'))
						index += 2;
					else if (RawEpilogue.Length > 1 && RawEpilogue[0] == (byte) '\n')
						index++;

					epilogue = CharsetUtils.ConvertToUnicode (Headers.Options, RawEpilogue, index, RawEpilogue.Length - index);
				}

				return epilogue;
			}
			set {
				if (Epilogue == value)
					return;

				if (value != null) {
					var folded = FoldPreambleOrEpilogue (FormatOptions.Default, value, true);
					RawEpilogue = Encoding.UTF8.GetBytes (folded);
					epilogue = null;
				} else {
					RawEpilogue = null;
					epilogue = null;
				}

				WriteEndBoundary = true;
			}
		}

		/// <summary>
		/// Get or set whether the end boundary should be written.
		/// </summary>
		/// <remarks>
		/// Gets or sets whether the end boundary should be written.
		/// </remarks>
		/// <value><c>true</c> if the end boundary should be written; otherwise, <c>false</c>.</value>
		internal bool WriteEndBoundary {
			get; set;
		}

		/// <summary>
		/// Dispatches to the specific visit method for this MIME entity.
		/// </summary>
		/// <remarks>
		/// This default implementation for <see cref="Multipart"/> nodes
		/// calls <see cref="MimeVisitor.VisitMultipart"/>. Override this
		/// method to call into a more specific method on a derived visitor class
		/// of the <see cref="MimeVisitor"/> class. However, it should still
		/// support unknown visitors by calling
		/// <see cref="MimeVisitor.VisitMultipart"/>.
		/// </remarks>
		/// <param name="visitor">The visitor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="visitor"/> is <c>null</c>.
		/// </exception>
		public override void Accept (MimeVisitor visitor)
		{
			if (visitor == null)
				throw new ArgumentNullException (nameof (visitor));

			visitor.VisitMultipart (this);
		}

		internal static string FoldPreambleOrEpilogue (FormatOptions options, string text, bool isEpilogue)
		{
			var builder = new StringBuilder ();
			int startIndex, wordIndex;
			int lineLength = 0;
			int index = 0;

			if (isEpilogue)
				builder.Append (options.NewLine);

			while (index < text.Length) {
				startIndex = index;

				while (index < text.Length) {
					if (!char.IsWhiteSpace (text[index]))
						break;

					if (text[index] == '\n') {
						builder.Append (options.NewLine);
						startIndex = index + 1;
						lineLength = 0;
					}

					index++;
				}

				wordIndex = index;

				while (index < text.Length && !char.IsWhiteSpace (text[index]))
					index++;

				int length = index - startIndex;

				if (lineLength > 0 && lineLength + length >= options.MaxLineLength) {
					builder.Append (options.NewLine);
					length = index - wordIndex;
					startIndex = wordIndex;
					lineLength = 0;
				}

				if (length > 0) {
					builder.Append (text, startIndex, length);
					lineLength += length;
				}
			}

			if (lineLength > 0)
				builder.Append (options.NewLine);

			return builder.ToString ();
		}

		static void WriteBytes (FormatOptions options, Stream stream, byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken)
		{
			var cancellable = stream as ICancellableStream;
			var filter = options.CreateNewLineFilter (ensureNewLine);
			int index, length;

			var output = filter.Flush (bytes, 0, bytes.Length, out index, out length);

			if (cancellable != null) {
				cancellable.Write (output, index, length, cancellationToken);
			} else {
				cancellationToken.ThrowIfCancellationRequested ();
				stream.Write (output, index, length);
			}
		}

		static Task WriteBytesAsync (FormatOptions options, Stream stream, byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken)
		{
			var filter = options.CreateNewLineFilter (ensureNewLine);
			int index, length;

			var output = filter.Flush (bytes, 0, bytes.Length, out index, out length);

			return stream.WriteAsync (output, index, length, cancellationToken);
		}

		/// <summary>
		/// Prepare the MIME entity for transport using the specified encoding constraints.
		/// </summary>
		/// <remarks>
		/// Prepares the MIME entity for transport using the specified encoding constraints.
		/// </remarks>
		/// <param name="constraint">The encoding constraint.</param>
		/// <param name="maxLineLength">The maximum number of octets allowed per line (not counting the CRLF). Must be between <c>60</c> and <c>998</c> (inclusive).</param>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <para><paramref name="maxLineLength"/> is not between <c>60</c> and <c>998</c> (inclusive).</para>
		/// <para>-or-</para>
		/// <para><paramref name="constraint"/> is not a valid value.</para>
		/// </exception>
		public override void Prepare (EncodingConstraint constraint, int maxLineLength = 78)
		{
			if (maxLineLength < FormatOptions.MinimumLineLength || maxLineLength > FormatOptions.MaximumLineLength)
				throw new ArgumentOutOfRangeException (nameof (maxLineLength));

			for (int i = 0; i < children.Count; i++)
				children[i].Prepare (constraint, maxLineLength);
		}

		/// <summary>
		/// Write the <see cref="Multipart"/> to the specified output stream.
		/// </summary>
		/// <remarks>
		/// Writes the multipart MIME entity and its subparts to the output stream.
		/// </remarks>
		/// <param name="options">The formatting options.</param>
		/// <param name="stream">The output stream.</param>
		/// <param name="contentOnly"><c>true</c> if only the content should be written; otherwise, <c>false</c>.</param>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public override void WriteTo (FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken = default (CancellationToken))
		{
			base.WriteTo (options, stream, contentOnly, cancellationToken);

			if (ContentType.IsMimeType ("multipart", "signed")) {
				// don't reformat the headers or content of any children of a multipart/signed
				if (options.International || options.HiddenHeaders.Count > 0) {
					options = options.Clone ();
					options.HiddenHeaders.Clear ();
					options.International = false;
				}
			}

			var cancellable = stream as ICancellableStream;

			if (RawPreamble != null && RawPreamble.Length > 0)
				WriteBytes (options, stream, RawPreamble, children.Count > 0 || EnsureNewLine, cancellationToken);

			var boundary = Encoding.ASCII.GetBytes ("--" + Boundary + "--");

			if (cancellable != null) {
				for (int i = 0; i < children.Count; i++) {
					var msg = children[i] as MessagePart;
					var multi = children[i] as Multipart;
					var part = children[i] as MimePart;

					cancellable.Write (boundary, 0, boundary.Length - 2, cancellationToken);
					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
					children[i].WriteTo (options, stream, false, cancellationToken);

					if (msg?.Message != null && msg.Message.Body != null) {
						multi = msg.Message.Body as Multipart;
						part = msg.Message.Body as MimePart;
					}

					if ((part != null && part.Content == null) ||
						(multi != null && !multi.WriteEndBoundary))
						continue;

					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
				}

				if (!WriteEndBoundary)
					return;

				cancellable.Write (boundary, 0, boundary.Length, cancellationToken);

				if (RawEpilogue == null)
					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
			} else {
				for (int i = 0; i < children.Count; i++) {
					var rfc822 = children[i] as MessagePart;
					var multi = children[i] as Multipart;
					var part = children[i] as MimePart;

					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (boundary, 0, boundary.Length - 2);
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
					children[i].WriteTo (options, stream, false, cancellationToken);

					if (rfc822?.Message != null && rfc822.Message.Body != null) {
						multi = rfc822.Message.Body as Multipart;
						part = rfc822.Message.Body as MimePart;
					}

					if ((part != null && part.Content == null) ||
						(multi != null && !multi.WriteEndBoundary))
						continue;

					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
				}

				if (!WriteEndBoundary)
					return;

				cancellationToken.ThrowIfCancellationRequested ();
				stream.Write (boundary, 0, boundary.Length);

				if (RawEpilogue == null) {
					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
				}
			}

			if (RawEpilogue != null && RawEpilogue.Length > 0)
				WriteBytes (options, stream, RawEpilogue, EnsureNewLine, cancellationToken);
		}

		/// <summary>
		/// Asynchronously write the <see cref="Multipart"/> to the specified output stream.
		/// </summary>
		/// <remarks>
		/// Asynchronously writes the multipart MIME entity and its subparts to the output stream.
		/// </remarks>
		/// <returns>An awaitable task.</returns>
		/// <param name="options">The formatting options.</param>
		/// <param name="stream">The output stream.</param>
		/// <param name="contentOnly"><c>true</c> if only the content should be written; otherwise, <c>false</c>.</param>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public override async Task WriteToAsync (FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken = default (CancellationToken))
		{
			await base.WriteToAsync (options, stream, contentOnly, cancellationToken).ConfigureAwait (false);

			if (ContentType.IsMimeType ("multipart", "signed")) {
				// don't hide or reformat the headers of any children of a multipart/signed
				if (options.International || options.HiddenHeaders.Count > 0) {
					options = options.Clone ();
					options.HiddenHeaders.Clear ();
					options.International = false;
				}
			}

			if (RawPreamble != null && RawPreamble.Length > 0)
				await WriteBytesAsync (options, stream, RawPreamble, children.Count > 0 || EnsureNewLine, cancellationToken).ConfigureAwait (false);

			var boundary = Encoding.ASCII.GetBytes ("--" + Boundary + "--");

			for (int i = 0; i < children.Count; i++) {
				var msg = children[i] as MessagePart;
				var multi = children[i] as Multipart;
				var part = children[i] as MimePart;

				await stream.WriteAsync (boundary, 0, boundary.Length - 2, cancellationToken).ConfigureAwait (false);
				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);
				await children[i].WriteToAsync (options, stream, false, cancellationToken).ConfigureAwait (false);

				if (msg?.Message != null && msg.Message.Body != null) {
					multi = msg.Message.Body as Multipart;
					part = msg.Message.Body as MimePart;
				}

				if ((part != null && part.Content == null) ||
				    (multi != null && !multi.WriteEndBoundary))
					continue;

				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);
			}

			if (!WriteEndBoundary)
				return;

			await stream.WriteAsync (boundary, 0, boundary.Length, cancellationToken).ConfigureAwait (false);

			if (RawEpilogue == null)
				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);

			if (RawEpilogue != null && RawEpilogue.Length > 0)
				await WriteBytesAsync (options, stream, RawEpilogue, EnsureNewLine, cancellationToken).ConfigureAwait (false);
		}

		#region ICollection implementation

		/// <summary>
		/// Get the number of parts in the multipart.
		/// </summary>
		/// <remarks>
		/// Indicates the number of parts in the multipart.
		/// </remarks>
		/// <value>The number of parts in the multipart.</value>
		public int Count {
			get { return children.Count; }
		}

		/// <summary>
		/// Get a value indicating whether this instance is read only.
		/// </summary>
		/// <remarks>
		/// A <see cref="Multipart"/> is never read-only.
		/// </remarks>
		/// <value><c>true</c> if this instance is read only; otherwise, <c>false</c>.</value>
		public bool IsReadOnly {
			get { return false; }
		}

		/// <summary>
		/// Add an entity to the multipart.
		/// </summary>
		/// <remarks>
		/// Adds the specified part to the multipart.
		/// </remarks>
		/// <param name="part">The part to add.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public void Add (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			WriteEndBoundary = true;
			children.Add (part);
		}

		/// <summary>
		/// Clear a multipart.
		/// </summary>
		/// <remarks>
		/// Removes all of the parts within the multipart.
		/// </remarks>
		public void Clear ()
		{
			WriteEndBoundary = true;
			children.Clear ();
		}

		/// <summary>
		/// Check if the <see cref="Multipart"/> contains the specified part.
		/// </summary>
		/// <remarks>
		/// Determines whether or not the multipart contains the specified part.
		/// </remarks>
		/// <returns><value>true</value> if the specified part exists;
		/// otherwise <value>false</value>.</returns>
		/// <param name="part">The part to check for.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public bool Contains (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			return children.Contains (part);
		}

		/// <summary>
		/// Copy all of the entities in the <see cref="Multipart"/> to the specified array.
		/// </summary>
		/// <remarks>
		/// Copies all of the entities within the <see cref="Multipart"/> into the array,
		/// starting at the specified array index.
		/// </remarks>
		/// <param name="array">The array to copy the headers to.</param>
		/// <param name="arrayIndex">The index into the array.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="array"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is out of range.
		/// </exception>
		public void CopyTo (MimeEntity[] array, int arrayIndex)
		{
			children.CopyTo (array, arrayIndex);
		}

		/// <summary>
		/// Remove an entity from the multipart.
		/// </summary>
		/// <remarks>
		/// Removes the specified part, if it exists within the multipart.
		/// </remarks>
		/// <returns><value>true</value> if the part was removed; otherwise <value>false</value>.</returns>
		/// <param name="part">The part to remove.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public bool Remove (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			if (!children.Remove (part))
				return false;

			WriteEndBoundary = true;

			return true;
		}

		#endregion

		#region IList implementation

		/// <summary>
		/// Get the index of an entity.
		/// </summary>
		/// <remarks>
		/// Finds the index of the specified part, if it exists.
		/// </remarks>
		/// <returns>The index of the specified part if found; otherwise <c>-1</c>.</returns>
		/// <param name="part">The part.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public int IndexOf (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			return children.IndexOf (part);
		}

		/// <summary>
		/// Insert an entity into the <see cref="Multipart"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Inserts the part into the multipart at the specified index.
		/// </remarks>
		/// <param name="index">The index.</param>
		/// <param name="part">The part.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public void Insert (int index, MimeEntity part)
		{
			if (index < 0 || index > children.Count)
				throw new ArgumentOutOfRangeException (nameof (index));

			if (part == null)
				throw new ArgumentNullException (nameof (part));

			children.Insert (index, part);
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Remove an entity from the <see cref="Multipart"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Removes the entity at the specified index.
		/// </remarks>
		/// <param name="index">The index.</param>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public void RemoveAt (int index)
		{
			children.RemoveAt (index);
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Get or set the <see cref="MimeEntity"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Gets or sets the <see cref="MimeEntity"/> at the specified index.
		/// </remarks>
		/// <value>The entity at the specified index.</value>
		/// <param name="index">The index.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public MimeEntity this[int index] {
			get { return children[index]; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				WriteEndBoundary = true;
				children[index] = value;
			}
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Get the enumerator for the children of the <see cref="Multipart"/>.
		/// </summary>
		/// <remarks>
		/// Gets the enumerator for the children of the <see cref="Multipart"/>.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		public IEnumerator<MimeEntity> GetEnumerator ()
		{
			return children.GetEnumerator ();
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Get the enumerator for the children of the <see cref="Multipart"/>.
		/// </summary>
		/// <remarks>
		/// Gets the enumerator for the children of the <see cref="Multipart"/>.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator ()
		{
			return children.GetEnumerator ();
		}

		#endregion
	}
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Collections;
using System.Threading.Tasks;
using System.Collections.Generic;

using MimeKit.IO;
using MimeKit.Utils;
using MimeKit.Encodings;

namespace MimeKit {
	/// <summary>
	/// A multipart MIME entity which may contain a collection of MIME entities.
	/// </summary>
	/// <remarks>
	/// <para>All multipart MIME entities will have a Content-Type with a media type of <c>"multipart"</c>.
	/// The most common multipart MIME entity used in email is the <c>"multipart/mixed"</c> entity.</para>
	/// <para>Four (4) initial subtypes were defined in the original MIME specifications: mixed, alternative,
	/// digest, and parallel.</para>
	/// <para>The "multipart/mixed" type is a sort of general-purpose container. When used in email, the
	/// first entity is typically the "body" of the message while additional entities are most often
	/// file attachments.</para>
	/// <para>Speaking of message "bodies", the "multipart/alternative" type is used to offer a list of
	/// alternative formats for the main body of the message (usually they will be "text/plain" and
	/// "text/html"). These alternatives are in order of increasing faithfulness to the original document
	/// (in other words, the last entity will be in a format that, when rendered, will most closely match
	/// what the sending client's WYSISYG editor produced).</para>
	/// <para>The "multipart/digest" type will typically contain a digest of MIME messages and is most
	/// commonly used by mailing-list software.</para>
	/// <para>The "multipart/parallel" type contains entities that are all meant to be shown (or heard)
	/// in parallel.</para>
	/// <para>Another commonly used type is the "multipart/related" type which contains, as one might expect,
	/// inter-related MIME parts which typically reference each other via URIs based on the Content-Id and/or
	/// Content-Location headers.</para>
	/// </remarks>
	public class Multipart : MimeEntity, ICollection<MimeEntity>, IList<MimeEntity>
	{
		readonly List<MimeEntity> children;
		string preamble, epilogue;

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// This constructor is used by <see cref="MimeParser"/>.
		/// </remarks>
		/// <param name="args">Information used by the constructor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		public Multipart (MimeEntityConstructorArgs args) : base (args)
		{
			children = new List<MimeEntity> ();
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with the specified subtype.
		/// </remarks>
		/// <param name="subtype">The multipart media sub-type.</param>
		/// <param name="args">An array of initialization parameters: headers and MIME entities.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="subtype"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="args"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="args"/> contains one or more arguments of an unknown type.
		/// </exception>
		public Multipart (string subtype, params object[] args) : this (subtype)
		{
			if (args == null)
				throw new ArgumentNullException (nameof (args));

			foreach (object obj in args) {
				if (obj == null || TryInit (obj))
					continue;

				if (obj is MimeEntity entity) {
					Add (entity);
					continue;
				}

				throw new ArgumentException ("Unknown initialization parameter: " + obj.GetType ());
			}
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with the specified subtype.
		/// </remarks>
		/// <param name="subtype">The multipart media sub-type.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="subtype"/> is <c>null</c>.
		/// </exception>
		public Multipart (string subtype) : base ("multipart", subtype)
		{
			ContentType.Boundary = GenerateBoundary ();
			children = new List<MimeEntity> ();
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="Multipart"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="Multipart"/> with a ContentType of multipart/mixed.
		/// </remarks>
		public Multipart () : this ("mixed")
		{
		}

		static string GenerateBoundary ()
		{
			var base64 = new Base64Encoder (true);
			var digest = new byte[16];
			var buf = new byte[24];
			int length;

			MimeUtils.GetRandomBytes (digest);

			length = base64.Flush (digest, 0, digest.Length, buf);

			return "=-" + Encoding.ASCII.GetString (buf, 0, length);
		}

		/// <summary>
		/// Get or set the boundary.
		/// </summary>
		/// <remarks>
		/// Gets or sets the boundary parameter on the Content-Type header.
		/// </remarks>
		/// <value>The boundary.</value>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		public string Boundary {
			get { return ContentType.Boundary; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				if (Boundary == value)
					return;

				ContentType.Boundary = value.Trim ();
			}
		}

		internal byte[] RawPreamble {
			get; set;
		}

		/// <summary>
		/// Get or set the preamble.
		/// </summary>
		/// <remarks>
		/// A multipart preamble appears before the first child entity of the
		/// multipart and is typically used only in the top-level multipart
		/// of the message to specify that the message is in MIME format and
		/// therefore requires a MIME compliant email application to render
		/// it correctly.
		/// </remarks>
		/// <value>The preamble.</value>
		public string Preamble {
			get {
				if (preamble == null && RawPreamble != null)
					preamble = CharsetUtils.ConvertToUnicode (Headers.Options, RawPreamble, 0, RawPreamble.Length);

				return preamble;
			}
			set {
				if (Preamble == value)
					return;

				if (value != null) {
					var folded = FoldPreambleOrEpilogue (FormatOptions.Default, value, false);
					RawPreamble = Encoding.UTF8.GetBytes (folded);
					preamble = folded;
				} else {
					RawPreamble = null;
					preamble = null;
				}

				WriteEndBoundary = true;
			}
		}

		internal byte[] RawEpilogue {
			get; set;
		}

		/// <summary>
		/// Get or set the epilogue.
		/// </summary>
		/// <remarks>
		/// A multipart epiloque is the text that appears after the closing boundary
		/// of the multipart and is typically either empty or a single new line
		/// character sequence.
		/// </remarks>
		/// <value>The epilogue.</value>
		public string Epilogue {
			get {
				if (epilogue == null && RawEpilogue != null) {
					int index = 0;

					// Note: In practice, the RawEpilogue contains the CRLF belonging to the end-boundary, but
					// for sanity, we pretend that it doesn't.
					if ((RawEpilogue.Length > 1 && RawEpilogue[0] == (byte) '\r' && RawEpilogue[1] == (byte) '\n'))
						index += 2;
					else if (RawEpilogue.Length > 1 && RawEpilogue[0] == (byte) '\n')
						index++;

					epilogue = CharsetUtils.ConvertToUnicode (Headers.Options, RawEpilogue, index, RawEpilogue.Length - index);
				}

				return epilogue;
			}
			set {
				if (Epilogue == value)
					return;

				if (value != null) {
					var folded = FoldPreambleOrEpilogue (FormatOptions.Default, value, true);
					RawEpilogue = Encoding.UTF8.GetBytes (folded);
					epilogue = null;
				} else {
					RawEpilogue = null;
					epilogue = null;
				}

				WriteEndBoundary = true;
			}
		}

		/// <summary>
		/// Get or set whether the end boundary should be written.
		/// </summary>
		/// <remarks>
		/// Gets or sets whether the end boundary should be written.
		/// </remarks>
		/// <value><c>true</c> if the end boundary should be written; otherwise, <c>false</c>.</value>
		internal bool WriteEndBoundary {
			get; set;
		}

		/// <summary>
		/// Dispatches to the specific visit method for this MIME entity.
		/// </summary>
		/// <remarks>
		/// This default implementation for <see cref="Multipart"/> nodes
		/// calls <see cref="MimeVisitor.VisitMultipart"/>. Override this
		/// method to call into a more specific method on a derived visitor class
		/// of the <see cref="MimeVisitor"/> class. However, it should still
		/// support unknown visitors by calling
		/// <see cref="MimeVisitor.VisitMultipart"/>.
		/// </remarks>
		/// <param name="visitor">The visitor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="visitor"/> is <c>null</c>.
		/// </exception>
		public override void Accept (MimeVisitor visitor)
		{
			if (visitor == null)
				throw new ArgumentNullException (nameof (visitor));

			visitor.VisitMultipart (this);
		}

		internal static string FoldPreambleOrEpilogue (FormatOptions options, string text, bool isEpilogue)
		{
			var builder = new StringBuilder ();
			int startIndex, wordIndex;
			int lineLength = 0;
			int index = 0;

			if (isEpilogue)
				builder.Append (options.NewLine);

			while (index < text.Length) {
				startIndex = index;

				while (index < text.Length) {
					if (!char.IsWhiteSpace (text[index]))
						break;

					if (text[index] == '\n') {
						builder.Append (options.NewLine);
						startIndex = index + 1;
						lineLength = 0;
					}

					index++;
				}

				wordIndex = index;

				while (index < text.Length && !char.IsWhiteSpace (text[index]))
					index++;

				int length = index - startIndex;

				if (lineLength > 0 && lineLength + length >= options.MaxLineLength) {
					builder.Append (options.NewLine);
					length = index - wordIndex;
					startIndex = wordIndex;
					lineLength = 0;
				}

				if (length > 0) {
					builder.Append (text, startIndex, length);
					lineLength += length;
				}
			}

			if (lineLength > 0)
				builder.Append (options.NewLine);

			return builder.ToString ();
		}

		static void WriteBytes (FormatOptions options, Stream stream, byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken)
		{
			var filter = options.CreateNewLineFilter (ensureNewLine);
			int index, length;

			var output = filter.Flush (bytes, 0, bytes.Length, out index, out length);

			if (stream is ICancellableStream cancellable) {
				cancellable.Write (output, index, length, cancellationToken);
			} else {
				cancellationToken.ThrowIfCancellationRequested ();
				stream.Write (output, index, length);
			}
		}

		static Task WriteBytesAsync (FormatOptions options, Stream stream, byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken)
		{
			var filter = options.CreateNewLineFilter (ensureNewLine);
			int index, length;

			var output = filter.Flush (bytes, 0, bytes.Length, out index, out length);

			return stream.WriteAsync (output, index, length, cancellationToken);
		}

		/// <summary>
		/// Prepare the MIME entity for transport using the specified encoding constraints.
		/// </summary>
		/// <remarks>
		/// Prepares the MIME entity for transport using the specified encoding constraints.
		/// </remarks>
		/// <param name="constraint">The encoding constraint.</param>
		/// <param name="maxLineLength">The maximum number of octets allowed per line (not counting the CRLF). Must be between <c>60</c> and <c>998</c> (inclusive).</param>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <para><paramref name="maxLineLength"/> is not between <c>60</c> and <c>998</c> (inclusive).</para>
		/// <para>-or-</para>
		/// <para><paramref name="constraint"/> is not a valid value.</para>
		/// </exception>
		public override void Prepare (EncodingConstraint constraint, int maxLineLength = 78)
		{
			if (maxLineLength < FormatOptions.MinimumLineLength || maxLineLength > FormatOptions.MaximumLineLength)
				throw new ArgumentOutOfRangeException (nameof (maxLineLength));

			for (int i = 0; i < children.Count; i++)
				children[i].Prepare (constraint, maxLineLength);
		}

		/// <summary>
		/// Write the <see cref="Multipart"/> to the specified output stream.
		/// </summary>
		/// <remarks>
		/// Writes the multipart MIME entity and its subparts to the output stream.
		/// </remarks>
		/// <param name="options">The formatting options.</param>
		/// <param name="stream">The output stream.</param>
		/// <param name="contentOnly"><c>true</c> if only the content should be written; otherwise, <c>false</c>.</param>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public override void WriteTo (FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken = default (CancellationToken))
		{
			base.WriteTo (options, stream, contentOnly, cancellationToken);

			if (ContentType.IsMimeType ("multipart", "signed")) {
				// don't reformat the headers or content of any children of a multipart/signed
				if (options.International || options.HiddenHeaders.Count > 0) {
					options = options.Clone ();
					options.HiddenHeaders.Clear ();
					options.International = false;
				}
			}

			if (RawPreamble != null && RawPreamble.Length > 0)
				WriteBytes (options, stream, RawPreamble, children.Count > 0 || EnsureNewLine, cancellationToken);

			var boundary = Encoding.ASCII.GetBytes ("--" + Boundary + "--");

			if (stream is ICancellableStream cancellable) {
				for (int i = 0; i < children.Count; i++) {
					var msg = children[i] as MessagePart;

					cancellable.Write (boundary, 0, boundary.Length - 2, cancellationToken);
					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
					children[i].WriteTo (options, stream, false, cancellationToken);

					if (msg?.Message != null && msg.Message.Body != null) {
						multi = msg.Message.Body as Multipart;
						part = msg.Message.Body as MimePart;
					}

					if ((children[i] is MimePart part && part.Content == null) ||
						(children[i] is Multipart multi && !multi.WriteEndBoundary))
						continue;

					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
				}

				if (!WriteEndBoundary)
					return;

				cancellable.Write (boundary, 0, boundary.Length, cancellationToken);

				if (RawEpilogue == null)
					cancellable.Write (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken);
			} else {
				for (int i = 0; i < children.Count; i++) {
					var rfc822 = children[i] as MessagePart;

					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (boundary, 0, boundary.Length - 2);
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
					children[i].WriteTo (options, stream, false, cancellationToken);

					if (rfc822?.Message != null && rfc822.Message.Body != null) {
						multi = rfc822.Message.Body as Multipart;
						part = rfc822.Message.Body as MimePart;
					}

					if ((children[i] is MimePart part && part.Content == null) ||
						(children[i] is Multipart multi && !multi.WriteEndBoundary))
						continue;

					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
				}

				if (!WriteEndBoundary)
					return;

				cancellationToken.ThrowIfCancellationRequested ();
				stream.Write (boundary, 0, boundary.Length);

				if (RawEpilogue == null) {
					cancellationToken.ThrowIfCancellationRequested ();
					stream.Write (options.NewLineBytes, 0, options.NewLineBytes.Length);
				}
			}

			if (RawEpilogue != null && RawEpilogue.Length > 0)
				WriteBytes (options, stream, RawEpilogue, EnsureNewLine, cancellationToken);
		}

		/// <summary>
		/// Asynchronously write the <see cref="Multipart"/> to the specified output stream.
		/// </summary>
		/// <remarks>
		/// Asynchronously writes the multipart MIME entity and its subparts to the output stream.
		/// </remarks>
		/// <returns>An awaitable task.</returns>
		/// <param name="options">The formatting options.</param>
		/// <param name="stream">The output stream.</param>
		/// <param name="contentOnly"><c>true</c> if only the content should be written; otherwise, <c>false</c>.</param>
		/// <param name="cancellationToken">The cancellation token.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <para><paramref name="options"/> is <c>null</c>.</para>
		/// <para>-or-</para>
		/// <para><paramref name="stream"/> is <c>null</c>.</para>
		/// </exception>
		/// <exception cref="System.OperationCanceledException">
		/// The operation was canceled via the cancellation token.
		/// </exception>
		/// <exception cref="System.IO.IOException">
		/// An I/O error occurred.
		/// </exception>
		public override async Task WriteToAsync (FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken = default (CancellationToken))
		{
			await base.WriteToAsync (options, stream, contentOnly, cancellationToken).ConfigureAwait (false);

			if (ContentType.IsMimeType ("multipart", "signed")) {
				// don't hide or reformat the headers of any children of a multipart/signed
				if (options.International || options.HiddenHeaders.Count > 0) {
					options = options.Clone ();
					options.HiddenHeaders.Clear ();
					options.International = false;
				}
			}

			if (RawPreamble != null && RawPreamble.Length > 0)
				await WriteBytesAsync (options, stream, RawPreamble, children.Count > 0 || EnsureNewLine, cancellationToken).ConfigureAwait (false);

			var boundary = Encoding.ASCII.GetBytes ("--" + Boundary + "--");

			for (int i = 0; i < children.Count; i++) {
				var msg = children[i] as MessagePart;

				await stream.WriteAsync (boundary, 0, boundary.Length - 2, cancellationToken).ConfigureAwait (false);
				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);
				await children[i].WriteToAsync (options, stream, false, cancellationToken).ConfigureAwait (false);

				if (msg?.Message != null && msg.Message.Body != null) {
					multi = msg.Message.Body as Multipart;
					part = msg.Message.Body as MimePart;
				}

				if ((children[i] is MimePart part && part.Content == null) ||
				    (children[i] is Multipart multi && !multi.WriteEndBoundary))
					continue;

				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);
			}

			if (!WriteEndBoundary)
				return;

			await stream.WriteAsync (boundary, 0, boundary.Length, cancellationToken).ConfigureAwait (false);

			if (RawEpilogue == null)
				await stream.WriteAsync (options.NewLineBytes, 0, options.NewLineBytes.Length, cancellationToken).ConfigureAwait (false);

			if (RawEpilogue != null && RawEpilogue.Length > 0)
				await WriteBytesAsync (options, stream, RawEpilogue, EnsureNewLine, cancellationToken).ConfigureAwait (false);
		}

		#region ICollection implementation

		/// <summary>
		/// Get the number of parts in the multipart.
		/// </summary>
		/// <remarks>
		/// Indicates the number of parts in the multipart.
		/// </remarks>
		/// <value>The number of parts in the multipart.</value>
		public int Count {
			get { return children.Count; }
		}

		/// <summary>
		/// Get a value indicating whether this instance is read only.
		/// </summary>
		/// <remarks>
		/// A <see cref="Multipart"/> is never read-only.
		/// </remarks>
		/// <value><c>true</c> if this instance is read only; otherwise, <c>false</c>.</value>
		public bool IsReadOnly {
			get { return false; }
		}

		/// <summary>
		/// Add an entity to the multipart.
		/// </summary>
		/// <remarks>
		/// Adds the specified part to the multipart.
		/// </remarks>
		/// <param name="part">The part to add.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public void Add (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			WriteEndBoundary = true;
			children.Add (part);
		}

		/// <summary>
		/// Clear a multipart.
		/// </summary>
		/// <remarks>
		/// Removes all of the parts within the multipart.
		/// </remarks>
		public void Clear ()
		{
			WriteEndBoundary = true;
			children.Clear ();
		}

		/// <summary>
		/// Check if the <see cref="Multipart"/> contains the specified part.
		/// </summary>
		/// <remarks>
		/// Determines whether or not the multipart contains the specified part.
		/// </remarks>
		/// <returns><value>true</value> if the specified part exists;
		/// otherwise <value>false</value>.</returns>
		/// <param name="part">The part to check for.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public bool Contains (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			return children.Contains (part);
		}

		/// <summary>
		/// Copy all of the entities in the <see cref="Multipart"/> to the specified array.
		/// </summary>
		/// <remarks>
		/// Copies all of the entities within the <see cref="Multipart"/> into the array,
		/// starting at the specified array index.
		/// </remarks>
		/// <param name="array">The array to copy the headers to.</param>
		/// <param name="arrayIndex">The index into the array.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="array"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="arrayIndex"/> is out of range.
		/// </exception>
		public void CopyTo (MimeEntity[] array, int arrayIndex)
		{
			children.CopyTo (array, arrayIndex);
		}

		/// <summary>
		/// Remove an entity from the multipart.
		/// </summary>
		/// <remarks>
		/// Removes the specified part, if it exists within the multipart.
		/// </remarks>
		/// <returns><value>true</value> if the part was removed; otherwise <value>false</value>.</returns>
		/// <param name="part">The part to remove.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public bool Remove (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			if (!children.Remove (part))
				return false;

			WriteEndBoundary = true;

			return true;
		}

		#endregion

		#region IList implementation

		/// <summary>
		/// Get the index of an entity.
		/// </summary>
		/// <remarks>
		/// Finds the index of the specified part, if it exists.
		/// </remarks>
		/// <returns>The index of the specified part if found; otherwise <c>-1</c>.</returns>
		/// <param name="part">The part.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		public int IndexOf (MimeEntity part)
		{
			if (part == null)
				throw new ArgumentNullException (nameof (part));

			return children.IndexOf (part);
		}

		/// <summary>
		/// Insert an entity into the <see cref="Multipart"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Inserts the part into the multipart at the specified index.
		/// </remarks>
		/// <param name="index">The index.</param>
		/// <param name="part">The part.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="part"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public void Insert (int index, MimeEntity part)
		{
			if (index < 0 || index > children.Count)
				throw new ArgumentOutOfRangeException (nameof (index));

			if (part == null)
				throw new ArgumentNullException (nameof (part));

			children.Insert (index, part);
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Remove an entity from the <see cref="Multipart"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Removes the entity at the specified index.
		/// </remarks>
		/// <param name="index">The index.</param>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public void RemoveAt (int index)
		{
			children.RemoveAt (index);
			WriteEndBoundary = true;
		}

		/// <summary>
		/// Get or set the <see cref="MimeEntity"/> at the specified index.
		/// </summary>
		/// <remarks>
		/// Gets or sets the <see cref="MimeEntity"/> at the specified index.
		/// </remarks>
		/// <value>The entity at the specified index.</value>
		/// <param name="index">The index.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="value"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentOutOfRangeException">
		/// <paramref name="index"/> is out of range.
		/// </exception>
		public MimeEntity this[int index] {
			get { return children[index]; }
			set {
				if (value == null)
					throw new ArgumentNullException (nameof (value));

				WriteEndBoundary = true;
				children[index] = value;
			}
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Get the enumerator for the children of the <see cref="Multipart"/>.
		/// </summary>
		/// <remarks>
		/// Gets the enumerator for the children of the <see cref="Multipart"/>.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		public IEnumerator<MimeEntity> GetEnumerator ()
		{
			return children.GetEnumerator ();
		}

		#endregion

		#region IEnumerable implementation

		/// <summary>
		/// Get the enumerator for the children of the <see cref="Multipart"/>.
		/// </summary>
		/// <remarks>
		/// Gets the enumerator for the children of the <see cref="Multipart"/>.
		/// </remarks>
		/// <returns>The enumerator.</returns>
		IEnumerator IEnumerable.GetEnumerator ()
		{
			return children.GetEnumerator ();
		}

		#endregion
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\Multipart.cs(449,7): error CS0841: Cannot use local variable 'multi' before it is declared,D:\a\1\s\MimeKit\Multipart.cs(450,7): error CS0841: Cannot use local variable 'part' before it is declared,D:\a\1\s\MimeKit\Multipart.cs(477,7): error CS0841: Cannot use local variable 'multi' before it is declared,D:\a\1\s\MimeKit\Multipart.cs(478,7): error CS0841: Cannot use local variable 'part' before it is declared,D:\a\1\s\MimeKit\Multipart.cs(553,6): error CS0841: Cannot use local variable 'multi' before it is declared,D:\a\1\s\MimeKit\Multipart.cs(554,6): error CS0841: Cannot use local variable 'part' before it is declared
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\MimeKit\MultipartAlternative.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;

using MimeKit.Text;

namespace MimeKit {
	/// <summary>
	/// A multipart/alternative MIME entity.
	/// </summary>
	/// <remarks>
	/// A multipart/alternative MIME entity contains, as one might expect, is used to offer a list of
	/// alternative formats for the main body of the message (usually they will be "text/plain" and
	/// "text/html"). These alternatives are in order of increasing faithfulness to the original document
	/// (in other words, the last entity will be in a format that, when rendered, will most closely match
	/// what the sending client's WYSISYG editor produced).
	/// </remarks>
	public class MultipartAlternative : Multipart
	{
		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// This constructor is used by <see cref="MimeParser"/>.
		/// </remarks>
		/// <param name="args">Information used by the constructor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		public MultipartAlternative (MimeEntityConstructorArgs args) : base (args)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MultipartAlternative"/> part.
		/// </remarks>
		/// <param name="args">An array of initialization parameters: headers and MIME entities.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="args"/> contains one or more arguments of an unknown type.
		/// </exception>
		public MultipartAlternative (params object[] args) : base ("alternative", args)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MultipartAlternative"/> part.
		/// </remarks>
		public MultipartAlternative () : base ("alternative")
		{
		}

		/// <summary>
		/// Get the text of the text/plain alternative.
		/// </summary>
		/// <remarks>
		/// Gets the text of the text/plain alternative, if it exists.
		/// </remarks>
		/// <value>The text if a text/plain alternative exists; otherwise, <c>null</c>.</value>
		public string TextBody {
			get { return GetTextBody (TextFormat.Plain); }
		}

		/// <summary>
		/// Get the HTML-formatted text of the text/html alternative.
		/// </summary>
		/// <remarks>
		/// Gets the HTML-formatted text of the text/html alternative, if it exists.
		/// </remarks>
		/// <value>The HTML if a text/html alternative exists; otherwise, <c>null</c>.</value>
		public string HtmlBody {
			get { return GetTextBody (TextFormat.Html); }
		}

		/// <summary>
		/// Dispatches to the specific visit method for this MIME entity.
		/// </summary>
		/// <remarks>
		/// This default implementation for <see cref="MultipartAlternative"/> nodes
		/// calls <see cref="MimeVisitor.VisitMultipartAlternative"/>. Override this
		/// method to call into a more specific method on a derived visitor class
		/// of the <see cref="MimeVisitor"/> class. However, it should still
		/// support unknown visitors by calling
		/// <see cref="MimeVisitor.VisitMultipartAlternative"/>.
		/// </remarks>
		/// <param name="visitor">The visitor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="visitor"/> is <c>null</c>.
		/// </exception>
		public override void Accept (MimeVisitor visitor)
		{
			if (visitor == null)
				throw new ArgumentNullException (nameof (visitor));

			visitor.VisitMultipartAlternative (this);
		}

		internal static string GetText (TextPart text)
		{
			if (text.IsFlowed) {
				var converter = new FlowedToText ();
				string delsp;

				if (text.ContentType.Parameters.TryGetValue ("delsp", out delsp))
					converter.DeleteSpace = delsp.ToLowerInvariant () == "yes";

				return converter.Convert (text.Text);
			}

			return text.Text;
		}

		/// <summary>
		/// Get the text body in the specified format.
		/// </summary>
		/// <remarks>
		/// Gets the text body in the specified format, if it exists.
		/// </remarks>
		/// <returns>The text body in the desired format if it exists; otherwise, <c>null</c>.</returns>
		/// <param name="format">The desired text format.</param>
		public string GetTextBody (TextFormat format)
		{
			// walk the multipart/alternative children backwards from greatest level of faithfulness to the least faithful
			for (int i = Count - 1; i >= 0; i--) {
				var alternative = this[i] as MultipartAlternative;

				if (alternative != null) {
					// Note: nested multipart/alternative parts make no sense... yet here we are.
					return alternative.GetTextBody (format);
				}

				var related = this[i] as MultipartRelated;
				var text = this[i] as TextPart;

				if (related != null) {
					var root = related.Root;

					alternative = root as MultipartAlternative;
					if (alternative != null)
						return alternative.GetTextBody (format);

					text = root as TextPart;
				}

				if (text != null && text.IsFormat (format))
					return GetText (text);
			}

			return null;
		}
	}
}

---- Transformed Tree ----
using System;

using MimeKit.Text;

namespace MimeKit {
	/// <summary>
	/// A multipart/alternative MIME entity.
	/// </summary>
	/// <remarks>
	/// A multipart/alternative MIME entity contains, as one might expect, is used to offer a list of
	/// alternative formats for the main body of the message (usually they will be "text/plain" and
	/// "text/html"). These alternatives are in order of increasing faithfulness to the original document
	/// (in other words, the last entity will be in a format that, when rendered, will most closely match
	/// what the sending client's WYSISYG editor produced).
	/// </remarks>
	public class MultipartAlternative : Multipart
	{
		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// This constructor is used by <see cref="MimeParser"/>.
		/// </remarks>
		/// <param name="args">Information used by the constructor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		public MultipartAlternative (MimeEntityConstructorArgs args) : base (args)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MultipartAlternative"/> part.
		/// </remarks>
		/// <param name="args">An array of initialization parameters: headers and MIME entities.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="args"/> is <c>null</c>.
		/// </exception>
		/// <exception cref="System.ArgumentException">
		/// <paramref name="args"/> contains one or more arguments of an unknown type.
		/// </exception>
		public MultipartAlternative (params object[] args) : base ("alternative", args)
		{
		}

		/// <summary>
		/// Initialize a new instance of the <see cref="MultipartAlternative"/> class.
		/// </summary>
		/// <remarks>
		/// Creates a new <see cref="MultipartAlternative"/> part.
		/// </remarks>
		public MultipartAlternative () : base ("alternative")
		{
		}

		/// <summary>
		/// Get the text of the text/plain alternative.
		/// </summary>
		/// <remarks>
		/// Gets the text of the text/plain alternative, if it exists.
		/// </remarks>
		/// <value>The text if a text/plain alternative exists; otherwise, <c>null</c>.</value>
		public string TextBody {
			get { return GetTextBody (TextFormat.Plain); }
		}

		/// <summary>
		/// Get the HTML-formatted text of the text/html alternative.
		/// </summary>
		/// <remarks>
		/// Gets the HTML-formatted text of the text/html alternative, if it exists.
		/// </remarks>
		/// <value>The HTML if a text/html alternative exists; otherwise, <c>null</c>.</value>
		public string HtmlBody {
			get { return GetTextBody (TextFormat.Html); }
		}

		/// <summary>
		/// Dispatches to the specific visit method for this MIME entity.
		/// </summary>
		/// <remarks>
		/// This default implementation for <see cref="MultipartAlternative"/> nodes
		/// calls <see cref="MimeVisitor.VisitMultipartAlternative"/>. Override this
		/// method to call into a more specific method on a derived visitor class
		/// of the <see cref="MimeVisitor"/> class. However, it should still
		/// support unknown visitors by calling
		/// <see cref="MimeVisitor.VisitMultipartAlternative"/>.
		/// </remarks>
		/// <param name="visitor">The visitor.</param>
		/// <exception cref="System.ArgumentNullException">
		/// <paramref name="visitor"/> is <c>null</c>.
		/// </exception>
		public override void Accept (MimeVisitor visitor)
		{
			if (visitor == null)
				throw new ArgumentNullException (nameof (visitor));

			visitor.VisitMultipartAlternative (this);
		}

		internal static string GetText (TextPart text)
		{
			if (text.IsFlowed) {
				var converter = new FlowedToText ();
				string delsp;

				if (text.ContentType.Parameters.TryGetValue ("delsp", out delsp))
					converter.DeleteSpace = delsp.ToLowerInvariant () == "yes";

				return converter.Convert (text.Text);
			}

			return text.Text;
		}

		/// <summary>
		/// Get the text body in the specified format.
		/// </summary>
		/// <remarks>
		/// Gets the text body in the specified format, if it exists.
		/// </remarks>
		/// <returns>The text body in the desired format if it exists; otherwise, <c>null</c>.</returns>
		/// <param name="format">The desired text format.</param>
		public string GetTextBody (TextFormat format)
		{
			// walk the multipart/alternative children backwards from greatest level of faithfulness to the least faithful
			for (int i = Count - 1; i >= 0; i--) {
				if (this[i] is MultipartAlternative alternative) {
					// Note: nested multipart/alternative parts make no sense... yet here we are.
					return alternative.GetTextBody (format);
				}

				if (this[i] is MultipartRelated related) {
					var root = related.Root;

					alternative = root as MultipartAlternative;

					if (this[i] is MultipartAlternative alternative)
						return alternative.GetTextBody (format);

					text = root as TextPart;
				}

				if (this[i] is TextPart text && text.IsFormat (format))
					return GetText (text);
			}

			return null;
		}
	}
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\MimeKit\MultipartAlternative.cs(165,6): error CS0841: Cannot use local variable 'alternative' before it is declared,D:\a\1\s\MimeKit\MultipartAlternative.cs(167,42): error CS0136: A local or parameter named 'alternative' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\MimeKit\MultipartAlternative.cs(170,6): error CS0841: Cannot use local variable 'text' before it is declared
######################################################################


