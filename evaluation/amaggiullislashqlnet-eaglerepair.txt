Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: QLNet(netstandard1.2)
    #1 Path: D:\a\1\s\src\QLNet\Cashflows\CashFlows.cs, Line: 362, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #2 Path: D:\a\1\s\src\QLNet\Cashflows\CouponPricer.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\src\QLNet\Cashflows\CouponPricer.cs, Line: 318, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #4 Path: D:\a\1\s\src\QLNet\Cashflows\CPICoupon.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #5 Path: D:\a\1\s\src\QLNet\Instruments\AssetSwap.cs, Line: 433, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #6 Path: D:\a\1\s\src\QLNet\Instruments\BasisSwap.cs, Line: 254, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\QLNet\Instruments\Bonds\CallableBond.cs, Line: 580, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\src\QLNet\Instruments\Bonds\ConvertibleBond.cs, Line: 175, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #9 Path: D:\a\1\s\src\QLNet\Instruments\CPISwap.cs, Line: 270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\src\QLNet\Instruments\FloatFloatSwap.cs, Line: 191, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #11 Path: D:\a\1\s\src\QLNet\Instruments\FloatFloatSwap.cs, Line: 208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\src\QLNet\Instruments\FloatFloatSwap.cs, Line: 235, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #13 Path: D:\a\1\s\src\QLNet\Instruments\FloatFloatSwap.cs, Line: 252, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #14 Path: D:\a\1\s\src\QLNet\Instruments\VanillaSwap.cs, Line: 250, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #15 Path: D:\a\1\s\src\QLNet\Instruments\YearOnYearInflationSwap.cs, Line: 209, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\QLNet\InterestRate.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\src\QLNet\Math\Vector.cs, Line: 135, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\QLNet\Methods\Finitedifferences\Meshers\FdmBlackScholesMesher.cs, Line: 179, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #19 Path: D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticBinaryBarrierEngine.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticBinaryBarrierEngine.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\QLNet\Pricingengines\BlackCalculator.cs, Line: 341, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #22 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #24 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #25 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 159, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 163, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #28 Path: D:\a\1\s\src\QLNet\Pricingengines\credit\IsdaCdsEngine.cs, Line: 167, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #29 Path: D:\a\1\s\src\QLNet\Pricingengines\vanilla\FDDividendEngine.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\src\QLNet\processes\BlackScholesProcess.cs, Line: 201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #31 Path: D:\a\1\s\src\QLNet\processes\BlackScholesProcess.cs, Line: 213, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\QLNet\Time\Calendars\BespokeCalendar.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\QLNet\Time\Schedule.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: QLNet.Tests
    #34 Path: D:\a\1\s\tests\QLNet.Tests\T_AmericanOption.cs, Line: 635, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #35 Path: D:\a\1\s\tests\QLNet.Tests\T_AmericanOption.cs, Line: 689, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #36 Path: D:\a\1\s\tests\QLNet.Tests\T_AsianOptions.cs, Line: 54, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #37 Path: D:\a\1\s\tests\QLNet.Tests\T_Bonds.cs, Line: 1328, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #38 Path: D:\a\1\s\tests\QLNet.Tests\T_CPISwap.cs, Line: 313, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\tests\QLNet.Tests\T_CPISwap.cs, Line: 339, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\tests\QLNet.Tests\T_CPISwap.cs, Line: 487, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: BermudanSwaption
    #41 Path: D:\a\1\s\src\BermudanSwaption\BermudanSwaption.cs, Line: 199, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971



--- Rules Summary ---
R8: 30
R9: 5
R7: 3
R4: 2
R2: 1

--- Summary ---
Fixed ReSharper issues: 40
Fixed SonarQube issues: 2
Total fixed issues: 41

Finished in: 24 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\QLNet\Cashflows\CashFlows.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Leg = System.Collections.Generic.List<QLNet.CashFlow>;


namespace QLNet
{
   //! %cashflow-analysis functions
   public class CashFlows
   {
      #region utility functions

      private static double aggregateRate(Leg leg, CashFlow cf)
      {
         if (cf == null)
            return 0.0;

         Date paymentDate = cf.date();
         bool firstCouponFound = false;
         double nominal = 0.0;
         double accrualPeriod = 0.0;
         DayCounter dc = null;
         double result = 0.0;

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
            {
               if (firstCouponFound)
               {
                  Utils.QL_REQUIRE(nominal.IsEqual(cp.nominal()) &&
                                   accrualPeriod.IsEqual(cp.accrualPeriod()) &&
                                   dc == cp.dayCounter(), () =>
                                   "cannot aggregate two different coupons on "
                                   + paymentDate);
               }
               else
               {
                  firstCouponFound = true;
                  nominal = cp.nominal();
                  accrualPeriod = cp.accrualPeriod();
                  dc = cp.dayCounter();
               }
               result += cp.rate();
            }
         }

         Utils.QL_REQUIRE(firstCouponFound, () => "no coupon paid at cashflow date " + paymentDate);
         return result;
      }
      public static double simpleDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                          Date settlementDate, Date npvDate)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double P = 0.0;
         double dPdy = 0.0;
         double t = 0.0;
         Date lastDate = npvDate;

         DayCounter dc = y.dayCounter();
         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);
            double B = y.discountFactor(t);
            P += c * B;
            dPdy += t * c * B;

            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0)) // no cashflows
            return 0.0;
         return dPdy / P;
      }
      public static double modifiedDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                            Date settlementDate, Date npvDate)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double P = 0.0;
         double t = 0.0;
         double dPdy = 0.0;
         double r = y.rate();
         int N = (int)y.frequency();
         Date lastDate = npvDate;
         DayCounter dc = y.dayCounter();

         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);

            double B = y.discountFactor(t);
            P += c * B;
            switch (y.compounding())
            {
               case Compounding.Simple:
                  dPdy -= c * B * B * t;
                  break;
               case Compounding.Compounded:
                  dPdy -= c * t * B / (1 + r / N);
                  break;
               case Compounding.Continuous:
                  dPdy -= c * B * t;
                  break;
               case Compounding.SimpleThenCompounded:
                  if (t <= 1.0 / N)
                     dPdy -= c * B * B * t;
                  else
                     dPdy -= c * t * B / (1 + r / N);
                  break;
               default:
                  Utils.QL_FAIL("unknown compounding convention (" + y.compounding() + ")");
                  break;
            }
            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0)) // no cashflows
            return 0.0;
         return -dPdy / P; // reverse derivative sign
      }

      public static double macaulayDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                            Date settlementDate, Date npvDate)
      {
         Utils.QL_REQUIRE(y.compounding() == Compounding.Compounded, () => "compounded rate required");

         return (1.0 + y.rate() / (int)y.frequency()) *
                modifiedDuration(leg, y, includeSettlementDateFlows, settlementDate, npvDate);
      }

      // helper function used to calculate Time-To-Discount for each stage when calculating discount factor stepwisely
      public static double getStepwiseDiscountTime(CashFlow cashFlow, DayCounter dc, Date npvDate, Date lastDate)
      {
         Date cashFlowDate = cashFlow.date();
         Date refStartDate, refEndDate;
         Coupon coupon = cashFlow as Coupon;
         if (coupon != null)
         {
            refStartDate = coupon.referencePeriodStart;
            refEndDate = coupon.referencePeriodEnd;
         }
         else
         {
            if (lastDate == npvDate)
            {
               // we don't have a previous coupon date,
               // so we fake it
               refStartDate = cashFlowDate - new Period(1, TimeUnit.Years);
            }
            else
            {
               refStartDate = lastDate;
            }

            refEndDate = cashFlowDate;

         }

         if (coupon != null && lastDate != coupon.accrualStartDate())
         {
            double couponPeriod = dc.yearFraction(coupon.accrualStartDate(), cashFlowDate, refStartDate, refEndDate);
            double accruedPeriod = dc.yearFraction(coupon.accrualStartDate(), lastDate, refStartDate, refEndDate);
            return couponPeriod - accruedPeriod;
         }
         else
         {
            return dc.yearFraction(lastDate, cashFlowDate, refStartDate, refEndDate);
         }
      }


      #endregion

      #region Helper Classes

      class IrrFinder : ISolver1d
      {
         private Leg leg_;
         private double npv_;
         private DayCounter dayCounter_;
         private Compounding compounding_;
         private Frequency frequency_;
         private bool includeSettlementDateFlows_;
         private Date settlementDate_, npvDate_;

         public IrrFinder(Leg leg, double npv, DayCounter dayCounter, Compounding comp, Frequency freq,
                          bool includeSettlementDateFlows, Date settlementDate, Date npvDate)
         {
            leg_ = leg;
            npv_ = npv;
            dayCounter_ = dayCounter;
            compounding_ = comp;
            frequency_ = freq;
            includeSettlementDateFlows_ = includeSettlementDateFlows;
            settlementDate_ = settlementDate;
            npvDate_ = npvDate;

            if (settlementDate == null)
               settlementDate_ = Settings.evaluationDate();

            if (npvDate == null)
               npvDate_ = settlementDate_;

            checkSign();
         }

         public override double value(double y)
         {
            InterestRate yield = new InterestRate(y, dayCounter_, compounding_, frequency_);
            double NPV = CashFlows.npv(leg_, yield, includeSettlementDateFlows_, settlementDate_, npvDate_);
            return npv_ - NPV;
         }

         public override double derivative(double y)
         {
            InterestRate yield = new InterestRate(y, dayCounter_, compounding_, frequency_);
            return modifiedDuration(leg_, yield, includeSettlementDateFlows_, settlementDate_, npvDate_);
         }

         private void checkSign()
         {
            // depending on the sign of the market price, check that cash
            // flows of the opposite sign have been specified (otherwise
            // IRR is nonsensical.)

            int lastSign = Math.Sign(-npv_), signChanges = 0;
            for (int i = 0; i < leg_.Count; ++i)
            {
               if (!leg_[i].hasOccurred(settlementDate_, includeSettlementDateFlows_) &&
                   !leg_[i].tradingExCoupon(settlementDate_))
               {
                  int thisSign = Math.Sign(leg_[i].amount());
                  if (lastSign * thisSign < 0) // sign change
                     signChanges++;

                  if (thisSign != 0)
                     lastSign = thisSign;
               }
            }
            Utils.QL_REQUIRE(signChanges > 0, () =>
                             "the given cash flows cannot result in the given market " +
                             "price due to their sign", QLNetExceptionEnum.InvalidPriceSignException);
         }
      }
      class ZSpreadFinder : ISolver1d
      {
         private Leg leg_;
         private double npv_;
         private SimpleQuote zSpread_;
         ZeroSpreadedTermStructure curve_;
         private bool includeSettlementDateFlows_;
         private Date settlementDate_, npvDate_;

         public ZSpreadFinder(Leg leg, YieldTermStructure discountCurve, double npv, DayCounter dc, Compounding comp, Frequency freq,
                              bool includeSettlementDateFlows, Date settlementDate, Date npvDate)
         {
            leg_ = leg;
            npv_ = npv;
            zSpread_ = new SimpleQuote(0.0);
            curve_ = new ZeroSpreadedTermStructure(new Handle<YieldTermStructure>(discountCurve),
                                                   new Handle<Quote>(zSpread_), comp, freq, dc);
            includeSettlementDateFlows_ = includeSettlementDateFlows;
            settlementDate_ = settlementDate;
            npvDate_ = npvDate;

            if (settlementDate == null)
               settlementDate_ = Settings.evaluationDate();

            if (npvDate == null)
               npvDate_ = settlementDate_;

            // if the discount curve allows extrapolation, let's
            // the spreaded curve do too.
            curve_.enableExtrapolation(discountCurve.allowsExtrapolation());
         }

         public override double value(double zSpread)
         {
            zSpread_.setValue(zSpread);
            double NPV = CashFlows.npv(leg_, curve_, includeSettlementDateFlows_, settlementDate_, npvDate_);
            return npv_ - NPV;
         }


      }
      class BPSCalculator : IAcyclicVisitor
      {
         private YieldTermStructure discountCurve_;
         double bps_, nonSensNPV_;

         public BPSCalculator(YieldTermStructure discountCurve)
         {
            discountCurve_ = discountCurve;
            nonSensNPV_ = 0.0;
            bps_ = 0.0;
         }

         #region IAcyclicVisitor pattern
         // visitor classes should implement the generic visit method in the following form
         public void visit(object o)
         {
            Type[] types = new Type[] { o.GetType() };
            MethodInfo methodInfo = Utils.GetMethodInfo(this, "visit", types);

            methodInfo?.Invoke(this, new object[]{o});
         }
         public void visit(Coupon c)
         {
            double bps = c.nominal() *
                         c.accrualPeriod() *
                         discountCurve_.discount(c.date());
            bps_ += bps;
         }
         public void visit(CashFlow cf)
         {
            nonSensNPV_ += cf.amount() * discountCurve_.discount(cf.date());
         }
         #endregion

         public double bps() { return bps_; }
         public double nonSensNPV() { return nonSensNPV_; }
      }
      #endregion

      #region Date functions
      public static Date startDate(Leg leg)
      {
         Utils.QL_REQUIRE(!leg.empty(), () => "empty leg");
         Date d = Date.maxDate();
         for (int i = 0; i < leg.Count; ++i)
         {
            Coupon c = leg[i] as Coupon;
            if (c != null)
               d = Date.Min(d, c.accrualStartDate());
            else
               d = Date.Min(d, leg[i].date());
         }
         return d;
      }
      public static Date maturityDate(Leg leg)
      {
         Utils.QL_REQUIRE(!leg.empty(), () => "empty leg");
         Date d = Date.minDate();
         for (int i = 0; i < leg.Count; ++i)
         {
            Coupon c = leg[i] as Coupon;
            if (c != null)
               d = Date.Max(d, c.accrualEndDate());
            else
               d = Date.Max(d, leg[i].date());
         }
         return d;
      }
      public static bool isExpired(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return true;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         for (int i = leg.Count; i > 0; --i)
            if (!leg[i - 1].hasOccurred(settlementDate, includeSettlementDateFlows))
               return false;
         return true;
      }
      #endregion

      #region CashFlow functions
      //! the last cashflow paying before or at the given date
      public static CashFlow previousCashFlow(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return null;

         Date d = (settlementDate ?? Settings.evaluationDate());
         return  leg.LastOrDefault(x => x.hasOccurred(d, includeSettlementDateFlows));
      }
      //! the first cashflow paying after the given date
      public static CashFlow nextCashFlow(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return null;

         Date d = (settlementDate ?? Settings.evaluationDate());

         // the first coupon paying after d is the one we're after
         return leg.FirstOrDefault(x => !x.hasOccurred(d, includeSettlementDateFlows));
      }
      public static Date previousCashFlowDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         return cf.date();
      }
      public static Date nextCashFlowDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         return cf.date();
      }
      public static double? previousCashFlowAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {

         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         Date paymentDate = cf.date();
         double? result = 0.0;
         result = leg.Where(cf1 => cf1.date() == paymentDate).Sum(cf1 => cf1.amount());
         return result;

      }
      public static double? nextCashFlowAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         Date paymentDate = cf.date();
         double result = 0.0;
         result = leg.Where(cf1 => cf1.date() == paymentDate).Sum(cf1 => cf1.amount());
         return result;
      }
      #endregion

      #region Coupon inspectors

      public static double previousCouponRate(List<CashFlow> leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);
         return aggregateRate(leg, cf);
      }
      public static double nextCouponRate(List<CashFlow> leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         return aggregateRate(leg, cf);
      }
      public static double nominal(Leg leg, bool includeSettlementDateFlows,  Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0.0;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.nominal();
         }
         return 0.0;
      }
      public static Date accrualStartDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accrualStartDate();
         }
         return null;
      }
      public static Date accrualEndDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accrualEndDate();
         }
         return null;
      }
      public static Date referencePeriodStart(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.referencePeriodStart;
         }
         return null;
      }
      public static Date referencePeriodEnd(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.referencePeriodEnd;
         }
         return null;
      }
      public static double accrualPeriod(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accrualPeriod();
         }
         return 0;
      }
      public static int accrualDays(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accrualDays();
         }
         return 0;
      }
      public static double accruedPeriod(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows,  settlementDate);
         if (cf == null)
            return 0;

         Date paymentDate = cf.date();
         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accruedPeriod(settlementDate);
         }
         return 0;
      }
      public static int accruedDays(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               return cp.accruedDays(settlementDate);
         }
         return 0;
      }
      public static double accruedAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;

         Date paymentDate = cf.date();
         double result = 0.0;

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            Coupon cp = x as Coupon;
            if (cp != null)
               result += cp.accruedAmount(settlementDate);
         }
         return result;
      }
      #endregion

      #region YieldTermStructure functions

      //! NPV of the cash flows. The NPV is the sum of the cash flows, each discounted according to the given term structure.
      public static double npv(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {

         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double totalNPV = 0.0;
         for (int i = 0; i < leg.Count; ++i)
         {
            if (!leg[i].hasOccurred(settlementDate, includeSettlementDateFlows) && !leg[i].tradingExCoupon(settlementDate))
               totalNPV += leg[i].amount() * discountCurve.discount(leg[i].date());
         }

         return totalNPV / discountCurve.discount(npvDate);
      }

      // Basis-point sensitivity of the cash flows.
      // The result is the change in NPV due to a uniform 1-basis-point change in the rate paid by the cash flows. The change for each coupon is discounted according to the given term structure.
      public static double bps(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         BPSCalculator calc = new BPSCalculator(discountCurve);
         for (int i = 0; i < leg.Count; ++i)
         {
            if (!leg[i].hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !leg[i].tradingExCoupon(settlementDate))
               leg[i].accept(calc);
         }
         return Const.BASIS_POINT * calc.bps() / discountCurve.discount(npvDate);
      }
      //! NPV and BPS of the cash flows.
      // The NPV and BPS of the cash flows calculated together for performance reason
      public static void npvbps(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                                Date settlementDate, Date npvDate, out double npv, out double bps)
      {
         npv = bps = 0.0;
         if (leg.empty())
         {
            bps = 0.0;
            return;
         }

         for (int i = 0; i < leg.Count; ++i)
         {
            CashFlow cf = leg[i];
            if (!cf.hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !cf.tradingExCoupon(settlementDate))
            {
               Coupon cp = leg[i] as Coupon;
               double df = discountCurve.discount(cf.date());
               npv += cf.amount() * df;
               if (cp != null)
                  bps += cp.nominal() * cp.accrualPeriod() * df;
            }
         }
         double d = discountCurve.discount(npvDate);
         npv /= d;
         bps = Const.BASIS_POINT * bps / d;
      }

      // At-the-money rate of the cash flows.
      // The result is the fixed rate for which a fixed rate cash flow  vector, equivalent to the input vector, has the required NPV according to the given term structure. If the required NPV is
      //  not given, the input cash flow vector's NPV is used instead.
      public static double atmRate(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                                   Date settlementDate = null, Date npvDate = null, double? targetNpv = null)
      {

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = 0.0;
         BPSCalculator calc = new BPSCalculator(discountCurve);
         for (int i = 0; i < leg.Count; ++i)
         {
            CashFlow cf = leg[i];
            if (!cf.hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !cf.tradingExCoupon(settlementDate))
            {
               npv += cf.amount() * discountCurve.discount(cf.date());
               cf.accept(calc);
            }
         }

         if (targetNpv == null)
            targetNpv = npv - calc.nonSensNPV();
         else
         {
            targetNpv *= discountCurve.discount(npvDate);
            targetNpv -= calc.nonSensNPV();
         }

         if (targetNpv.IsEqual(0.0))
            return 0.0;

         double bps = calc.bps();
         Utils.QL_REQUIRE(bps.IsNotEqual(0.0), () => "null bps: impossible atm rate");

         return targetNpv.Value / bps;
      }

      // NPV of the cash flows.
      // The NPV is the sum of the cash flows, each discounted
      // according to the given constant interest rate.  The result
      // is affected by the choice of the interest-rate compounding
      // and the relative frequency and day counter.
      public static double npv(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = 0.0;
         double discount = 1.0;
         Date lastDate = npvDate;
         DayCounter dc = yield.dayCounter();

         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double amount = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               amount = 0.0;
            }

            double b = yield.discountFactor(getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate));
            discount *= b;
            lastDate = leg[i].date();

            npv += amount * discount;
         }
         return npv;
      }
      public static double npv(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                               bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return npv(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                    includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Basis-point sensitivity of the cash flows.
      // The result is the change in NPV due to a uniform
      // 1-basis-point change in the rate paid by the cash
      // flows. The change for each coupon is discounted according
      // to the given constant interest rate.  The result is
      // affected by the choice of the interest-rate compounding
      // and the relative frequency and day counter.

      public static double bps(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         FlatForward flatRate = new FlatForward(settlementDate, yield.rate(), yield.dayCounter(),
                                                yield.compounding(), yield.frequency());
         return bps(leg, flatRate, includeSettlementDateFlows, settlementDate, npvDate);
      }

      public static double bps(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                               bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return bps(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                    includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! NPV of a single cash flows
      public static double npv(CashFlow cashflow, YieldTermStructure discountCurve,
                               Date settlementDate = null, Date npvDate = null, int exDividendDays = 0)
      {
         double NPV = 0.0;

         if (cashflow == null)
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         if (!cashflow.hasOccurred(settlementDate + exDividendDays))
            NPV = cashflow.amount() * discountCurve.discount(cashflow.date());


         return NPV / discountCurve.discount(npvDate);
      }


      //! CASH of the cash flows. The CASH is the sum of the cash flows.
      public static double cash(List<CashFlow> cashflows, Date settlementDate = null, int exDividendDays = 0)
      {
         if (cashflows.Count == 0)
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         double totalCASH = cashflows.Where(x => !x.hasOccurred(settlementDate + exDividendDays)).
                            Sum(c => c.amount());

         return totalCASH;
      }

      //! Implied internal rate of return.
      // The function verifies
      // the theoretical existance of an IRR and numerically
      // establishes the IRR to the desired precision.
      public static double yield(Leg leg, double npv, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                 bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null,
                                 double accuracy = 1.0e-10, int maxIterations = 100, double guess = 0.05)
      {
         NewtonSafe solver = new NewtonSafe();
         solver.setMaxEvaluations(maxIterations);
         IrrFinder objFunction = new IrrFinder(leg, npv,
                                               dayCounter, compounding, frequency,
                                               includeSettlementDateFlows,
                                               settlementDate, npvDate);
         return solver.solve(objFunction, accuracy, guess, guess / 10.0);
      }

      //! Cash-flow duration.
      public static double duration(Leg leg, InterestRate rate, Duration.Type type, bool includeSettlementDateFlows,
                                    Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         switch (type)
         {
            case Duration.Type.Simple:
               return simpleDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            case Duration.Type.Modified:
               return modifiedDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            case Duration.Type.Macaulay:
               return macaulayDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            default:
               Utils.QL_FAIL("unknown duration type");
               break;
         }
         return 0.0;
      }

      public static double duration(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                    Duration.Type type, bool includeSettlementDateFlows, Date settlementDate = null,
                                    Date npvDate = null)
      {
         return duration(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                         type, includeSettlementDateFlows,   settlementDate, npvDate);
      }

      //! Cash-flow convexity
      public static double convexity(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                     Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         DayCounter dc = yield.dayCounter();

         double P = 0.0;
         double t = 0.0;
         double d2Pdy2 = 0.0;
         double r = yield.rate();
         int N = (int)yield.frequency();
         Date lastDate = npvDate;


         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);

            double B = yield.discountFactor(t);
            P += c * B;
            switch (yield.compounding())
            {
               case  Compounding.Simple:
                  d2Pdy2 += c * 2.0 * B * B * B * t * t;
                  break;
               case Compounding.Compounded:
                  d2Pdy2 += c * B * t * (N * t + 1) / (N * (1 + r / N) * (1 + r / N));
                  break;
               case Compounding.Continuous:
                  d2Pdy2 += c * B * t * t;
                  break;
               case Compounding.SimpleThenCompounded:
                  if (t <= 1.0 / N)
                     d2Pdy2 += c * 2.0 * B * B * B * t * t;
                  else
                     d2Pdy2 += c * B * t * (N * t + 1) / (N * (1 + r / N) * (1 + r / N));
                  break;
               default:
                  Utils.QL_FAIL("unknown compounding convention (" + yield.compounding() + ")");
                  break;
            }
            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0))
            // no cashflows
            return 0.0;

         return d2Pdy2 / P;
      }

      public static double convexity(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                     bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return convexity(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                          includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Basis-point value
      /*! Obtained by setting dy = 0.0001 in the 2nd-order Taylor
          series expansion.
      */
      public static double basisPointValue(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                           Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = CashFlows.npv(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double modifiedDuration = CashFlows.duration(leg, yield, Duration.Type.Modified, includeSettlementDateFlows,
                                                      settlementDate, npvDate);
         double convexity = CashFlows.convexity(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double delta = -modifiedDuration * npv;
         double gamma = (convexity / 100.0) * npv;

         double shift = 0.0001;
         delta *= shift;
         gamma *= shift * shift;

         return delta + 0.5 * gamma;
      }
      public static double basisPointValue(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                           bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return basisPointValue(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                                includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Yield value of a basis point
      /*! The yield value of a one basis point change in price is
          the derivative of the yield with respect to the price
          multiplied by 0.01
      */
      public static double yieldValueBasisPoint(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                                Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = CashFlows.npv(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double modifiedDuration = CashFlows.duration(leg, yield, Duration.Type.Modified, includeSettlementDateFlows,
                                                      settlementDate, npvDate);

         double shift = 0.01;
         return (1.0 / (-npv * modifiedDuration)) * shift;
      }

      public static double yieldValueBasisPoint(Leg leg, double yield, DayCounter dayCounter, Compounding compounding,
                                                Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                                Date npvDate = null)
      {
         return yieldValueBasisPoint(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                                     includeSettlementDateFlows, settlementDate, npvDate);
      }
      #endregion

      #region  Z-spread utility functions

      // NPV of the cash flows.
      //  The NPV is the sum of the cash flows, each discounted
      //  according to the z-spreaded term structure.  The result
      //  is affected by the choice of the z-spread compounding
      //  and the relative frequency and day counter.
      public static double npv(Leg leg, YieldTermStructure discountCurve, double zSpread, DayCounter dc, Compounding comp,
                               Frequency freq, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         Handle<YieldTermStructure> discountCurveHandle = new Handle<YieldTermStructure>(discountCurve);
         Handle<Quote> zSpreadQuoteHandle = new Handle<Quote>(new SimpleQuote(zSpread));

         ZeroSpreadedTermStructure spreadedCurve = new ZeroSpreadedTermStructure(discountCurveHandle, zSpreadQuoteHandle,
                                                                                 comp, freq, dc);

         spreadedCurve.enableExtrapolation(discountCurveHandle.link.allowsExtrapolation());

         return npv(leg, spreadedCurve, includeSettlementDateFlows, settlementDate, npvDate);
      }
      //! implied Z-spread.
      public static double zSpread(Leg leg, double npv, YieldTermStructure discount, DayCounter dayCounter, Compounding compounding,
                                   Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                   Date npvDate = null, double accuracy = 1.0e-10, int maxIterations = 100, double guess = 0.0)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         Brent solver = new Brent();
         solver.setMaxEvaluations(maxIterations);
         ZSpreadFinder objFunction = new ZSpreadFinder(leg, discount, npv, dayCounter, compounding, frequency,
                                                       includeSettlementDateFlows, settlementDate, npvDate);
         double step = 0.01;
         return solver.solve(objFunction, accuracy, guess, step);
      }
      //! deprecated implied Z-spread.
      public static double zSpread(Leg leg, YieldTermStructure d, double npv, DayCounter dayCounter, Compounding compounding,
                                   Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                   Date npvDate = null, double accuracy = 1.0e-10, int maxIterations = 100,
                                   double guess = 0.0)
      {
         return zSpread(leg, npv, d, dayCounter, compounding, frequency,
                        includeSettlementDateFlows, settlementDate, npvDate,
                        accuracy, maxIterations, guess);
      }
      #endregion
   }


}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Leg = System.Collections.Generic.List<QLNet.CashFlow>;


namespace QLNet
{
   //! %cashflow-analysis functions
   public class CashFlows
   {
      #region utility functions

      private static double aggregateRate(Leg leg, CashFlow cf)
      {
         if (cf == null)
            return 0.0;

         Date paymentDate = cf.date();
         bool firstCouponFound = false;
         double nominal = 0.0;
         double accrualPeriod = 0.0;
         DayCounter dc = null;
         double result = 0.0;

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
            {
               if (firstCouponFound)
               {
                  Utils.QL_REQUIRE(nominal.IsEqual(cp.nominal()) &&
                                   accrualPeriod.IsEqual(cp.accrualPeriod()) &&
                                   dc == cp.dayCounter(), () =>
                                   "cannot aggregate two different coupons on "
                                   + paymentDate);
               }
               else
               {
                  firstCouponFound = true;
                  nominal = cp.nominal();
                  accrualPeriod = cp.accrualPeriod();
                  dc = cp.dayCounter();
               }
               result += cp.rate();
            }
         }

         Utils.QL_REQUIRE(firstCouponFound, () => "no coupon paid at cashflow date " + paymentDate);
         return result;
      }
      public static double simpleDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                          Date settlementDate, Date npvDate)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double P = 0.0;
         double dPdy = 0.0;
         double t = 0.0;
         Date lastDate = npvDate;

         DayCounter dc = y.dayCounter();
         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);
            double B = y.discountFactor(t);
            P += c * B;
            dPdy += t * c * B;

            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0)) // no cashflows
            return 0.0;
         return dPdy / P;
      }
      public static double modifiedDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                            Date settlementDate, Date npvDate)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double P = 0.0;
         double t = 0.0;
         double dPdy = 0.0;
         double r = y.rate();
         int N = (int)y.frequency();
         Date lastDate = npvDate;
         DayCounter dc = y.dayCounter();

         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);

            double B = y.discountFactor(t);
            P += c * B;
            switch (y.compounding())
            {
               case Compounding.Simple:
                  dPdy -= c * B * B * t;
                  break;
               case Compounding.Compounded:
                  dPdy -= c * t * B / (1 + r / N);
                  break;
               case Compounding.Continuous:
                  dPdy -= c * B * t;
                  break;
               case Compounding.SimpleThenCompounded:
                  if (t <= 1.0 / N)
                     dPdy -= c * B * B * t;
                  else
                     dPdy -= c * t * B / (1 + r / N);
                  break;
               default:
                  Utils.QL_FAIL("unknown compounding convention (" + y.compounding() + ")");
                  break;
            }
            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0)) // no cashflows
            return 0.0;
         return -dPdy / P; // reverse derivative sign
      }

      public static double macaulayDuration(Leg leg, InterestRate y, bool includeSettlementDateFlows,
                                            Date settlementDate, Date npvDate)
      {
         Utils.QL_REQUIRE(y.compounding() == Compounding.Compounded, () => "compounded rate required");

         return (1.0 + y.rate() / (int)y.frequency()) *
                modifiedDuration(leg, y, includeSettlementDateFlows, settlementDate, npvDate);
      }

      // helper function used to calculate Time-To-Discount for each stage when calculating discount factor stepwisely
      public static double getStepwiseDiscountTime(CashFlow cashFlow, DayCounter dc, Date npvDate, Date lastDate)
      {
         Date cashFlowDate = cashFlow.date();
         Date refStartDate, refEndDate;

         if (cashFlow is Coupon coupon)
         {
            refStartDate = coupon.referencePeriodStart;
            refEndDate = coupon.referencePeriodEnd;
         }
         else
         {
            if (lastDate == npvDate)
            {
               // we don't have a previous coupon date,
               // so we fake it
               refStartDate = cashFlowDate - new Period(1, TimeUnit.Years);
            }
            else
            {
               refStartDate = lastDate;
            }

            refEndDate = cashFlowDate;

         }

         if (cashFlow is Coupon coupon && lastDate != coupon.accrualStartDate())
         {
            double couponPeriod = dc.yearFraction(coupon.accrualStartDate(), cashFlowDate, refStartDate, refEndDate);
            double accruedPeriod = dc.yearFraction(coupon.accrualStartDate(), lastDate, refStartDate, refEndDate);
            return couponPeriod - accruedPeriod;
         }
         else
         {
            return dc.yearFraction(lastDate, cashFlowDate, refStartDate, refEndDate);
         }
      }


      #endregion

      #region Helper Classes

      class IrrFinder : ISolver1d
      {
         private Leg leg_;
         private double npv_;
         private DayCounter dayCounter_;
         private Compounding compounding_;
         private Frequency frequency_;
         private bool includeSettlementDateFlows_;
         private Date settlementDate_, npvDate_;

         public IrrFinder(Leg leg, double npv, DayCounter dayCounter, Compounding comp, Frequency freq,
                          bool includeSettlementDateFlows, Date settlementDate, Date npvDate)
         {
            leg_ = leg;
            npv_ = npv;
            dayCounter_ = dayCounter;
            compounding_ = comp;
            frequency_ = freq;
            includeSettlementDateFlows_ = includeSettlementDateFlows;
            settlementDate_ = settlementDate;
            npvDate_ = npvDate;

            if (settlementDate == null)
               settlementDate_ = Settings.evaluationDate();

            if (npvDate == null)
               npvDate_ = settlementDate_;

            checkSign();
         }

         public override double value(double y)
         {
            InterestRate yield = new InterestRate(y, dayCounter_, compounding_, frequency_);
            double NPV = CashFlows.npv(leg_, yield, includeSettlementDateFlows_, settlementDate_, npvDate_);
            return npv_ - NPV;
         }

         public override double derivative(double y)
         {
            InterestRate yield = new InterestRate(y, dayCounter_, compounding_, frequency_);
            return modifiedDuration(leg_, yield, includeSettlementDateFlows_, settlementDate_, npvDate_);
         }

         private void checkSign()
         {
            // depending on the sign of the market price, check that cash
            // flows of the opposite sign have been specified (otherwise
            // IRR is nonsensical.)

            int lastSign = Math.Sign(-npv_), signChanges = 0;
            for (int i = 0; i < leg_.Count; ++i)
            {
               if (!leg_[i].hasOccurred(settlementDate_, includeSettlementDateFlows_) &&
                   !leg_[i].tradingExCoupon(settlementDate_))
               {
                  int thisSign = Math.Sign(leg_[i].amount());
                  if (lastSign * thisSign < 0) // sign change
                     signChanges++;

                  if (thisSign != 0)
                     lastSign = thisSign;
               }
            }
            Utils.QL_REQUIRE(signChanges > 0, () =>
                             "the given cash flows cannot result in the given market " +
                             "price due to their sign", QLNetExceptionEnum.InvalidPriceSignException);
         }
      }
      class ZSpreadFinder : ISolver1d
      {
         private Leg leg_;
         private double npv_;
         private SimpleQuote zSpread_;
         ZeroSpreadedTermStructure curve_;
         private bool includeSettlementDateFlows_;
         private Date settlementDate_, npvDate_;

         public ZSpreadFinder(Leg leg, YieldTermStructure discountCurve, double npv, DayCounter dc, Compounding comp, Frequency freq,
                              bool includeSettlementDateFlows, Date settlementDate, Date npvDate)
         {
            leg_ = leg;
            npv_ = npv;
            zSpread_ = new SimpleQuote(0.0);
            curve_ = new ZeroSpreadedTermStructure(new Handle<YieldTermStructure>(discountCurve),
                                                   new Handle<Quote>(zSpread_), comp, freq, dc);
            includeSettlementDateFlows_ = includeSettlementDateFlows;
            settlementDate_ = settlementDate;
            npvDate_ = npvDate;

            if (settlementDate == null)
               settlementDate_ = Settings.evaluationDate();

            if (npvDate == null)
               npvDate_ = settlementDate_;

            // if the discount curve allows extrapolation, let's
            // the spreaded curve do too.
            curve_.enableExtrapolation(discountCurve.allowsExtrapolation());
         }

         public override double value(double zSpread)
         {
            zSpread_.setValue(zSpread);
            double NPV = CashFlows.npv(leg_, curve_, includeSettlementDateFlows_, settlementDate_, npvDate_);
            return npv_ - NPV;
         }


      }
      class BPSCalculator : IAcyclicVisitor
      {
         private YieldTermStructure discountCurve_;
         double bps_, nonSensNPV_;

         public BPSCalculator(YieldTermStructure discountCurve)
         {
            discountCurve_ = discountCurve;
            nonSensNPV_ = 0.0;
            bps_ = 0.0;
         }

         #region IAcyclicVisitor pattern
         // visitor classes should implement the generic visit method in the following form
         public void visit(object o)
         {
            Type[] types = new Type[] { o.GetType() };
            MethodInfo methodInfo = Utils.GetMethodInfo(this, "visit", types);

            methodInfo?.Invoke(this, new object[]{o});
         }
         public void visit(Coupon c)
         {
            double bps = c.nominal() *
                         c.accrualPeriod() *
                         discountCurve_.discount(c.date());
            bps_ += bps;
         }
         public void visit(CashFlow cf)
         {
            nonSensNPV_ += cf.amount() * discountCurve_.discount(cf.date());
         }
         #endregion

         public double bps() { return bps_; }
         public double nonSensNPV() { return nonSensNPV_; }
      }
      #endregion

      #region Date functions
      public static Date startDate(Leg leg)
      {
         Utils.QL_REQUIRE(!leg.empty(), () => "empty leg");
         Date d = Date.maxDate();
         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i] is Coupon c)
               d = Date.Min(d, c.accrualStartDate());
            else
               d = Date.Min(d, leg[i].date());
         }
         return d;
      }
      public static Date maturityDate(Leg leg)
      {
         Utils.QL_REQUIRE(!leg.empty(), () => "empty leg");
         Date d = Date.minDate();
         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i] is Coupon c)
               d = Date.Max(d, c.accrualEndDate());
            else
               d = Date.Max(d, leg[i].date());
         }
         return d;
      }
      public static bool isExpired(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return true;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         for (int i = leg.Count; i > 0; --i)
            if (!leg[i - 1].hasOccurred(settlementDate, includeSettlementDateFlows))
               return false;
         return true;
      }
      #endregion

      #region CashFlow functions
      //! the last cashflow paying before or at the given date
      public static CashFlow previousCashFlow(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return null;

         Date d = (settlementDate ?? Settings.evaluationDate());
         return  leg.LastOrDefault(x => x.hasOccurred(d, includeSettlementDateFlows));
      }
      //! the first cashflow paying after the given date
      public static CashFlow nextCashFlow(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (leg.empty())
            return null;

         Date d = (settlementDate ?? Settings.evaluationDate());

         // the first coupon paying after d is the one we're after
         return leg.FirstOrDefault(x => !x.hasOccurred(d, includeSettlementDateFlows));
      }
      public static Date previousCashFlowDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         return cf.date();
      }
      public static Date nextCashFlowDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         return cf.date();
      }
      public static double? previousCashFlowAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {

         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         Date paymentDate = cf.date();
         double? result = 0.0;
         result = leg.Where(cf1 => cf1.date() == paymentDate).Sum(cf1 => cf1.amount());
         return result;

      }
      public static double? nextCashFlowAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);

         if (cf == null)
            return null;

         Date paymentDate = cf.date();
         double result = 0.0;
         result = leg.Where(cf1 => cf1.date() == paymentDate).Sum(cf1 => cf1.amount());
         return result;
      }
      #endregion

      #region Coupon inspectors

      public static double previousCouponRate(List<CashFlow> leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = previousCashFlow(leg, includeSettlementDateFlows, settlementDate);
         return aggregateRate(leg, cf);
      }
      public static double nextCouponRate(List<CashFlow> leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         return aggregateRate(leg, cf);
      }
      public static double nominal(Leg leg, bool includeSettlementDateFlows,  Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0.0;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.nominal();
         }
         return 0.0;
      }
      public static Date accrualStartDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accrualStartDate();
         }
         return null;
      }
      public static Date accrualEndDate(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;

         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accrualEndDate();
         }
         return null;
      }
      public static Date referencePeriodStart(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.referencePeriodStart;
         }
         return null;
      }
      public static Date referencePeriodEnd(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return null;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.referencePeriodEnd;
         }
         return null;
      }
      public static double accrualPeriod(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accrualPeriod();
         }
         return 0;
      }
      public static int accrualDays(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accrualDays();
         }
         return 0;
      }
      public static double accruedPeriod(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows,  settlementDate);
         if (cf == null)
            return 0;

         Date paymentDate = cf.date();
         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accruedPeriod(settlementDate);
         }
         return 0;
      }
      public static int accruedDays(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;
         Date paymentDate = cf.date();

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               return cp.accruedDays(settlementDate);
         }
         return 0;
      }
      public static double accruedAmount(Leg leg, bool includeSettlementDateFlows, Date settlementDate = null)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         CashFlow cf = nextCashFlow(leg, includeSettlementDateFlows, settlementDate);
         if (cf == null)
            return 0;

         Date paymentDate = cf.date();
         double result = 0.0;

         foreach (CashFlow x in leg.Where(x => x.date() == paymentDate))
         {
            if (x is Coupon cp)
               result += cp.accruedAmount(settlementDate);
         }
         return result;
      }
      #endregion

      #region YieldTermStructure functions

      //! NPV of the cash flows. The NPV is the sum of the cash flows, each discounted according to the given term structure.
      public static double npv(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {

         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double totalNPV = 0.0;
         for (int i = 0; i < leg.Count; ++i)
         {
            if (!leg[i].hasOccurred(settlementDate, includeSettlementDateFlows) && !leg[i].tradingExCoupon(settlementDate))
               totalNPV += leg[i].amount() * discountCurve.discount(leg[i].date());
         }

         return totalNPV / discountCurve.discount(npvDate);
      }

      // Basis-point sensitivity of the cash flows.
      // The result is the change in NPV due to a uniform 1-basis-point change in the rate paid by the cash flows. The change for each coupon is discounted according to the given term structure.
      public static double bps(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         BPSCalculator calc = new BPSCalculator(discountCurve);
         for (int i = 0; i < leg.Count; ++i)
         {
            if (!leg[i].hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !leg[i].tradingExCoupon(settlementDate))
               leg[i].accept(calc);
         }
         return Const.BASIS_POINT * calc.bps() / discountCurve.discount(npvDate);
      }
      //! NPV and BPS of the cash flows.
      // The NPV and BPS of the cash flows calculated together for performance reason
      public static void npvbps(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                                Date settlementDate, Date npvDate, out double npv, out double bps)
      {
         npv = bps = 0.0;
         if (leg.empty())
         {
            bps = 0.0;
            return;
         }

         for (int i = 0; i < leg.Count; ++i)
         {
            CashFlow cf = leg[i];
            if (!cf.hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !cf.tradingExCoupon(settlementDate))
            {
               double df = discountCurve.discount(cf.date());
               npv += cf.amount() * df;

               if (leg[i] is Coupon cp)
                  bps += cp.nominal() * cp.accrualPeriod() * df;
            }
         }
         double d = discountCurve.discount(npvDate);
         npv /= d;
         bps = Const.BASIS_POINT * bps / d;
      }

      // At-the-money rate of the cash flows.
      // The result is the fixed rate for which a fixed rate cash flow  vector, equivalent to the input vector, has the required NPV according to the given term structure. If the required NPV is
      //  not given, the input cash flow vector's NPV is used instead.
      public static double atmRate(Leg leg, YieldTermStructure discountCurve, bool includeSettlementDateFlows,
                                   Date settlementDate = null, Date npvDate = null, double? targetNpv = null)
      {

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = 0.0;
         BPSCalculator calc = new BPSCalculator(discountCurve);
         for (int i = 0; i < leg.Count; ++i)
         {
            CashFlow cf = leg[i];
            if (!cf.hasOccurred(settlementDate, includeSettlementDateFlows) &&
                !cf.tradingExCoupon(settlementDate))
            {
               npv += cf.amount() * discountCurve.discount(cf.date());
               cf.accept(calc);
            }
         }

         if (targetNpv == null)
            targetNpv = npv - calc.nonSensNPV();
         else
         {
            targetNpv *= discountCurve.discount(npvDate);
            targetNpv -= calc.nonSensNPV();
         }

         if (targetNpv.IsEqual(0.0))
            return 0.0;

         double bps = calc.bps();
         Utils.QL_REQUIRE(bps.IsNotEqual(0.0), () => "null bps: impossible atm rate");

         return targetNpv.Value / bps;
      }

      // NPV of the cash flows.
      // The NPV is the sum of the cash flows, each discounted
      // according to the given constant interest rate.  The result
      // is affected by the choice of the interest-rate compounding
      // and the relative frequency and day counter.
      public static double npv(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = 0.0;
         double discount = 1.0;
         Date lastDate = npvDate;
         DayCounter dc = yield.dayCounter();

         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double amount = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               amount = 0.0;
            }

            double b = yield.discountFactor(getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate));
            discount *= b;
            lastDate = leg[i].date();

            npv += amount * discount;
         }
         return npv;
      }
      public static double npv(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                               bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return npv(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                    includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Basis-point sensitivity of the cash flows.
      // The result is the change in NPV due to a uniform
      // 1-basis-point change in the rate paid by the cash
      // flows. The change for each coupon is discounted according
      // to the given constant interest rate.  The result is
      // affected by the choice of the interest-rate compounding
      // and the relative frequency and day counter.

      public static double bps(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         FlatForward flatRate = new FlatForward(settlementDate, yield.rate(), yield.dayCounter(),
                                                yield.compounding(), yield.frequency());
         return bps(leg, flatRate, includeSettlementDateFlows, settlementDate, npvDate);
      }

      public static double bps(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                               bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return bps(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                    includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! NPV of a single cash flows
      public static double npv(CashFlow cashflow, YieldTermStructure discountCurve,
                               Date settlementDate = null, Date npvDate = null, int exDividendDays = 0)
      {
         double NPV = 0.0;

         if (cashflow == null)
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         if (!cashflow.hasOccurred(settlementDate + exDividendDays))
            NPV = cashflow.amount() * discountCurve.discount(cashflow.date());


         return NPV / discountCurve.discount(npvDate);
      }


      //! CASH of the cash flows. The CASH is the sum of the cash flows.
      public static double cash(List<CashFlow> cashflows, Date settlementDate = null, int exDividendDays = 0)
      {
         if (cashflows.Count == 0)
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         double totalCASH = cashflows.Where(x => !x.hasOccurred(settlementDate + exDividendDays)).
                            Sum(c => c.amount());

         return totalCASH;
      }

      //! Implied internal rate of return.
      // The function verifies
      // the theoretical existance of an IRR and numerically
      // establishes the IRR to the desired precision.
      public static double yield(Leg leg, double npv, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                 bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null,
                                 double accuracy = 1.0e-10, int maxIterations = 100, double guess = 0.05)
      {
         NewtonSafe solver = new NewtonSafe();
         solver.setMaxEvaluations(maxIterations);
         IrrFinder objFunction = new IrrFinder(leg, npv,
                                               dayCounter, compounding, frequency,
                                               includeSettlementDateFlows,
                                               settlementDate, npvDate);
         return solver.solve(objFunction, accuracy, guess, guess / 10.0);
      }

      //! Cash-flow duration.
      public static double duration(Leg leg, InterestRate rate, Duration.Type type, bool includeSettlementDateFlows,
                                    Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         switch (type)
         {
            case Duration.Type.Simple:
               return simpleDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            case Duration.Type.Modified:
               return modifiedDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            case Duration.Type.Macaulay:
               return macaulayDuration(leg, rate, includeSettlementDateFlows, settlementDate, npvDate);
            default:
               Utils.QL_FAIL("unknown duration type");
               break;
         }
         return 0.0;
      }

      public static double duration(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                    Duration.Type type, bool includeSettlementDateFlows, Date settlementDate = null,
                                    Date npvDate = null)
      {
         return duration(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                         type, includeSettlementDateFlows,   settlementDate, npvDate);
      }

      //! Cash-flow convexity
      public static double convexity(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                     Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         DayCounter dc = yield.dayCounter();

         double P = 0.0;
         double t = 0.0;
         double d2Pdy2 = 0.0;
         double r = yield.rate();
         int N = (int)yield.frequency();
         Date lastDate = npvDate;


         for (int i = 0; i < leg.Count; ++i)
         {
            if (leg[i].hasOccurred(settlementDate, includeSettlementDateFlows))
               continue;

            double c = leg[i].amount();
            if (leg[i].tradingExCoupon(settlementDate))
            {
               c = 0.0;
            }

            t += getStepwiseDiscountTime(leg[i], dc, npvDate, lastDate);

            double B = yield.discountFactor(t);
            P += c * B;
            switch (yield.compounding())
            {
               case  Compounding.Simple:
                  d2Pdy2 += c * 2.0 * B * B * B * t * t;
                  break;
               case Compounding.Compounded:
                  d2Pdy2 += c * B * t * (N * t + 1) / (N * (1 + r / N) * (1 + r / N));
                  break;
               case Compounding.Continuous:
                  d2Pdy2 += c * B * t * t;
                  break;
               case Compounding.SimpleThenCompounded:
                  if (t <= 1.0 / N)
                     d2Pdy2 += c * 2.0 * B * B * B * t * t;
                  else
                     d2Pdy2 += c * B * t * (N * t + 1) / (N * (1 + r / N) * (1 + r / N));
                  break;
               default:
                  Utils.QL_FAIL("unknown compounding convention (" + yield.compounding() + ")");
                  break;
            }
            lastDate = leg[i].date();
         }

         if (P.IsEqual(0.0))
            // no cashflows
            return 0.0;

         return d2Pdy2 / P;
      }

      public static double convexity(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                     bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return convexity(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                          includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Basis-point value
      /*! Obtained by setting dy = 0.0001 in the 2nd-order Taylor
          series expansion.
      */
      public static double basisPointValue(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                           Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = CashFlows.npv(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double modifiedDuration = CashFlows.duration(leg, yield, Duration.Type.Modified, includeSettlementDateFlows,
                                                      settlementDate, npvDate);
         double convexity = CashFlows.convexity(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double delta = -modifiedDuration * npv;
         double gamma = (convexity / 100.0) * npv;

         double shift = 0.0001;
         delta *= shift;
         gamma *= shift * shift;

         return delta + 0.5 * gamma;
      }
      public static double basisPointValue(Leg leg, double yield, DayCounter dayCounter, Compounding compounding, Frequency frequency,
                                           bool includeSettlementDateFlows, Date settlementDate = null, Date npvDate = null)
      {
         return basisPointValue(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                                includeSettlementDateFlows, settlementDate, npvDate);
      }

      //! Yield value of a basis point
      /*! The yield value of a one basis point change in price is
          the derivative of the yield with respect to the price
          multiplied by 0.01
      */
      public static double yieldValueBasisPoint(Leg leg, InterestRate yield, bool includeSettlementDateFlows,
                                                Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         double npv = CashFlows.npv(leg, yield, includeSettlementDateFlows, settlementDate, npvDate);
         double modifiedDuration = CashFlows.duration(leg, yield, Duration.Type.Modified, includeSettlementDateFlows,
                                                      settlementDate, npvDate);

         double shift = 0.01;
         return (1.0 / (-npv * modifiedDuration)) * shift;
      }

      public static double yieldValueBasisPoint(Leg leg, double yield, DayCounter dayCounter, Compounding compounding,
                                                Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                                Date npvDate = null)
      {
         return yieldValueBasisPoint(leg, new InterestRate(yield, dayCounter, compounding, frequency),
                                     includeSettlementDateFlows, settlementDate, npvDate);
      }
      #endregion

      #region  Z-spread utility functions

      // NPV of the cash flows.
      //  The NPV is the sum of the cash flows, each discounted
      //  according to the z-spreaded term structure.  The result
      //  is affected by the choice of the z-spread compounding
      //  and the relative frequency and day counter.
      public static double npv(Leg leg, YieldTermStructure discountCurve, double zSpread, DayCounter dc, Compounding comp,
                               Frequency freq, bool includeSettlementDateFlows,
                               Date settlementDate = null, Date npvDate = null)
      {
         if (leg.empty())
            return 0.0;

         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         Handle<YieldTermStructure> discountCurveHandle = new Handle<YieldTermStructure>(discountCurve);
         Handle<Quote> zSpreadQuoteHandle = new Handle<Quote>(new SimpleQuote(zSpread));

         ZeroSpreadedTermStructure spreadedCurve = new ZeroSpreadedTermStructure(discountCurveHandle, zSpreadQuoteHandle,
                                                                                 comp, freq, dc);

         spreadedCurve.enableExtrapolation(discountCurveHandle.link.allowsExtrapolation());

         return npv(leg, spreadedCurve, includeSettlementDateFlows, settlementDate, npvDate);
      }
      //! implied Z-spread.
      public static double zSpread(Leg leg, double npv, YieldTermStructure discount, DayCounter dayCounter, Compounding compounding,
                                   Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                   Date npvDate = null, double accuracy = 1.0e-10, int maxIterations = 100, double guess = 0.0)
      {
         if (settlementDate == null)
            settlementDate = Settings.evaluationDate();

         if (npvDate == null)
            npvDate = settlementDate;

         Brent solver = new Brent();
         solver.setMaxEvaluations(maxIterations);
         ZSpreadFinder objFunction = new ZSpreadFinder(leg, discount, npv, dayCounter, compounding, frequency,
                                                       includeSettlementDateFlows, settlementDate, npvDate);
         double step = 0.01;
         return solver.solve(objFunction, accuracy, guess, step);
      }
      //! deprecated implied Z-spread.
      public static double zSpread(Leg leg, YieldTermStructure d, double npv, DayCounter dayCounter, Compounding compounding,
                                   Frequency frequency, bool includeSettlementDateFlows, Date settlementDate = null,
                                   Date npvDate = null, double accuracy = 1.0e-10, int maxIterations = 100,
                                   double guess = 0.0)
      {
         return zSpread(leg, npv, d, dayCounter, compounding, frequency,
                        includeSettlementDateFlows, settlementDate, npvDate,
                        accuracy, maxIterations, guess);
      }
      #endregion
   }


}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\QLNet\Cashflows\CashFlows.cs(215,33): error CS0128: A local variable or function named 'coupon' is already defined in this scope,D:\a\1\s\src\QLNet\Cashflows\CashFlows.cs(215,55): error CS0165: Use of unassigned local variable 'coupon'
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\QLNet\Instruments\MakeCapFloor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;

namespace QLNet
{
   //! helper class
   /*! This class provides a more comfortable way
       to instantiate standard market cap and floor.
   */
   public class MakeCapFloor
   {
      public MakeCapFloor(CapFloorType capFloorType, Period tenor, IborIndex iborIndex, double? strike = null,
                          Period forwardStart = null)
      {
         capFloorType_ = capFloorType;
         strike_ = strike;
         firstCapletExcluded_ = (forwardStart == new Period(0, TimeUnit.Days));
         asOptionlet_ = false;
         makeVanillaSwap_ = new MakeVanillaSwap(tenor, iborIndex, 0.0, forwardStart);
      }

      public static implicit operator CapFloor(MakeCapFloor o) { return o.value(); }
      public CapFloor value()
      {
         VanillaSwap swap = makeVanillaSwap_;

         List<CashFlow> leg = swap.floatingLeg();
         if (firstCapletExcluded_)
            leg.RemoveAt(0);

         // only leaves the last coupon
         if (asOptionlet_ && leg.Count > 1)
         {
            leg.RemoveRange(0, leg.Count - 2); // Sun Studio needs an lvalue
         }

         List<double> strikeVector ;
         if (strike_ == null)
         {
            // temporary patch...
            // should be fixed for every CapFloor::Engine
            BlackCapFloorEngine temp = engine_ as BlackCapFloorEngine;
            Utils.QL_REQUIRE(temp != null, () => "cannot calculate ATM without a BlackCapFloorEngine");
            Handle<YieldTermStructure> discountCurve = temp.termStructure();
            strikeVector = new InitializedList<double>(1, CashFlows.atmRate(leg, discountCurve, false, discountCurve.link.referenceDate()));
         }
         else
         {
            strikeVector = new InitializedList<double>(1, strike_.Value);
         }

         CapFloor capFloor = new CapFloor(capFloorType_, leg, strikeVector);
         capFloor.setPricingEngine(engine_);
         return capFloor;

      }


      public MakeCapFloor withNominal(double n)
      {
         makeVanillaSwap_.withNominal(n);
         return this;
      }

      public MakeCapFloor withEffectiveDate(Date effectiveDate, bool firstCapletExcluded)
      {
         makeVanillaSwap_.withEffectiveDate(effectiveDate);
         firstCapletExcluded_ = firstCapletExcluded;
         return this;
      }

      public MakeCapFloor withTenor(Period t)
      {
         makeVanillaSwap_.withFixedLegTenor(t);
         makeVanillaSwap_.withFloatingLegTenor(t);
         return this;
      }

      public MakeCapFloor withCalendar(Calendar cal)
      {
         makeVanillaSwap_.withFixedLegCalendar(cal);
         makeVanillaSwap_.withFloatingLegCalendar(cal);
         return this;
      }
      public MakeCapFloor withConvention(BusinessDayConvention bdc)
      {
         makeVanillaSwap_.withFixedLegConvention(bdc);
         makeVanillaSwap_.withFloatingLegConvention(bdc);
         return this;
      }

      public MakeCapFloor withTerminationDateConvention(BusinessDayConvention bdc)
      {
         makeVanillaSwap_.withFixedLegTerminationDateConvention(bdc);
         makeVanillaSwap_.withFloatingLegTerminationDateConvention(bdc);
         return this;
      }

      public MakeCapFloor withRule(DateGeneration.Rule r)
      {
         makeVanillaSwap_.withFixedLegRule(r);
         makeVanillaSwap_.withFloatingLegRule(r);
         return this;
      }

      public MakeCapFloor withEndOfMonth(bool flag = true)
      {
         makeVanillaSwap_.withFixedLegEndOfMonth(flag);
         makeVanillaSwap_.withFloatingLegEndOfMonth(flag);
         return this;
      }

      public MakeCapFloor withFirstDate(Date d)
      {
         makeVanillaSwap_.withFixedLegFirstDate(d);
         makeVanillaSwap_.withFloatingLegFirstDate(d);
         return this;
      }

      public MakeCapFloor withNextToLastDate(Date d)
      {
         makeVanillaSwap_.withFixedLegNextToLastDate(d);
         makeVanillaSwap_.withFloatingLegNextToLastDate(d);
         return this;
      }

      public MakeCapFloor withDayCount(DayCounter dc)
      {
         makeVanillaSwap_.withFixedLegDayCount(dc);
         makeVanillaSwap_.withFloatingLegDayCount(dc);
         return this;
      }

      //! only get last coupon
      public MakeCapFloor asOptionlet(bool b = true)
      {
         asOptionlet_ = b;
         return this;
      }

      public MakeCapFloor withPricingEngine(IPricingEngine engine)
      {
         engine_ = engine;
         return this;
      }

      private CapFloorType capFloorType_;
      private double? strike_;
      private bool firstCapletExcluded_, asOptionlet_;

      private MakeVanillaSwap makeVanillaSwap_;

      private IPricingEngine engine_;

   }
}

---- Transformed Tree ----
using System.Collections.Generic;

namespace QLNet
{
   //! helper class
   /*! This class provides a more comfortable way
       to instantiate standard market cap and floor.
   */
   public class MakeCapFloor
   {
      public MakeCapFloor(CapFloorType capFloorType, Period tenor, IborIndex iborIndex, double? strike = null,
                          Period forwardStart = null)
      {
         capFloorType_ = capFloorType;
         strike_ = strike;
         firstCapletExcluded_ = (forwardStart == new Period(0, TimeUnit.Days));
         asOptionlet_ = false;
         makeVanillaSwap_ = new MakeVanillaSwap(tenor, iborIndex, 0.0, forwardStart);
      }

      public static implicit operator CapFloor(MakeCapFloor o) { return o.value(); }
      public CapFloor value()
      {
         VanillaSwap swap = makeVanillaSwap_;

         List<CashFlow> leg = swap.floatingLeg();
         if (firstCapletExcluded_)
            leg.RemoveAt(0);

         // only leaves the last coupon
         if (asOptionlet_ && leg.Count > 1)
         {
            leg.RemoveRange(0, leg.Count - 2); // Sun Studio needs an lvalue
         }

         List<double> strikeVector ;
         if (strike_ == null)
         {
            // temporary patch...            // should be fixed for every CapFloor::Engine
            Utils.QL_REQUIRE(engine_ is BlackCapFloorEngine temp, () => "cannot calculate ATM without a BlackCapFloorEngine");
            Handle<YieldTermStructure> discountCurve = temp.termStructure();
            strikeVector = new InitializedList<double>(1, CashFlows.atmRate(leg, discountCurve, false, discountCurve.link.referenceDate()));
         }
         else
         {
            strikeVector = new InitializedList<double>(1, strike_.Value);
         }

         CapFloor capFloor = new CapFloor(capFloorType_, leg, strikeVector);
         capFloor.setPricingEngine(engine_);
         return capFloor;

      }


      public MakeCapFloor withNominal(double n)
      {
         makeVanillaSwap_.withNominal(n);
         return this;
      }

      public MakeCapFloor withEffectiveDate(Date effectiveDate, bool firstCapletExcluded)
      {
         makeVanillaSwap_.withEffectiveDate(effectiveDate);
         firstCapletExcluded_ = firstCapletExcluded;
         return this;
      }

      public MakeCapFloor withTenor(Period t)
      {
         makeVanillaSwap_.withFixedLegTenor(t);
         makeVanillaSwap_.withFloatingLegTenor(t);
         return this;
      }

      public MakeCapFloor withCalendar(Calendar cal)
      {
         makeVanillaSwap_.withFixedLegCalendar(cal);
         makeVanillaSwap_.withFloatingLegCalendar(cal);
         return this;
      }
      public MakeCapFloor withConvention(BusinessDayConvention bdc)
      {
         makeVanillaSwap_.withFixedLegConvention(bdc);
         makeVanillaSwap_.withFloatingLegConvention(bdc);
         return this;
      }

      public MakeCapFloor withTerminationDateConvention(BusinessDayConvention bdc)
      {
         makeVanillaSwap_.withFixedLegTerminationDateConvention(bdc);
         makeVanillaSwap_.withFloatingLegTerminationDateConvention(bdc);
         return this;
      }

      public MakeCapFloor withRule(DateGeneration.Rule r)
      {
         makeVanillaSwap_.withFixedLegRule(r);
         makeVanillaSwap_.withFloatingLegRule(r);
         return this;
      }

      public MakeCapFloor withEndOfMonth(bool flag = true)
      {
         makeVanillaSwap_.withFixedLegEndOfMonth(flag);
         makeVanillaSwap_.withFloatingLegEndOfMonth(flag);
         return this;
      }

      public MakeCapFloor withFirstDate(Date d)
      {
         makeVanillaSwap_.withFixedLegFirstDate(d);
         makeVanillaSwap_.withFloatingLegFirstDate(d);
         return this;
      }

      public MakeCapFloor withNextToLastDate(Date d)
      {
         makeVanillaSwap_.withFixedLegNextToLastDate(d);
         makeVanillaSwap_.withFloatingLegNextToLastDate(d);
         return this;
      }

      public MakeCapFloor withDayCount(DayCounter dc)
      {
         makeVanillaSwap_.withFixedLegDayCount(dc);
         makeVanillaSwap_.withFloatingLegDayCount(dc);
         return this;
      }

      //! only get last coupon
      public MakeCapFloor asOptionlet(bool b = true)
      {
         asOptionlet_ = b;
         return this;
      }

      public MakeCapFloor withPricingEngine(IPricingEngine engine)
      {
         engine_ = engine;
         return this;
      }

      private CapFloorType capFloorType_;
      private double? strike_;
      private bool firstCapletExcluded_, asOptionlet_;

      private MakeVanillaSwap makeVanillaSwap_;

      private IPricingEngine engine_;

   }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\QLNet\Instruments\MakeCapFloor.cs(57,56): error CS0165: Use of unassigned local variable 'temp'
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

namespace QLNet
{
   //! Analytic pricing engine for double barrier binary options
   /*! This engine implements C.H.Hui series ("One-Touch Double Barrier
       Binary Option Values", Applied Financial Economics 6/1996), as
       described in "The complete guide to option pricing formulas 2nd Ed",
       E.G. Haug, McGraw-Hill, p.180

       The Knock In part of KI+KO and KO+KI options pays at hit, while the
       Double Knock In pays at end.
       This engine thus requires European esercise for Double Knock options,
       and American exercise for KIKO/KOKI.

       \ingroup barrierengines

       greeks are calculated by simple numeric derivation

       \test
       - the correctness of the returned value is tested by reproducing
         results available in literature.
   */

   // calc helper object
   public class AnalyticDoubleBarrierBinaryEngineHelper
   {
      public AnalyticDoubleBarrierBinaryEngineHelper(
         GeneralizedBlackScholesProcess process,
         CashOrNothingPayoff payoff,
         DoubleBarrierOption.Arguments arguments)
      {
         process_ = process;
         payoff_ = payoff;
         arguments_ = arguments;
      }

      // helper object methods
      public double payoffAtExpiry(double spot, double variance,
                                   DoubleBarrier.Type barrierType,
                                   int maxIteration = 100,
                                   double requiredConvergence = 1e-8)
      {
         Utils.QL_REQUIRE(spot > 0.0,
                          () => "positive spot value required");

         Utils.QL_REQUIRE(variance >= 0.0,
                          () => "negative variance not allowed");

         double residualTime = process_.time(arguments_.exercise.lastDate());
         Utils.QL_REQUIRE(residualTime > 0.0,
                          () => "expiration time must be > 0");

         // Option::Type type   = payoff_->optionType(); // this is not used ?
         double cash = payoff_.cashPayoff();
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;

         double sigmaq = variance / residualTime;
         double r = process_.riskFreeRate().currentLink().zeroRate(residualTime, Compounding.Continuous,
                                                                   Frequency.NoFrequency).rate();
         double q = process_.dividendYield().currentLink().zeroRate(residualTime,
                                                                    Compounding.Continuous, Frequency.NoFrequency).rate();
         double b = r - q;

         double alpha = -0.5 * (2 * b / sigmaq - 1);
         double beta = -0.25 * Math.Pow((2 * b / sigmaq - 1), 2) - 2 * r / sigmaq;
         double Z = Math.Log(barrier_hi / barrier_lo);
         double factor = ((2 * Const.M_PI * cash) / Math.Pow(Z, 2)); // common factor
         double lo_alpha = Math.Pow(spot / barrier_lo, alpha);
         double hi_alpha = Math.Pow(spot / barrier_hi, alpha);

         double tot = 0, term = 0;
         for (int i = 1 ; i < maxIteration ; ++i)
         {
            double term1 = (lo_alpha - Math.Pow(-1.0, i) * hi_alpha) /
                           (Math.Pow(alpha, 2) + Math.Pow(i * Const.M_PI / Z, 2));
            double term2 = Math.Sin(i * Const.M_PI / Z * Math.Log(spot / barrier_lo));
            double term3 = Math.Exp(-0.5 * (Math.Pow(i * Const.M_PI / Z, 2) - beta) * variance);
            term = factor * i * term1 * term2 * term3;
            tot += term;
         }

         // Check if convergence is sufficiently fast (for extreme parameters with big alpha the convergence can be very
         // poor, see for example Hui "One-touch double barrier binary option value")
         Utils.QL_REQUIRE(Math.Abs(term) < requiredConvergence, () => "serie did not converge sufficiently fast");

         if (barrierType == DoubleBarrier.Type.KnockOut)
            return Math.Max(tot, 0.0); // KO
         else
         {
            double discount = process_.riskFreeRate().currentLink().discount(
               arguments_.exercise.lastDate());
            Utils.QL_REQUIRE(discount>0.0,
                             () => "positive discount required");
            return Math.Max(cash * discount - tot, 0.0); // KI
         }
      }
      // helper object methods
      public double payoffKIKO(double spot, double variance,
                               DoubleBarrier.Type barrierType,
                               int maxIteration = 1000,
                               double requiredConvergence = 1e-8)
      {
         Utils.QL_REQUIRE(spot > 0.0,
                          () => "positive spot value required");

         Utils.QL_REQUIRE(variance >= 0.0,
                          () => "negative variance not allowed");

         double residualTime = process_.time(arguments_.exercise.lastDate());
         Utils.QL_REQUIRE(residualTime > 0.0,
                          () => "expiration time must be > 0");

         double cash = payoff_.cashPayoff();
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;
         if (barrierType == DoubleBarrier.Type.KOKI)
            Utils.swap(ref barrier_lo, ref barrier_hi);

         double sigmaq = variance / residualTime;
         double r = process_.riskFreeRate().currentLink().zeroRate(residualTime, Compounding.Continuous,
                                                                   Frequency.NoFrequency).rate();
         double q = process_.dividendYield().currentLink().zeroRate(residualTime,
                                                                    Compounding.Continuous, Frequency.NoFrequency).rate();
         double b = r - q;

         double alpha = -0.5 * (2 * b / sigmaq - 1);
         double beta = -0.25 * Math.Pow((2 * b / sigmaq - 1), 2) - 2 * r / sigmaq;
         double Z = Math.Log(barrier_hi / barrier_lo);
         double log_S_L = Math.Log(spot / barrier_lo);

         double tot = 0, term = 0;
         for (int i = 1 ; i < maxIteration ; ++i)
         {
            double factor = Math.Pow(i * Const.M_PI / Z, 2) - beta;
            double term1 = (beta - Math.Pow(i * Const.M_PI / Z, 2) * Math.Exp(-0.5 * factor * variance)) / factor;
            double term2 = Math.Sin(i * Const.M_PI / Z * log_S_L);
            term = (2.0 / (i * Const.M_PI)) * term1 * term2;
            tot += term;
         }
         tot += 1 - log_S_L / Z;
         tot *= cash * Math.Pow(spot / barrier_lo, alpha);

         // Check if convergence is sufficiently fast
         Utils.QL_REQUIRE(Math.Abs(term) < requiredConvergence, () => "serie did not converge sufficiently fast");

         return Math.Max(tot, 0.0);
      }

      protected GeneralizedBlackScholesProcess process_;
      protected CashOrNothingPayoff payoff_;
      protected DoubleBarrierOption.Arguments arguments_;
   }
   public class AnalyticDoubleBarrierBinaryEngine : DoubleBarrierOption.Engine
   {
      public AnalyticDoubleBarrierBinaryEngine(GeneralizedBlackScholesProcess process)
      {
         process_ = process;
         process_.registerWith(update);
      }

      public override void calculate()
      {
         if (arguments_.barrierType == DoubleBarrier.Type.KIKO ||
             arguments_.barrierType == DoubleBarrier.Type.KOKI)
         {
            AmericanExercise ex = arguments_.exercise as AmericanExercise;
            Utils.QL_REQUIRE(ex != null, () => "KIKO/KOKI options must have American exercise");
            Utils.QL_REQUIRE(ex.dates()[0] <=
                             process_.blackVolatility().currentLink().referenceDate(),
                             () => "American option with window exercise not handled yet");
         }
         else
         {
            EuropeanExercise ex = arguments_.exercise as EuropeanExercise;
            Utils.QL_REQUIRE(ex != null, () => "non-European exercise given");
         }
         CashOrNothingPayoff payoff = arguments_.payoff as CashOrNothingPayoff;
         Utils.QL_REQUIRE(payoff != null, () => "a cash-or-nothing payoff must be given");

         double spot = process_.stateVariable().currentLink().value();
         Utils.QL_REQUIRE(spot > 0.0, () => "negative or null underlying given");

         double variance =
            process_.blackVolatility().currentLink().blackVariance(
               arguments_.exercise.lastDate(),
               payoff.strike());
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;
         DoubleBarrier.Type barrierType = arguments_.barrierType;
         Utils.QL_REQUIRE(barrier_lo > 0.0,
                          () => "positive low barrier value required");
         Utils.QL_REQUIRE(barrier_hi > 0.0,
                          () => "positive high barrier value required");
         Utils.QL_REQUIRE(barrier_lo < barrier_hi,
                          () => "barrier_lo must be < barrier_hi");
         Utils.QL_REQUIRE(barrierType == DoubleBarrier.Type.KnockIn ||
                          barrierType == DoubleBarrier.Type.KnockOut ||
                          barrierType == DoubleBarrier.Type.KIKO ||
                          barrierType == DoubleBarrier.Type.KOKI,
                          () => "Unsupported barrier type");

         // degenerate cases
         switch (barrierType)
         {
            case DoubleBarrier.Type.KnockOut:
               if (spot <= barrier_lo || spot >= barrier_hi)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KnockIn:
               if (spot <= barrier_lo || spot >= barrier_hi)
               {
                  // knocked in - pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KIKO:
               if (spot >= barrier_hi)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               else if (spot <= barrier_lo)
               {
                  // knocked in, pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KOKI:
               if (spot <= barrier_lo)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               else if (spot >= barrier_hi)
               {
                  // knocked in, pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;
         }

         AnalyticDoubleBarrierBinaryEngineHelper helper = new AnalyticDoubleBarrierBinaryEngineHelper(process_,
               payoff, arguments_);
         switch (barrierType)
         {
            case DoubleBarrier.Type.KnockOut:
            case DoubleBarrier.Type.KnockIn:
               results_.value = helper.payoffAtExpiry(spot, variance, barrierType);
               break;

            case DoubleBarrier.Type.KIKO:
            case DoubleBarrier.Type.KOKI:
               results_.value = helper.payoffKIKO(spot, variance, barrierType);
               break;
            default:
               results_.value = null;
               break;
         }
      }

      protected GeneralizedBlackScholesProcess process_;
   }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;

namespace QLNet
{
   //! Analytic pricing engine for double barrier binary options
   /*! This engine implements C.H.Hui series ("One-Touch Double Barrier
       Binary Option Values", Applied Financial Economics 6/1996), as
       described in "The complete guide to option pricing formulas 2nd Ed",
       E.G. Haug, McGraw-Hill, p.180

       The Knock In part of KI+KO and KO+KI options pays at hit, while the
       Double Knock In pays at end.
       This engine thus requires European esercise for Double Knock options,
       and American exercise for KIKO/KOKI.

       \ingroup barrierengines

       greeks are calculated by simple numeric derivation

       \test
       - the correctness of the returned value is tested by reproducing
         results available in literature.
   */

   // calc helper object
   public class AnalyticDoubleBarrierBinaryEngineHelper
   {
      public AnalyticDoubleBarrierBinaryEngineHelper(
         GeneralizedBlackScholesProcess process,
         CashOrNothingPayoff payoff,
         DoubleBarrierOption.Arguments arguments)
      {
         process_ = process;
         payoff_ = payoff;
         arguments_ = arguments;
      }

      // helper object methods
      public double payoffAtExpiry(double spot, double variance,
                                   DoubleBarrier.Type barrierType,
                                   int maxIteration = 100,
                                   double requiredConvergence = 1e-8)
      {
         Utils.QL_REQUIRE(spot > 0.0,
                          () => "positive spot value required");

         Utils.QL_REQUIRE(variance >= 0.0,
                          () => "negative variance not allowed");

         double residualTime = process_.time(arguments_.exercise.lastDate());
         Utils.QL_REQUIRE(residualTime > 0.0,
                          () => "expiration time must be > 0");

         // Option::Type type   = payoff_->optionType(); // this is not used ?
         double cash = payoff_.cashPayoff();
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;

         double sigmaq = variance / residualTime;
         double r = process_.riskFreeRate().currentLink().zeroRate(residualTime, Compounding.Continuous,
                                                                   Frequency.NoFrequency).rate();
         double q = process_.dividendYield().currentLink().zeroRate(residualTime,
                                                                    Compounding.Continuous, Frequency.NoFrequency).rate();
         double b = r - q;

         double alpha = -0.5 * (2 * b / sigmaq - 1);
         double beta = -0.25 * Math.Pow((2 * b / sigmaq - 1), 2) - 2 * r / sigmaq;
         double Z = Math.Log(barrier_hi / barrier_lo);
         double factor = ((2 * Const.M_PI * cash) / Math.Pow(Z, 2)); // common factor
         double lo_alpha = Math.Pow(spot / barrier_lo, alpha);
         double hi_alpha = Math.Pow(spot / barrier_hi, alpha);

         double tot = 0, term = 0;
         for (int i = 1 ; i < maxIteration ; ++i)
         {
            double term1 = (lo_alpha - Math.Pow(-1.0, i) * hi_alpha) /
                           (Math.Pow(alpha, 2) + Math.Pow(i * Const.M_PI / Z, 2));
            double term2 = Math.Sin(i * Const.M_PI / Z * Math.Log(spot / barrier_lo));
            double term3 = Math.Exp(-0.5 * (Math.Pow(i * Const.M_PI / Z, 2) - beta) * variance);
            term = factor * i * term1 * term2 * term3;
            tot += term;
         }

         // Check if convergence is sufficiently fast (for extreme parameters with big alpha the convergence can be very
         // poor, see for example Hui "One-touch double barrier binary option value")
         Utils.QL_REQUIRE(Math.Abs(term) < requiredConvergence, () => "serie did not converge sufficiently fast");

         if (barrierType == DoubleBarrier.Type.KnockOut)
            return Math.Max(tot, 0.0); // KO
         else
         {
            double discount = process_.riskFreeRate().currentLink().discount(
               arguments_.exercise.lastDate());
            Utils.QL_REQUIRE(discount>0.0,
                             () => "positive discount required");
            return Math.Max(cash * discount - tot, 0.0); // KI
         }
      }
      // helper object methods
      public double payoffKIKO(double spot, double variance,
                               DoubleBarrier.Type barrierType,
                               int maxIteration = 1000,
                               double requiredConvergence = 1e-8)
      {
         Utils.QL_REQUIRE(spot > 0.0,
                          () => "positive spot value required");

         Utils.QL_REQUIRE(variance >= 0.0,
                          () => "negative variance not allowed");

         double residualTime = process_.time(arguments_.exercise.lastDate());
         Utils.QL_REQUIRE(residualTime > 0.0,
                          () => "expiration time must be > 0");

         double cash = payoff_.cashPayoff();
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;
         if (barrierType == DoubleBarrier.Type.KOKI)
            Utils.swap(ref barrier_lo, ref barrier_hi);

         double sigmaq = variance / residualTime;
         double r = process_.riskFreeRate().currentLink().zeroRate(residualTime, Compounding.Continuous,
                                                                   Frequency.NoFrequency).rate();
         double q = process_.dividendYield().currentLink().zeroRate(residualTime,
                                                                    Compounding.Continuous, Frequency.NoFrequency).rate();
         double b = r - q;

         double alpha = -0.5 * (2 * b / sigmaq - 1);
         double beta = -0.25 * Math.Pow((2 * b / sigmaq - 1), 2) - 2 * r / sigmaq;
         double Z = Math.Log(barrier_hi / barrier_lo);
         double log_S_L = Math.Log(spot / barrier_lo);

         double tot = 0, term = 0;
         for (int i = 1 ; i < maxIteration ; ++i)
         {
            double factor = Math.Pow(i * Const.M_PI / Z, 2) - beta;
            double term1 = (beta - Math.Pow(i * Const.M_PI / Z, 2) * Math.Exp(-0.5 * factor * variance)) / factor;
            double term2 = Math.Sin(i * Const.M_PI / Z * log_S_L);
            term = (2.0 / (i * Const.M_PI)) * term1 * term2;
            tot += term;
         }
         tot += 1 - log_S_L / Z;
         tot *= cash * Math.Pow(spot / barrier_lo, alpha);

         // Check if convergence is sufficiently fast
         Utils.QL_REQUIRE(Math.Abs(term) < requiredConvergence, () => "serie did not converge sufficiently fast");

         return Math.Max(tot, 0.0);
      }

      protected GeneralizedBlackScholesProcess process_;
      protected CashOrNothingPayoff payoff_;
      protected DoubleBarrierOption.Arguments arguments_;
   }
   public class AnalyticDoubleBarrierBinaryEngine : DoubleBarrierOption.Engine
   {
      public AnalyticDoubleBarrierBinaryEngine(GeneralizedBlackScholesProcess process)
      {
         process_ = process;
         process_.registerWith(update);
      }

      public override void calculate()
      {
         if (arguments_.barrierType == DoubleBarrier.Type.KIKO ||
             arguments_.barrierType == DoubleBarrier.Type.KOKI)
         {
            Utils.QL_REQUIRE(arguments_.exercise is AmericanExercise ex, () => "KIKO/KOKI options must have American exercise");
            Utils.QL_REQUIRE(ex.dates()[0] <=
                             process_.blackVolatility().currentLink().referenceDate(),
                             () => "American option with window exercise not handled yet");
         }
         else
         {
            Utils.QL_REQUIRE(arguments_.exercise is AmericanExercise ex, () => "non-European exercise given");
         }
         CashOrNothingPayoff payoff = arguments_.payoff as CashOrNothingPayoff;
         Utils.QL_REQUIRE(payoff != null, () => "a cash-or-nothing payoff must be given");

         double spot = process_.stateVariable().currentLink().value();
         Utils.QL_REQUIRE(spot > 0.0, () => "negative or null underlying given");

         double variance =
            process_.blackVolatility().currentLink().blackVariance(
               arguments_.exercise.lastDate(),
               payoff.strike());
         double barrier_lo = arguments_.barrier_lo.Value;
         double barrier_hi = arguments_.barrier_hi.Value;
         DoubleBarrier.Type barrierType = arguments_.barrierType;
         Utils.QL_REQUIRE(barrier_lo > 0.0,
                          () => "positive low barrier value required");
         Utils.QL_REQUIRE(barrier_hi > 0.0,
                          () => "positive high barrier value required");
         Utils.QL_REQUIRE(barrier_lo < barrier_hi,
                          () => "barrier_lo must be < barrier_hi");
         Utils.QL_REQUIRE(barrierType == DoubleBarrier.Type.KnockIn ||
                          barrierType == DoubleBarrier.Type.KnockOut ||
                          barrierType == DoubleBarrier.Type.KIKO ||
                          barrierType == DoubleBarrier.Type.KOKI,
                          () => "Unsupported barrier type");

         // degenerate cases
         switch (barrierType)
         {
            case DoubleBarrier.Type.KnockOut:
               if (spot <= barrier_lo || spot >= barrier_hi)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KnockIn:
               if (spot <= barrier_lo || spot >= barrier_hi)
               {
                  // knocked in - pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KIKO:
               if (spot >= barrier_hi)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               else if (spot <= barrier_lo)
               {
                  // knocked in, pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;

            case DoubleBarrier.Type.KOKI:
               if (spot <= barrier_lo)
               {
                  // knocked out, no value
                  results_.value = 0;
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               else if (spot >= barrier_hi)
               {
                  // knocked in, pays
                  results_.value = payoff.cashPayoff();
                  results_.delta = 0;
                  results_.gamma = 0;
                  results_.vega = 0;
                  results_.rho = 0;
                  return;
               }
               break;
         }

         AnalyticDoubleBarrierBinaryEngineHelper helper = new AnalyticDoubleBarrierBinaryEngineHelper(process_,
               payoff, arguments_);
         switch (barrierType)
         {
            case DoubleBarrier.Type.KnockOut:
            case DoubleBarrier.Type.KnockIn:
               results_.value = helper.payoffAtExpiry(spot, variance, barrierType);
               break;

            case DoubleBarrier.Type.KIKO:
            case DoubleBarrier.Type.KOKI:
               results_.value = helper.payoffKIKO(spot, variance, barrierType);
               break;
            default:
               results_.value = null;
               break;
         }
      }

      protected GeneralizedBlackScholesProcess process_;
   }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs(22,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs(191,30): error CS0165: Use of unassigned local variable 'ex',D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs(23,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\src\QLNet\Pricingengines\barrier\AnalyticDoubleBarrierBinaryEngine.cs(22,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\tests\QLNet.Tests\T_LiborMarketModel.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
#if NET452
using Microsoft.VisualStudio.TestTools.UnitTesting;
#else
using Xunit;
#endif
using QLNet;

namespace TestSuite
{
#if NET452
   [TestClass()]
#endif
   public class T_LiborMarketModel : IDisposable
   {
      #region Initialize&Cleanup
      private SavedSettings backup;
#if NET452
      [TestInitialize]
      public void testInitialize()
      {
#else
      public T_LiborMarketModel()
      {
#endif
         backup = new SavedSettings();
      }
#if NET452
      [TestCleanup]
#endif
      public void testCleanup()
      {
         Dispose();
      }
      public void Dispose()
      {
         backup.Dispose();
      }
      #endregion

      IborIndex makeIndex(List<Date> dates,
                          List<double> rates)
      {
         DayCounter dayCounter = new Actual360();

         RelinkableHandle<YieldTermStructure> termStructure = new RelinkableHandle<YieldTermStructure>();
         IborIndex index = new Euribor6M(termStructure);

         Date todaysDate =
            index.fixingCalendar().adjust(new Date(4, 9, 2005));
         Settings.setEvaluationDate(todaysDate);

         dates[0] = index.fixingCalendar().advance(todaysDate,
                                                   index.fixingDays(), TimeUnit.Days);
         Linear Interpolator = new Linear();
         termStructure.linkTo(new InterpolatedZeroCurve<Linear>(dates, rates, dayCounter, Interpolator));

         return index;
      }

      IborIndex makeIndex()
      {
         List<Date> dates = new List<Date>();
         List<double> rates = new List<double>();
         dates.Add(new Date(4, 9, 2005));
         dates.Add(new Date(4, 9, 2018));
         rates.Add(0.039);
         rates.Add(0.041);

         return makeIndex(dates, rates);
      }

      OptionletVolatilityStructure makeCapVolCurve(Date todaysDate)
      {
         double[] vols = {14.40, 17.15, 16.81, 16.64, 16.17,
                          15.78, 15.40, 15.21, 14.86
                         };

         List<Date> dates = new List<Date>() ;
         List<double> capletVols = new List<double>();
         LiborForwardModelProcess process =
            new LiborForwardModelProcess(10, makeIndex());

         for (int i = 0; i < 9; ++i)
         {
            capletVols.Add(vols[i] / 100);
            dates.Add(process.fixingDates()[i + 1]);
         }

         return new CapletVarianceCurve(todaysDate, dates,
                                        capletVols, new Actual360());
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testSimpleCovarianceModels()
      {
         // Testing simple covariance models
         const int size = 10;
         const double tolerance = 1e-14;
         int i;

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.1);

         Matrix recon = corrModel.correlation(0.0, null)
                        - corrModel.pseudoSqrt(0.0, null) * Matrix.transpose(corrModel.pseudoSqrt(0.0, null));

         for (i = 0; i < size; ++i)
         {
            for (int j = 0; j < size; ++j)
            {
               if (Math.Abs(recon[i, j]) > tolerance)
                  QAssert.Fail("Failed to reproduce correlation matrix"
                               + "\n    calculated: " + recon[i, j]
                               + "\n    expected:   " + 0);
            }
         }

         List<double> fixingTimes = new InitializedList<double>(size);
         for (i = 0; i < size; ++i)
         {
            fixingTimes[i] = 0.5 * i;
         }

         const double a = 0.2;
         const double b = 0.1;
         const double c = 2.1;
         const double d = 0.3;

         LmVolatilityModel volaModel = new LmLinearExponentialVolatilityModel(fixingTimes, a, b, c, d);

         LfmCovarianceProxy covarProxy = new LfmCovarianceProxy(volaModel, corrModel);

         LiborForwardModelProcess process = new LiborForwardModelProcess(size, makeIndex());

         LiborForwardModel liborModel = new LiborForwardModel(process, volaModel, corrModel);

         for (double t = 0; t < 4.6; t += 0.31)
         {
            recon = covarProxy.covariance(t, null)
                    - covarProxy.diffusion(t, null) * Matrix.transpose(covarProxy.diffusion(t, null));

            for (int k = 0; k < size; ++k)
            {
               for (int j = 0; j < size; ++j)
               {
                  if (Math.Abs(recon[k, j]) > tolerance)
                     QAssert.Fail("Failed to reproduce correlation matrix"
                                  + "\n    calculated: " + recon[k, j]
                                  + "\n    expected:   " + 0);
               }
            }

            Vector volatility = volaModel.volatility(t, null);

            for (int k = 0; k < size; ++k)
            {
               double expected = 0;
               if (k > 2 * t)
               {
                  double T = fixingTimes[k];
                  expected = (a * (T - t) + d) * Math.Exp(-b * (T - t)) + c;
               }

               if (Math.Abs(expected - volatility[k]) > tolerance)
                  QAssert.Fail("Failed to reproduce volatities"
                               + "\n    calculated: " + volatility[k]
                               + "\n    expected:   " + expected);
            }
         }
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testCapletPricing()
      {
         // Testing caplet pricing
         const int size = 10;
#if QL_USE_INDEXED_COUPON
         const double tolerance = 1e-5;
#else
         const double tolerance = 1e-12;
#endif

         IborIndex index = makeIndex();
         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);

         // set-up pricing engine
         OptionletVolatilityStructure capVolCurve = makeCapVolCurve(Settings.evaluationDate());

         Vector variances = new LfmHullWhiteParameterization(process, capVolCurve).covariance(0.0, null).diagonal();

         LmVolatilityModel volaModel = new LmFixedVolatilityModel(Vector.Sqrt(variances), process.fixingTimes());

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.3);

         IAffineModel model = (IAffineModel)(new LiborForwardModel(process, volaModel, corrModel));

         Handle<YieldTermStructure> termStructure = process.index().forwardingTermStructure();

         AnalyticCapFloorEngine engine1 = new AnalyticCapFloorEngine(model, termStructure);

         Cap cap1 = new Cap(process.cashFlows(),
                            new InitializedList<double>(size, 0.04));
         cap1.setPricingEngine(engine1);

         const double expected = 0.015853935178;
         double calculated = cap1.NPV();

         if (Math.Abs(expected - calculated) > tolerance)
            QAssert.Fail("Failed to reproduce npv"
                         + "\n    calculated: " + calculated
                         + "\n    expected:   " + expected);
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testCalibration()
      {
         // Testing calibration of a Libor forward model
         const int size = 14;
         const double tolerance = 8e-3;

         double[] capVols = {0.145708, 0.158465, 0.166248, 0.168672,
                             0.169007, 0.167956, 0.166261, 0.164239,
                             0.162082, 0.159923, 0.157781, 0.155745,
                             0.153776, 0.151950, 0.150189, 0.148582,
                             0.147034, 0.145598, 0.144248
                            };

         double[] swaptionVols = {0.170595, 0.166844, 0.158306, 0.147444,
                                  0.136930, 0.126833, 0.118135, 0.175963,
                                  0.166359, 0.155203, 0.143712, 0.132769,
                                  0.122947, 0.114310, 0.174455, 0.162265,
                                  0.150539, 0.138734, 0.128215, 0.118470,
                                  0.110540, 0.169780, 0.156860, 0.144821,
                                  0.133537, 0.123167, 0.114363, 0.106500,
                                  0.164521, 0.151223, 0.139670, 0.128632,
                                  0.119123, 0.110330, 0.103114, 0.158956,
                                  0.146036, 0.134555, 0.124393, 0.115038,
                                  0.106996, 0.100064
                                 };

         IborIndex index = makeIndex();
         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);
         Handle<YieldTermStructure> termStructure = index.forwardingTermStructure();

         // set-up the model
         LmVolatilityModel volaModel = new LmExtLinearExponentialVolModel(process.fixingTimes(),
                                                                          0.5, 0.6, 0.1, 0.1);

         LmCorrelationModel corrModel = new LmLinearExponentialCorrelationModel(size, 0.5, 0.8);

         LiborForwardModel  model = new LiborForwardModel(process, volaModel, corrModel);

         int swapVolIndex = 0;
         DayCounter dayCounter = index.forwardingTermStructure().link.dayCounter();

         // set-up calibration helper
         List<CalibrationHelper> calibrationHelper = new List<CalibrationHelper>();

         int i;
         for (i = 2; i < size; ++i)
         {
            Period maturity = i * index.tenor();
            Handle<Quote> capVol = new Handle<Quote>(new SimpleQuote(capVols[i - 2]));

            CalibrationHelper caphelper = new CapHelper(maturity, capVol, index, Frequency.Annual,
                                                        index.dayCounter(), true, termStructure, CalibrationHelper.CalibrationErrorType.ImpliedVolError);

            caphelper.setPricingEngine(new AnalyticCapFloorEngine(model, termStructure));

            calibrationHelper.Add(caphelper);

            if (i <= size / 2)
            {
               // add a few swaptions to test swaption calibration as well
               for (int j = 1; j <= size / 2; ++j)
               {
                  Period len = j * index.tenor();
                  Handle<Quote> swaptionVol =  new Handle<Quote>(
                     new SimpleQuote(swaptionVols[swapVolIndex++]));

                  CalibrationHelper swaptionHelper =
                     new SwaptionHelper(maturity, len, swaptionVol, index,
                                        index.tenor(), dayCounter,
                                        index.dayCounter(),
                                        termStructure, CalibrationHelper.CalibrationErrorType.ImpliedVolError);

                  swaptionHelper.setPricingEngine(new LfmSwaptionEngine(model, termStructure));

                  calibrationHelper.Add(swaptionHelper);
               }
            }
         }

         LevenbergMarquardt om = new LevenbergMarquardt(1e-6, 1e-6, 1e-6);
         //ConjugateGradient gc = new ConjugateGradient();

         model.calibrate(calibrationHelper,
                         om,
                         new EndCriteria(2000, 100, 1e-6, 1e-6, 1e-6),
                         new Constraint(),
                         new List<double>());

         // measure the calibration error
         double calculated = 0.0;
         for (i = 0; i < calibrationHelper.Count ; ++i)
         {
            double diff = calibrationHelper[i].calibrationError();
            calculated += diff * diff;
         }

         if (Math.Sqrt(calculated) > tolerance)
            QAssert.Fail("Failed to calibrate libor forward model"
                         + "\n    calculated diff: " + Math.Sqrt(calculated)
                         + "\n    expected : smaller than  " + tolerance);
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testSwaptionPricing()
      {
         // Testing forward swap and swaption pricing
         const int size  = 10;
         const int steps = 8 * size;
#if QL_USE_INDEXED_COUPON
         const double tolerance = 1e-6;
#else
         const double tolerance = 1e-12;
#endif

         List<Date> dates = new List<Date>();
         List<double> rates = new List<double>();
         dates.Add(new Date(4, 9, 2005));
         dates.Add(new Date(4, 9, 2011));
         rates.Add(0.04);
         rates.Add(0.08);

         IborIndex index = makeIndex(dates, rates);

         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.5);

         LmVolatilityModel volaModel = new LmLinearExponentialVolatilityModel(process.fixingTimes(),
                                                                              0.291, 1.483, 0.116, 0.00001);

         // set-up pricing engine
         process.setCovarParam((LfmCovarianceParameterization)
                               new LfmCovarianceProxy(volaModel, corrModel));

         // set-up a small Monte-Carlo simulation to price swations
         List<double> tmp = process.fixingTimes();

         TimeGrid grid = new TimeGrid(tmp, tmp.Count, steps);

         List<int> location = new List<int>();
         for (int i = 0; i < tmp.Count; ++i)
         {
            location.Add(grid.index(tmp[i])) ;
         }

         ulong seed = 42;
         const int nrTrails = 5000;
         LowDiscrepancy.icInstance = new InverseCumulativeNormal();

         IRNG rsg = (InverseCumulativeRsg<RandomSequenceGenerator<MersenneTwisterUniformRng>
                     , InverseCumulativeNormal>)
                    new PseudoRandom().make_sequence_generator(process.factors() * (grid.size() - 1), seed);



         MultiPathGenerator<IRNG> generator = new MultiPathGenerator<IRNG>(process,
                                                                           grid,
                                                                           rsg, false);

         LiborForwardModel liborModel = new LiborForwardModel(process, volaModel, corrModel);

         Calendar calendar = index.fixingCalendar();
         DayCounter dayCounter = index.forwardingTermStructure().link.dayCounter();
         BusinessDayConvention convention = index.businessDayConvention();

         Date settlement = index.forwardingTermStructure().link.referenceDate();

         SwaptionVolatilityMatrix m = liborModel.getSwaptionVolatilityMatrix();

         for (int i = 1; i < size; ++i)
         {
            for (int j = 1; j <= size - i; ++j)
            {
               Date fwdStart    = settlement + new Period(6 * i, TimeUnit.Months);
               Date fwdMaturity = fwdStart + new Period(6 * j, TimeUnit.Months);

               Schedule schedule = new Schedule(fwdStart, fwdMaturity, index.tenor(), calendar,
                                                convention, convention, DateGeneration.Rule.Forward, false);

               double swapRate  = 0.0404;
               VanillaSwap forwardSwap = new VanillaSwap(VanillaSwap.Type.Receiver, 1.0,
                                                         schedule, swapRate, dayCounter,
                                                         schedule, index, 0.0, index.dayCounter());
               forwardSwap.setPricingEngine(new DiscountingSwapEngine(index.forwardingTermStructure()));

               // check forward pricing first
               double expected = forwardSwap.fairRate();
               double calculated = liborModel.S_0(i - 1, i + j - 1);

               if (Math.Abs(expected - calculated) > tolerance)
                  QAssert.Fail("Failed to reproduce fair forward swap rate"
                               + "\n    calculated: " + calculated
                               + "\n    expected:   " + expected);

               swapRate = forwardSwap.fairRate();
               forwardSwap =
                  new VanillaSwap(VanillaSwap.Type.Receiver, 1.0,
                                  schedule, swapRate, dayCounter,
                                  schedule, index, 0.0, index.dayCounter());
               forwardSwap.setPricingEngine(new DiscountingSwapEngine(index.forwardingTermStructure()));

               if (i == j && i <= size / 2)
               {
                  IPricingEngine engine =
                     new LfmSwaptionEngine(liborModel, index.forwardingTermStructure());
                  Exercise exercise =
                     new EuropeanExercise(process.fixingDates()[i]);

                  Swaption swaption =
                     new Swaption(forwardSwap, exercise);
                  swaption.setPricingEngine(engine);

                  GeneralStatistics stat = new GeneralStatistics();

                  for (int n = 0; n < nrTrails; ++n)
                  {
                     Sample<IPath> path = (n % 2 != 0) ? generator.antithetic()
                                          : generator.next();
                     MultiPath value = path.value as MultiPath;
                     Utils.QL_REQUIRE(value != null, () => "Invalid Path");
                     //Sample<MultiPath> path = generator.next();
                     List<double> rates_ = new InitializedList<double>(size);
                     for (int k = 0; k < process.size(); ++k)
                     {
                        rates_[k] = value[k][location[i]];
                     }
                     List<double> dis = process.discountBond(rates_);

                     double npv = 0.0;
                     for (int k = i; k < i + j; ++k)
                     {
                        npv += (swapRate - rates_[k])
                               * (process.accrualEndTimes()[k]
                                  - process.accrualStartTimes()[k]) * dis[k];
                     }
                     stat.add(Math.Max(npv, 0.0));
                  }

                  if (Math.Abs(swaption.NPV() - stat.mean())
                      > stat.errorEstimate() * 2.35)
                     QAssert.Fail("Failed to reproduce swaption npv"
                                  + "\n    calculated: " + stat.mean()
                                  + "\n    expected:   " + swaption.NPV());
               }
            }
         }
      }
   }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
#if NET452
using Microsoft.VisualStudio.TestTools.UnitTesting;
#else
using Xunit;
#endif
using QLNet;

namespace TestSuite
{
#if NET452
   [TestClass()]
#endif
   public class T_LiborMarketModel : IDisposable
   {
      #region Initialize&Cleanup
      private SavedSettings backup;
#if NET452
      [TestInitialize]
      public void testInitialize()
      {
#else
      public T_LiborMarketModel()
      {
#endif
         backup = new SavedSettings();
      }
#if NET452
      [TestCleanup]
#endif
      public void testCleanup()
      {
         Dispose();
      }
      public void Dispose()
      {
         backup.Dispose();
      }
      #endregion

      IborIndex makeIndex(List<Date> dates,
                          List<double> rates)
      {
         DayCounter dayCounter = new Actual360();

         RelinkableHandle<YieldTermStructure> termStructure = new RelinkableHandle<YieldTermStructure>();
         IborIndex index = new Euribor6M(termStructure);

         Date todaysDate =
            index.fixingCalendar().adjust(new Date(4, 9, 2005));
         Settings.setEvaluationDate(todaysDate);

         dates[0] = index.fixingCalendar().advance(todaysDate,
                                                   index.fixingDays(), TimeUnit.Days);
         Linear Interpolator = new Linear();
         termStructure.linkTo(new InterpolatedZeroCurve<Linear>(dates, rates, dayCounter, Interpolator));

         return index;
      }

      IborIndex makeIndex()
      {
         List<Date> dates = new List<Date>();
         List<double> rates = new List<double>();
         dates.Add(new Date(4, 9, 2005));
         dates.Add(new Date(4, 9, 2018));
         rates.Add(0.039);
         rates.Add(0.041);

         return makeIndex(dates, rates);
      }

      OptionletVolatilityStructure makeCapVolCurve(Date todaysDate)
      {
         double[] vols = {14.40, 17.15, 16.81, 16.64, 16.17,
                          15.78, 15.40, 15.21, 14.86
                         };

         List<Date> dates = new List<Date>() ;
         List<double> capletVols = new List<double>();
         LiborForwardModelProcess process =
            new LiborForwardModelProcess(10, makeIndex());

         for (int i = 0; i < 9; ++i)
         {
            capletVols.Add(vols[i] / 100);
            dates.Add(process.fixingDates()[i + 1]);
         }

         return new CapletVarianceCurve(todaysDate, dates,
                                        capletVols, new Actual360());
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testSimpleCovarianceModels()
      {
         // Testing simple covariance models
         const int size = 10;
         const double tolerance = 1e-14;
         int i;

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.1);

         Matrix recon = corrModel.correlation(0.0, null)
                        - corrModel.pseudoSqrt(0.0, null) * Matrix.transpose(corrModel.pseudoSqrt(0.0, null));

         for (i = 0; i < size; ++i)
         {
            for (int j = 0; j < size; ++j)
            {
               if (Math.Abs(recon[i, j]) > tolerance)
                  QAssert.Fail("Failed to reproduce correlation matrix"
                               + "\n    calculated: " + recon[i, j]
                               + "\n    expected:   " + 0);
            }
         }

         List<double> fixingTimes = new InitializedList<double>(size);
         for (i = 0; i < size; ++i)
         {
            fixingTimes[i] = 0.5 * i;
         }

         const double a = 0.2;
         const double b = 0.1;
         const double c = 2.1;
         const double d = 0.3;

         LmVolatilityModel volaModel = new LmLinearExponentialVolatilityModel(fixingTimes, a, b, c, d);

         LfmCovarianceProxy covarProxy = new LfmCovarianceProxy(volaModel, corrModel);

         LiborForwardModelProcess process = new LiborForwardModelProcess(size, makeIndex());

         LiborForwardModel liborModel = new LiborForwardModel(process, volaModel, corrModel);

         for (double t = 0; t < 4.6; t += 0.31)
         {
            recon = covarProxy.covariance(t, null)
                    - covarProxy.diffusion(t, null) * Matrix.transpose(covarProxy.diffusion(t, null));

            for (int k = 0; k < size; ++k)
            {
               for (int j = 0; j < size; ++j)
               {
                  if (Math.Abs(recon[k, j]) > tolerance)
                     QAssert.Fail("Failed to reproduce correlation matrix"
                                  + "\n    calculated: " + recon[k, j]
                                  + "\n    expected:   " + 0);
               }
            }

            Vector volatility = volaModel.volatility(t, null);

            for (int k = 0; k < size; ++k)
            {
               double expected = 0;
               if (k > 2 * t)
               {
                  double T = fixingTimes[k];
                  expected = (a * (T - t) + d) * Math.Exp(-b * (T - t)) + c;
               }

               if (Math.Abs(expected - volatility[k]) > tolerance)
                  QAssert.Fail("Failed to reproduce volatities"
                               + "\n    calculated: " + volatility[k]
                               + "\n    expected:   " + expected);
            }
         }
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testCapletPricing()
      {
         // Testing caplet pricing
         const int size = 10;
#if QL_USE_INDEXED_COUPON
         const double tolerance = 1e-5;
#else
         const double tolerance = 1e-12;
#endif

         IborIndex index = makeIndex();
         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);

         // set-up pricing engine
         OptionletVolatilityStructure capVolCurve = makeCapVolCurve(Settings.evaluationDate());

         Vector variances = new LfmHullWhiteParameterization(process, capVolCurve).covariance(0.0, null).diagonal();

         LmVolatilityModel volaModel = new LmFixedVolatilityModel(Vector.Sqrt(variances), process.fixingTimes());

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.3);

         IAffineModel model = (IAffineModel)(new LiborForwardModel(process, volaModel, corrModel));

         Handle<YieldTermStructure> termStructure = process.index().forwardingTermStructure();

         AnalyticCapFloorEngine engine1 = new AnalyticCapFloorEngine(model, termStructure);

         Cap cap1 = new Cap(process.cashFlows(),
                            new InitializedList<double>(size, 0.04));
         cap1.setPricingEngine(engine1);

         const double expected = 0.015853935178;
         double calculated = cap1.NPV();

         if (Math.Abs(expected - calculated) > tolerance)
            QAssert.Fail("Failed to reproduce npv"
                         + "\n    calculated: " + calculated
                         + "\n    expected:   " + expected);
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testCalibration()
      {
         // Testing calibration of a Libor forward model
         const int size = 14;
         const double tolerance = 8e-3;

         double[] capVols = {0.145708, 0.158465, 0.166248, 0.168672,
                             0.169007, 0.167956, 0.166261, 0.164239,
                             0.162082, 0.159923, 0.157781, 0.155745,
                             0.153776, 0.151950, 0.150189, 0.148582,
                             0.147034, 0.145598, 0.144248
                            };

         double[] swaptionVols = {0.170595, 0.166844, 0.158306, 0.147444,
                                  0.136930, 0.126833, 0.118135, 0.175963,
                                  0.166359, 0.155203, 0.143712, 0.132769,
                                  0.122947, 0.114310, 0.174455, 0.162265,
                                  0.150539, 0.138734, 0.128215, 0.118470,
                                  0.110540, 0.169780, 0.156860, 0.144821,
                                  0.133537, 0.123167, 0.114363, 0.106500,
                                  0.164521, 0.151223, 0.139670, 0.128632,
                                  0.119123, 0.110330, 0.103114, 0.158956,
                                  0.146036, 0.134555, 0.124393, 0.115038,
                                  0.106996, 0.100064
                                 };

         IborIndex index = makeIndex();
         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);
         Handle<YieldTermStructure> termStructure = index.forwardingTermStructure();

         // set-up the model
         LmVolatilityModel volaModel = new LmExtLinearExponentialVolModel(process.fixingTimes(),
                                                                          0.5, 0.6, 0.1, 0.1);

         LmCorrelationModel corrModel = new LmLinearExponentialCorrelationModel(size, 0.5, 0.8);

         LiborForwardModel  model = new LiborForwardModel(process, volaModel, corrModel);

         int swapVolIndex = 0;
         DayCounter dayCounter = index.forwardingTermStructure().link.dayCounter();

         // set-up calibration helper
         List<CalibrationHelper> calibrationHelper = new List<CalibrationHelper>();

         int i;
         for (i = 2; i < size; ++i)
         {
            Period maturity = i * index.tenor();
            Handle<Quote> capVol = new Handle<Quote>(new SimpleQuote(capVols[i - 2]));

            CalibrationHelper caphelper = new CapHelper(maturity, capVol, index, Frequency.Annual,
                                                        index.dayCounter(), true, termStructure, CalibrationHelper.CalibrationErrorType.ImpliedVolError);

            caphelper.setPricingEngine(new AnalyticCapFloorEngine(model, termStructure));

            calibrationHelper.Add(caphelper);

            if (i <= size / 2)
            {
               // add a few swaptions to test swaption calibration as well
               for (int j = 1; j <= size / 2; ++j)
               {
                  Period len = j * index.tenor();
                  Handle<Quote> swaptionVol =  new Handle<Quote>(
                     new SimpleQuote(swaptionVols[swapVolIndex++]));

                  CalibrationHelper swaptionHelper =
                     new SwaptionHelper(maturity, len, swaptionVol, index,
                                        index.tenor(), dayCounter,
                                        index.dayCounter(),
                                        termStructure, CalibrationHelper.CalibrationErrorType.ImpliedVolError);

                  swaptionHelper.setPricingEngine(new LfmSwaptionEngine(model, termStructure));

                  calibrationHelper.Add(swaptionHelper);
               }
            }
         }

         LevenbergMarquardt om = new LevenbergMarquardt(1e-6, 1e-6, 1e-6);
         //ConjugateGradient gc = new ConjugateGradient();

         model.calibrate(calibrationHelper,
                         om,
                         new EndCriteria(2000, 100, 1e-6, 1e-6, 1e-6),
                         new Constraint(),
                         new List<double>());

         // measure the calibration error
         double calculated = 0.0;
         for (i = 0; i < calibrationHelper.Count ; ++i)
         {
            double diff = calibrationHelper[i].calibrationError();
            calculated += diff * diff;
         }

         if (Math.Sqrt(calculated) > tolerance)
            QAssert.Fail("Failed to calibrate libor forward model"
                         + "\n    calculated diff: " + Math.Sqrt(calculated)
                         + "\n    expected : smaller than  " + tolerance);
      }

#if NET452
      [TestCategory("LongRun"), TestMethod()]
#else
      [Fact(Skip = "LongRun")]
#endif
      public void testSwaptionPricing()
      {
         // Testing forward swap and swaption pricing
         const int size  = 10;
         const int steps = 8 * size;
#if QL_USE_INDEXED_COUPON
         const double tolerance = 1e-6;
#else
         const double tolerance = 1e-12;
#endif

         List<Date> dates = new List<Date>();
         List<double> rates = new List<double>();
         dates.Add(new Date(4, 9, 2005));
         dates.Add(new Date(4, 9, 2011));
         rates.Add(0.04);
         rates.Add(0.08);

         IborIndex index = makeIndex(dates, rates);

         LiborForwardModelProcess process = new LiborForwardModelProcess(size, index);

         LmCorrelationModel corrModel = new LmExponentialCorrelationModel(size, 0.5);

         LmVolatilityModel volaModel = new LmLinearExponentialVolatilityModel(process.fixingTimes(),
                                                                              0.291, 1.483, 0.116, 0.00001);

         // set-up pricing engine
         process.setCovarParam((LfmCovarianceParameterization)
                               new LfmCovarianceProxy(volaModel, corrModel));

         // set-up a small Monte-Carlo simulation to price swations
         List<double> tmp = process.fixingTimes();

         TimeGrid grid = new TimeGrid(tmp, tmp.Count, steps);

         List<int> location = new List<int>();
         for (int i = 0; i < tmp.Count; ++i)
         {
            location.Add(grid.index(tmp[i])) ;
         }

         ulong seed = 42;
         const int nrTrails = 5000;
         LowDiscrepancy.icInstance = new InverseCumulativeNormal();

         IRNG rsg = (InverseCumulativeRsg<RandomSequenceGenerator<MersenneTwisterUniformRng>
                     , InverseCumulativeNormal>)
                    new PseudoRandom().make_sequence_generator(process.factors() * (grid.size() - 1), seed);



         MultiPathGenerator<IRNG> generator = new MultiPathGenerator<IRNG>(process,
                                                                           grid,
                                                                           rsg, false);

         LiborForwardModel liborModel = new LiborForwardModel(process, volaModel, corrModel);

         Calendar calendar = index.fixingCalendar();
         DayCounter dayCounter = index.forwardingTermStructure().link.dayCounter();
         BusinessDayConvention convention = index.businessDayConvention();

         Date settlement = index.forwardingTermStructure().link.referenceDate();

         SwaptionVolatilityMatrix m = liborModel.getSwaptionVolatilityMatrix();

         for (int i = 1; i < size; ++i)
         {
            for (int j = 1; j <= size - i; ++j)
            {
               Date fwdStart    = settlement + new Period(6 * i, TimeUnit.Months);
               Date fwdMaturity = fwdStart + new Period(6 * j, TimeUnit.Months);

               Schedule schedule = new Schedule(fwdStart, fwdMaturity, index.tenor(), calendar,
                                                convention, convention, DateGeneration.Rule.Forward, false);

               double swapRate  = 0.0404;
               VanillaSwap forwardSwap = new VanillaSwap(VanillaSwap.Type.Receiver, 1.0,
                                                         schedule, swapRate, dayCounter,
                                                         schedule, index, 0.0, index.dayCounter());
               forwardSwap.setPricingEngine(new DiscountingSwapEngine(index.forwardingTermStructure()));

               // check forward pricing first
               double expected = forwardSwap.fairRate();
               double calculated = liborModel.S_0(i - 1, i + j - 1);

               if (Math.Abs(expected - calculated) > tolerance)
                  QAssert.Fail("Failed to reproduce fair forward swap rate"
                               + "\n    calculated: " + calculated
                               + "\n    expected:   " + expected);

               swapRate = forwardSwap.fairRate();
               forwardSwap =
                  new VanillaSwap(VanillaSwap.Type.Receiver, 1.0,
                                  schedule, swapRate, dayCounter,
                                  schedule, index, 0.0, index.dayCounter());
               forwardSwap.setPricingEngine(new DiscountingSwapEngine(index.forwardingTermStructure()));

               if (i == j && i <= size / 2)
               {
                  IPricingEngine engine =
                     new LfmSwaptionEngine(liborModel, index.forwardingTermStructure());
                  Exercise exercise =
                     new EuropeanExercise(process.fixingDates()[i]);

                  Swaption swaption =
                     new Swaption(forwardSwap, exercise);
                  swaption.setPricingEngine(engine);

                  GeneralStatistics stat = new GeneralStatistics();

                  for (int n = 0; n < nrTrails; ++n)
                  {
                     Sample<IPath> path = (n % 2 != 0) ? generator.antithetic()
                                          : generator.next();
                     Utils.QL_REQUIRE(path.value is MultiPath value, () => "Invalid Path");
                     //Sample<MultiPath> path = generator.next();
                     List<double> rates_ = new InitializedList<double>(size);
                     for (int k = 0; k < process.size(); ++k)
                     {
                        rates_[k] = value[k][location[i]];
                     }
                     List<double> dis = process.discountBond(rates_);

                     double npv = 0.0;
                     for (int k = i; k < i + j; ++k)
                     {
                        npv += (swapRate - rates_[k])
                               * (process.accrualEndTimes()[k]
                                  - process.accrualStartTimes()[k]) * dis[k];
                     }
                     stat.add(Math.Max(npv, 0.0));
                  }

                  if (Math.Abs(swaption.NPV() - stat.mean())
                      > stat.errorEstimate() * 2.35)
                     QAssert.Fail("Failed to reproduce swaption npv"
                                  + "\n    calculated: " + stat.mean()
                                  + "\n    expected:   " + swaption.NPV());
               }
            }
         }
      }
   }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\tests\QLNet.Tests\T_LiborMarketModel.cs(475,37): error CS0165: Use of unassigned local variable 'value'
######################################################################


