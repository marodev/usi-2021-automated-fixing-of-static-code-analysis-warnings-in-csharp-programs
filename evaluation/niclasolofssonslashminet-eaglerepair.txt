Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: MiNET
    #1 Path: D:\a\1\s\src\MiNET\MiNET\Enchantment.cs, Line: 393, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #2 Path: D:\a\1\s\src\MiNET\MiNET\Entities\EntitySpawnManager.cs, Line: 131, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #3 Path: D:\a\1\s\src\MiNET\MiNET\Entities\EntitySpawnManager.cs, Line: 145, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #4 Path: D:\a\1\s\src\MiNET\MiNET\Entities\Mob.cs, Line: 154, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #5 Path: D:\a\1\s\src\MiNET\MiNET\Entities\Mob.cs, Line: 164, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #6 Path: D:\a\1\s\src\MiNET\MiNET\Entities\Projectiles\Projectile.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\src\MiNET\MiNET\HealthManager.cs, Line: 117, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #8 Path: D:\a\1\s\src\MiNET\MiNET\HealthManager.cs, Line: 267, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #9 Path: D:\a\1\s\src\MiNET\MiNET\Items\ItemFactory.cs, Line: 87, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #10 Path: D:\a\1\s\src\MiNET\MiNET\Net\McpeAvailableCommands.cs, Line: 53, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #11 Path: D:\a\1\s\src\MiNET\MiNET\Net\Packet.cs, Line: 1657, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #12 Path: D:\a\1\s\src\MiNET\MiNET\Net\Packet.cs, Line: 1754, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #13 Path: D:\a\1\s\src\MiNET\MiNET\Net\Packet.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #14 Path: D:\a\1\s\src\MiNET\MiNET\Net\Packet.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #15 Path: D:\a\1\s\src\MiNET\MiNET\Net\Packet.cs, Line: 771, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\src\MiNET\MiNET\Player.cs, Line: 1861, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #17 Path: D:\a\1\s\src\MiNET\MiNET\Player.cs, Line: 2387, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\src\MiNET\MiNET\Player.cs, Line: 599, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\src\MiNET\MiNET\Plugins\PluginManager.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\src\MiNET\MiNET\Plugins\PluginManager.cs, Line: 177, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\src\MiNET\MiNET\Plugins\PluginManager.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\src\MiNET\MiNET\Plugins\PluginManager.cs, Line: 563, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\src\MiNET\MiNET\UI\CustomForm.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #24 Path: D:\a\1\s\src\MiNET\MiNET\UI\CustomForm.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #25 Path: D:\a\1\s\src\MiNET\MiNET\UI\CustomForm.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #26 Path: D:\a\1\s\src\MiNET\MiNET\UI\CustomForm.cs, Line: 2, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #27 Path: D:\a\1\s\src\MiNET\MiNET\UI\CustomForm.cs, Line: 60, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #28 Path: D:\a\1\s\src\MiNET\MiNET\Utils\DedicatedThreadPool.cs, Line: 334, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\src\MiNET\MiNET\Utils\DedicatedThreadPool.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #30 Path: D:\a\1\s\src\MiNET\MiNET\Utils\DedicatedThreadPool.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #31 Path: D:\a\1\s\src\MiNET\MiNET\Worlds\AnvilWorldProvider.cs, Line: 459, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #32 Path: D:\a\1\s\src\MiNET\MiNET\Worlds\AnvilWorldProvider.cs, Line: 477, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #33 Path: D:\a\1\s\src\MiNET\MiNET\Worlds\BlockLightCalculations.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #34 Path: D:\a\1\s\src\MiNET\MiNET\Worlds\Level.cs, Line: 1519, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: MiNET.Client
    #35 Path: D:\a\1\s\src\MiNET\MiNET.Client\BedrockTraceHandler.cs, Line: 658, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #36 Path: D:\a\1\s\src\MiNET\MiNET.Client\BedrockTraceHandler.cs, Line: 697, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #37 Path: D:\a\1\s\src\MiNET\MiNET.Client\BedrockTraceHandler.cs, Line: 728, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\src\MiNET\MiNET.Client\BedrockTraceHandler.cs, Line: 735, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs, Line: 197, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: TestPlugin
    #40 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 1042, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #41 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 1065, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #42 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 1125, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #43 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 1319, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #44 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 774, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #45 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 824, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #46 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 848, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #47 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 855, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #48 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 868, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #49 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 869, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #50 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 870, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #51 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 871, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #52 Path: D:\a\1\s\src\MiNET\TestPlugin\CoreCommands.cs, Line: 997, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #53 Path: D:\a\1\s\src\MiNET\TestPlugin\NiceLobby\NiceLobbyPlugin.cs, Line: 869, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #54 Path: D:\a\1\s\src\MiNET\TestPlugin\NiceLobby\NiceLobbyPlugin.cs, Line: 943, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #55 Path: D:\a\1\s\src\MiNET\TestPlugin\NiceLobby\NiceLobbyPlugin.cs, Line: 950, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #56 Path: D:\a\1\s\src\MiNET\TestPlugin\Pets\PetHealthManager.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\src\MiNET\TestPlugin\Pets\PetsPlugin.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: MiNETTests
    #58 Path: D:\a\1\s\src\MiNET\MiNET.Test\GenerateBlocksTests.cs, Line: 144, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #59 Path: D:\a\1\s\src\MiNET\MiNET.Test\GenerateBlocksTests.cs, Line: 145, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #60 Path: D:\a\1\s\src\MiNET\MiNET.Test\Streaming\RecyclableMemoryStream.cs, Line: 403, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #61 Path: D:\a\1\s\src\MiNET\MiNET.Test\Streaming\RecyclableMemoryStream.cs, Line: 505, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #62 Path: D:\a\1\s\src\MiNET\MiNET.Test\Streaming\RecyclableMemoryStreamManager.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #63 Path: D:\a\1\s\src\MiNET\MiNET.Test\Streaming\RecyclableMemoryStreamManager.cs, Line: 77, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R9: 24
R8: 19
R5: 9
R6: 7
R7: 3
R4: 1

--- Summary ---
Fixed ReSharper issues: 63
Fixed SonarQube issues: 17
Total fixed issues: 63

Finished in: 16 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\MiNET\MiNET\HealthManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.ComponentModel;
using System.Numerics;
using System.Reflection;
using System.Threading.Tasks;
using log4net;
using MiNET.Entities;
using MiNET.Items;
using MiNET.Net;
using MiNET.Utils;
using MiNET.Worlds;

namespace MiNET
{
	public enum DamageCause
	{
		[Description("{0} went MIA")] Unknown,

		[Description("{0} was pricked  to death")]
		Contact,
		[Description("{0} was slain by {1}")] EntityAttack,
		[Description("{0} was shot by {1}")] Projectile,

		[Description("{0} suffocated in a wall")]
		Suffocation,

		[Description("{0} hit the ground too hard")]
		Fall,
		[Description("{0} went up in flames")] Fire,
		[Description("{0} burned to death")] FireTick,

		[Description("{0} tried to swim in lava")]
		Lava,
		[Description("{0} drowned")] Drowning,
		[Description("{0} blew up")] BlockExplosion,
		[Description("{0} blew up")] EntityExplosion,

		[Description("{0} fell out of the world")]
		Void,
		[Description("{0} died")] Suicide,

		[Description("{0} was killed by magic")]
		Magic,
		[Description("{0} starved to death")] Starving,

		[Description("{0} died a customized death")]
		Custom
	}

	public class HealthManager
	{
		private static readonly ILog Log = LogManager.GetLogger(typeof(HealthManager));

		public Entity Entity { get; set; }
		public int MaxHealth { get; set; } = 200;
		public int Health { get; set; }
		public float Absorption { get; set; }
		public short MaxAir { get; set; } = 400;
		public short Air { get; set; }
		public bool IsDead { get; set; }
		public int FireTick { get; set; }
		public int SuffocationTicks { get; set; }
		public int LavaTicks { get; set; }
		public int CooldownTick { get; set; }
		public bool IsOnFire { get; set; }
		public bool IsInvulnerable { get; set; }
		public DamageCause LastDamageCause { get; set; }
		public Entity LastDamageSource { get; set; }

		public HealthManager(Entity entity)
		{
			Entity = entity;
			ResetHealth();
		}

		public int Hearts
		{
			get { return (int) Math.Ceiling(Health / 10d); }
		}

		public int MaxHearts
		{
			get { return (int) Math.Ceiling(MaxHealth / 10d); }
		}

		public virtual void Regen(int amount = 1)
		{
			Health += amount * 10;
			if (Health > MaxHealth) Health = MaxHealth;

			var player = Entity as Player;
			player?.SendUpdateAttributes();
		}

		public virtual void TakeHit(Entity source, int damage = 1, DamageCause cause = DamageCause.Unknown)
		{
			TakeHit(source, null, damage, cause);
		}

		public virtual void TakeHit(Entity source, Item tool, int damage = 1, DamageCause cause = DamageCause.Unknown)
		{
			var player = Entity as Player;
			if (player != null && player.GameMode != GameMode.Survival) return;


			if (CooldownTick > 0) return;

			LastDamageSource = source;
			LastDamageCause = cause;
			if (Absorption > 0)
			{
				float abs = Absorption * 10;
				abs = abs - damage;
				if (abs < 0)
				{
					Absorption = 0;
					damage = Math.Abs((int) Math.Floor(abs));
				}
				else
				{
					Absorption = abs / 10f;
					damage = 0;
				}
			}

			if (cause == DamageCause.Starving)
			{
				if (Entity.Level.Difficulty <= Difficulty.Easy && Hearts <= 10) return;
				if (Entity.Level.Difficulty <= Difficulty.Normal && Hearts <= 1) return;
			}

			Health -= damage * 10;
			if (Health < 0)
			{
				OnPlayerTakeHit(new HealthEventArgs(this, source, Entity));
				Health = 0;
				Kill();
				return;
			}

			if (player != null)
			{
				player.HungerManager.IncreaseExhaustion(0.3f);

				player.SendUpdateAttributes();
			}

			Entity.BroadcastEntityEvent();

			if (source != null)
			{
				DoKnockback(source, tool);
			}

			CooldownTick = 10;

			OnPlayerTakeHit(new HealthEventArgs(this, source, Entity));
		}

		protected virtual void DoKnockback(Entity source, Item tool)
		{
			double dx = source.KnownPosition.X - Entity.KnownPosition.X;

			Random rand = new Random();
			double dz;
			for (dz = source.KnownPosition.Z - Entity.KnownPosition.Z; dx * dx + dz * dz < 0.00010; dz = (rand.NextDouble() - rand.NextDouble()) * 0.01D)
			{
				dx = (rand.NextDouble() - rand.NextDouble()) * 0.01D;
			}

			double knockbackForce = Math.Sqrt(dx * dx + dz * dz);
			float knockbackMultiplier = 0.4F;

			//this.motX /= 2.0D;
			//this.motY /= 2.0D;
			//this.motZ /= 2.0D;
			double motX = 0;
			motX -= dx / knockbackForce * knockbackMultiplier;
			double motY = knockbackMultiplier;
			double motZ = 0;
			motZ -= dz / knockbackForce * knockbackMultiplier;
			if (motY > 0.4)
			{
				motY = 0.4;
			}

			var velocity = new Vector3((float) motX, (float) motY + 0.0f, (float) motZ);

			if (tool != null)
			{
				var knockback = tool.GetEnchantingLevel(EnchantingType.Knockback);
				velocity += Vector3.Normalize(velocity) * new Vector3(knockback * 0.5f, 0.1f, knockback * 0.5f);
			}

			Entity.Knockback(velocity);
		}

		public event EventHandler<HealthEventArgs> PlayerTakeHit;

		protected virtual void OnPlayerTakeHit(HealthEventArgs e)
		{
			EventHandler<HealthEventArgs> handler = PlayerTakeHit;
			if (handler != null) handler(this, e);
		}

		public virtual void Ignite(int ticks = 300)
		{
			if (IsDead) return;

			Player player = Entity as Player;
			if (player != null)
			{
				ticks -= ticks * player.DamageCalculator.CalculateFireTickReduction(player);
			}

			ticks = Math.Max(0, ticks);

			FireTick = ticks;
			if (!IsOnFire)
			{
				IsOnFire = true;
				Entity.BroadcastSetEntityData();
			}
		}

		private object _killSync = new object();

		public virtual void Kill()
		{
			lock (_killSync)
			{
				if (IsDead) return;
				IsDead = true;

				Health = 0;
			}

			var player = Entity as Player;
			player?.SendUpdateAttributes();

			Entity.BroadcastEntityEvent();

			if (player != null)
			{
				//SendWithDelay(2000, () =>
				//{
				//});

				Entity.BroadcastSetEntityData();
				Entity.DespawnEntity();

				if (!Entity.Level.KeepInventory)
				{
					player.DropInventory();
				}

				var mcpeRespawn = McpeRespawn.CreateObject();
				mcpeRespawn.x = player.SpawnPosition.X;
				mcpeRespawn.y = player.SpawnPosition.Y;
				mcpeRespawn.z = player.SpawnPosition.Z;
				mcpeRespawn.state = (byte) McpeRespawn.RespawnState.Search;
				mcpeRespawn.runtimeEntityId = player.EntityId;
				player.SendPacket(mcpeRespawn);
			}
			else
			{
				if (LastDamageSource is Player && Entity.Level.DoMobloot)
				{
					var drops = Entity.GetDrops();
					foreach (var drop in drops)
					{
						Entity.Level.DropItem(Entity.KnownPosition.ToVector3(), drop);
					}
				}

				// This is semi-good, but we need to give the death-animation time to play.

				SendWithDelay(2000, () =>
				{
					Entity.BroadcastSetEntityData();
					Entity.DespawnEntity();
				});
			}
		}

		private async Task SendWithDelay(int delay, Action action)
		{
			await Task.Delay(delay);
			action();
		}

		public virtual void ResetHealth()
		{
			Health = MaxHealth;
			Air = MaxAir;
			IsOnFire = false;
			FireTick = 0;
			SuffocationTicks = 10;
			LavaTicks = 0;
			IsDead = false;
			CooldownTick = 0;
			LastDamageCause = DamageCause.Unknown;
			LastDamageSource = null;
		}

		public virtual void OnTick()
		{
			if (!Entity.IsSpawned) return;

			if (IsDead) return;

			if (CooldownTick > 0)
			{
				CooldownTick--;
			}
			else
			{
				LastDamageSource = null;
			}

			if (IsInvulnerable) Health = MaxHealth;

			if (Health <= 0)
			{
				Kill();
				return;
			}

			if (Entity.KnownPosition.Y < 0 && !IsDead)
			{
				CooldownTick = 0;
				TakeHit(null, 300, DamageCause.Void);
				return;
			}

			if (IsInWater(Entity.KnownPosition))
			{
				Entity.IsInWater = true;

				Air--;
				if (Air <= 0)
				{
					if (Math.Abs(Air) % 10 == 0)
					{
						TakeHit(null, 1, DamageCause.Drowning);
						Entity.BroadcastSetEntityData();
					}
				}

				Entity.BroadcastSetEntityData();
			}
			else
			{
				Air = MaxAir;

				if (Entity.IsInWater)
				{
					Entity.IsInWater = false;
					Entity.BroadcastSetEntityData();
				}
			}

			if (IsOnFire && (Entity.IsInWater || IsStandingInWater(Entity.KnownPosition)))
			{
				IsOnFire = false;
				FireTick = 0;
				Entity.BroadcastSetEntityData();
			}

			if (IsInOpaque(Entity.KnownPosition))
			{
				if (SuffocationTicks <= 0)
				{
					TakeHit(null, 1, DamageCause.Suffocation);
					Entity.BroadcastSetEntityData();

					SuffocationTicks = 10;
				}
				else
				{
					SuffocationTicks--;
				}
			}
			else
			{
				SuffocationTicks = 10;
			}

			if (IsInLava(Entity.KnownPosition))
			{
				if (LastDamageCause.Equals(DamageCause.Lava))
				{
					FireTick += 2;
				}
				else
				{
					Ignite(300);
				}

				if (LavaTicks <= 0)
				{
					TakeHit(null, 4, DamageCause.Lava);
					Entity.BroadcastSetEntityData();

					LavaTicks = 10;
				}
				else
				{
					LavaTicks--;
				}
			}
			else
			{
				LavaTicks = 0;
			}

			if (!IsInLava(Entity.KnownPosition) && IsOnFire)
			{
				if (FireTick <= 0)
				{
					IsOnFire = false;
					Entity.BroadcastSetEntityData();
				}
				else if (FireTick % 20 == 0)
				{
					var player = Entity as Player;
					if (player != null)
					{
						player.DamageCalculator.CalculatePlayerDamage(null, player, null, 1, DamageCause.FireTick);
						TakeHit(null, 1, DamageCause.FireTick);
					}
					else
					{
						TakeHit(null, 1, DamageCause.FireTick);
					}
					//Entity.BroadcastSetEntityData();
				}

				FireTick--;
			}
		}

		public bool IsInWater(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			float y = playerPosition.Y + 1.62f;

			BlockCoordinates waterPos = new BlockCoordinates
			{
				X = (int) Math.Floor(playerPosition.X),
				Y = (int) Math.Floor(y),
				Z = (int) Math.Floor(playerPosition.Z)
			};

			var block = Entity.Level.GetBlock(waterPos);

			if (block == null || (block.Id != 8 && block.Id != 9)) return false;

			return y < Math.Floor(y) + 1 - ((1f / 9f) - 0.1111111);
		}

		public bool IsStandingInWater(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			var block = Entity.Level.GetBlock(playerPosition);

			if (block == null || (block.Id != 8 && block.Id != 9)) return false;

			return playerPosition.Y < Math.Floor(playerPosition.Y) + 1 - ((1f / 9f) - 0.1111111);
		}

		private bool IsInLava(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			var block = Entity.Level.GetBlock(playerPosition);

			if (block == null || (block.Id != 10 && block.Id != 11)) return false;

			return playerPosition.Y < Math.Floor(playerPosition.Y) + 1 - ((1f / 9f) - 0.1111111);
		}

		private bool IsInOpaque(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			BlockCoordinates solidPos = (BlockCoordinates) playerPosition;
			if (Entity.Height >= 1)
			{
				solidPos.Y += 1;
			}

			var block = Entity.Level.GetBlock(solidPos);

			if (block == null) return false;

			return !block.IsTransparent;
		}

		public static string GetDescription(Enum value)
		{
			FieldInfo fi = value.GetType().GetField(value.ToString());
			DescriptionAttribute[] attributes = (DescriptionAttribute[]) fi.GetCustomAttributes(typeof(DescriptionAttribute), false);

			if (attributes.Length > 0)
				return attributes[0].Description;

			return value.ToString();
		}
	}

	public class HealthEventArgs : EventArgs
	{
		public Entity SourceEntity { get; set; }
		public Entity TargetEntity { get; set; }
		public HealthManager HealthManager { get; set; }

		public HealthEventArgs(HealthManager healthManager, Entity sourceEntity, Entity targetEntity)
		{
			SourceEntity = sourceEntity;
			TargetEntity = targetEntity;
			HealthManager = healthManager;
		}
	}
}
---- Transformed Tree ----
using System;
using System.ComponentModel;
using System.Numerics;
using System.Reflection;
using System.Threading.Tasks;
using log4net;
using MiNET.Entities;
using MiNET.Items;
using MiNET.Net;
using MiNET.Utils;
using MiNET.Worlds;

namespace MiNET
{
	public enum DamageCause
	{
		[Description("{0} went MIA")] Unknown,

		[Description("{0} was pricked  to death")]
		Contact,
		[Description("{0} was slain by {1}")] EntityAttack,
		[Description("{0} was shot by {1}")] Projectile,

		[Description("{0} suffocated in a wall")]
		Suffocation,

		[Description("{0} hit the ground too hard")]
		Fall,
		[Description("{0} went up in flames")] Fire,
		[Description("{0} burned to death")] FireTick,

		[Description("{0} tried to swim in lava")]
		Lava,
		[Description("{0} drowned")] Drowning,
		[Description("{0} blew up")] BlockExplosion,
		[Description("{0} blew up")] EntityExplosion,

		[Description("{0} fell out of the world")]
		Void,
		[Description("{0} died")] Suicide,

		[Description("{0} was killed by magic")]
		Magic,
		[Description("{0} starved to death")] Starving,

		[Description("{0} died a customized death")]
		Custom
	}

	public class HealthManager
	{
		private static readonly ILog Log = LogManager.GetLogger(typeof(HealthManager));

		public Entity Entity { get; set; }
		public int MaxHealth { get; set; } = 200;
		public int Health { get; set; }
		public float Absorption { get; set; }
		public short MaxAir { get; set; } = 400;
		public short Air { get; set; }
		public bool IsDead { get; set; }
		public int FireTick { get; set; }
		public int SuffocationTicks { get; set; }
		public int LavaTicks { get; set; }
		public int CooldownTick { get; set; }
		public bool IsOnFire { get; set; }
		public bool IsInvulnerable { get; set; }
		public DamageCause LastDamageCause { get; set; }
		public Entity LastDamageSource { get; set; }

		public HealthManager(Entity entity)
		{
			Entity = entity;
			ResetHealth();
		}

		public int Hearts
		{
			get { return (int) Math.Ceiling(Health / 10d); }
		}

		public int MaxHearts
		{
			get { return (int) Math.Ceiling(MaxHealth / 10d); }
		}

		public virtual void Regen(int amount = 1)
		{
			Health += amount * 10;
			if (Health > MaxHealth) Health = MaxHealth;

			var player = Entity as Player;
			player?.SendUpdateAttributes();
		}

		public virtual void TakeHit(Entity source, int damage = 1, DamageCause cause = DamageCause.Unknown)
		{
			TakeHit(source, null, damage, cause);
		}

		public virtual void TakeHit(Entity source, Item tool, int damage = 1, DamageCause cause = DamageCause.Unknown)
		{
			if (Entity is Player player && player.GameMode != GameMode.Survival) return;


			if (CooldownTick > 0) return;

			LastDamageSource = source;
			LastDamageCause = cause;
			if (Absorption > 0)
			{
				float abs = Absorption * 10;
				abs = abs - damage;
				if (abs < 0)
				{
					Absorption = 0;
					damage = Math.Abs((int) Math.Floor(abs));
				}
				else
				{
					Absorption = abs / 10f;
					damage = 0;
				}
			}

			if (cause == DamageCause.Starving)
			{
				if (Entity.Level.Difficulty <= Difficulty.Easy && Hearts <= 10) return;
				if (Entity.Level.Difficulty <= Difficulty.Normal && Hearts <= 1) return;
			}

			Health -= damage * 10;
			if (Health < 0)
			{
				OnPlayerTakeHit(new HealthEventArgs(this, source, Entity));
				Health = 0;
				Kill();
				return;
			}

			if (Entity is Player player)
			{
				player.HungerManager.IncreaseExhaustion(0.3f);

				player.SendUpdateAttributes();
			}

			Entity.BroadcastEntityEvent();

			if (source != null)
			{
				DoKnockback(source, tool);
			}

			CooldownTick = 10;

			OnPlayerTakeHit(new HealthEventArgs(this, source, Entity));
		}

		protected virtual void DoKnockback(Entity source, Item tool)
		{
			double dx = source.KnownPosition.X - Entity.KnownPosition.X;

			Random rand = new Random();
			double dz;
			for (dz = source.KnownPosition.Z - Entity.KnownPosition.Z; dx * dx + dz * dz < 0.00010; dz = (rand.NextDouble() - rand.NextDouble()) * 0.01D)
			{
				dx = (rand.NextDouble() - rand.NextDouble()) * 0.01D;
			}

			double knockbackForce = Math.Sqrt(dx * dx + dz * dz);
			float knockbackMultiplier = 0.4F;

			//this.motX /= 2.0D;
			//this.motY /= 2.0D;
			//this.motZ /= 2.0D;
			double motX = 0;
			motX -= dx / knockbackForce * knockbackMultiplier;
			double motY = knockbackMultiplier;
			double motZ = 0;
			motZ -= dz / knockbackForce * knockbackMultiplier;
			if (motY > 0.4)
			{
				motY = 0.4;
			}

			var velocity = new Vector3((float) motX, (float) motY + 0.0f, (float) motZ);

			if (tool != null)
			{
				var knockback = tool.GetEnchantingLevel(EnchantingType.Knockback);
				velocity += Vector3.Normalize(velocity) * new Vector3(knockback * 0.5f, 0.1f, knockback * 0.5f);
			}

			Entity.Knockback(velocity);
		}

		public event EventHandler<HealthEventArgs> PlayerTakeHit;

		protected virtual void OnPlayerTakeHit(HealthEventArgs e)
		{
			EventHandler<HealthEventArgs> handler = PlayerTakeHit;
			if (handler != null) handler(this, e);
		}

		public virtual void Ignite(int ticks = 300)
		{
			if (IsDead) return;

			if (Entity is Player player)
			{
				ticks -= ticks * player.DamageCalculator.CalculateFireTickReduction(player);
			}

			ticks = Math.Max(0, ticks);

			FireTick = ticks;
			if (!IsOnFire)
			{
				IsOnFire = true;
				Entity.BroadcastSetEntityData();
			}
		}

		private object _killSync = new object();

		public virtual void Kill()
		{
			lock (_killSync)
			{
				if (IsDead) return;
				IsDead = true;

				Health = 0;
			}
			player?.SendUpdateAttributes();

			Entity.BroadcastEntityEvent();

			if (Entity is Player player)
			{
				//SendWithDelay(2000, () =>
				//{
				//});

				Entity.BroadcastSetEntityData();
				Entity.DespawnEntity();

				if (!Entity.Level.KeepInventory)
				{
					player.DropInventory();
				}

				var mcpeRespawn = McpeRespawn.CreateObject();
				mcpeRespawn.x = player.SpawnPosition.X;
				mcpeRespawn.y = player.SpawnPosition.Y;
				mcpeRespawn.z = player.SpawnPosition.Z;
				mcpeRespawn.state = (byte) McpeRespawn.RespawnState.Search;
				mcpeRespawn.runtimeEntityId = player.EntityId;
				player.SendPacket(mcpeRespawn);
			}
			else
			{
				if (LastDamageSource is Player && Entity.Level.DoMobloot)
				{
					var drops = Entity.GetDrops();
					foreach (var drop in drops)
					{
						Entity.Level.DropItem(Entity.KnownPosition.ToVector3(), drop);
					}
				}

				// This is semi-good, but we need to give the death-animation time to play.

				SendWithDelay(2000, () =>
				{
					Entity.BroadcastSetEntityData();
					Entity.DespawnEntity();
				});
			}
		}

		private async Task SendWithDelay(int delay, Action action)
		{
			await Task.Delay(delay);
			action();
		}

		public virtual void ResetHealth()
		{
			Health = MaxHealth;
			Air = MaxAir;
			IsOnFire = false;
			FireTick = 0;
			SuffocationTicks = 10;
			LavaTicks = 0;
			IsDead = false;
			CooldownTick = 0;
			LastDamageCause = DamageCause.Unknown;
			LastDamageSource = null;
		}

		public virtual void OnTick()
		{
			if (!Entity.IsSpawned) return;

			if (IsDead) return;

			if (CooldownTick > 0)
			{
				CooldownTick--;
			}
			else
			{
				LastDamageSource = null;
			}

			if (IsInvulnerable) Health = MaxHealth;

			if (Health <= 0)
			{
				Kill();
				return;
			}

			if (Entity.KnownPosition.Y < 0 && !IsDead)
			{
				CooldownTick = 0;
				TakeHit(null, 300, DamageCause.Void);
				return;
			}

			if (IsInWater(Entity.KnownPosition))
			{
				Entity.IsInWater = true;

				Air--;
				if (Air <= 0)
				{
					if (Math.Abs(Air) % 10 == 0)
					{
						TakeHit(null, 1, DamageCause.Drowning);
						Entity.BroadcastSetEntityData();
					}
				}

				Entity.BroadcastSetEntityData();
			}
			else
			{
				Air = MaxAir;

				if (Entity.IsInWater)
				{
					Entity.IsInWater = false;
					Entity.BroadcastSetEntityData();
				}
			}

			if (IsOnFire && (Entity.IsInWater || IsStandingInWater(Entity.KnownPosition)))
			{
				IsOnFire = false;
				FireTick = 0;
				Entity.BroadcastSetEntityData();
			}

			if (IsInOpaque(Entity.KnownPosition))
			{
				if (SuffocationTicks <= 0)
				{
					TakeHit(null, 1, DamageCause.Suffocation);
					Entity.BroadcastSetEntityData();

					SuffocationTicks = 10;
				}
				else
				{
					SuffocationTicks--;
				}
			}
			else
			{
				SuffocationTicks = 10;
			}

			if (IsInLava(Entity.KnownPosition))
			{
				if (LastDamageCause.Equals(DamageCause.Lava))
				{
					FireTick += 2;
				}
				else
				{
					Ignite(300);
				}

				if (LavaTicks <= 0)
				{
					TakeHit(null, 4, DamageCause.Lava);
					Entity.BroadcastSetEntityData();

					LavaTicks = 10;
				}
				else
				{
					LavaTicks--;
				}
			}
			else
			{
				LavaTicks = 0;
			}

			if (!IsInLava(Entity.KnownPosition) && IsOnFire)
			{
				if (FireTick <= 0)
				{
					IsOnFire = false;
					Entity.BroadcastSetEntityData();
				}
				else if (FireTick % 20 == 0)
				{
					if (Entity is Player player)
					{
						player.DamageCalculator.CalculatePlayerDamage(null, player, null, 1, DamageCause.FireTick);
						TakeHit(null, 1, DamageCause.FireTick);
					}
					else
					{
						TakeHit(null, 1, DamageCause.FireTick);
					}
					//Entity.BroadcastSetEntityData();
				}

				FireTick--;
			}
		}

		public bool IsInWater(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			float y = playerPosition.Y + 1.62f;

			BlockCoordinates waterPos = new BlockCoordinates
			{
				X = (int) Math.Floor(playerPosition.X),
				Y = (int) Math.Floor(y),
				Z = (int) Math.Floor(playerPosition.Z)
			};

			var block = Entity.Level.GetBlock(waterPos);

			if (block == null || (block.Id != 8 && block.Id != 9)) return false;

			return y < Math.Floor(y) + 1 - ((1f / 9f) - 0.1111111);
		}

		public bool IsStandingInWater(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			var block = Entity.Level.GetBlock(playerPosition);

			if (block == null || (block.Id != 8 && block.Id != 9)) return false;

			return playerPosition.Y < Math.Floor(playerPosition.Y) + 1 - ((1f / 9f) - 0.1111111);
		}

		private bool IsInLava(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			var block = Entity.Level.GetBlock(playerPosition);

			if (block == null || (block.Id != 10 && block.Id != 11)) return false;

			return playerPosition.Y < Math.Floor(playerPosition.Y) + 1 - ((1f / 9f) - 0.1111111);
		}

		private bool IsInOpaque(PlayerLocation playerPosition)
		{
			if (playerPosition.Y < 0 || playerPosition.Y > 255) return false;

			BlockCoordinates solidPos = (BlockCoordinates) playerPosition;
			if (Entity.Height >= 1)
			{
				solidPos.Y += 1;
			}

			var block = Entity.Level.GetBlock(solidPos);

			if (block == null) return false;

			return !block.IsTransparent;
		}

		public static string GetDescription(Enum value)
		{
			FieldInfo fi = value.GetType().GetField(value.ToString());
			DescriptionAttribute[] attributes = (DescriptionAttribute[]) fi.GetCustomAttributes(typeof(DescriptionAttribute), false);

			if (attributes.Length > 0)
				return attributes[0].Description;

			return value.ToString();
		}
	}

	public class HealthEventArgs : EventArgs
	{
		public Entity SourceEntity { get; set; }
		public Entity TargetEntity { get; set; }
		public HealthManager HealthManager { get; set; }

		public HealthEventArgs(HealthManager healthManager, Entity sourceEntity, Entity targetEntity)
		{
			SourceEntity = sourceEntity;
			TargetEntity = targetEntity;
			HealthManager = healthManager;
		}
	}
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\src\MiNET\MiNET\HealthManager.cs(303,5): warning CS4014: Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\MiNET\MiNET\HealthManager.cs(165,25): error CS0128: A local variable or function named 'player' is already defined in this scope,D:\a\1\s\src\MiNET\MiNET\HealthManager.cs(167,5): error CS0165: Use of unassigned local variable 'player',D:\a\1\s\src\MiNET\MiNET\HealthManager.cs(260,4): error CS0841: Cannot use local variable 'player' before it is declared,D:\a\1\s\src\MiNET\MiNET\HealthManager.cs(299,5): warning CS4014: Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.IO;
using System.Reflection;

namespace MiNET.Client
{
	public class ObjectDumper
	{
		public static void Write(object element)
		{
			Write(element, 0);
		}

		public static void Write(object element, int depth)
		{
			Write(element, depth, Console.Out);
		}

		public static void Write(object element, int depth, TextWriter log)
		{
			ObjectDumper dumper = new ObjectDumper(depth);
			dumper.writer = log;
			dumper.WriteObject(null, element);
		}

		private TextWriter writer;
		private int pos;
		private int level;
		private int depth;

		private ObjectDumper(int depth)
		{
			this.depth = depth;
		}

		private void Write(string s)
		{
			if (s != null)
			{
				writer.Write(s);
				pos += s.Length;
			}
		}

		private void WriteIndent()
		{
			for (int i = 0; i < level; i++) writer.Write("  ");
		}

		private void WriteLine()
		{
			writer.WriteLine();
			pos = 0;
		}

		private void WriteTab()
		{
			Write("\t");
			while (pos % 8 != 0) Write(" ");
		}

		private void WriteObject(string prefix, object element)
		{
			if (element == null || element is ValueType || element is string)
			{
				WriteIndent();
				Write(prefix);
				WriteValue(element);
				WriteLine();
			}
			else
			{
				IEnumerable enumerableElement = element as IEnumerable;
				if (enumerableElement != null)
				{
					foreach (object item in enumerableElement)
					{
						if (item is IEnumerable && !(item is string))
						{
							WriteIndent();
							Write(prefix);
							Write("...");
							WriteLine();
							if (level < depth)
							{
								level++;
								WriteObject(prefix, item);
								level--;
							}
						}
						else
						{
							WriteObject(prefix, item);
						}
					}
				}
				else
				{
					MemberInfo[] members = element.GetType().GetMembers(BindingFlags.Public | BindingFlags.Instance);
					WriteIndent();
					Write(prefix);
					bool propWritten = false;
					foreach (MemberInfo m in members)
					{
						FieldInfo f = m as FieldInfo;
						PropertyInfo p = m as PropertyInfo;
						if (f != null || p != null)
						{
							if (propWritten)
							{
								WriteTab();
							}
							else
							{
								propWritten = true;
							}
							Write(m.Name);
							Write("=");
							Type t = f != null ? f.FieldType : p.PropertyType;
							if (t.IsValueType || t == typeof(string))
							{
								WriteValue(f != null ? f.GetValue(element) : p.GetValue(element, null));
							}
							else
							{
								if (typeof(IEnumerable).IsAssignableFrom(t))
								{
									Write("...");
								}
								else
								{
									Write("{ }");
								}
							}
						}
						if (propWritten) WriteLine();
					}
					if (propWritten) WriteLine();
					if (level < depth)
					{
						foreach (MemberInfo m in members)
						{
							FieldInfo f = m as FieldInfo;
							PropertyInfo p = m as PropertyInfo;
							if (f != null || p != null)
							{
								Type t = f != null ? f.FieldType : p.PropertyType;
								if (!(t.IsValueType || t == typeof(string)))
								{
									object value = f != null ? f.GetValue(element) : p.GetValue(element, null);
									if (value != null)
									{
										level++;
										WriteObject(m.Name + ": ", value);
										level--;
									}
								}
							}
						}
					}
				}
			}
		}

		private void WriteValue(object o)
		{
			if (o == null)
			{
				Write("null");
			}
			else if (o is DateTime dateTime)
			{
				Write(dateTime.ToShortDateString());
			}
			else if (o is ValueType || o is string)
			{
				Write(o.ToString());
			}
			else if (o is IEnumerable)
			{
				Write("...");
			}
			else
			{
				Write("{ }");
			}
		}
	}
}
---- Transformed Tree ----
using System;
using System.Collections;
using System.IO;
using System.Reflection;

namespace MiNET.Client
{
	public class ObjectDumper
	{
		public static void Write(object element)
		{
			Write(element, 0);
		}

		public static void Write(object element, int depth)
		{
			Write(element, depth, Console.Out);
		}

		public static void Write(object element, int depth, TextWriter log)
		{
			ObjectDumper dumper = new ObjectDumper(depth);
			dumper.writer = log;
			dumper.WriteObject(null, element);
		}

		private TextWriter writer;
		private int pos;
		private int level;
		private int depth;

		private ObjectDumper(int depth)
		{
			this.depth = depth;
		}

		private void Write(string s)
		{
			if (s != null)
			{
				writer.Write(s);
				pos += s.Length;
			}
		}

		private void WriteIndent()
		{
			for (int i = 0; i < level; i++) writer.Write("  ");
		}

		private void WriteLine()
		{
			writer.WriteLine();
			pos = 0;
		}

		private void WriteTab()
		{
			Write("\t");
			while (pos % 8 != 0) Write(" ");
		}

		private void WriteObject(string prefix, object element)
		{
			if (element == null || element is ValueType || element is string)
			{
				WriteIndent();
				Write(prefix);
				WriteValue(element);
				WriteLine();
			}
			else
			{
				if (element is IEnumerable enumerableElement)
				{
					foreach (object item in enumerableElement)
					{
						if (item is IEnumerable && !(item is string))
						{
							WriteIndent();
							Write(prefix);
							Write("...");
							WriteLine();
							if (level < depth)
							{
								level++;
								WriteObject(prefix, item);
								level--;
							}
						}
						else
						{
							WriteObject(prefix, item);
						}
					}
				}
				else
				{
					MemberInfo[] members = element.GetType().GetMembers(BindingFlags.Public | BindingFlags.Instance);
					WriteIndent();
					Write(prefix);
					bool propWritten = false;
					foreach (MemberInfo m in members)
					{
						if (m is FieldInfo f || m is PropertyInfo p)
						{
							if (propWritten)
							{
								WriteTab();
							}
							else
							{
								propWritten = true;
							}
							Write(m.Name);
							Write("=");
							Type t = m is FieldInfo f ? f.FieldType : p.PropertyType;
							if (t.IsValueType || t == typeof(string))
							{
								WriteValue(m is FieldInfo f ? f.GetValue(element) : p.GetValue(element, null));
							}
							else
							{
								if (typeof(IEnumerable).IsAssignableFrom(t))
								{
									Write("...");
								}
								else
								{
									Write("{ }");
								}
							}
						}
						if (propWritten) WriteLine();
					}
					if (propWritten) WriteLine();
					if (level < depth)
					{
						foreach (MemberInfo m in members)
						{
							if (m is FieldInfo f || m is PropertyInfo p)
							{
								Type t = m is FieldInfo f ? f.FieldType : p.PropertyType;
								if (!(t.IsValueType || t == typeof(string)))
								{
									object value = m is FieldInfo f ? f.GetValue(element) : p.GetValue(element, null);
									if (value != null)
									{
										level++;
										WriteObject(m.Name + ": ", value);
										level--;
									}
								}
							}
						}
					}
				}
			}
		}

		private void WriteValue(object o)
		{
			if (o == null)
			{
				Write("null");
			}
			else if (o is DateTime dateTime)
			{
				Write(dateTime.ToShortDateString());
			}
			else if (o is ValueType || o is string)
			{
				Write(o.ToString());
			}
			else if (o is IEnumerable)
			{
				Write("...");
			}
			else
			{
				Write("{ }");
			}
		}
	}
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(142,32): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(145,35): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(168,33): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(171,40): error CS0136: A local or parameter named 'f' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(142,50): error CS0165: Use of unassigned local variable 'p',D:\a\1\s\src\MiNET\MiNET.Client\ObjectDumper.cs(168,51): error CS0165: Use of unassigned local variable 'p'
######################################################################


