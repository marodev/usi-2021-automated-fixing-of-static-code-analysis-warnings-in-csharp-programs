diff --git a/src/Arch/Alpha/AlphaRewriter.cs b/src/Arch/Alpha/AlphaRewriter.cs
index 9f59063be..4356bd4bd 100644
--- a/src/Arch/Alpha/AlphaRewriter.cs
+++ b/src/Arch/Alpha/AlphaRewriter.cs
@@ -71,9 +71,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                     Invalid();
                     host.Warn(
                        instr.Address,
-                       string.Format(
-                           "Alpha AXP instruction '{0}' not supported yet.",
-                           instr.Mnemonic));
+                       $"Alpha AXP instruction '{instr.Mnemonic}' not supported yet.");
 
                     break;
                 case Mnemonic.invalid:
@@ -278,7 +276,7 @@ private Expression Rewrite(MachineOperand op, bool highWord = false)
                 }
                 return m.Mem(mop.Width, ea);
             }
-            throw new NotImplementedException(string.Format("{0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"{op} ({op.GetType().Name})");
         }
     }
 }
\ No newline at end of file
diff --git a/src/Arch/Arm/AArch32/Arm32CallingConvention.cs b/src/Arch/Arm/AArch32/Arm32CallingConvention.cs
index d867ea54c..13fc2872c 100644
--- a/src/Arch/Arm/AArch32/Arm32CallingConvention.cs
+++ b/src/Arch/Arm/AArch32/Arm32CallingConvention.cs
@@ -95,7 +95,7 @@ public void SetReturnRegister(ICallingConventionEmitter ccr, int bitSize)
                 ccr.SequenceReturn(argRegs[1], argRegs[0]);
             }
             else
-                throw new NotSupportedException(string.Format("Return values of {0} bits are not supported.", bitSize));
+                throw new NotSupportedException($"Return values of {bitSize} bits are not supported.");
         }
 
         public bool IsArgument(Storage stg)
diff --git a/src/Arch/Arm/AArch32/ArmRewriter.cs b/src/Arch/Arm/AArch32/ArmRewriter.cs
index 47c9787fa..fcca1f5e7 100644
--- a/src/Arch/Arm/AArch32/ArmRewriter.cs
+++ b/src/Arch/Arm/AArch32/ArmRewriter.cs
@@ -957,7 +957,7 @@ void MaybePostOperand(MachineOperand op)
             switch (cond)
             {
             default:
-                throw new NotImplementedException(string.Format("ARM condition code {0} not implemented.", cond));
+                throw new NotImplementedException($"ARM condition code {cond} not implemented.");
             case ArmCondition.HS:
                 return m.Test(ConditionCode.UGE, FlagGroup(FlagM.CF, "C", PrimitiveType.Bool));
             case ArmCondition.LO:
diff --git a/src/Arch/Arm/AArch64/A64Rewriter.cs b/src/Arch/Arm/AArch64/A64Rewriter.cs
index aaa5ab262..873bce6f9 100644
--- a/src/Arch/Arm/AArch64/A64Rewriter.cs
+++ b/src/Arch/Arm/AArch64/A64Rewriter.cs
@@ -357,7 +357,7 @@ protected Expression TestCond(ArmCondition cond)
             switch (cond)
             {
             default:
-                throw new NotImplementedException(string.Format("ARM condition code {0} not implemented.", cond));
+                throw new NotImplementedException($"ARM condition code {cond} not implemented.");
             case ArmCondition.HS:
                 return m.Test(ConditionCode.UGE, FlagGroup(Registers.C));
             case ArmCondition.LO:
diff --git a/src/Arch/Avr/Avr8Architecture.cs b/src/Arch/Avr/Avr8Architecture.cs
index 8d1838541..0038be9b3 100644
--- a/src/Arch/Avr/Avr8Architecture.cs
+++ b/src/Arch/Avr/Avr8Architecture.cs
@@ -50,7 +50,7 @@ public Avr8Architecture(IServiceProvider services, string archId, Dictionary<str
             this.StackRegister = new RegisterStorage("SP", 0x3D, 0, PrimitiveType.Word16);
             this.ByteRegs = Enumerable.Range(0, 32)
                 .Select(n => new RegisterStorage(
-                    string.Format("r{0}", n),
+                    $"r{n}",
                     n,
                     0,
                     PrimitiveType.Byte))
diff --git a/src/Arch/Avr/Avr8Rewriter.cs b/src/Arch/Avr/Avr8Rewriter.cs
index e918b92ab..935ccc5fa 100644
--- a/src/Arch/Avr/Avr8Rewriter.cs
+++ b/src/Arch/Avr/Avr8Rewriter.cs
@@ -147,7 +147,7 @@ public void Rewrite(AvrInstruction instr)
             case Mnemonic.subi: RewriteBinOp(m.ISub, CmpFlags); break;
             case Mnemonic.swap: RewriteSwap(); break;
             default:
-                host.Error(instr.Address, string.Format("AVR8 instruction '{0}' is not supported yet.", instr.Mnemonic));
+                host.Error(instr.Address, $"AVR8 instruction '{instr.Mnemonic}' is not supported yet.");
                 EmitUnitTest();
                 m.Invalid();
                 break;
@@ -257,7 +257,7 @@ private Expression RewriteOp(int iOp)
             case AddressOperand aop:
                 return aop.Address;
             }
-            throw new NotImplementedException(string.Format("Rewriting {0}s not implemented yet.", op.GetType().Name));
+            throw new NotImplementedException($"Rewriting {op.GetType().Name}s not implemented yet.");
         }
 
         private void RewriteMem(int iOp, Expression src, Action<Expression, Expression> write, Expression? seg)
diff --git a/src/Arch/M68k/AddressOperand.cs b/src/Arch/M68k/AddressOperand.cs
index 3238bdb8e..59129f740 100644
--- a/src/Arch/M68k/AddressOperand.cs
+++ b/src/Arch/M68k/AddressOperand.cs
@@ -45,7 +45,7 @@ public T Accept<T>(M68kOperandVisitor<T> visitor)
 
         protected override void DoRender(MachineInstructionRenderer renderer, MachineInstructionRendererOptions options)
         {
-            renderer.WriteAddress(string.Format("${0:X8}", Address.Offset), Address);
+            renderer.WriteAddress($"${Address.Offset:X8}", Address);
         }
     }
 }
diff --git a/src/Arch/M68k/Assembler/Lexer.cs b/src/Arch/M68k/Assembler/Lexer.cs
index 668916151..559496334 100644
--- a/src/Arch/M68k/Assembler/Lexer.cs
+++ b/src/Arch/M68k/Assembler/Lexer.cs
@@ -283,7 +283,7 @@ private static NotImplementedException Unexpected(int ch, char c)
 
         private Token LightToken(TokenType t, State nextState)
         {
-            Debug.Write(string.Format("{0} ", t));
+            Debug.Write($"{t} ");
             if (t == TokenType.NL)
                 Debug.WriteLine("");
             st = nextState;
@@ -294,7 +294,7 @@ private Token HexToken(State nextState)
         {
             string hex = sb.ToString();
             int h = Convert.ToInt32(hex, 16);
-            Debug.Write(string.Format("{0} {1}", TokenType.INTEGER, h));
+            Debug.Write($"{TokenType.INTEGER} {h}");
             sb = new StringBuilder();
             st = nextState;
             return new Token(TokenType.INTEGER, h.ToString(System.Globalization.CultureInfo.InvariantCulture)); 
@@ -303,7 +303,7 @@ private Token HexToken(State nextState)
         private Token BuildToken(TokenType tokenType, State nextState)
         {
             var t = new Token(tokenType, sb.ToString());
-            Debug.Write(string.Format("{0} {1} ", t.Type, t.Text));
+            Debug.Write($"{t.Type} {t.Text} ");
             sb = new StringBuilder();
             st = nextState;
             return t;
@@ -316,10 +316,10 @@ private Token ClassifyTokenText()
             Token kw;
             if (keywords.TryGetValue(text, out kw))
             {
-                Debug.Write(string.Format("{0} ", kw.Type));
+                Debug.Write($"{kw.Type} ");
                 return kw;
             }
-            Debug.Write(string.Format("{0} {1} ", TokenType.ID, text));
+            Debug.Write($"{TokenType.ID} {text} ");
             return new Token(TokenType.ID, text);
         }
     }
diff --git a/src/Arch/M68k/Assembler/M68kAssembler.cs b/src/Arch/M68k/Assembler/M68kAssembler.cs
index 5a0b9759a..be95bc4c7 100644
--- a/src/Arch/M68k/Assembler/M68kAssembler.cs
+++ b/src/Arch/M68k/Assembler/M68kAssembler.cs
@@ -105,19 +105,17 @@ private int Ea(MachineOperand op, int shift)
 
         private int Ea(MachineOperand op)
         {
-            var rop = op as RegisterOperand;
-            if (rop != null)
+            if (op is RegisterOperand rop)
             {
-                var dReg = rop.Register as DataRegister;
-                if (dReg != null)
+                if (rop.Register is DataRegister dReg)
                     return (dReg.Number & 7);
-                var aReg = rop.Register as AddressRegister;
-                if (aReg != null)
+
+                if (rop.Register is AddressRegister aReg)
                     return (aReg.Number & 7) | 8;
                 throw new NotImplementedException(op.ToString());
             }
-            var mop = op as MemoryOperand;
-            if (mop != null)
+
+            if (op is MemoryOperand mop)
             {
                 var aReg = mop.Base;
                 if (mop.Offset == null || mop.Offset.ToInt32() == 0)
@@ -126,26 +124,23 @@ private int Ea(MachineOperand op)
                 return (aReg.Number & 7 | 0x28);
             }
 
-            var postOp = op as PostIncrementMemoryOperand;
-            if (postOp != null)
+            if (op is PostIncrementMemoryOperand postOp)
             {
                 return (postOp.Register.Number & 7 | 0x18);
             }
-            var preOp = op as PredecrementMemoryOperand;
-            if (preOp != null)
+
+            if (op is PredecrementMemoryOperand preOp)
             {
                 return (preOp.Register.Number & 7 | 0x20);
             }
 
-            var addrOp = op as M68kAddressOperand;
-            if (addrOp != null)
+            if (op is M68kAddressOperand addrOp)
             {
                 Imm(addrOp.Width.Size, addrOp.Address.ToUInt32());
                 return 0x39;
             }
 
-            var immOp = op as M68kImmediateOperand;
-            if (immOp != null)
+            if (op is M68kImmediateOperand immOp)
             {
                 Imm(immOp.Width.Size, immOp.Constant.ToUInt32());
                 return 0x3C;
diff --git a/src/Arch/M68k/M68kArchitecture.cs b/src/Arch/M68k/M68kArchitecture.cs
index 4580fe111..4be83703f 100644
--- a/src/Arch/M68k/M68kArchitecture.cs
+++ b/src/Arch/M68k/M68kArchitecture.cs
@@ -106,7 +106,7 @@ public override RegisterStorage GetRegister(string name)
         {
             var r = Registers.GetRegister(name);
             if (r == RegisterStorage.None)
-                throw new ArgumentException(string.Format("'{0}' is not a register name.", name));
+                throw new ArgumentException($"'{name}' is not a register name.");
             return r;
         }
 
diff --git a/src/Arch/M68k/M68kDisassembler.cs b/src/Arch/M68k/M68kDisassembler.cs
index 62a146c26..94dc9dcaf 100644
--- a/src/Arch/M68k/M68kDisassembler.cs
+++ b/src/Arch/M68k/M68kDisassembler.cs
@@ -1416,7 +1416,7 @@ private static bool d68020_cpsave(uint uInstr, M68kDisassembler dasm)
             }
             else
             {
-                dasm.g_dasm_str = string.Format("{0}save   {1}; (2-3)", (uInstr >> 9) & 7, dasm.get_ea_mode_str_8(uInstr));
+                dasm.g_dasm_str = $"{(uInstr >> 9) & 7}save   {dasm.get_ea_mode_str_8(uInstr)}; (2-3)";
             }
             return false;
         }
@@ -1454,7 +1454,7 @@ private static bool d68020_cptrapcc_16(uint uInstr, M68kDisassembler dasm)
                 return false;
             if (!dasm.rdr.TryReadBeInt16(out var s))
                 return false;
-            dasm.g_dasm_str = string.Format("{0}trap{1,4} {2}; (extension = {3}) (2-3)", (uInstr >> 9) & 7, g_cpcc[extension1 & 0x3f], s, extension2);
+            dasm.g_dasm_str = $"{(uInstr >> 9) & 7}trap{g_cpcc[extension1 & 0x3f], 4} {s}; (extension = {extension2}) (2-3)";
             return false;
         }
 
@@ -1486,7 +1486,7 @@ private static bool d68040_cpush(uint uInstr, M68kDisassembler dasm)
                 dasm.g_dasm_str = string.Format("cpushp  {0}, (A%d); (4)", (uInstr >> 6) & 3, uInstr & 7);
                 break;
             case 3:
-                dasm.g_dasm_str = string.Format("cpusha  {0}; (4)", (uInstr >> 6) & 3);
+                dasm.g_dasm_str = $"cpusha  {(uInstr >> 6) & 3}; (4)";
                 break;
             }
             return false;
@@ -1722,7 +1722,7 @@ private static bool d68040_fpu(uint uInstr, M68kDisassembler dasm)
 
             case 0x4:	// ea to control
                 {
-                    dasm.g_dasm_str = string.Format("fmovem.l   {0}, ", dasm.get_ea_mode_str_32(uInstr));
+                    dasm.g_dasm_str = $"fmovem.l   {dasm.get_ea_mode_str_32(uInstr)}, ";
                     if ((dasm.fpWord & 0x1000) != 0) dasm.g_dasm_str += "fpcr";
                     if ((dasm.fpWord & 0x0800) != 0) dasm.g_dasm_str += "/fpsr";
                     if ((dasm.fpWord & 0x0400) != 0) dasm.g_dasm_str += "/fpiar";
@@ -2196,7 +2196,7 @@ private static bool d68040_pflush(uint uInstr, M68kDisassembler dasm)
 
             if ((uInstr & 0x10) != 0)
             {
-                dasm.g_dasm_str = string.Format("pflusha{0}", (uInstr & 8)!=0 ? "" : "n");
+                dasm.g_dasm_str = $"pflusha{((uInstr & 8) != 0 ? "" : "n")}";
             }
             else
             {
@@ -2414,22 +2414,22 @@ private static bool d68851_p000(uint uInstr, M68kDisassembler dasm)
                 {
                     if ((modes & 0x0200)!=0)
                     {
-                        dasm.g_dasm_str = string.Format("pmovefd  {0},{1}", g_mmuregs[(modes >> 10) & 7], op);
+                        dasm.g_dasm_str = $"pmovefd  {g_mmuregs[(modes >> 10) & 7]},{op}";
                     }
                     else
                     {
-                        dasm.g_dasm_str = string.Format("pmovefd  {0},{1}", op, g_mmuregs[(modes >> 10) & 7]);
+                        dasm.g_dasm_str = $"pmovefd  {op},{g_mmuregs[(modes >> 10) & 7]}";
                     }
                 }
                 else
                 {
                     if ((modes & 0x0200)!=0)
                     {
-                        dasm.g_dasm_str = string.Format("pmove  {0},{1}", g_mmuregs[(modes >> 10) & 7], op);
+                        dasm.g_dasm_str = $"pmove  {g_mmuregs[(modes >> 10) & 7]},{op}";
                     }
                     else
                     {
-                        dasm.g_dasm_str = string.Format("pmove  {0},{1}", op, g_mmuregs[(modes >> 10) & 7]);
+                        dasm.g_dasm_str = $"pmove  {op},{g_mmuregs[(modes >> 10) & 7]}";
                     }
                 }
                 break;
@@ -2437,16 +2437,16 @@ private static bool d68851_p000(uint uInstr, M68kDisassembler dasm)
             case 3:	// MC68030 to/from status reg
                 if ((modes & 0x0200)!=0)
                 {
-                    dasm.g_dasm_str = string.Format("pmove  mmusr, {0}", op);
+                    dasm.g_dasm_str = $"pmove  mmusr, {op}";
                 }
                 else
                 {
-                    dasm.g_dasm_str = string.Format("pmove  {0}, mmusr", op);
+                    dasm.g_dasm_str = $"pmove  {op}, mmusr";
                 }
                 break;
 
             default:
-                dasm.g_dasm_str = string.Format("pmove [unknown form] {0}", op);
+                dasm.g_dasm_str = $"pmove [unknown form] {op}";
                 break;
             }
             return false;
diff --git a/src/Arch/M68k/M68kInstruction.cs b/src/Arch/M68k/M68kInstruction.cs
index 431e8ca65..32e1fea3a 100644
--- a/src/Arch/M68k/M68kInstruction.cs
+++ b/src/Arch/M68k/M68kInstruction.cs
@@ -55,7 +55,7 @@ protected override void DoRender(MachineInstructionRenderer renderer, MachineIns
             }
             if (DataWidth != null)
             {
-                renderer.WriteMnemonic(string.Format("{0}{1}", Mnemonic, DataSizeSuffix(DataWidth)));
+                renderer.WriteMnemonic($"{Mnemonic}{DataSizeSuffix(DataWidth)}");
             }
             else
             {
@@ -109,7 +109,7 @@ private string DataSizeSuffix(PrimitiveType dataWidth)
                 case 64: return ".q";
                 }
             }
-            throw new InvalidOperationException(string.Format("Unsupported data width {0}.", dataWidth.BitSize));
+            throw new InvalidOperationException($"Unsupported data width {dataWidth.BitSize}.");
         }
     }
 }
diff --git a/src/Arch/M68k/OperandFormatDecoder.cs b/src/Arch/M68k/OperandFormatDecoder.cs
index c38126a03..b1198e224 100644
--- a/src/Arch/M68k/OperandFormatDecoder.cs
+++ b/src/Arch/M68k/OperandFormatDecoder.cs
@@ -48,7 +48,7 @@ private static PrimitiveType SizeField(ushort opcode, int bitOffset)
             case 0: return PrimitiveType.Byte;
             case 1: return PrimitiveType.Word16;
             case 2: return PrimitiveType.Word32;
-            default: throw new InvalidOperationException(string.Format("Illegal size field in opcode {0:X4}.", opcode));
+            default: throw new InvalidOperationException($"Illegal size field in opcode {opcode:X4}.");
             }
         }
 
@@ -210,7 +210,7 @@ private bool TryParseOperandInner(ushort uInstr, byte addressMode, byte operandB
                     return false;
                 }
             default: 
-                throw new NotImplementedException(string.Format("Address mode {0:X1} not implemented.", addressMode));
+                throw new NotImplementedException($"Address mode {addressMode:X1} not implemented.");
             }
         }
 
diff --git a/src/Arch/M68k/Rewriter.Alu.cs b/src/Arch/M68k/Rewriter.Alu.cs
index 1bdb40a2d..0f62ee5bf 100644
--- a/src/Arch/M68k/Rewriter.Alu.cs
+++ b/src/Arch/M68k/Rewriter.Alu.cs
@@ -233,8 +233,8 @@ public void RewriteUnary(Func<Expression, Expression> unaryOpGen, Action<Express
         private void RewriteAddSubq(Func<Expression,Expression,Expression> opGen)
         {
             var opSrc = (Constant) orw.RewriteSrc(instr.Operands[0], instr.Address);
-            var regDst = instr.Operands[1] as RegisterOperand;
-            if (regDst != null && regDst.Register is AddressRegister)
+
+            if (instr.Operands[1] is RegisterOperand regDst && regDst.Register is AddressRegister)
             {
                 opSrc = Constant.Int32(opSrc.ToInt32());
                 var opDst = binder.EnsureRegister(regDst.Register);
@@ -544,14 +544,14 @@ public Expression GetEffectiveAddress(MachineOperand op)
                 ea = orw.Combine(ea, indop.OuterDisplacement);
                 return ea;
             }
-            var indIdx = instr.Operands[0] as IndirectIndexedOperand;
-            if (indIdx != null)
+
+            if (instr.Operands[0] is IndirectIndexedOperand indIdx)
             {
                 var a = binder.EnsureRegister(indIdx.ARegister);
                 var x = binder.EnsureRegister(indIdx.XRegister);
                 return m.IAdd(a, x);        //$REVIEW: woefully incomplete...
             }
-            throw new NotImplementedException(string.Format("{0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"{op} ({op.GetType().Name})");
         }
 
 
diff --git a/src/Arch/MSP430/Msp430InstructionComparer.cs b/src/Arch/MSP430/Msp430InstructionComparer.cs
index 9dfa95f94..59b5a14fc 100644
--- a/src/Arch/MSP430/Msp430InstructionComparer.cs
+++ b/src/Arch/MSP430/Msp430InstructionComparer.cs
@@ -46,8 +46,8 @@ private bool CompareOperands(MachineOperand op1, MachineOperand op2)
                 return false;
             if (op1.GetType() != op2.GetType())
                 return false;
-            var r1 = op1 as RegisterOperand;
-            if (r1 != null)
+
+            if (op1 is RegisterOperand r1)
             {
                 var r2 = (RegisterOperand)op2;
                 return CompareRegisters(r1.Register, r2.Register);
@@ -65,8 +65,8 @@ public override int GetOperandsHash(MachineInstruction instr)
         private int GetOperandHash(MachineOperand op)
         {
             var h = op.GetType().GetHashCode();
-            var r = op as RegisterOperand;
-            if (r != null)
+
+            if (op is RegisterOperand r)
             {
                 return GetRegisterHash(r.Register);
             }
diff --git a/src/Arch/MSP430/Registers.cs b/src/Arch/MSP430/Registers.cs
index 0a768435c..bafe61784 100644
--- a/src/Arch/MSP430/Registers.cs
+++ b/src/Arch/MSP430/Registers.cs
@@ -50,7 +50,7 @@ static Registers()
             }.Concat(
                 Enumerable.Range(4, 12)
                 .Select(i => new RegisterStorage(
-                    string.Format("r{0}", i), i, 0, Msp430Architecture.Word20)))
+                    $"r{i}", i, 0, Msp430Architecture.Word20)))
 
                 .ToArray();
             NZC = new FlagGroupStorage(sr, (uint) (FlagM.NF | FlagM.ZF | FlagM.CF), "NZC", PrimitiveType.Byte);
diff --git a/src/Arch/Microchip/Common/PICRegisters.cs b/src/Arch/Microchip/Common/PICRegisters.cs
index 2cafa1816..2e9b2dce4 100644
--- a/src/Arch/Microchip/Common/PICRegisters.cs
+++ b/src/Arch/Microchip/Common/PICRegisters.cs
@@ -671,7 +671,7 @@ protected static void AddForbiddenDests(bool clean, params PICRegisterStorage[]
             {
                 invalidDestRegisters.Clear();
             }
-            if (regs != null && regs.Count() > 0)
+            if (regs != null && regs.Any())
             {
                 foreach (var r in regs)
                 {
@@ -686,7 +686,7 @@ protected static void AddIndirectParents(bool clean, params (PICRegisterStorage
             {
                 indirectParentRegisters.Clear();
             }
-            if (pairs != null && pairs.Count() > 0)
+            if (pairs != null && pairs.Any())
             {
                 foreach (var (child, parent) in pairs)
                     indirectParentRegisters.Add(child, parent);
@@ -699,7 +699,7 @@ protected static void AddAlwaysAccessibleRegisters(bool clean, params PICRegiste
             {
                 alwayAccessibleRegisters.Clear();
             }
-            if (regs != null && regs.Count() > 0)
+            if (regs != null && regs.Any())
             {
                 foreach (var reg in regs)
                 {
diff --git a/src/Arch/Mips/Mips16eRewriter.cs b/src/Arch/Mips/Mips16eRewriter.cs
index 4a84c35c6..8475cc624 100644
--- a/src/Arch/Mips/Mips16eRewriter.cs
+++ b/src/Arch/Mips/Mips16eRewriter.cs
@@ -75,7 +75,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Warn(
                         instr.Address,
-                        string.Format("MIPS instruction '{0}' is not supported yet.", instr));
+                        $"MIPS instruction '{instr}' is not supported yet.");
                     EmitUnitTest(instr);
                     goto case Mnemonic.illegal;
                 case Mnemonic.illegal:
diff --git a/src/Arch/Mips/MipsInstructionComparer.cs b/src/Arch/Mips/MipsInstructionComparer.cs
index adc5289f9..42d78d3e0 100644
--- a/src/Arch/Mips/MipsInstructionComparer.cs
+++ b/src/Arch/Mips/MipsInstructionComparer.cs
@@ -49,32 +49,32 @@ private bool Compare(MachineOperand a, MachineOperand b)
                 return false;
             if (a.GetType() != b.GetType())
                 return false;
-            var rA = a as RegisterOperand;
-            if (rA != null)
+
+            if (a is RegisterOperand rA)
             {
                 if (NormalizeRegisters)
                     return true;
                 var rB = (RegisterOperand)b;
                 return rA.Register == rB.Register;
             }
-            var iA = a as ImmediateOperand;
-            if (iA != null)
+
+            if (a is ImmediateOperand iA)
             {
                 if (NormalizeConstants)
                     return true;
                 var iB = (ImmediateOperand)b;
                 return CompareValues(iA.Value, iB.Value);
             }
-            var aA = a as AddressOperand;
-            if (aA != null)
+
+            if (a is AddressOperand aA)
             {
                 if (NormalizeConstants)
                     return true;
                 var aB = (AddressOperand)b;
                 return aA.Address.ToLinear() == aB.Address.ToLinear();
             }
-            var mA = a as IndirectOperand;
-            if (mA != null)
+
+            if (a is IndirectOperand mA)
             {
                 var mB = (IndirectOperand)b;
                 if (!NormalizeRegisters && mA.Base != mB.Base)
@@ -101,32 +101,32 @@ private int GetHashCode(MachineOperand op)
         {
             if (op == null)
                 return 0;
-            var r = op as RegisterOperand;
-            if (r != null)
+
+            if (op is RegisterOperand r)
             {
                 if (NormalizeRegisters)
                     return 0;
                 else
                     return GetRegisterHash(r.Register);
             }
-            var i = op as ImmediateOperand;
-            if (i != null)
+
+            if (op is ImmediateOperand i)
             {
                 if (NormalizeConstants)
                     return 0;
                 else
                     return GetConstantHash(i.Value);
             }
-            var a = op as AddressOperand;
-            if (a != null)
+
+            if (op is AddressOperand a)
             {
                 if (NormalizeConstants)
                     return 0;
                 else
                     return a.Address.GetHashCode();
             }
-            var m = op as IndirectOperand;
-            if (m != null)
+
+            if (op is IndirectOperand m)
             {
                 int h = 0;
                 if (!NormalizeRegisters)
diff --git a/src/Arch/Mips/MipsProcessorArchitecture.cs b/src/Arch/Mips/MipsProcessorArchitecture.cs
index 79be3cba0..0e9eb8d4f 100644
--- a/src/Arch/Mips/MipsProcessorArchitecture.cs
+++ b/src/Arch/Mips/MipsProcessorArchitecture.cs
@@ -269,7 +269,7 @@ private IEnumerable<RegisterStorage> CreateGeneralRegisters()
                 select new RegisterStorage(
                     name != null 
                         ? name.n 
-                        : string.Format("r{0}", i),
+                        : $"r{i}",
                     i,
                     0,
                     WordWidth);
@@ -279,7 +279,7 @@ private RegisterStorage[] CreateFpuRegisters()
         {
             return Enumerable.Range(0, 32)
                 .Select(i => new RegisterStorage(
-                    string.Format("f{0}", i),
+                    $"f{i}",
                     i + 64,
                     0,
                     PrimitiveType.Word32))
@@ -290,7 +290,7 @@ private RegisterStorage[] CreateCcRegs()
         {
             return Enumerable.Range(0, 8)
                 .Select(i => new RegisterStorage(
-                    string.Format("cc{0}", i),
+                    $"cc{i}",
                     0x3000,
                     0,
                     PrimitiveType.Bool))
@@ -301,7 +301,7 @@ private RegisterStorage[] CreateFpuCcRegs()
         {
             return Enumerable.Range(0, 8)
                 .Select(i => new RegisterStorage(
-                    string.Format("fcc{0}", i),
+                    $"fcc{i}",
                     0x3000,
                     0,
                     PrimitiveType.Bool))
diff --git a/src/Arch/Mips/MipsRewriter.cs b/src/Arch/Mips/MipsRewriter.cs
index 98fb23ff1..1a2882bc5 100644
--- a/src/Arch/Mips/MipsRewriter.cs
+++ b/src/Arch/Mips/MipsRewriter.cs
@@ -73,7 +73,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Error(
                         instr.Address,
-                        string.Format("MIPS instruction '{0}' is not supported yet.", instr));
+                        $"MIPS instruction '{instr}' is not supported yet.");
                     EmitUnitTest(instr);
                     goto case Mnemonic.illegal;
                 case Mnemonic.illegal:
@@ -381,7 +381,7 @@ private Expression RewriteOperand(MachineOperand op)
             case IndexedOperand idxOp:
                 return RewriteIndexOperand(idxOp, 1);
             }
-            throw new NotImplementedException(string.Format("Rewriting of operand type {0} not implemented yet.", op.GetType().Name));
+            throw new NotImplementedException($"Rewriting of operand type {op.GetType().Name} not implemented yet.");
         }
 
         private Expression RewriteIndexOperand(IndexedOperand idxOp, int scale)
@@ -467,7 +467,7 @@ private Expression RewriteOperand0(MachineOperand op)
                 }
                 return m.Mem(idxOp.Width, ea);
             }
-            throw new NotImplementedException(string.Format("Rewriting of operand type {0} not implemented yet.", op.GetType().Name));
+            throw new NotImplementedException($"Rewriting of operand type {op.GetType().Name} not implemented yet.");
         }
 
     }
diff --git a/src/Arch/Mos6502/Mos65816Rewriter.cs b/src/Arch/Mos6502/Mos65816Rewriter.cs
index 4a78531c5..bf06c0bfc 100644
--- a/src/Arch/Mos6502/Mos65816Rewriter.cs
+++ b/src/Arch/Mos6502/Mos65816Rewriter.cs
@@ -64,7 +64,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Error(
                         instr.Address,
-                        string.Format("Mos65816 instruction '{0}' is not supported yet.", instr));
+                        $"Mos65816 instruction '{instr}' is not supported yet.");
                     EmitUnitTest();
                     goto case Mnemonic.illegal;
                 case Mnemonic.illegal: iclass = InstrClass.Invalid; m.Invalid(); break;
diff --git a/src/Arch/Pdp11/AddressOperand.cs b/src/Arch/Pdp11/AddressOperand.cs
index 6a2ad39da..af205b544 100644
--- a/src/Arch/Pdp11/AddressOperand.cs
+++ b/src/Arch/Pdp11/AddressOperand.cs
@@ -42,7 +42,7 @@ protected override void DoRender(MachineInstructionRenderer renderer, MachineIns
         {
             string s;
             if (base.Width.Size == 2)
-                s = string.Format("{0:X4}", Address.ToLinear());
+                s = $"{Address.ToLinear():X4}";
             else
                 s = Address.ToString();
             renderer.WriteAddress(s, Address);
diff --git a/src/Arch/Pdp11/Assembler/Lexer.cs b/src/Arch/Pdp11/Assembler/Lexer.cs
index 43addaae7..f7683729e 100644
--- a/src/Arch/Pdp11/Assembler/Lexer.cs
+++ b/src/Arch/Pdp11/Assembler/Lexer.cs
@@ -261,14 +261,14 @@ private State Transition(State newState)
 
         public void Unexpected(Token unexpected)
         {
-            throw new FormatException(string.Format("Unpexected token '{0}'.", unexpected));
+            throw new FormatException($"Unpexected token '{unexpected}'.");
         }
 
         public object? Expect(TokenType expected)
         {
             var token = Get();
             if (token.Type != expected)
-                throw new FormatException(string.Format("Unpexected token '{0}', expected '{1}'.", token.Type, expected));
+                throw new FormatException($"Unpexected token '{token.Type}', expected '{expected}'.");
             return token.Value;
         }
     }
diff --git a/src/Arch/Pdp11/Assembler/Pdp11Assembler.cs b/src/Arch/Pdp11/Assembler/Pdp11Assembler.cs
index 85e1c59a1..736778137 100644
--- a/src/Arch/Pdp11/Assembler/Pdp11Assembler.cs
+++ b/src/Arch/Pdp11/Assembler/Pdp11Assembler.cs
@@ -65,8 +65,8 @@ public Program GetImage()
         public void Equate(string id, object id2)
         {
             object value;
-            var sId2 = id2 as string;
-            if (sId2 != null && !Equates.TryGetValue(sId2, out value))
+
+            if (id2 is string sId2 && !Equates.TryGetValue(sId2, out value))
             {
                 value = id2;
             }
diff --git a/src/Arch/Pdp11/MemoryOperand.cs b/src/Arch/Pdp11/MemoryOperand.cs
index ca0d5d86a..fdc830470 100644
--- a/src/Arch/Pdp11/MemoryOperand.cs
+++ b/src/Arch/Pdp11/MemoryOperand.cs
@@ -83,10 +83,10 @@ protected override void DoRender(MachineInstructionRenderer renderer, MachineIns
             //case AddressMode.Immediate : fmt = "#{1:X4}"; break;
             case AddressMode.Absolute:
                 renderer.WriteAddress(
-                    string.Format("@#{0:X4}", EffectiveAddress),
+                    $"@#{EffectiveAddress:X4}",
                     Address.Ptr16(EffectiveAddress));
                 return;
-            default: throw new NotImplementedException(string.Format("Unknown mode {0}.", Mode));
+            default: throw new NotImplementedException($"Unknown mode {Mode}.");
             }
             renderer.WriteString(string.Format(fmt, Register, EffectiveAddress));
         }
diff --git a/src/Arch/Pdp11/Pdp11InstructionComparer.cs b/src/Arch/Pdp11/Pdp11InstructionComparer.cs
index 6a5fb8ba2..443647bac 100644
--- a/src/Arch/Pdp11/Pdp11InstructionComparer.cs
+++ b/src/Arch/Pdp11/Pdp11InstructionComparer.cs
@@ -53,28 +53,27 @@ private bool Compare(MachineOperand? opA, MachineOperand? opB)
                 return false;
             if (opA.GetType() != opB.GetType())
                 return false;
-            var ropA = opA as RegisterOperand;
-            if (ropA != null)
+
+            if (opA is RegisterOperand ropA)
             {
                 var ropB = (RegisterOperand)opB;
                 return ropA.Register == ropB.Register; 
             }
-            var addrA = opA as AddressOperand;
-            if (addrA != null)
+
+            if (opA is AddressOperand addrA)
             {
                 if (NormalizeConstants)
                     return true;
-                var addrB = opB as AddressOperand;
-                return addrB != null && addrA.Address.ToLinear() == addrB.Address.ToLinear();
+                return opB is AddressOperand addrB && addrA.Address.ToLinear() == addrB.Address.ToLinear();
             }
-            var immA = opA as ImmediateOperand;
-            if (immA != null)
+
+            if (opA is ImmediateOperand immA)
             {
                 var immB = (ImmediateOperand)opB;
                 return CompareValues(immA.Value, immB.Value);
             }
-            var memA = opA as MemoryOperand;
-            if (memA != null)
+
+            if (opA is MemoryOperand memA)
             {
                 var memB = (MemoryOperand)opB;
                 if (memA.PreDec != memB.PreDec)
@@ -103,29 +102,29 @@ private int Hash(MachineInstruction instr, int iOp)
                 return 0;
             var op = instr.Operands[iOp];
             int hash = op.GetType().GetHashCode();
-            var rop = op as RegisterOperand;
-            if (rop != null)
+
+            if (op is RegisterOperand rop)
             {
                 if (NormalizeRegisters)
                     return 0;
                 else 
                     return rop.Register.GetHashCode();
             }
-            var immop = op as ImmediateOperand;
-            if (immop != null)
+
+            if (op is ImmediateOperand immop)
             {
                 return base.GetConstantHash(immop.Value);
             }
-            var addrop = op as AddressOperand;
-            if (addrop != null)
+
+            if (op is AddressOperand addrop)
             {
                 if (NormalizeRegisters)
                     return 0;
                 else
                     return addrop.Address.GetHashCode();
             }
-            var mem = op as MemoryOperand;
-            if (mem != null)
+
+            if (op is MemoryOperand mem)
             {
                 var r = NormalizeRegisters || mem.Register == null
                     ? 0
diff --git a/src/Arch/Pdp11/Pdp11Rewriter.Alu.cs b/src/Arch/Pdp11/Pdp11Rewriter.Alu.cs
index c174b2fa9..a9019b67c 100644
--- a/src/Arch/Pdp11/Pdp11Rewriter.Alu.cs
+++ b/src/Arch/Pdp11/Pdp11Rewriter.Alu.cs
@@ -70,8 +70,8 @@ private void RewriteAshc()
                 m.Invalid();
                 return;
             }
-            var csh = sh as Constant;
-            if (csh != null)
+
+            if (sh is Constant csh)
             {
                 var n = csh.ToInt16();
                 if (n >= 0)
@@ -312,9 +312,9 @@ private void RewriteRotate(string op, uint cyMask)
         private void RewriteShift()
         {
             var src = RewriteSrc(instr.Operands[0]);
-            var immSrc = src as Constant;
             Func<Expression, Expression, Expression>? fn = null;
-            if (immSrc != null)
+
+            if (src is Constant immSrc)
             {
                 int sh = immSrc.ToInt32();
                 if (sh < 0)
diff --git a/src/Arch/PowerPC.Design/PowerPCSettingsInteractor.cs b/src/Arch/PowerPC.Design/PowerPCSettingsInteractor.cs
index bb9f62c52..06c0f140e 100644
--- a/src/Arch/PowerPC.Design/PowerPCSettingsInteractor.cs
+++ b/src/Arch/PowerPC.Design/PowerPCSettingsInteractor.cs
@@ -53,10 +53,7 @@ public object CreateControl()
 
         public void Close()
         {
-            if (control != null)
-            {
-                control.Dispose();
-            }
+            control?.Dispose();
             control = null;
         }
 
diff --git a/src/Arch/PowerPC/PowerPcArchitecture.cs b/src/Arch/PowerPC/PowerPcArchitecture.cs
index fc31ad9c9..053462286 100644
--- a/src/Arch/PowerPC/PowerPcArchitecture.cs
+++ b/src/Arch/PowerPC/PowerPcArchitecture.cs
@@ -292,7 +292,7 @@ private Decoder[] EnsureDecoders()
 
         public override RegisterStorage GetRegister(string name)
         {
-            return this.regs.Where(r => r.Name == name).SingleOrDefault();
+            return this.regs.SingleOrDefault(r => r.Name == name);
         }
 
         public override RegisterStorage[] GetRegisters()
diff --git a/src/Arch/PowerPC/PowerPcCallingConvention.cs b/src/Arch/PowerPC/PowerPcCallingConvention.cs
index 69d7a6830..87c201937 100644
--- a/src/Arch/PowerPC/PowerPcCallingConvention.cs
+++ b/src/Arch/PowerPC/PowerPcCallingConvention.cs
@@ -105,8 +105,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
 
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dt)
         {
-            var prim = dt as PrimitiveType;
-            if (prim != null && prim.Domain == Domain.Real)
+            if (dt is PrimitiveType prim && prim.Domain == Domain.Real)
             {
                 ccr.RegReturn(fregs[0]);
             }
diff --git a/src/Arch/PowerPC/PowerPcInstruction.cs b/src/Arch/PowerPC/PowerPcInstruction.cs
index 2df80e759..5ba0c65f6 100644
--- a/src/Arch/PowerPC/PowerPcInstruction.cs
+++ b/src/Arch/PowerPC/PowerPcInstruction.cs
@@ -52,9 +52,7 @@ public PowerPcInstruction(Mnemonic mnemonic, MachineOperand op1, MachineOperand
 
         protected override void DoRender(MachineInstructionRenderer renderer, MachineInstructionRendererOptions options)
         {
-            var op = string.Format("{0}{1}", 
-                Mnemonic,
-                setsCR0 ? "." : "");
+            var op = $"{Mnemonic}{(setsCR0 ? "." : "")}";
             renderer.WriteMnemonic(op);
             RenderOperands(renderer, options);
         }
diff --git a/src/Arch/PowerPC/PowerPcInstructionComparer.cs b/src/Arch/PowerPC/PowerPcInstructionComparer.cs
index 5cc8ee7ef..7642a4282 100644
--- a/src/Arch/PowerPC/PowerPcInstructionComparer.cs
+++ b/src/Arch/PowerPC/PowerPcInstructionComparer.cs
@@ -58,38 +58,38 @@ private bool Compare(MachineOperand opA, MachineOperand opB)
 
             if (opA.GetType() != opB.GetType())
                 return false;
-            var regA = opA as RegisterOperand;
-            if (regA != null)
+
+            if (opA is RegisterOperand regA)
             {
                 var regB = (RegisterOperand) opB;
                 return CompareRegisters(regA.Register, regB.Register);
             }
-            var immA = opA as ImmediateOperand;
-            if (immA != null)
+
+            if (opA is ImmediateOperand immA)
             {
                 var immB = (ImmediateOperand)opB;
                 return CompareValues(immA.Value, immB.Value);
             }
-            var addrA = opA as AddressOperand;
-            if (addrA != null)
+
+            if (opA is AddressOperand addrA)
             {
                 var addrB = (AddressOperand)opB;
                 return NormalizeConstants || addrA.Address == addrB.Address;
             }
-            var memA = opA as MemoryOperand;
-            if (memA != null)
+
+            if (opA is MemoryOperand memA)
             {
                 var memB = (MemoryOperand)opB;
                 return CompareRegisters(memA.BaseRegister, memB.BaseRegister) &&
                     memB.Offset == memB.Offset;
             }
-            var cA = opA as ConditionOperand;
-            if (cA != null)
+
+            if (opA is ConditionOperand cA)
             {
                 var cB = (ConditionOperand)opB;
                 return cA.condition == cB.condition;
             }
-            throw new NotImplementedException(string.Format("PowerPC operand type {0} not implemented.", opA.GetType().Name));
+            throw new NotImplementedException($"PowerPC operand type {opA.GetType().Name} not implemented.");
         }
 
         public override int GetOperandsHash(MachineInstruction instr)
@@ -108,29 +108,29 @@ private int OperandHash(MachineOperand op)
             if (op == null)
                 return 0;
             int h = op.GetType().GetHashCode();
-            var reg = op as RegisterOperand;
-            if (reg != null)
+
+            if (op is RegisterOperand reg)
             {
                 if (!NormalizeRegisters)
                     h ^= GetRegisterHash(reg.Register);
                 return h;
             }
-            var imm = op as ImmediateOperand;
-            if (imm != null)
+
+            if (op is ImmediateOperand imm)
             {
                 if (!NormalizeConstants)
                     h ^= base.GetConstantHash(imm.Value);
                 return h;
             }
-            var addr = op as AddressOperand;
-            if (addr != null)
+
+            if (op is AddressOperand addr)
             {
                 if (!NormalizeConstants)
                     h ^= addr.Address.GetHashCode();
                 return h;
             }
-            var mem = op as MemoryOperand;
-            if (mem != null)
+
+            if (op is MemoryOperand mem)
             {
                 if (!NormalizeRegisters)
                     h ^= GetRegisterHash(mem.BaseRegister);
@@ -138,13 +138,13 @@ private int OperandHash(MachineOperand op)
                     h ^= mem.Offset.GetHashCode();
                 return h;
             }
-            var c = op as ConditionOperand;
-            if (c != null)
+
+            if (op is ConditionOperand c)
             {
                 h ^= c.condition.GetHashCode();
                 return h;
             }
-            throw new NotImplementedException(string.Format("PowerPC operand type {0} not implemented.", op.GetType().Name));
+            throw new NotImplementedException($"PowerPC operand type {op.GetType().Name} not implemented.");
         }
     }
 }
diff --git a/src/Arch/PowerPC/PowerPcRewriter.Alu.cs b/src/Arch/PowerPC/PowerPcRewriter.Alu.cs
index 22c571c8f..6a2054371 100644
--- a/src/Arch/PowerPC/PowerPcRewriter.Alu.cs
+++ b/src/Arch/PowerPC/PowerPcRewriter.Alu.cs
@@ -614,7 +614,7 @@ void RewriteRldicl()
                 {
                     host.Error(
                         instr.Address,
-                        string.Format("PowerPC instruction '{0}' is not supported yet.", instr));
+                        $"PowerPC instruction '{instr}' is not supported yet.");
                     EmitUnitTest();
                     iclass = InstrClass.Invalid;
                     m.Invalid();
@@ -686,7 +686,7 @@ private void RewriteRldicr()
             {
                 host.Error(
                     instr.Address,
-                    string.Format("PowerPC instruction '{0}' is not supported yet.", instr));
+                    $"PowerPC instruction '{instr}' is not supported yet.");
                 EmitUnitTest();
                 iclass = InstrClass.Invalid;
                 m.Invalid();
@@ -712,7 +712,7 @@ private void RewriteRldimi()
             {
                 host.Error(
                     instr.Address,
-                    string.Format("PowerPC instruction '{0}' is not supported yet.", instr));
+                    $"PowerPC instruction '{instr}' is not supported yet.");
                 EmitUnitTest();
                 iclass = InstrClass.Invalid;
                 m.Invalid();
diff --git a/src/Arch/PowerPC/PowerPcRewriter.Mem.cs b/src/Arch/PowerPC/PowerPcRewriter.Mem.cs
index dd9664566..2f1ccb2e0 100644
--- a/src/Arch/PowerPC/PowerPcRewriter.Mem.cs
+++ b/src/Arch/PowerPC/PowerPcRewriter.Mem.cs
@@ -450,7 +450,7 @@ private void RewriteTrap(PrimitiveType size)
             default:
                 host.Warn(
                     instr.Address,
-                    string.Format("Unsupported trap operand {0:X2}.", c.ToInt32()));
+                    $"Unsupported trap operand {c.ToInt32():X2}.");
                 iclass = InstrClass.Invalid;
                 m.Invalid();
                 return;
diff --git a/src/Arch/PowerPC/PowerPcRewriter.cs b/src/Arch/PowerPC/PowerPcRewriter.cs
index 98704492c..5e69643db 100644
--- a/src/Arch/PowerPC/PowerPcRewriter.cs
+++ b/src/Arch/PowerPC/PowerPcRewriter.cs
@@ -85,7 +85,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Error(
                         instr.Address, 
-                        string.Format("PowerPC instruction '{0}' is not supported yet.", instr));
+                        $"PowerPC instruction '{instr}' is not supported yet.");
                     EmitUnitTest();
                     goto case Mnemonic.illegal;
                 case Mnemonic.illegal: iclass = InstrClass.Invalid; m.Invalid(); break;
diff --git a/src/Arch/Qualcomm/HexagonRewriter.cs b/src/Arch/Qualcomm/HexagonRewriter.cs
index 270a36eb1..49125a005 100644
--- a/src/Arch/Qualcomm/HexagonRewriter.cs
+++ b/src/Arch/Qualcomm/HexagonRewriter.cs
@@ -109,7 +109,7 @@ private void ProcessPacket(HexagonPacket packet)
                 default:
                     host.Error(
                         instr.Address,
-                        string.Format("Hexagon instruction '{0}' is not supported yet.", instr));
+                        $"Hexagon instruction '{instr}' is not supported yet.");
                     EmitUnitTest(packet, instr.Mnemonic.ToString());
                     break;
                 case Mnemonic.ASSIGN: RewriteAssign(instr.Operands[0], instr.Operands[1]); break;
diff --git a/src/Arch/RiscV/RiscVCallingConvention.cs b/src/Arch/RiscV/RiscVCallingConvention.cs
index 23659609a..143168f2b 100644
--- a/src/Arch/RiscV/RiscVCallingConvention.cs
+++ b/src/Arch/RiscV/RiscVCallingConvention.cs
@@ -121,8 +121,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             for (int i = 0; i < dtParams.Count; ++i)
             {
                 var dtParam = dtParams[i];
-                var pt = dtParam as PrimitiveType;
-                if (pt != null && pt.Domain == Domain.Real)
+
+                if (dtParam is PrimitiveType pt && pt.Domain == Domain.Real)
                 {
                     if (ir >= fregs.Length)
                     {
diff --git a/src/Arch/RiscV/RiscVInstruction.cs b/src/Arch/RiscV/RiscVInstruction.cs
index af8352763..cd87683b1 100644
--- a/src/Arch/RiscV/RiscVInstruction.cs
+++ b/src/Arch/RiscV/RiscVInstruction.cs
@@ -120,9 +120,9 @@ protected override void RenderOperand(MachineOperand op, MachineInstructionRende
                 //$TODO: 32-bit?
                 if (addrop.Width.BitSize == 32)
                 {
-                    renderer.WriteAddress(string.Format("{0:X8}", addrop.Address.ToLinear()), addrop.Address);
+                    renderer.WriteAddress($"{addrop.Address.ToLinear():X8}", addrop.Address);
                 } else {
-                    renderer.WriteAddress(string.Format("{0:X16}", addrop.Address.ToLinear()), addrop.Address);
+                    renderer.WriteAddress($"{addrop.Address.ToLinear():X16}", addrop.Address);
                 }
                     return;
             case MemoryOperand memop:
diff --git a/src/Arch/RiscV/RiscVInstructionComparer.cs b/src/Arch/RiscV/RiscVInstructionComparer.cs
index 764827204..9561617e4 100644
--- a/src/Arch/RiscV/RiscVInstructionComparer.cs
+++ b/src/Arch/RiscV/RiscVInstructionComparer.cs
@@ -50,20 +50,19 @@ private bool CompareOperands(MachineOperand opA, MachineOperand opB)
             if (opA.GetType() != opB.GetType())
                 return false;
 
-            var ropA = opA as RegisterOperand;
-            if (ropA != null)
+            if (opA is RegisterOperand ropA)
             {
                 var ropB = (RegisterOperand)opB;
                 return NormalizeRegisters || ropA.Register == ropB.Register;
             }
-            var immA = opA as ImmediateOperand;
-            if (immA != null)
+
+            if (opA is ImmediateOperand immA)
             {
                 var immB = (ImmediateOperand)opB;
                 return NormalizeConstants || base.CompareValues(immA.Value, immB.Value);
             }
-            var addrA = opA as AddressOperand;
-            if (addrA != null)
+
+            if (opA is AddressOperand addrA)
             {
                 var addrB = (AddressOperand)opB;
                 return NormalizeConstants || addrA.Address == addrB.Address;
@@ -85,24 +84,24 @@ private int GetOperandHash(MachineOperand op)
         {
             if (op == null)
                 return 0;
-            var rop = op as RegisterOperand;
-            if (rop != null)
+
+            if (op is RegisterOperand rop)
             {
                 if (NormalizeRegisters)
                     return 0;
                 else
                     return rop.Register.Number.GetHashCode();
             }
-            var immop = op as ImmediateOperand;
-            if (immop != null)
+
+            if (op is ImmediateOperand immop)
             {
                 if (NormalizeConstants)
                     return 0;
                 else
                     return base.GetConstantHash(immop.Value);
             }
-            var aop = op as AddressOperand;
-            if (aop != null)
+
+            if (op is AddressOperand aop)
             {
                 if (NormalizeConstants)
                     return 0;
@@ -110,7 +109,7 @@ private int GetOperandHash(MachineOperand op)
                     return aop.Address.GetHashCode();
             }
             throw new NotImplementedException(
-                string.Format("RiscV operand {0} ({1}) not implemented.", op, op.GetType().Name));
+                $"RiscV operand {op} ({op.GetType().Name}) not implemented.");
         }
     }
 }
\ No newline at end of file
diff --git a/src/Arch/Sparc/SparcInstructionComparer.cs b/src/Arch/Sparc/SparcInstructionComparer.cs
index cbd332362..7515d590c 100644
--- a/src/Arch/Sparc/SparcInstructionComparer.cs
+++ b/src/Arch/Sparc/SparcInstructionComparer.cs
@@ -48,33 +48,32 @@ private bool CompareOperands(MachineOperand a, MachineOperand b)
                 return false;
             if (a.GetType() != b.GetType())
                 return false;
-            var rA = a as RegisterOperand;
-            if (rA != null)
+
+            if (a is RegisterOperand rA)
             {
                 return CompareRegisters(rA.Register, ((RegisterOperand)b).Register);
             }
 
-            var immA = a as ImmediateOperand;
-            if (immA != null)
+            if (a is ImmediateOperand immA)
             {
                 return CompareValues(immA.Value, ((ImmediateOperand)b).Value);
             }
-            var addrA = a as AddressOperand;
-            if (addrA != null)
+
+            if (a is AddressOperand addrA)
             {
                 return NormalizeConstants ||
                     addrA.Address.ToLinear() == ((AddressOperand)b).Address.ToLinear();
             }
-            var mA = a as MemoryOperand;
-            if (mA != null)
+
+            if (a is MemoryOperand mA)
             {
                 var mB = (MemoryOperand)b;
                 if (!CompareRegisters(mA.Base, mB.Base))
                     return false;
                 return CompareValues(mA.Offset, mB.Offset);
             }
-            var xA = a as IndexedMemoryOperand;
-            if (xA != null)
+
+            if (a is IndexedMemoryOperand xA)
             {
                 var xB = (IndexedMemoryOperand)b;
                 if (!CompareRegisters(xA.Base, xB.Base))
@@ -98,30 +97,30 @@ private int GetOperandHash(MachineOperand op)
         {
             if (op == null)
                 return 0;
-            var r = op as RegisterOperand;
-            if (r != null)
+
+            if (op is RegisterOperand r)
             {
                 return GetRegisterHash(r.Register);
             }
-            var i = op as ImmediateOperand;
-            if (i != null)
+
+            if (op is ImmediateOperand i)
             {
                 return GetConstantHash(i.Value);
             }
-            var a = op as AddressOperand;
-            if (a != null)
+
+            if (op is AddressOperand a)
             {
                 return a.Address.GetHashCode();
             }
-            var m = op as MemoryOperand;
-            if (m != null)
+
+            if (op is MemoryOperand m)
             {
                 var h = GetRegisterHash(m.Base);
                 h = h ^ 29 * GetConstantHash(m.Offset);
                 return h;
             }
-            var x = op as IndexedMemoryOperand;
-            if (x != null)
+
+            if (op is IndexedMemoryOperand x)
             {
                 var h = GetRegisterHash(x.Base);
                 h = h ^ 59 * GetRegisterHash(x.Index);
diff --git a/src/Arch/Sparc/SparcRewriter.cs b/src/Arch/Sparc/SparcRewriter.cs
index d2fabcaa3..af693ac14 100644
--- a/src/Arch/Sparc/SparcRewriter.cs
+++ b/src/Arch/Sparc/SparcRewriter.cs
@@ -295,7 +295,7 @@ private Expression RewriteOp(MachineOperand op, bool g0_becomes_null)
             }
             if (op is ImmediateOperand imm)
                 return imm.Value;
-            throw new NotImplementedException(string.Format("Unsupported operand {0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"Unsupported operand {op} ({op.GetType().Name})");
         }
 
         private Expression RewriteRegister(int iop)
@@ -321,7 +321,7 @@ private Expression RewriteMemOp(MachineOperand op, PrimitiveType size)
                     offset = i.Index == arch.Registers.g0 ? null : binder.EnsureRegister(i.Index);
                 }
                 else
-                    throw new NotImplementedException(string.Format("Unknown memory operand {0} ({1})", op, op.GetType().Name));
+                    throw new NotImplementedException($"Unknown memory operand {op} ({op.GetType().Name})");
             }
             return m.Mem(size, SimplifySum(baseReg, offset));
         }
diff --git a/src/Arch/SuperH/MemoryOperand.cs b/src/Arch/SuperH/MemoryOperand.cs
index a0f2c63a9..23cb27d83 100644
--- a/src/Arch/SuperH/MemoryOperand.cs
+++ b/src/Arch/SuperH/MemoryOperand.cs
@@ -56,14 +56,14 @@ protected override void DoRender(MachineInstructionRenderer renderer, MachineIns
         {
             switch(mode)
             {
-            case AddressingMode.Indirect: renderer.WriteString(string.Format("@{0}", this.reg.Name)); break;
-            case AddressingMode.IndirectDisplacement: renderer.WriteString(string.Format("@({0},{1})", disp, this.reg.Name)); break;
-            case AddressingMode.IndirectPreDecr: renderer.WriteString(string.Format("@-{0}", reg.Name)); break;
-            case AddressingMode.IndirectPostIncr: renderer.WriteString(string.Format("@{0}+", reg.Name)); break;
-            case AddressingMode.IndexedIndirect: renderer.WriteString(string.Format("@(r0,{0})", reg.Name)); break;
+            case AddressingMode.Indirect: renderer.WriteString($"@{this.reg.Name}"); break;
+            case AddressingMode.IndirectDisplacement: renderer.WriteString($"@({disp},{this.reg.Name})"); break;
+            case AddressingMode.IndirectPreDecr: renderer.WriteString($"@-{reg.Name}"); break;
+            case AddressingMode.IndirectPostIncr: renderer.WriteString($"@{reg.Name}+"); break;
+            case AddressingMode.IndexedIndirect: renderer.WriteString($"@(r0,{reg.Name})"); break;
             case AddressingMode.GbrIndexedIndirect: renderer.WriteString("@(r0,gbr)"); break;
-            case AddressingMode.PcRelativeDisplacement: renderer.WriteString(string.Format("@({0:X2},pc)", disp)); break;
-            default: throw new NotImplementedException(string.Format("AddressingMode.{0}", mode));
+            case AddressingMode.PcRelativeDisplacement: renderer.WriteString($"@({disp:X2},pc)"); break;
+            default: throw new NotImplementedException($"AddressingMode.{mode}");
             }
         }
     }
diff --git a/src/Arch/SuperH/SuperHRewriter.cs b/src/Arch/SuperH/SuperHRewriter.cs
index 6b5e353f4..b2297950d 100644
--- a/src/Arch/SuperH/SuperHRewriter.cs
+++ b/src/Arch/SuperH/SuperHRewriter.cs
@@ -72,9 +72,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Error(
                         dasm.Current.Address,
-                        string.Format(
-                            "SuperH instruction {0} not supported yet.",
-                        dasm.Current.Mnemonic));
+                        $"SuperH instruction {dasm.Current.Mnemonic} not supported yet.");
                     EmitUnitTest();
                     goto case Mnemonic.invalid;
                 case Mnemonic.invalid:
diff --git a/src/Arch/Tlcs/Tlcs90/Tlcs90Disassembler.cs b/src/Arch/Tlcs/Tlcs90/Tlcs90Disassembler.cs
index d366e0243..63483b680 100644
--- a/src/Arch/Tlcs/Tlcs90/Tlcs90Disassembler.cs
+++ b/src/Arch/Tlcs/Tlcs90/Tlcs90Disassembler.cs
@@ -414,7 +414,7 @@ public override Tlcs90Instruction Decode(uint bPrev, Tlcs90Disassembler dasm)
                     case 'X': baseReg = Registers.ix;  break;
                     case 'Y': baseReg = Registers.ix;  break;
                     case 'H': baseReg = Registers.hl; idxReg = Registers.a;  break;
-                    default: throw new NotImplementedException(string.Format("Tlcs-90: dst {0}", format));
+                    default: throw new NotImplementedException($"Tlcs-90: dst {format}");
                     }
                     if (idxReg == null)
                     {
@@ -423,7 +423,7 @@ public override Tlcs90Instruction Decode(uint bPrev, Tlcs90Disassembler dasm)
                         offset = Constant.SByte((sbyte)bOff);
                     }
                     break;
-                default: throw new NotImplementedException(string.Format("Tlcs-90: dst {0}", format));
+                default: throw new NotImplementedException($"Tlcs-90: dst {format}");
                 }
                 if (!dasm.rdr.TryReadByte(out byte b))
                     return dasm.CreateInvalidInstruction();
@@ -506,7 +506,7 @@ public override Tlcs90Instruction Decode(uint bPrev, Tlcs90Disassembler dasm)
                     case 'X': baseReg = Registers.ix; break;
                     case 'Y': baseReg = Registers.iy; break;
                     case 'H': baseReg = Registers.hl; idxReg = Registers.a;  break;
-                    default: throw new NotImplementedException(string.Format("Tlcs-90: src {0}", format));
+                    default: throw new NotImplementedException($"Tlcs-90: src {format}");
                     };
                     if (idxReg == null)
                     {
@@ -533,7 +533,7 @@ public override Tlcs90Instruction Decode(uint bPrev, Tlcs90Disassembler dasm)
                         return dasm.CreateInvalidInstruction();
                     offset = Constant.UInt16((ushort)(0xFF00 | pageAddr));
                     break;
-                default: throw new NotImplementedException(string.Format("Tlcs-90: src {0}", format));
+                default: throw new NotImplementedException($"Tlcs-90: src {format}");
                 }
 
                 if (!dasm.rdr.TryReadByte(out byte b))
diff --git a/src/Arch/Tlcs/Tlcs90/Tlcs90InstructionComparer.cs b/src/Arch/Tlcs/Tlcs90/Tlcs90InstructionComparer.cs
index 95af92848..f0568ec8f 100644
--- a/src/Arch/Tlcs/Tlcs90/Tlcs90InstructionComparer.cs
+++ b/src/Arch/Tlcs/Tlcs90/Tlcs90InstructionComparer.cs
@@ -93,37 +93,37 @@ private int HashOp(MachineOperand op)
             if (op == null)
                 return 0;
             int h = op.GetType().GetHashCode();
-            var regOp = op as RegisterOperand;
-            if (regOp != null)
+
+            if (op is RegisterOperand regOp)
             {
                 if (NormalizeRegisters)
                     return h;
                 else
                     return h * 29 ^ regOp.Register.GetHashCode();
             }
-            var immOp = op as ImmediateOperand;
-            if (immOp != null)
+
+            if (op is ImmediateOperand immOp)
             {
                 if (NormalizeConstants)
                     return h;
                 else
                     return h * 13 ^ GetConstantHash(immOp.Value);
             }
-            var addrOp = op as AddressOperand;
-            if (addrOp != null)
+
+            if (op is AddressOperand addrOp)
             {
                 if (NormalizeConstants)
                     return h;
                 else
                     return h * 29 ^ addrOp.Address.GetHashCode();
             }
-            var condOp = op as ConditionOperand;
-            if (condOp != null)
+
+            if (op is ConditionOperand condOp)
             {
                 return h * 19 ^ condOp.Code.GetHashCode();
             }
-            var memOp = op as MemoryOperand;
-            if (memOp != null)
+
+            if (op is MemoryOperand memOp)
             {
                 if (!NormalizeRegisters && memOp.Base != null)
                     h = h * 23 ^ memOp.Base.GetHashCode();
@@ -131,7 +131,7 @@ private int HashOp(MachineOperand op)
                     h = h * 17 ^ GetConstantHash(memOp.Offset);
                 return h;
             }
-            throw new NotImplementedException(string.Format("{0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"{op} ({op.GetType().Name})");
         }
     }
 }
\ No newline at end of file
diff --git a/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.Control.cs b/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.Control.cs
index 75500d98f..2c791fd2a 100644
--- a/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.Control.cs
+++ b/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.Control.cs
@@ -92,8 +92,8 @@ private void RewriteJp()
             if (instr.Operands.Length >= 2)
             {
                 var cc = RewriteCondition((ConditionOperand)instr.Operands[0]);
-                var addrOp = instr.Operands[1] as AddressOperand;
-                if (addrOp != null)
+
+                if (instr.Operands[1] is AddressOperand addrOp)
                 {
                     m.Branch(cc, addrOp.Address, InstrClass.ConditionalTransfer);
                     return;
diff --git a/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.cs b/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.cs
index 144b2fc9b..acf3b9d37 100644
--- a/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.cs
+++ b/src/Arch/Tlcs/Tlcs90/Tlcs90Rewriter.cs
@@ -74,9 +74,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                     Invalid();
                     host.Warn(
                        instr.Address,
-                       string.Format(
-                           "TLCS-90 instruction '{0}' not supported yet.",
-                           instr.Mnemonic));
+                       $"TLCS-90 instruction '{instr.Mnemonic}' not supported yet.");
 
                     break;
                 case Mnemonic.invalid: m.Invalid(); break;
@@ -147,9 +145,7 @@ private void Invalid()
         {
             host.Error(
                instr.Address,
-               string.Format(
-                   "Rewriting of TLCS-90 instruction '{0}' not implemented yet.",
-                   instr.Mnemonic));
+               $"Rewriting of TLCS-90 instruction '{instr.Mnemonic}' not implemented yet.");
             iclass = InstrClass.Invalid;
             m.Invalid();
         }
diff --git a/src/Arch/Tlcs/Tlcs900/Tlcs900InstructionComparer.cs b/src/Arch/Tlcs/Tlcs900/Tlcs900InstructionComparer.cs
index 5a9bf7227..346ce87c9 100644
--- a/src/Arch/Tlcs/Tlcs900/Tlcs900InstructionComparer.cs
+++ b/src/Arch/Tlcs/Tlcs900/Tlcs900InstructionComparer.cs
@@ -50,37 +50,37 @@ private bool CompareOp(MachineOperand opA, MachineOperand opB)
                 return false;
             if (opA.GetType() != opB.GetType())
                 return false;
-            var regOpA = opA as RegisterOperand;
-            if (regOpA != null)
+
+            if (opA is RegisterOperand regOpA)
             {
                 if (NormalizeRegisters)
                     return true;
                 var regOpB = (RegisterOperand)opB;
                 return regOpA.Register == regOpB.Register;
             }
-            var immOpA = opA as ImmediateOperand;
-            if (immOpA != null)
+
+            if (opA is ImmediateOperand immOpA)
             {
                 if (NormalizeConstants)
                     return true;
                 var immOpB = (ImmediateOperand)opB;
                 return CompareValues(immOpA.Value, immOpB.Value);
             }
-            var addrOpA = opA as AddressOperand;
-            if (addrOpA != null)
+
+            if (opA is AddressOperand addrOpA)
             {
                 if (NormalizeConstants)
                     return true;
                 var addrOpB = (AddressOperand)opB;
                 return addrOpA.Address.ToLinear() == addrOpB.Address.ToLinear();
             }
-            var condOpA = opA as ConditionOperand;
-            if (condOpA != null)
+
+            if (opA is ConditionOperand condOpA)
             {
                 return condOpA.Code == ((ConditionOperand)opB).Code;
             }
-            var memOpA = opA as MemoryOperand;
-            if (memOpA != null)
+
+            if (opA is MemoryOperand memOpA)
             {
                 var memOpB = (MemoryOperand) opB;
                 if (NormalizeRegisters && !CompareRegisters(memOpA.Base, memOpB.Base))
@@ -105,37 +105,37 @@ private int HashOp(MachineOperand op)
             if (op == null)
                 return 0;
             int h = op.GetType().GetHashCode();
-            var regOp = op as RegisterOperand;
-            if (regOp != null)
+
+            if (op is RegisterOperand regOp)
             {
                 if (NormalizeRegisters)
                     return h;
                 else
                     return h * 29 ^ regOp.Register.GetHashCode();
             }
-            var immOp = op as ImmediateOperand;
-            if (immOp != null)
+
+            if (op is ImmediateOperand immOp)
             {
                 if (NormalizeConstants)
                     return h;
                 else
                     return h * 13 ^ GetConstantHash(immOp.Value);
             }
-            var addrOp = op as AddressOperand;
-            if (addrOp != null)
+
+            if (op is AddressOperand addrOp)
             {
                 if (NormalizeConstants)
                     return h;
                 else
                     return h * 29 ^ addrOp.Address.GetHashCode();
             }
-            var condOp = op as ConditionOperand;
-            if (condOp != null)
+
+            if (op is ConditionOperand condOp)
             {
                 return h * 19 ^ condOp.Code.GetHashCode();
             }
-            var memOp = op as MemoryOperand;
-            if (memOp != null)
+
+            if (op is MemoryOperand memOp)
             {
                 if (!NormalizeRegisters && memOp.Base != null)
                     h = h * 23 ^ memOp.Base.GetHashCode();
@@ -143,7 +143,7 @@ private int HashOp(MachineOperand op)
                     h = h * 17 ^ GetConstantHash(memOp.Offset);
                 return h;
             }
-            throw new NotImplementedException(string.Format("{0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"{op} ({op.GetType().Name})");
         }
     }
 }
\ No newline at end of file
diff --git a/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.Control.cs b/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.Control.cs
index abfa78ab7..a49992203 100644
--- a/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.Control.cs
+++ b/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.Control.cs
@@ -66,8 +66,8 @@ private void RewriteJp()
                 iclass = InstrClass.ConditionalTransfer;
                 var test = GenerateTestExpression(co, false);
                 var dst = RewriteSrc(instr.Operands[1]);
-                var addr = dst as Address;
-                if (addr != null)
+
+                if (dst is Address addr)
                 {
                     m.Branch(test, addr, InstrClass.ConditionalTransfer);
                 }
diff --git a/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.cs b/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.cs
index 008937297..b4db09f87 100644
--- a/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.cs
+++ b/src/Arch/Tlcs/Tlcs900/Tlcs900Rewriter.cs
@@ -72,9 +72,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Warn(
                        instr.Address,
-                       string.Format(
-                           "TLCS-900 instruction '{0}' not supported yet.",
-                           instr.Mnemonic));
+                       $"TLCS-900 instruction '{instr.Mnemonic}' not supported yet.");
                     EmitUnitTest();
                     Invalid();
                     break;
diff --git a/src/Arch/Vax/VaxInstructionComparer.cs b/src/Arch/Vax/VaxInstructionComparer.cs
index a95e1baef..075111071 100644
--- a/src/Arch/Vax/VaxInstructionComparer.cs
+++ b/src/Arch/Vax/VaxInstructionComparer.cs
@@ -50,13 +50,12 @@ private bool Compare(MachineOperand a, MachineOperand b)
         {
             if (a.GetType() != b.GetType())
                 return false;
-            var rA = a as RegisterOperand;
-            if (rA != null)
+
+            if (a is RegisterOperand rA)
             {
                 if (NormalizeRegisters)
                     return true;
-                var rB = b as RegisterOperand;
-                return rB != null && rA.Register == rB.Register;
+                return b is RegisterOperand rB && rA.Register == rB.Register;
             }
             throw new NotImplementedException();
         }
diff --git a/src/Arch/X86/Assembler/ModRmBuilder.cs b/src/Arch/X86/Assembler/ModRmBuilder.cs
index ce3dedbe4..2872094f7 100644
--- a/src/Arch/X86/Assembler/ModRmBuilder.cs
+++ b/src/Arch/X86/Assembler/ModRmBuilder.cs
@@ -225,7 +225,7 @@ public int Get16AddressingModeMask(MemoryOperand memOp)
 			}
 			if (mask == 1<<(int) Registers.bx.Number)
 				return 7;
-			OnError(string.Format("Illegal 16-bit addressing mode: {0} ", memOp.ToString()));
+			OnError($"Illegal 16-bit addressing mode: {memOp.ToString()} ");
 			return 0;
 		}
 
diff --git a/src/Arch/X86/Assembler/OperandParser.cs b/src/Arch/X86/Assembler/OperandParser.cs
index ec244a743..f37784de9 100644
--- a/src/Arch/X86/Assembler/OperandParser.cs
+++ b/src/Arch/X86/Assembler/OperandParser.cs
@@ -71,7 +71,7 @@ private void Expect(Token tok)
 		{
 			if (lexer.GetToken() != tok)
 			{
-				OnError(string.Format("Expected token: '{0}'", tok));
+				OnError($"Expected token: '{tok}'");
 			}
 		}
 
@@ -79,7 +79,7 @@ private void Expect(Token tok, string name)
 		{
 			if (lexer.GetToken() != tok)
 			{
-				OnError(string.Format("Expected token: '{0}'", name));
+				OnError($"Expected token: '{name}'");
 			}
 		}
 
@@ -223,7 +223,7 @@ private void ParseMemoryFactor(MemoryOperand memOp)
 			switch (token)
 			{
 			default:
-				OnError(string.Format("Unexpected token '{0}'", token));
+				OnError($"Unexpected token '{token}'");
 				return null;
 			case Token.BRA:
 				return ParseMemoryOperand(RegisterStorage.None);
diff --git a/src/Arch/X86/Assembler/X86Assembler.cs b/src/Arch/X86/Assembler/X86Assembler.cs
index 7e4729bf3..041ecd97d 100644
--- a/src/Arch/X86/Assembler/X86Assembler.cs
+++ b/src/Arch/X86/Assembler/X86Assembler.cs
@@ -580,7 +580,7 @@ internal void ProcessMov(params ParsedOperand[] ops)
                 if (regOpSrc != null)
                 {
                     if (regOpSrc.Width != regOpDst.Width)
-                        this.Error(string.Format("size mismatch between {0} and {1}", regOpSrc.Register, regOpDst.Register));
+                        this.Error($"size mismatch between {regOpSrc.Register} and {regOpDst.Register}");
                     EmitOpcode(0x8A | (isWord & 1), dataWidth);
                     modRm.EmitModRM(reg, regOpSrc);
                     return;
@@ -954,7 +954,7 @@ public void EmitOpcode(int b, PrimitiveType? dataWidth)
 				if (SegmentOverride == Registers.ds) bOv = 0x3E; else
 				if (SegmentOverride == Registers.fs) bOv = 0x64; else
 				if (SegmentOverride == Registers.gs) bOv = 0x65; else
-				throw new ArgumentOutOfRangeException(string.Format("Invalid segment register {0}." , SegmentOverride));
+				throw new ArgumentOutOfRangeException($"Invalid segment register {SegmentOverride}.");
 				emitter.EmitByte(bOv);
 				SegmentOverride = RegisterStorage.None;
 			}
@@ -1231,7 +1231,7 @@ public void Fiadd(ParsedOperand operand)
             {
             case 2: opcode = 0xDE; break;
             case 4: opcode = 0xDA; break;
-            default: Error(string.Format("Instruction doesn't support {0}-byte operands.", dataWidth.Size)); return;
+            default: Error($"Instruction doesn't support {dataWidth.Size}-byte operands."); return;
             }
             EmitOpcode(opcode, dataWidth);
             EmitModRM(0, operand);
@@ -1249,7 +1249,7 @@ public void Fild(ParsedOperand op)
             case 2: opCode = 0xDF; reg = 0x00; break;
             case 4: opCode = 0xDB; reg = 0x00; break;
             case 8: opCode = 0xDF; reg = 0x05; break;
-            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
+            default: Error($"Instruction doesn't support {dataWidth.Size}-byte operands"); return;
             }
             EmitOpcode(opCode, dataWidth);
             EmitModRM(reg, op);
@@ -1267,7 +1267,7 @@ public void Fistp(ParsedOperand src)
             case 2: opCode = 0xDF; reg = 0x03; break;
             case 4: opCode = 0xDB; reg = 0x03; break;
             case 8: opCode = 0xDF; reg = 0x07; break;
-            default: Error(string.Format("Instruction doesn't support {0}-byte operands", dataWidth.Size)); return;
+            default: Error($"Instruction doesn't support {dataWidth.Size}-byte operands"); return;
             }
             EmitOpcode(opCode, null);
             EmitModRM(reg, src);
diff --git a/src/Arch/X86/Assembler/X86TextAssembler.cs b/src/Arch/X86/Assembler/X86TextAssembler.cs
index 183648310..99cdd7ad9 100644
--- a/src/Arch/X86/Assembler/X86TextAssembler.cs
+++ b/src/Arch/X86/Assembler/X86TextAssembler.cs
@@ -137,7 +137,7 @@ public Address StartAddress
 
 		private bool Error(string pstr)
 		{
-			throw new ApplicationException(string.Format("line {0}: error: {1}", lexer.LineNumber, pstr));
+			throw new ApplicationException($"line {lexer.LineNumber}: error: {pstr}");
 		}
 
 		private void Expect(Token tok)
@@ -200,9 +200,9 @@ private void Expect(Token tok, string msg)
 			else
 			{
 				if (min == max)
-					Error(string.Format("Instruction expects {0} operand(s).", min));
+					Error($"Instruction expects {min} operand(s).");
 				else
-					Error(string.Format("Instruction expects between {0} and {1} operand(s).", min, max));
+					Error($"Instruction expects between {min} and {max} operand(s).");
 				return null;
 			}
 		}
diff --git a/src/Arch/X86/OperandRewriter.cs b/src/Arch/X86/OperandRewriter.cs
index 9e89f58de..b598321f4 100644
--- a/src/Arch/X86/OperandRewriter.cs
+++ b/src/Arch/X86/OperandRewriter.cs
@@ -56,7 +56,7 @@ public Expression Transform(X86Instruction instr, MachineOperand op, DataType op
             case ImmediateOperand imm: return CreateConstant(imm, (PrimitiveType) opWidth);
             case FpuOperand fpu: return FpuRegister(fpu.StNumber);
             case AddressOperand addr: return addr.Address;
-            default: throw new NotImplementedException(string.Format("Operand {0}", op));
+            default: throw new NotImplementedException($"Operand {op}");
             }
         }
 
diff --git a/src/Arch/X86/X86Disassembler.cs b/src/Arch/X86/X86Disassembler.cs
index cf5f872c6..a260432a8 100644
--- a/src/Arch/X86/X86Disassembler.cs
+++ b/src/Arch/X86/X86Disassembler.cs
@@ -381,9 +381,7 @@ private RegisterStorage MmxRegFromBits(int bits, PrimitiveType dataWidth)
             case 6: return Registers.mm6;
             case 7: return Registers.mm7;
             }
-            throw new ArgumentOutOfRangeException(string.Format(
-                "Unsupported register {0} or data width {1}.",
-                bits, dataWidth));
+            throw new ArgumentOutOfRangeException($"Unsupported register {bits} or data width {dataWidth}.");
         }
 
         private RegisterStorage RegFromBitsRexX(int bits, PrimitiveType dataWidth, Func<int, PrimitiveType, RegisterStorage> fnReg)
@@ -552,7 +550,7 @@ public static RegisterStorage SegFromBits(int bits)
 			case 6: return Registers.ss;
 			case 7: return Registers.ds;
 			}
-			throw new ArgumentOutOfRangeException("bits", string.Format("{0} doesn't correspond to a segment register.", bits));
+			throw new ArgumentOutOfRangeException("bits", $"{bits} doesn't correspond to a segment register.");
 		}
 
         // Operand decoders //////
diff --git a/src/Arch/X86/X86Emulator.cs b/src/Arch/X86/X86Emulator.cs
index 8923c826f..f9bb8dbb8 100644
--- a/src/Arch/X86/X86Emulator.cs
+++ b/src/Arch/X86/X86Emulator.cs
@@ -210,7 +210,7 @@ public void Execute(X86Instruction instr)
             switch (instr.Mnemonic)
             {
             default:
-                throw new NotImplementedException(string.Format("Instruction emulation for {0} not implemented yet.", instr));
+                throw new NotImplementedException($"Instruction emulation for {instr} not implemented yet.");
             case Mnemonic.adc: Adc(instr.Operands[0], instr.Operands[1]); return;
             case Mnemonic.add: Add(instr.Operands[0], instr.Operands[1]); return;
             case Mnemonic.and: And(instr.Operands[0], instr.Operands[1]); return;
diff --git a/src/Arch/X86/X86InstructionComparer.cs b/src/Arch/X86/X86InstructionComparer.cs
index 9bd17084d..4871e47e9 100644
--- a/src/Arch/X86/X86InstructionComparer.cs
+++ b/src/Arch/X86/X86InstructionComparer.cs
@@ -75,7 +75,7 @@ public bool CompareOperands(MachineOperand opA, MachineOperand opB)
                 var fpuB = (FpuOperand) opB;
                 return NormalizeRegisters || fpuA.StNumber == fpuB.StNumber;
             }
-            throw new NotImplementedException(string.Format("NYI: {0}", opA.GetType()));
+            throw new NotImplementedException($"NYI: {opA.GetType()}");
 		}
 
 
diff --git a/src/Arch/X86/X86ProcessorArchitecture.cs b/src/Arch/X86/X86ProcessorArchitecture.cs
index ec264e14c..6fb124ea7 100644
--- a/src/Arch/X86/X86ProcessorArchitecture.cs
+++ b/src/Arch/X86/X86ProcessorArchitecture.cs
@@ -226,7 +226,7 @@ public override RegisterStorage GetRegister(string name)
 		{
 			var r = Registers.GetRegister(name);
 			if (r == RegisterStorage.None)
-				throw new ArgumentException(string.Format("'{0}' is not a register name.", name));
+				throw new ArgumentException($"'{name}' is not a register name.");
 			return r;
 		}
 
diff --git a/src/Arch/X86/X86Rewriter.Alu.cs b/src/Arch/X86/X86Rewriter.Alu.cs
index 14158fec4..2f53462fe 100644
--- a/src/Arch/X86/X86Rewriter.Alu.cs
+++ b/src/Arch/X86/X86Rewriter.Alu.cs
@@ -545,7 +545,7 @@ private void RewriteDivide(Func<Expression, Expression, Expression> op, Domain d
                 regDividend = binder.EnsureSequence(PrimitiveType.Word128, regRemainder.Storage, regQuotient.Storage);
                 break;
             default:
-                throw new ArgumentOutOfRangeException(string.Format("{0}-byte divisions not supported.", instrCur.dataWidth.Size));
+                throw new ArgumentOutOfRangeException($"{instrCur.dataWidth.Size}-byte divisions not supported.");
             };
             PrimitiveType p = ((PrimitiveType)regRemainder.DataType).MaskDomain(domain);
             var tmp = binder.CreateTemporary(regDividend.DataType);
@@ -674,7 +674,7 @@ private void RewriteMultiply(Func<Expression,Expression,Expression> op, Domain r
                         PrimitiveType.Word128, Registers.rdx, multiplicator.Storage);
                     break;
                 default:
-                    throw new ApplicationException(string.Format("Unexpected operand size: {0}", instrCur.Operands[0].Width));
+                    throw new ApplicationException($"Unexpected operand size: {instrCur.Operands[0].Width}");
                 };
                 var bin = op(SrcOp(0), multiplicator);
                 bin.DataType = PrimitiveType.Create(resultDomain, product.DataType.BitSize);
diff --git a/src/Arch/X86/X86Rewriter.cs b/src/Arch/X86/X86Rewriter.cs
index 6b415cd16..5afae1903 100644
--- a/src/Arch/X86/X86Rewriter.cs
+++ b/src/Arch/X86/X86Rewriter.cs
@@ -648,10 +648,7 @@ public Expression Intrinsic(IntrinsicProcedure intrinsic, DataType retType, para
         {
             if (args.Length != intrinsic.Arity)
                 throw new ArgumentOutOfRangeException(
-                    string.Format("Intrinsic {0} expected {1} arguments, but was passed {2}.",
-                    intrinsic.Name,
-                    intrinsic.Arity,
-                    args.Length));
+                    $"Intrinsic {intrinsic.Name} expected {intrinsic.Arity} arguments, but was passed {args.Length}.");
 
             return m.Fn(new ProcedureConstant(arch.PointerType, intrinsic), retType, args);
         }
diff --git a/src/Arch/Xtensa/XtensaRewriter.Control.cs b/src/Arch/Xtensa/XtensaRewriter.Control.cs
index 1348025e2..ceef11c65 100644
--- a/src/Arch/Xtensa/XtensaRewriter.Control.cs
+++ b/src/Arch/Xtensa/XtensaRewriter.Control.cs
@@ -61,9 +61,9 @@ private void RewriteBbx(Func<Expression, Expression> cmp0)
         {
             iclass = InstrClass.ConditionalTransfer;
             var src = RewriteOp(instr.Operands[0]);
-            var immOp = instr.Operands[1] as ImmediateOperand;
             Expression mask;
-            if (immOp != null)
+
+            if (instr.Operands[1] is ImmediateOperand immOp)
             {
                 mask = Constant.Word32(1 << immOp.Value.ToInt32());
             }
@@ -126,8 +126,8 @@ private void RewriteCall0()
         {
             iclass = InstrClass.Transfer | InstrClass.Call;
             var dst = RewriteOp(instr.Operands[0]);
-            var rDst = dst as Identifier;
-            if (rDst != null && rDst.Storage == Registers.a0)
+
+            if (dst is Identifier rDst && rDst.Storage == Registers.a0)
             {
                 var tmp = binder.CreateTemporary(rDst.DataType);
                 m.Assign(tmp, dst);
@@ -173,8 +173,8 @@ void UnshiftRegisters(int shift)
             iclass = InstrClass.Transfer | InstrClass.Call;
             ShiftRegisters(iReg);
             var dst = RewriteOp(instr.Operands[0]);
-            var rDst = dst as Identifier;
-            if (rDst != null && rDst.Storage == Registers.a0)
+
+            if (dst is Identifier rDst && rDst.Storage == Registers.a0)
             {
                 var tmp = binder.CreateTemporary(rDst.DataType);
                 m.Assign(tmp, dst);
diff --git a/src/Arch/Z80/MemoryOperand.cs b/src/Arch/Z80/MemoryOperand.cs
index d2ceb79af..82d86dc7a 100644
--- a/src/Arch/Z80/MemoryOperand.cs
+++ b/src/Arch/Z80/MemoryOperand.cs
@@ -75,13 +75,13 @@ protected override void DoRender(MachineInstructionRenderer renderer, MachineIns
                 }
                 else
                 {
-                    renderer.WriteString(string.Format("({0})", Base));
+                    renderer.WriteString($"({Base})");
                 }
             }
             else
             {
                 renderer.WriteString("(");
-                renderer.WriteAddress(string.Format("{0:X4}", Offset!.ToUInt16()), Address.Ptr16(Offset.ToUInt16()));
+                renderer.WriteAddress($"{Offset!.ToUInt16():X4}", Address.Ptr16(Offset.ToUInt16()));
                 renderer.WriteString(")");
             }
         }
diff --git a/src/Arch/Z80/Z80InstructionComparer.cs b/src/Arch/Z80/Z80InstructionComparer.cs
index b8da19a4d..1b289c7b2 100644
--- a/src/Arch/Z80/Z80InstructionComparer.cs
+++ b/src/Arch/Z80/Z80InstructionComparer.cs
@@ -131,7 +131,7 @@ private int HashOp(MachineOperand op)
                     h = h * 17 ^ GetConstantHash(memOp.Offset);
                 return h;
             }
-            throw new NotImplementedException(string.Format("{0} ({1})", op, op.GetType().Name));
+            throw new NotImplementedException($"{op} ({op.GetType().Name})");
         }
     }
 }
\ No newline at end of file
diff --git a/src/Arch/Z80/Z80Rewriter.cs b/src/Arch/Z80/Z80Rewriter.cs
index 906a4f8e1..3324b9d1a 100644
--- a/src/Arch/Z80/Z80Rewriter.cs
+++ b/src/Arch/Z80/Z80Rewriter.cs
@@ -526,7 +526,7 @@ private Expression RewriteOp(MachineOperand op)
                         }
                         }
             default:
-                throw new NotImplementedException(string.Format("Rewriting of Z80 operand type {0} is not implemented yet.", op.GetType().FullName));
+                throw new NotImplementedException($"Rewriting of Z80 operand type {op.GetType().FullName} is not implemented yet.");
             }
         }
 
diff --git a/src/Arch/i8051/i8051Rewriter.cs b/src/Arch/i8051/i8051Rewriter.cs
index 987bd93cf..fb2f59b76 100644
--- a/src/Arch/i8051/i8051Rewriter.cs
+++ b/src/Arch/i8051/i8051Rewriter.cs
@@ -73,9 +73,7 @@ public IEnumerator<RtlInstructionCluster> GetEnumerator()
                 default:
                     host.Warn(
                        instr.Address,
-                       string.Format(
-                           "i8051 instruction '{0}' not supported yet.",
-                           instr.Mnemonic));
+                       $"i8051 instruction '{instr.Mnemonic}' not supported yet.");
                     goto case Mnemonic.Invalid;
                 case Mnemonic.Invalid:
                 case Mnemonic.reserved:
diff --git a/src/Core/Address.cs b/src/Core/Address.cs
index d62b1797d..0bf6ed1fe 100644
--- a/src/Core/Address.cs
+++ b/src/Core/Address.cs
@@ -345,7 +345,7 @@ public override ulong ToLinear()
 
         public override string ToString()
         {
-            return string.Format("{0:X4}", uValue);
+            return $"{uValue:X4}";
         }
     }
 
@@ -412,7 +412,7 @@ public override ulong ToLinear()
 
         public override string ToString()
         {
-            return string.Format("{0:X8}", uValue);
+            return $"{uValue:X8}";
         }
     }
 
@@ -604,7 +604,7 @@ public override Expression CloneExpression()
 
         public override string GenerateName(string prefix, string suffix)
         {
-            return string.Format("{0}{1:X16}{2}", prefix, uValue, suffix);
+            return $"{prefix}{uValue:X16}{suffix}";
         }
 
         public override Address NewOffset(ulong offset)
@@ -634,7 +634,7 @@ public override ulong ToLinear()
 
         public override string ToString()
         {
-            return string.Format("{0:X16}", uValue);
+            return $"{uValue:X16}";
         }
     }
 }
diff --git a/src/Core/Assemblers/Emitter.cs b/src/Core/Assemblers/Emitter.cs
index 9b4139897..d333b884c 100644
--- a/src/Core/Assemblers/Emitter.cs
+++ b/src/Core/Assemblers/Emitter.cs
@@ -130,7 +130,7 @@ public void EmitLeImmediate(Constant c, PrimitiveType dt)
 			case 1: EmitByte(c.ToInt32()); return;
 			case 2: EmitLeUInt16(c.ToInt32()); return;
 			case 4: EmitLeUInt32(c.ToUInt32()); return;
-			default: throw new NotSupportedException(string.Format("Unsupported type: {0}", dt));
+			default: throw new NotSupportedException($"Unsupported type: {dt}");
 			}
 		}
 
diff --git a/src/Core/BackwalkOperation.cs b/src/Core/BackwalkOperation.cs
index 5f04255f1..8c44ae47d 100644
--- a/src/Core/BackwalkOperation.cs
+++ b/src/Core/BackwalkOperation.cs
@@ -64,7 +64,7 @@ private string OperatorToString(BackwalkOperator op)
 
 		public override string ToString()
 		{
-			return string.Format("{0} {1}", OperatorToString(op), operand);
+			return $"{OperatorToString(op)} {operand}";
 		}
 	}
 
@@ -84,7 +84,7 @@ public int TableOffset
 
 		public override string ToString()
 		{
-			return string.Format("deref {0:X8} {1}", operand, entrySize);
+			return $"deref {operand:X8} {entrySize}";
 		}
 	}
 
@@ -113,7 +113,7 @@ public override int Apply(int limit)
 
 		public override string ToString()
 		{
-			return string.Format("branch {0}", cc);
+			return $"branch {cc}";
 		}
 	}
 
@@ -133,7 +133,7 @@ public string ErrorMessage
 
 		public override string ToString()
 		{
-			return string.Format("err {0}", errorMsg);
+			return $"err {errorMsg}";
 		}
 	}
 
diff --git a/src/Core/BitRange.cs b/src/Core/BitRange.cs
index 81cd80347..95106759e 100644
--- a/src/Core/BitRange.cs
+++ b/src/Core/BitRange.cs
@@ -71,7 +71,7 @@ public bool Covers(BitRange that)
 
         public override bool Equals(object obj)
         {
-            if (obj != null && obj is BitRange that)
+            if (obj is BitRange that)
             {
                 return this.Lsb == that.Lsb && this.Msb == that.Msb;
             }
@@ -164,7 +164,7 @@ public override string ToString()
             if (IsEmpty)
                 return "[]";
             else
-                return string.Format("[{0}..{1}]", Lsb, Msb - 1);
+                return $"[{Lsb}..{Msb - 1}]";
         }
     }
 }
diff --git a/src/Core/CLanguage/CDirectiveLexer.cs b/src/Core/CLanguage/CDirectiveLexer.cs
index c9e22b4d4..b81c96d59 100644
--- a/src/Core/CLanguage/CDirectiveLexer.cs
+++ b/src/Core/CLanguage/CDirectiveLexer.cs
@@ -211,10 +211,10 @@ public virtual CToken ReadPragma(string pragma)
                         Expect(CTokenType.RParen);
                     }
                     else
-                        throw new FormatException(string.Format("Unknown verb {0}.", verb));
+                        throw new FormatException($"Unknown verb {verb}.");
                     break;
                 default:
-                    throw new FormatException(string.Format("Unexpected token {0}.", token.Type));
+                    throw new FormatException($"Unexpected token {token.Type}.");
                 }
                 return lexer.Read();
             }
@@ -257,7 +257,7 @@ private object Expect(CTokenType expected)
         private object Expect(CTokenType expected, CToken actualToken)
         {
             if (actualToken.Type != expected)
-                throw new FormatException(string.Format("Expected '{0}' but got '{1}' on line {2}.", expected, actualToken.Type, lexer.LineNumber));
+                throw new FormatException($"Expected '{expected}' but got '{actualToken.Type}' on line {lexer.LineNumber}.");
             return actualToken.Value;
         }
 
@@ -265,9 +265,9 @@ private void Expect(CTokenType expected, object expectedValue)
         {
             var token = lexer.Read();
             if (token.Type != expected)
-                throw new FormatException(string.Format("Expected '{0}' but got '{1}'.", expected, token.Type));
+                throw new FormatException($"Expected '{expected}' but got '{token.Type}'.");
             if (!expectedValue.Equals(token.Value))
-                throw new FormatException(string.Format("Expected '{0}' but got '{1}.", expectedValue, token.Value));
+                throw new FormatException($"Expected '{expectedValue}' but got '{token.Value}.");
         }
     }
 }
diff --git a/src/Core/CLanguage/CLexer.cs b/src/Core/CLanguage/CLexer.cs
index ccea6b261..3abbf2d38 100644
--- a/src/Core/CLanguage/CLexer.cs
+++ b/src/Core/CLanguage/CLexer.cs
@@ -779,7 +779,7 @@ public CToken Read()
 
         private void Nyi(State state, char ch)
         {
-            throw new NotImplementedException(string.Format("State {0}, ch: {1} (U+{2:X4})", state, ch, (uint)ch));
+            throw new NotImplementedException($"State {state}, ch: {ch} (U+{(uint)ch:X4})");
         }
 
         private void ClearBuffer()
diff --git a/src/Core/CLanguage/CParser.cs b/src/Core/CLanguage/CParser.cs
index 85bce095c..337e36e5c 100644
--- a/src/Core/CLanguage/CParser.cs
+++ b/src/Core/CLanguage/CParser.cs
@@ -116,14 +116,12 @@ private object ExpectToken(CTokenType token)
         private Exception Unexpected(CToken unexpected)
         {
             return new CParserException(
-                string.Format("Unexpected token '{0}' ({1}) on line {2}.",
-                unexpected.Type,
-                unexpected.Value ?? unexpected.Type, lexer.LineNumber));
+                $"Unexpected token '{unexpected.Type}' ({unexpected.Value ?? unexpected.Type}) on line {lexer.LineNumber}.");
         }
 
         private Exception Unexpected(CTokenType expected, CTokenType actual)
         {
-            throw new CParserException(string.Format("Expected token '{0}' but saw '{1}' on line {2}.", expected, actual, lexer.LineNumber));
+            throw new CParserException($"Expected token '{expected}' but saw '{actual}' on line {lexer.LineNumber}.");
         }
 
         public bool IsTypeName(CToken x)
diff --git a/src/Core/CLanguage/CSyntax.cs b/src/Core/CLanguage/CSyntax.cs
index 970c2c7c2..7bef49121 100644
--- a/src/Core/CLanguage/CSyntax.cs
+++ b/src/Core/CLanguage/CSyntax.cs
@@ -128,7 +128,7 @@ public override T Accept<T>(DeclSpecVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("(__declspec {0})", Name);
+            return $"(__declspec {Name})";
         }
     }
 
@@ -274,8 +274,8 @@ public override T Accept<T>(CSyntaxVisitor<T> visitor)
         public override string ToString()
         {
             return (Value == null)
-                ? string.Format("({0})", Name)
-                : string.Format("({0} {1})", Name, Value);
+                ? $"({Name})"
+                : $"({Name} {Value})";
         }
     }
 
@@ -474,7 +474,7 @@ public override T Accept<T>(DeclaratorVisitor<T> visitor)
             return visitor.VisitArray(this);
         }
 
-        public override string ToString() { return string.Format("(arr {0} {1})", Declarator, Size); }
+        public override string ToString() { return $"(arr {Declarator} {Size})"; }
     }
 
     public class StructDecl : CSyntax
@@ -660,10 +660,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
             return visitor.VisitMember(this);
         }
 
-        public override string ToString() { return string.Format("({0} {1} {2}",
-            Expression,
-            Dereference ? "->" : ".",
-            FieldName); }
+        public override string ToString() { return $"({Expression} {(Dereference ? "->" : ".")} {FieldName}"; }
     }
     public class CUnaryExpression : CExpression
     {
@@ -675,7 +672,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
             return visitor.VisitUnary(this);
         }
 
-        public override string ToString() { return string.Format("({0} {1})", Operation, Expression); }
+        public override string ToString() { return $"({Operation} {Expression})"; }
     }
 
     public class CBinaryExpression : CExpression
@@ -690,7 +687,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
         }
 
 
-        public override string ToString() { return string.Format("({0} {1} {2})", Operation, Left, Right); }
+        public override string ToString() { return $"({Operation} {Left} {Right})"; }
     }
 
     public class AssignExpression : CExpression
@@ -717,7 +714,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("(cast {0} {1})", Type, Expression);
+            return $"(cast {Type} {Expression})";
         }
     }
 
@@ -734,7 +731,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("(cond {0} {1} {2})", Condition, Consequent, Alternative);
+            return $"(cond {Condition} {Consequent} {Alternative})";
         }
     }
 
@@ -762,8 +759,7 @@ public override T Accept<T>(CExpressionVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("(sizeof {0})",
-                Type != null ? (object) Type : (object) Expression);
+            return $"(sizeof {(Type != null ? (object)Type : (object)Expression)})";
         }
     }
 
@@ -815,7 +811,7 @@ public class LineLabel : Label
     {
         public string Name;
 
-        public override string ToString() { return string.Format("label {0})", Name); }
+        public override string ToString() { return $"label {Name})"; }
     }
 
     public class CaseLabel : Label
@@ -827,7 +823,7 @@ public override string ToString()
             if (Value == null)
                 return "(default)";
             else
-                return string.Format("(case {0})", Value);
+                return $"(case {Value})";
         }
     }
 
@@ -881,7 +877,7 @@ public override string ToString()
         {
             if (Expression == null)
                 return " ";
-            return string.Format("({0})", Expression.ToString());
+            return $"({Expression.ToString()})";
         }
     }
 
diff --git a/src/Core/CLanguage/NamedDataTypeExtractor.cs b/src/Core/CLanguage/NamedDataTypeExtractor.cs
index 4d78b700a..82c1ee015 100644
--- a/src/Core/CLanguage/NamedDataTypeExtractor.cs
+++ b/src/Core/CLanguage/NamedDataTypeExtractor.cs
@@ -304,7 +304,7 @@ private NamedDataType ConvertArrayToPointer(NamedDataType nt)
         private void ApplyCallConvention(CTokenType convention)
         {
             if (callingConvention != CTokenType.None && callingConvention != convention)
-                throw new FormatException(string.Format("Unexpected extra calling convention specifier '{0}'.", callingConvention));
+                throw new FormatException($"Unexpected extra calling convention specifier '{callingConvention}'.");
             callingConvention = convention;
         }
 
@@ -313,27 +313,27 @@ private void ApplyCallConvention(CTokenType convention)
             switch (simpleType.Type)
             {
             default:
-                throw new NotImplementedException(string.Format("{0}", simpleType.Type));
+                throw new NotImplementedException($"{simpleType.Type}");
             case CTokenType.Void:
                 if (domain != Domain.None)
-                    throw new FormatException(string.Format("Can't have 'void' after '{0}'.", domain));
+                    throw new FormatException($"Can't have 'void' after '{domain}'.");
                 return new VoidType_v1();
             case CTokenType.__W64:
                 return dt;      // Used by Microsoft compilers for 32->64 bit transition, deprecated.
             case CTokenType.Signed:
                 if (domain != Domain.None)
-                    throw new FormatException(string.Format("Can't have 'signed' after '{0}'.", domain));
+                    throw new FormatException($"Can't have 'signed' after '{domain}'.");
                 domain = Domain.SignedInt;
                 return CreatePrimitive();
             case CTokenType.Unsigned:
                 if (domain != Domain.None)
-                    throw new FormatException(string.Format("Can't have 'unsigned' after '{0}'.", domain));
+                    throw new FormatException($"Can't have 'unsigned' after '{domain}'.");
                 domain = Domain.UnsignedInt;
                 return CreatePrimitive();
             case CTokenType.Bool:
             case CTokenType._Bool:
                 if (domain != Domain.None)
-                    throw new FormatException(string.Format("An '{0}' boolean doesn't make sense.", domain));
+                    throw new FormatException($"An '{domain}' boolean doesn't make sense.");
                 domain = Domain.Boolean;
                 basicType = CBasicType.Bool;
                 return CreatePrimitive();
@@ -341,26 +341,26 @@ private void ApplyCallConvention(CTokenType convention)
                 if (domain == Domain.None)
                     domain = Domain.Character;
                 else if (domain != Domain.SignedInt && domain != Domain.UnsignedInt)
-                    throw new FormatException(string.Format("Unexpected domain {0}.", domain));
+                    throw new FormatException($"Unexpected domain {domain}.");
                 basicType = CBasicType.Char;
                 return CreatePrimitive();
             case CTokenType.Wchar_t:
                 if (domain == Domain.None)
                     domain = Domain.Character;
                 else if (domain != Domain.SignedInt && domain != Domain.UnsignedInt)
-                    throw new FormatException(string.Format("Unexpected domain {0}", domain));
+                    throw new FormatException($"Unexpected domain {domain}");
                 basicType = CBasicType.WChar_t;
                 return CreatePrimitive();
             case CTokenType.Short:
                 if (domain != Domain.None && domain != Domain.SignedInt && domain != Domain.UnsignedInt)
-                    throw new FormatException(string.Format("Unexpected domain {0}", domain));
+                    throw new FormatException($"Unexpected domain {domain}");
                 basicType = CBasicType.Short;
                 return CreatePrimitive();
             case CTokenType.Int:
                 if (domain == Domain.None)
                     domain = Domain.SignedInt;
                 else if (domain != Domain.SignedInt && domain != Domain.UnsignedInt)
-                    throw new FormatException(string.Format("Unexpected domain {0}", domain));
+                    throw new FormatException($"Unexpected domain {domain}");
                 if (basicType == CBasicType.None)
                     basicType = CBasicType.Int;
                 return CreatePrimitive();
@@ -374,18 +374,18 @@ private void ApplyCallConvention(CTokenType convention)
                 if (domain == Domain.None)
                     domain = Domain.SignedInt;
                 else if (domain != Domain.SignedInt && domain != Domain.UnsignedInt)
-                    throw new FormatException(string.Format("Unexpected domain {0}", domain));
+                    throw new FormatException($"Unexpected domain {domain}");
                 basicType = CBasicType.Int64;
                 return CreatePrimitive();
             case CTokenType.Float:
                 if (domain != Domain.None)
-                    throw new FormatException(string.Format("Unexpected domain {0} before float.", domain));
+                    throw new FormatException($"Unexpected domain {domain} before float.");
                 domain = Domain.Real;
                 basicType = CBasicType.Float;
                 return CreatePrimitive();
             case CTokenType.Double:
                 if (domain != Domain.None && domain != Domain.SignedInt)  //$REVIEW: short double? long double? long long double?
-                    throw new FormatException(string.Format("Unexpected domain {0} before float.", domain));
+                    throw new FormatException($"Unexpected domain {domain} before float.");
                 domain = Domain.Real;
                 if (basicType == CBasicType.None)
                     basicType = CBasicType.Double;
@@ -421,9 +421,7 @@ public SerializedType VisitTypedef(TypeDefName typeDefName)
             }
             if (!symbolTable.NamedTypes.TryGetValue(typeDefName.Name, out var type))
             {
-                throw new ApplicationException(string.Format(
-                        "Type name {0} not defined.",
-                        typeDefName.Name ?? "(null)"));
+                throw new ApplicationException($"Type name {typeDefName.Name ?? "(null)"} not defined.");
             }
             byteSize = type.Accept(symbolTable.Sizer);
             return new TypeReference_v1(typeDefName.Name);
@@ -485,7 +483,7 @@ public SerializedType VisitEnum(EnumeratorTypeSpec e)
             if (e.Tag == null || !symbolTable.EnumsSeen.TryGetValue(e.Tag, out var _))
             {
                 var en = new SerializedEnumType {
-                    Name = e.Tag ?? string.Format("enum_{0}", symbolTable.EnumsSeen.Count)
+                    Name = e.Tag ?? $"enum_{symbolTable.EnumsSeen.Count}"
                 };
                 symbolTable.EnumsSeen.Add(en.Name, en);
                 var enumEvaluator = new EnumEvaluator(new CConstantEvaluator(platform, symbolTable.Constants));
diff --git a/src/Core/Configuration/PlatformDefinition.cs b/src/Core/Configuration/PlatformDefinition.cs
index 35b524714..59afc83e2 100644
--- a/src/Core/Configuration/PlatformDefinition.cs
+++ b/src/Core/Configuration/PlatformDefinition.cs
@@ -67,7 +67,7 @@ public virtual IPlatform Load(IServiceProvider services, IProcessorArchitecture
             var type = svc.GetType(TypeName);
             if (type == null)
                 throw new TypeLoadException(
-                    string.Format("Unable to load {0} environment.", Description));
+                    $"Unable to load {Description} environment.");
             var platform = (Platform)Activator.CreateInstance(type, services, arch);
             LoadSettingsFromConfiguration(services, platform);
             return platform;
@@ -115,7 +115,7 @@ private PlatformHeuristics LoadHeuristics(PlatformHeuristics_v1? heuristics)
             {
                 prologs = heuristics.ProcedurePrologs
                     .Select(p => LoadMaskedPattern(p)!)
-                    .Where(p => p != null && p.Bytes != null)
+                    .Where(p => p?.Bytes != null)
                     .ToArray();
             }
 
diff --git a/src/Core/Configuration/RekoConfigurationService.cs b/src/Core/Configuration/RekoConfigurationService.cs
index b4d56d5db..0c0b61f0a 100644
--- a/src/Core/Configuration/RekoConfigurationService.cs
+++ b/src/Core/Configuration/RekoConfigurationService.cs
@@ -371,7 +371,7 @@ public virtual ICollection<RawFileDefinition> GetRawFiles()
             if (modelName is null)
                 return GetArchitecture(archLabel, new Dictionary<string, object>());
             var elem = GetArchitectures()
-                .Where(e => e.Name == archLabel).SingleOrDefault();
+                .SingleOrDefault(e => e.Name == archLabel);
             if (elem == null)
                 return null;
             ModelDefinition? model;
@@ -407,7 +407,7 @@ public virtual ICollection<RawFileDefinition> GetRawFiles()
         public IProcessorArchitecture? GetArchitecture(string archLabel, Dictionary<string, object>? options)
         {
             var elem = GetArchitectures()
-                .Where(e => e.Name == archLabel).SingleOrDefault();
+                .SingleOrDefault(e => e.Name == archLabel);
             if (elem == null || elem.TypeName == null)
                 return null;
             options ??= new Dictionary<string, object>();
@@ -427,7 +427,7 @@ public virtual ICollection<RawFileDefinition> GetRawFiles()
         public PlatformDefinition GetEnvironment(string envName)
         {
             var env = GetEnvironments()
-                .Where(e => e.Name == envName).SingleOrDefault();
+                .SingleOrDefault(e => e.Name == envName);
             if (env != null)
                 return env;
 
@@ -445,8 +445,8 @@ public virtual LoaderDefinition GetImageLoader(string loaderName)
         public virtual RawFileDefinition? GetRawFile(string rawFileFormat)
         {
             return GetRawFiles()
-                .Where(r => r.Name == rawFileFormat)
-                .SingleOrDefault();
+                .SingleOrDefault(r => r.Name == rawFileFormat)
+;
         }
 
         public IEnumerable<UiStyleDefinition> GetDefaultPreferences()
diff --git a/src/Core/Dfa/DfaBuilder.cs b/src/Core/Dfa/DfaBuilder.cs
index e4d49f928..931a898f0 100644
--- a/src/Core/Dfa/DfaBuilder.cs
+++ b/src/Core/Dfa/DfaBuilder.cs
@@ -127,7 +127,7 @@ public void BuildAutomaton(TreeNode tree)
                 {
                     var U = CreateIntermediateState(p.Node.FollowPos!);
                     Dstates.TryGetValue(U, out IntermediateState dstate);
-                    if (U.Nodes.Count() > 0 && dstate == null)
+                    if (U.Nodes.Any() && dstate == null)
                     {
                         Dstates.Add(U, U);
                         unmarked.Enqueue(U);
diff --git a/src/Core/Expressions/Constant.cs b/src/Core/Expressions/Constant.cs
index 194be692b..7f781d231 100644
--- a/src/Core/Expressions/Constant.cs
+++ b/src/Core/Expressions/Constant.cs
@@ -174,7 +174,7 @@ public static Constant RealFromBitpattern(PrimitiveType dt, long bits)
 			else if (dt == PrimitiveType.Real64)
 				return DoubleFromBitpattern(bits);
 			else
-				throw new ArgumentException(string.Format("Data type {0} is not a floating point type.", dt));
+				throw new ArgumentException($"Data type {dt} is not a floating point type.");
 		}
 
 		public static Constant FloatFromBitpattern(long bits)
@@ -303,7 +303,7 @@ public virtual bool IsNegative
                 else if (p.Domain == Domain.Pointer)
                     return false;
                 else
-					throw new InvalidOperationException(string.Format("Type {0} can't be negative", DataType));
+					throw new InvalidOperationException($"Type {DataType} can't be negative");
 			}
 		}
 
@@ -342,7 +342,7 @@ public virtual Constant Negate()
                 return Constant.Create(p, -Convert.ToInt64(c));
 			}
 			else 
-				throw new InvalidOperationException(string.Format("Type {0} doesn't support negation.", p));
+				throw new InvalidOperationException($"Type {p} doesn't support negation.");
 		}
 
 		public static Constant Pi()
diff --git a/src/Core/Expressions/Expression.cs b/src/Core/Expressions/Expression.cs
index 1fffc2221..8b66540de 100644
--- a/src/Core/Expressions/Expression.cs
+++ b/src/Core/Expressions/Expression.cs
@@ -75,7 +75,7 @@ public Expression(DataType dataType)
         /// <returns></returns>
         public virtual Expression Invert()
         {
-            throw new NotSupportedException(string.Format("Expression of type {0} doesn't support Invert.", GetType().Name));
+            throw new NotSupportedException($"Expression of type {GetType().Name} doesn't support Invert.");
         }
 
         public override string ToString()
diff --git a/src/Core/Expressions/ExpressionMatcher.cs b/src/Core/Expressions/ExpressionMatcher.cs
index 9d4fe7841..a8fe1d710 100644
--- a/src/Core/Expressions/ExpressionMatcher.cs
+++ b/src/Core/Expressions/ExpressionMatcher.cs
@@ -473,7 +473,7 @@ public WildOperator(string Label)
 
             public override string ToString()
             {
-                return string.Format("[{0}]", Label);
+                return $"[{Label}]";
             }
         }
 
diff --git a/src/Core/Expressions/ExpressionTypeAscenderBase.cs b/src/Core/Expressions/ExpressionTypeAscenderBase.cs
index e31058cb6..67f0021a0 100644
--- a/src/Core/Expressions/ExpressionTypeAscenderBase.cs
+++ b/src/Core/Expressions/ExpressionTypeAscenderBase.cs
@@ -88,7 +88,7 @@ public DataType VisitArrayAccess(ArrayAccess acc)
 
         private Exception NYI(Expression e)
         {
-            return new NotImplementedException(string.Format("Not implemented: {0}", e));
+            return new NotImplementedException($"Not implemented: {e}");
         }
 
         public DataType VisitBinaryExpression(BinaryExpression binExp)
diff --git a/src/Core/FieldAttribute.cs b/src/Core/FieldAttribute.cs
index dfa951737..4526146b3 100644
--- a/src/Core/FieldAttribute.cs
+++ b/src/Core/FieldAttribute.cs
@@ -48,7 +48,7 @@ public virtual object ReadValue(System.Reflection.FieldInfo f, EndianImageReader
             {
                 return fn(rdr);
             }
-            throw new NotSupportedException(string.Format("Field type {0} not supported.", f.FieldType.FullName));
+            throw new NotSupportedException($"Field type {f.FieldType.FullName} not supported.");
         }
     }
 
diff --git a/src/Core/Frame.cs b/src/Core/Frame.cs
index d1c8c1a74..11b14d01d 100644
--- a/src/Core/Frame.cs
+++ b/src/Core/Frame.cs
@@ -134,9 +134,7 @@ public Identifier EnsureIdentifier(Storage stgForeign)
             case TemporaryStorage tmp:
                 return CreateTemporary(tmp.Name, tmp.DataType);
             }
-            throw new NotImplementedException(string.Format(
-                "Unsupported storage {0}.",
-                stgForeign != null ? stgForeign.ToString() : "(null)"));
+            throw new NotImplementedException($"Unsupported storage {(stgForeign != null ? stgForeign.ToString() : "(null)")}.");
         }
 
 		/// <summary>
@@ -192,7 +190,7 @@ public Identifier EnsureFpuStackVariable(int depth, DataType type)
 			Identifier? id = FindFpuStackVariable(depth);
 			if (id == null)
 			{
-				string name = string.Format("{0}{1}", (depth < 0 ? "rLoc" : "rArg"), Math.Abs(depth));
+				string name = $"{(depth < 0 ? "rLoc" : "rArg")}{Math.Abs(depth)}";
 				id = new Identifier(name, type, new FpuStackStorage(depth, type));
 				identifiers.Add(id);
 			}
diff --git a/src/Core/FrameApplicationBuilder.cs b/src/Core/FrameApplicationBuilder.cs
index ca9a6d2ad..c887a56f9 100644
--- a/src/Core/FrameApplicationBuilder.cs
+++ b/src/Core/FrameApplicationBuilder.cs
@@ -100,12 +100,12 @@ public virtual Expression VisitFpuStackStorage(FpuStackStorage fpu)
 
         public Expression VisitMemoryStorage(MemoryStorage global)
         {
-            throw new NotSupportedException(string.Format("A {0} can't be used as a formal parameter.", global.GetType().FullName));
+            throw new NotSupportedException($"A {global.GetType().FullName} can't be used as a formal parameter.");
         }
 
         public Expression VisitStackLocalStorage(StackLocalStorage local)
         {
-            throw new NotSupportedException(string.Format("A {0} can't be used as a formal parameter.", local.GetType().FullName));
+            throw new NotSupportedException($"A {local.GetType().FullName} can't be used as a formal parameter.");
         }
 
         public Expression VisitOutArgumentStorage(OutArgumentStorage arg)
@@ -145,7 +145,7 @@ public Expression VisitStackArgumentStorage(StackArgumentStorage stack)
 
         public Expression VisitTemporaryStorage(TemporaryStorage temp)
         {
-            throw new NotSupportedException(string.Format("A {0} can't be used as a formal parameter.", temp.GetType().FullName));
+            throw new NotSupportedException($"A {temp.GetType().FullName} can't be used as a formal parameter.");
         }
 
         #endregion
diff --git a/src/Core/ImageLoader.cs b/src/Core/ImageLoader.cs
index 0c1e36054..f360b41f9 100644
--- a/src/Core/ImageLoader.cs
+++ b/src/Core/ImageLoader.cs
@@ -86,9 +86,7 @@ public ImageLoader(IServiceProvider services, string filename, byte[] imgRaw)
         public virtual Program Load(Address addrLoad, IProcessorArchitecture arch, IPlatform platform)
         {
             throw new NotSupportedException(
-                string.Format(
-                    "Image loader {0} doesn't support overriding the processor architecture or platform.",
-                    GetType().FullName));
+                $"Image loader {GetType().FullName} doesn't support overriding the processor architecture or platform.");
         }
 
         /// <summary>
diff --git a/src/Core/ImageMap.cs b/src/Core/ImageMap.cs
index 3af8b89ca..7997eb514 100644
--- a/src/Core/ImageMap.cs
+++ b/src/Core/ImageMap.cs
@@ -119,7 +119,7 @@ public void AddItemWithSize(Address addr, ImageMapItem itemNew)
         {
             if (!TryFindItem(addr, out var item))
             {
-                throw new ArgumentException(string.Format("Address {0} is not within the image range.", addr));
+                throw new ArgumentException($"Address {addr} is not within the image range.");
             }
             // Do not split items with known data.
             if (!(item.DataType is UnknownType || item.DataType is CodeType))
@@ -193,7 +193,7 @@ private DataType ChopAfter(DataType type, int offset)
                 throw new ArgumentNullException("type");
             if (type is UnknownType || type is CodeType)
                 return type;
-            throw new NotImplementedException(string.Format("Cannot chop image map item of type {0}.", type));
+            throw new NotImplementedException($"Cannot chop image map item of type {type}.");
         }
 
         private DataType ChopBefore(DataType type, int offset)
@@ -370,7 +370,7 @@ public bool IsInRange(ulong linearAddress)
 
 		public override string ToString()
 		{
-            return string.Format("{0}, size: {1}, type:{2}", Address, Size, DataType);
+            return $"{Address}, size: {Size}, type:{DataType}";
 		}
 	}
 }
diff --git a/src/Core/ImageSegment.cs b/src/Core/ImageSegment.cs
index 6bf2d02b8..8c33d9212 100644
--- a/src/Core/ImageSegment.cs
+++ b/src/Core/ImageSegment.cs
@@ -213,7 +213,7 @@ public virtual bool IsInRange(ulong linearAddress)
 
         public override string ToString()
 		{
-			return string.Format("Segment {0} at {1}, {2} / {3} bytes", Name, Address.ToString(), ContentSize, Size);
+			return $"Segment {Name} at {Address.ToString()}, {ContentSize} / {Size} bytes";
 		}
     }
 
diff --git a/src/Core/ImageSymbol.cs b/src/Core/ImageSymbol.cs
index bdcf9eee3..7d2b165e2 100644
--- a/src/Core/ImageSymbol.cs
+++ b/src/Core/ImageSymbol.cs
@@ -194,10 +194,7 @@ public static ImageSymbol DataObject(IProcessorArchitecture arch, Address addres
 
         public override string ToString()
         {
-            return string.Format(
-                "{0} ({1})",
-                string.IsNullOrEmpty(Name) ? "???" : Name,
-                Address);
+            return $"{(string.IsNullOrEmpty(Name) ? "???" : Name)} ({Address})";
         }
     }
 
diff --git a/src/Core/ImportReference.cs b/src/Core/ImportReference.cs
index 5d127388a..069069872 100644
--- a/src/Core/ImportReference.cs
+++ b/src/Core/ImportReference.cs
@@ -145,7 +145,7 @@ public OrdinalImportReference(Address addr, string moduleName, int ordinal, Symb
 
         private static string MakeEntryName(string moduleName, int ordinal)
         {
-            return string.Format("{0}_{1}", moduleName, ordinal);
+            return $"{moduleName}_{ordinal}";
         }
 
         public override int CompareTo(ImportReference that)
@@ -181,7 +181,7 @@ public override ExternalProcedure ResolveImportedProcedure(IDynamicLinker resolv
 
         public override string ToString()
         {
-            return string.Format("{0}!Ordinal_{1}", ModuleName, Ordinal);
+            return $"{ModuleName}!Ordinal_{Ordinal}";
         }
     }
 }
diff --git a/src/Core/IntrinsicProcedure.cs b/src/Core/IntrinsicProcedure.cs
index 59a5b8689..1fbec952c 100644
--- a/src/Core/IntrinsicProcedure.cs
+++ b/src/Core/IntrinsicProcedure.cs
@@ -106,7 +106,7 @@ public override string ToString()
 			}
 			else
 			{
-				return string.Format("{0} {1}({2} args)", ReturnType, Name, arity);
+				return $"{ReturnType} {Name}({arity} args)";
 			}
 		}
 	}
diff --git a/src/Core/Lib/DiGraph.cs b/src/Core/Lib/DiGraph.cs
index e6de5dc6f..c070508ac 100644
--- a/src/Core/Lib/DiGraph.cs
+++ b/src/Core/Lib/DiGraph.cs
@@ -246,7 +246,7 @@ public bool ContainsEdge(T itemFrom, T itemTo)
 
         public override string ToString()
         {
-            return string.Format("Nodes = {0}", nodes.Count);
+            return $"Nodes = {nodes.Count}";
         }
     }
 }
diff --git a/src/Core/Lib/DirectedGraphImpl.cs b/src/Core/Lib/DirectedGraphImpl.cs
index e1c4a8555..e3834e24a 100644
--- a/src/Core/Lib/DirectedGraphImpl.cs
+++ b/src/Core/Lib/DirectedGraphImpl.cs
@@ -157,7 +157,7 @@ private ICollection<T> CreateEdgeCollectionCore(T o, bool fSuccessors)
 		{
             int iNode;
             if (!mpobjectNode.TryGetValue(o, out iNode))
-                throw new ArgumentException(string.Format("Unknown node {0}.", o));
+                throw new ArgumentException($"Unknown node {o}.");
                 //return new EdgeCollection(this, -1, fSuccessors);
 			return new EdgeCollection(this, iNode, fSuccessors);
 		}
diff --git a/src/Core/Lib/Float16.cs b/src/Core/Lib/Float16.cs
index 43fdf2e63..420b4fa99 100644
--- a/src/Core/Lib/Float16.cs
+++ b/src/Core/Lib/Float16.cs
@@ -120,8 +120,7 @@ public double ToDouble(IFormatProvider formatProvider)
 
         private InvalidCastException InvalidCast(Type type)
         {
-            return new InvalidCastException(string.Format("Invalid cast from '{0}' to '{1}'.",
-                type.Name, GetType().Name));
+            return new InvalidCastException($"Invalid cast from '{type.Name}' to '{GetType().Name}'.");
         }
 
         TypeCode IConvertible.GetTypeCode()
diff --git a/src/Core/Lib/Float80.cs b/src/Core/Lib/Float80.cs
index ebd538200..0816075d2 100644
--- a/src/Core/Lib/Float80.cs
+++ b/src/Core/Lib/Float80.cs
@@ -108,8 +108,7 @@ public double ToDouble(IFormatProvider formatProvider)
 
         private InvalidCastException InvalidCast(Type type)
         {
-            return new InvalidCastException(string.Format("Invalid cast from '{0}' to '{1}'.",
-                type.Name, GetType().Name));
+            return new InvalidCastException($"Invalid cast from '{type.Name}' to '{GetType().Name}'.");
         }
 
         TypeCode IConvertible.GetTypeCode()
diff --git a/src/Core/Lib/Float96.cs b/src/Core/Lib/Float96.cs
index 2dc3e2931..25eb98f99 100644
--- a/src/Core/Lib/Float96.cs
+++ b/src/Core/Lib/Float96.cs
@@ -109,8 +109,7 @@ public double ToDouble(IFormatProvider formatProvider)
 
         private InvalidCastException InvalidCast(Type type)
         {
-            return new InvalidCastException(string.Format("Invalid cast from '{0}' to '{1}'.",
-                type.Name, GetType().Name));
+            return new InvalidCastException($"Invalid cast from '{type.Name}' to '{GetType().Name}'.");
         }
 
         TypeCode IConvertible.GetTypeCode()
diff --git a/src/Core/Lib/IntervalTree.cs b/src/Core/Lib/IntervalTree.cs
index f966e9596..c04b9405d 100644
--- a/src/Core/Lib/IntervalTree.cs
+++ b/src/Core/Lib/IntervalTree.cs
@@ -87,7 +87,7 @@ public bool Covers(Interval<T> that)
 
         public override string ToString()
         {
-            return string.Format("[{0}, {1}]", this.Start.ToString(), this.End.ToString());
+            return $"[{this.Start.ToString()}, {this.End.ToString()}]";
         }
 
         public Interval<T> Intersect(Interval<T> that)
@@ -425,14 +425,14 @@ public void Write(TextWriter w)
             this.Visit((node, level) =>
             {
                 w.Write(new string(' ', 2 * level));
-                w.Write(string.Format("{0}.{1}", node.Interval, node.Max));
+                w.Write($"{node.Interval}.{node.Max}");
 
                 if (node.Range != null)
                 {
                     w.Write(" ... ");
                     foreach (var rangeNode in node.GetRange())
                     {
-                        w.Write(string.Format("{0}  ", rangeNode.Key));
+                        w.Write($"{rangeNode.Key}  ");
                     }
                 }
 
@@ -1419,9 +1419,9 @@ public int Compare(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
             /// </returns>
             public override bool Equals(object obj)
             {
-                if (obj is KeyValueComparer<TKey, TValue>)
+                if (obj is KeyValueComparer<TKey, TValue> TKeys)
                 {
-                    return object.Equals(this.keyComparer, ((KeyValueComparer<TKey, TValue>)obj).keyComparer);
+                    return object.Equals(this.keyComparer, TKeys.keyComparer);
                 }
                 else
                 {
@@ -1451,7 +1451,7 @@ public static IComparer<T> GetComparer()
                 }
                 else
                 {
-                    throw new InvalidOperationException(string.Format("The type {0} cannot be compared. It must implement IComparable<T> or IComparable", typeof(T).FullName));
+                    throw new InvalidOperationException($"The type {typeof(T).FullName} cannot be compared. It must implement IComparable<T> or IComparable");
                 }
             }
         }
diff --git a/src/Core/Lib/LinqAlgorithms.cs b/src/Core/Lib/LinqAlgorithms.cs
index 117c6b077..dfd26df19 100644
--- a/src/Core/Lib/LinqAlgorithms.cs
+++ b/src/Core/Lib/LinqAlgorithms.cs
@@ -115,7 +115,7 @@ public class Item
 
             public override string ToString()
             {
-                return string.Format("c: {0}, n: {1}", component_id, id);
+                return $"c: {component_id}, n: {id}";
             }
         }
 
@@ -173,8 +173,7 @@ private static void DumpComponents(Dictionary<long, Item> items)
             Debug.Print("{0}", string.Join(Environment.NewLine,
                 items.Values.OrderBy(v => v.component_id)
                     .ThenBy(v => v.id)
-                    .Select(v => string.Format(
-                        "c: {0}, n: {1}", v.component_id, v.id))));
+                    .Select(v => $"c: {v.component_id}, n: {v.id}")));
         }
     }
 }
\ No newline at end of file
diff --git a/src/Core/Lib/SuffixArray.cs b/src/Core/Lib/SuffixArray.cs
index 2dbdeb9ab..4b616dab0 100644
--- a/src/Core/Lib/SuffixArray.cs
+++ b/src/Core/Lib/SuffixArray.cs
@@ -432,7 +432,7 @@ private int CalcLcp(int i, int j)
 
         public override string ToString()
         {
-            return string.Format("[{0}]", string.Join(", ", m_sa.Take(80)));
+            return $"[{string.Join(", ", m_sa.Take(80))}]";
         }
 
 
diff --git a/src/Core/Lib/UbjsonReader.cs b/src/Core/Lib/UbjsonReader.cs
index ea3fbf947..aafc71218 100644
--- a/src/Core/Lib/UbjsonReader.cs
+++ b/src/Core/Lib/UbjsonReader.cs
@@ -74,7 +74,7 @@ public UbjsonReader(Stream stm)
                 case UbjsonMarker.Array: return ReadArray();
                 case UbjsonMarker.Object: return ReadObject();
                 default:
-                    throw new NotSupportedException(string.Format("Unknown marker {0}.", (char)m));
+                    throw new NotSupportedException($"Unknown marker {(char)m}.");
                 }
             }
         }
diff --git a/src/Core/Memory/ByteMemoryArea.cs b/src/Core/Memory/ByteMemoryArea.cs
index d8216ab22..ab04132ef 100644
--- a/src/Core/Memory/ByteMemoryArea.cs
+++ b/src/Core/Memory/ByteMemoryArea.cs
@@ -68,7 +68,7 @@ public static bool CompareArrays(byte[] src, int iSrc, byte[] dst, int cb)
 
         public override string ToString()
         {
-            return string.Format("Image {0}{1} - length {2} bytes{3}", "{", BaseAddress, this.Length, "}");
+            return $"Image {"{"}{BaseAddress} - length {this.Length} bytes{"}"}";
         }
 
         public override EndianImageReader CreateBeReader(Address addr)
@@ -256,7 +256,7 @@ public static bool TryReadLe(byte[] abImage, long imageOffset, PrimitiveType typ
                     c = Constant.Real80(real80);
                     return true;
                 default:
-                    throw new InvalidOperationException(string.Format("Real type {0} not supported.", type));
+                    throw new InvalidOperationException($"Real type {type} not supported.");
                 }
             }
 
@@ -285,7 +285,7 @@ public static bool TryReadLe(byte[] abImage, long imageOffset, PrimitiveType typ
                 c = Constant.Create(type, l);
                 return true;
             default:
-               throw new NotImplementedException(string.Format("Primitive type {0} not supported.", type));
+               throw new NotImplementedException($"Primitive type {type} not supported.");
             }
             c = default!;
             return false;
@@ -307,7 +307,7 @@ public static bool TryReadBe(byte[] abImage, long imageOffset, PrimitiveType typ
                         break;
                     value = Constant.DoubleFromBitpattern(dbl);
                     return true;
-                default: throw new NotSupportedException(string.Format("Real type {0} not supported.", type));
+                default: throw new NotSupportedException($"Real type {type} not supported.");
                 }
             }
             else
@@ -335,7 +335,7 @@ public static bool TryReadBe(byte[] abImage, long imageOffset, PrimitiveType typ
                     value = Constant.Create(type, d);
                     return true;
                 default:
-                    throw new NotImplementedException(string.Format("Primitive type {0} not supported.", type));
+                    throw new NotImplementedException($"Primitive type {type} not supported.");
                 }
             }
             value = default!;
diff --git a/src/Core/Memory/EndianImageReader.cs b/src/Core/Memory/EndianImageReader.cs
index 4c1d2e099..3c0131494 100644
--- a/src/Core/Memory/EndianImageReader.cs
+++ b/src/Core/Memory/EndianImageReader.cs
@@ -112,7 +112,7 @@ public bool ReadNullCharTerminator(DataType charType)
             {
                 8 => (char) ReadByte() == 0,
                 16 => (char) ReadUInt16() == 0,
-                _ => throw new NotSupportedException(string.Format("Character bit size {0} not supported.", charType.BitSize)),
+                _ => throw new NotSupportedException($"Character bit size {charType.BitSize} not supported."),
             };
         }
 
diff --git a/src/Core/Memory/Word16MemoryArea.cs b/src/Core/Memory/Word16MemoryArea.cs
index fd37ac3f0..9c2fe2cf4 100644
--- a/src/Core/Memory/Word16MemoryArea.cs
+++ b/src/Core/Memory/Word16MemoryArea.cs
@@ -75,7 +75,7 @@ public ulong ReadBeUInt64(long offset)
 
         public override string ToString()
         {
-            return string.Format("Image {0}{1} - length {2} 16-bit words {3}", "{", BaseAddress, this.Length, "}");
+            return $"Image {"{"}{BaseAddress} - length {this.Length} 16-bit words {"}"}";
         }
 
 
diff --git a/src/Core/NamingPolicy.cs b/src/Core/NamingPolicy.cs
index 1b2991b0e..bfc691d08 100644
--- a/src/Core/NamingPolicy.cs
+++ b/src/Core/NamingPolicy.cs
@@ -87,7 +87,7 @@ public virtual string GlobalName(StructureField field)
             if (field.IsNameSet)
                 return field.Name;
             var fieldName = Types.StructureFieldName(field, null);
-            return string.Format("g_{0}", fieldName);
+            return $"g_{fieldName}";
         }
 
         /// <summary>
diff --git a/src/Core/Operators/IAddOperator.cs b/src/Core/Operators/IAddOperator.cs
index 6e0bd165f..b8a2c7fdf 100644
--- a/src/Core/Operators/IAddOperator.cs
+++ b/src/Core/Operators/IAddOperator.cs
@@ -53,7 +53,7 @@ public override Constant ApplyConstants(Constant c1, Constant c2)
                 var p2 = (PrimitiveType) c1.DataType;
                 if ((p1.Domain & p2.Domain) == 0 && 
                     (p1.Domain | p2.Domain) != Domain.Integer)
-                    throw new ArgumentException(string.Format("Can't add types of disjoint domains {0} and {1}", c1.DataType, c2.DataType));
+                    throw new ArgumentException($"Can't add types of disjoint domains {c1.DataType} and {c2.DataType}");
             }
             return BuildConstant(c1.DataType, c2.DataType, c1.ToInt64() + c2.ToInt64());
 		}
diff --git a/src/Core/Operators/ShlOperator.cs b/src/Core/Operators/ShlOperator.cs
index 355c6552e..cbe15730b 100644
--- a/src/Core/Operators/ShlOperator.cs
+++ b/src/Core/Operators/ShlOperator.cs
@@ -30,9 +30,9 @@ public override Constant ApplyConstants(Constant c1, Constant c2)
 		{
             if (!ValidArgs(c1, c2))
                 return Constant.Invalid;
-            var pt = c1.DataType as PrimitiveType;
             var dom = Domain.Integer;
-            if (pt != null)
+
+            if (c1.DataType is PrimitiveType pt)
                 dom = pt.Domain & Domain.Integer;
             if (dom == 0)
                 dom = Domain.Integer;
diff --git a/src/Core/Output/CodeFormatter.cs b/src/Core/Output/CodeFormatter.cs
index 9a2c3332b..14bdaea6d 100644
--- a/src/Core/Output/CodeFormatter.cs
+++ b/src/Core/Output/CodeFormatter.cs
@@ -170,7 +170,7 @@ public void VisitAddress(Address addr)
                 var s = addr.ToString();
                 if (!s.Contains(':'))
                 {
-                    s = string.Format("0x{0}<p{1}>", s, addr.DataType.BitSize);
+                    s = $"0x{s}<p{addr.DataType.BitSize}>";
             }
                 InnerFormatter.Write(s);
         }
@@ -944,9 +944,9 @@ private static int Nybbles(int bitSize)
                 }
                 var ch = Convert.ToChar(value);
                 if (Char.IsControl(ch))
-                    return (string.Format(format, string.Format("\\x{0:X2}", (int) ch)), "");
+                    return (string.Format(format, $"\\x{(int)ch:X2}"), "");
                 else if (ch == '\'' || ch == '\\')
-                    return (string.Format(format, string.Format("\\{0}", ch)), "");
+                    return (string.Format(format, $"\\{ch}"), "");
                 return (format, "");
             case Domain.UnsignedInt:
                 if (!(value is ulong n))
diff --git a/src/Core/Output/JsonWriter.cs b/src/Core/Output/JsonWriter.cs
index 43a5d09b8..a97d35139 100644
--- a/src/Core/Output/JsonWriter.cs
+++ b/src/Core/Output/JsonWriter.cs
@@ -57,12 +57,12 @@ public void WritePropertyName(string n)
                 pp.PrintCharacter(',');
                 pp.ConnectedLineBreak();
             }
-            pp.PrintString(string.Format("\"{0}\":", n));
+            pp.PrintString($"\"{n}\":");
         }
 
         public void Write(string s)
         {
-            pp.PrintString(string.Format("\"{0}\"", s));
+            pp.PrintString($"\"{s}\"");
             if (state.Count > 0 && state.Peek() == PROP)
             {
                 state.Pop();
diff --git a/src/Core/Output/TypeReferenceFormatter.cs b/src/Core/Output/TypeReferenceFormatter.cs
index e01ba12e4..dc308f7eb 100644
--- a/src/Core/Output/TypeReferenceFormatter.cs
+++ b/src/Core/Output/TypeReferenceFormatter.cs
@@ -209,7 +209,7 @@ void TypeSpecifier(DataType t)
                 wantSpace = true;
                 return;
             }
-            else if (t is PrimitiveType) {
+            else if (t is PrimitiveType primitiveType) {
                 //case tree_code.VOID_TYPE:
                 //case tree_code.BOOLEAN_TYPE:
                 //case tree_code.CHAR_TYPE:
@@ -219,15 +219,15 @@ void TypeSpecifier(DataType t)
                 //    t = TYPE_NAME(t);
                 //else
                 //    t = c_common_type_for_mode(TYPE_MODE(t), TREE_UNSIGNED(t));
-                WritePrimitiveTypeName((PrimitiveType)t);
+                WritePrimitiveTypeName(primitiveType);
                 //if (declaration && !string.IsNullOrEmpty(declaredName))
                 //    fmt.Write(' ');
                 wantSpace = true;
                 return;
             }
-            else if (t is VoidType)
+            else if (t is VoidType voidType)
             {
-                WriteVoidType((VoidType)t);
+                WriteVoidType(voidType);
                 wantSpace = true;
                 return;
             }
diff --git a/src/Core/Pascal/PascalLexer.cs b/src/Core/Pascal/PascalLexer.cs
index 52996f67d..8b5c67ba4 100644
--- a/src/Core/Pascal/PascalLexer.cs
+++ b/src/Core/Pascal/PascalLexer.cs
@@ -337,7 +337,7 @@ private Token MaybeKeyword(string str)
 
         private void Nyi(State state, char ch)
         {
-            throw new NotImplementedException(string.Format("Line: {0}, State {1}, ch: {2} (U+{3:X4})", lineNumber, state, ch, (uint)ch));
+            throw new NotImplementedException($"Line: {lineNumber}, State {state}, ch: {ch} (U+{(uint)ch:X4})");
         }
 
         private Token Tok(TokenType type, object value = null)
diff --git a/src/Core/Pascal/PascalParser.cs b/src/Core/Pascal/PascalParser.cs
index db3d3ff8f..64dde3146 100644
--- a/src/Core/Pascal/PascalParser.cs
+++ b/src/Core/Pascal/PascalParser.cs
@@ -575,7 +575,7 @@ private T Expect<T>(TokenType expectedType)
         {
             var tok = lexer.Read();
             if (tok.Type != expectedType)
-                throw new ApplicationException(string.Format("Expected token {0} but read {1}.", expectedType, tok));
+                throw new ApplicationException($"Expected token {expectedType} but read {tok}.");
             return (T)tok.Value;
         }
 
@@ -583,12 +583,12 @@ private void Expect(TokenType expectedType)
         {
             var tok = lexer.Read();
             if (tok.Type != expectedType)
-                throw new ApplicationException(string.Format("Expected token {0} but read {1}.", expectedType, tok));
+                throw new ApplicationException($"Expected token {expectedType} but read {tok}.");
         }
 
         private void Unexpected(Token token)
         {
-            throw new ApplicationException(string.Format("Token {0} was not expected.", token));
+            throw new ApplicationException($"Token {token} was not expected.");
         }
     }
 }
diff --git a/src/Core/Pascal/PascalSyntax.cs b/src/Core/Pascal/PascalSyntax.cs
index 171084d4f..c70adaa9c 100644
--- a/src/Core/Pascal/PascalSyntax.cs
+++ b/src/Core/Pascal/PascalSyntax.cs
@@ -679,8 +679,7 @@ public override void Write(TextWriter writer)
 
         private void WriteOpcode(TextWriter w, Exp opcode)
         {
-            var i = opcode as NumericLiteral;
-            if (i != null)
+            if (opcode is NumericLiteral i)
             {
                 w.Write("${0:X4}", i.Value);
             }
diff --git a/src/Core/Pascal/Token.cs b/src/Core/Pascal/Token.cs
index 9ce877908..9acec0f28 100644
--- a/src/Core/Pascal/Token.cs
+++ b/src/Core/Pascal/Token.cs
@@ -34,9 +34,9 @@ public class Token
         public override string ToString()
         {
             if (Value is null)
-                return string.Format("{0}", Type);
+                return $"{Type}";
             else
-                return string.Format("{0}:{1}", Type, Value);
+                return $"{Type}:{Value}";
         }
     }
 
diff --git a/src/Core/Platform.cs b/src/Core/Platform.cs
index 84de5457e..def9e7f3e 100644
--- a/src/Core/Platform.cs
+++ b/src/Core/Platform.cs
@@ -358,9 +358,7 @@ public virtual void EnsureTypeLibraries(string envName)
                 var cfgSvc = Services.RequireService<IConfigurationService>();
                 var envCfg = cfgSvc.GetEnvironment(envName);
                 if (envCfg == null)
-                    throw new ApplicationException(string.Format(
-                        "Environment '{0}' doesn't appear in the configuration file. Your installation may be out-of-date.",
-                        envName));
+                    throw new ApplicationException($"Environment '{envName}' doesn't appear in the configuration file. Your installation may be out-of-date.");
                 this.Metadata = new TypeLibrary(envCfg.CaseInsensitive);
 
                 var tlSvc = Services.RequireService<ITypeLibraryLoaderService>();
@@ -406,7 +404,7 @@ private void ApplyCharacteristicsToServices(CharacteristicsLibrary[] characteris
         /// <returns></returns>
         public virtual string FormatProcedureName(Program program, Procedure proc)
         {
-            return string.Format("{0}!{1}", program.Name, proc.Name);
+            return $"{program.Name}!{proc.Name}";
         }
 
         public abstract int GetBitSizeFromCBasicType(CBasicType cb);
@@ -558,8 +556,8 @@ public virtual bool TryParseAddress(string? sAddress, out Address addr)
         {
             EnsureTypeLibraries(PlatformIdentifier);
             return CharacteristicsLibs.Select(cl => cl.Lookup(procName))
-                .Where(c => c != null)
-                .FirstOrDefault();
+                .FirstOrDefault(c => c != null)
+;
         }
 
         public virtual void WriteMetadata(Program program, string path)
@@ -637,7 +635,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Core/Procedure.cs b/src/Core/Procedure.cs
index 0ef3f23a3..f7a9475dd 100644
--- a/src/Core/Procedure.cs
+++ b/src/Core/Procedure.cs
@@ -156,7 +156,7 @@ public string QualifiedName()
             if (EnclosingType == null)
                 return Name;
             if (EnclosingType is StructType_v1 str)
-                return string.Format("{0}::{1}", str.Name, Name);
+                return $"{str.Name}::{Name}";
             return Name;
         }
 
diff --git a/src/Core/Program.cs b/src/Core/Program.cs
index 6e487fb16..6784af070 100644
--- a/src/Core/Program.cs
+++ b/src/Core/Program.cs
@@ -412,21 +412,21 @@ public void EnsureDirectoryNames(string absFileName)
         public EndianImageReader CreateImageReader(IProcessorArchitecture arch, Address addr)
         {
             if (!SegmentMap.TryFindSegment(addr, out var segment))
-                 throw new ArgumentException(string.Format("The address {0} is invalid.", addr));
+                 throw new ArgumentException($"The address {addr} is invalid.");
             return arch.CreateImageReader(segment.MemoryArea, addr);
         }
 
         public ImageWriter CreateImageWriter(IProcessorArchitecture arch, Address addr)
         {
             if (!SegmentMap.TryFindSegment(addr, out var segment))
-                throw new ArgumentException(string.Format("The address {0} is invalid.", addr));
+                throw new ArgumentException($"The address {addr} is invalid.");
             return arch.CreateImageWriter(segment.MemoryArea, addr);
         }
 
         public IEnumerable<MachineInstruction> CreateDisassembler(IProcessorArchitecture arch, Address addr)
         {
             if (!SegmentMap.TryFindSegment(addr, out var segment))
-                throw new ArgumentException(string.Format("The address {0} is invalid.", addr));
+                throw new ArgumentException($"The address {addr} is invalid.");
             return arch.CreateDisassembler(
                 arch.CreateImageReader(segment.MemoryArea, addr));
         }
diff --git a/src/Core/Rational.cs b/src/Core/Rational.cs
index af9132053..fe75778b0 100644
--- a/src/Core/Rational.cs
+++ b/src/Core/Rational.cs
@@ -119,7 +119,7 @@ public double ToDouble()
 
         public override string ToString()
         {
-            return string.Format("{0}/{1}", Numerator, Denominator);
+            return $"{Numerator}/{Denominator}";
         }
     }
 }
diff --git a/src/Core/Rtl/RtlCluster.cs b/src/Core/Rtl/RtlCluster.cs
index b8ca093e9..7a40be14c 100644
--- a/src/Core/Rtl/RtlCluster.cs
+++ b/src/Core/Rtl/RtlCluster.cs
@@ -56,7 +56,7 @@ public RtlInstructionCluster(Address addr, int instrLength, params RtlInstructio
 
         public override string ToString()
         {
-            return string.Format("{0}({1}): {2} instructions", Address, Length, Instructions.Length);
+            return $"{Address}({Length}): {Instructions.Length} instructions";
         }
 
         public void Write(TextWriter writer)
diff --git a/src/Core/SegmentMap.cs b/src/Core/SegmentMap.cs
index 2f282c980..91829ca41 100644
--- a/src/Core/SegmentMap.cs
+++ b/src/Core/SegmentMap.cs
@@ -197,8 +197,7 @@ public Address MapLinearAddressToAddress(ulong linearAddress)
                 }
             }
             throw new ArgumentOutOfRangeException(
-                string.Format("Linear address {0:X8} is not in known segment.",
-                linearAddress));
+                $"Linear address {linearAddress:X8} is not in known segment.");
         }
 
 
diff --git a/src/Core/Serialization/ArgumentDeserializer.cs b/src/Core/Serialization/ArgumentDeserializer.cs
index fdba14d17..3a1d0a595 100644
--- a/src/Core/Serialization/ArgumentDeserializer.cs
+++ b/src/Core/Serialization/ArgumentDeserializer.cs
@@ -91,7 +91,7 @@ public class ArgumentDeserializer
                 return null;
             }
             if (argCur.Type == null)
-                throw new ApplicationException(string.Format("Argument '{0}' has no type.", argCur.Name));
+                throw new ApplicationException($"Argument '{argCur.Name}' has no type.");
             var dt = this.argCur.Type.Accept(procSer.TypeLoader);
             if (dt is VoidType)
             {
diff --git a/src/Core/Serialization/ArrayType_v1.cs b/src/Core/Serialization/ArrayType_v1.cs
index f4329efe0..6dd7d99a7 100644
--- a/src/Core/Serialization/ArrayType_v1.cs
+++ b/src/Core/Serialization/ArrayType_v1.cs
@@ -43,7 +43,7 @@ public override T Accept<T>(ISerializedTypeVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("arr({0},{1})", ElementType, Length);
+            return $"arr({ElementType},{Length})";
         }
     }
 }
diff --git a/src/Core/Serialization/Json/JsonWriter.cs b/src/Core/Serialization/Json/JsonWriter.cs
index 859193549..3c6da0c88 100644
--- a/src/Core/Serialization/Json/JsonWriter.cs
+++ b/src/Core/Serialization/Json/JsonWriter.cs
@@ -95,7 +95,7 @@ public void Write(object o)
                 atomWriter(this, o);
                 return;
             }
-            throw new NotImplementedException(string.Format("Don't know how to write {0}.", o.GetType()));
+            throw new NotImplementedException($"Don't know how to write {o.GetType()}.");
         }
 
         public void Write(bool value)
diff --git a/src/Core/Serialization/ProjectLoader.cs b/src/Core/Serialization/ProjectLoader.cs
index c21adbc1a..6e8ed14c8 100644
--- a/src/Core/Serialization/ProjectLoader.cs
+++ b/src/Core/Serialization/ProjectLoader.cs
@@ -174,13 +174,11 @@ public Project LoadProject(string filename, Project_v5 sp)
             }
 
             this.arch = arch ?? throw new ApplicationException(
-                    string.Format("Unknown architecture '{0}' in project file.",
-                        sp.ArchitectureName ?? "(null)"));
+                    $"Unknown architecture '{sp.ArchitectureName ?? "(null)"}' in project file.");
             var env = cfgSvc.GetEnvironment(sp.PlatformName!);
             if (env == null)
                 throw new ApplicationException(
-                    string.Format("Unknown operating environment '{0}' in project file.",
-                        sp.PlatformName ?? "(null)"));
+                    $"Unknown operating environment '{sp.PlatformName ?? "(null)"}' in project file.");
             this.platform = env.Load(Services, arch);
             this.project.LoadedMetadata = this.platform.CreateMetadata();
             var typelibs = sp.Inputs.OfType<MetadataFile_v3>().Select(m => VisitMetadataFile(filename, m));
@@ -204,13 +202,11 @@ public Project LoadProject(string filename, Project_v4 sp)
             this.arch = cfgSvc.GetArchitecture(sp.ArchitectureName!);
             if (arch == null)
                 throw new ApplicationException(
-                    string.Format("Unknown architecture '{0}' in project file.",
-                        sp.ArchitectureName ?? "(null)"));
+                    $"Unknown architecture '{sp.ArchitectureName ?? "(null)"}' in project file.");
             var env = cfgSvc.GetEnvironment(sp.PlatformName!);
             if (env == null)
                 throw new ApplicationException(
-                    string.Format("Unknown operating environment '{0}' in project file.",
-                        sp.PlatformName ?? "(null)"));
+                    $"Unknown operating environment '{sp.PlatformName ?? "(null)"}' in project file.");
             this.platform = env.Load(Services, arch);
             this.project.LoadedMetadata = this.platform.CreateMetadata();
             var typelibs = sp.Inputs.OfType<MetadataFile_v3>().Select(m => VisitMetadataFile(filename, m));
@@ -516,7 +512,7 @@ public void LoadUserData(UserData_v4 sUser, Program program, UserData user, stri
             if (sUser.JumpTables != null)
             {
                 program.User.JumpTables = sUser.JumpTables.Select(LoadJumpTable_v4)
-                    .Where(t => t != null && t.Address != null)
+                    .Where(t => t?.Address != null)
                     .ToSortedList(k => k!.Address, v => v);
             }
             if (sUser.IndirectJumps != null)
@@ -860,9 +856,7 @@ private IPlatform DeterminePlatform(string filename)
                 var oSvc = Services.GetService<IOracleService>();
                 if (oSvc != null)
                 {
-                    platform = oSvc.QueryPlatform(string.Format(
-                        "Please specify with operating environment should be used with metadata file {0}.",
-                        filename));
+                    platform = oSvc.QueryPlatform($"Please specify with operating environment should be used with metadata file {filename}.");
                 }
                 Debug.Print("Got platform <{0}>", platform);
                 return platform;
diff --git a/src/Core/Serialization/ProjectSaver.cs b/src/Core/Serialization/ProjectSaver.cs
index ded621186..240b24baf 100644
--- a/src/Core/Serialization/ProjectSaver.cs
+++ b/src/Core/Serialization/ProjectSaver.cs
@@ -242,10 +242,7 @@ private Annotation_v3 SerializeAnnotation(Annotation arg)
         private XmlElement? SerializeOptionValue(string key, object value, XmlDocument doc)
         {
             var el = SerializeValue(value, doc);
-            if (el != null)
-            {
-                el.SetAttribute("key", "", key);
-            }
+            el?.SetAttribute("key", "", key);
             return el;
         }
 
diff --git a/src/Core/Serialization/SerializedTypedef.cs b/src/Core/Serialization/SerializedTypedef.cs
index 716026929..7630369aa 100644
--- a/src/Core/Serialization/SerializedTypedef.cs
+++ b/src/Core/Serialization/SerializedTypedef.cs
@@ -44,7 +44,7 @@ public override T Accept<T>(ISerializedTypeVisitor<T> visitor)
 
         public override string ToString()
         {
-            return string.Format("typedef({0}, {1})", Name, DataType);
+            return $"typedef({Name}, {DataType})";
         }
     }
 }
diff --git a/src/Core/Services/ITypeLibraryLoaderService.cs b/src/Core/Services/ITypeLibraryLoaderService.cs
index f0e5d4921..5db5b6e64 100644
--- a/src/Core/Services/ITypeLibraryLoaderService.cs
+++ b/src/Core/Services/ITypeLibraryLoaderService.cs
@@ -73,7 +73,7 @@ public TypeLibrary LoadMetadataIntoLibrary(IPlatform platform, TypeLibraryDefini
             }
             catch (Exception ex)
             {
-                listener.Error(ex, string.Format("Unable to load metadata file {0}.", tlElement.Name));
+                listener.Error(ex, $"Unable to load metadata file {tlElement.Name}.");
                 return libDst;
             }
         }
diff --git a/src/Core/Storage.cs b/src/Core/Storage.cs
index d7b058515..36aeaf168 100644
--- a/src/Core/Storage.cs
+++ b/src/Core/Storage.cs
@@ -100,7 +100,7 @@ public Storage(string storageKind, string name, DataType dataType)
 
         public virtual bool Exceeds(Storage that)
         {
-            throw new NotImplementedException(string.Format("Exceeds not implemented for {0}.", that.GetType().Name));
+            throw new NotImplementedException($"Exceeds not implemented for {that.GetType().Name}.");
         }
 
         public virtual BitRange GetBitRange()
@@ -283,11 +283,11 @@ private static string MakeName(int depth)
         {
             if (depth >= 0)
             {
-                return string.Format("FPU +{0}", depth);
+                return $"FPU +{depth}";
             }
             else
             {
-                return string.Format("FPU -{0}", -depth);
+                return $"FPU -{-depth}";
             }
         }
 
diff --git a/src/Core/TypeLibraryDeserializer.cs b/src/Core/TypeLibraryDeserializer.cs
index bd29acc11..1453131c8 100644
--- a/src/Core/TypeLibraryDeserializer.cs
+++ b/src/Core/TypeLibraryDeserializer.cs
@@ -146,7 +146,7 @@ public void LoadProcedure(Procedure_v1 sp)
             {
                 Debug.Print("An error occurred when loading the signature of procedure {0}.", sp.Name);
                 throw new ApplicationException(
-                    string.Format("An error occurred when loading the signature of procedure {0}.", sp.Name),
+                    $"An error occurred when loading the signature of procedure {sp.Name}.",
                     ex);
             }
         }
diff --git a/src/Core/TypedDataDumper.cs b/src/Core/TypedDataDumper.cs
index 069d6cfa6..4991339c6 100644
--- a/src/Core/TypedDataDumper.cs
+++ b/src/Core/TypedDataDumper.cs
@@ -87,19 +87,19 @@ public void VisitPointer(Pointer ptr)
             case 2:
                 fmt.WriteKeyword("dw");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X4}", rdr.ReadByte()));
+                fmt.Write($"0x{rdr.ReadByte():X4}");
                 fmt.WriteLine();
                 return;
             case 4:
                 fmt.WriteKeyword("dd");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X8}", rdr.ReadUInt32()));
+                fmt.Write($"0x{rdr.ReadUInt32():X8}");
                 fmt.WriteLine();
                 return;
             case 8:
                 fmt.WriteKeyword("dq");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X16}", rdr.ReadUInt64()));
+                fmt.Write($"0x{rdr.ReadUInt64():X16}");
                 fmt.WriteLine();
                 return;
             }
@@ -112,25 +112,25 @@ public void VisitPrimitive(PrimitiveType pt)
             case 1:
                 fmt.WriteKeyword("db");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X2}", rdr.ReadByte()));
+                fmt.Write($"0x{rdr.ReadByte():X2}");
                 fmt.WriteLine();
                 return;
             case 2:
                 fmt.WriteKeyword("dw");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X4}", rdr.ReadUInt16()));
+                fmt.Write($"0x{rdr.ReadUInt16():X4}");
                 fmt.WriteLine();
                 return;
             case 4:
                 fmt.WriteKeyword("dd");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X8}", rdr.ReadUInt32()));
+                fmt.Write($"0x{rdr.ReadUInt32():X8}");
                 fmt.WriteLine();
                 return;
             case 8:
                 fmt.WriteKeyword("dq");
                 fmt.Write("\t");
-                fmt.Write(string.Format("0x{0:X16}", rdr.ReadUInt64()));
+                fmt.Write($"0x{rdr.ReadUInt64():X16}");
                 fmt.WriteLine();
                 return;
             default:
@@ -144,7 +144,7 @@ private void DumpBytes(int size)
             bool newLine = false;
             fmt.WriteKeyword("db");
             fmt.Write("\t");
-            fmt.Write(string.Format("0x{0:X2}", rdr.ReadByte()));
+            fmt.Write($"0x{rdr.ReadByte():X2}");
             for (int i = 1; i < size; ++i)
             {
                 if (newLine)
@@ -153,12 +153,12 @@ private void DumpBytes(int size)
                     fmt.Write("\t");
                     fmt.WriteKeyword("db");
                     fmt.Write("\t");
-                    fmt.Write(string.Format("0x{0:X2}", rdr.ReadByte()));
+                    fmt.Write($"0x{rdr.ReadByte():X2}");
                 }
                 else
                 {
                     fmt.Write(", ");
-                    fmt.Write(string.Format("0x{0:X2}", rdr.ReadByte()));
+                    fmt.Write($"0x{rdr.ReadByte():X2}");
                 }
                 newLine = (rdr.Address.ToLinear() & 0xF) == 0;
             }
@@ -202,7 +202,7 @@ public void VisitString(StringType str)
                             }
                             fmt.Write(sep);
                             sep = ",";
-                            fmt.Write(string.Format("0x{0:X2}", b));
+                            fmt.Write($"0x{b:X2}");
                             if (b == 0)
                                 break;
                         }
diff --git a/src/Core/TypedServiceProvider.cs b/src/Core/TypedServiceProvider.cs
index 8daaf066d..96f05587a 100644
--- a/src/Core/TypedServiceProvider.cs
+++ b/src/Core/TypedServiceProvider.cs
@@ -51,7 +51,7 @@ public static T GetService<T>(this IServiceProvider sp)
         {
             var result = sp.GetService<T>();
             if (result == default(T))
-                throw new InvalidOperationException(string.Format("Service {0} is required.", typeof(T).Name));
+                throw new InvalidOperationException($"Service {typeof(T).Name} is required.");
             return result;
         }
 
diff --git a/src/Core/Types/DataType.cs b/src/Core/Types/DataType.cs
index 834e51982..b94347fa0 100644
--- a/src/Core/Types/DataType.cs
+++ b/src/Core/Types/DataType.cs
@@ -116,7 +116,7 @@ public DataType Clone()
 
         protected void ThrowBadSize()
 		{
-			throw new InvalidOperationException(string.Format("Can't set size of {0}.", GetType().Name));
+			throw new InvalidOperationException($"Can't set size of {GetType().Name}.");
 		}
 
 		public sealed override string ToString()
diff --git a/src/Core/Types/DataTypeComparer.cs b/src/Core/Types/DataTypeComparer.cs
index fab1893ac..908a671a1 100644
--- a/src/Core/Types/DataTypeComparer.cs
+++ b/src/Core/Types/DataTypeComparer.cs
@@ -213,7 +213,7 @@ public int CompareInternal(DataType x, DataType y, int count)
             {
                 return Compare(fnX, fnY, ++count);
             }
-			throw new NotImplementedException(string.Format("NYI: comparison between {0} and {1}", x.GetType(), y.GetType()));
+			throw new NotImplementedException($"NYI: comparison between {x.GetType()} and {y.GetType()}");
 		}
 
 		public int Compare(UnionType x, UnionType y, int count)
diff --git a/src/Core/Types/TypeStore.cs b/src/Core/Types/TypeStore.cs
index 6c3d18e00..410cae4ba 100644
--- a/src/Core/Types/TypeStore.cs
+++ b/src/Core/Types/TypeStore.cs
@@ -79,7 +79,7 @@ public TypeVariable CreateTypeVariable(TypeFactory factory)
 
         public TypeVariable EnsureExpressionTypeVariable(TypeFactory factory, Expression e, string? name)
         {
-            if (e != null && e.TypeVariable != null)
+            if (e?.TypeVariable != null)
                 return e.TypeVariable;
 
             TypeVariable tv = name != null ? factory.CreateTypeVariable(name) : factory.CreateTypeVariable();
diff --git a/src/Core/Types/Unifier.cs b/src/Core/Types/Unifier.cs
index 521309dba..2ee841d2f 100644
--- a/src/Core/Types/Unifier.cs
+++ b/src/Core/Types/Unifier.cs
@@ -616,9 +616,7 @@ public DataType UnifyStructures(StructureType a, StructureType b)
                     var fieldType = Unify(fa.DataType, fb.DataType)!;
                     if (!TryMakeFieldName(fa, fb, out string fieldName))
                         throw new NotSupportedException(
-                            string.Format(
-                                "Failed to unify field '{0}' in structure '{1}' with field '{2}' in structure '{3}'.",
-                                fa.Name, a, fb.Name, b));
+                            $"Failed to unify field '{fa.Name}' in structure '{a}' with field '{fb.Name}' in structure '{b}'.");
                     mem.Fields.Add(fa.Offset, fieldType, fieldName);
 					fa = null;
 					fb = null;
diff --git a/src/Core/Types/UnionType.cs b/src/Core/Types/UnionType.cs
index 3345245c6..2cbaba887 100644
--- a/src/Core/Types/UnionType.cs
+++ b/src/Core/Types/UnionType.cs
@@ -175,7 +175,7 @@ public UnionAlternative(string? name, DataType dt, int index) : base(dt)
 
         private string GenerateDefaultName()
         {
-            return string.Format("u{0}", Index);
+            return $"u{Index}";
         }
 
         public UnionAlternative Clone()
diff --git a/src/Decompiler/Analysis/CallApplicationBuilder.cs b/src/Decompiler/Analysis/CallApplicationBuilder.cs
index 6a2065e93..b9f8f90cb 100644
--- a/src/Decompiler/Analysis/CallApplicationBuilder.cs
+++ b/src/Decompiler/Analysis/CallApplicationBuilder.cs
@@ -113,7 +113,7 @@ public override OutArgument BindOutArg(Identifier id)
             }
             if (!bindUses)
                 return null;
-            throw new NotImplementedException(string.Format("Offsets not matching? SP({0})", fpu.FpuStackOffset));
+            throw new NotImplementedException($"Offsets not matching? SP({fpu.FpuStackOffset})");
         }
 
         public Expression VisitMemoryStorage(MemoryStorage global)
diff --git a/src/Decompiler/Analysis/ConditionCodeEliminator.cs b/src/Decompiler/Analysis/ConditionCodeEliminator.cs
index c5661057a..ff5e52d35 100644
--- a/src/Decompiler/Analysis/ConditionCodeEliminator.cs
+++ b/src/Decompiler/Analysis/ConditionCodeEliminator.cs
@@ -571,7 +571,7 @@ public Expression ComparisonFromConditionCode(ConditionCode cc, BinaryExpression
                 return ComparisonFromParity(bin, isNegated);
             case ConditionCode.PO:
                 return ComparisonFromParity(bin, !isNegated);
-            default: throw new NotImplementedException(string.Format("Case {0} not handled.", cc));
+            default: throw new NotImplementedException($"Case {cc} not handled.");
 			}
 
 			Expression e;
diff --git a/src/Decompiler/Analysis/DataFlowAnalysis.cs b/src/Decompiler/Analysis/DataFlowAnalysis.cs
index 5016b9bac..a22b0d358 100644
--- a/src/Decompiler/Analysis/DataFlowAnalysis.cs
+++ b/src/Decompiler/Analysis/DataFlowAnalysis.cs
@@ -84,10 +84,7 @@ public void DumpProgram()
 				output.WriteLine();
 				foreach (Block block in proc.ControlGraph.Blocks)
 				{
-					if (block != null)
-					{
-						block.Write(output);
-					}
+					block?.Write(output);
 				}
 				Debug.WriteLine(output.ToString());
 			}
@@ -299,7 +296,7 @@ private void RemoveImplicitRegistersFromHellNodes(SsaState ssa)
                 return false;
             if (trashedRegisters.Count == 0)
                 return false;
-            return !trashedRegisters.Where(r => r.OverlapsWith(stg)).Any();
+            return !trashedRegisters.Any(r => r.OverlapsWith(stg));
         }
 
         /// <summary>
@@ -522,10 +519,7 @@ public SsaTransform ConvertToSsa(Procedure proc)
         public void ClearTestFiles()
         {
             var testSvc = this.services.GetService<ITestGenerationService>();
-            if (testSvc != null)
-            {
-                testSvc.RemoveFiles("analysis_");
-            }
+            testSvc?.RemoveFiles("analysis_");
         }
 
         [Conditional("DEBUG")]
diff --git a/src/Decompiler/Analysis/SsaIdentifierCollection.cs b/src/Decompiler/Analysis/SsaIdentifierCollection.cs
index fab63db75..013fef762 100644
--- a/src/Decompiler/Analysis/SsaIdentifierCollection.cs
+++ b/src/Decompiler/Analysis/SsaIdentifierCollection.cs
@@ -96,7 +96,7 @@ public bool TryGetValue(Identifier id, out SsaIdentifier sid)
 
 		private string FormatSsaName(Identifier id, int v)
 		{
-            return string.Format("{0}_{1}", id.Name, v);
+            return $"{id.Name}_{v}";
 		}
 
         private static string ReplaceNumericSuffix(string str, int newSuffix)
diff --git a/src/Decompiler/Analysis/SsaMutator.cs b/src/Decompiler/Analysis/SsaMutator.cs
index 5c18af980..e4fbfbbd7 100644
--- a/src/Decompiler/Analysis/SsaMutator.cs
+++ b/src/Decompiler/Analysis/SsaMutator.cs
@@ -79,9 +79,9 @@ public SsaMutator(SsaState ssa)
             int delta)
         {
             // Locate the post-call definition of the register, if any
-            var defRegBinding = call.Definitions.Where(
+            var defRegBinding = call.Definitions.FirstOrDefault(
                 u => u.Storage == register)
-                .FirstOrDefault();
+;
             if (defRegBinding == null)
                 return;
             var defRegId = defRegBinding.Expression as Identifier;
diff --git a/src/Decompiler/Analysis/SsaState.cs b/src/Decompiler/Analysis/SsaState.cs
index a671d1477..9269059ba 100644
--- a/src/Decompiler/Analysis/SsaState.cs
+++ b/src/Decompiler/Analysis/SsaState.cs
@@ -191,23 +191,13 @@ public void ValidateUses(Action<string> error)
                 {
                     if (!idMapActual.ContainsKey(id) || idMapActual[id] < idMapStored[id])
                         error(
-                            string.Format(
-                                "{0}: incorrect {1} id in {2}:{3} uses",
-                                Procedure.Name,
-                                id,
-                                stm.Block,
-                                stm));
+                            $"{Procedure.Name}: incorrect {id} id in {stm.Block}:{stm} uses");
                 }
                 foreach (var id in idMapActual.Keys)
                 {
                     if (!idMapStored.ContainsKey(id) || idMapStored[id] < idMapActual[id])
                         error(
-                            string.Format(
-                                "{0}: there is no {1} id in {2}:{3} uses",
-                                Procedure.Name,
-                                id,
-                                stm.Block,
-                                stm));
+                            $"{Procedure.Name}: there is no {id} id in {stm.Block}:{stm} uses");
                 }
             }
         }
@@ -244,12 +234,7 @@ public void ValidateDefinitions(Action<string> error)
                 {
                     if (actualDefs.TryGetValue(defId, out var def))
                     {
-                        error(string.Format(
-                            "{0}: multiple definitions for {1} ({2} and {3})",
-                            Procedure.Name,
-                            defId,
-                            stm,
-                            def));
+                        error($"{Procedure.Name}: multiple definitions for {defId} ({stm} and {def})");
                     }
                     else
                     {
@@ -265,12 +250,7 @@ public void ValidateDefinitions(Action<string> error)
                 }
                 if (sid.DefStatement != actualDef)
                 {
-                    error(string.Format(
-                        "{0}: incorrect definition for {1}({2}). Should be {3}",
-                        Procedure.Name,
-                        sid.Identifier,
-                        sid.DefStatement?.ToString() ?? "<null>",
-                        actualDef?.ToString() ?? "<null>"));
+                    error($"{Procedure.Name}: incorrect definition for {sid.Identifier}({sid.DefStatement?.ToString() ?? "<null>"}). Should be {actualDef?.ToString() ?? "<null>"}");
                 }
             }
             foreach (var defId in actualDefs.Keys)
@@ -278,11 +258,7 @@ public void ValidateDefinitions(Action<string> error)
                 if (!Identifiers.Contains(defId) &&
                     actualDefs.ContainsKey(defId))
                 {
-                    error(string.Format(
-                        "{0}: there is no {1}({2}) in the ssa identifiers",
-                        Procedure.Name,
-                        defId,
-                        actualDefs[defId]?.ToString() ?? "<null>"));
+                    error($"{Procedure.Name}: there is no {defId}({actualDefs[defId]?.ToString() ?? "<null>"}) in the ssa identifiers");
                 }
             }
         }
diff --git a/src/Decompiler/Analysis/SsaTransform.cs b/src/Decompiler/Analysis/SsaTransform.cs
index 27e9bebab..5056c67dc 100644
--- a/src/Decompiler/Analysis/SsaTransform.cs
+++ b/src/Decompiler/Analysis/SsaTransform.cs
@@ -863,7 +863,7 @@ private Storage FrameShift(CallInstruction call, Storage callerStorage, int spDe
             // assume all are.
             if (trashedRegisters.Count == 0)
                 return true;
-            return trashedRegisters.Where(r => r.OverlapsWith(stg)).Any();
+            return trashedRegisters.Any(r => r.OverlapsWith(stg));
         }
 
         private ProcedureBase? GetCalleeProcedure(CallInstruction ci)
diff --git a/src/Decompiler/Decompiler.cs b/src/Decompiler/Decompiler.cs
index 760db91a5..5febcdb57 100644
--- a/src/Decompiler/Decompiler.cs
+++ b/src/Decompiler/Decompiler.cs
@@ -605,7 +605,7 @@ private void ScanProgram(Program program)
         {
             return
                 userCalls
-                .Where(sc => sc != null && sc.Signature != null)
+                .Where(sc => sc?.Signature != null)
                 .Select(sc =>
                 {
                 //$BUG: need access to platform.Metadata.
diff --git a/src/Decompiler/Evaluation/ExpressionSimplifier.cs b/src/Decompiler/Evaluation/ExpressionSimplifier.cs
index e9de23cb6..8ed025472 100644
--- a/src/Decompiler/Evaluation/ExpressionSimplifier.cs
+++ b/src/Decompiler/Evaluation/ExpressionSimplifier.cs
@@ -568,7 +568,7 @@ public static Constant SimplifyTwoConstants(Operator op, Constant l, Constant r)
             {
                 return ((BinaryOperator) op).ApplyConstants(l, r);
             }
-            throw new ArgumentException(string.Format("Can't add types of different domains {0} and {1}", l.DataType, r.DataType));
+            throw new ArgumentException($"Can't add types of different domains {l.DataType} and {r.DataType}");
         }
 
         public virtual Expression VisitConversion(Conversion conversion)
diff --git a/src/Decompiler/Loading/DccSignatureLoader.cs b/src/Decompiler/Loading/DccSignatureLoader.cs
index b36541e2e..392bae252 100644
--- a/src/Decompiler/Loading/DccSignatureLoader.cs
+++ b/src/Decompiler/Loading/DccSignatureLoader.cs
@@ -369,7 +369,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             /* Read the parameters */
             if (!rdr.TryReadLeUInt32(out uint fileSig) || fileSig != 0x73636364) // "dccs"
             {
-                listener.Warn(string.Format("{0} is not a DCC signature file.", fpath));
+                listener.Warn($"{fpath} is not a DCC signature file.");
                 return false;
             }
 
@@ -379,7 +379,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             SymLen = rdr.ReadLeUInt16();
             if ((PatLen != PATLEN) || (SymLen != SYMLEN))
             {
-                listener.Warn(string.Format("Can't use signature file with sym and pattern lengths of {0} and {1}.", SymLen, PatLen));
+                listener.Warn($"Can't use signature file with sym and pattern lengths of {SymLen} and {PatLen}.");
                 return false;
             }
 
@@ -400,7 +400,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (!rdr.TryReadLeUInt16(out ww) || ww != 0x3154)    // "T1"
             {
                 Debug.Print("Expected 'T1'");
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             len = (ushort) (PatLen * 256u * 2);        // 2 = sizeof ushort
@@ -408,7 +408,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (w != len)
             {
                 Debug.Print("Problem with size of T1: file {0}, calc {1}", w, len);
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             readFileSection(T1base, len, rdr);
@@ -422,7 +422,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (w != len)
             {
                 Debug.Print("Problem with size of T2: file %d, calc %d\n", w, len);
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             readFileSection(T2base, len, rdr);
@@ -431,7 +431,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (!rdr.TryReadLeUInt16(out ww) || ww != 0x6767)    // "gg"
             {
                 Debug.Print("Expected 'gg'");
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             len = (ushort) (numVert * 2); //  sizeof(uint16_t));
@@ -439,7 +439,7 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (w != len)
             {
                 Debug.Print("Problem with size of g[]: file {0}, calc {1}", w, len);
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             readFileSection(g, len, rdr);
@@ -450,14 +450,14 @@ public bool SetupLibCheck(IServiceProvider services, string fpath, byte[] bytes)
             if (!rdr.TryReadLeUInt16(out ww) || ww != 0x7468)    // "ht"
             {
                 Debug.Print("Expected 'ht'");
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
             w = rdr.ReadLeUInt16();
             if (w != numKeys * (SymLen + PatLen + 2)) // sizeof(uint16_t)))
             {
                 Debug.Print("Problem with size of hash table: file {0}, calc {1}", w, len);
-                listener.Warn(string.Format("{0} is not a valid DCCS file.", fpath));
+                listener.Warn($"{fpath} is not a valid DCCS file.");
                 return false;
             }
 
@@ -861,10 +861,7 @@ void STATE_checkStartup(Program program, ProcessorState state)
 
             gotVendor:
 
-            sSigName = string.Format("dcc{0}{1}{2}.sig",
-                    chVendor, /* Add vendor */
-                    chVersion, /* Add version */
-                    chModel); /* Add model */
+            sSigName = $"dcc{chVendor}{chVersion}{chModel}.sig"; /* Add model */
             Debug.Print("Signature file: {0}", sSigName);
         }
 
@@ -892,7 +889,7 @@ void readProtoFile(IServiceProvider services)
             var fsSvc = services.RequireService<IFileSystemService>();
             if (fsSvc.FileExists(szProFName))
             {
-                listener.Warn(string.Format("Cannot open library prototype data file {0}.", szProFName));
+                listener.Warn($"Cannot open library prototype data file {szProFName}.");
                 return;
             }
             var bytes = fsSvc.ReadAllBytes(szProFName);
@@ -902,7 +899,7 @@ void readProtoFile(IServiceProvider services)
             uint fileSig = fProto.ReadLeUInt32();
             if (fileSig != 0x70636364)      // "dccp"
             {
-                listener.Warn(string.Format("{0} is not a dcc prototype file.", szProFName));
+                listener.Warn($"{szProFName} is not a dcc prototype file.");
                 return;
             }
 
@@ -910,7 +907,7 @@ void readProtoFile(IServiceProvider services)
             if (sectionID != 0x4E46)        // "FN"
             {
                 Debug.Print("FN (Function) subsection expected in {0}", szProFName);
-                listener.Warn(string.Format("{0} is not a dcc prototype file.", szProFName));
+                listener.Warn($"{szProFName} is not a dcc prototype file.");
                 return;
             }
             numFunc = fProto.ReadLeUInt16();    /* Num of entries to allocate */
diff --git a/src/Decompiler/Loading/Loader.cs b/src/Decompiler/Loading/Loader.cs
index 5f78dc0dc..bb4eb9c54 100644
--- a/src/Decompiler/Loading/Loader.cs
+++ b/src/Decompiler/Loading/Loader.cs
@@ -414,7 +414,7 @@ public static uint HexDigit(char digit)
             case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
                 return (uint) ((digit - 'a') + 10);
             default:
-                throw new ArgumentException(string.Format("Invalid hexadecimal digit '{0}'.", digit));
+                throw new ArgumentException($"Invalid hexadecimal digit '{digit}'.");
             }
         }
 
@@ -426,7 +426,7 @@ public static T CreateImageLoader<T>(IServiceProvider services, string typeName,
             var svc = services.RequireService<IPluginLoaderService>();
             var t = svc.GetType(typeName);
             if (t == null)
-                throw new ApplicationException(string.Format("Unable to find loader {0}.", typeName));
+                throw new ApplicationException($"Unable to find loader {typeName}.");
             return (T) Activator.CreateInstance(t, services, filename, bytes);
         }
 
@@ -438,7 +438,7 @@ public static T CreateOuterImageLoader<T>(IServiceProvider services, string type
             var svc = services.RequireService<IPluginLoaderService>();
             var type = svc.GetType(typeName);
             if (type == null)
-                throw new ApplicationException(string.Format("Unable to find loader {0}.", typeName));
+                throw new ApplicationException($"Unable to find loader {typeName}.");
             return (T) Activator.CreateInstance(type, innerLoader);
         }
 
@@ -469,7 +469,7 @@ public static ImageLoader CreateCustomImageLoader(IServiceProvider services, str
             var ass = Assembly.LoadFrom(loader);
             var t = ass.GetTypes().SingleOrDefault(tt => typeof(ImageLoader).IsAssignableFrom(tt));
             if (t == null)
-                throw new ApplicationException(string.Format("Unable to find image loader in {0}.", loader));
+                throw new ApplicationException($"Unable to find image loader in {loader}.");
             return (ImageLoader) Activator.CreateInstance(t, services, filename, bytes);
         }
 
diff --git a/src/Decompiler/Loading/UnpackingService.cs b/src/Decompiler/Loading/UnpackingService.cs
index 0ec2b3081..a69329d1d 100644
--- a/src/Decompiler/Loading/UnpackingService.cs
+++ b/src/Decompiler/Loading/UnpackingService.cs
@@ -106,7 +106,7 @@ public ImageLoader FindUnpackerBySignature(ImageLoader loader, uint entryPointOf
             // The suffix array is currently unused but the algorithm that generates it scales poorly
             // making Reko unable to load certain EXE files (due to the endless wait times)
             // EnsureSuffixArray(filename + ".sufa-raw.ubj", image);
-            var signature = Signatures.Where(s => Matches(s, loader.RawImage, entryPointOffset)).FirstOrDefault();
+            var signature = Signatures.FirstOrDefault(s => Matches(s, loader.RawImage, entryPointOffset));
             if (signature == null || signature.Name == null)
                 return loader;
             listener.Info("Signature of '{0}' detected.", signature.Name);
diff --git a/src/Decompiler/Scanning/Backwalker.cs b/src/Decompiler/Scanning/Backwalker.cs
index 072dab8a1..24a5662fb 100644
--- a/src/Decompiler/Scanning/Backwalker.cs
+++ b/src/Decompiler/Scanning/Backwalker.cs
@@ -384,7 +384,7 @@ public void DumpBlock(RegisterStorage regIdx, Block block)
             if (bin == null)
                 return RegisterStorage.None;
             var e = bin.Left;
-            while (e != null && e is Cast)
+            while (e is Cast)
             {
                 e = ((Cast)e).Expression;
             }
@@ -425,9 +425,7 @@ private void DumpInstructions(StatementList instrs, int idx)
             for (int i = 0; i < instrs.Count; ++i)
             {
                 Debug.WriteLineIf(trace.TraceInfo,
-                    string.Format("{0} {1}",
-                    idx == i ? '*' : ' ',
-                    instrs[i]));
+                    $"{(idx == i ? '*' : ' ')} {instrs[i]}");
             }
         }
 		
diff --git a/src/Decompiler/Scanning/BackwardSlicer.cs b/src/Decompiler/Scanning/BackwardSlicer.cs
index f90a0e0ab..ea832317c 100644
--- a/src/Decompiler/Scanning/BackwardSlicer.cs
+++ b/src/Decompiler/Scanning/BackwardSlicer.cs
@@ -727,9 +727,7 @@ public SlicerResult VisitArrayAccess(ArrayAccess acc, BackwardSlicerContext ctx)
                 this.slicer.AreEqual(binExp.Left, binExp.Right))
             {
                 // XOR r,r (or SUB r,r) clears a register. Is it part of a live register?
-                var regDst = this.assignLhs as Identifier;
-                var regHi = binExp.Left as Identifier;
-                if (regHi != null && regDst != null &&
+                if (binExp.Left is Identifier regHi && this.assignLhs is Identifier regDst &&
                     DomainOf(regDst) == regHi.Storage.Domain &&
                     regDst.Storage.OffsetOf(regHi.Storage) == 8)
                 {
diff --git a/src/Decompiler/Scanning/BlockCloner.cs b/src/Decompiler/Scanning/BlockCloner.cs
index b2b5e503e..4307ed8b8 100644
--- a/src/Decompiler/Scanning/BlockCloner.cs
+++ b/src/Decompiler/Scanning/BlockCloner.cs
@@ -104,7 +104,7 @@ public Instruction VisitAssignment(Assignment ass)
         public Instruction VisitBranch(Branch branch)
         {
             //$TODO: this may not be necessary once scanner-development is done.
-            return new SideEffect(Constant.String(string.Format("cloned {0}", branch), StringType.NullTerminated(PrimitiveType.Char)));
+            return new SideEffect(Constant.String($"cloned {branch}", StringType.NullTerminated(PrimitiveType.Char)));
         }
 
         public Instruction VisitCallInstruction(CallInstruction ci)
diff --git a/src/Decompiler/Scanning/BlockWorkitem.cs b/src/Decompiler/Scanning/BlockWorkitem.cs
index 8d3ff6e01..6ea9a81d6 100644
--- a/src/Decompiler/Scanning/BlockWorkitem.cs
+++ b/src/Decompiler/Scanning/BlockWorkitem.cs
@@ -926,16 +926,16 @@ private FunctionType GuessProcedureSignature(CallInstruction call)
         public bool ProcessAlloca(CallSite site, ExternalProcedure impProc)
         {
             if (impProc.Signature == null)
-                throw new ApplicationException(string.Format("You must specify a procedure signature for {0} since it has been marked as 'alloca'.", impProc.Name));
+                throw new ApplicationException($"You must specify a procedure signature for {impProc.Name} since it has been marked as 'alloca'.");
             var ab = arch.CreateFrameApplicationBuilder(
                 frame!,
                 site,
                 new ProcedureConstant(program.Platform.PointerType, impProc));
             if (impProc.Signature.Parameters!.Length != 1)
-                throw new ApplicationException(string.Format("An alloca function must have exactly one parameter, but {0} has {1}.", impProc.Name, impProc.Signature.Parameters.Length));
+                throw new ApplicationException($"An alloca function must have exactly one parameter, but {impProc.Name} has {impProc.Signature.Parameters.Length}.");
             var target = ab.Bind(impProc.Signature.Parameters[0]);
             if (!(target is Identifier id))
-                throw new ApplicationException(string.Format("The parameter of {0} wasn't a register.", impProc.Name));
+                throw new ApplicationException($"The parameter of {impProc.Name} wasn't a register.");
             if (state.GetValue(id) is Constant c && c.IsValid)
             {
                 Emit(new Assignment(stackReg!, new BinaryExpression(Operator.ISub, stackReg!.DataType, stackReg, c)));
@@ -1281,7 +1281,7 @@ private ProcedureBase ResolveDispatchProcedureCall(DispatchProcedure disp, Proce
             //$TODO if SVC uis null (and not-speculating) report the error.
             if (svc != null && svc.Signature == null)
             {
-                scanner.Error(ric!.Address, string.Format("System service '{0}' didn't specify a signature.", svc.Name));
+                scanner.Error(ric!.Address, $"System service '{svc.Name}' didn't specify a signature.");
             }
             return svc;
         }
diff --git a/src/Decompiler/Scanning/HeuristicDisassembler.cs b/src/Decompiler/Scanning/HeuristicDisassembler.cs
index adb16124e..93549ac2f 100644
--- a/src/Decompiler/Scanning/HeuristicDisassembler.cs
+++ b/src/Decompiler/Scanning/HeuristicDisassembler.cs
@@ -188,9 +188,7 @@ public RtlBlock Disassemble(Address addr)
                         return current;
                     default:
                         throw new NotImplementedException(
-                            string.Format(
-                                "RTL class {0}.", 
-                                instr.Class));
+                            $"RTL class {instr.Class}.");
                     }
                 }
             }
diff --git a/src/Decompiler/Scanning/ImageSymbolWorkItem.cs b/src/Decompiler/Scanning/ImageSymbolWorkItem.cs
index 4e860dde0..1121ec7c8 100644
--- a/src/Decompiler/Scanning/ImageSymbolWorkItem.cs
+++ b/src/Decompiler/Scanning/ImageSymbolWorkItem.cs
@@ -48,9 +48,7 @@ public override void Process()
 
         public override string ToString()
         {
-            return string.Format("Symbol: {0}{1}",
-                sym.Name ?? sym.Address!.ToString(),
-                isEntryPoint ? " entry" : "");
+            return $"Symbol: {sym.Name ?? sym.Address!.ToString()}{(isEntryPoint ? " entry" : "")}";
         }
     }
 }
diff --git a/src/Decompiler/Scanning/RegexpBuilder.cs b/src/Decompiler/Scanning/RegexpBuilder.cs
index 3e68258cf..46d5198b8 100644
--- a/src/Decompiler/Scanning/RegexpBuilder.cs
+++ b/src/Decompiler/Scanning/RegexpBuilder.cs
@@ -849,9 +849,7 @@ public void Compact()
 					restates[i].BasePosition = basePos[i] - min;
 					restates[i].Accepts = states[i].Accepts;
 					Debug.WriteLine(
-						string.Format(
-							"s{0}{1} base:{2}", 
-							i, restates[i].Accepts?" (acc)":"", restates[i].BasePosition));
+						$"s{i}{(restates[i].Accepts ? " (acc)" : "")} base:{restates[i].BasePosition}");
 				}
 				int [] checkNew = new int[max-min];
 				int [] nextNew = new int[max-min];
diff --git a/src/Decompiler/Scanning/RtlBlock.cs b/src/Decompiler/Scanning/RtlBlock.cs
index fb69a170b..f700d0e12 100644
--- a/src/Decompiler/Scanning/RtlBlock.cs
+++ b/src/Decompiler/Scanning/RtlBlock.cs
@@ -56,7 +56,7 @@ public Address GetEndAddress()
 
         public override string ToString()
         {
-            return string.Format("block({0})", Address);
+            return $"block({Address})";
         }
     }
 }
diff --git a/src/Decompiler/Scanning/Scanner.cs b/src/Decompiler/Scanning/Scanner.cs
index 6d8b18cbb..d7a48fad1 100644
--- a/src/Decompiler/Scanning/Scanner.cs
+++ b/src/Decompiler/Scanning/Scanner.cs
@@ -437,10 +437,7 @@ public Block CreateCallRetThunk(Address addrFrom, Procedure procOld, Procedure p
         {
             //$BUG: ReturnAddressOnStack property needs to be properly set, the
             // EvenOdd sample shows how this doesn't work currently. 
-            var blockName = string.Format(
-                "{0}_thunk_{1}",
-                Program.NamingPolicy.BlockName(addrFrom),
-                procNew.Name);
+            var blockName = $"{Program.NamingPolicy.BlockName(addrFrom)}_thunk_{procNew.Name}";
             var callRetThunkBlock = procOld.AddSyntheticBlock(
                 addrFrom,
                 blockName);
diff --git a/src/Decompiler/Scanning/ScannerInLinq.cs b/src/Decompiler/Scanning/ScannerInLinq.cs
index c836bdeb0..220cae59b 100644
--- a/src/Decompiler/Scanning/ScannerInLinq.cs
+++ b/src/Decompiler/Scanning/ScannerInLinq.cs
@@ -316,7 +316,7 @@ select new
                 from b in the_blocks.Values
                 group b by b.component_id into g
                 orderby g.Key
-                select string.Format("{0:X8}:{1}", g.Key, g.Count())));
+                select $"{g.Key:X8}:{g.Count()}"));
         }
 
         /// <summary>
@@ -509,14 +509,9 @@ void DumpInstructions(ScanResults sr)
                 string.Join("\r\n",
                     from instr in sr.FlatInstructions.Values
                     join e in sr.FlatEdges on instr.addr equals e.first into es
-                    from e in new[] { string.Join(", ", es.Select(ee => string.Format("{0:X8}", ee.second))) }
+                    from e in new[] { string.Join(", ", es.Select(ee => $"{ee.second:X8}")) }
                     orderby instr.addr
-                    select string.Format(
-                        "{0:X8} {1} {2} {3}",
-                            instr.addr,
-                            instr.size,
-                            (char)(instr.type + 'A'),
-                            e)));
+                    select $"{instr.addr:X8} {instr.size} {(char)(instr.type + 'A')} {e}"));
         }
 
         private void DumpBlocks(ScanResults sr, Dictionary<Address, block> blocks)
@@ -537,7 +532,7 @@ public void DumpBlocks(ScanResults sr, Dictionary<Address, block> blocks, Action
                     on b.id equals i.block_id
                join l in sr.FlatInstructions.Values on b.id equals l.addr
                join e in sr.FlatEdges on b.id equals e.first into es
-               from e in new[] { string.Join(", ", es.Select(ee => string.Format("{0:X8}", ee.second))) }
+               from e in new[] { string.Join(", ", es.Select(ee => $"{ee.second:X8}")) }
                orderby b.id
                select string.Format(
                    "{0:X8}-{1:X8} ({2}): {3}{4}",
@@ -576,7 +571,7 @@ private void DumpBadBlocks(ScanResults sr, Dictionary<long, block> blocks, IEnum
                      select new { block_id = g.Key, max = g.Max(iii => iii.addr.ToLinear()  + (uint) iii.size) })
                      on b.id equals i.block_id
                 join e in edges on b.id equals e.first into es
-                from e in new[] { string.Join(", ", es.Select(ee => string.Format("{0:X8}", ee.second))) }
+                from e in new[] { string.Join(", ", es.Select(ee => $"{ee.second:X8}")) }
                 orderby b.id
                 select string.Format(
                     "{0:X8}-{1:X8} {2} ({3}): {4}",
diff --git a/src/Decompiler/Scanning/ShingledScanner.cs b/src/Decompiler/Scanning/ShingledScanner.cs
index 6bf3dafc8..2d2a9cb38 100644
--- a/src/Decompiler/Scanning/ShingledScanner.cs
+++ b/src/Decompiler/Scanning/ShingledScanner.cs
@@ -668,7 +668,7 @@ where IsPossibleExecutableCodeDestination(addr.Key, map)
             IDictionary<ImageSegment, byte[]> map)
         {
             if (!program.SegmentMap.TryFindSegment(addr, out ImageSegment seg))
-                throw new InvalidOperationException(string.Format("Address {0} doesn't belong to any segment.", addr));
+                throw new InvalidOperationException($"Address {addr} doesn't belong to any segment.");
             return map[seg][addr - seg.Address] == MaybeCode;
         }
 
diff --git a/src/Decompiler/Scanning/VarargsFormatScanner.cs b/src/Decompiler/Scanning/VarargsFormatScanner.cs
index 848ddb9a4..334969c40 100644
--- a/src/Decompiler/Scanning/VarargsFormatScanner.cs
+++ b/src/Decompiler/Scanning/VarargsFormatScanner.cs
@@ -120,8 +120,7 @@ private Expression GetValue(Expression op)
             }
             else
             {
-                var reg = GetValue(formatParam) as Address;
-                if (reg != null)
+                if (GetValue(formatParam) is Address reg)
                 {
                     var str = ReadCString(reg);
                     if (str != null)
@@ -174,9 +173,7 @@ private bool VarargsParserSet(ProcedureCharacteristics chr)
             var type = svc.GetType(varargsParserTypename);
             if (type == null)
                 throw new TypeLoadException(
-                    string.Format(
-                        "Unable to load {0} varargs parser.",
-                        chr.VarargsParserClass));
+                    $"Unable to load {chr.VarargsParserClass} varargs parser.");
             var varargsParser = (IVarargsFormatParser)Activator.CreateInstance(
                 type,
                 program,
diff --git a/src/Decompiler/Scanning/VectorBuilder.cs b/src/Decompiler/Scanning/VectorBuilder.cs
index 69b31e10a..e4e6d82e8 100644
--- a/src/Decompiler/Scanning/VectorBuilder.cs
+++ b/src/Decompiler/Scanning/VectorBuilder.cs
@@ -255,7 +255,7 @@ public bool IsStackRegister(Storage stg)
 
         private List<Address> PostError(string err, Address addrInstr, Address addrTable)
         {
-            Debug.WriteLine(string.Format("Instruction at {0}, table at {1}: {2}", addrInstr, addrTable, err));
+            Debug.WriteLine($"Instruction at {addrInstr}, table at {addrTable}: {err}");
             return new List<Address>();
         }
 
diff --git a/src/Decompiler/Structure/StructureAnalysis.cs b/src/Decompiler/Structure/StructureAnalysis.cs
index 0706271a5..067fcda59 100644
--- a/src/Decompiler/Structure/StructureAnalysis.cs
+++ b/src/Decompiler/Structure/StructureAnalysis.cs
@@ -554,8 +554,8 @@ private Region FindIrregularSwitchFollowRegion(Region n)
             int incoming(Region r)
             {
                 return regionGraph.Predecessors(r)
-                    .Where(p => caseNodes!.Contains(p))
-                    .Count();
+                    .Count(p => caseNodes!.Contains(p))
+;
             }
             var candidates = caseNodes.SelectMany(c => regionGraph.Successors(c))
                 .Where(c => !caseNodes.Contains(c))
@@ -934,10 +934,7 @@ public void VirtualizeEdge(VirtualEdge vEdge)
                 else
                     eventListener.Error(
                         eventListener.CreateProcedureNavigator(program, proc),
-                        string.Format(
-                            "Removing edge ({0}, {1}) caused loss of some code blocks",
-                            vEdge.From.Block.DisplayName,
-                            vEdge.To.Block.DisplayName));
+                        $"Removing edge ({vEdge.From.Block.DisplayName}, {vEdge.To.Block.DisplayName}) caused loss of some code blocks");
 
                 Probe();
             }
@@ -975,7 +972,7 @@ public void CollapseToTailRegion(Region from, Region to, AbsynStatement stm)
                 break;
             default:
                 DumpGraph();
-                throw new NotImplementedException(string.Format("Can't collapse {0} ({1}) => {2}) in procedure {3}", from.Block.DisplayName, from.Type, to.Block.DisplayName, proc.Name));
+                throw new NotImplementedException($"Can't collapse {from.Block.DisplayName} ({from.Type}) => {to.Block.DisplayName}) in procedure {proc.Name}");
             }
         }
 
@@ -1274,8 +1271,8 @@ private int CountIncomingEdges(Region n, ISet<Region> loopNodes)
         {
             return
                 regionGraph.Predecessors(n)
-                    .Where(p => !loopNodes.Contains(p))
-                    .Count();
+                    .Count(p => !loopNodes.Contains(p))
+;
         }
 
         private (Region? follow, Region? latch) DetermineFollowLatch(Region head, ISet<Region> loopNodes)
@@ -1379,7 +1376,7 @@ public enum LoopType
 
         private bool HasExitEdgeFrom(Region n, Region follow)
         {
-            return regionGraph.Successors(n).Where(s => (s == follow)).Any();
+            return regionGraph.Successors(n).Any(s => (s == follow));
         }
 
         private LoopType DetermineLoopType(Region header, Region latch, Region follow)
diff --git a/src/Decompiler/Typing/ArrayExpressionMatcher.cs b/src/Decompiler/Typing/ArrayExpressionMatcher.cs
index d7514b0c9..08dccf007 100644
--- a/src/Decompiler/Typing/ArrayExpressionMatcher.cs
+++ b/src/Decompiler/Typing/ArrayExpressionMatcher.cs
@@ -110,8 +110,7 @@ public bool Match(Expression e)
                     if (bInner2.Operator == Operator.IAdd)
                     {
                         // (+ x (+ a b)) 
-                        var bbInner = bInner2.Left as BinaryExpression;
-                        if (bbInner != null && MatchMul(bbInner))
+                        if (bInner2.Left is BinaryExpression bbInner && MatchMul(bbInner))
                         {
                             // (+ x (+ (* i c) y)) rearranges to become
                             // (+ (* i c) (+ x y))
diff --git a/src/Decompiler/Typing/ConstantPointerAnalysis.cs b/src/Decompiler/Typing/ConstantPointerAnalysis.cs
index 46546a9fd..70f557498 100644
--- a/src/Decompiler/Typing/ConstantPointerAnalysis.cs
+++ b/src/Decompiler/Typing/ConstantPointerAnalysis.cs
@@ -87,7 +87,7 @@ public void FollowConstantPointers()
             {
                 throw new NotImplementedException();
             }
-            throw new NotImplementedException(string.Format("Don't know how to handle pointers to {0}.", fieldType));
+            throw new NotImplementedException($"Don't know how to handle pointers to {fieldType}.");
 		}
 
 		public Identifier Globals
diff --git a/src/Decompiler/Typing/ExpressionTypeDescender.cs b/src/Decompiler/Typing/ExpressionTypeDescender.cs
index 57cc59c6f..f1a81f617 100644
--- a/src/Decompiler/Typing/ExpressionTypeDescender.cs
+++ b/src/Decompiler/Typing/ExpressionTypeDescender.cs
@@ -117,8 +117,7 @@ private void BindActualTypesToFormalTypes(Application appl)
             var parameters = sig.Parameters!;
             if (!sig.IsVariadic && appl.Arguments.Length != parameters.Length)
                 throw new InvalidOperationException(
-                    string.Format("Call to {0} had {1} arguments instead of the expected {2}.",
-                    appl.Procedure, appl.Arguments.Length, parameters.Length));
+                    $"Call to {appl.Procedure} had {appl.Arguments.Length} arguments instead of the expected {parameters.Length}.");
             for (int i = 0; i < appl.Arguments.Length; ++i)
             {
                 if (!sig.IsVariadic || i < parameters.Length)
@@ -419,13 +418,13 @@ private DataType PushSubtrahendDataType(DataType dtDiff, DataType dtMin)
             {
                 if (dtMin is Pointer || ptMin != null && ptMin.Domain == Domain.Pointer)
                     return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
-                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
+                throw new TypeInferenceException($"Not handling {dtDiff} and {dtMin} yet");
             }
             if (dtDiff is MemberPointer || ptDiff != null && ptDiff.Domain == Domain.Offset)
             {
                 if (dtMin is MemberPointer || ptMin != null && ptMin.Domain == Domain.Offset)
                     return PrimitiveType.Create(Domain.Integer, dtDiff.BitSize);
-                throw new TypeInferenceException(string.Format("Not handling {0} and {1} yet", dtDiff, dtMin));
+                throw new TypeInferenceException($"Not handling {dtDiff} and {dtMin} yet");
             }
             return dtMin;
         }
@@ -798,7 +797,7 @@ public bool VisitMkSequence(MkSequence seq, TypeVariable tv)
 
         private bool NYI(Expression e, TypeVariable tv)
         {
-            throw new NotImplementedException(string.Format("Haven't implemented pushing {0} ({1}) into {2} yet.", tv, tv.DataType, e));
+            throw new NotImplementedException($"Haven't implemented pushing {tv} ({tv.DataType}) into {e} yet.");
         }
 
         public bool VisitOutArgument(OutArgument outArgument, TypeVariable tv)
diff --git a/src/Decompiler/Typing/TraitCollector.cs b/src/Decompiler/Typing/TraitCollector.cs
index 9dca36bac..571100ac5 100644
--- a/src/Decompiler/Typing/TraitCollector.cs
+++ b/src/Decompiler/Typing/TraitCollector.cs
@@ -84,8 +84,7 @@ private void BindActualTypesToFormalTypes(Application appl)
             FunctionType sig = pc.Procedure.Signature;
             if (appl.Arguments.Length != sig.Parameters!.Length)
                 throw new InvalidOperationException(
-                    string.Format("Call to {0} had {1} arguments instead of the expected {2}.",
-                    pc.Procedure.Name, appl.Arguments.Length, sig.Parameters.Length));
+                    $"Call to {pc.Procedure.Name} had {appl.Arguments.Length} arguments instead of the expected {sig.Parameters.Length}.");
             for (int i = 0; i < appl.Arguments.Length; ++i)
             {
                 handler.EqualTrait(appl.Arguments[i], sig.Parameters[i]);
@@ -115,7 +114,7 @@ public void CollectProgramTraits(Program program)
                 AddProcedureTraits(p);
                 foreach (Statement stm in p.Statements)
                 {
-                    Debug.WriteLineIf(trace.TraceVerbose, string.Format("Tracing: {0} ", stm.Instruction));
+                    Debug.WriteLineIf(trace.TraceVerbose, $"Tracing: {stm.Instruction} ");
                     stm.Instruction.Accept(this);
                 }
             }
@@ -575,7 +574,7 @@ public DataType VisitPointerAddition(PointerAddition pa)
 		{
 			FunctionType sig = pc.Procedure.Signature;
 			DataType []? argTypes = null;
-			if (sig != null && sig.Parameters != null)
+			if (sig?.Parameters != null)
 			{
 				argTypes = new DataType[sig.Parameters.Length];
 				for (int i = 0; i < argTypes.Length; ++i)
@@ -644,7 +643,7 @@ public DataType VisitUnaryExpression(UnaryExpression unary)
                 return handler.DataTypeTrait(unary, PrimitiveType.Bool);
 			}
 			else
-				throw new NotImplementedException(string.Format("TraitCollection.UnaryExpression: {0}", unary));
+				throw new NotImplementedException($"TraitCollection.UnaryExpression: {unary}");
 		}
 
 		#endregion 
diff --git a/src/Decompiler/Typing/TypeTransformer.cs b/src/Decompiler/Typing/TypeTransformer.cs
index 1f2f2629b..426c628be 100644
--- a/src/Decompiler/Typing/TypeTransformer.cs
+++ b/src/Decompiler/Typing/TypeTransformer.cs
@@ -232,7 +232,7 @@ public void Transform()
                 if (iteration > 50)
                 {
                     eventListener.Warn(
-                        string.Format("Type transformer has looped {0} times, quitting prematurely.", iteration));
+                        $"Type transformer has looped {iteration} times, quitting prematurely.");
                     return;
                 }
 				Changed = false;
diff --git a/src/Drivers/CmdLine/CmdLineDriver.cs b/src/Drivers/CmdLine/CmdLineDriver.cs
index 44f29f2aa..04625486e 100644
--- a/src/Drivers/CmdLine/CmdLineDriver.cs
+++ b/src/Drivers/CmdLine/CmdLineDriver.cs
@@ -237,7 +237,7 @@ private void DecompileRawImage(Dictionary<string, object> pArgs)
             {
                 var arch = config.GetArchitecture((string) pArgs["--arch"]);
                 if (arch == null)
-                    throw new ApplicationException(string.Format("Unknown architecture {0}", pArgs["--arch"]));
+                    throw new ApplicationException($"Unknown architecture {pArgs["--arch"]}");
                 if (pArgs.TryGetValue("--arch-options", out var oArchOptions))
                 {
                     var archOptions = (Dictionary<string, object>) oArchOptions;
@@ -246,7 +246,7 @@ private void DecompileRawImage(Dictionary<string, object> pArgs)
                 pArgs.TryGetValue("--env", out object sEnv);
 
                 if (!arch.TryParseAddress((string) pArgs["--base"], out Address addrBase))
-                    throw new ApplicationException(string.Format("'{0}' doesn't appear to be a valid address.", pArgs["--base"]));
+                    throw new ApplicationException($"'{pArgs["--base"]}' doesn't appear to be a valid address.");
                 pArgs.TryGetValue("--entry", out object oAddrEntry);
 
                 pArgs.TryGetValue("--loader", out object sLoader);
diff --git a/src/Environments/AmigaOS.Design/AmigaOSPropertiesInteractor.cs b/src/Environments/AmigaOS.Design/AmigaOSPropertiesInteractor.cs
index c258870df..55bec67de 100644
--- a/src/Environments/AmigaOS.Design/AmigaOSPropertiesInteractor.cs
+++ b/src/Environments/AmigaOS.Design/AmigaOSPropertiesInteractor.cs
@@ -56,7 +56,7 @@ public object CreateControl()
                 this.Control.KickstartVersionList.DataSource =
                     mapKickstartToListOfLibraries
                     .Select(kv => new ListOption(
-                        string.Format("Kickstart {0}", kv.Key),
+                        $"Kickstart {kv.Key}",
                         kv.Value))
                     .ToList();
                 this.Control.KickstartVersionList.SelectedIndex = 0;
diff --git a/src/Environments/AmigaOS/AmigaOSPlatform.cs b/src/Environments/AmigaOS/AmigaOSPlatform.cs
index f92919251..33fd72a2b 100644
--- a/src/Environments/AmigaOS/AmigaOSPlatform.cs
+++ b/src/Environments/AmigaOS/AmigaOSPlatform.cs
@@ -232,7 +232,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/AmigaOS/FuncsFileParser.cs b/src/Environments/AmigaOS/FuncsFileParser.cs
index 379643c19..566f9e7d3 100644
--- a/src/Environments/AmigaOS/FuncsFileParser.cs
+++ b/src/Environments/AmigaOS/FuncsFileParser.cs
@@ -134,8 +134,7 @@ private bool PeekAndDiscard(TokenType type)
         {
             var tok = lex.GetToken();
             if (tok.Type != type)
-                throw new InvalidOperationException(string.Format(
-                    "Expected {0} but read {1} ({2}).", type, tok.Type, tok.Value));
+                throw new InvalidOperationException($"Expected {type} but read {tok.Type} ({tok.Value}).");
             return tok.Value;
         }
         
diff --git a/src/Environments/C64/C64BasicRewriter.cs b/src/Environments/C64/C64BasicRewriter.cs
index 57b013128..cc2c3be65 100644
--- a/src/Environments/C64/C64BasicRewriter.cs
+++ b/src/Environments/C64/C64BasicRewriter.cs
@@ -177,10 +177,7 @@ private void ParseStatement()
                     RewriteLet();
                     break;
                 }
-                throw new NotImplementedException(string.Format(
-                    "Unimplemented BASIC token {0:X2} [{1}].",
-                    (int)line[i - 1],
-                    C64BasicInstruction.TokenToString(b)));
+                throw new NotImplementedException($"Unimplemented BASIC token {(int)line[i - 1]:X2} [{C64BasicInstruction.TokenToString(b)}].");
             }
         }
 
@@ -188,7 +185,7 @@ private void Expect(byte tok)
         {
             if (!EatSpaces() ||
                 line[i] != tok)
-                throw new InvalidOperationException(string.Format("Expected token {0}.", (Token)tok));
+                throw new InvalidOperationException($"Expected token {(Token)tok}.");
             ++i;
         }
 
diff --git a/src/Environments/C64/C64Platform.cs b/src/Environments/C64/C64Platform.cs
index 3c6ceccb4..9b9d09468 100644
--- a/src/Environments/C64/C64Platform.cs
+++ b/src/Environments/C64/C64Platform.cs
@@ -93,7 +93,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Cpm/CpmPlatform.cs b/src/Environments/Cpm/CpmPlatform.cs
index 5c4d5938e..fd09fafc7 100644
--- a/src/Environments/Cpm/CpmPlatform.cs
+++ b/src/Environments/Cpm/CpmPlatform.cs
@@ -89,7 +89,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/MacOS/Classic/ConstantEvaluator.cs b/src/Environments/MacOS/Classic/ConstantEvaluator.cs
index d27465dd8..286c90c55 100644
--- a/src/Environments/MacOS/Classic/ConstantEvaluator.cs
+++ b/src/Environments/MacOS/Classic/ConstantEvaluator.cs
@@ -99,7 +99,7 @@ public Constant VisitIdentifier(Id id)
                 }
                 else
                 {
-                    throw new InvalidOperationException(string.Format("Undefined constant '{0}'.", id.Name));
+                    throw new InvalidOperationException($"Undefined constant '{id.Name}'.");
                 }
             }
             else
@@ -107,7 +107,7 @@ public Constant VisitIdentifier(Id id)
                 if (c.IsValid)
                     return c;
                 else
-                    throw new InvalidOperationException(string.Format("Recursive constant definition of {0}.", id.Name));
+                    throw new InvalidOperationException($"Recursive constant definition of {id.Name}.");
             }
             throw new NotImplementedException();
         }
diff --git a/src/Environments/MacOS/Classic/InlineCodeInterpreter.cs b/src/Environments/MacOS/Classic/InlineCodeInterpreter.cs
index 542334699..3cd9ced0a 100644
--- a/src/Environments/MacOS/Classic/InlineCodeInterpreter.cs
+++ b/src/Environments/MacOS/Classic/InlineCodeInterpreter.cs
@@ -113,7 +113,7 @@ public InlineCodeInterpreter(IDictionary<string, Constant> constants)
                     ++iOpcode;
                     break;
                 }
-                throw new NotImplementedException(string.Format("uInstr: {0:X4}", uInstr));
+                throw new NotImplementedException($"uInstr: {uInstr:X4}");
             }
             if (iOpcode < uOpcodes.Length)
             {
@@ -129,7 +129,7 @@ public InlineCodeInterpreter(IDictionary<string, Constant> constants)
                         ssig.ReturnValue.Kind = new Register_v1 { Name = reg.Name };
                         continue;
                     }
-                    throw new NotImplementedException(string.Format("uInstr: {0:X4}", uInstr));
+                    throw new NotImplementedException($"uInstr: {uInstr:X4}");
                 }
             }
             if (vector == 0)
diff --git a/src/Environments/MacOS/Classic/MacOSClassic.cs b/src/Environments/MacOS/Classic/MacOSClassic.cs
index e66f49f39..4fa2b5cdb 100644
--- a/src/Environments/MacOS/Classic/MacOSClassic.cs
+++ b/src/Environments/MacOS/Classic/MacOSClassic.cs
@@ -117,7 +117,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/MacOS/Classic/ResourceFork.cs b/src/Environments/MacOS/Classic/ResourceFork.cs
index 7dde4d760..37adacad9 100644
--- a/src/Environments/MacOS/Classic/ResourceFork.cs
+++ b/src/Environments/MacOS/Classic/ResourceFork.cs
@@ -273,12 +273,12 @@ public void Dump()
         {
             foreach (ResourceType type in ResourceTypes)
             {
-                Debug.WriteLine(string.Format("Resource type {0}", type.Name));
+                Debug.WriteLine($"Resource type {type.Name}");
                 foreach (ResourceReference rsrc in type.References)
                 {
-                    Debug.WriteLine(string.Format("   Resource ID: {0:X4}", rsrc.ResourceID));
-                    Debug.WriteLine(string.Format("   Name: {0}", rsrc.Name));
-                    Debug.WriteLine(string.Format("   Offset: {0:X8}", rsrc.DataOffset));
+                    Debug.WriteLine($"   Resource ID: {rsrc.ResourceID:X4}");
+                    Debug.WriteLine($"   Name: {rsrc.Name}");
+                    Debug.WriteLine($"   Offset: {rsrc.DataOffset:X8}");
                     Debug.WriteLine("    ====");
                 }
             }
diff --git a/src/Environments/Msdos/Msdos386Platform.cs b/src/Environments/Msdos/Msdos386Platform.cs
index 9de72714a..8584c05b1 100644
--- a/src/Environments/Msdos/Msdos386Platform.cs
+++ b/src/Environments/Msdos/Msdos386Platform.cs
@@ -108,7 +108,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Msdos/MsdosPlatform.cs b/src/Environments/Msdos/MsdosPlatform.cs
index 89ab92f64..df3ba5db4 100644
--- a/src/Environments/Msdos/MsdosPlatform.cs
+++ b/src/Environments/Msdos/MsdosPlatform.cs
@@ -152,7 +152,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Msdos/StartupFinder.cs b/src/Environments/Msdos/StartupFinder.cs
index 92c30e8f8..c446e5e34 100644
--- a/src/Environments/Msdos/StartupFinder.cs
+++ b/src/Environments/Msdos/StartupFinder.cs
@@ -257,10 +257,7 @@ public StartupFinder(IServiceProvider services, Program program, Address addrSta
             }
 
             gotVendor:
-            var sSigName = string.Format("dcc{0}{1}{2}.sig",
-                   chVendor, /* Add vendor */
-                   chVersion, /* Add version */
-                   chModel); /* Add model */
+            var sSigName = $"dcc{chVendor}{chVersion}{chModel}.sig"; /* Add model */
             Debug.Print("Signature file: {0}", sSigName);
             return ImageSymbol.Procedure(arch, addrEntry, "main", state: this.state);
         }
diff --git a/src/Environments/OS2/OS2Platform16.cs b/src/Environments/OS2/OS2Platform16.cs
index 46b2cecd5..d18a31053 100644
--- a/src/Environments/OS2/OS2Platform16.cs
+++ b/src/Environments/OS2/OS2Platform16.cs
@@ -112,7 +112,7 @@ public override CallingConvention GetCallingConvention(string? ccName)
             case "__pascal":
                 return new X86CallingConvention(4, 2, 4, false, true);
             }
-            throw new NotSupportedException(string.Format("Calling convention '{0}' is not supported.", ccName));
+            throw new NotSupportedException($"Calling convention '{ccName}' is not supported.");
         }
 
         public override ExternalProcedure? LookupProcedureByOrdinal(string? moduleName, int ordinal)
diff --git a/src/Environments/Ps3/Ps3Platform.cs b/src/Environments/Ps3/Ps3Platform.cs
index 1c13320f7..6223e66c2 100644
--- a/src/Environments/Ps3/Ps3Platform.cs
+++ b/src/Environments/Ps3/Ps3Platform.cs
@@ -98,7 +98,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/RiscOS/RiscOSPlatform.cs b/src/Environments/RiscOS/RiscOSPlatform.cs
index 8fed5006c..f9c020756 100644
--- a/src/Environments/RiscOS/RiscOSPlatform.cs
+++ b/src/Environments/RiscOS/RiscOSPlatform.cs
@@ -103,7 +103,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Snes/SnesParser.cs b/src/Environments/Snes/SnesParser.cs
index f51d242d1..2a304b518 100644
--- a/src/Environments/Snes/SnesParser.cs
+++ b/src/Environments/Snes/SnesParser.cs
@@ -215,8 +215,8 @@ public override Program Load(Address? addrLoad)
                 //           in the ROM. If the size of the ROM is not a power of 2, then some
                 //           bytes may enter the sum multiple times through mirroring. The
                 //           checksum complement is the bitwise-xor of the checksum with 0xFFFF.
-                props["checksum"] = String.Format("{0:X4}", data[header + 46] + (data[header + 47] << 8));
-                props["checksum_complement"] = String.Format("{0:X4}", data[header + 44] + (data[header + 45] << 8));
+                props["checksum"] = $"{data[header + 46] + (data[header + 47] << 8):X4}";
+                props["checksum_complement"] = $"{data[header + 44] + (data[header + 45] << 8):X4}";
 
                 var arch = new Mos65816Architecture(Services, "m65816", new Dictionary<string, object>());
                 return new Program
@@ -681,7 +681,7 @@ public virtual string getCartridgeType(byte[] data, int header, bool bs)
                 }
                 if (!string.IsNullOrEmpty(chip))
                 {
-                    kart = String.Format("{0}+{1}", contents[(romType & 15) % 3], chip);
+                    kart = $"{contents[(romType & 15) % 3]}+{chip}";
                 }
                 else
                 {
diff --git a/src/Environments/SysV/ArchSpecific/ArchSpecificFactory.cs b/src/Environments/SysV/ArchSpecific/ArchSpecificFactory.cs
index 6ee67449e..9c0e6cb0f 100644
--- a/src/Environments/SysV/ArchSpecific/ArchSpecificFactory.cs
+++ b/src/Environments/SysV/ArchSpecific/ArchSpecificFactory.cs
@@ -129,7 +129,7 @@ public CallingConvention CreateCallingConverion(IProcessorArchitecture arch)
             case "ia64":
                 return new Ia64CallingConvention(arch);
             default:
-                throw new NotImplementedException(string.Format("ELF calling convention for {0} not implemented yet.", arch.Description));
+                throw new NotImplementedException($"ELF calling convention for {arch.Description} not implemented yet.");
             }
         }
     }
diff --git a/src/Environments/SysV/ArchSpecific/ArmCallingConvention.cs b/src/Environments/SysV/ArchSpecific/ArmCallingConvention.cs
index 0ed409ef1..d8f02ae95 100644
--- a/src/Environments/SysV/ArchSpecific/ArmCallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/ArmCallingConvention.cs
@@ -96,7 +96,7 @@ public void SetReturnRegister(ICallingConventionEmitter ccr, int bitSize)
                 ccr.SequenceReturn(argRegs[1], argRegs[0]);
             }
             else
-                throw new NotSupportedException(string.Format("Return values of {0} bits are not supported.", bitSize));
+                throw new NotSupportedException($"Return values of {bitSize} bits are not supported.");
         }
 
         public bool IsArgument(Storage stg)
diff --git a/src/Environments/SysV/ArchSpecific/MipsCallingConvention.cs b/src/Environments/SysV/ArchSpecific/MipsCallingConvention.cs
index e6035d380..ba5d35814 100644
--- a/src/Environments/SysV/ArchSpecific/MipsCallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/MipsCallingConvention.cs
@@ -68,8 +68,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             for (int i = 0; i < dtParams.Count; ++i)
             {
                 var dtParam = dtParams[i];
-                var prim = dtParam as PrimitiveType;
-                if (prim != null && prim.Domain == Domain.Real && !firstArgIntegral)
+                if (dtParam is PrimitiveType prim && prim.Domain == Domain.Real && !firstArgIntegral)
                 {
                     if ((ir % 2) != 0)
                         ++ir;
@@ -91,7 +90,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
                         }
                         else
                         {
-                            throw new NotSupportedException(string.Format("Real type of size {0} not supported.", prim.Size));
+                            throw new NotSupportedException($"Real type of size {prim.Size} not supported.");
                         }
                     }
                 }
@@ -134,8 +133,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dt)
         {
             int bitSize = dt.BitSize;
-            var prim = dt as PrimitiveType;
-            if (prim != null && prim.Domain == Domain.Real)
+
+            if (dt is PrimitiveType prim && prim.Domain == Domain.Real)
             {
                 ccr.RegReturn(fret);
             }
diff --git a/src/Environments/SysV/ArchSpecific/PowerPcCallingConvention.cs b/src/Environments/SysV/ArchSpecific/PowerPcCallingConvention.cs
index 93af2b31f..0890ef5b6 100644
--- a/src/Environments/SysV/ArchSpecific/PowerPcCallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/PowerPcCallingConvention.cs
@@ -60,8 +60,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             for (int i = 0; i < dtParams.Count; ++i)
             {
                 var dtArg = dtParams[i];
-                var prim = dtArg as PrimitiveType;
-                if (prim != null && prim.Domain == Domain.Real)
+
+                if (dtArg is PrimitiveType prim && prim.Domain == Domain.Real)
                 {
                     if (fr > 8)
                     {
@@ -106,8 +106,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
 
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dt)
         {
-            var prim = dt as PrimitiveType;
-            if (prim != null && prim.Domain == Domain.Real)
+            if (dt is PrimitiveType prim && prim.Domain == Domain.Real)
             {
                 ccr.RegReturn(fregs[0]);
             }
diff --git a/src/Environments/SysV/ArchSpecific/SparcCallingConvention.cs b/src/Environments/SysV/ArchSpecific/SparcCallingConvention.cs
index 527380694..449a056f0 100644
--- a/src/Environments/SysV/ArchSpecific/SparcCallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/SparcCallingConvention.cs
@@ -80,8 +80,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
 
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dtArg)
         {
-            var ptArg = dtArg as PrimitiveType;
-            if (ptArg != null)
+            if (dtArg is PrimitiveType ptArg)
             {
                 if (ptArg.Domain == Domain.Real)
                 {
diff --git a/src/Environments/SysV/ArchSpecific/SuperHCallingConvention.cs b/src/Environments/SysV/ArchSpecific/SuperHCallingConvention.cs
index 70d5c1a7e..dadc30c5d 100644
--- a/src/Environments/SysV/ArchSpecific/SuperHCallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/SuperHCallingConvention.cs
@@ -98,8 +98,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             }
             foreach (var dtParam in dtParams)
             {
-                var pt = dtParam as PrimitiveType;
-                if (pt != null && pt.Domain == Domain.Real)
+                if (dtParam is PrimitiveType pt && pt.Domain == Domain.Real)
                 {
                     if (pt.Size == 4)
                     {
diff --git a/src/Environments/SysV/ArchSpecific/X86_64CallingConvention.cs b/src/Environments/SysV/ArchSpecific/X86_64CallingConvention.cs
index f320fd012..93ba43dc1 100644
--- a/src/Environments/SysV/ArchSpecific/X86_64CallingConvention.cs
+++ b/src/Environments/SysV/ArchSpecific/X86_64CallingConvention.cs
@@ -71,8 +71,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             // space for the four registers
             foreach (var dtParam in dtParams)
             {
-                var prim = dtParam as PrimitiveType;
-                if (prim != null && prim.Domain == Domain.Real)
+                if (dtParam is PrimitiveType prim && prim.Domain == Domain.Real)
                 {
                     if (fr >= fregs.Length)
                     {
@@ -112,9 +111,9 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
 
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dtArg)
         {
-            var pt = dtArg as PrimitiveType;
             int bitSize = dtArg.BitSize;
-            if (pt != null && pt.Domain == Domain.Real)
+
+            if (dtArg is PrimitiveType pt && pt.Domain == Domain.Real)
             {
                 var xmm0 = fregs[0];
                 if (bitSize <= 64)
diff --git a/src/Environments/SysV/GccMangledNameParser.cs b/src/Environments/SysV/GccMangledNameParser.cs
index f3792f5bf..92bafd3cc 100644
--- a/src/Environments/SysV/GccMangledNameParser.cs
+++ b/src/Environments/SysV/GccMangledNameParser.cs
@@ -149,11 +149,11 @@ private void AddSubstitution(object n)
             }
             else if (c <= 10)
             {
-                substitutions.Add(string.Format("{0}_", (char)('0' + c - 1)), n);
+                substitutions.Add($"{(char)('0' + c - 1)}_", n);
             }
             else if (c <= 36)
             {
-                substitutions.Add(string.Format("{0}_", (char)('A' + c - 11)), n);
+                substitutions.Add($"{(char)('A' + c - 11)}_", n);
             }
             else
             {
@@ -390,7 +390,7 @@ private SerializedType Type()
                     AddSubstitution(tref);
                     return Qualify(tref, qual);
                 }
-                throw new NotImplementedException(string.Format("Unknown GCC type code '{0}' ({1}).", str[i], str.Substring(i)));
+                throw new NotImplementedException($"Unknown GCC type code '{str[i]}' ({str.Substring(i)}).");
             }
         }
 
diff --git a/src/Environments/SysV/SysVPlatform.cs b/src/Environments/SysV/SysVPlatform.cs
index 3e862ad1d..14dcbddc1 100644
--- a/src/Environments/SysV/SysVPlatform.cs
+++ b/src/Environments/SysV/SysVPlatform.cs
@@ -87,7 +87,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
@@ -170,8 +170,8 @@ private RegisterStorage[] LoadTrashedRegisters()
                 return null;
             var proc = new ExternalProcedure(procName, sig);
             var characteristics = CharacteristicsLibs.Select(cl => cl.Lookup(procName))
-                .Where(c => c != null)
-                .FirstOrDefault();
+                .FirstOrDefault(c => c != null)
+;
             if (characteristics != null)
                 proc.Characteristics = characteristics;
             return proc;
diff --git a/src/Environments/Trs80/Trs80Platform.cs b/src/Environments/Trs80/Trs80Platform.cs
index 6ac33e794..d758d48c7 100644
--- a/src/Environments/Trs80/Trs80Platform.cs
+++ b/src/Environments/Trs80/Trs80Platform.cs
@@ -82,7 +82,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Arch/MipsCallingConvention.cs b/src/Environments/Windows/Arch/MipsCallingConvention.cs
index c55cbaf51..1aa60ab53 100644
--- a/src/Environments/Windows/Arch/MipsCallingConvention.cs
+++ b/src/Environments/Windows/Arch/MipsCallingConvention.cs
@@ -91,8 +91,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             for (int iArg = 0; iArg < dtParams.Count; ++iArg)
             {
                 var dtArg = dtParams[iArg];
-                var prim = dtArg as PrimitiveType;
-                if (prim != null && prim.Domain == Domain.Real)
+
+                if (dtArg is PrimitiveType prim && prim.Domain == Domain.Real)
                 {
                     if (fr >= fregs.Length)
                     {
@@ -139,8 +139,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
         public void SetReturnRegister(ICallingConventionEmitter ccr, DataType dtArg)
         {
             int bitSize = dtArg.BitSize;
-            var pt = dtArg as PrimitiveType;
-            if (pt != null && pt.Domain == Domain.Real)
+
+            if (dtArg is PrimitiveType pt && pt.Domain == Domain.Real)
             {
                 if (bitSize > 64)
                     throw new NotImplementedException();
diff --git a/src/Environments/Windows/Arch/X86_64CallingConvention.cs b/src/Environments/Windows/Arch/X86_64CallingConvention.cs
index dd4965254..c02d2853f 100644
--- a/src/Environments/Windows/Arch/X86_64CallingConvention.cs
+++ b/src/Environments/Windows/Arch/X86_64CallingConvention.cs
@@ -57,8 +57,8 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
             {
                 if (dtRet.Size > 8)
                     throw new NotImplementedException();
-                var pt = dtRet as PrimitiveType;
-                if (pt != null && pt.Domain == Domain.Real)
+
+                if (dtRet is PrimitiveType pt && pt.Domain == Domain.Real)
                 {
                     ccr.RegReturn(Registers.xmm0);
                 }
@@ -84,8 +84,7 @@ public void Generate(ICallingConventionEmitter ccr, DataType? dtRet, DataType? d
                 var dt = dtParams[i];
                 if (dt.Size > 8)
                     throw new NotImplementedException();
-                var pt = dt as PrimitiveType;
-                if (pt != null && pt.Domain == Domain.Real && i < fRegs.Length)
+                if (dtRet is PrimitiveType pt && pt.Domain == Domain.Real && i < fRegs.Length)
                 {
                     ccr.RegParam(fRegs[i]);
                 }
diff --git a/src/Environments/Windows/BorlandMangledNamedParser.cs b/src/Environments/Windows/BorlandMangledNamedParser.cs
index 74b1cfd5b..4f190bc33 100644
--- a/src/Environments/Windows/BorlandMangledNamedParser.cs
+++ b/src/Environments/Windows/BorlandMangledNamedParser.cs
@@ -248,7 +248,7 @@ public BorlandMangledNamedParser(string fnName)
                     --i;
                     if (char.IsDigit(s[i]))
                         return ParseEnumClassName();
-                    throw new NotImplementedException(string.Format("Unexpected character '{0}'.", s[i]));
+                    throw new NotImplementedException($"Unexpected character '{s[i]}'.");
                 }
             }
             return null;
diff --git a/src/Environments/Windows/ModuleDefinitionLoader.cs b/src/Environments/Windows/ModuleDefinitionLoader.cs
index 20b52bec2..f7a71b23b 100644
--- a/src/Environments/Windows/ModuleDefinitionLoader.cs
+++ b/src/Environments/Windows/ModuleDefinitionLoader.cs
@@ -65,10 +65,7 @@ public override TypeLibrary Load(IPlatform platform, TypeLibrary dstLib)
                 case TokenType.EXPORTS: ParseExports(loader); break;
                 case TokenType.LIBRARY: ParseLibrary(loader); break;
                 default: throw new NotImplementedException(
-                    string.Format("Unknown token {0} ({1}) on line {2}.",
-                    tok.Type,
-                    tok.Text,
-                    tok.LineNumber));
+                    $"Unknown token {tok.Type} ({tok.Text}) on line {tok.LineNumber}.");
                 }
             }
         }
diff --git a/src/Environments/Windows/MsMangledNameParser.cs b/src/Environments/Windows/MsMangledNameParser.cs
index 80dabeab5..d3cf50610 100644
--- a/src/Environments/Windows/MsMangledNameParser.cs
+++ b/src/Environments/Windows/MsMangledNameParser.cs
@@ -279,7 +279,7 @@ public string[] ParseQualification()
 
             case 'Y': sig = ParseGlobalFunction( ""); break;
             case 'Z': sig = ParseGlobalFunction( "far"); break;
-            default: throw new NotImplementedException(string.Format("Character '{0}' not supported", str[i - 1]));
+            default: throw new NotImplementedException($"Character '{str[i - 1]}' not supported");
 
             }
             return (
diff --git a/src/Environments/Windows/SignatureGuesser.cs b/src/Environments/Windows/SignatureGuesser.cs
index 817a21d73..e457c4ffe 100644
--- a/src/Environments/Windows/SignatureGuesser.cs
+++ b/src/Environments/Windows/SignatureGuesser.cs
@@ -89,8 +89,7 @@ public static (string?, SerializedType?, SerializedType?) InferTypeFromName(stri
                 var field = bmnp.Parse();
                 if (field.Item1 != null)
                 {
-                    var sproc = field.Item2 as SerializedSignature;
-                    if (sproc != null)
+                    if (field.Item2 is SerializedSignature sproc)
                     {
                         return new Procedure_v1
                         {
@@ -124,8 +123,8 @@ public static (string?, SerializedType?, SerializedType?) InferTypeFromName(stri
                     Debug.Print("*** Error parsing {0}. {1}", fnName, ex.Message);
                     return null;
                 }
-                var sproc = field.Item2 as SerializedSignature;
-                if (sproc != null)
+
+                if (field.Item2 is SerializedSignature sproc)
                 {
                     return new Procedure_v1 {
                         Name = field.Item1,
diff --git a/src/Environments/Windows/Win16Platform.cs b/src/Environments/Windows/Win16Platform.cs
index 81e37f03d..02c7d8d87 100644
--- a/src/Environments/Windows/Win16Platform.cs
+++ b/src/Environments/Windows/Win16Platform.cs
@@ -103,7 +103,7 @@ public override CallingConvention GetCallingConvention(string? ccName)
             case "stdcall":
                 return new X86CallingConvention(4, 4, 4, false, false);
             }
-            throw new NotSupportedException(string.Format("Calling convention '{0}' is not supported.", ccName));
+            throw new NotSupportedException($"Calling convention '{ccName}' is not supported.");
         }
 
         public override SystemService? FindService(int vector, ProcessorState? state, SegmentMap? segmentMap)
@@ -125,7 +125,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Win32M68kPlatform.cs b/src/Environments/Windows/Win32M68kPlatform.cs
index 9c96ead1a..d761298ec 100644
--- a/src/Environments/Windows/Win32M68kPlatform.cs
+++ b/src/Environments/Windows/Win32M68kPlatform.cs
@@ -69,7 +69,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
 			case CBasicType.Double: return 64;
 			case CBasicType.LongDouble: return 64;
 			case CBasicType.Int64: return 64;
-			default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+			default: throw new NotImplementedException($"C basic type {cb} not supported.");
 			}
 		}
 
diff --git a/src/Environments/Windows/Win32MipsPlatform.cs b/src/Environments/Windows/Win32MipsPlatform.cs
index ff00a1dfd..786b21734 100644
--- a/src/Environments/Windows/Win32MipsPlatform.cs
+++ b/src/Environments/Windows/Win32MipsPlatform.cs
@@ -175,7 +175,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Win32Platform.cs b/src/Environments/Windows/Win32Platform.cs
index 79207d8a0..bfdc2ed88 100644
--- a/src/Environments/Windows/Win32Platform.cs
+++ b/src/Environments/Windows/Win32Platform.cs
@@ -165,7 +165,7 @@ public override CallingConvention GetCallingConvention(string? ccName)
                     Architecture.WordWidth.Size,
                     Architecture.PointerType.Size);
             }
-            throw new ArgumentOutOfRangeException(string.Format("Unknown calling convention '{0}'.", ccName));
+            throw new ArgumentOutOfRangeException($"Unknown calling convention '{ccName}'.");
         }
 
         public override ImageSymbol? FindMainProcedure(Program program, Address addrStart)
@@ -190,7 +190,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
             case CBasicType.WChar_t: return 2;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Win32PpcPlatform.cs b/src/Environments/Windows/Win32PpcPlatform.cs
index 1c1e1f5b8..04333470e 100644
--- a/src/Environments/Windows/Win32PpcPlatform.cs
+++ b/src/Environments/Windows/Win32PpcPlatform.cs
@@ -102,7 +102,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Win32ThumbPlatform.cs b/src/Environments/Windows/Win32ThumbPlatform.cs
index 48f2f78f7..b6d795c1b 100644
--- a/src/Environments/Windows/Win32ThumbPlatform.cs
+++ b/src/Environments/Windows/Win32ThumbPlatform.cs
@@ -173,7 +173,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Windows/Win_x86_64_Platform.cs b/src/Environments/Windows/Win_x86_64_Platform.cs
index a19b89e79..922bd5d80 100644
--- a/src/Environments/Windows/Win_x86_64_Platform.cs
+++ b/src/Environments/Windows/Win_x86_64_Platform.cs
@@ -137,7 +137,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/Xbox/Xbox360Platform.cs b/src/Environments/Xbox/Xbox360Platform.cs
index 94f1618b7..9b5b3a815 100644
--- a/src/Environments/Xbox/Xbox360Platform.cs
+++ b/src/Environments/Xbox/Xbox360Platform.cs
@@ -142,7 +142,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Environments/ZX81/ZX81Environment.cs b/src/Environments/ZX81/ZX81Environment.cs
index f595ac44a..43507582b 100644
--- a/src/Environments/ZX81/ZX81Environment.cs
+++ b/src/Environments/ZX81/ZX81Environment.cs
@@ -91,7 +91,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/Gui/AddressNavigator.cs b/src/Gui/AddressNavigator.cs
index 7f1484cf6..19209069e 100644
--- a/src/Gui/AddressNavigator.cs
+++ b/src/Gui/AddressNavigator.cs
@@ -58,7 +58,7 @@ public void NavigateTo()
 
         public override string ToString()
         {
-            return string.Format("{0}!{1}", Program.Filename, Address);
+            return $"{Program.Filename}!{Address}";
         }
     }
 }
diff --git a/src/Gui/Forms/CallHierarchyInteractor.cs b/src/Gui/Forms/CallHierarchyInteractor.cs
index 6b56110e8..8e5bc711b 100644
--- a/src/Gui/Forms/CallHierarchyInteractor.cs
+++ b/src/Gui/Forms/CallHierarchyInteractor.cs
@@ -215,7 +215,7 @@ public override void Initialize(object obj)
                 base.Initialize(obj);
                 var proc = stm.Block.Procedure;
                 var offset = stm.LinearAddress - proc.EntryAddress.ToLinear();
-                this.TreeNode.Text = string.Format("{0}+{1} {2}", proc, offset, stm.Instruction);
+                this.TreeNode.Text = $"{proc}+{offset} {stm.Instruction}";
             }
 
             public override void OnExpanded()
diff --git a/src/Gui/Forms/MainFormInteractor.cs b/src/Gui/Forms/MainFormInteractor.cs
index ecd7392ac..2489c9a79 100644
--- a/src/Gui/Forms/MainFormInteractor.cs
+++ b/src/Gui/Forms/MainFormInteractor.cs
@@ -358,7 +358,7 @@ public bool OpenBinaryAs(string initialFilename)
                 string sAddr = null;
                 string loader = null;
                 EntryPointDefinition entry = null;
-                if (rawFileOption != null && rawFileOption.Value != null)
+                if (rawFileOption?.Value != null)
                 {
                     var raw = (RawFileDefinition)rawFileOption.Value;
                     loader = raw.Loader;
@@ -374,10 +374,10 @@ public bool OpenBinaryAs(string initialFilename)
                 sAddr = sAddr ?? dlg.AddressTextBox.Text.Trim();
                 arch = config.GetArchitecture(archName);
                 if (arch == null)
-                    throw new InvalidOperationException(string.Format("Unable to load {0} architecture.", archName));
+                    throw new InvalidOperationException($"Unable to load {archName} architecture.");
                 arch.LoadUserOptions(dlg.ArchitectureOptions);
                 if (!arch.TryParseAddress(sAddr, out var addrBase))
-                    throw new ApplicationException(string.Format("'{0}' doesn't appear to be a valid address.", sAddr));
+                    throw new ApplicationException($"'{sAddr}' doesn't appear to be a valid address.");
                 var details = new LoadDetails
                 {
                     LoaderName = loader,
@@ -394,7 +394,7 @@ public bool OpenBinaryAs(string initialFilename)
             {
                 uiSvc.ShowError(
                     ex,
-                    string.Format("An error occurred when opening the binary file {0}.", dlg.FileName.Text));
+                    $"An error occurred when opening the binary file {dlg.FileName.Text}.");
             }
             return true;
         }
@@ -686,7 +686,7 @@ public void ViewCallGraph()
 
             var program = project.Programs[0];
             var cgvSvc = sc.RequireService<ICallGraphViewService>();
-            var title = string.Format("{0} {1}", program.Name, Resources.CallGraphTitle);
+            var title = $"{program.Name} {Resources.CallGraphTitle}";
             cgvSvc.ShowCallgraph(program, title);
         }
 
@@ -884,7 +884,7 @@ private bool QueryMruItem(int cmdId, CommandStatus cmdStatus, CommandText cmdTex
             if (0 <= iMru && iMru < mru.Items.Count)
             {
                 cmdStatus.Status = MenuStatus.Visible | MenuStatus.Enabled;
-                cmdText.Text = string.Format("&{0} {1}", iMru + 1, mru.Items[iMru]);
+                cmdText.Text = $"&{iMru + 1} {mru.Items[iMru]}";
                 return true;
             }
             return false;
diff --git a/src/Gui/Forms/ScannedPageInteractor.cs b/src/Gui/Forms/ScannedPageInteractor.cs
index d1928a47e..aad1f7291 100644
--- a/src/Gui/Forms/ScannedPageInteractor.cs
+++ b/src/Gui/Forms/ScannedPageInteractor.cs
@@ -144,11 +144,11 @@ private void ShowMemoryControlRange(IStatusBarService sbSvc, AddressRange range)
                 return;
             if (range.Begin.ToLinear() == range.End.ToLinear())       //$REFACTOR: make bytespan a method of addressrange.
             {
-                sbSvc.SetText(string.Format("[{0}]", range.Begin));
+                sbSvc.SetText($"[{range.Begin}]");
             }
             else
             {
-                sbSvc.SetText(string.Format("[{0}-{1}]", range.Begin, range.End));
+                sbSvc.SetText($"[{range.Begin}-{range.End}]");
             }
         }
     }
diff --git a/src/Gui/Forms/TextEncodingInteractor.cs b/src/Gui/Forms/TextEncodingInteractor.cs
index 65069fa87..3459134c9 100644
--- a/src/Gui/Forms/TextEncodingInteractor.cs
+++ b/src/Gui/Forms/TextEncodingInteractor.cs
@@ -36,7 +36,7 @@ public void Attach(ITextEncodingDialog dlg)
                 Encoding.GetEncodings()
                 .OrderBy(e => e.DisplayName)
                 .Select(e => new ListOption(
-                    string.Format("{0} - {1}", e.DisplayName, e.Name),
+                    $"{e.DisplayName} - {e.Name}",
                     e.Name)));
         }
 
diff --git a/src/Gui/SearchService.cs b/src/Gui/SearchService.cs
index aee445943..54fbbbad1 100644
--- a/src/Gui/SearchService.cs
+++ b/src/Gui/SearchService.cs
@@ -38,10 +38,7 @@ public class SearchService : IObserver<ICodeLocation>
 
         public void StartSearch(IObservable<ICodeLocation> newSearcher, ISearchResult result)
         {
-            if (subscription != null)
-            {
-                subscription.Dispose();
-            }
+            subscription?.Dispose();
             subscription = newSearcher.Subscribe(this);
         }
 
diff --git a/src/Gui/TreeNodeDesignerHost.cs b/src/Gui/TreeNodeDesignerHost.cs
index 5ef3cddf4..1d8a74005 100644
--- a/src/Gui/TreeNodeDesignerHost.cs
+++ b/src/Gui/TreeNodeDesignerHost.cs
@@ -171,10 +171,7 @@ private ITreeNode CreateTreeNode(object o, TreeNodeDesigner des, TreeNodeDesigne
         private void tree_AfterSelect(object sender, EventArgs e)
         {
             var des = GetSelectedDesigner();
-            if (des != null)
-            {
-                des.DoDefaultAction();
-            }
+            des?.DoDefaultAction();
         }
 
         private void tree_BeforeExpand(object sender, TreeViewEventArgs e)
diff --git a/src/ImageLoaders/BinHex/BinHexDecoder.cs b/src/ImageLoaders/BinHex/BinHexDecoder.cs
index 66890ae47..82da83d19 100644
--- a/src/ImageLoaders/BinHex/BinHexDecoder.cs
+++ b/src/ImageLoaders/BinHex/BinHexDecoder.cs
@@ -164,7 +164,7 @@ private void Expect(char ch)
         {
             int c = input.Read();
             if (c != ch)
-                throw new FormatException(string.Format("Expected '{0}'.", (char) ch));
+                throw new FormatException($"Expected '{(char)ch}'.");
         }
 
         private void FindBinhexHeader()
diff --git a/src/ImageLoaders/BinHex/Cpt/CompactProArchive.cs b/src/ImageLoaders/BinHex/Cpt/CompactProArchive.cs
index 5e13f285a..d9ba682f9 100644
--- a/src/ImageLoaders/BinHex/Cpt/CompactProArchive.cs
+++ b/src/ImageLoaders/BinHex/Cpt/CompactProArchive.cs
@@ -87,18 +87,18 @@ public List<ArchiveDirectoryEntry> Load(Stream infp)
                     cptindex[cptptr + F_FOLDER] = 0;
                 }
                 if (infp.Read(cptindex, cptptr + 1, cptindex[cptptr]) != cptindex[cptptr])
-                    throw new ApplicationException(string.Format("Can't read file header #{0}.", i + 1));
+                    throw new ApplicationException($"Can't read file header #{i + 1}.");
                 cpt_crc = updcrc(cpt_crc, cptindex, cptptr + 1, cptindex[cptptr]);
                 if (cptindex[cptptr + F_FOLDER] != 0)
                 {
                     if (infp.Read(cptindex, cptptr + F_FOLDERSIZE, 2) != 2)
-                        throw new ApplicationException(string.Format("Can't read file header #{0}.", i + 1));
+                        throw new ApplicationException($"Can't read file header #{i + 1}.");
                     cpt_crc = updcrc(cpt_crc, cptindex, cptptr + F_FOLDERSIZE, 2);
                 }
                 else
                 {
                     if (infp.Read(cptindex, cptptr + F_VOLUME, FILEHDRSIZE - F_VOLUME) != FILEHDRSIZE - F_VOLUME)
-                        throw new ApplicationException(string.Format("Can't read file header #{0}.", i + 1));
+                        throw new ApplicationException($"Can't read file header #{i + 1}.");
                     cpt_crc = updcrc(cpt_crc, cptindex, cptptr + F_VOLUME,
                             FILEHDRSIZE - F_VOLUME);
                 }
@@ -117,7 +117,7 @@ public List<ArchiveDirectoryEntry> Load(Stream infp)
             {
                 if (cpt_filehdr(out filehdr, cptindex, cptptr) == -1)
                 {
-                    throw new ApplicationException(string.Format("Can't read file header #{0}", i + 1));
+                    throw new ApplicationException($"Can't read file header #{i + 1}");
                 }
                 if (filehdr.folder != 0)
                 {
@@ -277,7 +277,7 @@ private MacFolderEntry cpt_folder(string name, FileHdr fileh, byte[] cptindex, i
             {
                 if (cpt_filehdr(out filehdr, cptindex, cptptr) == -1)
                 {
-                    throw new ApplicationException(string.Format("Can't read file header #{0}", i + 1));
+                    throw new ApplicationException($"Can't read file header #{i + 1}");
                 }
                 if (filehdr.folder != 0)
                 {
diff --git a/src/ImageLoaders/BinHex/Cpt/CptCompressor.cs b/src/ImageLoaders/BinHex/Cpt/CptCompressor.cs
index 05e9cc3d4..961f0155f 100644
--- a/src/ImageLoaders/BinHex/Cpt/CptCompressor.cs
+++ b/src/ImageLoaders/BinHex/Cpt/CptCompressor.cs
@@ -293,7 +293,7 @@ private void cpt_readHuff(int size, HuffNode[] Hufftree)
             // next paraphrased from ReadLengths with adaption for Compactor. 
             int treeBytes = cpt_data[cpt_char++];
             if (size < treeBytes * 2)   // too many entries, something is wrong! 
-                throw new ApplicationException(string.Format("Bytes is: {0}, expected: {1}.", treeBytes, size / 2));
+                throw new ApplicationException($"Bytes is: {treeBytes}, expected: {size / 2}.");
             
             tree_MaxLength = 0;
             tree_entries = 0;
diff --git a/src/ImageLoaders/Dol/DolLoader.cs b/src/ImageLoaders/Dol/DolLoader.cs
index 9a30fd2f7..1f244373d 100644
--- a/src/ImageLoaders/Dol/DolLoader.cs
+++ b/src/ImageLoaders/Dol/DolLoader.cs
@@ -125,7 +125,7 @@ public class DolLoader : ImageLoader
                 Array.Copy(RawImage, hdr.offsetText[i], bytes, 0, bytes.Length);
                 var mem = new ByteMemoryArea(hdr.addressText[i], bytes); 
                 segments.Add(new ImageSegment(
-                    string.Format("Text{0}", snum),
+                    $"Text{snum}",
                     mem,
                     AccessMode.ReadExecute));
             }
@@ -141,7 +141,7 @@ public class DolLoader : ImageLoader
                 var mem = new ByteMemoryArea(hdr.addressText[i], bytes);
 
                 segments.Add(new ImageSegment(
-                    string.Format("Data{0}", snum),
+                    $"Data{snum}",
                     mem,
                     AccessMode.ReadWrite));
             }
diff --git a/src/ImageLoaders/Elf/DynamicSectionRenderer.cs b/src/ImageLoaders/Elf/DynamicSectionRenderer.cs
index 75f993913..f812aa6a4 100644
--- a/src/ImageLoaders/Elf/DynamicSectionRenderer.cs
+++ b/src/ImageLoaders/Elf/DynamicSectionRenderer.cs
@@ -97,7 +97,7 @@ public override void Render(ImageSegment segment, Program program, Formatter for
         public void Render(ulong fileOffset, Formatter formatter)
         {
             // Get the entry that has the segment# for the string table.
-            var dynStrtab = loader.GetDynamicEntries(fileOffset).Where(d => d.Tag == DT_STRTAB).FirstOrDefault();
+            var dynStrtab = loader.GetDynamicEntries(fileOffset).FirstOrDefault(d => d.Tag == DT_STRTAB);
             if (dynStrtab == null)
                 return;
             var offStrtab = loader.AddressToFileOffset(dynStrtab.UValue);
@@ -108,7 +108,7 @@ public void Render(ulong fileOffset, Formatter formatter)
                 if (!machineSpecific.TryGetValue(entry.Tag, out var dser) &&
                     !ElfDynamicEntry.TagInfos.TryGetValue(entry.Tag, out dser))
                 {
-                    entryName = string.Format("{0:X8}    ", entry.Tag);
+                    entryName = $"{entry.Tag:X8}    ";
                     fmt = DtFormat.Hexadecimal;
                 }
                 else
@@ -134,7 +134,7 @@ protected virtual void RenderEntry(string name, DtFormat format, ElfDynamicEntry
                 formatter.Write("{0,8}", entry.SValue);
                 break;
             case DtFormat.Address:
-                formatter.WriteHyperlink(string.Format("{0:X8}", entry.UValue), Address.Ptr32((uint)entry.UValue));
+                formatter.WriteHyperlink($"{entry.UValue:X8}", Address.Ptr32((uint)entry.UValue));
                 break;
             case DtFormat.String:
                 formatter.Write(loader.ReadAsciiString(fileOffset + entry.UValue));
@@ -197,7 +197,7 @@ public override void Render(ImageSegment segment, Program program, Formatter for
         public void Render(ulong fileOffset, Formatter formatter)
         { 
             // Get the entry that has the segment# for the string table.
-            var dynStrtab = loader.GetDynamicEntries(fileOffset).Where(d => d.Tag == DT_STRTAB).FirstOrDefault();
+            var dynStrtab = loader.GetDynamicEntries(fileOffset).FirstOrDefault(d => d.Tag == DT_STRTAB);
             if (dynStrtab == null)
                 return;
             var offStrtab = loader.AddressToFileOffset(dynStrtab.UValue);
@@ -210,7 +210,7 @@ public void Render(ulong fileOffset, Formatter formatter)
                 if (!machineSpecific.TryGetValue(entry.Tag, out var dser) &&
                     !ElfDynamicEntry.TagInfos.TryGetValue(entry.Tag, out dser))
                 {
-                    entryName = string.Format("{0:X8}    ", entry.Tag);
+                    entryName = $"{entry.Tag:X8}    ";
                     fmt = DtFormat.Hexadecimal;
                 }
                 else
@@ -264,7 +264,7 @@ protected virtual void RenderEntry(string name, DtFormat format, ElfDynamicEntry
                 formatter.Write("{0,16}", entry.SValue);
                 break;
             case DtFormat.Address:
-                formatter.WriteHyperlink(string.Format("{0:X16}", entry.UValue), Address.Ptr64(entry.UValue));
+                formatter.WriteHyperlink($"{entry.UValue:X16}", Address.Ptr64(entry.UValue));
                 break;
             case DtFormat.String:
                 formatter.Write(loader.ReadAsciiString(strtabSection!.FileOffset + entry.UValue));
diff --git a/src/ImageLoaders/Elf/ElfLoader.cs b/src/ImageLoaders/Elf/ElfLoader.cs
index 89b50b9ae..bda305df3 100644
--- a/src/ImageLoaders/Elf/ElfLoader.cs
+++ b/src/ImageLoaders/Elf/ElfLoader.cs
@@ -397,7 +397,7 @@ public IPlatform LoadPlatform(byte osAbi, IProcessorArchitecture arch)
                 envName = "linux";      //$TODO: create a linux platform
                 break;
             default:
-                throw new NotSupportedException(string.Format("Unsupported ELF ABI 0x{0:X2}.", osAbi));
+                throw new NotSupportedException($"Unsupported ELF ABI 0x{osAbi:X2}.");
             }
             var env = cfgSvc.GetEnvironment(envName);
             this.platform = env.Load(Services, arch);
@@ -664,10 +664,7 @@ public void Dump()
 
         protected string DumpShFlags(ulong shf)
         {
-            return string.Format("{0}{1}{2}",
-                ((shf & SHF_EXECINSTR) != 0) ? "x" : " ",
-                ((shf & SHF_ALLOC) != 0) ? "a" : " ",
-                ((shf & SHF_WRITE) != 0) ? "w" : " ");
+            return $"{(((shf & SHF_EXECINSTR) != 0) ? "x" : " ")}{(((shf & SHF_ALLOC) != 0) ? "a" : " ")}{(((shf & SHF_WRITE) != 0) ? "w" : " ")}";
         }
 
 
diff --git a/src/ImageLoaders/Elf/ElfLoader32.cs b/src/ImageLoaders/Elf/ElfLoader32.cs
index eed55f93e..820d7c9ae 100644
--- a/src/ImageLoaders/Elf/ElfLoader32.cs
+++ b/src/ImageLoaders/Elf/ElfLoader32.cs
@@ -121,7 +121,7 @@ public override Address CreateAddress(ulong uAddr)
                 }
                 else
                 {
-                    throw new NotSupportedException(string.Format("The MIPS architecture does not support ELF endianness value {0}", endianness));
+                    throw new NotSupportedException($"The MIPS architecture does not support ELF endianness value {endianness}");
                 }
                 break;
             case ElfMachine.EM_RISCV:
@@ -323,7 +323,7 @@ public string GetSymbolName(ElfSection symSection, uint symbolNo)
         {
             var strSection = symSection.LinkedSection;
             if (strSection == null)
-                return string.Format("null:{0:X8}", symbolNo);
+                return $"null:{symbolNo:X8}";
             uint offset = (uint) (symSection.FileOffset + symbolNo * symSection.EntrySize);
             var rdr = CreateReader(offset);
             rdr.TryReadUInt32(out offset);
diff --git a/src/ImageLoaders/Elf/Relocators/SparcRelocator.cs b/src/ImageLoaders/Elf/Relocators/SparcRelocator.cs
index fbce13385..6168a5f8c 100644
--- a/src/ImageLoaders/Elf/Relocators/SparcRelocator.cs
+++ b/src/ImageLoaders/Elf/Relocators/SparcRelocator.cs
@@ -122,9 +122,7 @@ public override (Address?, ElfSymbol?) RelocateEntry(Program program, ElfSymbol
                 Debug.Print("Relocation type {0} not handled yet.", rt);
                 return (addr, null);
             default:
-                throw new NotImplementedException(string.Format(
-                    "SPARC ELF relocation type {0} not implemented yet.",
-                    rt));
+                throw new NotImplementedException($"SPARC ELF relocation type {rt} not implemented yet.");
             }
             var arch = program.Architecture;
             var relR = program.CreateImageReader(arch, addr);
diff --git a/src/ImageLoaders/Elf/Relocators/x86Relocator.cs b/src/ImageLoaders/Elf/Relocators/x86Relocator.cs
index 236f80e06..f6d97b96c 100644
--- a/src/ImageLoaders/Elf/Relocators/x86Relocator.cs
+++ b/src/ImageLoaders/Elf/Relocators/x86Relocator.cs
@@ -131,9 +131,7 @@ public override (Address?, ElfSymbol?) RelocateEntry(Program program, ElfSymbol
                 P = 0;
                 break;
             default:
-                throw new NotImplementedException(string.Format(
-                    "i386 ELF relocation type {0} not implemented yet.",
-                    rt));
+                throw new NotImplementedException($"i386 ELF relocation type {rt} not implemented yet.");
             }
             var w = relR.ReadLeUInt32();
             w += ((uint)(B + S + A + P) >> sh) & mask;
diff --git a/src/ImageLoaders/Hunk/HunkFileParser.cs b/src/ImageLoaders/Hunk/HunkFileParser.cs
index 645356342..4fb762920 100644
--- a/src/ImageLoaders/Hunk/HunkFileParser.cs
+++ b/src/ImageLoaders/Hunk/HunkFileParser.cs
@@ -85,7 +85,7 @@ public virtual HunkFile Parse()
                 {
                     // no hunk file?
                     if (isFirstHunk)
-                        throw new BadImageFormatException(String.Format("Unknown hunk type: {0}.", hunkType));
+                        throw new BadImageFormatException($"Unknown hunk type: {hunkType}.");
 
                     if (sawEndHunk)
                     {
@@ -151,7 +151,7 @@ public virtual HunkFile Parse()
                         }
                     }
                 };
-                Debug.WriteLineIf(trace.TraceVerbose, string.Format("Loading hunk type: {0}", hunkType));
+                Debug.WriteLineIf(trace.TraceVerbose, $"Loading hunk type: {hunkType}");
                 switch (hunkType)
                 {
                 case HunkType.HUNK_HEADER:
@@ -222,7 +222,7 @@ public virtual HunkFile Parse()
                     this.parse_unit_or_name(hunk);
                     break;
                 default:
-                    throw new BadImageFormatException(string.Format("Unsupported hunk {0}.", (int) hunkType));
+                    throw new BadImageFormatException($"Unsupported hunk {(int)hunkType}.");
                 }
                 last_file_offset = (uint)hunkFileOffset;
             }
@@ -368,7 +368,7 @@ public TextHunk ParseText(Action<Hunk> fn)
             fn(hunk);
             var num_longs = this.read_long();
             if (num_longs < 0)
-                throw new BadImageFormatException(string.Format("{0} has invalid size.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid size.");
 
             // Read in the hunk data
             var size = num_longs * 4;
@@ -377,8 +377,8 @@ public TextHunk ParseText(Action<Hunk> fn)
             hunk.memf = this.SetMemoryFlags(flags, 30);
             hunk.data_file_offset = (uint)f.Offset;
             hunk.Data = f.ReadBytes(hunk.alloc_size);
-            Debug.WriteLineIf(trace.TraceVerbose, string.Format("  alloc_size:  {0:X8}", hunk.alloc_size));
-            Debug.WriteLineIf(trace.TraceVerbose, string.Format("  file_offset: {0:X8}", hunk.data_file_offset));
+            Debug.WriteLineIf(trace.TraceVerbose, $"  alloc_size:  {hunk.alloc_size:X8}");
+            Debug.WriteLineIf(trace.TraceVerbose, $"  file_offset: {hunk.data_file_offset:X8}");
             return hunk;
         }
 
@@ -388,7 +388,7 @@ public BssHunk ParseBss(Action<Hunk> fn)
             fn(hunk);
             var num_longs = this.read_long();
             if (num_longs < 0)
-                throw new BadImageFormatException(string.Format("{0} has invalid size.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid size.");
             // read in hunk data
             var size = num_longs * 4;
             hunk.size = size & ~Hunk.HUNKF_ALL;
@@ -408,7 +408,7 @@ public RelocHunk ParseReloc(Action<Hunk> fn)
             {
                 num_relocs = this.read_long();
                 if (num_relocs < 0)
-                    throw new BadImageFormatException(string.Format("{0} has invalid number of relocations.", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid number of relocations.");
                 else if (num_relocs == 0)
                 {
                     // last relocation found
@@ -417,8 +417,8 @@ public RelocHunk ParseReloc(Action<Hunk> fn)
                 // build reloc map
                 var hunkNo = this.read_long();
                 if (hunkNo < 0)
-                    throw new BadImageFormatException(string.Format("{0} has invalid hunk num.", hunk.HunkType));
-                Debug.WriteLineIf(trace.TraceVerbose, string.Format("  hunk: {0}, relocs: {1}", hunkNo, num_relocs));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid hunk num.");
+                Debug.WriteLineIf(trace.TraceVerbose, $"  hunk: {hunkNo}, relocs: {num_relocs}");
                 var offsets = new List<uint>();
                 num_relocs &= 0xFFFF;
                 for (var a = 0; a < num_relocs; ++a)
@@ -426,13 +426,7 @@ public RelocHunk ParseReloc(Action<Hunk> fn)
                     var offset = this.read_long();
                     if (offset < 0)
                         throw new BadImageFormatException(
-                            string.Format(
-                                "{0} has invalid relocation #{1} offset {2} (num_relocs={3} hunkNo={4}, offset={5})", 
-                                hunk.HunkType, 
-                                a, offset,
-                                num_relocs,
-                                hunkNo, 
-                                f.Offset));
+                            $"{hunk.HunkType} has invalid relocation #{a} offset {offset} (num_relocs={num_relocs} hunkNo={hunkNo}, offset={f.Offset})");
                     offsets.Add((uint) offset);
                 }
                 reloc[hunkNo] = offsets;
@@ -453,7 +447,7 @@ public void ParseRelocShort(Action<Hunk> h)
             {
                 num_relocs = this.read_word(f);
                 if (num_relocs < 0)
-                    throw new BadImageFormatException(string.Format("{0} has invalid number of relocations.", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid number of relocations.");
                 else if (num_relocs == 0)
                 {
                     // last relocation found
@@ -463,7 +457,7 @@ public void ParseRelocShort(Action<Hunk> h)
                 // build reloc map
                 var hunkNo = this.read_word(f);
                 if (hunkNo < 0)
-                    throw new BadImageFormatException(string.Format("{0} has invalid hunk num.", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid hunk num.");
                 var offsets = new List<uint>();
                 var count = num_relocs & 0xFFFF;
                 total_words += count + 2;
@@ -471,8 +465,7 @@ public void ParseRelocShort(Action<Hunk> h)
                 {
                     var offset = f.ReadBeInt16();
                     if (offset < 0)
-                        throw new BadImageFormatException(string.Format(
-                            "{0} has invalid relocation #{1} offset {2} (num_relocs={3} hunkNo={4}, offset={5}).", hunk.HunkType, a, offset, num_relocs, hunkNo, f.Offset));
+                        throw new BadImageFormatException($"{hunk.HunkType} has invalid relocation #{a} offset {offset} (num_relocs={num_relocs} hunkNo={hunkNo}, offset={f.Offset}).");
                     offsets.Add((uint) offset);
                 }
                 reloc[hunkNo] = offsets;
@@ -495,7 +488,7 @@ public void ParseSymbol(Action<Hunk> h)
             {
                 var x = this.ReadString();
                 if (x == null)
-                    throw new BadImageFormatException(string.Format("{0} has invalid symbol name", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid symbol name");
                 else if (x.Length == 0)
                 {
                     // last name occurred
@@ -503,7 +496,7 @@ public void ParseSymbol(Action<Hunk> h)
                 }
                 var value = this.read_long();
                 if (value < 0)
-                    throw new NotImplementedException(string.Format("{0} has invalid symbol value", hunk.HunkType));
+                    throw new NotImplementedException($"{hunk.HunkType} has invalid symbol value");
                 symbols[x] = value;
             }
         }
@@ -513,7 +506,7 @@ public void ParseDebug(Action<Hunk> h)
             var hunk = new DebugHunk();
             var num_longs = this.read_long();
             if (num_longs < 0)
-                throw new BadImageFormatException(string.Format("{0} has invalid size.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid size.");
             var size = num_longs * 4;
             if (num_longs < 2)
             {
@@ -569,7 +562,7 @@ public virtual void ParseOverlay(Action<Hunk> h)
             // read size of overlay hunk
             var ov_size = this.read_long();
             if (ov_size < 0)
-                throw new BadImageFormatException(string.Format("{0} has invalid size.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid size.");
             
             // read data of overlay
             var byte_size = (ov_size + 1) * 4;
@@ -578,12 +571,12 @@ public virtual void ParseOverlay(Action<Hunk> h)
             // check: first get header hunk
             var hdr_hunk = this.hunks[0];
             if (hdr_hunk.HunkType != HunkType.HUNK_HEADER)
-                throw new BadImageFormatException(string.Format("{0} has no header hunk.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has no header hunk.");
             
             // first find the code segment of the overlay manager
             var overlayManagerHunk = this.FindFirstCodeHunk();
             if (overlayManagerHunk == null)
-                throw new BadImageFormatException(string.Format("{0} has no overlay manager hunk.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has no overlay manager hunk.");
             
             // check overlay manager
             var overlay_mgr_data = overlayManagerHunk.Data!;
@@ -722,7 +715,7 @@ public virtual void ParseIndex(Action<Hunk> h)
                 f.ReadBeInt16();
             }
             else if (total_size != 0)
-                throw new BadImageFormatException(string.Format("{0} has invalid padding.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid padding.");
         }
 
         public void ParseExt(Action<Hunk> h)
@@ -743,11 +736,11 @@ public void ParseExt(Action<Hunk> h)
                 var ext_type = (ExtType) (byte) (ext_type_size >> (int) ExtType.EXT_TYPE_SHIFT);
                 ext_size = ext_type_size & (int) ExtType.EXT_TYPE_SIZE_MASK;
                 if (ext_size < 0)
-                    throw new BadImageFormatException(string.Format("{0} has invalid size.", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid size.");
                 // ext name
                 string? ext_name = this.ReadSizedString(ext_size);
                 if (ext_name == null)
-                    throw new BadImageFormatException(string.Format("{0} has invalid name.", hunk.HunkType));
+                    throw new BadImageFormatException($"{hunk.HunkType} has invalid name.");
                 else if (ext_name.Length == 0)
                     break;
                 
@@ -756,7 +749,7 @@ public void ParseExt(Action<Hunk> h)
 
                 // check and setup type name
                 if (!ext_names.ContainsKey(ext_type))
-                    throw new BadImageFormatException(string.Format("{0} has unspported ext entry {1}.", hunk.HunkType, ext_type));
+                    throw new BadImageFormatException($"{hunk.HunkType} has unspported ext entry {ext_type}.");
                 // ext common
                 if (ext_type == ExtType.EXT_ABSCOMMON || ext_type == ExtType.EXT_RELCOMMON)
                 {
@@ -795,7 +788,7 @@ public void parse_unit_or_name(Action<Hunk> h)
             h(hunk);
             var n = this.ReadString();
             if (n == null)
-                throw new BadImageFormatException(string.Format("{0} has invalid name.", hunk.HunkType));
+                throw new BadImageFormatException($"{hunk.HunkType} has invalid name.");
             hunk.Name = n;
         }
 
diff --git a/src/ImageLoaders/Hunk/HunkLoader.cs b/src/ImageLoaders/Hunk/HunkLoader.cs
index 1c4aad308..22466110c 100644
--- a/src/ImageLoaders/Hunk/HunkLoader.cs
+++ b/src/ImageLoaders/Hunk/HunkLoader.cs
@@ -164,7 +164,7 @@ public bool BuildLoadSegments()
                     {
                     }
                     else
-                        throw new BadImageFormatException(string.Format("Expected hunk start in loadseg: {0) {1}/{1:X}", e.HunkType, (int) hunk_type));
+                        throw new BadImageFormatException($"Expected hunk start in loadseg: {e.HunkType}1{(int)hunk_type}1:X");
                 }
                 else
                 {
diff --git a/src/ImageLoaders/Hunk/HunkRelocator.cs b/src/ImageLoaders/Hunk/HunkRelocator.cs
index d6bdd682d..cf59b77c0 100644
--- a/src/ImageLoaders/Hunk/HunkRelocator.cs
+++ b/src/ImageLoaders/Hunk/HunkRelocator.cs
@@ -82,7 +82,7 @@ public byte[] Relocate(List<uint> addr)
             var datas = new System.IO.MemoryStream();
             foreach (List<Hunk> segment in this.hunk_file.segments)
             {
-                Debug.WriteLineIf(Trace.TraceVerbose, string.Format("Relocating segment {0}", segment[0]));
+                Debug.WriteLineIf(Trace.TraceVerbose, $"Relocating segment {segment[0]}");
                 var mainHunk = segment[0];
                 int hunk_no = mainHunk.hunk_no;
                 int alloc_size = mainHunk.alloc_size;
@@ -90,8 +90,8 @@ public byte[] Relocate(List<uint> addr)
 
                 // Fill in segment data
                 byte[] data;
-                var txt = mainHunk as TextHunk;
-                if (txt != null)
+
+                if (mainHunk is TextHunk txt)
                 {
                     Debug.Assert(txt.size <= alloc_size);
                     data = txt.Data!;
diff --git a/src/ImageLoaders/Hunk/Hunks.cs b/src/ImageLoaders/Hunk/Hunks.cs
index 337a6e35b..b02c8e181 100644
--- a/src/ImageLoaders/Hunk/Hunks.cs
+++ b/src/ImageLoaders/Hunk/Hunks.cs
@@ -88,7 +88,7 @@ public partial class Hunk
 
         public override string ToString()
         {
-            return string.Format("{0} ({1})", hunk_no, string.IsNullOrEmpty(Name) ? "<unnamed>" : Name);
+            return $"{hunk_no} ({(string.IsNullOrEmpty(Name) ? "<unnamed>" : Name)})";
         }
     }
 
diff --git a/src/ImageLoaders/Llvm/LLVMInstructionTranslator.cs b/src/ImageLoaders/Llvm/LLVMInstructionTranslator.cs
index 1a4ecea12..7be2bc531 100644
--- a/src/ImageLoaders/Llvm/LLVMInstructionTranslator.cs
+++ b/src/ImageLoaders/Llvm/LLVMInstructionTranslator.cs
@@ -69,7 +69,7 @@ public int VisitBinary(Binary bin)
             switch (bin.Operator)
             {
             default:
-                throw new NotImplementedException(string.Format("TranslateInstruction({0})", bin.Operator));
+                throw new NotImplementedException($"TranslateInstruction({bin.Operator})");
             case TokenType.add: fn = m.IAdd; break;
             case TokenType.sub: fn = m.ISub; break;
             case TokenType.mul: fn = m.IMul; break;
@@ -90,7 +90,7 @@ public int VisitBitwiseBinary(BitwiseBinary bit)
             switch (bit.Operator)
             {
             default:
-                throw new NotImplementedException(string.Format("VisitBitwiseBinary({0})", bit.Operator));
+                throw new NotImplementedException($"VisitBitwiseBinary({bit.Operator})");
             case TokenType.and: fn = m.And; break;
             case TokenType.ashr: fn = m.Sar; break;
             case TokenType.shl: fn = m.Shl; break;
@@ -149,7 +149,7 @@ public int VisitCmp(CmpInstruction cmp)
                 switch (cmp.ConditionCode)
                 {
                 default:
-                    throw new NotImplementedException(string.Format("TranslateCmp({0})", cmp.ConditionCode));
+                    throw new NotImplementedException($"TranslateCmp({cmp.ConditionCode})");
                 case TokenType.eq: fn = m.Eq; break;
                 case TokenType.ne: fn = m.Ne; break;
                 case TokenType.sge: fn = m.Ge; break;
@@ -167,11 +167,11 @@ public int VisitCmp(CmpInstruction cmp)
                 switch (cmp.ConditionCode)
                 {
                 default:
-                    throw new NotImplementedException(string.Format("TranslateCmp({0})", cmp.ConditionCode));
+                    throw new NotImplementedException($"TranslateCmp({cmp.ConditionCode})");
                 }
             }
             else
-                throw new NotImplementedException(string.Format("TranslateCmp({0})", cmp.Operator));
+                throw new NotImplementedException($"TranslateCmp({cmp.Operator})");
 
             m.Assign(dst, fn(op1, op2));
             return 0;
@@ -187,7 +187,7 @@ public int VisitConversion(Conversion conv)
             switch (conv.Operator)
             {
             default:
-                throw new NotImplementedException(string.Format("TranslateConversion({0},{1},{2})", conv.Operator, srcType, dstType));
+                throw new NotImplementedException($"TranslateConversion({conv.Operator},{srcType},{dstType})");
             case TokenType.bitcast:     // reinterpret_cast requires no convert
                 e = src;
                 break;
@@ -398,7 +398,7 @@ private Expression MakeValueExpression(Value value, DataType dt)
             case GetElementPtrExpr get:
                 return GetElementPtr(get.PointerType!, get.Pointer!, get.Indices!);
             }
-            throw new NotImplementedException(string.Format("MakeValueExpression: {0} {1}", value.GetType().Name, value.ToString() ?? "(null)"));
+            throw new NotImplementedException($"MakeValueExpression: {value.GetType().Name} {value.ToString() ?? "(null)"}");
         }
     }
 }
diff --git a/src/ImageLoaders/Llvm/LLVMLexer.cs b/src/ImageLoaders/Llvm/LLVMLexer.cs
index a9fa3301f..16ce50ace 100644
--- a/src/ImageLoaders/Llvm/LLVMLexer.cs
+++ b/src/ImageLoaders/Llvm/LLVMLexer.cs
@@ -400,7 +400,7 @@ private static bool IsHexDigit(char ch)
 
         private void Unexpected(string un)
         {
-            throw new FormatException(string.Format("Unexpected string '{0}' on line {1}.", un, LineNumber));
+            throw new FormatException($"Unexpected string '{un}' on line {LineNumber}.");
         }
 
         private Token Identifier(StringBuilder sb)
diff --git a/src/ImageLoaders/Llvm/LLVMParser.cs b/src/ImageLoaders/Llvm/LLVMParser.cs
index e6eb8b3d6..46609a955 100644
--- a/src/ImageLoaders/Llvm/LLVMParser.cs
+++ b/src/ImageLoaders/Llvm/LLVMParser.cs
@@ -843,8 +843,7 @@ private Token Get()
         private void Unexpected(Token tok)
         {
             throw new FormatException(
-                string.Format("Unexpected token '{0}' {1} on line {2}.",
-                tok.Type, tok.Value, tok.LineNumber));
+                $"Unexpected token '{tok.Type}' {tok.Value} on line {tok.LineNumber}.");
         }
     }
 }
diff --git a/src/ImageLoaders/Llvm/LLVMSyntax.cs b/src/ImageLoaders/Llvm/LLVMSyntax.cs
index 486744b60..eb5c6a577 100644
--- a/src/ImageLoaders/Llvm/LLVMSyntax.cs
+++ b/src/ImageLoaders/Llvm/LLVMSyntax.cs
@@ -304,8 +304,8 @@ public override void Write(Formatter w)
                 w.Write("{0}", Value);
                 return;
             }
-            var bytes = Value as byte[];
-            if (bytes != null)
+
+            if (Value is byte[] bytes)
             {
                 w.Write("c\"");
                 foreach (var b in bytes)
diff --git a/src/ImageLoaders/Llvm/ProgramBuilder.cs b/src/ImageLoaders/Llvm/ProgramBuilder.cs
index 2d7c5c49f..de1aad5e3 100644
--- a/src/ImageLoaders/Llvm/ProgramBuilder.cs
+++ b/src/ImageLoaders/Llvm/ProgramBuilder.cs
@@ -101,9 +101,7 @@ private IProcessorArchitecture LoadArchitecture(string llvmArchName)
             {
             case "x86_64": archName = "x86-protected-64"; break;
             default:
-                throw new NotImplementedException(string.Format(
-                    "Support for LLVM type {0} not supported yet.",
-                    llvmArchName));
+                throw new NotImplementedException($"Support for LLVM type {llvmArchName} not supported yet.");
             }
             return cfgSvc.GetArchitecture(archName)!;
         }
@@ -189,7 +187,7 @@ public void TranslateEntry(ModuleEntry entry)
                 //$TODO
                 return;
             }
-            throw new NotImplementedException(string.Format("TranslateEntry({0})", entry.GetType()));
+            throw new NotImplementedException($"TranslateEntry({entry.GetType()})");
         }
 
 
diff --git a/src/ImageLoaders/Llvm/TypeTranslator.cs b/src/ImageLoaders/Llvm/TypeTranslator.cs
index 36c0d4587..98e332dd8 100644
--- a/src/ImageLoaders/Llvm/TypeTranslator.cs
+++ b/src/ImageLoaders/Llvm/TypeTranslator.cs
@@ -62,7 +62,7 @@ public DataType VisitBaseType(LLVMBaseType b)
             case Domain.Void:
                 return VoidType.Instance;
             }
-            throw new NotImplementedException(string.Format("{0}", b));
+            throw new NotImplementedException($"{b}");
         }
 
         public DataType VisitFunction(LLVMFunctionType fn)
diff --git a/src/ImageLoaders/MachO/Parser.cs b/src/ImageLoaders/MachO/Parser.cs
index 7676c528f..5c4fdd1d4 100644
--- a/src/ImageLoaders/MachO/Parser.cs
+++ b/src/ImageLoaders/MachO/Parser.cs
@@ -100,7 +100,7 @@ public ArchSpecific CreateArchitecture(uint cputype)
             case CPU_TYPE_MC680x0: return MakeSpecific("m68k", a=> new M68kSpecific(a));
             case CPU_TYPE_ARM64: return MakeSpecific("arm-64", a => new Arm64Specific(a));
             default:
-                throw new NotSupportedException(string.Format("Processor format {0} is not supported.", cputype));
+                throw new NotSupportedException($"Processor format {cputype} is not supported.");
             }
         }
 
@@ -392,7 +392,7 @@ void ParseSection32(uint iSection, uint protection, SegmentMap segmentMap)
 
             var addr = Address.Ptr32(uAddr);
             var bytes = rdr.CreateNew(this.ldr.RawImage, offset);
-            var name = string.Format("{0},{1}", segmentName, sectionName);
+            var name = $"{segmentName},{sectionName}";
 
             AddSection(segmentMap, size, flags, reserved1, reserved2, protection, addr, bytes, name);
         }
@@ -462,7 +462,7 @@ void ParseSection64(uint protection, SegmentMap segmentMap)
 
             var addr = Address.Ptr64(uAddr);
             var bytes = rdr.CreateNew(this.ldr.RawImage, offset);
-            var name = string.Format("{0},{1}", segmentName, sectionName);
+            var name = $"{segmentName},{sectionName}";
             AddSection(segmentMap, (uint)size, flags, reserved1, reserved2, protection, addr, bytes, name);
         }
 
diff --git a/src/ImageLoaders/MzExe/CodeView/CodeViewLoader.cs b/src/ImageLoaders/MzExe/CodeView/CodeViewLoader.cs
index f4892ded8..34915ebc4 100644
--- a/src/ImageLoaders/MzExe/CodeView/CodeViewLoader.cs
+++ b/src/ImageLoaders/MzExe/CodeView/CodeViewLoader.cs
@@ -127,7 +127,7 @@ public PublicSymbol(Address addr, int typeidx, string name)
 
             public override string ToString()
             {
-                return String.Format("<PublicSymbol \'{0}\', addr 0x{1} type {2}>", this.name, this.addr, this.typeidx);
+                return $"<PublicSymbol \'{this.name}\', addr 0x{this.addr} type {this.typeidx}>";
             }
         }
 
@@ -161,7 +161,7 @@ public sstPublics(SST sst, int module, byte[] data)
             public override string ToString()
             {
                 //return '<sstPublics len=%d nSymbols=%d>' % (len(self.data), len(self.symbols))
-                return String.Format("<sstPublics {0}>", string.Join(" ", this.symbols));
+                return $"<sstPublics {string.Join(" ", this.symbols)}>";
             }
         }
 
diff --git a/src/ImageLoaders/MzExe/MsdosImageLoader.cs b/src/ImageLoaders/MzExe/MsdosImageLoader.cs
index c600433a5..a34c5ea54 100644
--- a/src/ImageLoaders/MzExe/MsdosImageLoader.cs
+++ b/src/ImageLoaders/MzExe/MsdosImageLoader.cs
@@ -165,7 +165,7 @@ public override RelocationResults Relocate(Program program, Address addrLoad)
             foreach (var de in segments)
             {
                 var tmp = new TemporaryStorage(
-                    string.Format("seg{0:X4}", de.Value),
+                    $"seg{de.Value:X4}",
                     0,
                     PrimitiveType.SegmentSelector);
                 segmentMap.Segments[de.Key].Identifier = new Identifier(
diff --git a/src/ImageLoaders/MzExe/NeImageLoader.cs b/src/ImageLoaders/MzExe/NeImageLoader.cs
index b734c41d9..833a9ecf7 100644
--- a/src/ImageLoaders/MzExe/NeImageLoader.cs
+++ b/src/ImageLoaders/MzExe/NeImageLoader.cs
@@ -528,7 +528,7 @@ private bool LoadSegment(NeSegment neSeg, ByteMemoryArea mem)
                 neSeg.Address!.Selector!.Value.ToString("X4"),
                 access);
             var stg = new TemporaryStorage(
-                string.Format("seg{0:X4}", seg.Address!.Selector!.Value),
+                $"seg{seg.Address!.Selector!.Value:X4}",
                 0,
                 PrimitiveType.SegmentSelector);
             seg.Identifier = new Identifier(seg.Name, stg.DataType, stg);
@@ -763,7 +763,7 @@ private bool ApplyRelocations(EndianImageReader rdr, int cRelocations, NeSegment
                         // Borland creates additive records with offset zero. Strange, but OK.
                         w = mem.ReadLeUInt16(sp);
                         if (w != 0)
-                            listener.Error(string.Format("Additive selector to {0:X4}. Please report.", w));
+                            listener.Error($"Additive selector to {w:X4}. Please report.");
                         else
                             mem.WriteLeUInt16(sp, address!.Selector!.Value);
                         break;
@@ -820,19 +820,9 @@ private string WriteRelocationEntry(NeRelocationEntry re)
             {
             //case NE_RELTYPE.NAME:
             case NE_RELTYPE.ORDINAL:
-                return string.Format("{0,8} {1,8} {2:X4} {3:X4} {4:X4}",
-                    re.address_type,
-                    re.relocation_type,
-                    re.offset,
-                    moduleNames[re.target1 - 1],
-                    re.target2);
+                return $"{re.address_type, 8} {re.relocation_type, 8} {re.offset:X4} {moduleNames[re.target1 - 1]:X4} {re.target2:X4}";
             default:
-                return string.Format("{0,8} {1,8} {2:X4} {3:X4} {4:X4}",
-                    re.address_type,
-                    re.relocation_type,
-                    re.offset,
-                    re.target1,
-                    re.target2);
+                return $"{re.address_type, 8} {re.relocation_type, 8} {re.offset:X4} {re.target1:X4} {re.target2:X4}";
             }
         }
     }
diff --git a/src/ImageLoaders/MzExe/Pe/ResourceLoader.cs b/src/ImageLoaders/MzExe/Pe/ResourceLoader.cs
index a741b1a89..fb6bb76b7 100644
--- a/src/ImageLoaders/MzExe/Pe/ResourceLoader.cs
+++ b/src/ImageLoaders/MzExe/Pe/ResourceLoader.cs
@@ -202,7 +202,7 @@ public ProgramResourceInstance ReadResourceEntry(EndianImageReader rdr, string r
             string localeName = GetLocaleName(langId);
             return new ProgramResourceInstance
             {
-                Name = string.Format("{0}:{1}", resourceId, localeName),
+                Name = $"{resourceId}:{localeName}",
                 Type = GetResourceType(resourceType),
                 Bytes = abResource,
             };
diff --git a/src/ImageLoaders/MzExe/PeImageLoader.cs b/src/ImageLoaders/MzExe/PeImageLoader.cs
index 4773d6650..241141ea0 100644
--- a/src/ImageLoaders/MzExe/PeImageLoader.cs
+++ b/src/ImageLoaders/MzExe/PeImageLoader.cs
@@ -201,7 +201,7 @@ public IProcessorArchitecture CreateArchitecture(ushort peMachineType)
             case MACHINE_POWERPC: arch = "ppc-le-32"; break;
             case MACHINE_POWERPC_BE: arch = "ppc-be-32"; break;
             case MACHINE_XBOX360: arch = "ppc-be-64"; break;
-			default: throw new ArgumentException(string.Format("Unsupported machine type 0x{0:X4} in PE header.", peMachineType));
+			default: throw new ArgumentException($"Unsupported machine type 0x{peMachineType:X4} in PE header.");
 			}
             return cfgSvc.GetArchitecture(arch)!;
 		}
@@ -222,7 +222,7 @@ public IPlatform CreatePlatform(ushort peMachineType, IServiceProvider sp, IProc
             case MACHINE_POWERPC: env = "winPpc32"; break;
             case MACHINE_POWERPC_BE: env = "winPpc32"; break;   //$REVIEW: this probably should be macOS-ppc
             case MACHINE_XBOX360: env = "xbox360"; break;
-            default: throw new ArgumentException(string.Format("Unsupported machine type 0x:{0:X4} in PE hader.", peMachineType));
+            default: throw new ArgumentException($"Unsupported machine type 0x:{peMachineType:X4} in PE hader.");
             }
             return Services.RequireService<IConfigurationService>()
                 .GetEnvironment(env)
@@ -246,7 +246,7 @@ private SizeSpecificLoader CreateInnerLoader(ushort peMachineType)
             case MACHINE_x86_64:
             case MACHINE_ARM64:
                 return new Pe64Loader(this);
-            default: throw new ArgumentException(string.Format("Unsupported machine type 0x:{0:X4} in PE header.", peMachineType));
+            default: throw new ArgumentException($"Unsupported machine type 0x:{peMachineType:X4} in PE header.");
             }
         }
 
@@ -266,7 +266,7 @@ private Relocator CreateRelocator(ushort peMachineType, Program program)
             case MACHINE_POWERPC_BE: return new PowerPcRelocator(Services, program);    //$REVIEW do we need a big-endian version of this?
             case MACHINE_XBOX360: return new PowerPcRelocator(Services, program);       //$REVIEW do we need a big-endian version of this?
 
-            default: throw new ArgumentException(string.Format("Unsupported machine type 0x:{0:X4} in PE hader.", peMachineType));
+            default: throw new ArgumentException($"Unsupported machine type 0x:{peMachineType:X4} in PE hader.");
             }
         }
 
@@ -287,7 +287,7 @@ private short GetExpectedMagic(ushort peMachineType)
             case MACHINE_x86_64:
             case MACHINE_ARM64:
                 return 0x020B;
-			default: throw new ArgumentException(string.Format("Unsupported machine type 0x{0:X4} in PE header.", peMachineType));
+			default: throw new ArgumentException($"Unsupported machine type 0x{peMachineType:X4} in PE header.");
 			}
         }
 
@@ -364,7 +364,7 @@ private List<Section> LoadSections(Address addrLoad, uint rvaSectionTable, int s
         public ByteMemoryArea LoadSectionBytes(Address addrLoad, List<Section> sections)
         {
             var vaMax = sections.Max(s => s.VirtualAddress);
-            var sectionMax = sections.Where(s => s.VirtualAddress == vaMax).First();
+            var sectionMax = sections.First(s => s.VirtualAddress == vaMax);
             var imgLoaded = new ByteMemoryArea(addrLoad, new byte[sectionMax.VirtualAddress + Math.Max(sectionMax.VirtualSize, sectionMax.SizeRawData)]);
             foreach (Section s in sectionList)
             {
diff --git a/src/ImageLoaders/MzExe/PkLiteUnpacker.cs b/src/ImageLoaders/MzExe/PkLiteUnpacker.cs
index 95352837c..4d08b403d 100644
--- a/src/ImageLoaders/MzExe/PkLiteUnpacker.cs
+++ b/src/ImageLoaders/MzExe/PkLiteUnpacker.cs
@@ -60,12 +60,12 @@ public PkLiteUnpacker(MsdosImageLoader loader)
 			uint pkLiteHdrOffset = (uint) (loader.ExeLoader.e_cparHeader * 0x10);
 
 			if (RawImage[pkLiteHdrOffset] != 0xB8)
-				throw new ApplicationException(string.Format("Expected MOV AX,XXXX at offset 0x{0:X4}.", pkLiteHdrOffset));
+				throw new ApplicationException($"Expected MOV AX,XXXX at offset 0x{pkLiteHdrOffset:X4}.");
 			uint cparUncompressed = ByteMemoryArea.ReadLeUInt16(RawImage, pkLiteHdrOffset + 1);
 			abU = new byte[cparUncompressed * 0x10U];
 
 			if (RawImage[pkLiteHdrOffset + 0x04C] != 0x83)
-				throw new ApplicationException(string.Format("Expected ADD BX,+XX at offset 0x{0:X4}.", pkLiteHdrOffset + 0x04C));
+				throw new ApplicationException($"Expected ADD BX,+XX at offset 0x{pkLiteHdrOffset + 0x04C:X4}.");
 			uint offCompressedData = pkLiteHdrOffset + RawImage[pkLiteHdrOffset + 0x04E] * 0x10u - PspSize;
 			bitStm = new BitStream(RawImage, (int) offCompressedData);
             this.imgU = null!;
diff --git a/src/ImageLoaders/WebAssembly/WasmDisassembler.cs b/src/ImageLoaders/WebAssembly/WasmDisassembler.cs
index 1c2cf2790..a091ec899 100644
--- a/src/ImageLoaders/WebAssembly/WasmDisassembler.cs
+++ b/src/ImageLoaders/WebAssembly/WasmDisassembler.cs
@@ -86,7 +86,7 @@ public WasmDisassembler(WasmArchitecture arch, EndianImageReader rdr)
                     ops.Add(new ImmediateOperand(Constant.FloatFromBitpattern(u)));
                     break;
                 default:
-                    throw new NotImplementedException(string.Format("Format '{0}'.", fmt[i - 1]));
+                    throw new NotImplementedException($"Format '{fmt[i - 1]}'.");
                 }
             }
 
diff --git a/src/ImageLoaders/WebAssembly/WasmEvaluator.cs b/src/ImageLoaders/WebAssembly/WasmEvaluator.cs
index 0c3e3c7c8..2e0448e98 100644
--- a/src/ImageLoaders/WebAssembly/WasmEvaluator.cs
+++ b/src/ImageLoaders/WebAssembly/WasmEvaluator.cs
@@ -251,7 +251,7 @@ public object Run()
                 default:
                     string str;
                     if (!WasmInstruction.mpoptostring.TryGetValue((Mnemonic)b, out str))
-                        str = string.Format("0x{0:X2}", (int)b);
+                        str = $"0x{(int)b:X2}";
                     throw new NotImplementedException(string.Format(
                         "WASM evaluator doesn't know how to evaluate {0} ({1:X2}).",
                         str,
diff --git a/src/Libraries/Microchip/Utils/PICPartsInfo.cs b/src/Libraries/Microchip/Utils/PICPartsInfo.cs
index 3ba667c7f..6c9133581 100644
--- a/src/Libraries/Microchip/Utils/PICPartsInfo.cs
+++ b/src/Libraries/Microchip/Utils/PICPartsInfo.cs
@@ -151,14 +151,14 @@ public IEnumerable<string> PICNamesList()
         /// </summary>
         /// <param name="id">The part identifier.</param>
         public string GetPICName(int id)
-            => Parts.Where(p => p.ProcID == id).FirstOrDefault()?.Name;
+            => Parts.FirstOrDefault(p => p.ProcID == id)?.Name;
 
         /// <summary>
         /// Gets part identifier of a PIC given its name.
         /// </summary>
         /// <param name="picName">Name of the PIC.</param>
         public uint? GetPICProcID(string picName)
-            => Parts.Where(p => p.Name == picName).FirstOrDefault()?.ProcID;
+            => Parts.FirstOrDefault(p => p.Name == picName)?.ProcID;
 
     }
 
diff --git a/src/Libraries/Microchip/Utils/XMLHelpers.cs b/src/Libraries/Microchip/Utils/XMLHelpers.cs
index cdc3c0d0f..e22c45608 100644
--- a/src/Libraries/Microchip/Utils/XMLHelpers.cs
+++ b/src/Libraries/Microchip/Utils/XMLHelpers.cs
@@ -87,7 +87,7 @@ private static XmlSerializer getSerializer<T>(ref XElement xelem, string sdescen
                 return new XmlSerializer(typeof(T), xelem.Name.NamespaceName);
 
             // Look for a descendant of this element making it the root element.
-            xelem = xelem.Descendants().Where((x) => x.Name.LocalName == sdescendantName).FirstOrDefault();
+            xelem = xelem.Descendants().FirstOrDefault((x) => x.Name.LocalName == sdescendantName);
             if (xelem == null)
                 return null;
 
diff --git a/src/UnitTests/Analysis/DataFlowAnalysisTests2.cs b/src/UnitTests/Analysis/DataFlowAnalysisTests2.cs
index 7c210edd6..43682648d 100644
--- a/src/UnitTests/Analysis/DataFlowAnalysisTests2.cs
+++ b/src/UnitTests/Analysis/DataFlowAnalysisTests2.cs
@@ -83,7 +83,7 @@ private void AssertProgramFlow(string sExp, Program program, ProgramDataFlow flo
                 var pflow = flow.ProcedureFlows[proc];
                 sw.WriteLine("// Trashed   {0}", string.Join(", ", pflow.Trashed.OrderBy(s => s.ToString())));
                 sw.WriteLine("// Preserved {0}", string.Join(", ", pflow.Preserved.OrderBy(s => s.ToString())));
-                sw.WriteLine("// Used      {0}", string.Join(", ", pflow.BitsUsed.Select(s => string.Format("({0}:{1})", s.Key, s.Value)).OrderBy(s => s)));
+                sw.WriteLine("// Used      {0}", string.Join(", ", pflow.BitsUsed.Select(s => $"({s.Key}:{s.Value})").OrderBy(s => s)));
                 proc.Write(false, sw);
                 sep = "===" + Environment.NewLine;
             }
diff --git a/src/UnitTests/Analysis/IndirectCallRewriterTests.cs b/src/UnitTests/Analysis/IndirectCallRewriterTests.cs
index 94aee0669..a8a5f8f15 100644
--- a/src/UnitTests/Analysis/IndirectCallRewriterTests.cs
+++ b/src/UnitTests/Analysis/IndirectCallRewriterTests.cs
@@ -149,7 +149,7 @@ private DataType Int32()
         {
             var storages = parameters.Select(p => p.Storage as StackStorage)
                 .Where(stg => stg != null);
-            var stackDelta = storages.Count() == 0 ? 4 :
+            var stackDelta = !storages.Any()? 4 :
                 storages.Max(stg => stg.StackOffset + stg.DataType.Size);
             var ft = new FunctionType(returnValue, parameters)
             {
diff --git a/src/UnitTests/Analysis/SsaLivenessTests.cs b/src/UnitTests/Analysis/SsaLivenessTests.cs
index bc40e6bb4..9547063e0 100644
--- a/src/UnitTests/Analysis/SsaLivenessTests.cs
+++ b/src/UnitTests/Analysis/SsaLivenessTests.cs
@@ -55,7 +55,7 @@ public void SltLiveLoop()
             SsaIdentifier i_1 = ssa.Identifiers.Where(s => s.Identifier.Name == "i_1").Single();
             SsaIdentifier i_3 = ssa.Identifiers.Where(s => s.Identifier.Name == "i_3").Single();
 			Assert.IsFalse(sla.IsLiveOut(i.Identifier, i_1.DefStatement));
-            var block1 = proc.ControlGraph.Blocks.Where(b => b.DisplayName == "loop").Single();
+            var block1 = proc.ControlGraph.Blocks.Single(b => b.DisplayName == "loop");
 			Assert.AreEqual("branch Mem0[i_3:byte] != 0<i8> loop", block1.Statements[2].Instruction.ToString());
 			Assert.IsTrue(sla.IsLiveOut(i_1.Identifier, block1.Statements[2]), "i_1 should be live at the end of block 1");
 			Assert.IsTrue(sla.IsLiveOut(i_3.Identifier, block1.Statements[2]),"i_3 should be live at the end of block 1");
diff --git a/src/UnitTests/Analysis/SsaTransformTests.cs b/src/UnitTests/Analysis/SsaTransformTests.cs
index 46cc51f38..04e31eb76 100644
--- a/src/UnitTests/Analysis/SsaTransformTests.cs
+++ b/src/UnitTests/Analysis/SsaTransformTests.cs
@@ -1775,7 +1775,7 @@ def Mem0
 
         private Identifier Reg(int n)
         {
-            string name = string.Format("r{0}", n);
+            string name = $"r{n}";
             return new Identifier(
                 name,
                 PrimitiveType.Word32,
@@ -3315,8 +3315,8 @@ public void Ssa_KeepSignatureRegisterType()
 
             var ass = proc.Statements
                 .Select(stm => stm.Instruction as Assignment)
-                .Where(instr => instr != null)
-                .Single();
+                .Single(instr => instr != null)
+;
             Assert.AreEqual("r2_2 = r2", ass.ToString());
             // verify that data type of register was not overwritten
             Assert.AreEqual("word32", ass.Dst.DataType.ToString());
diff --git a/src/UnitTests/Analysis/TrashedRegisterFinderTests.cs b/src/UnitTests/Analysis/TrashedRegisterFinderTests.cs
index 81b216c17..270dd9403 100644
--- a/src/UnitTests/Analysis/TrashedRegisterFinderTests.cs
+++ b/src/UnitTests/Analysis/TrashedRegisterFinderTests.cs
@@ -93,8 +93,7 @@ private void RunTest()
                         ",",
                         flow.Constants
                             .OrderBy(kv => kv.Key.ToString())
-                            .Select(kv => string.Format(
-                                "{0}:{1}", kv.Key, kv.Value))));
+                            .Select(kv => $"{kv.Key}:{kv.Value}")));
                 }
                 sw.WriteLine();
             }
@@ -154,7 +153,7 @@ private ProcedureFlow FlowOf(string procName)
 
         private void Expect(string fnName, string preserved, string trashed, string consts)
         {
-            fnName = string.Format("== {0} ====", fnName);
+            fnName = $"== {fnName} ====";
             sbExpected.AppendLine(String.Join(Environment.NewLine, new[] { fnName, preserved, trashed, consts }));
         }
 
diff --git a/src/UnitTests/Analysis/ValuePropagationTests.cs b/src/UnitTests/Analysis/ValuePropagationTests.cs
index 76aad4af8..7bfe3a060 100644
--- a/src/UnitTests/Analysis/ValuePropagationTests.cs
+++ b/src/UnitTests/Analysis/ValuePropagationTests.cs
@@ -97,7 +97,7 @@ private Identifier RegArg(int n, string name)
         private Identifier StackArg(int offset)
         {
             return new Identifier(
-                string.Format("arg{0:X2}", offset),
+                $"arg{offset:X2}",
                 PrimitiveType.Word32,
                 new StackArgumentStorage(offset, PrimitiveType.Word32));
         }
diff --git a/src/UnitTests/Arch/ArchTestBase.cs b/src/UnitTests/Arch/ArchTestBase.cs
index e2e604a95..2c92d3a40 100644
--- a/src/UnitTests/Arch/ArchTestBase.cs
+++ b/src/UnitTests/Arch/ArchTestBase.cs
@@ -133,14 +133,12 @@ public bool TryRead(IProcessorArchitecture arch, Address addr, PrimitiveType dt,
 
             public void Error(Address address, string message, params object[] args)
             {
-                throw new Exception(string.Format("{0}: {1}", address, 
-                    string.Format(message, args)));
+                throw new Exception($"{address}: {string.Format(message, args)}");
             }
 
             public void Warn(Address address, string format, params object[] args)
             {
-                throw new Exception(string.Format("{0}: {1}", address,
-                    string.Format(format, args)));
+                throw new Exception($"{address}: {string.Format(format, args)}");
             }
         }
 
@@ -166,7 +164,7 @@ public uint BitStringToUInt32(string bitPattern)
             }
             if (cBits == 0 || cBits % Architecture.InstructionBitSize != 0)
                 throw new ArgumentException(
-                    string.Format("Bit pattern didn't contain exactly a multiple of {0} binary digits, but {1}.", Architecture.InstructionBitSize, cBits),
+                    $"Bit pattern didn't contain exactly a multiple of {Architecture.InstructionBitSize} binary digits, but {cBits}.",
                     "bitPattern");
             return instr;
         }
diff --git a/src/UnitTests/Arch/Arm/A32DisassemblerTests.cs b/src/UnitTests/Arch/Arm/A32DisassemblerTests.cs
index 4a882968e..8780cfd05 100644
--- a/src/UnitTests/Arch/Arm/A32DisassemblerTests.cs
+++ b/src/UnitTests/Arch/Arm/A32DisassemblerTests.cs
@@ -105,7 +105,7 @@ protected static uint ParseBitPattern(string bitPattern)
             }
             if (cBits != 32)
                 throw new ArgumentException(
-                    string.Format("Bit pattern didn't contain exactly 32 binary digits, but {0}.", cBits),
+                    $"Bit pattern didn't contain exactly 32 binary digits, but {cBits}.",
                     "bitPattern");
             return instr;
         }
diff --git a/src/UnitTests/Arch/RewriterTestBase.cs b/src/UnitTests/Arch/RewriterTestBase.cs
index 9881dbc1b..593e3ebda 100644
--- a/src/UnitTests/Arch/RewriterTestBase.cs
+++ b/src/UnitTests/Arch/RewriterTestBase.cs
@@ -104,12 +104,12 @@ protected void AssertCode(params string[] expected)
             var rewriter = GetRtlStream(mem, frame, host).GetEnumerator();
             while (i < expected.Length && rewriter.MoveNext())
             {
-                Assert.AreEqual(expected[i], string.Format("{0}|{1}|{2}", i, RtlInstruction.FormatClass(rewriter.Current.Class), rewriter.Current));
+                Assert.AreEqual(expected[i], $"{i}|{RtlInstruction.FormatClass(rewriter.Current.Class)}|{rewriter.Current}");
                 ++i;
                 var ee = rewriter.Current.Instructions.OfType<RtlInstruction>().GetEnumerator();
                 while (i < expected.Length && ee.MoveNext())
                 {
-                    Assert.AreEqual(expected[i], string.Format("{0}|{1}|{2}", i, RtlInstruction.FormatClass(ee.Current.Class), ee.Current));
+                    Assert.AreEqual(expected[i], $"{i}|{RtlInstruction.FormatClass(ee.Current.Class)}|{ee.Current}");
                     ++i;
                 }
             }
diff --git a/src/UnitTests/Arch/Sparc/SparcRewriterTests.cs b/src/UnitTests/Arch/Sparc/SparcRewriterTests.cs
index 7abbd0311..40522d706 100644
--- a/src/UnitTests/Arch/Sparc/SparcRewriterTests.cs
+++ b/src/UnitTests/Arch/Sparc/SparcRewriterTests.cs
@@ -100,7 +100,7 @@ private MachineOperand Op(object o)
             {
             case RegisterStorage reg: return new RegisterOperand(reg);
             case Constant c: return new ImmediateOperand(c);
-            default: throw new NotImplementedException(string.Format("Unsupported: {0} ({1})", o, o.GetType().Name));
+            default: throw new NotImplementedException($"Unsupported: {o} ({o.GetType().Name})");
             }
         }
 
diff --git a/src/UnitTests/Arch/X86/X86DisassemblerTests.cs b/src/UnitTests/Arch/X86/X86DisassemblerTests.cs
index ec274b358..deed68276 100644
--- a/src/UnitTests/Arch/X86/X86DisassemblerTests.cs
+++ b/src/UnitTests/Arch/X86/X86DisassemblerTests.cs
@@ -283,7 +283,7 @@ foo		proc
             StringBuilder sb = new StringBuilder();
             foreach (var ii in dasm.Take(4))
             {
-                sb.AppendLine(string.Format("{0}", ii.ToString()));
+                sb.AppendLine($"{ii.ToString()}");
             }
             string s = sb.ToString();
             Assert.AreEqual(
diff --git a/src/UnitTests/Arch/X86/X86InstructionComparer.Tests.cs b/src/UnitTests/Arch/X86/X86InstructionComparer.Tests.cs
index 8c9e73213..384c87bba 100644
--- a/src/UnitTests/Arch/X86/X86InstructionComparer.Tests.cs
+++ b/src/UnitTests/Arch/X86/X86InstructionComparer.Tests.cs
@@ -38,13 +38,13 @@ private MachineOperand Op(object o)
                 return null;
             if (o is MachineOperand)
                 return (MachineOperand)o;
-            if (o is int)
+            if (o is int i)
             {
-                return new ImmediateOperand(Constant.Word32((int)o));
+                return new ImmediateOperand(Constant.Word32(i));
             }
-            else if (o is string)
+            else if (o is string s)
             {
-                return new RegisterOperand(Registers.GetRegister((string)o));
+                return new RegisterOperand(Registers.GetRegister(s));
             }
             else
                 throw new NotImplementedException();
diff --git a/src/UnitTests/Core/Lib/SuffixArrayTests.cs b/src/UnitTests/Core/Lib/SuffixArrayTests.cs
index 497d27a43..cd9b005a7 100644
--- a/src/UnitTests/Core/Lib/SuffixArrayTests.cs
+++ b/src/UnitTests/Core/Lib/SuffixArrayTests.cs
@@ -69,8 +69,8 @@ public void Test3()
 
             for (int i = 0; i < str.Length; ++i)
             {
-                Assert.AreEqual(str.Substring(sa[i]), expectedSubstrs[i], String.Format("Wrong entry {0}", i));
-                Assert.AreEqual(sa.Lcp[i], expectedLcps[i], String.Format("Wrong LCP {0}", i));
+                Assert.AreEqual(str.Substring(sa[i]), expectedSubstrs[i], $"Wrong entry {i}");
+                Assert.AreEqual(sa.Lcp[i], expectedLcps[i], $"Wrong LCP {i}");
             }
         }
         /// <summary>
diff --git a/src/UnitTests/Environments/SysV/GccMangledNameParserTests.cs b/src/UnitTests/Environments/SysV/GccMangledNameParserTests.cs
index f299d4dfe..7edb4d6d8 100644
--- a/src/UnitTests/Environments/SysV/GccMangledNameParserTests.cs
+++ b/src/UnitTests/Environments/SysV/GccMangledNameParserTests.cs
@@ -118,7 +118,7 @@ public StringBuilder VisitPrimitive(PrimitiveType_v1 primitive)
                     }
                     break;
                 default:
-                    throw new NotSupportedException(string.Format("Domain {0} is not supported.", primitive.Domain));
+                    throw new NotSupportedException($"Domain {primitive.Domain} is not supported.");
                 }
                 if (name != null)
                     sb.AppendFormat(" {0}", name);
diff --git a/src/UnitTests/FileUnitTester.cs b/src/UnitTests/FileUnitTester.cs
index 8deb20507..4f441ecf5 100644
--- a/src/UnitTests/FileUnitTester.cs
+++ b/src/UnitTests/FileUnitTester.cs
@@ -40,15 +40,13 @@ public FileUnitTester(string testOutputFile)
 		private void Init(string testOutputFile)
 		{
 			this.testOutputFile = MapTestPath(testOutputFile);
-			this.testExpectedFile = string.Format("{0}/{1}.exp",
-				Path.GetDirectoryName(this.testOutputFile),
-				Path.GetFileNameWithoutExtension(this.testOutputFile));
+			this.testExpectedFile = $"{Path.GetDirectoryName(this.testOutputFile)}/{Path.GetFileNameWithoutExtension(this.testOutputFile)}.exp";
 			this.stm = new StreamWriter(this.testOutputFile, false, new UTF8Encoding(false));
 		}
 		
 		public static string MapTestPath(string relativePath)
 		{
-			return string.Format("{0}/{1}", TestDirectory, relativePath);
+			return $"{TestDirectory}/{relativePath}";
 		}
 
 		public static void RunTest(string testOutputFile, Action<FileUnitTester> handler)
@@ -99,9 +97,9 @@ public void CompareFiles(StreamReader expected, StreamReader test)
 
 				if (tstLine == null && expLine == null)
 					return;
-				Assert.IsNotNull(expLine, string.Format("File should have ended before line {0}", line));
-				Assert.IsNotNull(tstLine, string.Format("File ended unexpectedly at line {0}", line));
-				Assert.AreEqual(expLine, tstLine, string.Format("File differs on line {0}", line));
+				Assert.IsNotNull(expLine, $"File should have ended before line {line}");
+				Assert.IsNotNull(tstLine, $"File ended unexpectedly at line {line}");
+				Assert.AreEqual(expLine, tstLine, $"File differs on line {line}");
 				++line;
 			}
 		}
diff --git a/src/UnitTests/ImageLoaders/MzExe/PeImageLoaderTests.cs b/src/UnitTests/ImageLoaders/MzExe/PeImageLoaderTests.cs
index 2868ada29..31a87fd87 100644
--- a/src/UnitTests/ImageLoaders/MzExe/PeImageLoaderTests.cs
+++ b/src/UnitTests/ImageLoaders/MzExe/PeImageLoaderTests.cs
@@ -336,8 +336,7 @@ private int Given_Ilt32(params object [] import)
             writer.Position = rvaTable;                     // rewind to beginning of table.
             foreach (object imp in import)
             {
-                var s = imp as string;
-                if (s != null)
+                if (imp is string s)
                 {
                     writer.WriteLeInt32((int)strWriter.Position);
                     strWriter.WriteLeInt16(0);
@@ -369,8 +368,7 @@ private int Given_Ilt64(params object[] import)
             writer.Position = rvaTable;                     // rewind to beginning of table.
             foreach (object imp in import)
             {
-                var s = imp as string;
-                if (s != null)
+                if (imp is string s)
                 {
                     writer.WriteLeInt64((int)strWriter.Position);
                     strWriter.WriteLeInt16(0);
diff --git a/src/UnitTests/Mocks/FakeArchitecture.cs b/src/UnitTests/Mocks/FakeArchitecture.cs
index b6e600594..09267ff04 100644
--- a/src/UnitTests/Mocks/FakeArchitecture.cs
+++ b/src/UnitTests/Mocks/FakeArchitecture.cs
@@ -135,7 +135,7 @@ public override IEnumerable<RtlInstructionCluster> CreateRewriter(EndianImageRea
                 }
                 else
                 {
-                    Assert.Fail(string.Format("Unexpected request for a rewriter at address {0}", rdr.Address));
+                    Assert.Fail($"Unexpected request for a rewriter at address {rdr.Address}");
                 }
             }
             return trace;
diff --git a/src/UnitTests/Mocks/FakeDecompilerEventListener.cs b/src/UnitTests/Mocks/FakeDecompilerEventListener.cs
index 3fa880b8f..f28e44b69 100644
--- a/src/UnitTests/Mocks/FakeDecompilerEventListener.cs
+++ b/src/UnitTests/Mocks/FakeDecompilerEventListener.cs
@@ -134,7 +134,7 @@ public void Error(ICodeLocation location, Exception ex, string message, params o
 
         public void ShowProgress(string caption, int numerator, int denominator)
         {
-            lastProgress = string.Format("{0}: {1}%", caption, (numerator * 100) / (denominator != 0 ? denominator : 1));
+            lastProgress = $"{caption}: {(numerator * 100) / (denominator != 0 ? denominator : 1)}%";
         }
 
         public void Advance(int count)
diff --git a/src/UnitTests/Mocks/FakePlatform.cs b/src/UnitTests/Mocks/FakePlatform.cs
index 2394a4fc5..d1b0df648 100644
--- a/src/UnitTests/Mocks/FakePlatform.cs
+++ b/src/UnitTests/Mocks/FakePlatform.cs
@@ -87,7 +87,7 @@ public override int GetBitSizeFromCBasicType(CBasicType cb)
             case CBasicType.Double: return 64;
             case CBasicType.LongDouble: return 64;
             case CBasicType.Int64: return 64;
-            default: throw new NotImplementedException(string.Format("C basic type {0} not supported.", cb));
+            default: throw new NotImplementedException($"C basic type {cb} not supported.");
             }
         }
 
diff --git a/src/UnitTests/Mocks/ProcedureBuilder.cs b/src/UnitTests/Mocks/ProcedureBuilder.cs
index 90dacc7a8..3e8362743 100644
--- a/src/UnitTests/Mocks/ProcedureBuilder.cs
+++ b/src/UnitTests/Mocks/ProcedureBuilder.cs
@@ -249,7 +249,7 @@ private Block EnsureBlock(string name)
 
             if (name == null)
             {
-                name = string.Format("l{0}", ++numBlock);
+                name = $"l{++numBlock}";
             }
             Block = BlockOf(name);
             Block.Address = Address.Ptr32(LinearAddress);
diff --git a/src/UnitTests/Scanning/GlobalDataWorkItemTests.cs b/src/UnitTests/Scanning/GlobalDataWorkItemTests.cs
index 264f01b03..ee3c62860 100644
--- a/src/UnitTests/Scanning/GlobalDataWorkItemTests.cs
+++ b/src/UnitTests/Scanning/GlobalDataWorkItemTests.cs
@@ -54,7 +54,7 @@ public void Setup()
                 It.IsAny<Address>(),
                 It.IsAny<string>(),
                 It.IsAny<object[]>()))
-                .Callback((Address a, string s, object[] args) => { Assert.Fail(string.Format("{0}: {1}", a, string.Format(s, args))); });
+                .Callback((Address a, string s, object[] args) => { Assert.Fail($"{a}: {string.Format(s, args)}"); });
         }
 
         private void Given_Program(Address address, byte[] bytes)
diff --git a/src/UnitTests/Scanning/ValueSetEvaluatorTests.cs b/src/UnitTests/Scanning/ValueSetEvaluatorTests.cs
index 7c17d5556..071dd8ebf 100644
--- a/src/UnitTests/Scanning/ValueSetEvaluatorTests.cs
+++ b/src/UnitTests/Scanning/ValueSetEvaluatorTests.cs
@@ -118,8 +118,7 @@ private ValueSet CVS(params int[] values)
 
         private string DumpReads(Dictionary<Address, DataType> reads)
         {
-            return string.Format("({0})",
-                string.Join(",", reads.OrderBy(d => d.Key)));
+            return $"({string.Join(",", reads.OrderBy(d => d.Key))})";
         }
 
         [Test]
diff --git a/src/UnitTests/Structure/StructureAnalysisTests.cs b/src/UnitTests/Structure/StructureAnalysisTests.cs
index 816510123..5df4a2438 100644
--- a/src/UnitTests/Structure/StructureAnalysisTests.cs
+++ b/src/UnitTests/Structure/StructureAnalysisTests.cs
@@ -56,10 +56,7 @@ private void RunTest(string sExp, Procedure proc)
         {
             var cfgc = new ControlFlowGraphCleaner(proc);
             cfgc.Transform();
-            if (ccc != null)
-            {
-                ccc.Transform();
-            }
+            ccc?.Transform();
             var ps = new StructureAnalysis(new FakeDecompilerEventListener(), new Program(), proc);
             var reg = ps.Execute();
             var sb = new StringWriter();
diff --git a/src/UnitTests/TestSerializedTypeRenderer.cs b/src/UnitTests/TestSerializedTypeRenderer.cs
index 6f3125583..d3136c892 100644
--- a/src/UnitTests/TestSerializedTypeRenderer.cs
+++ b/src/UnitTests/TestSerializedTypeRenderer.cs
@@ -96,7 +96,7 @@ public StringBuilder VisitPrimitive(PrimitiveType_v1 primitive)
                 }
                 break;
             default:
-                throw new NotSupportedException(string.Format("Domain {0} is not supported.", primitive.Domain));
+                throw new NotSupportedException($"Domain {primitive.Domain} is not supported.");
             }
             if (name != null)
                 sb.AppendFormat(" {0}", name);
diff --git a/src/UnitTests/Typing/Trait.cs b/src/UnitTests/Typing/Trait.cs
index e65a80831..b8812ade4 100644
--- a/src/UnitTests/Typing/Trait.cs
+++ b/src/UnitTests/Typing/Trait.cs
@@ -81,7 +81,7 @@ public TraitEqual(TypeVariable typeOther)
 
 		public override string ToString()
 		{
-			return string.Format("trait_equal({0})", TypeOther);
+			return $"trait_equal({TypeOther})";
 		}
 	}
 
@@ -97,7 +97,7 @@ public TraitDataType(DataType dt)
 
 		public override string ToString()
 		{
-			return string.Format("trait_primitive({0})", dt);
+			return $"trait_primitive({dt})";
 		}
 
 		public DataType DataType
@@ -175,7 +175,7 @@ public TraitMemSize(int size)
 
 		public override string ToString()
 		{
-			return string.Format("trait_memsize({0})", Size);
+			return $"trait_memsize({Size})";
 		}
 
 	}
@@ -195,7 +195,7 @@ public TraitArray(int elementSize, int length)
 
 		public override string ToString()
 		{
-			return string.Format("trait_array({0}, {1})", ElementSize, Length);
+			return $"trait_array({ElementSize}, {Length})";
 		}
 	}
 
@@ -274,7 +274,7 @@ public TraitPointer(TypeVariable pointee)
 
 		public override string ToString()
 		{
-			return string.Format("trait_ptr({0}", pointee);
+			return $"trait_ptr({pointee}";
 		}
 	}
 	///
@@ -290,7 +290,7 @@ public TraitConstant(Constant c)
 
 		public override string ToString()
 		{
-			return string.Format("trait_const({0})", Value);
+			return $"trait_const({Value})";
 		}
 	}
 }
diff --git a/src/UserInterfaces/WindowsForms/CallGraphPane.cs b/src/UserInterfaces/WindowsForms/CallGraphPane.cs
index e8d302280..3d40f83ee 100644
--- a/src/UserInterfaces/WindowsForms/CallGraphPane.cs
+++ b/src/UserInterfaces/WindowsForms/CallGraphPane.cs
@@ -44,10 +44,7 @@ public CallGraphPane(Program program)
 
         public void Close()
         {
-            if (Control != null)
-            {
-                Control.Dispose();
-            }
+            Control?.Dispose();
             Control = null;
         }
 
diff --git a/src/UserInterfaces/WindowsForms/CfgBlockNode.cs b/src/UserInterfaces/WindowsForms/CfgBlockNode.cs
index 43a73d569..de7082b78 100644
--- a/src/UserInterfaces/WindowsForms/CfgBlockNode.cs
+++ b/src/UserInterfaces/WindowsForms/CfgBlockNode.cs
@@ -107,16 +107,14 @@ static System.Drawing.Drawing2D.GraphicsPath FillTheGraphicsPath(ICurve iCurve)
         private static void AddSegmentToPath(ICurve seg, ref System.Drawing.Drawing2D.GraphicsPath p)
         {
             const float radiansToDegrees = (float)(180.0 / Math.PI);
-            LineSegment line = seg as LineSegment;
-            if (line != null)
+
+            if (seg is LineSegment line)
                 p.AddLine(PointF(line.Start), PointF(line.End));
             else {
-                CubicBezierSegment cb = seg as CubicBezierSegment;
-                if (cb != null)
+                if (seg is CubicBezierSegment cb)
                     p.AddBezier(PointF(cb.B(0)), PointF(cb.B(1)), PointF(cb.B(2)), PointF(cb.B(3)));
                 else {
-                    Ellipse ellipse = seg as Ellipse;
-                    if (ellipse != null)
+                    if (seg is Ellipse ellipse)
                         p.AddArc((float)(ellipse.Center.X - ellipse.AxisA.Length), (float)(ellipse.Center.Y - ellipse.AxisB.Length),
                             (float)(2 * ellipse.AxisA.Length), (float)(2 * ellipse.AxisB.Length), (float)(ellipse.ParStart * radiansToDegrees),
                             (float)((ellipse.ParEnd - ellipse.ParStart) * radiansToDegrees));
diff --git a/src/UserInterfaces/WindowsForms/CodeViewInteractor.cs b/src/UserInterfaces/WindowsForms/CodeViewInteractor.cs
index 194f6e1fd..fa41a37d3 100644
--- a/src/UserInterfaces/WindowsForms/CodeViewInteractor.cs
+++ b/src/UserInterfaces/WindowsForms/CodeViewInteractor.cs
@@ -293,9 +293,8 @@ private Address CodeView_GetAnchorAddress()
             var pt = codeView.GetAnchorMiddlePoint();
             var tag = codeView.GetTagFromPoint(pt);
             var addr = tag as Address;
-            var proc = tag as Procedure;
 
-            if (proc != null)
+            if (tag is Procedure proc)
                 addr = proc.EntryAddress;
 
             return addr;
@@ -365,9 +364,8 @@ public void ViewCode()
         void TextView_Navigate(object sender, EditorNavigationArgs e)
         {
             var addr = e.Destination as Address;
-            var proc = e.Destination as Procedure;
 
-            if (proc != null)
+            if (e.Destination is Procedure proc)
                 addr = proc.EntryAddress;
 
             if (addr == null)
diff --git a/src/UserInterfaces/WindowsForms/Controls/CommandMenuItem.cs b/src/UserInterfaces/WindowsForms/Controls/CommandMenuItem.cs
index f8c4c0c05..f3dc7e3ab 100644
--- a/src/UserInterfaces/WindowsForms/Controls/CommandMenuItem.cs
+++ b/src/UserInterfaces/WindowsForms/Controls/CommandMenuItem.cs
@@ -76,7 +76,7 @@ public bool IsTemporary
 
         public override string ToString()
         {
-            return string.Format("{0} {1} {2}", Text, IsDynamic ? "Dyn" : "", IsTemporary ? "Tmp" : "   ");
+            return $"{Text} {(IsDynamic ? "Dyn" : "")} {(IsTemporary ? "Tmp" : "   ")}";
         }
 
 		public MenuCommand MenuCommand
diff --git a/src/UserInterfaces/WindowsForms/Controls/MemoryControl.cs b/src/UserInterfaces/WindowsForms/Controls/MemoryControl.cs
index c7e65357c..47644e81a 100644
--- a/src/UserInterfaces/WindowsForms/Controls/MemoryControl.cs
+++ b/src/UserInterfaces/WindowsForms/Controls/MemoryControl.cs
@@ -685,7 +685,7 @@ private Address PaintLine(Graphics g, Rectangle rc, EndianImageReader rdr, Point
                 // Draw the address part.
 
                 rc.X = 0;
-                string s = string.Format("{0}", rdr.Address);
+                string s = $"{rdr.Address}";
                 int cx = (int)g.MeasureString(s + "X", ctrl.Font, rc.Width, StringFormat.GenericTypographic).Width;
                 if (!render && new Rectangle(rc.X, rc.Y, cx, rc.Height).Contains(ctrl.ptDown))
                 {
@@ -733,7 +733,7 @@ private Address PaintLine(Graphics g, Rectangle rc, EndianImageReader rdr, Point
                         if (rdr.IsValid)
                         {
                             byte b = rdr.ReadByte();
-                            s = string.Format("{0:X2}", b);
+                            s = $"{b:X2}";
                             abCode.Add(b);
                         }
                         else
diff --git a/src/UserInterfaces/WindowsForms/Controls/MixedCodeDataModel.SpanGenerator.cs b/src/UserInterfaces/WindowsForms/Controls/MixedCodeDataModel.SpanGenerator.cs
index b3ebe81ae..ab7c2de03 100644
--- a/src/UserInterfaces/WindowsForms/Controls/MixedCodeDataModel.SpanGenerator.cs
+++ b/src/UserInterfaces/WindowsForms/Controls/MixedCodeDataModel.SpanGenerator.cs
@@ -245,7 +245,7 @@ private class MemSpanifyer : SpanGenerator
                     {
                         var addr1 = rdr.Address;
                         byte b = rdr.ReadByte();
-                        line.Add(new MemoryTextSpan(addr1, string.Format(" {0:X2}", b), UiStyles.MemoryWindow));
+                        line.Add(new MemoryTextSpan(addr1, $" {b:X2}", UiStyles.MemoryWindow));
                         //$BUG: should use platform.Encoding
                         abCode.Add(b);
                     }
diff --git a/src/UserInterfaces/WindowsForms/Controls/TextPointer.cs b/src/UserInterfaces/WindowsForms/Controls/TextPointer.cs
index efed882bd..b71fa9257 100644
--- a/src/UserInterfaces/WindowsForms/Controls/TextPointer.cs
+++ b/src/UserInterfaces/WindowsForms/Controls/TextPointer.cs
@@ -45,7 +45,7 @@ public TextPointer(object line, int span, int ch)
 
         public override string ToString()
         {
-            return string.Format("{0}:{1}:{2}", Line, Span, Character);
+            return $"{Line}:{Span}:{Character}";
         }
     }
 }
diff --git a/src/UserInterfaces/WindowsForms/Controls/TextView.cs b/src/UserInterfaces/WindowsForms/Controls/TextView.cs
index 63707aa56..eac750f08 100644
--- a/src/UserInterfaces/WindowsForms/Controls/TextView.cs
+++ b/src/UserInterfaces/WindowsForms/Controls/TextView.cs
@@ -254,7 +254,7 @@ protected override void OnMouseUp(MouseEventArgs e)
                 {
                     cursorPos = anchorPos = pos;
                     var span = GetSpan(e.Location);
-                    if (span != null && span.Tag != null)
+                    if (span?.Tag != null)
                     {
                         Navigate.Fire(this, new EditorNavigationArgs(span.Tag));
                     }
@@ -265,7 +265,7 @@ protected override void OnMouseUp(MouseEventArgs e)
                     if (IsSelectionEmpty())
                     {
                         var span = GetSpan(e.Location);
-                        if (span != null && span.Tag != null)
+                        if (span?.Tag != null)
                         {
                             Navigate.Fire(this, new EditorNavigationArgs(span.Tag));
                         }
diff --git a/src/UserInterfaces/WindowsForms/DisassemblyViewInteractor.cs b/src/UserInterfaces/WindowsForms/DisassemblyViewInteractor.cs
index 0e0d4e8bf..d601d282a 100644
--- a/src/UserInterfaces/WindowsForms/DisassemblyViewInteractor.cs
+++ b/src/UserInterfaces/WindowsForms/DisassemblyViewInteractor.cs
@@ -121,8 +121,7 @@ internal void ClearText()
         private bool IsProgramLoaded(Program program)
         {
             return
-                program != null &&
-                program.Architecture != null &&
+program?.Architecture != null &&
                 program.ImageMap != null &&
                 StartAddress != null;
         }
diff --git a/src/UserInterfaces/WindowsForms/Forms/AboutDialog.cs b/src/UserInterfaces/WindowsForms/Forms/AboutDialog.cs
index 0a7f3b646..0de5bff4a 100644
--- a/src/UserInterfaces/WindowsForms/Forms/AboutDialog.cs
+++ b/src/UserInterfaces/WindowsForms/Forms/AboutDialog.cs
@@ -34,11 +34,8 @@ partial class AboutDialog : Form, IAboutDialog
         public AboutDialog()
         {
             InitializeComponent();
-            this.Text = String.Format("About {0}", AssemblyTitle);
-            this.lblVersion.Text = String.Format(
-                "Version {0} ({1})",
-                AssemblyVersion,
-                Environment.Is64BitProcess ? "64-bit" : "32-bit");
+            this.Text = $"About {AssemblyTitle}";
+            this.lblVersion.Text = $"Version {AssemblyVersion} ({(Environment.Is64BitProcess ? "64-bit" : "32-bit")})";
             linkLabel1.LinkClicked += delegate(object o, LinkLabelLinkClickedEventArgs e)
             {
                 System.Diagnostics.Process.Start(linkLabel1.Text);
diff --git a/src/UserInterfaces/WindowsForms/Forms/AddressPromptDialog.Designer.cs b/src/UserInterfaces/WindowsForms/Forms/AddressPromptDialog.Designer.cs
index 8e0deb2d3..9e9480405 100644
--- a/src/UserInterfaces/WindowsForms/Forms/AddressPromptDialog.Designer.cs
+++ b/src/UserInterfaces/WindowsForms/Forms/AddressPromptDialog.Designer.cs
@@ -101,10 +101,7 @@ protected override void Dispose(bool disposing)
         {
             if (disposing)
             {
-                if (components != null)
-                {
-                    components.Dispose();
-                }
+                components?.Dispose();
             }
             base.Dispose(disposing);
         }
diff --git a/src/UserInterfaces/WindowsForms/Forms/ArchiveBrowserService.cs b/src/UserInterfaces/WindowsForms/Forms/ArchiveBrowserService.cs
index f6dbcee17..ac2873c5b 100644
--- a/src/UserInterfaces/WindowsForms/Forms/ArchiveBrowserService.cs
+++ b/src/UserInterfaces/WindowsForms/Forms/ArchiveBrowserService.cs
@@ -99,8 +99,8 @@ private void Populate(ICollection<ArchiveDirectoryEntry> archiveEntries, TreeNod
                     TreeNode node = new TreeNode();
                     node.Text = entry.Name;
                     node.Tag = entry;
-                    ArchivedFolder folder = entry as ArchivedFolder;
-                    if (folder != null)
+
+                    if (entry is ArchivedFolder folder)
                     {
                         Populate(folder.Items, node.Nodes);
                     }
diff --git a/src/UserInterfaces/WindowsForms/Forms/DiagnosticsInteractor.cs b/src/UserInterfaces/WindowsForms/Forms/DiagnosticsInteractor.cs
index 1902d97bf..84b1d04d7 100644
--- a/src/UserInterfaces/WindowsForms/Forms/DiagnosticsInteractor.cs
+++ b/src/UserInterfaces/WindowsForms/Forms/DiagnosticsInteractor.cs
@@ -216,8 +216,8 @@ protected void listView_DoubleClick(object sender, EventArgs e)
             var item = FocusedListItem;
             if (item == null)
                 return;
-            var location = item.Tag as ICodeLocation;
-            if (location != null)
+
+            if (item.Tag is ICodeLocation location)
                 location.NavigateTo();
         }
 
diff --git a/src/UserInterfaces/WindowsForms/ImageSegmentPane.cs b/src/UserInterfaces/WindowsForms/ImageSegmentPane.cs
index c83603040..fa31936f1 100644
--- a/src/UserInterfaces/WindowsForms/ImageSegmentPane.cs
+++ b/src/UserInterfaces/WindowsForms/ImageSegmentPane.cs
@@ -47,8 +47,7 @@ public object CreateControl()
 
         void TextView_Navigate(object sender, EditorNavigationArgs e)
         {
-            var addr = e.Destination as Address;
-            if (addr !=null)
+            if (e.Destination is Address addr)
             {
                 var svc = services.RequireService<ILowLevelViewService>();
                 svc.ShowMemoryAtAddress(program, addr);
diff --git a/src/UserInterfaces/WindowsForms/ResourceEditorService.cs b/src/UserInterfaces/WindowsForms/ResourceEditorService.cs
index 3ef00b4f9..a4ed0c4e1 100644
--- a/src/UserInterfaces/WindowsForms/ResourceEditorService.cs
+++ b/src/UserInterfaces/WindowsForms/ResourceEditorService.cs
@@ -55,7 +55,7 @@ public void Show(Program program, ProgramResourceInstance resource)
 
         private string ResourceToString(ProgramResourceInstance resource)
         {
-            return string.Format("{0}:{1}", resource.Type, resource.Name);
+            return $"{resource.Type}:{resource.Name}";
         }
     }
 }
diff --git a/src/UserInterfaces/WindowsForms/TabControlHost.cs b/src/UserInterfaces/WindowsForms/TabControlHost.cs
index 3b07dfedf..45493bd1c 100644
--- a/src/UserInterfaces/WindowsForms/TabControlHost.cs
+++ b/src/UserInterfaces/WindowsForms/TabControlHost.cs
@@ -66,7 +66,7 @@ public bool ContainsFocus
 
         private TabPage FindPage(IWindowFrame frame)
         {
-            return tabCtrl.TabPages.Cast<TabPage>().Where(p => p.Tag == frame).FirstOrDefault();
+            return tabCtrl.TabPages.Cast<TabPage>().FirstOrDefault(p => p.Tag == frame);
         }
 
         public bool QueryStatus(CommandID cmdId, CommandStatus status, CommandText text)
diff --git a/src/UserInterfaces/WindowsForms/UiPreferenceService.cs b/src/UserInterfaces/WindowsForms/UiPreferenceService.cs
index af5f78c4b..960ce88ae 100644
--- a/src/UserInterfaces/WindowsForms/UiPreferenceService.cs
+++ b/src/UserInterfaces/WindowsForms/UiPreferenceService.cs
@@ -194,8 +194,8 @@ private void SetStyle(string name)
         {
             var defStyle = configSvc
                 .GetDefaultPreferences()
-                .Where(s => s.Name == name)
-                .Single();
+                .Single(s => s.Name == name)
+;
 
             var snames = this.SettingNames[name];
 
diff --git a/src/UserInterfaces/WindowsForms/WindowsFormsDialogFactory.cs b/src/UserInterfaces/WindowsForms/WindowsFormsDialogFactory.cs
index d0dd60eee..63cec64d1 100644
--- a/src/UserInterfaces/WindowsForms/WindowsFormsDialogFactory.cs
+++ b/src/UserInterfaces/WindowsForms/WindowsFormsDialogFactory.cs
@@ -82,7 +82,7 @@ public IAssembleFileDialog CreateAssembleFileDialog()
 
         public ICallSiteDialog CreateCallSiteDialog(Program program, UserCallData ucd)
         {
-            Debug.Assert(ucd != null && ucd.Address != null);
+            Debug.Assert(ucd?.Address != null);
             var dlg = new CallSiteDialog();
             dlg.Address = ucd.Address;
             dlg.NoReturn.Checked = ucd.NoReturn;
diff --git a/src/WindowsItp/TreeViewDialog.cs b/src/WindowsItp/TreeViewDialog.cs
index 2ba73ebd6..f7f4b7c19 100644
--- a/src/WindowsItp/TreeViewDialog.cs
+++ b/src/WindowsItp/TreeViewDialog.cs
@@ -141,7 +141,7 @@ private void DisplayElapsedTime(Action action)
             sw.Start();
             action();
             sw.Stop();
-            lblResult.Text = string.Format("Elapsed time: {0}", sw.Elapsed);
+            lblResult.Text = $"Elapsed time: {sw.Elapsed}";
         }
 
         private void btnClear_Click(object sender, EventArgs e)
diff --git a/src/tools/genPICdb/Program.cs b/src/tools/genPICdb/Program.cs
index df1edeba4..e086929ff 100644
--- a/src/tools/genPICdb/Program.cs
+++ b/src/tools/genPICdb/Program.cs
@@ -1,3 +1,4 @@
+using System.Linq;
 #region License
 /* 
  *
@@ -147,7 +148,7 @@ private static XDocument pruneAndPatch(XDocument xdoc)
             {
                 if (e.Name.Namespace != XNamespace.None)
                     e.Name = XNamespace.None.GetName(e.Name.LocalName);
-                if (e.Attributes().Where(a => a.IsNamespaceDeclaration || a.Name.Namespace != XNamespace.None).Any())
+                if (e.Attributes().Any(a => a.IsNamespaceDeclaration || a.Name.Namespace != XNamespace.None))
                     e.ReplaceAttributes(e.Attributes().Select(a => a.IsNamespaceDeclaration ? null : a.Name.Namespace != XNamespace.None ? new XAttribute(XNamespace.None.GetName(a.Name.LocalName), a.Value) : a));
             }
 
@@ -297,7 +298,7 @@ private static bool acceptPICEntry(ZipArchiveEntry picentry, Func<string, bool>
         // Writes the list of PIC parts information to the compressed PIC database.
         private static void writePartsInfo(ZipArchive zout)
         {
-            if (picPartsInfo.Parts.Count() <= 0)
+            if (!picPartsInfo.Parts.Any())
                 return;
             picPartsInfo.Version = mplabLoc.Version;
             var xdoc = new XDocument(new XDeclaration("1.0", "utf-8", "yes"));
@@ -476,7 +477,7 @@ public int Execute(string[] args)
             }
 #endif
 
-            if (args.Count() > 0)
+            if (args.Any())
             {
                 var filePath = args[0];
                 picLocalDBFilePath = Path.Combine(workingDir, filePath);
diff --git a/src/tools/hunktool/HunkShow.cs b/src/tools/hunktool/HunkShow.cs
index e65bdf1ce..7c67548cb 100644
--- a/src/tools/hunktool/HunkShow.cs
+++ b/src/tools/hunktool/HunkShow.cs
@@ -137,7 +137,7 @@ public virtual void show_segment(List<Hunk> hunk, List<List<Hunk>> seg_list)
             name = "";
             if (!string.IsNullOrEmpty(hunk[0].Name))
             {
-                name = String.Format("'{0}'", main.Name);
+                name = $"'{main.Name}'";
             }
             var type_name = main.HunkType.ToString().Replace("HUNK_", "");
             size = main.size;
@@ -183,24 +183,24 @@ public virtual void show_index_info(IHunk info)
             // references from index
             if (info.refs != null && info.refs.Count > 0)
             {
-                this.print_extra("refs", string.Format("#{0}", info.refs.Count));
+                this.print_extra("refs", $"#{info.refs.Count}");
                 if (!this.brief)
                 {
                     foreach (var @ref in info.refs)
                     {
-                        this.print_symbol(~0u, @ref.name, string.Format("({0} bits)", @ref.bits));
+                        this.print_symbol(~0u, @ref.name, $"({@ref.bits} bits)");
                     }
                 }
             }
                         // defines from index
             if (info.defs != null && info.defs.Count > 0)
             {
-                this.print_extra("defs", string.Format("#{0}", info.defs.Count));
+                this.print_extra("defs", $"#{info.defs.Count}");
                 if (!this.brief)
                 {
                     foreach (var d in info.defs)
                     {
-                        this.print_symbol((uint) d.value, d.name, string.Format("(type {0})", d.type));
+                        this.print_symbol((uint) d.value, d.name, $"(type {d.type})");
                     }
                 }
             }
@@ -212,7 +212,7 @@ public virtual void show_extra_hunk(Hunk hunk)
             if (HunkFileParser.reloc_hunks.Contains(hunk_type))
             {
                 var type_name = hunk.HunkType.ToString().Replace("HUNK_", "").ToLower();
-                this.print_extra("reloc", String.Format("{0} #{1}", type_name, ((RelocHunk)hunk).reloc));
+                this.print_extra("reloc", $"{type_name} #{((RelocHunk)hunk).reloc}");
                 if (!this.brief)
                 {
                     this.show_reloc_hunk((RelocHunk)hunk);
@@ -229,7 +229,7 @@ public virtual void show_extra_hunk(Hunk hunk)
             else if (hunk_type == HunkType.HUNK_SYMBOL)
             {
                 var h = (SymbolHunk)hunk;
-                this.print_extra("symbol", String.Format("#{0}", h.symbols.Count));
+                this.print_extra("symbol", $"#{h.symbols.Count}");
                 if (!this.brief)
                 {
                     this.show_symbol_hunk(h);
@@ -247,7 +247,7 @@ public virtual void show_extra_hunk(Hunk hunk)
             }
             else
             {
-                this.print_extra("extra", String.Format("{0}", hunk.HunkType));
+                this.print_extra("extra", $"{hunk.HunkType}");
             }
         }
 
@@ -261,15 +261,15 @@ public virtual void show_reloc_hunk(RelocHunk hunk)
                 {
                     foreach (var offset in offsets)
                     {
-                        this.print_symbol(offset, string.Format("Segment #{0}", hunk_num), "");
+                        this.print_symbol(offset, $"Segment #{hunk_num}", "");
                     }
                 }
                 else
                 {
-                    this.print_extra_sub(String.Format("To Segment #{0}: {1,4} entries", hunk_num, offsets.Count));
+                    this.print_extra_sub($"To Segment #{hunk_num}: {offsets.Count, 4} entries");
                     foreach (var off in offsets)
                     {
-                        this.print_extra_sub(string.Format("\t{0:X8}", off));
+                        this.print_extra_sub($"\t{off:X8}");
                     }
                 }
             }
@@ -280,14 +280,14 @@ public virtual void show_debug_hunk(DebugHunk hunk)
             var debug_type = hunk.debug_type;
             if (debug_type == "LINE")
             {
-                this.print_extra_sub(String.Format("line for '{0}'", hunk.src_file));
+                this.print_extra_sub($"line for '{hunk.src_file}'");
                 if (this.show_debug)
                 {
                     foreach (var src_off in hunk.src_map)
                     {
                         var addr = src_off.Value;
                         var line = src_off.Key;
-                        this.print_symbol(addr, String.Format("line {0}", line), "");
+                        this.print_symbol(addr, $"line {line}", "");
                     }
                 }
             }
@@ -371,14 +371,14 @@ public virtual void print_symbol(uint addr, string name, object extra)
             }
             else
             {
-                a = String.Format("{0:X8}", addr);
+                a = $"{addr:X8}";
             }
-            Console.WriteLine(String.Format("\t\t\t{0}  {1,-32}  {2}", a, name, extra));
+            Console.WriteLine($"\t\t\t{a}  {name, -32}  {extra}");
         }
 
         public virtual void print_unit(object no, object name)
         {
-            Console.WriteLine(String.Format("  #{0,3}  UNIT  {1}", no, name));
+            Console.WriteLine($"  #{no, 3}  UNIT  {name}");
         }
 
         private void print_hex(byte[] bytes, int indent = 0)
@@ -387,7 +387,7 @@ private void print_hex(byte[] bytes, int indent = 0)
             {
                 Console.WriteLine("{0}{1}",
                     new string(' ', indent),
-                    string.Join(" ", line.Select(b => string.Format("{0:X2}", (int)b))));
+                    string.Join(" ", line.Select(b => $"{(int)b:X2}")));
             }
         }
 
diff --git a/src/tools/hunktool/SignatureGenerator.cs b/src/tools/hunktool/SignatureGenerator.cs
index a0a6e61ae..ffa2e8bdd 100644
--- a/src/tools/hunktool/SignatureGenerator.cs
+++ b/src/tools/hunktool/SignatureGenerator.cs
@@ -156,7 +156,7 @@ private int SizeOfRef(ExtType ext)
                 return 2;
             case ExtType.EXT_DEF: return 4;
             case ExtType.EXT_ABSREF32: return 4;
-            default: throw new NotImplementedException(string.Format("Unknown {0}", ext));
+            default: throw new NotImplementedException($"Unknown {ext}");
             }
         }
     }
