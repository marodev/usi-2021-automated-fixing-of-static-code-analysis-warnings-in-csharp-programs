diff --git a/Duplicati/CommandLine/BackendTester/Program.cs b/Duplicati/CommandLine/BackendTester/Program.cs
index 3537472a4..4629b2777 100644
--- a/Duplicati/CommandLine/BackendTester/Program.cs
+++ b/Duplicati/CommandLine/BackendTester/Program.cs
@@ -280,8 +280,8 @@ namespace Duplicati.CommandLine.BackendTester
 
                     TempFile originalRenamedFile = null;
                     string renamedFileNewName = null;
-                    IRenameEnabledBackend renameEnabledBackend = backend as IRenameEnabledBackend;
-                    if (renameEnabledBackend != null)
+
+                    if (backend is IRenameEnabledBackend renameEnabledBackend)
                     {
                         // Rename the second file in the list, if there are more than one. If not, just do the first one.
                         int renameIndex = files.Count > 1 ? 1 : 0;
@@ -401,7 +401,7 @@ namespace Duplicati.CommandLine.BackendTester
                     {
                         using (Duplicati.Library.Utility.TempFile tempFile = new Duplicati.Library.Utility.TempFile())
                         {
-                            backend.Get(string.Format("NonExistentFile-{0}", Guid.NewGuid()), tempFile.Name);
+                            backend.Get($"NonExistentFile-{Guid.NewGuid()}", tempFile.Name);
                         }
                     }
                     catch (FileMissingException)
@@ -419,10 +419,9 @@ namespace Duplicati.CommandLine.BackendTester
                         Console.WriteLine("*** Retrieval of non-existent file should have failed with FileMissingException");
                     }
                 }
-
-                // Test quota retrieval
-                IQuotaEnabledBackend quotaEnabledBackend = backend as IQuotaEnabledBackend;
-                if (quotaEnabledBackend != null)
+
+                // Test quota retrieval
+                if (backend is IQuotaEnabledBackend quotaEnabledBackend)
                 {
                     Console.WriteLine("Checking quota...");
                     IQuotaInfo quota = null;
diff --git a/Duplicati/CommandLine/BackendTool/Program.cs b/Duplicati/CommandLine/BackendTool/Program.cs
index 0b30706cd..ca2db0fed 100644
--- a/Duplicati/CommandLine/BackendTool/Program.cs
+++ b/Duplicati/CommandLine/BackendTool/Program.cs
@@ -99,7 +99,7 @@ namespace Duplicati.CommandLine.BackendTool
                     if (command == "list")
                     {
                         if (args.Count != 2)
-                            throw new UserInformationException(string.Format("too many arguments: {0}", string.Join(",", args)), "BackendToolTooManyArguments");
+                            throw new UserInformationException($"too many arguments: {string.Join(",", args)}", "BackendToolTooManyArguments");
                         Console.WriteLine("{0}\t{1}\t{2}\t{3}", "Name", "Dir/File", "LastChange", "Size");
                     
                         foreach(var e in backend.List())
@@ -110,7 +110,7 @@ namespace Duplicati.CommandLine.BackendTool
                     else if (command == "create")
                     {
                         if (args.Count != 2)
-                            throw new UserInformationException(string.Format("too many arguments: {0}", string.Join(",", args)), "BackendToolTooManyArguments");
+                            throw new UserInformationException($"too many arguments: {string.Join(",", args)}", "BackendToolTooManyArguments");
 
                         backend.CreateFolder();
                         
@@ -121,7 +121,7 @@ namespace Duplicati.CommandLine.BackendTool
                         if (args.Count < 3)
                             throw new UserInformationException("DELETE requires a filename argument", "BackendToolDeleteRequiresAnArgument");
                         if (args.Count > 3)
-                            throw new Exception(string.Format("too many arguments: {0}", string.Join(",", args)));
+                            throw new Exception($"too many arguments: {string.Join(",", args)}");
                         backend.Delete(Path.GetFileName(args[2]));
                         
                         return 0;
@@ -131,7 +131,7 @@ namespace Duplicati.CommandLine.BackendTool
                         if (args.Count < 3)
                             throw new UserInformationException("GET requires a filename argument", "BackendToolGetRequiresAnArgument");
                         if (args.Count > 3)
-                            throw new UserInformationException(string.Format("too many arguments: {0}", string.Join(",", args)), "BackendToolTooManyArguments");
+                            throw new UserInformationException($"too many arguments: {string.Join(",", args)}", "BackendToolTooManyArguments");
                         if (File.Exists(args[2]))
                             throw new UserInformationException("File already exists, not overwriting!", "BackendToolFileAlreadyExists");
                         backend.Get(Path.GetFileName(args[2]), args[2]);
@@ -143,7 +143,7 @@ namespace Duplicati.CommandLine.BackendTool
                         if (args.Count < 3)
                             throw new UserInformationException("PUT requires a filename argument","BackendToolPutRequiresAndArgument");
                         if (args.Count > 3)
-                            throw new UserInformationException(string.Format("too many arguments: {0}", string.Join(",", args)), "BackendToolTooManyArguments");
+                            throw new UserInformationException($"too many arguments: {string.Join(",", args)}", "BackendToolTooManyArguments");
                            
                         backend.PutAsync(Path.GetFileName(args[2]), args[2], CancellationToken.None).Wait();
                         
diff --git a/Duplicati/CommandLine/Commands.cs b/Duplicati/CommandLine/Commands.cs
index 74523762c..ee37e07fa 100644
--- a/Duplicati/CommandLine/Commands.cs
+++ b/Duplicati/CommandLine/Commands.cs
@@ -523,7 +523,7 @@ namespace Duplicati.CommandLine
             using(var output = new ConsoleOutput(outwriter, options))
             using (var i = new Library.Main.Controller(backend, options, output))
             {
-                output.MessageEvent(string.Format("Restore started at {0}", DateTime.Now));
+                output.MessageEvent($"Restore started at {DateTime.Now}");
                 setup(i);
                 if (controlFiles)
                 {
@@ -565,14 +565,14 @@ namespace Duplicati.CommandLine
 
                         periodicOutput.WriteOutput += (progress, files, size, counting) =>
                         {
-                            output.MessageEvent(string.Format("  {0} files need to be restored ({1})", files, Library.Utility.Utility.FormatSizeString(size)));
+                            output.MessageEvent($"  {files} files need to be restored ({Library.Utility.Utility.FormatSizeString(size)})");
                         };
 
                         var res = i.Restore(args.ToArray(), filter);
                         string restorePath;
                         options.TryGetValue("restore-path", out restorePath);
 
-                        output.MessageEvent(string.Format("Restored {0} ({1}) files to {2}", res.RestoredFiles, Library.Utility.Utility.FormatSizeString(res.SizeOfRestoredFiles), string.IsNullOrEmpty(restorePath) ? "original path" : restorePath));
+                        output.MessageEvent($"Restored {res.RestoredFiles} ({Library.Utility.Utility.FormatSizeString(res.SizeOfRestoredFiles)}) files to {(string.IsNullOrEmpty(restorePath) ? "original path" : restorePath)}");
                         output.MessageEvent(string.Format("Duration of restore: {0:hh\\:mm\\:ss}", res.Duration));
 
                         if (res.RestoredFiles > 0 && !Library.Main.Utility.SuppressDonationMessages)
@@ -614,7 +614,7 @@ namespace Duplicati.CommandLine
                         output.MessageEvent("The \"disable-on-battery\" option only affects scheduled backups and is ignored by backups run manually or from the command line.");
                     }
 
-                    output.MessageEvent(string.Format("Backup started at {0}", DateTime.Now));
+                    output.MessageEvent($"Backup started at {DateTime.Now}");
 
                     output.PhaseChanged += (phase, previousPhase) =>
                     {
@@ -647,7 +647,7 @@ namespace Duplicati.CommandLine
 
                     periodicOutput.WriteOutput += (progress, files, size, counting) =>
                     {
-                        output.MessageEvent(string.Format("  {0} files need to be examined ({1}){2}", files, Library.Utility.Utility.FormatSizeString(size), counting ? " (still counting)" : ""));
+                        output.MessageEvent($"  {files} files need to be examined ({Library.Utility.Utility.FormatSizeString(size)}){(counting ? " (still counting)" : "")}");
                     };
 
                     using (var i = new Library.Main.Controller(backend, options, output))
@@ -662,34 +662,33 @@ namespace Duplicati.CommandLine
                     Library.Utility.Utility.PrintSerializeObject(result, outwriter);
                     outwriter.WriteLine();
                 }
-
-                var parsedStats = result.BackendStatistics as Duplicati.Library.Interface.IParsedBackendStatistics;
                 output.MessageEvent(string.Format("  Duration of backup: {0:hh\\:mm\\:ss}", result.Duration));
-                if (parsedStats != null)
+
+                if (result.BackendStatistics is Duplicati.Library.Interface.IParsedBackendStatistics parsedStats)
                 {
                     if (parsedStats.KnownFileCount > 0)
                     {
-                        output.MessageEvent(string.Format("  Remote files: {0}", parsedStats.KnownFileCount));
-                        output.MessageEvent(string.Format("  Remote size: {0}", Library.Utility.Utility.FormatSizeString(parsedStats.KnownFileSize)));
+                        output.MessageEvent($"  Remote files: {parsedStats.KnownFileCount}");
+                        output.MessageEvent($"  Remote size: {Library.Utility.Utility.FormatSizeString(parsedStats.KnownFileSize)}");
                     }
 
                     if (parsedStats.TotalQuotaSpace >= 0)
                     {
-                        output.MessageEvent(string.Format("  Total remote quota: {0}", Library.Utility.Utility.FormatSizeString(parsedStats.TotalQuotaSpace)));
+                        output.MessageEvent($"  Total remote quota: {Library.Utility.Utility.FormatSizeString(parsedStats.TotalQuotaSpace)}");
                     }
 
                     if (parsedStats.FreeQuotaSpace >= 0)
                     {
-                        output.MessageEvent(string.Format("  Available remote quota: {0}", Library.Utility.Utility.FormatSizeString(parsedStats.FreeQuotaSpace)));
+                        output.MessageEvent($"  Available remote quota: {Library.Utility.Utility.FormatSizeString(parsedStats.FreeQuotaSpace)}");
                     }
                 }
 
-                output.MessageEvent(string.Format("  Files added: {0}", result.AddedFiles));
-                output.MessageEvent(string.Format("  Files deleted: {0}", result.DeletedFiles));
-                output.MessageEvent(string.Format("  Files changed: {0}", result.ModifiedFiles));
+                output.MessageEvent($"  Files added: {result.AddedFiles}");
+                output.MessageEvent($"  Files deleted: {result.DeletedFiles}");
+                output.MessageEvent($"  Files changed: {result.ModifiedFiles}");
 
-                output.MessageEvent(string.Format("  Data uploaded: {0}", Library.Utility.Utility.FormatSizeString(result.BackendStatistics.BytesUploaded)));
-                output.MessageEvent(string.Format("  Data downloaded: {0}", Library.Utility.Utility.FormatSizeString(result.BackendStatistics.BytesDownloaded)));
+                output.MessageEvent($"  Data uploaded: {Library.Utility.Utility.FormatSizeString(result.BackendStatistics.BytesUploaded)}");
+                output.MessageEvent($"  Data downloaded: {Library.Utility.Utility.FormatSizeString(result.BackendStatistics.BytesDownloaded)}");
 
                 if (result.ExaminedFiles == 0 && (filter != null && !filter.Empty))
                     output.MessageEvent("No files were processed. If this was not intentional you may want to use the \"test-filters\" command");
@@ -1092,14 +1091,14 @@ namespace Duplicati.CommandLine
                     {
                         previd = id;
                         outputcount = 0;
-                        con.MessageEvent(string.Format("{0}\t: {1}\t({2} match(es))", id, time.ToLocalTime(), count));
+                        con.MessageEvent($"{id}\t: {time.ToLocalTime()}\t({count} match(es))");
                     }
 
-                    con.MessageEvent(string.Format("\t{0} ({1})", path, Library.Utility.Utility.FormatSizeString(size)));
+                    con.MessageEvent($"\t{path} ({Library.Utility.Utility.FormatSizeString(size)})");
                     outputcount++;
                     if (outputcount >= 5 && !fullresult && count != outputcount)
                     {
-                        con.MessageEvent(string.Format("\t ... and {0} more, (use --{1} to list all)", count - outputcount, "full-result"));
+                        con.MessageEvent($"\t ... and {count - outputcount} more, (use --{"full-result"} to list all)");
                         return false;
                     }
 
diff --git a/Duplicati/CommandLine/Help.cs b/Duplicati/CommandLine/Help.cs
index 57eaa10cf..dab7067ed 100644
--- a/Duplicati/CommandLine/Help.cs
+++ b/Duplicati/CommandLine/Help.cs
@@ -116,7 +116,7 @@ namespace Duplicati.CommandLine
                     // These properties are only valid for Windows
                     tp = tp.Replace("%EXAMPLE_WILDCARD_DRIVE_SOURCE_PATH%", @"*:\source");
                     tp = tp.Replace("%EXAMPLE_VOLUME_GUID_SOURCE_PATH%", @"\\?\Volume{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}\source");
-                    tp = tp.Replace("%KNOWN_DRIVES_AND_VOLUMES%", string.Join(Environment.NewLine + "    ", Library.Utility.Utility.GetVolumeGuidsAndDriveLetters().Select(pair => string.Format("{0}  {1}", pair.Key, pair.Value))));
+                    tp = tp.Replace("%KNOWN_DRIVES_AND_VOLUMES%", string.Join(Environment.NewLine + "    ", Library.Utility.Utility.GetVolumeGuidsAndDriveLetters().Select(pair => $"{pair.Key}  {pair.Value}")));
 
                     // We don't need to hide things between these tags on Windows
                     tp = tp.Replace("%IF_WINDOWS%", string.Empty);
@@ -500,9 +500,9 @@ namespace Duplicati.CommandLine
         private static string PrintArgSimple(Duplicati.Library.Interface.ICommandLineArgument arg, string name)
         {
             if (string.IsNullOrEmpty(arg.DefaultValue))
-                return string.Format("  --{0}{1}    {2}", name, Environment.NewLine, arg.LongDescription);
+                return $"  --{name}{Environment.NewLine}    {arg.LongDescription}";
             else
-                return string.Format("  --{0} = {1}{2}    {3}", name, arg.DefaultValue, Environment.NewLine, arg.LongDescription);
+                return $"  --{name} = {arg.DefaultValue}{Environment.NewLine}    {arg.LongDescription}";
         }
     }
 }
diff --git a/Duplicati/CommandLine/RecoveryTool/List.cs b/Duplicati/CommandLine/RecoveryTool/List.cs
index 5fe20eb50..4a9a99bee 100644
--- a/Duplicati/CommandLine/RecoveryTool/List.cs
+++ b/Duplicati/CommandLine/RecoveryTool/List.cs
@@ -90,7 +90,7 @@ namespace Duplicati.CommandLine.RecoveryTool
             {
                 var items = ParseListFiles(folder);
                 if (index < 0 || index >= items.Length)
-                    throw new Duplicati.Library.Interface.UserInformationException(string.Format("Valid range for version is 0 to {0}", items.Length - 1), "RecoveryToolInvalidVersion");
+                    throw new Duplicati.Library.Interface.UserInformationException($"Valid range for version is 0 to {items.Length - 1}", "RecoveryToolInvalidVersion");
 
                 return items[index].Value;
             }
diff --git a/Duplicati/CommandLine/RecoveryTool/Restore.cs b/Duplicati/CommandLine/RecoveryTool/Restore.cs
index b2fc5282e..e9306e035 100644
--- a/Duplicati/CommandLine/RecoveryTool/Restore.cs
+++ b/Duplicati/CommandLine/RecoveryTool/Restore.cs
@@ -95,9 +95,9 @@ namespace Duplicati.CommandLine.RecoveryTool
             var filehasher = string.IsNullOrWhiteSpace(filehash_str) ? null : Library.Utility.HashAlgorithmHelper.Create(filehash_str);
 
             if (blockhasher == null)
-                throw new Duplicati.Library.Interface.UserInformationException(string.Format("Block hash algorithm not valid: {0}", blockhash_str), "BlockHashAlgorithmNotSupported");
+                throw new Duplicati.Library.Interface.UserInformationException($"Block hash algorithm not valid: {blockhash_str}", "BlockHashAlgorithmNotSupported");
             if (filehasher == null)
-                throw new Duplicati.Library.Interface.UserInformationException(string.Format("File hash algorithm not valid: {0}", filehash_str), "FileHashAlgorithmNotSupported");
+                throw new Duplicati.Library.Interface.UserInformationException($"File hash algorithm not valid: {filehash_str}", "FileHashAlgorithmNotSupported");
 
             var hashesprblock = blocksize / (blockhasher.HashSize / 8);
 
@@ -352,7 +352,7 @@ namespace Duplicati.CommandLine.RecoveryTool
                         lfi = 0;
                     }
 
-                throw new Exception(string.Format("Unexpected long line starting at offset {0}, read {1} bytes without a newline", p, m_linebuf.Length));
+                throw new Exception($"Unexpected long line starting at offset {p}, read {m_linebuf.Length} bytes without a newline");
             }
 
             private IEnumerable<KeyValuePair<string, string>> AllFileLines()
@@ -409,7 +409,7 @@ namespace Duplicati.CommandLine.RecoveryTool
                         break;
                 }
 
-                throw new Exception(string.Format("Unable to locate block with hash: {0}", hash));
+                throw new Exception($"Unable to locate block with hash: {hash}");
             }
 
             public void WriteHash(Stream sw, string hash)
@@ -452,7 +452,7 @@ namespace Duplicati.CommandLine.RecoveryTool
                     if (cf == null)
                     {
                         stream.Dispose();
-                        throw new Exception(string.Format("Unable to decompress {0}, no such compression module {1}", filename, Path.GetExtension(filename).Trim('.')));
+                        throw new Exception($"Unable to decompress {filename}, no such compression module {Path.GetExtension(filename).Trim('.')}");
                     }
                     m_lookup[filename] = cf;
                     m_streams[filename] = stream;
diff --git a/Duplicati/GUI/Duplicati.GUI.TrayIcon/HttpServerConnection.cs b/Duplicati/GUI/Duplicati.GUI.TrayIcon/HttpServerConnection.cs
index 19fd89ec2..cfa408ddd 100644
--- a/Duplicati/GUI/Duplicati.GUI.TrayIcon/HttpServerConnection.cs
+++ b/Duplicati/GUI/Duplicati.GUI.TrayIcon/HttpServerConnection.cs
@@ -222,7 +222,7 @@ namespace Duplicati.GUI.TrayIcon
 
         private static string EncodeQueryString(Dictionary<string, string> dict)
         {
-            return string.Join("&", Array.ConvertAll(dict.Keys.ToArray(), key => string.Format("{0}={1}", Uri.EscapeUriString(key), Uri.EscapeUriString(dict[key]))));
+            return string.Join("&", Array.ConvertAll(dict.Keys.ToArray(), key => $"{Uri.EscapeUriString(key)}={Uri.EscapeUriString(dict[key])}"));
         }
 
         private class SaltAndNonce
@@ -501,13 +501,13 @@ namespace Duplicati.GUI.TrayIcon
         public void StopTask(long id)
         {
             var req = new Dictionary<string, string>();
-            ExecuteAndNotify("POST", string.Format("/task/{0}/stop", Library.Utility.Uri.UrlPathEncode(id.ToString())), req);
+            ExecuteAndNotify("POST", $"/task/{Library.Utility.Uri.UrlPathEncode(id.ToString())}/stop", req);
         }
 
         public void AbortTask(long id)
         {
             var req = new Dictionary<string, string>();
-            ExecuteAndNotify("POST", string.Format("/task/{0}/abort", Library.Utility.Uri.UrlPathEncode(id.ToString())), req);
+            ExecuteAndNotify("POST", $"/task/{Library.Utility.Uri.UrlPathEncode(id.ToString())}/abort", req);
         }
 
         public void RunBackup(long id, bool forcefull = false)
@@ -515,13 +515,13 @@ namespace Duplicati.GUI.TrayIcon
             var req = new Dictionary<string, string>();
             if (forcefull)
                 req.Add("full", "true");
-            ExecuteAndNotify("POST", string.Format("/backup/{0}/start", Library.Utility.Uri.UrlPathEncode(id.ToString())), req);
+            ExecuteAndNotify("POST", $"/backup/{Library.Utility.Uri.UrlPathEncode(id.ToString())}/start", req);
         }
   
         public void DismissNotification(long id)
         {
             var req = new Dictionary<string, string>();
-            ExecuteAndNotify("DELETE", string.Format("/notification/{0}", Library.Utility.Uri.UrlPathEncode(id.ToString())), req);
+            ExecuteAndNotify("DELETE", $"/notification/{Library.Utility.Uri.UrlPathEncode(id.ToString())}", req);
         }
 
         public void Dispose()
diff --git a/Duplicati/GUI/Duplicati.GUI.TrayIcon/ImageLoader.cs b/Duplicati/GUI/Duplicati.GUI.TrayIcon/ImageLoader.cs
index f796cfc90..2d3986e4d 100644
--- a/Duplicati/GUI/Duplicati.GUI.TrayIcon/ImageLoader.cs
+++ b/Duplicati/GUI/Duplicati.GUI.TrayIcon/ImageLoader.cs
@@ -51,7 +51,7 @@ namespace Duplicati.GUI.TrayIcon
         {
             Icon ico;
 
-            var cachename = string.Format("{0};{1}x{2}", filename, size.Width, size.Height);
+            var cachename = $"{filename};{size.Width}x{size.Height}";
 
             if (ICONS.TryGetValue(cachename, out ico))
                 return ico;
diff --git a/Duplicati/GUI/Duplicati.GUI.TrayIcon/Program.cs b/Duplicati/GUI/Duplicati.GUI.TrayIcon/Program.cs
index 31b4025d9..c6fc44f6e 100644
--- a/Duplicati/GUI/Duplicati.GUI.TrayIcon/Program.cs
+++ b/Duplicati/GUI/Duplicati.GUI.TrayIcon/Program.cs
@@ -307,7 +307,7 @@ namespace Duplicati.GUI.TrayIcon
             else if (toolkit == TOOLKIT_RUMPS)
                 return GetRumpsRunnerInstance();
             else 
-                throw new UserInformationException(string.Format("The selected toolkit '{0}' is invalid", toolkit), "TrayIconInvalidToolKit");
+                throw new UserInformationException($"The selected toolkit '{toolkit}' is invalid", "TrayIconInvalidToolKit");
         }
         
         //We keep these in functions to avoid attempting to load the instance,
diff --git a/Duplicati/GUI/Duplicati.GUI.TrayIcon/RumpsRunner.cs b/Duplicati/GUI/Duplicati.GUI.TrayIcon/RumpsRunner.cs
index 0d8a10fd9..f5f2611dc 100644
--- a/Duplicati/GUI/Duplicati.GUI.TrayIcon/RumpsRunner.cs
+++ b/Duplicati/GUI/Duplicati.GUI.TrayIcon/RumpsRunner.cs
@@ -118,7 +118,7 @@ namespace Duplicati.GUI.TrayIcon
 
             try
             {
-                var si = System.Diagnostics.Process.Start(RUMPS_PYTHON, string.Format("\"{0}\" TEST", SCRIPT_PATH));
+                var si = System.Diagnostics.Process.Start(RUMPS_PYTHON, $"\"{SCRIPT_PATH}\" TEST");
                 si.WaitForExit((int)TimeSpan.FromSeconds(5).TotalMilliseconds);
                 if (!si.HasExited)
                 {
@@ -145,7 +145,7 @@ namespace Duplicati.GUI.TrayIcon
             if (m_toRumps != null)
                 m_toRumps.Dispose();
             
-            var startinfo = new System.Diagnostics.ProcessStartInfo(RUMPS_PYTHON, string.Format("\"{0}\"", SCRIPT_PATH));
+            var startinfo = new System.Diagnostics.ProcessStartInfo(RUMPS_PYTHON, $"\"{SCRIPT_PATH}\"");
             startinfo.CreateNoWindow = true;
             startinfo.UseShellExecute = false;
             startinfo.RedirectStandardInput = true;
diff --git a/Duplicati/Library/AutoUpdater/AutoUpdateSettings.cs b/Duplicati/Library/AutoUpdater/AutoUpdateSettings.cs
index 0526366f9..676b81233 100644
--- a/Duplicati/Library/AutoUpdater/AutoUpdateSettings.cs
+++ b/Duplicati/Library/AutoUpdater/AutoUpdateSettings.cs
@@ -46,12 +46,7 @@ namespace Duplicati.Library.AutoUpdater
         internal const string MATCH_UPDATE_URL_FILENAME_GROUP = "filename";
 
         internal static readonly Regex MATCH_AUTOUPDATE_URL = 
-            new Regex(string.Format(
-                "(?<{0}>.+)(?<{1}>{3})(?<{2}>/([^/]+).manifest)", 
-                MATCH_UPDATE_URL_PREFIX_GROUP,
-                MATCH_UPDATE_URL_CHANNEL_GROUP,
-                MATCH_UPDATE_URL_FILENAME_GROUP,
-                string.Join("|", Enum.GetNames(typeof(ReleaseType)).Union(new [] { "preview", "rene" }) )), RegexOptions.Compiled | RegexOptions.IgnoreCase);
+            new Regex($"(?<{MATCH_UPDATE_URL_PREFIX_GROUP}>.+)(?<{MATCH_UPDATE_URL_CHANNEL_GROUP}>{MATCH_UPDATE_URL_FILENAME_GROUP})(?<{string.Join("|", Enum.GetNames(typeof(ReleaseType)).Union(new[]{"preview", "rene"}))}>/([^/]+).manifest)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
 
 
         static AutoUpdateSettings()
diff --git a/Duplicati/Library/AutoUpdater/Program.cs b/Duplicati/Library/AutoUpdater/Program.cs
index 92ced508c..c54b856fd 100644
--- a/Duplicati/Library/AutoUpdater/Program.cs
+++ b/Duplicati/Library/AutoUpdater/Program.cs
@@ -64,7 +64,7 @@ namespace Duplicati.Library.AutoUpdater
                         var selfdir = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
                         if (string.Equals(Util.AppendDirSeparator(selfdir), Util.AppendDirSeparator(UpdaterManager.InstalledBaseDir)))
                             versions = versions.Union(new KeyValuePair<string, UpdateInfo>[] { new KeyValuePair<string, UpdateInfo>(selfdir, UpdaterManager.SelfVersion) });
-                        Console.WriteLine(string.Join(Environment.NewLine, versions.Select(x => string.Format(" {0} {1} ({2})", (x.Value.Version == UpdaterManager.SelfVersion.Version ? "*" : "-"), x.Value.Displayname, x.Value.Version))));
+                        Console.WriteLine(string.Join(Environment.NewLine, versions.Select(x => $" {(x.Value.Version == UpdaterManager.SelfVersion.Version ? "*" : "-")} {x.Value.Displayname} ({x.Value.Version})")));
                         return 0;
                     }
 
@@ -75,7 +75,7 @@ namespace Duplicati.Library.AutoUpdater
                         if (string.Equals(Util.AppendDirSeparator(selfdir), Util.AppendDirSeparator(UpdaterManager.InstalledBaseDir)))
                             versions = versions.Union(new KeyValuePair<string, UpdateInfo>[] { new KeyValuePair<string, UpdateInfo>(selfdir, UpdaterManager.SelfVersion) });
 
-                        Console.WriteLine(string.Join(Environment.NewLine, versions.Select(x => string.Format(" {0} {1} ({2}): {3}", (x.Value.Version == UpdaterManager.SelfVersion.Version ? "*" : "-"), x.Value.Displayname, x.Value.Version, UpdaterManager.VerifyUnpackedFolder(x.Key, x.Value) ? "Valid" : "*** Modified ***"))));
+                        Console.WriteLine(string.Join(Environment.NewLine, versions.Select(x => $" {(x.Value.Version == UpdaterManager.SelfVersion.Version ? "*" : "-")} {x.Value.Displayname} ({x.Value.Version}): {(UpdaterManager.VerifyUnpackedFolder(x.Key, x.Value) ? "Valid" : "*** Modified ***")}")));
                         return 0;
                     }
                 case "check":
diff --git a/Duplicati/Library/AutoUpdater/UpdaterManager.cs b/Duplicati/Library/AutoUpdater/UpdaterManager.cs
index 8d7b90955..a76377cdf 100644
--- a/Duplicati/Library/AutoUpdater/UpdaterManager.cs
+++ b/Duplicati/Library/AutoUpdater/UpdaterManager.cs
@@ -339,7 +339,7 @@ namespace Duplicati.Library.AutoUpdater
                     using (var tmpfile = new Library.Utility.TempFile())
                     {
                         System.Net.WebClient wc = new System.Net.WebClient();
-                        wc.Headers.Add(System.Net.HttpRequestHeader.UserAgent, string.Format("{0} v{1}{2}", APPNAME, SelfVersion.Version, string.IsNullOrWhiteSpace(InstallID) ? "" : " -" + InstallID));
+                        wc.Headers.Add(System.Net.HttpRequestHeader.UserAgent, $"{APPNAME} v{SelfVersion.Version}{(string.IsNullOrWhiteSpace(InstallID) ? "" : " -" + InstallID)}");
                         wc.Headers.Add("X-Install-ID", InstallID);
                         wc.DownloadFile(url, tmpfile);
 
@@ -457,7 +457,7 @@ namespace Duplicati.Library.AutoUpdater
                                 cb = (s) => { progress(Math.Min(1.0, Math.Max(0.0, (double)s / version.CompressedSize))); };
 
                             var wreq = (System.Net.HttpWebRequest)System.Net.WebRequest.Create(url);
-                            wreq.UserAgent = string.Format("{0} v{1}", APPNAME, SelfVersion.Version);
+                            wreq.UserAgent = $"{APPNAME} v{SelfVersion.Version}";
                             wreq.Headers.Add("X-Install-ID", InstallID);
 
                             var areq = new Duplicati.Library.Utility.AsyncHttpRequest(wreq);
@@ -472,18 +472,18 @@ namespace Duplicati.Library.AutoUpdater
                             var md5 = System.Security.Cryptography.MD5.Create();
 
                             if (tempfile.Length != version.CompressedSize)
-                                throw new Exception(string.Format("Invalid file size {0}, expected {1} for {2}", tempfile.Length, version.CompressedSize, url));
+                                throw new Exception($"Invalid file size {tempfile.Length}, expected {version.CompressedSize} for {url}");
 
                             tempfile.Position = 0;
                             var sha256hash = Convert.ToBase64String(sha256.ComputeHash(tempfile));
                             if (sha256hash != version.SHA256)
-                                throw new Exception(string.Format("Damaged or corrupted file, sha256 mismatch for {0}", url));
+                                throw new Exception($"Damaged or corrupted file, sha256 mismatch for {url}");
 
 
                             tempfile.Position = 0;
                             var md5hash = Convert.ToBase64String(md5.ComputeHash(tempfile));
                             if (md5hash != version.MD5)
-                                throw new Exception(string.Format("Damaged or corrupted file, md5 mismatch for {0}", url));
+                                throw new Exception($"Damaged or corrupted file, md5 mismatch for {url}");
 
                             tempfile.Position = 0;
                             using (var tempfolder = new Duplicati.Library.Utility.TempFolder())
@@ -492,7 +492,7 @@ namespace Duplicati.Library.AutoUpdater
                                 foreach (var file in zip.ListFilesWithSize(""))
                                 {
                                     if (System.IO.Path.IsPathRooted(file.Key) || file.Key.Trim().StartsWith("..", StringComparison.OrdinalIgnoreCase))
-                                        throw new Exception(string.Format("Out-of-place file path detected: {0}", file.Key));
+                                        throw new Exception($"Out-of-place file path detected: {file.Key}");
 
                                     var targetpath = System.IO.Path.Combine(tempfolder, file.Key);
                                     var targetfolder = System.IO.Path.GetDirectoryName(targetpath);
@@ -552,7 +552,7 @@ namespace Duplicati.Library.AutoUpdater
                                 }
                                 else
                                 {
-                                    throw new Exception(string.Format("Unable to verify unpacked folder for url: {0}", url));
+                                    throw new Exception($"Unable to verify unpacked folder for url: {url}");
                                 }
                             }
                         }
@@ -633,7 +633,7 @@ namespace Duplicati.Library.AutoUpdater
                         if (ignore)
                             continue;
 
-                        throw new Exception(string.Format("Found unexpected file: {0}", file));
+                        throw new Exception($"Found unexpected file: {file}");
                     }
 
                     paths.Remove(relpath);
@@ -647,11 +647,11 @@ namespace Duplicati.Library.AutoUpdater
                     using (var fs = System.IO.File.OpenRead(file))
                     {
                         if (Convert.ToBase64String(sha256.ComputeHash(fs)) != fe.SHA256)
-                            throw new Exception(string.Format("Invalid sha256 hash for file: {0}", file));
+                            throw new Exception($"Invalid sha256 hash for file: {file}");
 
                         fs.Position = 0;
                         if (Convert.ToBase64String(md5.ComputeHash(fs)) != fe.MD5)
-                            throw new Exception(string.Format("Invalid md5 hash for file: {0}", file));
+                            throw new Exception($"Invalid md5 hash for file: {file}");
                     }
                 }
 
@@ -662,9 +662,9 @@ namespace Duplicati.Library.AutoUpdater
                     .ToList();
 
                 if (filteredpaths.Count == 1)
-                    throw new Exception(string.Format("Folder {0} is missing: {1}", folder, filteredpaths.First()));
+                    throw new Exception($"Folder {folder} is missing: {filteredpaths.First()}");
                 else if (filteredpaths.Count > 0)
-                    throw new Exception(string.Format("Folder {0} is missing {1} and {2} other file(s)", folder, filteredpaths.First(), filteredpaths.Count - 1));
+                    throw new Exception($"Folder {folder} is missing {filteredpaths.First()} and {filteredpaths.Count - 1} other file(s)");
 
                 return true;
             }
@@ -1016,7 +1016,7 @@ namespace Duplicati.Library.AutoUpdater
                 {
                     var report_file = System.IO.Path.Combine(
                         string.IsNullOrEmpty(INSTALLDIR) ? Library.Utility.TempFolder.SystemTempPath : INSTALLDIR,
-                        string.Format("{0}-crashlog.txt", AutoUpdateSettings.AppName)
+                        $"{AutoUpdateSettings.AppName}-crashlog.txt"
                      );
 
                     System.IO.File.WriteAllText(report_file, tex.ToString());
diff --git a/Duplicati/Library/Backend/AzureBlob/AzureBlobWrapper.cs b/Duplicati/Library/Backend/AzureBlob/AzureBlobWrapper.cs
index b05465713..872e047b8 100644
--- a/Duplicati/Library/Backend/AzureBlob/AzureBlobWrapper.cs
+++ b/Duplicati/Library/Backend/AzureBlob/AzureBlobWrapper.cs
@@ -66,15 +66,10 @@ namespace Duplicati.Library.Backend.AzureBlob
         {
             OperationContext.GlobalSendingRequest += (sender, args) =>
             {
-                args.Request.UserAgent = string.Format(
-                    "APN/1.0 Duplicati/{0} AzureBlob/2.0 {1}",
-                    System.Reflection.Assembly.GetExecutingAssembly().GetName().Version,
-                    Microsoft.WindowsAzure.Storage.Shared.Protocol.Constants.HeaderConstants.UserAgent
-                );
+                args.Request.UserAgent = $"APN/1.0 Duplicati/{System.Reflection.Assembly.GetExecutingAssembly().GetName().Version} AzureBlob/2.0 {Microsoft.WindowsAzure.Storage.Shared.Protocol.Constants.HeaderConstants.UserAgent}";
             };
 
-            var connectionString = string.Format("DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}",
-                accountName, accessKey);
+            var connectionString = $"DefaultEndpointsProtocol=https;AccountName={accountName};AccountKey={accessKey}";
             var storageAccount = CloudStorageAccount.Parse(connectionString);
             var blobClient = storageAccount.CreateCloudBlobClient();
 
diff --git a/Duplicati/Library/Backend/Backblaze/B2.cs b/Duplicati/Library/Backend/Backblaze/B2.cs
index d1e811d92..ccb1c2f05 100644
--- a/Duplicati/Library/Backend/Backblaze/B2.cs
+++ b/Duplicati/Library/Backend/Backblaze/B2.cs
@@ -120,13 +120,13 @@ namespace Duplicati.Library.Backend.Backblaze
                 if (m_bucket == null)
                 {
                     var buckets = m_helper.PostAndGetJSONData<ListBucketsResponse>(
-                        string.Format("{0}/b2api/v1/b2_list_buckets", m_helper.APIUrl),
+                        $"{m_helper.APIUrl}/b2api/v1/b2_list_buckets",
                         new ListBucketsRequest() {
                             AccountID = m_helper.AccountID
                         }
                     );
 
-                    if (buckets != null && buckets.Buckets != null)
+                    if (buckets?.Buckets != null)
                         m_bucket = buckets.Buckets.FirstOrDefault(x => string.Equals(x.BucketName, m_bucketname, StringComparison.OrdinalIgnoreCase));
 
                     if (m_bucket == null)
@@ -143,7 +143,7 @@ namespace Duplicati.Library.Backend.Backblaze
             {
                 if (m_uploadUrl == null)
                     m_uploadUrl = m_helper.PostAndGetJSONData<UploadUrlResponse>(
-                        string.Format("{0}/b2api/v1/b2_get_upload_url", m_helper.APIUrl),
+                        $"{m_helper.APIUrl}/b2api/v1/b2_get_upload_url",
                         new UploadUrlRequest() { BucketID = Bucket.BucketID }
                     );
 
@@ -200,7 +200,7 @@ namespace Duplicati.Library.Backend.Backblaze
                 measure = typeof(OverrideableStream).GetField("m_basestream", System.Reflection.BindingFlags.DeclaredOnly | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic).GetValue(measure) as System.IO.Stream;
 
             if (measure == null)
-                throw new Exception(string.Format("Unable to unwrap stream from: {0}", stream.GetType()));
+                throw new Exception($"Unable to unwrap stream from: {stream.GetType()}");
 
             string sha1;
             if (measure.CanSeek)
@@ -287,9 +287,9 @@ namespace Duplicati.Library.Backend.Backblaze
                 List();
 
             if (m_filecache != null && m_filecache.ContainsKey(remotename))
-                req = new AsyncHttpRequest(m_helper.CreateRequest(string.Format("{0}/b2api/v1/b2_download_file_by_id?fileId={1}", DownloadUrl, Library.Utility.Uri.UrlEncode(GetFileID(remotename)))));
+                req = new AsyncHttpRequest(m_helper.CreateRequest($"{DownloadUrl}/b2api/v1/b2_download_file_by_id?fileId={Library.Utility.Uri.UrlEncode(GetFileID(remotename))}"));
             else
-                req = new AsyncHttpRequest(m_helper.CreateRequest(string.Format("{0}/{1}{2}", DownloadUrl, m_urlencodedprefix, Library.Utility.Uri.UrlPathEncode(remotename))));
+                req = new AsyncHttpRequest(m_helper.CreateRequest($"{DownloadUrl}/{m_urlencodedprefix}{Library.Utility.Uri.UrlPathEncode(remotename)}"));
 
             try
             {
@@ -317,7 +317,7 @@ namespace Duplicati.Library.Backend.Backblaze
             do
             {
                 var resp = m_helper.PostAndGetJSONData<ListFilesResponse>(
-                    string.Format("{0}/b2api/v1/b2_list_file_versions", m_helper.APIUrl),
+                    $"{m_helper.APIUrl}/b2api/v1/b2_list_file_versions",
                     new ListFilesRequest() {
                         BucketID = Bucket.BucketID,
                         MaxFileCount = m_pagesize,
@@ -386,7 +386,7 @@ namespace Duplicati.Library.Backend.Backblaze
                 
                 foreach(var n in m_filecache[remotename].OrderBy(x => x.UploadTimestamp))
                     m_helper.PostAndGetJSONData<DeleteResponse>(
-                        string.Format("{0}/b2api/v1/b2_delete_file_version", m_helper.APIUrl),
+                        $"{m_helper.APIUrl}/b2api/v1/b2_delete_file_version",
                         new DeleteRequest() {
                             FileName = m_prefix + remotename,
                             FileID = n.FileID
@@ -410,7 +410,7 @@ namespace Duplicati.Library.Backend.Backblaze
         public void CreateFolder()
         {
             m_bucket = m_helper.PostAndGetJSONData<BucketEntity>(
-                string.Format("{0}/b2api/v1/b2_create_bucket", m_helper.APIUrl),
+                $"{m_helper.APIUrl}/b2api/v1/b2_create_bucket",
                 new BucketEntity() {
                     AccountID = m_helper.AccountID,
                     BucketName = m_bucketname,
diff --git a/Duplicati/Library/Backend/Backblaze/B2AuthHelper.cs b/Duplicati/Library/Backend/Backblaze/B2AuthHelper.cs
index a358924ed..119be0798 100644
--- a/Duplicati/Library/Backend/Backblaze/B2AuthHelper.cs
+++ b/Duplicati/Library/Backend/Backblaze/B2AuthHelper.cs
@@ -87,7 +87,7 @@ namespace Duplicati.Library.Backend.Backblaze
                         try
                         {
                             var req = base.CreateRequest(AUTH_URL);
-                            req.Headers.Add("Authorization", string.Format("Basic {0}", m_credentials));
+                            req.Headers.Add("Authorization", $"Basic {m_credentials}");
                             req.ContentType = "application/json; charset=utf-8";
 
                             using(var resp = (HttpWebResponse)new AsyncHttpRequest(req).GetResponse())
@@ -147,7 +147,7 @@ namespace Duplicati.Library.Backend.Backblaze
                     newex = new Exception("Raw message: " + rawdata);
 
                     var msg = JsonConvert.DeserializeObject<ErrorResponse>(rawdata);
-                    newex = new Exception(string.Format("{0} - {1}: {2}", msg.Status, msg.Code, msg.Message));
+                    newex = new Exception($"{msg.Status} - {msg.Code}: {msg.Message}");
                 }
             }
             catch
diff --git a/Duplicati/Library/Backend/Box/BoxBackend.cs b/Duplicati/Library/Backend/Box/BoxBackend.cs
index 03d6f6bb0..ce1168052 100644
--- a/Duplicati/Library/Backend/Box/BoxBackend.cs
+++ b/Duplicati/Library/Backend/Box/BoxBackend.cs
@@ -73,7 +73,7 @@ namespace Duplicati.Library.Backend.Box
                         newex = new Exception("Raw message: " + rawdata);
 
                         var msg = JsonConvert.DeserializeObject<ErrorResponse>(rawdata);
-                        newex = new Exception(string.Format("{0} - {1}: {2}", msg.Status, msg.Code, msg.Message));
+                        newex = new Exception($"{msg.Status} - {msg.Code}: {msg.Message}");
 
                         /*if (msg.ContextInfo != null && msg.ContextInfo.Length > 0)
                             newex = new Exception(string.Format("{0} - {1}: {2}{3}{4}", msg.Status, msg.Code, msg.Message, Environment.NewLine, string.Join("; ", from n in msg.ContextInfo select n.Message)));
@@ -137,7 +137,7 @@ namespace Duplicati.Library.Backend.Box
                         throw new FolderMissingException();
 
                     el = m_oauth.PostAndGetJSONData<ListFolderResponse>(
-                        string.Format("{0}/folders", BOX_API_URL),
+                        $"{BOX_API_URL}/folders",
                         new CreateItemRequest() { Name = p, Parent = new IDReference() { ID = parentid } }
                     );
                 }
@@ -172,7 +172,7 @@ namespace Duplicati.Library.Backend.Box
             
             do
             {
-                var resp = m_oauth.GetJSONData<ShortListResponse>(string.Format("{0}/folders/{1}/items?limit={2}&offset={3}&fields=name,size,modified_at", BOX_API_URL, parentid, PAGE_SIZE, offset));
+                var resp = m_oauth.GetJSONData<ShortListResponse>($"{BOX_API_URL}/folders/{parentid}/items?limit={PAGE_SIZE}&offset={offset}&fields=name,size,modified_at");
 
                 if (resp.Entries == null || resp.Entries.Length == 0)
                     break;
@@ -244,7 +244,7 @@ namespace Duplicati.Library.Backend.Box
 
         public void Get(string remotename, System.IO.Stream stream)
         {
-            using (var resp = m_oauth.GetResponse(string.Format("{0}/files/{1}/content", BOX_API_URL, GetFileID(remotename))))
+            using (var resp = m_oauth.GetResponse($"{BOX_API_URL}/files/{GetFileID(remotename)}/content"))
             using(var rs = Duplicati.Library.Utility.AsyncHttpRequest.TrySetTimeout(resp.GetResponseStream()))
                 Library.Utility.Utility.CopyStream(rs, stream);
         }
@@ -277,12 +277,12 @@ namespace Duplicati.Library.Backend.Box
             var fileid = GetFileID(remotename);
             try
             {
-                using(var r = m_oauth.GetResponse(string.Format("{0}/files/{1}", BOX_API_URL, fileid), null, "DELETE"))
+                using(var r = m_oauth.GetResponse($"{BOX_API_URL}/files/{fileid}", null, "DELETE"))
                 {
                 }
 
                 if (m_deleteFromTrash)
-                    using(var r = m_oauth.GetResponse(string.Format("{0}/files/{1}/trash", BOX_API_URL, fileid), null, "DELETE"))
+                    using(var r = m_oauth.GetResponse($"{BOX_API_URL}/files/{fileid}/trash", null, "DELETE"))
                     {
                     }
             }
diff --git a/Duplicati/Library/Backend/Dropbox/Dropbox.cs b/Duplicati/Library/Backend/Dropbox/Dropbox.cs
index 835deb38b..86f7f9743 100644
--- a/Duplicati/Library/Backend/Dropbox/Dropbox.cs
+++ b/Duplicati/Library/Backend/Dropbox/Dropbox.cs
@@ -123,7 +123,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                string path = String.Format("{0}/{1}", m_path, remotename);
+                string path = $"{m_path}/{remotename}";
                 dbx.Delete(path);
             }
             catch (DropboxException)
@@ -188,7 +188,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                string path = string.Format("{0}/{1}", m_path, remotename);
+                string path = $"{m_path}/{remotename}";
                 dbx.DownloadFile(path, stream);
             }
             catch (DropboxException)
diff --git a/Duplicati/Library/Backend/FTP/FTPBackend.cs b/Duplicati/Library/Backend/FTP/FTPBackend.cs
index e5c2bbc2e..428b7783d 100644
--- a/Duplicati/Library/Backend/FTP/FTPBackend.cs
+++ b/Duplicati/Library/Backend/FTP/FTPBackend.cs
@@ -229,26 +229,17 @@ namespace Duplicati.Library.Backend
             {
                 try
                 {
-                    if (sr != null)
-                    {
-                        sr.Dispose();
-                    }
+                    sr?.Dispose();
                 }
                 finally
                 {
                     try
                     {
-                        if (rs != null)
-                        {
-                            rs.Dispose();
-                        }
+                        rs?.Dispose();
                     }
                     finally
                     {
-                        if (resp != null)
-                        {
-                            resp.Dispose();
-                        }
+                        resp?.Dispose();
                     }
                 }
             }
diff --git a/Duplicati/Library/Backend/GoogleServices/GoogleCloudStorage.cs b/Duplicati/Library/Backend/GoogleServices/GoogleCloudStorage.cs
index 1c63f0e06..9a65ae870 100644
--- a/Duplicati/Library/Backend/GoogleServices/GoogleCloudStorage.cs
+++ b/Duplicati/Library/Backend/GoogleServices/GoogleCloudStorage.cs
@@ -207,9 +207,9 @@ namespace Duplicati.Library.Backend.GoogleCloudStorage
                 StringBuilder storageClasses = new StringBuilder();
 
                 foreach (KeyValuePair<string, string> s in WebApi.GoogleCloudStorage.KNOWN_GCS_LOCATIONS)
-                    locations.AppendLine(string.Format("{0}: {1}", s.Key, s.Value));
+                    locations.AppendLine($"{s.Key}: {s.Value}");
                 foreach (KeyValuePair<string, string> s in WebApi.GoogleCloudStorage.KNOWN_GCS_STORAGE_CLASSES)
-                    storageClasses.AppendLine(string.Format("{0}: {1}", s.Key, s.Value));
+                    storageClasses.AppendLine($"{s.Key}: {s.Value}");
 
                 return new List<ICommandLineArgument>(new ICommandLineArgument[] {
                     new CommandLineArgument(LOCATION_OPTION, CommandLineArgument.ArgumentType.String, Strings.GoogleCloudStorage.LocationDescriptionShort, Strings.GoogleCloudStorage.LocationDescriptionLong(locations.ToString())),
diff --git a/Duplicati/Library/Backend/GoogleServices/GoogleCommon.cs b/Duplicati/Library/Backend/GoogleServices/GoogleCommon.cs
index b087be3f1..46266fb22 100644
--- a/Duplicati/Library/Backend/GoogleServices/GoogleCommon.cs
+++ b/Duplicati/Library/Backend/GoogleServices/GoogleCommon.cs
@@ -44,7 +44,7 @@ namespace Duplicati.Library.Backend.GoogleServices
             var req = oauth.CreateRequest(uploaduri);
             req.Method = "PUT";
             req.ContentLength = 0;
-            req.Headers["Content-Range"] = string.Format("bytes */{0}", streamlength);
+            req.Headers["Content-Range"] = $"bytes */{streamlength}";
 
             var areq = new AsyncHttpRequest(req);
             using(var resp = oauth.GetResponseWithoutException(areq))
@@ -56,7 +56,7 @@ namespace Duplicati.Library.Backend.GoogleServices
                 {
                     response = oauth.ReadJSONResponse<T>(resp);
                     if (response == null)
-                        throw new Exception(string.Format("Upload succeeded, but no data was returned, status code: {0}", code));
+                        throw new Exception($"Upload succeeded, but no data was returned, status code: {code}");
                     
                     return streamlength;
                 }
@@ -73,7 +73,7 @@ namespace Duplicati.Library.Backend.GoogleServices
                         return long.Parse(resp.Headers["Range"].Split(new char[] { '-' })[1]) + 1;
                 }
                 else
-                    throw new WebException(string.Format("Unexpected status code: {0}", code), null, WebExceptionStatus.ServerProtocolViolation, resp);
+                    throw new WebException($"Unexpected status code: {code}", null, WebExceptionStatus.ServerProtocolViolation, resp);
             }
         }
 
@@ -163,7 +163,7 @@ namespace Duplicati.Library.Backend.GoogleServices
                     var chunkSize = Math.Min(UPLOAD_CHUNK_SIZE, stream.Length - offset);
 
                     req.ContentLength = chunkSize;
-                    req.Headers["Content-Range"] = string.Format("bytes {0}-{1}/{2}", offset, offset + chunkSize - 1, stream.Length);
+                    req.Headers["Content-Range"] = $"bytes {offset}-{offset + chunkSize - 1}/{stream.Length}";
 
                     // Upload the remaining data
                     var areq = new AsyncHttpRequest(req);
@@ -192,18 +192,18 @@ namespace Duplicati.Library.Backend.GoogleServices
                         {
                             offset += chunkSize;
                             if (offset != stream.Length)
-                                throw new Exception(string.Format("Upload succeeded prematurely. Uploaded: {0}, total size: {1}", offset, stream.Length));
+                                throw new Exception($"Upload succeeded prematurely. Uploaded: {offset}, total size: {stream.Length}");
 
                             //Verify that the response is also valid
                             var res = oauth.ReadJSONResponse<T>(resp);
                             if (res == null)
-                                throw new Exception(string.Format("Upload succeeded, but no data was returned, status code: {0}", code));
+                                throw new Exception($"Upload succeeded, but no data was returned, status code: {code}");
 
                             return res;
                         }
                         else
                         {
-                            throw new WebException(string.Format("Unexpected status code: {0}", code), null, WebExceptionStatus.ServerProtocolViolation, resp);
+                            throw new WebException($"Unexpected status code: {code}", null, WebExceptionStatus.ServerProtocolViolation, resp);
                         }
                     }
                 }
diff --git a/Duplicati/Library/Backend/GoogleServices/GoogleDrive.cs b/Duplicati/Library/Backend/GoogleServices/GoogleDrive.cs
index 29e179e50..9d0db6681 100644
--- a/Duplicati/Library/Backend/GoogleServices/GoogleDrive.cs
+++ b/Duplicati/Library/Backend/GoogleServices/GoogleDrive.cs
@@ -438,9 +438,9 @@ namespace Duplicati.Library.Backend.GoogleDrive
         private IEnumerable<GoogleDriveFolderItem> ListFolder(string parentfolder, bool? onlyFolders = null, string name = null)
         {
             var fileQuery = new string[] {
-                string.IsNullOrEmpty(name) ? null : string.Format("title = '{0}'", EscapeTitleEntries(name)),
-                onlyFolders == null ? null : string.Format("mimeType {0}= '{1}'", onlyFolders.Value ? "" : "!", FOLDER_MIMETYPE),
-                string.Format("'{0}' in parents", EscapeTitleEntries(parentfolder)),
+                string.IsNullOrEmpty(name) ? null : $"title = '{EscapeTitleEntries(name)}'",
+                onlyFolders == null ? null : $"mimeType {(onlyFolders.Value ? "" : "!")}= '{FOLDER_MIMETYPE}'",
+                $"'{EscapeTitleEntries(parentfolder)}' in parents",
                 "trashed=false"
             };
 
diff --git a/Duplicati/Library/Backend/Jottacloud/Jottacloud.cs b/Duplicati/Library/Backend/Jottacloud/Jottacloud.cs
index 95dc2762f..b497cc5bd 100644
--- a/Duplicati/Library/Backend/Jottacloud/Jottacloud.cs
+++ b/Duplicati/Library/Backend/Jottacloud/Jottacloud.cs
@@ -180,7 +180,7 @@ namespace Duplicati.Library.Backend
 
             if (chunksize > int.MaxValue || chunksize < 1024)
             {
-                throw new ArgumentOutOfRangeException(nameof(chunksize), string.Format("The chunk size cannot be less than {0}, nor larger than {1}", Utility.Utility.FormatSizeString(1024), Utility.Utility.FormatSizeString(int.MaxValue)));
+                throw new ArgumentOutOfRangeException(nameof(chunksize), $"The chunk size cannot be less than {Utility.Utility.FormatSizeString(1024)}, nor larger than {Utility.Utility.FormatSizeString(int.MaxValue)}");
             }
 
             m_chunksize = chunksize;
@@ -298,7 +298,7 @@ namespace Duplicati.Library.Backend
             var xFile = doc.DocumentElement;
             if (xFile.Attributes["deleted"] != null)
             {
-                throw new FileMissingException(string.Format("{0}: {1}", LC.L("The requested file does not exist"), remotename));
+                throw new FileMissingException($"{LC.L("The requested file does not exist")}: {remotename}");
             }
 
             return ToFileEntry(xFile);
@@ -482,7 +482,7 @@ namespace Duplicati.Library.Backend
             while (baseStream is Duplicati.Library.Utility.OverrideableStream)
                 baseStream = typeof(Duplicati.Library.Utility.OverrideableStream).GetField("m_basestream", System.Reflection.BindingFlags.DeclaredOnly | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic).GetValue(baseStream) as System.IO.Stream;
             if (baseStream == null)
-                throw new Exception(string.Format("Unable to unwrap stream from: {0}", stream.GetType()));
+                throw new Exception($"Unable to unwrap stream from: {stream.GetType()}");
             string md5Hash;
             if (baseStream.CanSeek)
             {
diff --git a/Duplicati/Library/Backend/OAuthHelper/JSONWebHelper.cs b/Duplicati/Library/Backend/OAuthHelper/JSONWebHelper.cs
index 33accbd2e..ba5047798 100644
--- a/Duplicati/Library/Backend/OAuthHelper/JSONWebHelper.cs
+++ b/Duplicati/Library/Backend/OAuthHelper/JSONWebHelper.cs
@@ -28,7 +28,7 @@ namespace Duplicati.Library
 {
     public class JSONWebHelper
     {
-        public static readonly string USER_AGENT = string.Format("Duplicati v{0}", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
+        public static readonly string USER_AGENT = $"Duplicati v{System.Reflection.Assembly.GetExecutingAssembly().GetName().Version}";
         private readonly string m_user_agent;
         public string OAuthLoginUrl { get; protected set; }
         public string UserAgent { get { return m_user_agent; } }
@@ -162,7 +162,7 @@ namespace Duplicati.Library
                          "--" + boundary + "\r\n"
                          + string.Join("",
                              from n in p.Headers
-                             select string.Format("{0}: {1}\r\n", n.Key, n.Value)
+                             select $"{n.Key}: {n.Value}\r\n"
                          ) + "\r\n"),
                          p)).ToArray();
 
diff --git a/Duplicati/Library/Backend/OAuthHelper/MultipartItem.cs b/Duplicati/Library/Backend/OAuthHelper/MultipartItem.cs
index 67176ec11..cc73090e0 100644
--- a/Duplicati/Library/Backend/OAuthHelper/MultipartItem.cs
+++ b/Duplicati/Library/Backend/OAuthHelper/MultipartItem.cs
@@ -96,7 +96,7 @@ namespace Duplicati.Library
                 if (string.IsNullOrWhiteSpace(value))
                     Headers.Remove("Content-Disposition");
                 else
-                    Headers["Content-Disposition"] = string.Format("form-data; name=\"{0}\"", Library.Utility.Uri.UrlEncode(value)); 
+                    Headers["Content-Disposition"] = $"form-data; name=\"{Library.Utility.Uri.UrlEncode(value)}\""; 
             }
         }
 
@@ -137,7 +137,7 @@ namespace Duplicati.Library
                 return this;
             }
                 
-            return SetHeaderRaw("Content-Disposition", string.Format("form-data; name=\"{0}\"; filename=\"{1}\"", Library.Utility.Uri.UrlEncode(name), Library.Utility.Uri.UrlEncode(filename)));
+            return SetHeaderRaw("Content-Disposition", $"form-data; name=\"{Library.Utility.Uri.UrlEncode(name)}\"; filename=\"{Library.Utility.Uri.UrlEncode(filename)}\"");
         }
 
     }}
diff --git a/Duplicati/Library/Backend/OAuthHelper/OAuthHelper.cs b/Duplicati/Library/Backend/OAuthHelper/OAuthHelper.cs
index 007376cc0..9a802453e 100644
--- a/Duplicati/Library/Backend/OAuthHelper/OAuthHelper.cs
+++ b/Duplicati/Library/Backend/OAuthHelper/OAuthHelper.cs
@@ -112,7 +112,7 @@ namespace Duplicati.Library
         {
             var r = base.CreateRequest(url, method);
             if (!noAuthorization && AutoAuthHeader && !string.Equals(OAuthContextSettings.ServerURL, url))
-                r.Headers["Authorization"] = string.Format("Bearer {0}", AccessToken);
+                r.Headers["Authorization"] = $"Bearer {AccessToken}";
             return r;
         } 
 
diff --git a/Duplicati/Library/Backend/OneDrive/Exceptions.cs b/Duplicati/Library/Backend/OneDrive/Exceptions.cs
index 0eb50882d..def3d63d1 100644
--- a/Duplicati/Library/Backend/OneDrive/Exceptions.cs
+++ b/Duplicati/Library/Backend/OneDrive/Exceptions.cs
@@ -19,7 +19,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
         private readonly HttpWebResponse webResponse;
 
         public MicrosoftGraphException(HttpResponseMessage response)
-            : this(string.Format("{0}: {1} error from request {2}", response.StatusCode, response.ReasonPhrase, response.RequestMessage.RequestUri), response)
+            : this($"{response.StatusCode}: {response.ReasonPhrase} error from request {response.RequestMessage.RequestUri}", response)
         {
         }
 
@@ -35,7 +35,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
         }
 
         public MicrosoftGraphException(HttpWebResponse response)
-            : this(string.Format("{0}: {1} error from request {2}", response.StatusCode, response.StatusDescription, response.ResponseUri), response)
+            : this($"{response.StatusCode}: {response.StatusDescription} error from request {response.ResponseUri}", response)
         {
         }
 
@@ -93,7 +93,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
                     // it wouldn't be as bad as recording the username/password in logs, since the token will expire, but it doesn't hurt to be safe.
                     // So we replace anything in the request that looks like the auth header with a safe version.
                     string requestMessage = authorizationHeaderRemover.Replace(response.RequestMessage.ToString(), "Authorization: Bearer ABC...XYZ");
-                    return string.Format("{0}\n{1}\n{2}", requestMessage, response, PrettifyJson(content.Await()));
+                    return $"{requestMessage}\n{response}\n{PrettifyJson(content.Await())}";
                 }
             }
             else
@@ -106,7 +106,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
         {
             if (response != null)
             {
-                return string.Format("{0}\n{1}", message, ResponseToString(response));
+                return $"{message}\n{ResponseToString(response)}";
             }
             else
             {
@@ -122,7 +122,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
                 using (var responseStream = response.GetResponseStream())
                 using (var textReader = new StreamReader(responseStream))
                 {
-                    return string.Format("{0}\n{1}", response, PrettifyJson(textReader.ReadToEnd()));
+                    return $"{response}\n{PrettifyJson(textReader.ReadToEnd())}";
                 }
             }
             else
@@ -135,7 +135,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
         {
             if (response != null)
             {
-                return string.Format("{0}\n{1}", message, ResponseToString(response));
+                return $"{message}\n{ResponseToString(response)}";
             }
             else
             {
@@ -172,12 +172,12 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
     public class DriveItemNotFoundException : MicrosoftGraphException
     {
         public DriveItemNotFoundException(HttpResponseMessage response)
-            : base(string.Format("Item at {0} was not found", response?.RequestMessage?.RequestUri?.ToString() ?? "<unknown>"), response)
+            : base($"Item at {response?.RequestMessage?.RequestUri?.ToString() ?? "<unknown>"} was not found", response)
         {
         }
 
         public DriveItemNotFoundException(HttpWebResponse response)
-            : base(string.Format("Item at {0} was not found", response?.ResponseUri?.ToString() ?? "<unknown>"), response)
+            : base($"Item at {response?.ResponseUri?.ToString() ?? "<unknown>"} was not found", response)
         {
         }
     }
@@ -190,7 +190,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
             int fragmentCount,
             MicrosoftGraphException fragmentException)
             : base(
-                  string.Format("Error uploading fragment {0} of {1} for {2}", fragment, fragmentCount, originalResponse?.RequestMessage?.RequestUri?.ToString() ?? "<unknown>"),
+                  $"Error uploading fragment {fragment} of {fragmentCount} for {originalResponse?.RequestMessage?.RequestUri?.ToString() ?? "<unknown>"}",
                   originalResponse,
                   fragmentException)
         {
@@ -205,7 +205,7 @@ namespace Duplicati.Library.Backend.MicrosoftGraph
             int fragmentCount,
             MicrosoftGraphException fragmentException)
             : base(
-                  string.Format("Error uploading fragment {0} of {1} for {2}", fragment, fragmentCount, originalResponse?.ResponseUri?.ToString() ?? "<unknown>"),
+                  $"Error uploading fragment {fragment} of {fragmentCount} for {originalResponse?.ResponseUri?.ToString() ?? "<unknown>"}",
                   originalResponse,
                   fragmentException)
         {
diff --git a/Duplicati/Library/Backend/OneDrive/MicrosoftGraphBackend.cs b/Duplicati/Library/Backend/OneDrive/MicrosoftGraphBackend.cs
index c8e533fc7..874745fb3 100644
--- a/Duplicati/Library/Backend/OneDrive/MicrosoftGraphBackend.cs
+++ b/Duplicati/Library/Backend/OneDrive/MicrosoftGraphBackend.cs
@@ -205,8 +205,8 @@ namespace Duplicati.Library.Backend
                     // - Upload session endpoint (which seems to be different depending on the drive being accessed - not sure if it can vary for a single drive)
                     // To get the upload session endpoint, we can start an upload session and then immediately cancel it.
                     // We pick a random file name (using a guid) to make sure we don't conflict with an existing file
-                    string dnsTestFile = string.Format("DNSNameTest-{0}", Guid.NewGuid());
-                    UploadSession uploadSession = this.Post<UploadSession>(string.Format("{0}/root:{1}{2}:/createUploadSession", this.DrivePrefix, this.RootPath, NormalizeSlashes(dnsTestFile)), MicrosoftGraphBackend.dummyUploadSession);
+                    string dnsTestFile = $"DNSNameTest-{Guid.NewGuid()}";
+                    UploadSession uploadSession = this.Post<UploadSession>($"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(dnsTestFile)}:/createUploadSession", MicrosoftGraphBackend.dummyUploadSession);
 
                     // Canceling an upload session is done by sending a DELETE to the upload URL
                     if (this.m_client != null)
@@ -308,7 +308,7 @@ namespace Duplicati.Library.Backend
                 DriveItem folderItem;
                 try
                 {
-                    folderItem = this.Get<DriveItem>(string.Format("{0}/root:{1}", this.DrivePrefix, NormalizeSlashes(nextPath)));
+                    folderItem = this.Get<DriveItem>($"{this.DrivePrefix}/root:{NormalizeSlashes(nextPath)}");
                 }
                 catch (DriveItemNotFoundException)
                 {
@@ -318,7 +318,7 @@ namespace Duplicati.Library.Backend
                         Folder = new FolderFacet(),
                     };
 
-                    folderItem = this.Post(string.Format("{0}/items/{1}/children", this.DrivePrefix, parentFolder), newFolder);
+                    folderItem = this.Post($"{this.DrivePrefix}/items/{parentFolder}/children", newFolder);
                 }
 
                 parentFolder = folderItem.Id;
@@ -328,7 +328,7 @@ namespace Duplicati.Library.Backend
 
         public IEnumerable<IFileEntry> List()
         {
-            foreach (DriveItem item in this.Enumerate<DriveItem>(string.Format("{0}/root:{1}:/children", this.DrivePrefix, this.RootPath)))
+            foreach (DriveItem item in this.Enumerate<DriveItem>($"{this.DrivePrefix}/root:{this.RootPath}:/children"))
             {
                 // Exclude non-files and deleted items (not sure if they show up in this listing, but make sure anyway)
                 if (item.IsFile && !item.IsDeleted)
@@ -354,7 +354,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                string getUrl = string.Format("{0}/root:{1}{2}:/content", this.DrivePrefix, this.RootPath, NormalizeSlashes(remotename));
+                string getUrl = $"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(remotename)}:/content";
                 if (this.m_client != null)
                 {
                     using (var response = this.m_client.GetAsync(getUrl).Await())
@@ -389,7 +389,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                this.Patch(string.Format("{0}/root:{1}{2}", this.DrivePrefix, this.RootPath, NormalizeSlashes(oldname)), new DriveItem() { Name = newname });
+                this.Patch($"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(oldname)}", new DriveItem() { Name = newname });
             }
             catch (DriveItemNotFoundException ex)
             {
@@ -411,7 +411,7 @@ namespace Duplicati.Library.Backend
             // PUT only supports up to 4 MB file uploads. There's a separate process for larger files.
             if (stream.Length < PUT_MAX_SIZE)
             {
-                string putUrl = string.Format("{0}/root:{1}{2}:/content", this.DrivePrefix, this.RootPath, NormalizeSlashes(remotename));
+                string putUrl = $"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(remotename)}:/content";
                 if (this.m_client != null)
                 {
                     using (StreamContent streamContent = new StreamContent(stream))
@@ -440,7 +440,7 @@ namespace Duplicati.Library.Backend
                 // The documentation seems somewhat contradictory - it states that uploads must be done sequentially,
                 // but also states that the nextExpectedRanges value returned may indicate multiple ranges...
                 // For now, this plays it safe and does a sequential upload.
-                string createSessionUrl = string.Format("{0}/root:{1}{2}:/createUploadSession", this.DrivePrefix, this.RootPath, NormalizeSlashes(remotename));
+                string createSessionUrl = $"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(remotename)}:/createUploadSession";
                 if (this.m_client != null)
                 {
                     using (HttpRequestMessage createSessionRequest = new HttpRequestMessage(HttpMethod.Post, createSessionUrl))
@@ -602,7 +602,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                string deleteUrl = string.Format("{0}/root:{1}{2}", this.DrivePrefix, this.RootPath, NormalizeSlashes(remotename));
+                string deleteUrl = $"{this.DrivePrefix}/root:{this.RootPath}{NormalizeSlashes(remotename)}";
                 if (this.m_client != null)
                 {
                     using (var response = this.m_client.DeleteAsync(deleteUrl).Await())
@@ -629,7 +629,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                string rootPath = string.Format("{0}/root:{1}", this.DrivePrefix, this.RootPath);
+                string rootPath = $"{this.DrivePrefix}/root:{this.RootPath}";
                 this.Get<DriveItem>(rootPath);
             }
             catch (DriveItemNotFoundException ex)
diff --git a/Duplicati/Library/Backend/OneDrive/MicrosoftGroup.cs b/Duplicati/Library/Backend/OneDrive/MicrosoftGroup.cs
index 2907d88c0..523f6d7f9 100644
--- a/Duplicati/Library/Backend/OneDrive/MicrosoftGroup.cs
+++ b/Duplicati/Library/Backend/OneDrive/MicrosoftGroup.cs
@@ -41,7 +41,7 @@ namespace Duplicati.Library.Backend
                 throw new UserInformationException(Strings.MicrosoftGroup.MissingGroupIdAndEmailAddress, "MicrosoftGroupMissingGroupIdAndEmailAddress");
             }
 
-            this.drivePath = string.Format("/groups/{0}/drive", groupId);
+            this.drivePath = $"/groups/{groupId}/drive";
         }
 
         public override string ProtocolKey
diff --git a/Duplicati/Library/Backend/OneDrive/OneDriveV2.cs b/Duplicati/Library/Backend/OneDrive/OneDriveV2.cs
index fa151a710..575d15634 100644
--- a/Duplicati/Library/Backend/OneDrive/OneDriveV2.cs
+++ b/Duplicati/Library/Backend/OneDrive/OneDriveV2.cs
@@ -20,7 +20,7 @@ namespace Duplicati.Library.Backend
             string driveId;
             if (options.TryGetValue(DRIVE_ID_OPTION, out driveId))
             {
-                this.drivePath = string.Format("/drives/{0}", driveId);
+                this.drivePath = $"/drives/{driveId}";
             }
             else
             {
diff --git a/Duplicati/Library/Backend/OneDrive/SharePointV2.cs b/Duplicati/Library/Backend/OneDrive/SharePointV2.cs
index d42b7195a..3ef03eaee 100644
--- a/Duplicati/Library/Backend/OneDrive/SharePointV2.cs
+++ b/Duplicati/Library/Backend/OneDrive/SharePointV2.cs
@@ -38,7 +38,7 @@ namespace Duplicati.Library.Backend
                 throw new UserInformationException(Strings.SharePointV2.MissingSiteId, "SharePointMissingSiteId");
             }
 
-            this.drivePath = string.Format("/sites/{0}/drive", this.siteId);
+            this.drivePath = $"/sites/{this.siteId}/drive";
         }
 
         public override string ProtocolKey
@@ -94,7 +94,7 @@ namespace Duplicati.Library.Backend
             if (string.Equals(uri.Host, "https", StringComparison.OrdinalIgnoreCase) || string.Equals(uri.Host, "http", StringComparison.OrdinalIgnoreCase))
             {
                 // LocalPath will already be prefixed by "//", due to the https:// part.
-                uri = new Uri(string.Format("{0}:{1}", uri.Scheme, uri.LocalPath));
+                uri = new Uri($"{uri.Scheme}:{uri.LocalPath}");
             }
 
             SharePointSite site = this.GetSharePointSite(uri);
@@ -103,7 +103,7 @@ namespace Duplicati.Library.Backend
                 // Get the web URL of the site's main drive
                 try
                 {
-                    Drive drive = this.Get<Drive>(string.Format("{0}/sites/{1}/drive", this.ApiVersion, site.Id));
+                    Drive drive = this.Get<Drive>($"{this.ApiVersion}/sites/{site.Id}/drive");
 
                     this.siteId = site.Id;
                     Uri driveWebUrl = new Uri(drive.WebUrl);
@@ -127,7 +127,7 @@ namespace Duplicati.Library.Backend
             // We can get a SharePoint site's info by querying /v1.0/sites/{hostname}:{siteWebPath}.
             // Since this full URL likely has the web path as some subpart of it, we check against each subpath to see if that is a site,
             // and if it is, we record the site ID.
-            string requestBase = string.Format("{0}/sites/{1}", this.ApiVersion, uri.Host);
+            string requestBase = $"{this.ApiVersion}/sites/{uri.Host}";
 
             // Just like the original SharePoint backend, use the "//" as a hint at where the site might be
             int siteHint = uri.Path.IndexOf("//", StringComparison.Ordinal);
@@ -135,7 +135,7 @@ namespace Duplicati.Library.Backend
             {
                 try
                 {
-                    string request = string.Format("{0}:/{1}", requestBase, uri.Path.Substring(0, siteHint));
+                    string request = $"{requestBase}:/{uri.Path.Substring(0, siteHint)}";
                     return this.Get<SharePointSite>(request);
                 }
                 catch (MicrosoftGraphException)
@@ -149,7 +149,7 @@ namespace Duplicati.Library.Backend
             {
                 try
                 {
-                    string request = string.Format("{0}:/{1}", requestBase, string.Join("/", pathPieces.Take(i)));
+                    string request = $"{requestBase}:/{string.Join("/", pathPieces.Take(i))}";
                     return this.Get<SharePointSite>(request);
                 }
                 catch (MicrosoftGraphException)
diff --git a/Duplicati/Library/Backend/OpenStack/OpenStackStorage.cs b/Duplicati/Library/Backend/OpenStack/OpenStackStorage.cs
index 306aa9087..97ee9ffcc 100644
--- a/Duplicati/Library/Backend/OpenStack/OpenStackStorage.cs
+++ b/Duplicati/Library/Backend/OpenStack/OpenStackStorage.cs
@@ -531,7 +531,7 @@ namespace Duplicati.Library.Backend.OpenStack
 
         public IEnumerable<IFileEntry> List()
         {
-            var plainurl = JoinUrls(SimpleStorageEndPoint, m_container) + string.Format("?format=json&delimiter=/&limit={0}", PAGE_LIMIT);
+            var plainurl = JoinUrls(SimpleStorageEndPoint, m_container) + $"?format=json&delimiter=/&limit={PAGE_LIMIT}";
             if (!string.IsNullOrEmpty(m_prefix))
                 plainurl += "&prefix=" + Library.Utility.Uri.UrlEncode(m_prefix);
 
@@ -561,7 +561,7 @@ namespace Duplicati.Library.Backend.OpenStack
                     yield break;
 
                 // Prepare next listing entry
-                url = plainurl + string.Format("&marker={0}", Library.Utility.Uri.UrlEncode(items.Last().name));
+                url = plainurl + $"&marker={Library.Utility.Uri.UrlEncode(items.Last().name)}";
             }
         }
 
@@ -611,7 +611,7 @@ namespace Duplicati.Library.Backend.OpenStack
             {
                 var authuris = new StringBuilder();
                 foreach(var s in KNOWN_OPENSTACK_PROVIDERS)
-                    authuris.AppendLine(string.Format("{0}: {1}", s.Key, s.Value));
+                    authuris.AppendLine($"{s.Key}: {s.Value}");
 
                 return new List<ICommandLineArgument>(new [] {
                     new CommandLineArgument(DOMAINNAME_OPTION, CommandLineArgument.ArgumentType.String, Strings.OpenStack.DomainnameOptionShort, Strings.OpenStack.DomainnameOptionLong),
diff --git a/Duplicati/Library/Backend/Rclone/Rclone.cs b/Duplicati/Library/Backend/Rclone/Rclone.cs
index a4bd84fca..024d7e648 100644
--- a/Duplicati/Library/Backend/Rclone/Rclone.cs
+++ b/Duplicati/Library/Backend/Rclone/Rclone.cs
@@ -103,7 +103,7 @@ namespace Duplicati.Library.Backend
 
             ProcessStartInfo psi = new ProcessStartInfo
             {
-                Arguments = String.Format("{0} {1}", arguments, opt_rclone),
+                Arguments = $"{arguments} {opt_rclone}",
                 CreateNoWindow = true,
                 FileName = command,
                 RedirectStandardError = true,
@@ -181,7 +181,7 @@ namespace Duplicati.Library.Backend
 
             if (errorBuilder.ToString().Contains(RCLONE_ERROR_CONFIG_NOT_FOUND))
             {
-                throw new Exception(String.Format("Missing config file? {0}", errorBuilder));
+                throw new Exception($"Missing config file? {errorBuilder}");
             }
 
             if (errorBuilder.Length > 0) {
@@ -199,7 +199,7 @@ namespace Duplicati.Library.Backend
             try
             {
 
-                str_result = RcloneCommandExecuter(rclone_executable, String.Format("lsjson {0}:{1}", remote_repo, remote_path), CancellationToken.None).Await();
+                str_result = RcloneCommandExecuter(rclone_executable, $"lsjson {remote_repo}:{remote_path}", CancellationToken.None).Await();
                 // this will give an error if the executable does not exist.
             }
 
@@ -237,7 +237,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                return RcloneCommandExecuter(rclone_executable, String.Format("copyto {0}:{1} {2}:{3}/{4}", local_repo, filename, remote_repo, remote_path, remotename), cancelToken);
+                return RcloneCommandExecuter(rclone_executable, $"copyto {local_repo}:{filename} {remote_repo}:{remote_path}/{remotename}", cancelToken);
             }
             catch (FolderMissingException ex)
             {
@@ -249,7 +249,7 @@ namespace Duplicati.Library.Backend
         {
             try
             {
-                RcloneCommandExecuter(rclone_executable, String.Format("copyto {2}:{3} {0}:{1}", local_repo, filename, remote_repo, Path.Combine(this.remote_path, remotename)), CancellationToken.None).Await();
+                RcloneCommandExecuter(rclone_executable, $"copyto {local_repo}:{filename} {remote_repo}:{Path.Combine(this.remote_path, remotename)}", CancellationToken.None).Await();
             }
             catch (FolderMissingException ex) {
                 throw new FileMissingException(ex);
@@ -262,7 +262,7 @@ namespace Duplicati.Library.Backend
             // Will give a "directory not found" error if the file does not exist, need to change that to a missing file exception
             try
             {
-                RcloneCommandExecuter(rclone_executable, String.Format("delete {0}:{1}", remote_repo, Path.Combine(remote_path, remotename)), CancellationToken.None).Await();
+                RcloneCommandExecuter(rclone_executable, $"delete {remote_repo}:{Path.Combine(remote_path, remotename)}", CancellationToken.None).Await();
             }
             catch (FolderMissingException ex) {
                 throw new FileMissingException(ex);
@@ -308,7 +308,7 @@ namespace Duplicati.Library.Backend
 
         public void CreateFolder()
         {
-            RcloneCommandExecuter(rclone_executable, String.Format("mkdir {0}:{1}", remote_repo, remote_path), CancellationToken.None).Await();
+            RcloneCommandExecuter(rclone_executable, $"mkdir {remote_repo}:{remote_path}", CancellationToken.None).Await();
         }
 
 #endregion
diff --git a/Duplicati/Library/Backend/S3/S3Backend.cs b/Duplicati/Library/Backend/S3/S3Backend.cs
index 2470b196d..816d122df 100644
--- a/Duplicati/Library/Backend/S3/S3Backend.cs
+++ b/Duplicati/Library/Backend/S3/S3Backend.cs
@@ -150,7 +150,7 @@ namespace Duplicati.Library.Backend
                 {
                     var name = new Regex("([a-z])([A-Z])").Replace(f.Name, "$1 $2");
                     var prop = f.GetValue(null) as Amazon.S3.S3StorageClass;
-                    if (prop != null && prop.Value != null)
+                    if (prop?.Value != null)
                         yield return new KeyValuePair<string, string>(name, prop.Value);
                 }
             }
@@ -371,10 +371,10 @@ namespace Duplicati.Library.Backend
                 StringBuilder hostnames = new StringBuilder();
                 StringBuilder locations = new StringBuilder();
                 foreach (var s in KNOWN_S3_PROVIDERS)
-                    hostnames.AppendLine(string.Format("{0}: {1}", s.Key, s.Value));
+                    hostnames.AppendLine($"{s.Key}: {s.Value}");
 
                 foreach (var s in KNOWN_S3_LOCATIONS)
-                    locations.AppendLine(string.Format("{0}: {1}", s.Key, s.Value));
+                    locations.AppendLine($"{s.Key}: {s.Value}");
 
                 var defaults = new Amazon.S3.AmazonS3Config();
 
@@ -384,8 +384,8 @@ namespace Duplicati.Library.Backend
                             "s3-ext-" + x.Name.ToLowerInvariant(),
                             x.PropertyType == typeof(bool) ? CommandLineArgument.ArgumentType.Boolean : x.PropertyType.IsEnum ? CommandLineArgument.ArgumentType.Enumeration : CommandLineArgument.ArgumentType.String,
                             x.Name,
-                            string.Format("Extended option {0}", x.Name),
-                            string.Format("{0}", x.GetValue(defaults)),
+                            $"Extended option {x.Name}",
+                            $"{x.GetValue(defaults)}",
                             null,
                             x.PropertyType.IsEnum ? Enum.GetNames(x.PropertyType) : null));
 
diff --git a/Duplicati/Library/Backend/S3/S3IAM.cs b/Duplicati/Library/Backend/S3/S3IAM.cs
index f7e1f5429..c6557702b 100644
--- a/Duplicati/Library/Backend/S3/S3IAM.cs
+++ b/Duplicati/Library/Backend/S3/S3IAM.cs
@@ -89,7 +89,7 @@ namespace Duplicati.Library.Backend
             ValidateArgument(operationstring, KEY_OPERATION);
 
             if (!Enum.TryParse(operationstring, true, out Operation operation))
-                throw new ArgumentException(string.Format("Unable to parse {0} as an operation", operationstring));
+                throw new ArgumentException($"Unable to parse {operationstring} as an operation");
 
             switch (operation)
             {
@@ -207,8 +207,8 @@ namespace Duplicati.Library.Backend
         private static IDictionary<string, string> CreateUnprivilegedUser(string awsid, string awskey, string path)
         {
             var now = Utility.Utility.SerializeDateTime(DateTime.Now);
-            var username = string.Format("duplicati-autocreated-backup-user-{0}", now);
-            var policyname = string.Format("duplicati-autocreated-policy-{0}", now);
+            var username = $"duplicati-autocreated-backup-user-{now}";
+            var policyname = $"duplicati-autocreated-policy-{now}";
             var policydoc = GeneratePolicyDoc(path);
 
             var cl = new AmazonIdentityManagementServiceClient(awsid, awskey);
diff --git a/Duplicati/Library/Backend/SSHv2/KeyGenerator.cs b/Duplicati/Library/Backend/SSHv2/KeyGenerator.cs
index 4a09c6096..bbbeadd24 100644
--- a/Duplicati/Library/Backend/SSHv2/KeyGenerator.cs
+++ b/Duplicati/Library/Backend/SSHv2/KeyGenerator.cs
@@ -204,7 +204,7 @@ namespace Duplicati.Library.Backend
             }
             else
             {
-                throw new UserInformationException(string.Format("Unsupported key type: {0}", keytype), "SSHUnsupportedKey");
+                throw new UserInformationException($"Unsupported key type: {keytype}", "SSHUnsupportedKey");
             }
         }
         public string Key { get { return "ssh-keygen"; } }
diff --git a/Duplicati/Library/Backend/SharePoint/SharePointBackend.cs b/Duplicati/Library/Backend/SharePoint/SharePointBackend.cs
index c0af18060..f6b7aebd4 100644
--- a/Duplicati/Library/Backend/SharePoint/SharePointBackend.cs
+++ b/Duplicati/Library/Backend/SharePoint/SharePointBackend.cs
@@ -268,7 +268,7 @@ namespace Duplicati.Library.Backend
                     ctx = null;
                 }
             }
-            finally { if (ctx != null) { ctx.Dispose(); } }
+            finally { ctx?.Dispose(); }
 
             return result;
         }
diff --git a/Duplicati/Library/Backend/Sia/Sia.cs b/Duplicati/Library/Backend/Sia/Sia.cs
index a9c0f1030..47612c73f 100644
--- a/Duplicati/Library/Backend/Sia/Sia.cs
+++ b/Duplicati/Library/Backend/Sia/Sia.cs
@@ -76,7 +76,7 @@ namespace Duplicati.Library.Backend.Sia
             }
 
             req.KeepAlive = false;
-            req.UserAgent = string.Format("Sia-Agent (Duplicati SIA client {0})", System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
+            req.UserAgent = $"Sia-Agent (Duplicati SIA client {System.Reflection.Assembly.GetExecutingAssembly().GetName().Version})";
 
             return req;
         }
@@ -95,7 +95,7 @@ namespace Duplicati.Library.Backend.Sia
             {
                 body = reader.ReadToEnd();
             }
-            return string.Format("{0} failed, response: {1}", context, body);
+            return $"{context} failed, response: {body}";
         }
 
         public class SiaFile
@@ -321,11 +321,7 @@ namespace Duplicati.Library.Backend.Sia
             string siafile = m_targetpath + "/" + remotename;
 
             try {
-                endpoint = string.Format("/renter/upload/{0}/{1}?source={2}",
-                    m_targetpath, 
-                    Utility.Uri.UrlEncode(remotename).Replace("+", "%20"),
-                    Utility.Uri.UrlEncode(filename).Replace("+", "%20")
-                );
+                endpoint = $"/renter/upload/{m_targetpath}/{Utility.Uri.UrlEncode(remotename).Replace("+", "%20")}?source={Utility.Uri.UrlEncode(filename).Replace("+", "%20")}";
 
                 HttpWebRequest req = CreateRequest(endpoint);
                 req.Method = WebRequestMethods.Http.Post;
@@ -360,11 +356,7 @@ namespace Duplicati.Library.Backend.Sia
 
             try
             {
-                endpoint = string.Format("/renter/download/{0}/{1}?destination={2}",
-                    m_targetpath,
-                    Library.Utility.Uri.UrlEncode(remotename).Replace("+", "%20"),
-                    Library.Utility.Uri.UrlEncode(tmpfilename).Replace("+", "%20")
-                );
+                endpoint = $"/renter/download/{m_targetpath}/{Library.Utility.Uri.UrlEncode(remotename).Replace("+", "%20")}?destination={Library.Utility.Uri.UrlEncode(tmpfilename).Replace("+", "%20")}";
                 System.Net.HttpWebRequest req = CreateRequest(endpoint);
                 req.Method = System.Net.WebRequestMethods.Http.Get;
 
@@ -406,10 +398,7 @@ namespace Duplicati.Library.Backend.Sia
 
             try
             {
-                endpoint = string.Format("/renter/delete/{0}/{1}",
-                    m_targetpath,
-                    Library.Utility.Uri.UrlEncode(remotename).Replace("+", "%20")
-                );
+                endpoint = $"/renter/delete/{m_targetpath}/{Library.Utility.Uri.UrlEncode(remotename).Replace("+", "%20")}";
                 System.Net.HttpWebRequest req = CreateRequest(endpoint);
                 req.Method = System.Net.WebRequestMethods.Http.Post;
 
diff --git a/Duplicati/Library/Backend/Tardigrade/TardigradeFile.cs b/Duplicati/Library/Backend/Tardigrade/TardigradeFile.cs
index 794e427e0..f074fbde8 100644
--- a/Duplicati/Library/Backend/Tardigrade/TardigradeFile.cs
+++ b/Duplicati/Library/Backend/Tardigrade/TardigradeFile.cs
@@ -29,7 +29,7 @@ namespace Duplicati.Library.Backend.Tardigrade
         public TardigradeFile(uplink.NET.Models.Object tardigradeObject)
         {
             IsFolder = tardigradeObject.IsPrefix;
-            var lastAccess = tardigradeObject.CustomMetaData.Entries.Where(e => e.Key == TARDIGRADE_LAST_ACCESS).FirstOrDefault();
+            var lastAccess = tardigradeObject.CustomMetaData.Entries.FirstOrDefault(e => e.Key == TARDIGRADE_LAST_ACCESS);
             if (lastAccess != null && !string.IsNullOrEmpty(lastAccess.Value))
             {
                 LastAccess = DateTime.Parse(lastAccess.Value);
@@ -39,7 +39,7 @@ namespace Duplicati.Library.Backend.Tardigrade
                 LastAccess = DateTime.MinValue;
             }
 
-            var lastMod = tardigradeObject.CustomMetaData.Entries.Where(e => e.Key == TARDIGRADE_LAST_MODIFICATION).FirstOrDefault();
+            var lastMod = tardigradeObject.CustomMetaData.Entries.FirstOrDefault(e => e.Key == TARDIGRADE_LAST_MODIFICATION);
             if (lastMod != null && !string.IsNullOrEmpty(lastMod.Value))
             {
                 LastModification = DateTime.Parse(lastMod.Value);
diff --git a/Duplicati/Library/Common/IO/SystemIOLinux.cs b/Duplicati/Library/Common/IO/SystemIOLinux.cs
index 1acb95b47..dbfb3c008 100644
--- a/Duplicati/Library/Common/IO/SystemIOLinux.cs
+++ b/Duplicati/Library/Common/IO/SystemIOLinux.cs
@@ -183,7 +183,7 @@ namespace Duplicati.Library.Common.IO
                     dict["unix-ext:" + x.Key] = Convert.ToBase64String(x.Value);
 
             var fse = UnixSupport.File.GetUserGroupAndPermissions(f);
-            dict["unix:uid-gid-perm"] = string.Format("{0}-{1}-{2}", fse.UID, fse.GID, fse.Permissions);
+            dict["unix:uid-gid-perm"] = $"{fse.UID}-{fse.GID}-{fse.Permissions}";
             if (fse.OwnerName != null)
             {
                 dict["unix:owner-name"] = fse.OwnerName;
diff --git a/Duplicati/Library/Common/IO/SystemIOWindows.cs b/Duplicati/Library/Common/IO/SystemIOWindows.cs
index b29a34331..9f7190a2f 100644
--- a/Duplicati/Library/Common/IO/SystemIOWindows.cs
+++ b/Duplicati/Library/Common/IO/SystemIOWindows.cs
@@ -516,7 +516,7 @@ namespace Duplicati.Library.Common.IO
         public void CreateSymlink(string symlinkfile, string target, bool asDir)
         {
             if (FileExists(symlinkfile) || DirectoryExists(symlinkfile))
-                throw new System.IO.IOException(string.Format("File already exists: {0}", symlinkfile));
+                throw new System.IO.IOException($"File already exists: {symlinkfile}");
 
             if (asDir)
             {
@@ -534,7 +534,7 @@ namespace Duplicati.Library.Common.IO
                 catch { }
 
             if ((attr & System.IO.FileAttributes.ReparsePoint) == 0)
-                throw new System.IO.IOException(string.Format("Unable to create symlink, check account permissions: {0}", symlinkfile));
+                throw new System.IO.IOException($"Unable to create symlink, check account permissions: {symlinkfile}");
         }
         #endregion
     }
diff --git a/Duplicati/Library/Common/IO/VssBackupComponents.cs b/Duplicati/Library/Common/IO/VssBackupComponents.cs
index bffaa28d6..d7f555e53 100644
--- a/Duplicati/Library/Common/IO/VssBackupComponents.cs
+++ b/Duplicati/Library/Common/IO/VssBackupComponents.cs
@@ -94,7 +94,7 @@ namespace Duplicati.Library.Common.IO
             {
                 if (!_vssBackupComponents.WriterMetadata.Any(o => o.WriterId.Equals(writerGUID)))
                 {
-                    throw new Exception(string.Format("Writer with GUID {0} was not added to VSS writer set.", writerGUID.ToString()));
+                    throw new Exception($"Writer with GUID {writerGUID.ToString()} was not added to VSS writer set.");
                 }
             }
         }
diff --git a/Duplicati/Library/Compression/FileArchiveZip.cs b/Duplicati/Library/Compression/FileArchiveZip.cs
index 0f59b08f3..cd78ceb5b 100644
--- a/Duplicati/Library/Compression/FileArchiveZip.cs
+++ b/Duplicati/Library/Compression/FileArchiveZip.cs
@@ -184,7 +184,7 @@ namespace Duplicati.Library.Compression
                             rd.Dispose();
                         });
 
-                throw new Exception(string.Format("Stream not found: {0}", entry.Key));
+                throw new Exception($"Stream not found: {entry.Key}");
             }
             catch
             {
@@ -334,7 +334,7 @@ namespace Duplicati.Library.Compression
             else if (ze is SharpCompress.Common.Zip.ZipEntry)
                 return GetStreamFromReader(ze);
 
-            throw new Exception(string.Format("Unexpected result: {0}", ze.GetType().FullName));
+            throw new Exception($"Unexpected result: {ze.GetType().FullName}");
 
         }
 
diff --git a/Duplicati/Library/DynamicLoader/DynamicLoader.cs b/Duplicati/Library/DynamicLoader/DynamicLoader.cs
index 79db17535..b8c62d527 100644
--- a/Duplicati/Library/DynamicLoader/DynamicLoader.cs
+++ b/Duplicati/Library/DynamicLoader/DynamicLoader.cs
@@ -127,8 +127,7 @@ namespace Duplicati.Library.DynamicLoader
                                     //TODO: Figure out how to support types with no default constructors
                                     if (t.GetConstructor(Type.EmptyTypes) != null)
                                     {
-                                        T i = Activator.CreateInstance(t) as T;
-                                        if (i != null)
+                                        if (Activator.CreateInstance(t) is T i)
                                             interfaces.Add(i);
                                     }
                                 }
diff --git a/Duplicati/Library/Localization/MoLocalizationService.cs b/Duplicati/Library/Localization/MoLocalizationService.cs
index 2616a038a..5a421e3b8 100644
--- a/Duplicati/Library/Localization/MoLocalizationService.cs
+++ b/Duplicati/Library/Localization/MoLocalizationService.cs
@@ -72,9 +72,9 @@ namespace Duplicati.Library.Localization
         {
             var filenames = new string[] { 
                 // Load the specialized version first
-                string.Format("localization-{0}.mo", ci.Name.Replace('-', '_')), 
+                $"localization-{ci.Name.Replace('-', '_')}.mo", 
                 // Then try the generic language version
-                string.Format("localization-{0}.mo", ci.TwoLetterISOLanguageName) 
+                $"localization-{ci.TwoLetterISOLanguageName}.mo" 
             };
 
             foreach(var fn in filenames)
diff --git a/Duplicati/Library/Logging/LogEntry.cs b/Duplicati/Library/Logging/LogEntry.cs
index 983a98184..a3999c94d 100644
--- a/Duplicati/Library/Logging/LogEntry.cs
+++ b/Duplicati/Library/Logging/LogEntry.cs
@@ -127,7 +127,7 @@ namespace Duplicati.Library.Logging
                 catch
                 {
                     // Try no to crash ...
-                    return string.Format("Error while formating: \"{0}\" with arguments: [{1}]", Message, string.Join(", ", Arguments.Select(x => x == null ? "(null)" : x.ToString())));
+                    return $"Error while formating: \"{Message}\" with arguments: [{string.Join(", ", Arguments.Select(x => x == null ? "(null)" : x.ToString()))}]";
 
                 }
             }
diff --git a/Duplicati/Library/Main/BackendManager.cs b/Duplicati/Library/Main/BackendManager.cs
index 904e300b1..5172afd6a 100644
--- a/Duplicati/Library/Main/BackendManager.cs
+++ b/Duplicati/Library/Main/BackendManager.cs
@@ -237,7 +237,7 @@ namespace Duplicati.Library.Main
                         case OperationType.CreateFolder:
                             return BackendActionType.CreateFolder;
                         default:
-                            throw new Exception(string.Format("Unexpected operation type: {0}", this.Operation));
+                            throw new Exception($"Unexpected operation type: {this.Operation}");
                     }
                 }
             }
@@ -386,14 +386,14 @@ namespace Duplicati.Library.Main
                 try { shortname = new Library.Utility.Uri(shortname).Scheme; }
                 catch { }
 
-                throw new Duplicati.Library.Interface.UserInformationException(string.Format("Backend not supported: {0}", shortname), "BackendNotSupported");
+                throw new Duplicati.Library.Interface.UserInformationException($"Backend not supported: {shortname}", "BackendNotSupported");
             }
 
             if (!m_options.NoEncryption)
             {
                 m_encryption = DynamicLoader.EncryptionLoader.GetModule(m_options.EncryptionModule, m_options.Passphrase, m_options.RawOptions);
                 if (m_encryption == null)
-                    throw new Duplicati.Library.Interface.UserInformationException(string.Format("Encryption method not supported: {0}", m_options.EncryptionModule), "EncryptionMethodNotSupported");
+                    throw new Duplicati.Library.Interface.UserInformationException($"Encryption method not supported: {m_options.EncryptionModule}", "EncryptionMethodNotSupported");
             }
 
             if (m_taskControl != null)
@@ -474,7 +474,7 @@ namespace Duplicati.Library.Main
                             if (m_backend == null)
                                 throw new Exception("Backend failed to re-load");
 
-                            using (new Logging.Timer(LOGTAG, string.Format("RemoteOperation{0}", item.Operation), string.Format("RemoteOperation{0}", item.Operation)))
+                            using (new Logging.Timer(LOGTAG, $"RemoteOperation{item.Operation}", $"RemoteOperation{item.Operation}"))
                                 switch (item.Operation)
                                 {
                                     case OperationType.Put:
@@ -746,9 +746,9 @@ namespace Duplicati.Library.Main
             {
                 var f = m_backend.List().FirstOrDefault(n => n.Name.Equals(item.RemoteFilename, StringComparison.OrdinalIgnoreCase));
                 if (f == null)
-                    throw new Exception(string.Format("List verify failed, file was not found after upload: {0}", item.RemoteFilename));
+                    throw new Exception($"List verify failed, file was not found after upload: {item.RemoteFilename}");
                 else if (f.Size != item.Size && f.Size >= 0)
-                    throw new Exception(string.Format("List verify failed for file: {0}, size was {1} but expected to be {2}", f.Name, f.Size, item.Size));
+                    throw new Exception($"List verify failed for file: {f.Name}, size was {f.Size} but expected to be {item.Size}");
             }
 
             item.DeleteLocalFile(m_statwriter);
diff --git a/Duplicati/Library/Main/Controller.cs b/Duplicati/Library/Main/Controller.cs
index 18669a994..01c3740e6 100644
--- a/Duplicati/Library/Main/Controller.cs
+++ b/Duplicati/Library/Main/Controller.cs
@@ -356,7 +356,7 @@ namespace Duplicati.Library.Main
             string targetmail;
             m_options.RawOptions.TryGetValue("send-mail-to", out targetmail);
             if (string.IsNullOrWhiteSpace(targetmail))
-                throw new Exception(string.Format("No email specified, please use --{0}", "send-mail-to"));
+                throw new Exception($"No email specified, please use --{"send-mail-to"}");
 
             m_options.RawOptions["disable-module"] = string.Join(
                 ",",
@@ -426,7 +426,7 @@ namespace Duplicati.Library.Main
                     Logging.Log.WriteInformationMessage(LOGTAG, "StartingOperation", Strings.Controller.StartingOperationMessage(m_options.MainAction));
 
                     using (new ProcessController(m_options))
-                    using (new Logging.Timer(LOGTAG, string.Format("Run{0}", result.MainOperation), string.Format("Running {0}", result.MainOperation)))
+                    using (new Logging.Timer(LOGTAG, $"Run{result.MainOperation}", $"Running {result.MainOperation}"))
                     using(new CoCoL.IsolatedChannelScope())
                     using(m_options.ConcurrencyMaxThreads <= 0 ? null : new CoCoL.CappedThreadedThreadPool(m_options.ConcurrencyMaxThreads))
                         method(result);
@@ -685,10 +685,9 @@ namespace Duplicati.Library.Main
                 selectedRetentionOptions.Add("retention-policy");
             }
 
-            if (selectedRetentionOptions.Count() > 1)
+            if (selectedRetentionOptions.Count > 1)
             {
-                throw new Interface.UserInformationException(string.Format("Setting multiple retention options ({0}) is not permitted",
-                    String.Join(", ", selectedRetentionOptions.Select(x => "--" + x))), "MultipleRetentionOptionsNotSupported");
+                throw new Interface.UserInformationException($"Setting multiple retention options ({String.Join(", ", selectedRetentionOptions.Select(x => "--" + x))}) is not permitted", "MultipleRetentionOptionsNotSupported");
             }
 
             // Check Prefix
@@ -709,7 +708,7 @@ namespace Duplicati.Library.Main
             }
             catch (Exception e) // simply reading the option value might also result in an exception due to incorrect formatting
             {
-                throw new Interface.UserInformationException(string.Format("An error occoured while processing the value of --{0}", "retention-policy"), "RetentionPolicyParseError", e);
+                throw new Interface.UserInformationException($"An error occoured while processing the value of --{"retention-policy"}", "RetentionPolicyParseError", e);
             }
 
             //Keep a list of all supplied options
diff --git a/Duplicati/Library/Main/Database/ExtensionMethods.cs b/Duplicati/Library/Main/Database/ExtensionMethods.cs
index 4cec546e4..faeb1fbff 100644
--- a/Duplicati/Library/Main/Database/ExtensionMethods.cs
+++ b/Duplicati/Library/Main/Database/ExtensionMethods.cs
@@ -49,11 +49,11 @@ namespace Duplicati.Library.Main.Database
                 {
                     string v;
                     if (p.Value is string)
-                        v = string.Format("\"{0}\"", p.Value);
+                        v = $"\"{p.Value}\"";
                     else if (p.Value == null)
                         v = "NULL";
                     else
-                        v = string.Format("{0}", p.Value);
+                        v = $"{p.Value}";
 
                     txt = txt.Substring(0, ix) + v + txt.Substring(ix + 1);
                 }
@@ -84,7 +84,7 @@ namespace Duplicati.Library.Main.Database
                     self.AddParameter(n);
             }
 
-            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteNonQuery", string.Format("ExecuteNonQuery: {0}", self.GetPrintableCommandText())) : null)
+            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteNonQuery", $"ExecuteNonQuery: {self.GetPrintableCommandText()}") : null)
                 return self.ExecuteNonQuery();
         }
 
@@ -105,7 +105,7 @@ namespace Duplicati.Library.Main.Database
                     self.AddParameter(n);
             }
 
-            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteScalar", string.Format("ExecuteScalar: {0}", self.GetPrintableCommandText())) : null)
+            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteScalar", $"ExecuteScalar: {self.GetPrintableCommandText()}") : null)
                 return self.ExecuteScalar();
         }
 
@@ -146,7 +146,7 @@ namespace Duplicati.Library.Main.Database
                     self.AddParameter(n);
             }
 
-            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteScalarInt64", string.Format("ExecuteScalarInt64: {0}", self.GetPrintableCommandText())) : null)
+            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteScalarInt64", $"ExecuteScalarInt64: {self.GetPrintableCommandText()}") : null)
                 using(var rd = self.ExecuteReader())
                     if (rd.Read())
                         return ConvertValueToInt64(rd, 0, defaultvalue);
@@ -171,7 +171,7 @@ namespace Duplicati.Library.Main.Database
                     self.AddParameter(n);
             }
 
-            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteReader", string.Format("ExecuteReader: {0}", self.GetPrintableCommandText())) : null)
+            using(writeLog ? new Logging.Timer(LOGTAG, "ExecuteReader", $"ExecuteReader: {self.GetPrintableCommandText()}") : null)
                 return self.ExecuteReader();
         }
 
diff --git a/Duplicati/Library/Main/Database/LocalBackupDatabase.cs b/Duplicati/Library/Main/Database/LocalBackupDatabase.cs
index 10b8f737e..74bc109bc 100644
--- a/Duplicati/Library/Main/Database/LocalBackupDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalBackupDatabase.cs
@@ -326,12 +326,12 @@ namespace Duplicati.Library.Main.Database
                         {
                             var bid = cmd.ExecuteScalarInt64(@"SELECT ""ID"" FROM ""Block"" WHERE ""Hash"" = ?", -1, h);
                             if (bid == -1)
-                                throw new Exception(string.Format("Could not find any blocks with the given hash: {0}", h));
+                                throw new Exception($"Could not find any blocks with the given hash: {h}");
                             foreach (var rd in cmd.ExecuteReaderEnumerable(@"SELECT ""Size"" FROM ""Block"" WHERE ""Hash"" = ?", h))
                                 Logging.Log.WriteErrorMessage(LOGTAG, "FoundIssue1400Error", null, "Found block with ID {0} and hash {1} and size {2}", bid, h, rd.ConvertValueToInt64(0, -1));
                         }
 
-                        throw new Exception(string.Format("Unexpected result count: {0}, expected {1}, check log for more messages", c, 1));
+                        throw new Exception($"Unexpected result count: {c}, expected {1}, check log for more messages");
                     }
 
                     ix++;
@@ -816,7 +816,7 @@ namespace Duplicati.Library.Main.Database
                 cmd.Transaction = transaction;
                 var c = cmd.ExecuteNonQuery(@"UPDATE ""Fileset"" SET ""VolumeID"" = ? WHERE ""ID"" = ?", volumeid, filesetid);
                 if (c != 1)
-                    throw new Exception(string.Format("Failed to link filesetid {0} to volumeid {1}", filesetid, volumeid));
+                    throw new Exception($"Failed to link filesetid {filesetid} to volumeid {volumeid}");
             }
         }
 
@@ -827,7 +827,7 @@ namespace Duplicati.Library.Main.Database
                 cmd.Transaction = transaction;
                 var c = cmd.ExecuteNonQuery(@"UPDATE ""Block"" SET ""VolumeID"" = ? WHERE ""Hash"" = ? AND ""Size"" = ? AND ""VolumeID"" = ? ", targetvolumeid, blockkey, size, sourcevolumeid);
                 if (c != 1)
-                    throw new Exception(string.Format("Failed to move block {0}:{1} from volume {2}, count: {3}", blockkey, size, sourcevolumeid, c));
+                    throw new Exception($"Failed to move block {blockkey}:{size} from volume {sourcevolumeid}, count: {c}");
             }
         }
 
@@ -839,7 +839,7 @@ namespace Duplicati.Library.Main.Database
             {
                 var c = cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Block"" WHERE ""VolumeID"" = ? ", -1, volumeid);
                 if (c != 0)
-                    throw new Exception(string.Format("Failed to safe-delete volume {0}, blocks: {1}", name, c));
+                    throw new Exception($"Failed to safe-delete volume {name}, blocks: {c}");
 
                 RemoveRemoteVolume(name, transaction);
             }
diff --git a/Duplicati/Library/Main/Database/LocalDatabase.cs b/Duplicati/Library/Main/Database/LocalDatabase.cs
index fd1048d20..f27f041f7 100644
--- a/Duplicati/Library/Main/Database/LocalDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalDatabase.cs
@@ -374,7 +374,7 @@ namespace Duplicati.Library.Main.Database
                 cmd.Transaction = tr.Parent;
                 var c = cmd.ExecuteNonQuery(@"DELETE FROM ""RemoteVolume"" WHERE ""Name"" = ? AND ""State"" = ? ", name, state.ToString());
                 if (c != 1)
-                    throw new Exception(string.Format("Unexpected number of remote volumes deleted: {0}, expected {1}", c, 1));
+                    throw new Exception($"Unexpected number of remote volumes deleted: {c}, expected {1}");
 
                 tr.Commit();
             }
@@ -780,11 +780,11 @@ ON
                 var unique_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM (SELECT DISTINCT ""BlocksetID"", ""Index"" FROM ""BlocklistHash"")", 0);
 
                 if (real_count != unique_count)
-                    throw new InvalidDataException(string.Format("Found {0} blocklist hashes, but there should be {1}. Run repair to fix it.", real_count, unique_count));
+                    throw new InvalidDataException($"Found {real_count} blocklist hashes, but there should be {unique_count}. Run repair to fix it.");
 
                 var itemswithnoblocklisthash = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM (SELECT * FROM (SELECT ""N"".""BlocksetID"", ((""N"".""BlockCount"" + {0} - 1) / {0}) AS ""BlocklistHashCountExpected"", CASE WHEN ""G"".""BlocklistHashCount"" IS NULL THEN 0 ELSE ""G"".""BlocklistHashCount"" END AS ""BlocklistHashCountActual"" FROM (SELECT ""BlocksetID"", COUNT(*) AS ""BlockCount"" FROM ""BlocksetEntry"" GROUP BY ""BlocksetID"") ""N"" LEFT OUTER JOIN (SELECT ""BlocksetID"", COUNT(*) AS ""BlocklistHashCount"" FROM ""BlocklistHash"" GROUP BY ""BlocksetID"") ""G"" ON ""N"".""BlocksetID"" = ""G"".""BlocksetID"" WHERE ""N"".""BlockCount"" > 1) WHERE ""BlocklistHashCountExpected"" != ""BlocklistHashCountActual"")", blocksize / hashsize), 0);
                 if (itemswithnoblocklisthash != 0)
-                    throw new InvalidDataException(string.Format("Found {0} file(s) with missing blocklist hashes", itemswithnoblocklisthash));
+                    throw new InvalidDataException($"Found {itemswithnoblocklisthash} file(s) with missing blocklist hashes");
 
                 if (cmd.ExecuteScalarInt64(@"SELECT COUNT(*) FROM ""Blockset"" WHERE ""Length"" > 0 AND ""ID"" NOT IN (SELECT ""BlocksetId"" FROM ""BlocksetEntry"")") != 0)
                 {
@@ -809,8 +809,8 @@ ON
                                 var filesetname = filesetid.ToString();
                                 var fileset = FilesetTimes.Zip(Enumerable.Range(0, FilesetTimes.Count()), (a, b) => new Tuple<long, long, DateTime>(b, a.Key, a.Value)).FirstOrDefault(x => x.Item2 == filesetid);
                                 if (fileset != null)
-                                    filesetname = string.Format("version {0}: {1} (database id: {2})", fileset.Item1, fileset.Item3, fileset.Item2);
-                                throw new Interface.UserInformationException(string.Format("Unexpected difference in fileset {0}, found {1} entries, but expected {2}", filesetname, expandedlist, storedlist), "FilesetDifferences");
+                                    filesetname = $"version {fileset.Item1}: {fileset.Item3} (database id: {fileset.Item2})";
+                                throw new Interface.UserInformationException($"Unexpected difference in fileset {filesetname}, found {expandedlist} entries, but expected {storedlist}", "FilesetDifferences");
                             }
                         }
                 }
@@ -1238,7 +1238,7 @@ ORDER BY
                 //Rename the old entry, to preserve ID links
                 var c = cmd.ExecuteNonQuery(@"UPDATE ""Remotevolume"" SET ""Name"" = ? WHERE ""Name"" = ?", newname, oldname);
                 if (c != 1)
-                    throw new Exception(string.Format("Unexpected result from renaming \"{0}\" to \"{1}\", expected {2} got {3}", oldname, newname, 1, c));
+                    throw new Exception($"Unexpected result from renaming \"{oldname}\" to \"{newname}\", expected {1} got {c}");
 
                 // Grab the type of entry
                 var type = (RemoteVolumeType)Enum.Parse(typeof(RemoteVolumeType), cmd.ExecuteScalar(@"SELECT ""Type"" FROM ""Remotevolume"" WHERE ""Name"" = ?", newname).ToString(), true);
diff --git a/Duplicati/Library/Main/Database/LocalDeleteDatabase.cs b/Duplicati/Library/Main/Database/LocalDeleteDatabase.cs
index f97d5ff4d..f26641928 100644
--- a/Duplicati/Library/Main/Database/LocalDeleteDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalDeleteDatabase.cs
@@ -82,7 +82,7 @@ namespace Duplicati.Library.Main.Database
                 }
 
                 if (deleted != toDelete.Length)
-                    throw new Exception(string.Format("Unexpected number of deleted filesets {0} vs {1}", deleted, toDelete.Length));
+                    throw new Exception($"Unexpected number of deleted filesets {deleted} vs {toDelete.Length}");
     
                 //Then we delete anything that is no longer being referenced
                 cmd.ExecuteNonQuery(@"DELETE FROM ""FilesetEntry"" WHERE ""FilesetID"" NOT IN (SELECT DISTINCT ""ID"" FROM ""Fileset"")");
@@ -101,7 +101,7 @@ namespace Duplicati.Library.Main.Database
                 var updated = cmd.ExecuteNonQuery(@"UPDATE ""RemoteVolume"" SET ""State"" = ? WHERE ""Type"" = ? AND ""State"" IN (?, ?, ?) AND ""ID"" NOT IN (SELECT ""VolumeID"" FROM ""Fileset"") ", RemoteVolumeState.Deleting.ToString(), RemoteVolumeType.Files.ToString(), RemoteVolumeState.Uploaded.ToString(), RemoteVolumeState.Verified.ToString(), RemoteVolumeState.Temporary.ToString());
 
                 if (deleted != updated)
-                    throw new Exception(string.Format("Unexpected number of remote volumes marked as deleted. Found {0} filesets, but {1} volumes", deleted, updated));
+                    throw new Exception($"Unexpected number of remote volumes marked as deleted. Found {deleted} filesets, but {updated} volumes");
 
                 using (var rd = cmd.ExecuteReader(@"SELECT ""Name"", ""Size"" FROM ""RemoteVolume"" WHERE ""Type"" = ? AND ""State"" = ? ", RemoteVolumeType.Files.ToString(), RemoteVolumeState.Deleting.ToString()))
                 {
diff --git a/Duplicati/Library/Main/Database/LocalPurgeDatabase.cs b/Duplicati/Library/Main/Database/LocalPurgeDatabase.cs
index 0f93da71a..49d77a70c 100644
--- a/Duplicati/Library/Main/Database/LocalPurgeDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalPurgeDatabase.cs
@@ -43,7 +43,7 @@ namespace Duplicati.Library.Main.Database
             using (var cmd = m_connection.CreateCommand(transaction))
             using (var rd = cmd.ExecuteReader(@"SELECT ""B"".""Name"" FROM ""Fileset"" A, ""RemoteVolume"" B WHERE ""A"".""VolumeID"" = ""B"".""ID"" AND ""A"".""ID"" = ? ", id))
                 if (!rd.Read())
-                    throw new Exception(string.Format("No remote volume found for fileset with id {0}", id));
+                    throw new Exception($"No remote volume found for fileset with id {id}");
                 else
                     return rd.ConvertValueToString(0);
         }
@@ -160,7 +160,7 @@ namespace Duplicati.Library.Main.Database
                     RemovedFileSize = cmd.ExecuteScalarInt64(string.Format(@"SELECT SUM(""C"".""Length"") FROM ""{0}"" A, ""FileLookup"" B, ""Blockset"" C WHERE ""A"".""FileID"" = ""B"".""ID"" AND ""B"".""BlocksetID"" = ""C"".""ID"" ", m_tablename), 0);
                     var filesetcount = cmd.ExecuteScalarInt64(string.Format(@"SELECT COUNT(*) FROM ""FilesetEntry"" WHERE ""FilesetID"" = " + ParentID), 0);
                     if (filesetcount == RemovedFileCount)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Refusing to purge {0} files from fileset with ID {1}, as that would remove the entire fileset.\nTo delete a fileset, use the \"delete\" command.", RemovedFileCount, ParentID), "PurgeWouldRemoveEntireFileset");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Refusing to purge {RemovedFileCount} files from fileset with ID {ParentID}, as that would remove the entire fileset.\nTo delete a fileset, use the \"delete\" command.", "PurgeWouldRemoveEntireFileset");
                 }
             }
 
diff --git a/Duplicati/Library/Main/Database/LocalRecreateDatabase.cs b/Duplicati/Library/Main/Database/LocalRecreateDatabase.cs
index 53db0845f..bba26b4a8 100644
--- a/Duplicati/Library/Main/Database/LocalRecreateDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalRecreateDatabase.cs
@@ -403,7 +403,7 @@ namespace Duplicati.Library.Main.Database
                 m_updateBlockVolumeCommand.SetParameterValue(2, size);
                 var c = m_updateBlockVolumeCommand.ExecuteNonQuery();
                 if (c != 1)
-                    throw new Exception(string.Format("Failed to update table, found {0} entries for key {1} with size {2}", c ,hash, size));
+                    throw new Exception($"Failed to update table, found {c} entries for key {hash} with size {size}");
                     
                 return true;
             }
diff --git a/Duplicati/Library/Main/Database/LocalRepairDatabase.cs b/Duplicati/Library/Main/Database/LocalRepairDatabase.cs
index 8b929a6d3..8d7b2fc57 100644
--- a/Duplicati/Library/Main/Database/LocalRepairDatabase.cs
+++ b/Duplicati/Library/Main/Database/LocalRepairDatabase.cs
@@ -40,7 +40,7 @@ namespace Duplicati.Library.Main.Database
             {
                 var filesetid = cmd.ExecuteScalarInt64(@"SELECT ""Fileset"".""ID"" FROM ""Fileset"",""RemoteVolume"" WHERE ""Fileset"".""VolumeID"" = ""RemoteVolume"".""ID"" AND ""RemoteVolume"".""Name"" = ?", -1, filelist);
                 if (filesetid == -1)
-                    throw new Exception(string.Format("No such remote file: {0}", filelist));
+                    throw new Exception($"No such remote file: {filelist}");
                     
                 return filesetid;
             }
@@ -155,7 +155,7 @@ namespace Duplicati.Library.Main.Database
                     
                     var blockCount = cmd.ExecuteNonQuery(string.Format(@"INSERT INTO ""{0}"" (""Hash"", ""Size"", ""Restored"") SELECT DISTINCT ""Block"".""Hash"", ""Block"".""Size"", 0 AS ""Restored"" FROM ""Block"",""Remotevolume"" WHERE ""Block"".""VolumeID"" = ""Remotevolume"".""ID"" AND ""Remotevolume"".""Name"" = ? ", m_tablename), volumename);
                     if (blockCount == 0)
-                        throw new Exception(string.Format("Unexpected empty block volume: {0}", volumename));
+                        throw new Exception($"Unexpected empty block volume: {volumename}");
 
                     cmd.ExecuteNonQuery(string.Format(@"CREATE UNIQUE INDEX ""{0}-Ix"" ON ""{0}"" (""Hash"", ""Size"", ""Restored"")", tablename));
                 }
@@ -386,12 +386,12 @@ namespace Duplicati.Library.Main.Database
                                     {
                                         var c = c5.ExecuteScalarInt64(null, -1, blkey, blocklistoffset, RemoteVolumeType.Blocks.ToString(), RemoteVolumeState.Uploaded.ToString(), RemoteVolumeState.Verified.ToString());
                                         if (c <= 0)
-                                            throw new Exception(string.Format("Missing block for blocklisthash: {0}", blkey));
+                                            throw new Exception($"Missing block for blocklisthash: {blkey}");
                                         else
                                         {
                                             var rc = c6.ExecuteNonQuery(null, c, c);
                                             if (rc != 2)
-                                                throw new Exception(string.Format("Unexpected update count: {0}", rc));
+                                                throw new Exception($"Unexpected update count: {rc}");
                                         }
                                     }
 
@@ -415,12 +415,12 @@ namespace Duplicati.Library.Main.Database
                                 {
                                     var c = c5.ExecuteScalarInt64(null, -1, blkeyfinal, blocklistoffset, RemoteVolumeType.Blocks.ToString(), RemoteVolumeState.Uploaded.ToString(), RemoteVolumeState.Verified.ToString());
                                     if (c == 0)
-                                        throw new Exception(string.Format("Missing block for blocklisthash: {0}", blkeyfinal));
+                                        throw new Exception($"Missing block for blocklisthash: {blkeyfinal}");
                                     else
                                     {
                                         var rc = c6.ExecuteNonQuery(null, c, c);
                                         if (rc != 2)
-                                            throw new Exception(string.Format("Unexpected update count: {0}", rc));
+                                            throw new Exception($"Unexpected update count: {rc}");
                                     }
                                 }
 
@@ -433,7 +433,7 @@ namespace Duplicati.Library.Main.Database
 
                     itemswithnoblocklisthash = cmd.ExecuteScalarInt64(countsql, 0);
                     if (itemswithnoblocklisthash != 0)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair, after repair {0} blocklisthashes were missing", itemswithnoblocklisthash), "MissingBlocklistHashesRepairFailed");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Failed to repair, after repair {itemswithnoblocklisthash} blocklisthashes were missing", "MissingBlocklistHashesRepairFailed");
 
                     Logging.Log.WriteInformationMessage(LOGTAG, "MissingBlocklisthashesRepaired", "Missing blocklisthashes repaired succesfully");
                     tr.Commit();
@@ -466,7 +466,7 @@ namespace Duplicati.Library.Main.Database
                             var expected = rd.GetInt32(2) - 1;
                             var actual = c2.ExecuteNonQuery(null, rd.GetValue(0), rd.GetValue(1), expected);
                             if (actual != expected)
-                                throw new Exception(string.Format("Unexpected number of results after fix, got: {0}, expected: {1}", actual, expected));
+                                throw new Exception($"Unexpected number of results after fix, got: {actual}, expected: {expected}");
                         }
                     }
 
@@ -478,7 +478,7 @@ namespace Duplicati.Library.Main.Database
                     var real_count = cmd.ExecuteScalarInt64(@"SELECT Count(*) FROM ""BlocklistHash""", 0);
 
                     if (real_count != unique_count)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Failed to repair, result should have been {0} blocklist hashes, but result was {1} blocklist hashes", unique_count, real_count), "DuplicateBlocklistHashesRepairFailed");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Failed to repair, result should have been {unique_count} blocklist hashes, but result was {real_count} blocklist hashes", "DuplicateBlocklistHashesRepairFailed");
 
                     try
                     {
@@ -519,7 +519,7 @@ namespace Duplicati.Library.Main.Database
                 cmd.ExecuteNonQuery(string.Format(@"DROP TABLE IF EXISTS ""{0}"" ", tablename));
 
                 if (aliens != 0)
-                    throw new Exception(string.Format("Not all blocks were found in {0}", filename));
+                    throw new Exception($"Not all blocks were found in {filename}");
             }
         }
 
@@ -567,13 +567,13 @@ ORDER BY
                     foreach (var r in cmd.ExecuteReaderEnumerable(query, hash, length))
                     {
                         if (!en.MoveNext())
-                            throw new Exception(string.Format("Too few entries in source blocklist with hash {0}", hash));
+                            throw new Exception($"Too few entries in source blocklist with hash {hash}");
                         if (en.Current != r.GetString(0))
-                            throw new Exception(string.Format("Mismatch in blocklist with hash {0}", hash));
+                            throw new Exception($"Mismatch in blocklist with hash {hash}");
                     }
 
                     if (en.MoveNext())
-                        throw new Exception(string.Format("Too many source blocklist entries in {0}", hash));
+                        throw new Exception($"Too many source blocklist entries in {hash}");
                 }
             }
         }
diff --git a/Duplicati/Library/Main/DatabaseLocator.cs b/Duplicati/Library/Main/DatabaseLocator.cs
index b014cda91..f0819207e 100644
--- a/Duplicati/Library/Main/DatabaseLocator.cs
+++ b/Duplicati/Library/Main/DatabaseLocator.cs
@@ -127,7 +127,7 @@ namespace Duplicati.Library.Main
                 select n).ToList();
             
             if (matches.Count > 1)
-                throw new Duplicati.Library.Interface.UserInformationException(string.Format("Multiple sources found for: {0}", backend), "MultipleLocalDatabaseSourcesFound");
+                throw new Duplicati.Library.Interface.UserInformationException($"Multiple sources found for: {backend}", "MultipleLocalDatabaseSourcesFound");
             
             // Re-select
             if (matches.Count == 0 && anyUsername && string.IsNullOrEmpty(username))
@@ -142,7 +142,7 @@ namespace Duplicati.Library.Main
                     select n).ToList();
                     
                 if (matches.Count > 1)
-                    throw new Duplicati.Library.Interface.UserInformationException(String.Format("Multiple sources found for \"{0}\", try supplying --{1}", backend, "auth-username"), "MultipleLocalDatabaseSourcesFound");
+                    throw new Duplicati.Library.Interface.UserInformationException($"Multiple sources found for \"{backend}\", try supplying --{"auth-username"}", "MultipleLocalDatabaseSourcesFound");
             }
             
             if (matches.Count == 0 && !autoCreate)
diff --git a/Duplicati/Library/Main/Operation/Backup/BackendUploader.cs b/Duplicati/Library/Main/Operation/Backup/BackendUploader.cs
index 307d60a52..4066f91e2 100644
--- a/Duplicati/Library/Main/Operation/Backup/BackendUploader.cs
+++ b/Duplicati/Library/Main/Operation/Backup/BackendUploader.cs
@@ -446,9 +446,9 @@ namespace Duplicati.Library.Main.Operation.Backup
             {
                 var f = backend.List().FirstOrDefault(n => n.Name.Equals(item.RemoteFilename, StringComparison.OrdinalIgnoreCase));
                 if (f == null)
-                    throw new Exception(string.Format("List verify failed, file was not found after upload: {0}", item.RemoteFilename));
+                    throw new Exception($"List verify failed, file was not found after upload: {item.RemoteFilename}");
                 else if (f.Size != item.Size && f.Size >= 0)
-                    throw new Exception(string.Format("List verify failed for file: {0}, size was {1} but expected to be {2}", f.Name, f.Size, item.Size));
+                    throw new Exception($"List verify failed for file: {f.Name}, size was {f.Size} but expected to be {item.Size}");
             }
 
             item.DeleteLocalFile();
diff --git a/Duplicati/Library/Main/Operation/Backup/FileProgressThrottler.cs b/Duplicati/Library/Main/Operation/Backup/FileProgressThrottler.cs
index 6cd145058..0fedc276c 100644
--- a/Duplicati/Library/Main/Operation/Backup/FileProgressThrottler.cs
+++ b/Duplicati/Library/Main/Operation/Backup/FileProgressThrottler.cs
@@ -97,7 +97,7 @@ namespace Duplicati.Library.Main.Operation.Backup
 
         private void DecreaseTransferRate(long bytesTransferred)
         {
-            var percentDecrease = (((double)100 / m_Files.Count()) / 100);
+            var percentDecrease = (((double)100 / m_Files.Count) / 100);
             var overAmount = bytesTransferred - m_MaxBytesPerSecond;
 
             foreach (var file in m_Files.OrderByDescending(f => f.Value.BytesPerSecond))
@@ -117,7 +117,7 @@ namespace Duplicati.Library.Main.Operation.Backup
 
         private void IncreaseTransferRate(long bytesTransferred)
         {
-            var percentIncrease = (((double)100 / m_Files.Count()) / 100);
+            var percentIncrease = (((double)100 / m_Files.Count) / 100);
             var underAmount = m_MaxBytesPerSecond - bytesTransferred;
 
             foreach (var file in m_Files.OrderByDescending(f => f.Value.BytesPerSecond))
diff --git a/Duplicati/Library/Main/Operation/BackupHandler.cs b/Duplicati/Library/Main/Operation/BackupHandler.cs
index f78246cdd..1e15a1906 100644
--- a/Duplicati/Library/Main/Operation/BackupHandler.cs
+++ b/Duplicati/Library/Main/Operation/BackupHandler.cs
@@ -410,7 +410,7 @@ namespace Duplicati.Library.Main.Operation
 
                 var probe_path = m_database.GetFirstPath();
                 if (probe_path != null && Util.GuessDirSeparator(probe_path) != Util.DirectorySeparatorString)
-                    throw new UserInformationException(string.Format("The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems, which is not supported. To proceed without losing remote data, delete all filesets and make sure the --{0} option is set, then run the backup again to re-use the existing data on the remote store.", "no-auto-compact"), "CrossOsDatabaseReuseNotSupported");
+                    throw new UserInformationException($"The backup contains files that belong to another operating system. Proceeding with a backup would cause the database to contain paths from two different operation systems, which is not supported. To proceed without losing remote data, delete all filesets and make sure the --{"no-auto-compact"} option is set, then run the backup again to re-use the existing data on the remote store.", "CrossOsDatabaseReuseNotSupported");
 
                 if (m_database.PartiallyRecreated)
                     throw new UserInformationException("The database was only partially recreated. This database may be incomplete and the repair process is not allowed to alter remote files as that could result in data loss.", "DatabaseIsPartiallyRecreated");
@@ -471,7 +471,7 @@ namespace Duplicati.Library.Main.Operation
                                 // Grab the previous backup ID, if any
                                 var prevfileset = m_database.FilesetTimes.FirstOrDefault();
                                 if (prevfileset.Value.ToUniversalTime() > m_database.OperationTimestamp.ToUniversalTime())
-                                    throw new Exception(string.Format("The previous backup has time {0}, but this backup has time {1}. Something is wrong with the clock.", prevfileset.Value.ToLocalTime(), m_database.OperationTimestamp.ToLocalTime()));
+                                    throw new Exception($"The previous backup has time {prevfileset.Value.ToLocalTime()}, but this backup has time {m_database.OperationTimestamp.ToLocalTime()}. Something is wrong with the clock.");
                                 
                                 var lastfilesetid = prevfileset.Value.Ticks == 0 ? -1 : prevfileset.Key;
 
diff --git a/Duplicati/Library/Main/Operation/Common/IndexVolumeCreator.cs b/Duplicati/Library/Main/Operation/Common/IndexVolumeCreator.cs
index 49f5495b7..8cb627798 100644
--- a/Duplicati/Library/Main/Operation/Common/IndexVolumeCreator.cs
+++ b/Duplicati/Library/Main/Operation/Common/IndexVolumeCreator.cs
@@ -152,7 +152,7 @@ namespace Duplicati.Library.Main.Operation.Common
                     {
                         var bh = Convert.ToBase64String(h.ComputeHash(b.Item2, 0, b.Item3));
                         if (bh != b.Item1)
-                            throw new Exception(string.Format("Internal consistency check failed, generated index block has wrong hash, {0} vs {1}", bh, b.Item1));
+                            throw new Exception($"Internal consistency check failed, generated index block has wrong hash, {bh} vs {b.Item1}");
                         w.WriteBlocklist(b.Item1, b.Item2, 0, b.Item3);
                     }
 
diff --git a/Duplicati/Library/Main/Operation/CompactHandler.cs b/Duplicati/Library/Main/Operation/CompactHandler.cs
index f02880aba..0caea117c 100644
--- a/Duplicati/Library/Main/Operation/CompactHandler.cs
+++ b/Duplicati/Library/Main/Operation/CompactHandler.cs
@@ -43,7 +43,7 @@ namespace Duplicati.Library.Main.Operation
         public virtual void Run()
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new Exception(string.Format("Database file does not exist: {0}", m_options.Dbpath));
+                throw new Exception($"Database file does not exist: {m_options.Dbpath}");
             
             using(var db = new LocalDeleteDatabase(m_options.Dbpath, "Compact"))
             {
@@ -164,7 +164,7 @@ namespace Duplicati.Library.Main.Operation
                                                 //TODO: How do we get the compression hint? Reverse query for filename in db?
                                                 var s = f.ReadBlock(e.Key, buffer);
                                                 if (s != e.Value)
-                                                    throw new Exception(string.Format("Size mismatch problem for block {0}, {1} vs {2}", e.Key, s, e.Value));
+                                                    throw new Exception($"Size mismatch problem for block {e.Key}, {s} vs {e.Value}");
 
                                                 newvol.AddBlock(e.Key, buffer, 0, s, Duplicati.Library.Interface.CompressionHint.Compressible);
                                                 if (newvolindex != null)
diff --git a/Duplicati/Library/Main/Operation/CreateBugReportHandler.cs b/Duplicati/Library/Main/Operation/CreateBugReportHandler.cs
index 7d0ba3ece..07b3e03c5 100644
--- a/Duplicati/Library/Main/Operation/CreateBugReportHandler.cs
+++ b/Duplicati/Library/Main/Operation/CreateBugReportHandler.cs
@@ -48,10 +48,10 @@ namespace Duplicati.Library.Main.Operation
                 m_targetpath = m_targetpath + "." + module;
 
             if (System.IO.File.Exists(m_targetpath))
-                throw new UserInformationException(string.Format("Output file already exists, not overwriting: {0}", m_targetpath), "BugReportTargetAlreadyExists");
+                throw new UserInformationException($"Output file already exists, not overwriting: {m_targetpath}", "BugReportTargetAlreadyExists");
 
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "BugReportSourceDatabaseNotFound");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "BugReportSourceDatabaseNotFound");
 
             m_result.OperationProgressUpdater.UpdatePhase(OperationPhase.BugReport_Running);
             m_result.OperationProgressUpdater.UpdateProgress(0);
diff --git a/Duplicati/Library/Main/Operation/DeleteHandler.cs b/Duplicati/Library/Main/Operation/DeleteHandler.cs
index c3693a1fe..6f4b752f8 100644
--- a/Duplicati/Library/Main/Operation/DeleteHandler.cs
+++ b/Duplicati/Library/Main/Operation/DeleteHandler.cs
@@ -46,7 +46,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run()
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseFileMissing");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseFileMissing");
 
             using(var db = new Database.LocalDeleteDatabase(m_options.Dbpath, "Delete"))
             {
diff --git a/Duplicati/Library/Main/Operation/FilelistProcessor.cs b/Duplicati/Library/Main/Operation/FilelistProcessor.cs
index 643c0110f..d6af657e5 100644
--- a/Duplicati/Library/Main/Operation/FilelistProcessor.cs
+++ b/Duplicati/Library/Main/Operation/FilelistProcessor.cs
@@ -111,7 +111,7 @@ namespace Duplicati.Library.Main.Operation
 
             if (extraCount > 0)
             {
-                var s = string.Format("Found {0} remote files that are not recorded in local storage, please run repair", extraCount);
+                var s = $"Found {extraCount} remote files that are not recorded in local storage, please run repair";
                 Logging.Log.WriteErrorMessage(LOGTAG, "ExtraRemoteFiles", null, s);
                 throw new Duplicati.Library.Interface.UserInformationException(s, "ExtraRemoteFiles");
             }
@@ -121,7 +121,7 @@ namespace Duplicati.Library.Main.Operation
 
             if (doubles.Count > 0)
             {
-                var s = string.Format("Found remote files reported as duplicates, either the backend module is broken or you need to manually remove the extra copies.\nThe following files were found multiple times: {0}", string.Join(", ", doubles));
+                var s = $"Found remote files reported as duplicates, either the backend module is broken or you need to manually remove the extra copies.\nThe following files were found multiple times: {string.Join(", ", doubles)}";
                 Logging.Log.WriteErrorMessage(LOGTAG, "DuplicateRemoteFiles", null, s);
                 throw new Duplicati.Library.Interface.UserInformationException(s, "DuplicateRemoteFiles");
             }
@@ -130,9 +130,9 @@ namespace Duplicati.Library.Main.Operation
             {
                 string s;
                 if (!tp.BackupPrefixes.Contains(options.Prefix) && tp.BackupPrefixes.Length > 0)
-                    s = string.Format("Found {0} files that are missing from the remote storage, and no files with the backup prefix {1}, but found the following backup prefixes: {2}", missingCount, options.Prefix, string.Join(", ", tp.BackupPrefixes));
+                    s = $"Found {missingCount} files that are missing from the remote storage, and no files with the backup prefix {options.Prefix}, but found the following backup prefixes: {string.Join(", ", tp.BackupPrefixes)}";
                 else
-                    s = string.Format("Found {0} files that are missing from the remote storage, please run repair", missingCount);
+                    s = $"Found {missingCount} files that are missing from the remote storage, please run repair";
 
                 Logging.Log.WriteErrorMessage(LOGTAG, "MissingRemoteFiles", null, s);
                 throw new Duplicati.Library.Interface.UserInformationException(s, "MissingRemoteFiles");
@@ -279,7 +279,7 @@ namespace Duplicati.Library.Main.Operation
                 if (e.Value == RemoteVolumeState.Uploading || e.Value == RemoteVolumeState.Temporary)
                     database.UnlinkRemoteVolume(e.Key, e.Value);
                 else
-                    throw new Exception(string.Format("The remote volume {0} appears in the database with state {1} and a deleted state, cannot continue", e.Key, e.Value.ToString()));
+                    throw new Exception($"The remote volume {e.Key} appears in the database with state {e.Value.ToString()} and a deleted state, cannot continue");
             }
 
             var locallist = database.GetRemoteVolumes();
diff --git a/Duplicati/Library/Main/Operation/ListAffected.cs b/Duplicati/Library/Main/Operation/ListAffected.cs
index 3c9c9e3bd..291946762 100644
--- a/Duplicati/Library/Main/Operation/ListAffected.cs
+++ b/Duplicati/Library/Main/Operation/ListAffected.cs
@@ -36,7 +36,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run(List<string> args, Action<Duplicati.Library.Interface.IListAffectedResults> callback = null)
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
 
             using(var db = new Database.LocalListAffectedDatabase(m_options.Dbpath))
             {
diff --git a/Duplicati/Library/Main/Operation/ListBrokenFilesHandler.cs b/Duplicati/Library/Main/Operation/ListBrokenFilesHandler.cs
index 3a7d78b94..e20a36914 100644
--- a/Duplicati/Library/Main/Operation/ListBrokenFilesHandler.cs
+++ b/Duplicati/Library/Main/Operation/ListBrokenFilesHandler.cs
@@ -42,7 +42,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run(Library.Utility.IFilter filter, Func<long, DateTime, long, string, long, bool> callbackhandler = null)
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
 
             using (var db = new Database.LocalListBrokenFilesDatabase(m_options.Dbpath))
             using (var tr = db.BeginTransaction())
@@ -111,7 +111,7 @@ namespace Duplicati.Library.Main.Operation
                 else if (missing.Count == 0)
                     Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenFilesetsOrMissingFiles", "Found no broken filesets and no missing remote files");
                 else
-                    Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenSetsButMissingRemoteFiles", string.Format("Found no broken filesets, but {0} missing remote files. Run purge-broken-files.", missing.Count));
+                    Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenSetsButMissingRemoteFiles", $"Found no broken filesets, but {missing.Count} missing remote files. Run purge-broken-files.");
 
                 return;
             }
diff --git a/Duplicati/Library/Main/Operation/ListChangesHandler.cs b/Duplicati/Library/Main/Operation/ListChangesHandler.cs
index aafcde1b3..8a30ee34b 100644
--- a/Duplicati/Library/Main/Operation/ListChangesHandler.cs
+++ b/Duplicati/Library/Main/Operation/ListChangesHandler.cs
@@ -85,7 +85,7 @@ namespace Duplicati.Library.Main.Operation
                 {
                     var dbtimes = db.FilesetTimes.ToList();
                     if (dbtimes.Count < 2)
-                        throw new UserInformationException(string.Format("Need at least two backups to show differences, database contains {0} backups", dbtimes.Count), "NeedTwoBackupsToStartDiff");
+                        throw new UserInformationException($"Need at least two backups to show differences, database contains {dbtimes.Count} backups", "NeedTwoBackupsToStartDiff");
                     
                     long baseVersionId;
                     long compareVersionId;
@@ -110,7 +110,7 @@ namespace Duplicati.Library.Main.Operation
                                 
                     var numberedList = parsedlist.Zip(Enumerable.Range(0, parsedlist.Length), (a, b) => new Tuple<long, DateTime, Volumes.IParsedVolume>(b, a.Time, a)).ToList();
                     if (numberedList.Count < 2)
-                        throw new UserInformationException(string.Format("Need at least two backups to show differences, database contains {0} backups", numberedList.Count), "NeedTwoBackupsToStartDiff");
+                        throw new UserInformationException($"Need at least two backups to show differences, database contains {numberedList.Count} backups", "NeedTwoBackupsToStartDiff");
 
                     Volumes.IParsedVolume baseFile;
                     Volumes.IParsedVolume compareFile;
diff --git a/Duplicati/Library/Main/Operation/PurgeBrokenFilesHandler.cs b/Duplicati/Library/Main/Operation/PurgeBrokenFilesHandler.cs
index e90a44070..6a4e30de1 100644
--- a/Duplicati/Library/Main/Operation/PurgeBrokenFilesHandler.cs
+++ b/Duplicati/Library/Main/Operation/PurgeBrokenFilesHandler.cs
@@ -41,7 +41,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run(Library.Utility.IFilter filter)
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
 
             if (filter != null && !filter.Empty)
                 throw new UserInformationException("Filters are not supported for this operation", "FiltersNotAllowedOnPurgeBrokenFiles");
@@ -65,7 +65,7 @@ namespace Duplicati.Library.Main.Operation
                     else if (missing.Count == 0)
                         Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenFilesetsOrMissingFiles", "Found no broken filesets and no missing remote files");
                     else
-                        Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenSetsButMissingRemoteFiles", string.Format("Found no broken filesets, but {0} missing remote files. Purging from database.", missing.Count));
+                        Logging.Log.WriteInformationMessage(LOGTAG, "NoBrokenSetsButMissingRemoteFiles", $"Found no broken filesets, but {missing.Count} missing remote files. Purging from database.");
                 }
                 else
                 { 
@@ -152,7 +152,7 @@ namespace Duplicati.Library.Main.Operation
                                 filesets = pgdb.FilesetTimes.ToList();
                                 var thisversion = filesets.FindIndex(y => y.Key == bs.FilesetID);
                                 if (thisversion < 0)
-                                    throw new Exception(string.Format("Failed to find match for {0} ({1}) in {2}", bs.FilesetID, bs.Timestamp.ToLocalTime(), string.Join(", ", filesets.Select(x => x.ToString()))));
+                                    throw new Exception($"Failed to find match for {bs.FilesetID} ({bs.Timestamp.ToLocalTime()}) in {string.Join(", ", filesets.Select(x => x.ToString()))}");
 
                                 opts.RawOptions["version"] = thisversion.ToString();
                                 opts.RawOptions.Remove("time");
@@ -161,7 +161,7 @@ namespace Duplicati.Library.Main.Operation
                                 new PurgeFilesHandler(m_backendurl, opts, (PurgeFilesResults)m_result.PurgeResults).Run(pgdb, pgoffset, pgspan, (cmd, filesetid, tablename) =>
                                 {
                                     if (filesetid != bs.FilesetID)
-                                        throw new Exception(string.Format("Unexpected filesetid: {0}, expected {1}", filesetid, bs.FilesetID));
+                                        throw new Exception($"Unexpected filesetid: {filesetid}, expected {bs.FilesetID}");
                                     db.InsertBrokenFileIDsIntoTable(filesetid, tablename, "FileID", cmd.Transaction);
                                 });
                             }
diff --git a/Duplicati/Library/Main/Operation/PurgeFilesHandler.cs b/Duplicati/Library/Main/Operation/PurgeFilesHandler.cs
index 31800bb22..0ce46d2d7 100644
--- a/Duplicati/Library/Main/Operation/PurgeFilesHandler.cs
+++ b/Duplicati/Library/Main/Operation/PurgeFilesHandler.cs
@@ -45,7 +45,7 @@ namespace Duplicati.Library.Main.Operation
                 throw new UserInformationException("Cannot purge with an empty filter, as that would cause all files to be removed.\nTo remove an entire backup set, use the \"delete\" command.", "EmptyFilterPurgeNotAllowed");
 
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
 
             using (var db = new Database.LocalPurgeDatabase(m_options.Dbpath))
                 DoRun(db, filter, null, 0, 1);
@@ -69,7 +69,7 @@ namespace Duplicati.Library.Main.Operation
                     throw new UserInformationException("The purge command does not work on partially recreated databases", "PurgeNotAllowedOnPartialDatabase");
 
                 if (db.RepairInProgress && filtercommand == null)
-                    throw new UserInformationException(string.Format("The purge command does not work on an incomplete database, try the {0} operation.", "purge-broken-files"), "PurgeNotAllowedOnIncompleteDatabase");
+                    throw new UserInformationException($"The purge command does not work on an incomplete database, try the {"purge-broken-files"} operation.", "PurgeNotAllowedOnIncompleteDatabase");
 
                 var versions = db.GetFilesetIDs(m_options.Time, m_options.Version).OrderByDescending(x => x).ToArray();
                 if (versions.Length <= 0)
@@ -77,7 +77,7 @@ namespace Duplicati.Library.Main.Operation
 
                 var orphans = db.CountOrphanFiles(null);
                 if (orphans != 0)
-                    throw new UserInformationException(string.Format("Unable to start the purge process as there are {0} orphan file(s)", orphans), "CannotPurgeWithOrphans");
+                    throw new UserInformationException($"Unable to start the purge process as there are {orphans} orphan file(s)", "CannotPurgeWithOrphans");
 
                 Utility.UpdateOptionsFromDb(db, m_options);
                 Utility.VerifyParameters(db, m_options);
@@ -118,7 +118,7 @@ namespace Duplicati.Library.Main.Operation
                             }
 
                         if (ix < 0)
-                            throw new InvalidProgramException(string.Format("Fileset was reported with id {0}, but could not be found?", versionid));
+                            throw new InvalidProgramException($"Fileset was reported with id {versionid}, but could not be found?");
 
                         var secs = 0;
                         while (secs < 60)
@@ -135,10 +135,10 @@ namespace Duplicati.Library.Main.Operation
                         var prevfilename = db.GetRemoteVolumeNameForFileset(filesets[ix].Key, tr);
 
                         if (secs >= 60)
-                            throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is more than 60 seconds away", prevfilename, ts));
+                            throw new Exception($"Unable to create a new fileset for {prevfilename} because the resulting timestamp {ts} is more than 60 seconds away");
 
                         if (ix != 0 && filesets[ix - 1].Value <= ts)
-                            throw new Exception(string.Format("Unable to create a new fileset for {0} because the resulting timestamp {1} is larger than the next timestamp {2}", prevfilename, ts, filesets[ix - 1].Value));
+                            throw new Exception($"Unable to create a new fileset for {prevfilename} because the resulting timestamp {ts} is larger than the next timestamp {filesets[ix - 1].Value}");
 
                         using (var tempset = db.CreateTemporaryFileset(versionid, tr))
                         {
@@ -179,7 +179,7 @@ namespace Duplicati.Library.Main.Operation
                                     {
                                         foreach (var fe in tempset.ListAllDeletedFiles())
                                         {
-                                            var msg = string.Format("  Purging file {0} ({1})", fe.Key, Library.Utility.Utility.FormatSizeString(fe.Value));
+                                            var msg = $"  Purging file {fe.Key} ({Library.Utility.Utility.FormatSizeString(fe.Value)})";
 
                                             Logging.Log.WriteProfilingMessage(LOGTAG, "PurgeFile", msg);
                                             Logging.Log.WriteVerboseMessage(LOGTAG, "PurgeFile", msg);
diff --git a/Duplicati/Library/Main/Operation/RecreateDatabaseHandler.cs b/Duplicati/Library/Main/Operation/RecreateDatabaseHandler.cs
index 5d1258176..a5bdd5179 100644
--- a/Duplicati/Library/Main/Operation/RecreateDatabaseHandler.cs
+++ b/Duplicati/Library/Main/Operation/RecreateDatabaseHandler.cs
@@ -38,7 +38,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run(string path, Library.Utility.IFilter filter = null, NumberedFilterFilelistDelegate filelistfilter = null, BlockVolumePostProcessor blockprocessor = null)
         {
             if (System.IO.File.Exists(path))
-                throw new UserInformationException(string.Format("Cannot recreate database because file already exists: {0}", path), "RecreateTargetDatabaseExists");
+                throw new UserInformationException($"Cannot recreate database because file already exists: {path}", "RecreateTargetDatabaseExists");
 
             using(var db = new LocalDatabase(path, "Recreate", true))
             {
@@ -57,7 +57,7 @@ namespace Duplicati.Library.Main.Operation
         public void RunUpdate(Library.Utility.IFilter filter = null, NumberedFilterFilelistDelegate filelistfilter = null, BlockVolumePostProcessor blockprocessor = null)
         {
             if (!m_options.RepairOnlyPaths)
-                throw new UserInformationException(string.Format("Can only update with paths, try setting {0}", "--repair-only-paths"), "RepairUpdateRequiresPathsOnly");
+                throw new UserInformationException($"Can only update with paths, try setting {"--repair-only-paths"}", "RepairUpdateRequiresPathsOnly");
 
             using(var db = new LocalDatabase(m_options.Dbpath, "Recreate", true))
             {
@@ -123,11 +123,11 @@ namespace Duplicati.Library.Main.Operation
                 
                         var types = tmp.Distinct().ToArray();
                         if (tmp.Length == 0)
-                            throw new UserInformationException(string.Format("Found {0} files at the remote storage, but none that could be parsed", rawlist.Count), "EmptyRemoteLocation");
+                            throw new UserInformationException($"Found {rawlist.Count} files at the remote storage, but none that could be parsed", "EmptyRemoteLocation");
                         else if (types.Length == 1)
-                            throw new UserInformationException(string.Format("Found {0} parse-able files with the prefix {1}, did you forget to set the backup prefix?", tmp.Length, types[0]), "EmptyRemoteLocationWithPrefix");
+                            throw new UserInformationException($"Found {tmp.Length} parse-able files with the prefix {types[0]}, did you forget to set the backup prefix?", "EmptyRemoteLocationWithPrefix");
                         else
-                            throw new UserInformationException(string.Format("Found {0} parse-able files (of {1} files) with different prefixes: {2}, did you forget to set the backup prefix?", tmp.Length, rawlist.Count, string.Join(", ", types)), "EmptyRemoteLocationWithPrefix");
+                            throw new UserInformationException($"Found {tmp.Length} parse-able files (of {rawlist.Count} files) with different prefixes: {string.Join(", ", types)}, did you forget to set the backup prefix?", "EmptyRemoteLocationWithPrefix");
                     }
                 }
 
@@ -197,7 +197,7 @@ namespace Duplicati.Library.Main.Operation
                             }
                             else
                             {
-                                m_result.OperationProgressUpdater.UpdateProgress(((float)progress / filelistWork.Count()) * (m_options.RepairOnlyPaths ? 1f : 0.2f));
+                                m_result.OperationProgressUpdater.UpdateProgress(((float)progress / filelistWork.Count) * (m_options.RepairOnlyPaths ? 1f : 0.2f));
                                 Logging.Log.WriteVerboseMessage(LOGTAG, "ProcessingFilelistVolumes", "Processing filelist volume {0} of {1}", progress, filelistWork.Count);
                             }
 
@@ -376,7 +376,7 @@ namespace Duplicati.Library.Main.Operation
                                             {
                                                 var p = VolumeBase.ParseFilename(filename);
                                                 if (p == null)
-                                                    throw new Exception(string.Format("Unable to parse filename: {0}", filename));
+                                                    throw new Exception($"Unable to parse filename: {filename}");
     											Logging.Log.WriteErrorMessage(LOGTAG, "MissingFileDetected", null, "Remote file referenced as {0} by {1}, but not found in list, registering a missing remote file", filename, sf.Name);
 												missing = true;
 											    volumeID = restoredb.RegisterRemoteVolume(filename, p.FileType, RemoteVolumeState.Temporary, tr);
@@ -526,7 +526,7 @@ namespace Duplicati.Library.Main.Operation
                     {
                         var broken = lbfdb.GetBrokenFilesets(new DateTime(0), null, null).Count();
                         if (broken != 0)
-                            throw new UserInformationException(string.Format("Recreated database has missing blocks and {0} broken filelists. Consider using \"{1}\" and \"{2}\" to purge broken data from the remote store and the database.", broken, "list-broken-files", "purge-broken-files"), "DatabaseIsBrokenConsiderPurge");
+                            throw new UserInformationException($"Recreated database has missing blocks and {broken} broken filelists. Consider using \"{"list-broken-files"}\" and \"{"purge-broken-files"}\" to purge broken data from the remote store and the database.", "DatabaseIsBrokenConsiderPurge");
                     }
 
                     restoredb.VerifyConsistency(m_options.Blocksize, m_options.BlockhashSize, true, null);
diff --git a/Duplicati/Library/Main/Operation/RepairHandler.cs b/Duplicati/Library/Main/Operation/RepairHandler.cs
index eeb949ad7..c0c248e48 100644
--- a/Duplicati/Library/Main/Operation/RepairHandler.cs
+++ b/Duplicati/Library/Main/Operation/RepairHandler.cs
@@ -98,7 +98,7 @@ namespace Duplicati.Library.Main.Operation
         public void RunRepairRemote()
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "RepairDatabaseFileDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "RepairDatabaseFileDoesNotExist");
 
             m_result.OperationProgressUpdater.UpdateProgress(0);
 
@@ -133,13 +133,13 @@ namespace Duplicati.Library.Main.Operation
                     if (!tp.ParsedVolumes.Any() && tp.OtherVolumes.Any())
                     {
                         if (tp.BackupPrefixes.Length == 1)
-                            throw new UserInformationException(string.Format("Found no backup files with prefix {0}, but files with prefix {1}, did you forget to set the backup prefix?", m_options.Prefix, tp.BackupPrefixes[0]), "RemoteFolderEmptyWithPrefix");
+                            throw new UserInformationException($"Found no backup files with prefix {m_options.Prefix}, but files with prefix {tp.BackupPrefixes[0]}, did you forget to set the backup prefix?", "RemoteFolderEmptyWithPrefix");
                         else
-                            throw new UserInformationException(string.Format("Found no backup files with prefix {0}, but files with prefixes {1}, did you forget to set the backup prefix?", m_options.Prefix, string.Join(", ", tp.BackupPrefixes)), "RemoteFolderEmptyWithPrefix");
+                            throw new UserInformationException($"Found no backup files with prefix {m_options.Prefix}, but files with prefixes {string.Join(", ", tp.BackupPrefixes)}, did you forget to set the backup prefix?", "RemoteFolderEmptyWithPrefix");
                     }
                     else if (!tp.ParsedVolumes.Any() && tp.ExtraVolumes.Any())
                     {
-                        throw new UserInformationException(string.Format("No files were missing, but {0} remote files were, found, did you mean to run recreate-database?", tp.ExtraVolumes.Count()), "NoRemoteFilesMissing");
+                        throw new UserInformationException($"No files were missing, but {tp.ExtraVolumes.Count()} remote files were, found, did you mean to run recreate-database?", "NoRemoteFilesMissing");
                     }
                 }
 
@@ -169,7 +169,7 @@ namespace Duplicati.Library.Main.Operation
                                         res = TestHandler.TestVolumeInternals(testdb, n, tf, m_options, 1);
 
                                     if (res.Value.Any())
-                                        throw new Exception(string.Format("Remote verification failure: {0}", res.Value.First()));
+                                        throw new Exception($"Remote verification failure: {res.Value.First()}");
 
                                     if (!m_options.Dryrun)
                                     {
@@ -215,13 +215,13 @@ namespace Duplicati.Library.Main.Operation
                                         {
                                             var entry = db.GetRemoteVolume(rv.Filename);
                                             if (entry.ID < 0)
-                                                throw new Exception(string.Format("Unknown remote file {0} detected", rv.Filename));
+                                                throw new Exception($"Unknown remote file {rv.Filename} detected");
                                             
                                             if (!new [] { RemoteVolumeState.Uploading, RemoteVolumeState.Uploaded, RemoteVolumeState.Verified }.Contains(entry.State))
-                                                throw new Exception(string.Format("Volume {0} has local state {1}", rv.Filename, entry.State));
+                                                throw new Exception($"Volume {rv.Filename} has local state {entry.State}");
                                         
                                             if (entry.Hash != rv.Hash || entry.Size != rv.Length || ! new [] { RemoteVolumeState.Uploading, RemoteVolumeState.Uploaded, RemoteVolumeState.Verified }.Contains(entry.State))
-                                                throw new Exception(string.Format("Volume {0} hash/size mismatch ({1} - {2}) vs ({3} - {4})", rv.Filename, entry.Hash, entry.Size, rv.Hash, rv.Length));
+                                                throw new Exception($"Volume {rv.Filename} hash/size mismatch ({entry.Hash} - {entry.Size}) vs ({rv.Hash} - {rv.Length})");
 
                                             db.CheckAllBlocksAreInVolume(rv.Filename, rv.Blocks);
                                         }
@@ -330,7 +330,7 @@ namespace Duplicati.Library.Main.Operation
                                         {
                                             var bh = Convert.ToBase64String(h.ComputeHash(b.Item2, 0, b.Item3));
                                             if (bh != b.Item1)
-                                                throw new Exception(string.Format("Internal consistency check failed, generated index block has wrong hash, {0} vs {1}", bh, b.Item1));
+                                                throw new Exception($"Internal consistency check failed, generated index block has wrong hash, {bh} vs {b.Item1}");
 
                                             w.WriteBlocklist(b.Item1, b.Item2, 0, b.Item3);
                                         }
@@ -416,7 +416,7 @@ namespace Duplicati.Library.Main.Operation
                                         foreach (var f in mbl.GetFilesetsUsingMissingBlocks())
                                             Logging.Log.WriteInformationMessage(LOGTAG, "AffectedFilesetName", f.Name);
 
-                                        var recoverymsg = string.Format("If you want to continue working with the database, you can use the \"{0}\" and \"{1}\" commands to purge the missing data from the database and the remote storage.", "list-broken-files", "purge-broken-files");
+                                        var recoverymsg = $"If you want to continue working with the database, you can use the \"{"list-broken-files"}\" and \"{"purge-broken-files"}\" commands to purge the missing data from the database and the remote storage.";
 
                                         if (!m_options.Dryrun)
                                         {
@@ -470,7 +470,7 @@ namespace Duplicati.Library.Main.Operation
         public void RunRepairCommon()
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
 
             m_result.OperationProgressUpdater.UpdateProgress(0);
 
diff --git a/Duplicati/Library/Main/Operation/RestoreHandler.cs b/Duplicati/Library/Main/Operation/RestoreHandler.cs
index 198444eb7..0890503be 100644
--- a/Duplicati/Library/Main/Operation/RestoreHandler.cs
+++ b/Duplicati/Library/Main/Operation/RestoreHandler.cs
@@ -56,7 +56,7 @@ namespace Duplicati.Library.Main.Operation
         {
             var tmp = VolumeBase.ParseFilename(filename);
             if (tmp == null)
-                throw new UserInformationException(string.Format("Unable to parse filename to valid entry: {0}", filename), "FailedToParseRemoteName");
+                throw new UserInformationException($"Unable to parse filename to valid entry: {filename}", "FailedToParseRemoteName");
 
             return tmp.CompressionModule;
         }
@@ -476,7 +476,7 @@ namespace Duplicati.Library.Main.Operation
                                 }
     
                                 if (key != file.Hash)
-                                    throw new Exception(string.Format("Failed to restore file: \"{0}\". File hash is {1}, expected hash is {2}", file.Path, key, file.Hash));
+                                    throw new Exception($"Failed to restore file: \"{file.Path}\". File hash is {key}, expected hash is {file.Hash}");
                                 result.RestoredFiles++;
                                 result.SizeOfRestoredFiles += size;
                             }
@@ -763,7 +763,7 @@ namespace Duplicati.Library.Main.Operation
                         Logging.Log.WriteVerboseMessage(LOGTAG, "FilePatchedWithLocal", "Target file is not patched any local data: {0}", targetpath);
                         
                     if (patched && options.Dryrun)
-                        Logging.Log.WriteDryrunMessage(LOGTAG, "WouldPatchWithLocal", string.Format("Would patch file with local data: {0}", targetpath));
+                        Logging.Log.WriteDryrunMessage(LOGTAG, "WouldPatchWithLocal", $"Would patch file with local data: {targetpath}");
                 }
 
                 blockmarker.UpdateProcessed(result.OperationProgressUpdater);
diff --git a/Duplicati/Library/Main/Operation/SystemInfoHandler.cs b/Duplicati/Library/Main/Operation/SystemInfoHandler.cs
index 1bbd08eb5..77ca4965a 100644
--- a/Duplicati/Library/Main/Operation/SystemInfoHandler.cs
+++ b/Duplicati/Library/Main/Operation/SystemInfoHandler.cs
@@ -31,25 +31,25 @@ namespace Duplicati.Library.Main.Operation
 
         public static IEnumerable<string> GetSystemInfo()
         {
-            yield return string.Format("Duplicati: {0} ({1})", Duplicati.Library.Utility.Utility.getEntryAssembly().FullName, System.Reflection.Assembly.GetExecutingAssembly().FullName);
+            yield return $"Duplicati: {Duplicati.Library.Utility.Utility.getEntryAssembly().FullName} ({System.Reflection.Assembly.GetExecutingAssembly().FullName})";
 
-            yield return string.Format("Autoupdate urls: {0}", string.Join(";", Duplicati.Library.AutoUpdater.AutoUpdateSettings.URLs));
-            yield return string.Format("Update folder: {0}", Duplicati.Library.AutoUpdater.UpdaterManager.INSTALLDIR);
-            yield return string.Format("Base install folder: {0}", Duplicati.Library.AutoUpdater.UpdaterManager.InstalledBaseDir);
-            yield return string.Format("Version name: \"{0}\" ({1})", Duplicati.Library.AutoUpdater.UpdaterManager.SelfVersion.Displayname, System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
-            yield return string.Format("Current Version folder {0}", System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location));
+            yield return $"Autoupdate urls: {string.Join(";", Duplicati.Library.AutoUpdater.AutoUpdateSettings.URLs)}";
+            yield return $"Update folder: {Duplicati.Library.AutoUpdater.UpdaterManager.INSTALLDIR}";
+            yield return $"Base install folder: {Duplicati.Library.AutoUpdater.UpdaterManager.InstalledBaseDir}";
+            yield return $"Version name: \"{Duplicati.Library.AutoUpdater.UpdaterManager.SelfVersion.Displayname}\" ({System.Reflection.Assembly.GetExecutingAssembly().GetName().Version})";
+            yield return $"Current Version folder {System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location)}";
 
-            yield return string.Format("OS: {0}", Environment.OSVersion);
-            yield return string.Format("Uname: {0}", Platform.UnameAll);
+            yield return $"OS: {Environment.OSVersion}";
+            yield return $"Uname: {Platform.UnameAll}";
 
-            yield return string.Format("64bit: {0} ({1})", Environment.Is64BitOperatingSystem, Environment.Is64BitProcess);
-            yield return string.Format("Machinename: {0}", Environment.MachineName);
-            yield return string.Format("Processors: {0}", Environment.ProcessorCount);
-            yield return string.Format(".Net Version: {0}", Environment.Version);
-            yield return string.Format("Mono: {0} ({1}) ({2})", Duplicati.Library.Utility.Utility.IsMono, Duplicati.Library.Utility.Utility.MonoVersion, Duplicati.Library.Utility.Utility.MonoDisplayVersion);
-            yield return string.Format("Locale: {0}, {1}, {2}", System.Threading.Thread.CurrentThread.CurrentCulture, System.Threading.Thread.CurrentThread.CurrentUICulture, System.Globalization.CultureInfo.InstalledUICulture);
-            yield return string.Format("Date/time strings: {0} - {1}", System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongDatePattern, System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongTimePattern);
-            yield return string.Format("Tempdir: {0}", Library.Utility.TempFolder.SystemTempPath);
+            yield return $"64bit: {Environment.Is64BitOperatingSystem} ({Environment.Is64BitProcess})";
+            yield return $"Machinename: {Environment.MachineName}";
+            yield return $"Processors: {Environment.ProcessorCount}";
+            yield return $".Net Version: {Environment.Version}";
+            yield return $"Mono: {Duplicati.Library.Utility.Utility.IsMono} ({Duplicati.Library.Utility.Utility.MonoVersion}) ({Duplicati.Library.Utility.Utility.MonoDisplayVersion})";
+            yield return $"Locale: {System.Threading.Thread.CurrentThread.CurrentCulture}, {System.Threading.Thread.CurrentThread.CurrentUICulture}, {System.Globalization.CultureInfo.InstalledUICulture}";
+            yield return $"Date/time strings: {System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongDatePattern} - {System.Threading.Thread.CurrentThread.CurrentCulture.DateTimeFormat.LongTimePattern}";
+            yield return $"Tempdir: {Library.Utility.TempFolder.SystemTempPath}";
 
             Type sqlite = null;
             string sqliteversion = "";
@@ -62,8 +62,8 @@ namespace Duplicati.Library.Main.Operation
                 try { sqliteversion = (string)sqlite.GetProperty("SQLiteVersion").GetValue(null, null); }
                 catch { }
 
-                yield return string.Format("SQLite: {0} - {1}", sqliteversion, sqlite.FullName);
-                yield return string.Format("SQLite assembly: {0}", sqlite.Assembly.Location);
+                yield return $"SQLite: {sqliteversion} - {sqlite.FullName}";
+                yield return $"SQLite assembly: {sqlite.Assembly.Location}";
             }
         }
     }
diff --git a/Duplicati/Library/Main/Operation/TestHandler.cs b/Duplicati/Library/Main/Operation/TestHandler.cs
index 77b47aad3..8770255c4 100644
--- a/Duplicati/Library/Main/Operation/TestHandler.cs
+++ b/Duplicati/Library/Main/Operation/TestHandler.cs
@@ -44,7 +44,7 @@ namespace Duplicati.Library.Main.Operation
         public void Run(long samples)
         {
             if (!System.IO.File.Exists(m_options.Dbpath))
-                throw new UserInformationException(string.Format("Database file does not exist: {0}", m_options.Dbpath), "DatabaseDoesNotExist");
+                throw new UserInformationException($"Database file does not exist: {m_options.Dbpath}", "DatabaseDoesNotExist");
                                 
             using(var db = new LocalTestDatabase(m_options.Dbpath))
             using(var backend = new BackendManager(m_backendurl, m_options, m_results.BackendWriter, db))
diff --git a/Duplicati/Library/Main/Options.cs b/Duplicati/Library/Main/Options.cs
index f83d6b7d7..e9ace0c4d 100644
--- a/Duplicati/Library/Main/Options.cs
+++ b/Duplicati/Library/Main/Options.cs
@@ -1279,7 +1279,7 @@ namespace Duplicati.Library.Main
 
                 long blocksize = Library.Utility.Sizeparser.ParseSize(tmp, "kb");
                 if (blocksize > int.MaxValue || blocksize < 1024)
-                    throw new ArgumentOutOfRangeException(nameof(blocksize), string.Format("The blocksize cannot be less than {0}, nor larger than {1}", 1024, int.MaxValue));
+                    throw new ArgumentOutOfRangeException(nameof(blocksize), $"The blocksize cannot be less than {1024}, nor larger than {int.MaxValue}");
                 
                 return (int)blocksize;
             }
@@ -1906,11 +1906,11 @@ namespace Duplicati.Library.Main
             {
                 if (timeframe < TimeSpan.Zero)
                 {
-                    throw new ArgumentOutOfRangeException(nameof(timeframe), string.Format("The timeframe cannot be negative: '{0}'", timeframe));
+                    throw new ArgumentOutOfRangeException(nameof(timeframe), $"The timeframe cannot be negative: '{timeframe}'");
                 }
                 if (interval < TimeSpan.Zero)
                 {
-                    throw new ArgumentOutOfRangeException(nameof(interval), string.Format("The interval cannot be negative: '{0}'", interval));
+                    throw new ArgumentOutOfRangeException(nameof(interval), $"The interval cannot be negative: '{interval}'");
                 }
 
                 this.Timeframe = timeframe;
diff --git a/Duplicati/Library/Main/ResultClasses.cs b/Duplicati/Library/Main/ResultClasses.cs
index 2f3ef85bd..398965ab2 100644
--- a/Duplicati/Library/Main/ResultClasses.cs
+++ b/Duplicati/Library/Main/ResultClasses.cs
@@ -201,7 +201,7 @@ namespace Duplicati.Library.Main
 
         // ReSharper disable once UnusedMember.Global
         // This is referenced in the logs.
-        public string Version { get { return string.Format("{0} ({1})", AutoUpdater.UpdaterManager.SelfVersion.Version, AutoUpdater.UpdaterManager.SelfVersion.Displayname); } }
+        public string Version { get { return $"{AutoUpdater.UpdaterManager.SelfVersion.Version} ({AutoUpdater.UpdaterManager.SelfVersion.Displayname})"; } }
 
         public DateTime EndTime { get; set; }
         public DateTime BeginTime { get; set; }
diff --git a/Duplicati/Library/Main/Utility.cs b/Duplicati/Library/Main/Utility.cs
index 15774e2bc..5718eaab1 100644
--- a/Duplicati/Library/Main/Utility.cs
+++ b/Duplicati/Library/Main/Utility.cs
@@ -158,7 +158,7 @@ namespace Duplicati.Library.Main
                         }
                     }
                     else
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("You have attempted to change the parameter \"{0}\" from \"{1}\" to \"{2}\", which is not supported. Please configure a new clean backup if you want to change the parameter.", k.Key, opts[k.Key], k.Value), "ParameterChangeNotSupported");
+                        throw new Duplicati.Library.Interface.UserInformationException($"You have attempted to change the parameter \"{k.Key}\" from \"{opts[k.Key]}\" to \"{k.Value}\", which is not supported. Please configure a new clean backup if you want to change the parameter.", "ParameterChangeNotSupported");
                     
                 }
                             
diff --git a/Duplicati/Library/Main/Volumes/FilesetVolumeReader.cs b/Duplicati/Library/Main/Volumes/FilesetVolumeReader.cs
index af5156ac3..247b7710e 100644
--- a/Duplicati/Library/Main/Volumes/FilesetVolumeReader.cs
+++ b/Duplicati/Library/Main/Volumes/FilesetVolumeReader.cs
@@ -60,7 +60,7 @@ namespace Duplicati.Library.Main.Volumes
                                 }
 
                                 if (m_reader.TokenType != JsonToken.String)
-                                    throw new InvalidDataException(string.Format("Invalid JSON, expected String, but found {0}, {1}", m_reader.TokenType, m_reader.Value));
+                                    throw new InvalidDataException($"Invalid JSON, expected String, but found {m_reader.TokenType}, {m_reader.Value}");
 
                                 m_current = m_reader.Value == null ? null : m_reader.Value.ToString();
                                 return true;
@@ -128,7 +128,7 @@ namespace Duplicati.Library.Main.Volumes
                             }
 
                             if (balance != 0)
-                                throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry of type {0}", this.TypeString));
+                                throw new InvalidDataException($"Invalid JSON, EOF found while reading entry of type {this.TypeString}");
                         }
                         else
                         {
@@ -143,17 +143,17 @@ namespace Duplicati.Library.Main.Volumes
                             }
 
                             if (!m_reader.Read())
-                                throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
                             if (m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "metahash")
                             {
                                 if (!m_reader.Read())
-                                    throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                    throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
 
                                 this.Metahash = m_reader.Value.ToString();
                                 this.Metasize = ReadJsonInt64Property(m_reader, "metasize");
 
                                 if (!m_reader.Read())
-                                    throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                    throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
 
                                 if (m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "metablocklists")
                                 {
@@ -161,19 +161,19 @@ namespace Duplicati.Library.Main.Volumes
                                     SkipJsonToken(m_reader, JsonToken.StartArray);
 
                                     if (!m_reader.Read())
-                                        throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                        throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
                                     
                                     while(m_reader.TokenType == JsonToken.String)
                                     {
                                         metadatablocklisthashes.Add(m_reader.Value.ToString());
                                         if (!m_reader.Read())
-                                            throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                            throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
                                     }
                                     
                                     if (m_reader.TokenType != JsonToken.EndArray)
-                                        throw new InvalidDataException(string.Format("Invalid JSON, unexpected token {1} found while reading entry {0}", this.Path, m_reader.TokenType));
+                                        throw new InvalidDataException($"Invalid JSON, unexpected token {this.Path} found while reading entry {m_reader.TokenType}");
                                     if (!m_reader.Read())
-                                        throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                        throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
 
                                     this.MetaBlocklistHashes = metadatablocklisthashes;
                                     this.Metablockhash = null;
@@ -181,11 +181,11 @@ namespace Duplicati.Library.Main.Volumes
                                 else if (m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "metablockhash")
                                 {
                                     if (!m_reader.Read())
-                                        throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                        throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
                                     this.Metablockhash = m_reader.Value.ToString();
 
                                     if (!m_reader.Read())
-                                        throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                        throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
 
                                     this.MetaBlocklistHashes = null;
                                 }
@@ -199,7 +199,7 @@ namespace Duplicati.Library.Main.Volumes
                             else if ((this.Type == FilelistEntryType.File || this.Type == FilelistEntryType.AlternateStream) && m_reader.TokenType == JsonToken.PropertyName && m_reader.Value != null && m_reader.Value.ToString() == "blockhash")
                             {
                                 if (!m_reader.Read())
-                                    throw new InvalidDataException(string.Format("Invalid JSON, EOF found while reading entry {0}", this.Path));
+                                    throw new InvalidDataException($"Invalid JSON, EOF found while reading entry {this.Path}");
                                 
                                 this.Blockhash = m_reader.Value.ToString();
                                 this.Blocksize = ReadJsonInt64Property(m_reader, "blocksize");
@@ -209,7 +209,7 @@ namespace Duplicati.Library.Main.Volumes
                             {
                                 this.BlocklistHashes = null;
                                 if (m_reader.TokenType != JsonToken.EndObject)
-                                    throw new InvalidDataException(string.Format("Invalid JSON, expected EndObject, but found {0}, \"{1}\" while reading entry {2}", m_reader.TokenType, m_reader.Value, this.Path));
+                                    throw new InvalidDataException($"Invalid JSON, expected EndObject, but found {m_reader.TokenType}, \"{m_reader.Value}\" while reading entry {this.Path}");
                             }
                         }
                     }
@@ -275,7 +275,7 @@ namespace Duplicati.Library.Main.Volumes
                     }
 
                     if (m_reader.TokenType != JsonToken.StartObject)
-                        throw new InvalidDataException(string.Format("Invalid JSON, expected StartObject, but got {0}, {1}", m_reader.TokenType, m_reader.Value));
+                        throw new InvalidDataException($"Invalid JSON, expected StartObject, but got {m_reader.TokenType}, {m_reader.Value}");
 
                     m_current = new FileEntry(m_reader);
 
diff --git a/Duplicati/Library/Main/Volumes/FilesetVolumeWriter.cs b/Duplicati/Library/Main/Volumes/FilesetVolumeWriter.cs
index df57b4ebd..3fc26e57f 100644
--- a/Duplicati/Library/Main/Volumes/FilesetVolumeWriter.cs
+++ b/Duplicati/Library/Main/Volumes/FilesetVolumeWriter.cs
@@ -137,15 +137,9 @@ namespace Duplicati.Library.Main.Volumes
                 this.AddFilelistFile();
             }
 
-            if (m_tempStream != null)
-            {
-                m_tempStream.Dispose();
-            }
+            m_tempStream?.Dispose();
 
-            if (m_tempFile != null)
-            {
-                m_tempFile.Dispose();
-            }
+            m_tempFile?.Dispose();
 
             base.Close();
         }
diff --git a/Duplicati/Library/Main/Volumes/IndexVolumeReader.cs b/Duplicati/Library/Main/Volumes/IndexVolumeReader.cs
index 9db35c07f..17a6e288b 100644
--- a/Duplicati/Library/Main/Volumes/IndexVolumeReader.cs
+++ b/Duplicati/Library/Main/Volumes/IndexVolumeReader.cs
@@ -96,7 +96,7 @@ namespace Duplicati.Library.Main.Volumes
                             }
 
                             if (m_reader.TokenType != JsonToken.StartObject)
-                                throw new InvalidDataException(string.Format("Invalid JSON, expected StartObject, but got {0}, {1}", m_reader.TokenType, m_reader.Value));
+                                throw new InvalidDataException($"Invalid JSON, expected StartObject, but got {m_reader.TokenType}, {m_reader.Value}");
 
                             var hash = ReadJsonStringProperty(m_reader, "hash");
                             var size = ReadJsonInt64Property(m_reader, "size");
@@ -131,7 +131,7 @@ namespace Duplicati.Library.Main.Volumes
                             SkipJsonToken(m_reader, JsonToken.StartObject);
                             var p = SkipJsonToken(m_reader, JsonToken.PropertyName);
                             if (p == null || p.ToString() != "blocks")
-                                throw new InvalidDataException(string.Format("Invalid JSON, expected property \"blocks\", but got {0}, {1}", m_reader.TokenType, m_reader.Value));
+                                throw new InvalidDataException($"Invalid JSON, expected property \"blocks\", but got {m_reader.TokenType}, {m_reader.Value}");
                             SkipJsonToken(m_reader, JsonToken.StartArray);
 
                             m_current = null;
diff --git a/Duplicati/Library/Main/Volumes/InvalidManifestException.cs b/Duplicati/Library/Main/Volumes/InvalidManifestException.cs
index f9c535fc4..855ae4934 100644
--- a/Duplicati/Library/Main/Volumes/InvalidManifestException.cs
+++ b/Duplicati/Library/Main/Volumes/InvalidManifestException.cs
@@ -9,7 +9,7 @@ namespace Duplicati.Library.Main.Volumes
     public class InvalidManifestException : Exception
     {
         public InvalidManifestException(string fieldname, string value, string expected)
-            : base(string.Format("Invalid manifest detected, the field {0} has value {1} but the value {2} was expected", fieldname, value, expected))
+            : base($"Invalid manifest detected, the field {fieldname} has value {value} but the value {expected} was expected")
         {
         }
 
diff --git a/Duplicati/Library/Main/Volumes/VolumeReaderBase.cs b/Duplicati/Library/Main/Volumes/VolumeReaderBase.cs
index 8a4a3e3fa..ed10a2017 100644
--- a/Duplicati/Library/Main/Volumes/VolumeReaderBase.cs
+++ b/Duplicati/Library/Main/Volumes/VolumeReaderBase.cs
@@ -24,7 +24,7 @@ namespace Duplicati.Library.Main.Volumes
                 if (stream is FileStream fileStream)
                     name = fileStream.Name;
 
-                throw new Exception(string.Format("Unable to create {0} decompressor on file {1}", compressor, name));
+                throw new Exception($"Unable to create {compressor} decompressor on file {name}");
             }
 
             return tmp;
@@ -165,7 +165,7 @@ namespace Duplicati.Library.Main.Volumes
         protected static object SkipJsonToken(JsonReader reader, JsonToken type)
         {
             if (!reader.Read() || reader.TokenType != type)
-                throw new InvalidDataException(string.Format("Invalid JSON, expected \"{0}\", but got {1}, {2}", type, reader.TokenType, reader.Value));
+                throw new InvalidDataException($"Invalid JSON, expected \"{type}\", but got {reader.TokenType}, {reader.Value}");
 
             return reader.Value;
         }
@@ -174,7 +174,7 @@ namespace Duplicati.Library.Main.Volumes
         {
             var p = SkipJsonToken(reader, JsonToken.PropertyName);
             if (p == null || p.ToString() != propertyname)
-                throw new InvalidDataException(string.Format("Invalid JSON, expected property \"{0}\", but got {1}, {2}", propertyname, reader.TokenType, reader.Value));
+                throw new InvalidDataException($"Invalid JSON, expected property \"{propertyname}\", but got {reader.TokenType}, {reader.Value}");
 
             return SkipJsonToken(reader, type);
         }
diff --git a/Duplicati/Library/Main/Volumes/VolumeWriterBase.cs b/Duplicati/Library/Main/Volumes/VolumeWriterBase.cs
index a2c07025d..3ac7aead5 100644
--- a/Duplicati/Library/Main/Volumes/VolumeWriterBase.cs
+++ b/Duplicati/Library/Main/Volumes/VolumeWriterBase.cs
@@ -58,7 +58,7 @@ namespace Duplicati.Library.Main.Volumes
             m_compression = DynamicLoader.CompressionLoader.GetModule(options.CompressionModule, m_localFileStream, ArchiveMode.Write, options.RawOptions);
 
             if (m_compression == null)
-                throw new UserInformationException(string.Format("Unsupported compression module: {0}", options.CompressionModule), "UnsupportedCompressionModule");
+                throw new UserInformationException($"Unsupported compression module: {options.CompressionModule}", "UnsupportedCompressionModule");
 
             if ((this is IndexVolumeWriter || this is FilesetVolumeWriter) && this.m_compression is ICompressionHinting hinting)
                 hinting.LowOverheadMode = true;
diff --git a/Duplicati/Library/Modules/Builtin/HyperVOptions.cs b/Duplicati/Library/Modules/Builtin/HyperVOptions.cs
index af2a6f354..2ea237bfc 100644
--- a/Duplicati/Library/Modules/Builtin/HyperVOptions.cs
+++ b/Duplicati/Library/Modules/Builtin/HyperVOptions.cs
@@ -159,7 +159,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundGuest = hypervUtility.Guests.Where(x => x.ID == new Guid(guestID));
 
                     if (foundGuest.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Hyper-V guest specified in source with ID {0} cannot be found", guestID), "HyperVGuestNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Hyper-V guest specified in source with ID {guestID} cannot be found", "HyperVGuestNotFound");
 
                     guestsForBackup.Add(foundGuest.First());
                 }
@@ -170,7 +170,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundGuest = hypervUtility.Guests.Where(x => x.ID == new Guid(guestID));
 
                     if (foundGuest.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Hyper-V guest specified in include filter with ID {0} cannot be found", guestID), "HyperVGuestNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Hyper-V guest specified in include filter with ID {guestID} cannot be found", "HyperVGuestNotFound");
 
                     guestsForBackup.Add(foundGuest.First());
                     Logging.Log.WriteInformationMessage(LOGTAG, "IncludeByFilter", "Including {0} based on including filters", guestID);
@@ -184,7 +184,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundGuest = guestsForBackup.Where(x => x.ID == new Guid(guestID));
 
                     if (foundGuest.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("Hyper-V guest specified in exclude filter with ID {0} cannot be found", guestID), "HyperVGuestNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"Hyper-V guest specified in exclude filter with ID {guestID} cannot be found", "HyperVGuestNotFound");
 
                     guestsForBackup.Remove(foundGuest.First());
                     Logging.Log.WriteInformationMessage(LOGTAG, "ExcludeByFilter", "Excluding {0} based on excluding filters", guestID);
diff --git a/Duplicati/Library/Modules/Builtin/MSSQLOptions.cs b/Duplicati/Library/Modules/Builtin/MSSQLOptions.cs
index 13c8decfa..21cf553df 100644
--- a/Duplicati/Library/Modules/Builtin/MSSQLOptions.cs
+++ b/Duplicati/Library/Modules/Builtin/MSSQLOptions.cs
@@ -157,7 +157,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundDB = mssqlUtility.DBs.Where(x => x.ID.Equals(dbID, StringComparison.OrdinalIgnoreCase));
 
                     if (foundDB.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("DB name specified in source with ID {0} cannot be found", dbID), "MsSqlDatabaseNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"DB name specified in source with ID {dbID} cannot be found", "MsSqlDatabaseNotFound");
 
                     dbsForBackup.Add(foundDB.First());
                 }
@@ -168,7 +168,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundDB = mssqlUtility.DBs.Where(x => x.ID.Equals(dbID, StringComparison.OrdinalIgnoreCase));
 
                     if (foundDB.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("DB name specified in include filter with ID {0} cannot be found", dbID), "MsSqlDatabaseNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"DB name specified in include filter with ID {dbID} cannot be found", "MsSqlDatabaseNotFound");
 
                     dbsForBackup.Add(foundDB.First());
                     Logging.Log.WriteInformationMessage(LOGTAG, "IncludeByFilter", "Including {0} based on including filters", dbID);
@@ -182,7 +182,7 @@ namespace Duplicati.Library.Modules.Builtin
                     var foundDB = dbsForBackup.Where(x => x.ID.Equals(dbID, StringComparison.OrdinalIgnoreCase));
 
                     if (foundDB.Count() != 1)
-                        throw new Duplicati.Library.Interface.UserInformationException(string.Format("DB name specified in exclude filter with ID {0} cannot be found", dbID), "MsSqlDatabaseNotFound");
+                        throw new Duplicati.Library.Interface.UserInformationException($"DB name specified in exclude filter with ID {dbID} cannot be found", "MsSqlDatabaseNotFound");
 
                     dbsForBackup.Remove(foundDB.First());
                     Logging.Log.WriteInformationMessage(LOGTAG, "ExcludeByFilter", "Excluding {0} based on excluding filters", dbID);
diff --git a/Duplicati/Library/Modules/Builtin/ReportHelper.cs b/Duplicati/Library/Modules/Builtin/ReportHelper.cs
index 085cf3c65..ade30104a 100644
--- a/Duplicati/Library/Modules/Builtin/ReportHelper.cs
+++ b/Duplicati/Library/Modules/Builtin/ReportHelper.cs
@@ -386,7 +386,7 @@ namespace Duplicati.Library.Modules.Builtin
             ParsedResultType level;
             if (result is Exception)
                 level = ParsedResultType.Fatal;
-            else if (result != null && result is IBasicResults results)
+            else if (result is IBasicResults results)
                 level = results.ParsedResult;
             else
                 level = ParsedResultType.Error;
diff --git a/Duplicati/Library/Modules/Builtin/RunScript.cs b/Duplicati/Library/Modules/Builtin/RunScript.cs
index 183201a02..621e2f205 100644
--- a/Duplicati/Library/Modules/Builtin/RunScript.cs
+++ b/Duplicati/Library/Modules/Builtin/RunScript.cs
@@ -200,7 +200,7 @@ namespace Duplicati.Library.Modules.Builtin
             }
             else if (result is Exception)
                 level = ParsedResultType.Fatal;
-            else if (result != null && result is IBasicResults results)
+            else if (result is IBasicResults results)
                 level = results.ParsedResult;
             else
                 level = ParsedResultType.Error;
diff --git a/Duplicati/Library/Modules/Builtin/SendJabberMessage.cs b/Duplicati/Library/Modules/Builtin/SendJabberMessage.cs
index 755ae54f9..d99d4140e 100644
--- a/Duplicati/Library/Modules/Builtin/SendJabberMessage.cs
+++ b/Duplicati/Library/Modules/Builtin/SendJabberMessage.cs
@@ -217,7 +217,7 @@ namespace Duplicati.Library.Modules.Builtin
             agsXMPP.XmppElementHandler loginErroHandler = (sender, e) => {
                 Logging.Log.WriteWarningMessage(LOGTAG, "XMPPLoginError", null, "Failed to login to XMPP: {0}", e);
 
-                ex = new Exception(string.Format("Failed to log in: {0}", e));
+                ex = new Exception($"Failed to log in: {e}");
                 waitEvent.Set();
             };
     
diff --git a/Duplicati/Library/Modules/Builtin/SendMail.cs b/Duplicati/Library/Modules/Builtin/SendMail.cs
index 107ba4b80..3f9e81ef9 100644
--- a/Duplicati/Library/Modules/Builtin/SendMail.cs
+++ b/Duplicati/Library/Modules/Builtin/SendMail.cs
@@ -219,7 +219,7 @@ namespace Duplicati.Library.Modules.Builtin
                 if (from.EndsWith(">", StringComparison.Ordinal))
                     from = from.Insert(from.Length - 1, "@" + toMailDomain);
                 else
-                    from = string.Format("No Reply - Backup report <{0}@{1}>", from, toMailDomain);
+                    from = $"No Reply - Backup report <{from}@{toMailDomain}>";
             }
 
             if (MailboxAddress.TryParse(from, out mailbox))
diff --git a/Duplicati/Library/Modules/Builtin/Strings.cs b/Duplicati/Library/Modules/Builtin/Strings.cs
index 5be252a65..2b2974b8f 100644
--- a/Duplicati/Library/Modules/Builtin/Strings.cs
+++ b/Duplicati/Library/Modules/Builtin/Strings.cs
@@ -56,7 +56,7 @@ namespace Duplicati.Library.Modules.Builtin.Strings {
         public static string FinishoptionLong { get { return LC.L(@"Executes a script after performing an operation. The script will receive the operation results written to stdout."); } }
         public static string FinishoptionShort { get { return LC.L(@"Run a script on exit"); } }
         public static string InvalidExitCodeError(string script, int exitcode) { return LC.L(@"The script ""{0}"" returned with exit code {1}", script, exitcode); }
-        public static string ExitCodeError(string script, int exitcode, string message) { return LC.L(@"The script ""{0}"" returned with exit code {1}{2}", script, exitcode, string.IsNullOrWhiteSpace(message) ? string.Empty : string.Format(": {0}", message)); }
+        public static string ExitCodeError(string script, int exitcode, string message) { return LC.L(@"The script ""{0}"" returned with exit code {1}{2}", script, exitcode, string.IsNullOrWhiteSpace(message) ? string.Empty : $": {message}"); }
         public static string RequiredoptionLong { get { return LC.L(@"Executes a script before performing an operation. The operation will block until the script has completed or timed out. If the script returns a non-zero error code or times out, the operation will be aborted."); } }
         public static string RequiredoptionShort { get { return LC.L(@"Run a required script on startup"); } }
         public static string ResultFormatShort { get { return LC.L(@"Selects the output format for results"); } }
diff --git a/Duplicati/Library/SQLiteHelper/DatabaseUpgrader.cs b/Duplicati/Library/SQLiteHelper/DatabaseUpgrader.cs
index 68761305a..8708607c5 100644
--- a/Duplicati/Library/SQLiteHelper/DatabaseUpgrader.cs
+++ b/Duplicati/Library/SQLiteHelper/DatabaseUpgrader.cs
@@ -82,7 +82,7 @@ namespace Duplicati.Library.SQLiteHelper
 
             // match condition to retrieve parts
             var m = Regex.Match(cond, condPattern, RegexOptions.ExplicitCapture | RegexOptions.IgnoreCase | RegexOptions.Singleline);
-            if (!m.Success) throw new ArgumentException(string.Format("Malformed condition '{0}'.", cond));
+            if (!m.Success) throw new ArgumentException($"Malformed condition '{cond}'.");
             var variable = m.Groups["VARIABLE"].Value;
             var op = m.Groups["OPERATOR"].Value;
             var literal = m.Groups["LITERAL"].Value.Trim();
@@ -90,7 +90,7 @@ namespace Duplicati.Library.SQLiteHelper
             // find variable and convert literal to correct type
             IComparable varVal;
             if (!vars.TryGetValue(variable, out varVal))
-                throw new KeyNotFoundException(string.Format("Unknown variable '{0}' used in condition.", variable));
+                throw new KeyNotFoundException($"Unknown variable '{variable}' used in condition.");
 
             IComparable litVal;
             try
@@ -101,7 +101,7 @@ namespace Duplicati.Library.SQLiteHelper
                     litVal = (IComparable)System.Convert.ChangeType(literal, varVal.GetType(), System.Globalization.CultureInfo.InvariantCulture);
             }
             catch (Exception ex)
-            { throw new FormatException(string.Format("Failed to convert literal '{0}' to desired type '{1}' for comparison", literal, varVal.GetType().Name), ex); }
+            { throw new FormatException($"Failed to convert literal '{literal}' to desired type '{varVal.GetType().Name}' for comparison", ex); }
 
             return ops[op](varVal, litVal);
         }
diff --git a/Duplicati/Library/SQLiteHelper/SQLiteLoader.cs b/Duplicati/Library/SQLiteHelper/SQLiteLoader.cs
index 4a752af16..529034a08 100644
--- a/Duplicati/Library/SQLiteHelper/SQLiteLoader.cs
+++ b/Duplicati/Library/SQLiteHelper/SQLiteLoader.cs
@@ -203,7 +203,7 @@ namespace Duplicati.Library.SQLiteHelper
                     {
                         foreach (var asmversion in new[] { "4.0.0.0", "2.0.0.0" })
                         {
-                            var name = string.Format("Mono.Data.Sqlite, Version={0}, Culture=neutral, PublicKeyToken=0738eb9f132ed756", asmversion);
+                            var name = $"Mono.Data.Sqlite, Version={asmversion}, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
                             try
                             {
                                 Type t = System.Reflection.Assembly.Load(name).GetType("Mono.Data.Sqlite.SqliteConnection");
diff --git a/Duplicati/Library/Snapshots/HyperVUtility.cs b/Duplicati/Library/Snapshots/HyperVUtility.cs
index 338706c85..93fae7fd9 100644
--- a/Duplicati/Library/Snapshots/HyperVUtility.cs
+++ b/Duplicati/Library/Snapshots/HyperVUtility.cs
@@ -33,8 +33,7 @@ namespace Duplicati.Library.Snapshots
 
         public override bool Equals(object obj)
         {
-            HyperVGuest guest = obj as HyperVGuest;
-            if (guest != null)
+            if (obj is HyperVGuest guest)
             {
                 return Equals(guest);
             }
@@ -106,8 +105,8 @@ namespace Duplicati.Library.Snapshots
 
             //Set the scope to use in WMI. V2 for Server 2012 or newer.
             _wmiScope = _wmiv2Namespace
-                ? new ManagementScope(string.Format("\\\\{0}\\root\\virtualization\\v2", _wmiHost))
-                : new ManagementScope(string.Format("\\\\{0}\\root\\virtualization", _wmiHost));
+                ? new ManagementScope($"\\\\{_wmiHost}\\root\\virtualization\\v2")
+                : new ManagementScope($"\\\\{_wmiHost}\\root\\virtualization");
             //Set the VM ID Selector Field for the WMI Query
             _vmIdField = _wmiv2Namespace ? "VirtualSystemIdentifier" : "SystemName";
 
@@ -222,8 +221,8 @@ namespace Duplicati.Library.Snapshots
             var result = new List<string>();
             string path;
             var wmiQuery = _wmiv2Namespace
-                ? string.Format("select * from Msvm_VirtualSystemSettingData where {0}='{1}'", _vmIdField, vmID)
-                : string.Format("select * from Msvm_VirtualSystemGlobalSettingData where {0}='{1}'", _vmIdField, vmID);
+                ? $"select * from Msvm_VirtualSystemSettingData where {_vmIdField}='{vmID}'"
+                : $"select * from Msvm_VirtualSystemGlobalSettingData where {_vmIdField}='{vmID}'";
 
             using (var mObject1 = new ManagementObjectSearcher(_wmiScope, new ObjectQuery(wmiQuery)).Get().Cast<ManagementObject>().First())
                 if (_wmiv2Namespace)
@@ -232,9 +231,7 @@ namespace Duplicati.Library.Snapshots
                     if (File.Exists(path))
                         result.Add(path);
 
-                    using (var snaps = new ManagementObjectSearcher(_wmiScope, new ObjectQuery(string.Format(
-                        "SELECT * FROM Msvm_VirtualSystemSettingData where VirtualSystemType='Microsoft:Hyper-V:Snapshot:Realized' and {0}='{1}'",
-                        _vmIdField, vmID))).Get())
+                    using (var snaps = new ManagementObjectSearcher(_wmiScope, new ObjectQuery($"SELECT * FROM Msvm_VirtualSystemSettingData where VirtualSystemType='Microsoft:Hyper-V:Snapshot:Realized' and {_vmIdField}='{vmID}'")).Get())
                     {
                         foreach (var snap in snaps)
                         {
@@ -256,9 +253,7 @@ namespace Duplicati.Library.Snapshots
                     if (Directory.Exists(path))
                         result.Add(path);
 
-                    var snapsIDs = new ManagementObjectSearcher(_wmiScope, new ObjectQuery(string.Format(
-                        "SELECT * FROM Msvm_VirtualSystemSettingData where SettingType=5 and {0}='{1}'",
-                        _vmIdField, vmID))).Get().OfType<ManagementObject>().Select(o => (string)o.GetPropertyValue("InstanceID")).ToList();
+                    var snapsIDs = new ManagementObjectSearcher(_wmiScope, new ObjectQuery($"SELECT * FROM Msvm_VirtualSystemSettingData where SettingType=5 and {_vmIdField}='{vmID}'")).Get().OfType<ManagementObject>().Select(o => (string)o.GetPropertyValue("InstanceID")).ToList();
 
                     foreach (var snapID in snapsIDs)
                     {
@@ -282,7 +277,7 @@ namespace Duplicati.Library.Snapshots
         private List<string> GetVMVhdPathsWMI(string vmID)
         {
             var result = new List<string>();
-            using (var vm = new ManagementObjectSearcher(_wmiScope, new ObjectQuery(string.Format("select * from Msvm_ComputerSystem where Name = '{0}'", vmID)))
+            using (var vm = new ManagementObjectSearcher(_wmiScope, new ObjectQuery($"select * from Msvm_ComputerSystem where Name = '{vmID}'"))
                 .Get().OfType<ManagementObject>().First())
             {
                 foreach (var sysSettings in vm.GetRelated("MsVM_VirtualSystemSettingData"))
diff --git a/Duplicati/Library/Snapshots/MSSQLUtility.cs b/Duplicati/Library/Snapshots/MSSQLUtility.cs
index 6149581c3..a3f19b92a 100644
--- a/Duplicati/Library/Snapshots/MSSQLUtility.cs
+++ b/Duplicati/Library/Snapshots/MSSQLUtility.cs
@@ -31,8 +31,7 @@ namespace Duplicati.Library.Snapshots
 
         public override bool Equals(object obj)
         {
-            MSSQLDB db = obj as MSSQLDB;
-            if (db != null)
+            if (obj is MSSQLDB db)
             {
                 return Equals(db);
             }
diff --git a/Duplicati/Library/UsageReporter/OSInfoHelper.cs b/Duplicati/Library/UsageReporter/OSInfoHelper.cs
index b810990ce..28c215e5b 100644
--- a/Duplicati/Library/UsageReporter/OSInfoHelper.cs
+++ b/Duplicati/Library/UsageReporter/OSInfoHelper.cs
@@ -86,7 +86,7 @@ namespace Duplicati.Library.UsageReporter
                         var version = lines.Where(x => x.Trim().StartsWith("ProductVersion:", StringComparison.Ordinal)).Select(x => x.Trim().Substring("ProductVersion:".Length).Trim()).FirstOrDefault();
                         var build = lines.Where(x => x.Trim().StartsWith("BuildVersion:", StringComparison.Ordinal)).Select(x => x.Trim().Substring("BuildVersion:".Length).Trim()).FirstOrDefault();
                         if (!string.IsNullOrWhiteSpace(product))
-                            return string.Format("{0} {1} {2}", product, version, build);
+                            return $"{product} {version} {build}";
                     }
                        
                     return RunProgramAndReadOutput("uname", "-srvmp");
@@ -136,7 +136,7 @@ namespace Duplicati.Library.UsageReporter
                         version = version ?? keys.FirstOrDefault(x => string.Equals(x.Item1, "VERSION_ID", StringComparison.OrdinalIgnoreCase));
 
                         if (name != null && version != null)
-                            return string.Format("{0} {1}", name.Item2, version.Item2);
+                            return $"{name.Item2} {version.Item2}";
                         if (name != null)
                             return name.Item2;
                     }
diff --git a/Duplicati/Library/UsageReporter/ReportSet.cs b/Duplicati/Library/UsageReporter/ReportSet.cs
index f8ca534d9..85005069d 100644
--- a/Duplicati/Library/UsageReporter/ReportSet.cs
+++ b/Duplicati/Library/UsageReporter/ReportSet.cs
@@ -65,9 +65,9 @@ namespace Duplicati.Library.UsageReporter
         private static void DoInitCLR()
         {
             if (Utility.Utility.IsMono)
-                Cached_CLRVersion = string.Format("Mono {0} ({1}), CLR: {2}", Utility.Utility.MonoDisplayVersion, Utility.Utility.MonoVersion, Environment.Version);
+                Cached_CLRVersion = $"Mono {Utility.Utility.MonoDisplayVersion} ({Utility.Utility.MonoVersion}), CLR: {Environment.Version}";
             else
-                Cached_CLRVersion = string.Format(".Net {0}", Environment.Version);
+                Cached_CLRVersion = $".Net {Environment.Version}";
         }
 
         [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
diff --git a/Duplicati/Library/Utility/AsyncHttpRequest.cs b/Duplicati/Library/Utility/AsyncHttpRequest.cs
index 0ba349d71..7e33f8ec8 100644
--- a/Duplicati/Library/Utility/AsyncHttpRequest.cs
+++ b/Duplicati/Library/Utility/AsyncHttpRequest.cs
@@ -221,7 +221,7 @@ namespace Duplicati.Library.Utility
                 catch (Exception ex)
                 {
                     if (m_timedout)
-                        m_exception = new WebException(string.Format("{0} timed out", m_isRequest ? "GetRequestStream" : "GetResponse"), ex, WebExceptionStatus.Timeout, ex is WebException exception ? exception.Response : null);
+                        m_exception = new WebException($"{(m_isRequest ? "GetRequestStream" : "GetResponse")} timed out", ex, WebExceptionStatus.Timeout, ex is WebException exception ? exception.Response : null);
                     else
                     {
                         // Workaround for: https://bugzilla.xamarin.com/show_bug.cgi?id=28287
diff --git a/Duplicati/Library/Utility/DirectStreamLink.cs b/Duplicati/Library/Utility/DirectStreamLink.cs
index aec086c78..746a06a4c 100644
--- a/Duplicati/Library/Utility/DirectStreamLink.cs
+++ b/Duplicati/Library/Utility/DirectStreamLink.cs
@@ -271,8 +271,7 @@ namespace Duplicati.Library.Utility
 
             // we close m_passWriteThrough before blocking, so if at end of chain (stacked DirectStreamLinks) 
             // a blocked reader is waiting, it can proceed sooner.
-            if (m_passWriteThrough != null)
-            { m_passWriteThrough.Close(); }
+            m_passWriteThrough?.Close();
 
             if (m_blockOnClose) // wait until reader has closed its stream before continuing.
             {
diff --git a/Duplicati/Library/Utility/FileBackedList.cs b/Duplicati/Library/Utility/FileBackedList.cs
index f31afa302..d7908430c 100644
--- a/Duplicati/Library/Utility/FileBackedList.cs
+++ b/Duplicati/Library/Utility/FileBackedList.cs
@@ -132,7 +132,7 @@ namespace Duplicati.Library.Utility
             var pos = m_stream.Position;
             Serialize(value, m_stream);
             if (m_stream.Position - pos != size)
-                throw new Exception(string.Format("Stream serializer wrote a different set of bytes than it was supposed to. Expected {0} bytes, but wrote {1} bytes", m_stream.Position - pos, size));
+                throw new Exception($"Stream serializer wrote a different set of bytes than it was supposed to. Expected {m_stream.Position - pos} bytes, but wrote {size} bytes");
 
             m_count++;
         }
diff --git a/Duplicati/Library/Utility/FilterExpression.cs b/Duplicati/Library/Utility/FilterExpression.cs
index fc4eb1745..1d3b67b57 100644
--- a/Duplicati/Library/Utility/FilterExpression.cs
+++ b/Duplicati/Library/Utility/FilterExpression.cs
@@ -687,7 +687,7 @@ namespace Duplicati.Library.Utility
                     work.Push(filterExpression.First);
                 }
                 else
-                    throw new Exception(string.Format("Cannot serialize filter instance of type: {0}", f.GetType()));
+                    throw new Exception($"Cannot serialize filter instance of type: {f.GetType()}");
 
             }
             return res.Where(x => !string.IsNullOrWhiteSpace(x)).ToArray();
diff --git a/Duplicati/Library/Utility/TempFile.cs b/Duplicati/Library/Utility/TempFile.cs
index 8a379e6c5..9c93382c9 100644
--- a/Duplicati/Library/Utility/TempFile.cs
+++ b/Duplicati/Library/Utility/TempFile.cs
@@ -56,9 +56,9 @@ namespace Duplicati.Library.Utility
             foreach (var f in st.GetFrames())
                 if (f.GetMethod().DeclaringType.Assembly != typeof(TempFile).Assembly)
                 {
-                    var n = string.Format("{0}_{1}_{2}_{3}", f.GetMethod().DeclaringType.FullName, f.GetMethod().Name, Library.Utility.Utility.SerializeDateTime(DateTime.UtcNow), Guid.NewGuid().ToString().Substring(0, 8));
+                    var n = $"{f.GetMethod().DeclaringType.FullName}_{f.GetMethod().Name}_{Library.Utility.Utility.SerializeDateTime(DateTime.UtcNow)}_{Guid.NewGuid().ToString().Substring(0, 8)}";
                     if (n.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) >= 0)
-                        n = string.Format("{0}_{1}_{2}_{3}", f.GetMethod().DeclaringType.Name, f.GetMethod().Name, Library.Utility.Utility.SerializeDateTime(DateTime.UtcNow), Guid.NewGuid().ToString().Substring(0, 8));
+                        n = $"{f.GetMethod().DeclaringType.Name}_{f.GetMethod().Name}_{Library.Utility.Utility.SerializeDateTime(DateTime.UtcNow)}_{Guid.NewGuid().ToString().Substring(0, 8)}";
                     if (n.IndexOfAny(System.IO.Path.GetInvalidFileNameChars()) < 0)
                     {
                         lock (m_lock)
diff --git a/Duplicati/Library/Utility/UrlUtility.cs b/Duplicati/Library/Utility/UrlUtility.cs
index 13e27c15d..9b2acde13 100644
--- a/Duplicati/Library/Utility/UrlUtility.cs
+++ b/Duplicati/Library/Utility/UrlUtility.cs
@@ -65,7 +65,7 @@ namespace Duplicati.Library.Utility
                 catch
                 {
                     if (ErrorHandler != null)
-                        ErrorHandler(string.Format("Unable to open a browser window, please manually visit: \r\n{0}", url));
+                        ErrorHandler($"Unable to open a browser window, please manually visit: \r\n{url}");
                 }
             }
             else if (Platform.IsClientPosix)
@@ -88,7 +88,7 @@ namespace Duplicati.Library.Utility
                 catch
                 {
                     if (ErrorHandler != null)
-                        ErrorHandler(string.Format("Unable to open a browser window, please manually visit: \r\n{0}", url));
+                        ErrorHandler($"Unable to open a browser window, please manually visit: \r\n{url}");
                 }
             }
             else
@@ -143,7 +143,7 @@ namespace Duplicati.Library.Utility
             catch
             {
                 if (ErrorHandler != null)
-                    ErrorHandler(string.Format("Unable to open a browser window, please manually visit: \r\n{0}", url));
+                    ErrorHandler($"Unable to open a browser window, please manually visit: \r\n{url}");
             }
 
         }
diff --git a/Duplicati/Server/Database/Connection.cs b/Duplicati/Server/Database/Connection.cs
index ce9ed53da..08d37f058 100644
--- a/Duplicati/Server/Database/Connection.cs
+++ b/Duplicati/Server/Database/Connection.cs
@@ -1050,7 +1050,7 @@ namespace Duplicati.Server.Database
                     var r = cmd.ExecuteNonQuery();
                     // Roll back the transaction if more than 1 ID was deleted. Multiple "BackupID" rows being deleted isn't a problem.
                     if (identifier == "ID" && r > 1)
-                        throw new Exception(string.Format("Too many records attempted deleted from table {0} for id {1}: {2}", tablename, id, r));
+                        throw new Exception($"Too many records attempted deleted from table {tablename} for id {id}: {r}");
                     return r == 1;
                 }
             }
diff --git a/Duplicati/Server/Duplicati.Server.Serialization/InterfaceResolver.cs b/Duplicati/Server/Duplicati.Server.Serialization/InterfaceResolver.cs
index 76c093c17..cd4de475a 100644
--- a/Duplicati/Server/Duplicati.Server.Serialization/InterfaceResolver.cs
+++ b/Duplicati/Server/Duplicati.Server.Serialization/InterfaceResolver.cs
@@ -47,7 +47,7 @@ namespace Duplicati.Server.Serialization
         {
             if (value == null)
             {
-                throw new JsonSerializationException(string.Format("Invalid DayOfWeek: {0}", value));
+                throw new JsonSerializationException($"Invalid DayOfWeek: {value}");
             }
             else
             {
@@ -75,7 +75,7 @@ namespace Duplicati.Server.Serialization
                         writer.WriteValue("sun");
                         break;
                     default:
-                        throw new JsonSerializationException(string.Format("Invalid DayOfWeek: {0}", value));
+                        throw new JsonSerializationException($"Invalid DayOfWeek: {value}");
                 }
             }
         }
@@ -83,9 +83,9 @@ namespace Duplicati.Server.Serialization
         public override object ReadJson(JsonReader reader, Type objectType, object existingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
             if (reader.TokenType == JsonToken.Null)
-                throw new JsonSerializationException(string.Format("Cannot convert null value to {0}", objectType));
+                throw new JsonSerializationException($"Cannot convert null value to {objectType}");
             else if (reader.TokenType != JsonToken.String)
-                throw new JsonSerializationException(string.Format("Cannot convert {0} value to {1}", reader.TokenType, objectType));
+                throw new JsonSerializationException($"Cannot convert {reader.TokenType} value to {objectType}");
             
             var v = (string)reader.Value;
             DayOfWeek result;
@@ -110,7 +110,7 @@ namespace Duplicati.Server.Serialization
                     return DayOfWeek.Sunday;                    
             }
             
-            throw new JsonSerializationException(string.Format("Cannot convert \"{0}\" to {1}", v, objectType));
+            throw new JsonSerializationException($"Cannot convert \"{v}\" to {objectType}");
         }
 
         public override bool CanConvert(Type objectType)
diff --git a/Duplicati/Server/Runner.cs b/Duplicati/Server/Runner.cs
index 33a230381..329de0972 100644
--- a/Duplicati/Server/Runner.cs
+++ b/Duplicati/Server/Runner.cs
@@ -410,15 +410,15 @@ namespace Duplicati.Server
             parts.AddRange(sources);
 
             foreach (var opt in options)
-                parts.Add(string.Format("--{0}={1}", opt.Key, opt.Value));
+                parts.Add($"--{opt.Key}={opt.Value}");
 
             if (cf != null)
                 foreach (var f in cf)
-                    parts.Add(string.Format("--{0}={1}", f.Include ? "include" : "exclude", f.Expression));
+                    parts.Add($"--{(f.Include ? "include" : "exclude")}={f.Expression}");
 
             if (bf != null)
                 foreach (var f in bf)
-                    parts.Add(string.Format("--{0}={1}", f.Include ? "include" : "exclude", f.Expression));
+                    parts.Add($"--{(f.Include ? "include" : "exclude")}={f.Expression}");
 
             return parts.ToArray();
         }
@@ -625,7 +625,7 @@ namespace Duplicati.Server
             }
             catch (Exception ex)
             {
-                Program.DataConnection.LogError(data.Backup.ID, string.Format("Failed while executing \"{0}\" with id: {1}", data.Operation, data.Backup.ID), ex);
+                Program.DataConnection.LogError(data.Backup.ID, $"Failed while executing \"{data.Operation}\" with id: {data.Backup.ID}", ex);
                 UpdateMetadataError(data.Backup, ex);
                 Library.UsageReporter.Reporter.Report(ex);
 
@@ -695,7 +695,7 @@ namespace Duplicati.Server
             Program.DataConnection.RegisterNotification(
                 NotificationType.Error,
                 backup.IsTemporary ?
-                    "Error" : string.Format("Error while running {0}", backup.Name),
+                    "Error" : $"Error while running {backup.Name}",
                 ex.Message,
                 ex,
                 backup.ID,
@@ -845,13 +845,13 @@ namespace Duplicati.Server
 
                 var title = result.ParsedResult == Library.Interface.ParsedResultType.Warning
                                 ? (backup.IsTemporary ?
-                                "Warning" : string.Format("Warning while running {0}", backup.Name))
+                                "Warning" : $"Warning while running {backup.Name}")
                             : (backup.IsTemporary ?
-                                "Error" : string.Format("Error while running {0}", backup.Name));
+                                "Error" : $"Error while running {backup.Name}");
 
                 var message = result.ParsedResult == Library.Interface.ParsedResultType.Warning
-                                    ? string.Format("Got {0} warning(s)", result.Warnings.Count())
-                                    : string.Format("Got {0} error(s)", result.Errors.Count());
+                                    ? $"Got {result.Warnings.Count()} warning(s)"
+                                    : $"Got {result.Errors.Count()} error(s)";
 
                 Program.DataConnection.RegisterNotification(
                     type,
diff --git a/Duplicati/Server/WebServer/RESTHandler.cs b/Duplicati/Server/WebServer/RESTHandler.cs
index b09b78378..b900391fb 100644
--- a/Duplicati/Server/WebServer/RESTHandler.cs
+++ b/Duplicati/Server/WebServer/RESTHandler.cs
@@ -71,7 +71,7 @@ namespace Duplicati.Server.WebServer
         private static System.Globalization.CultureInfo ParseRequestCulture(RequestInfo info)
         {
             // Inject the override
-            return ParseRequestCulture(string.Format("{0},{1}", info.Request.Headers["X-UI-Language"], info.Request.Headers["Accept-Language"]));
+            return ParseRequestCulture($"{info.Request.Headers["X-UI-Language"]},{info.Request.Headers["Accept-Language"]}");
         }
 
         public static System.Globalization.CultureInfo ParseDefaultRequestCulture(RequestInfo info)
@@ -192,7 +192,7 @@ namespace Duplicati.Server.WebServer
                 }
                 catch (Exception ex)
                 {
-                    Program.DataConnection.LogError("", string.Format("Request for {0} gave error", info.Request.Uri), ex);
+                    Program.DataConnection.LogError("", $"Request for {info.Request.Uri} gave error", ex);
                     Console.WriteLine(ex);
 
                     try
diff --git a/Duplicati/Server/WebServer/RESTMethods/Backup.cs b/Duplicati/Server/WebServer/RESTMethods/Backup.cs
index 926e7ba80..5f0c8d389 100644
--- a/Duplicati/Server/WebServer/RESTMethods/Backup.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/Backup.cs
@@ -164,7 +164,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
                 }
 
                 info.Response.ContentLength = data.Length;
-                info.Response.AddHeader("Content-Disposition", string.Format("attachment; filename={0}", filename));
+                info.Response.AddHeader("Content-Disposition", $"attachment; filename={filename}");
                 info.Response.ContentType = "application/octet-stream";
 
                 info.BodyWriter.SetOK();
@@ -431,7 +431,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
                             IsActive(bk, info);
                             return;
                         default:
-                            info.ReportClientError(string.Format("Invalid component: {0}", operation), System.Net.HttpStatusCode.BadRequest);
+                            info.ReportClientError($"Invalid component: {operation}", System.Net.HttpStatusCode.BadRequest);
                             return;
                     }
 
@@ -611,9 +611,9 @@ namespace Duplicati.Server.WebServer.RESTMethods
             catch (Exception ex)
             {
                 if (data == null)
-                    info.ReportClientError(string.Format("Unable to parse backup or schedule object: {0}", ex.Message), System.Net.HttpStatusCode.BadRequest);
+                    info.ReportClientError($"Unable to parse backup or schedule object: {ex.Message}", System.Net.HttpStatusCode.BadRequest);
                 else
-                    info.ReportClientError(string.Format("Unable to save backup or schedule: {0}", ex.Message), System.Net.HttpStatusCode.InternalServerError);
+                    info.ReportClientError($"Unable to save backup or schedule: {ex.Message}", System.Net.HttpStatusCode.InternalServerError);
             }
         }
 
diff --git a/Duplicati/Server/WebServer/RESTMethods/Backups.cs b/Duplicati/Server/WebServer/RESTMethods/Backups.cs
index 91c028013..819d57ed3 100644
--- a/Duplicati/Server/WebServer/RESTMethods/Backups.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/Backups.cs
@@ -275,9 +275,9 @@ namespace Duplicati.Server.WebServer.RESTMethods
             catch (Exception ex)
             {
                 if (data == null)
-                    info.ReportClientError(string.Format("Unable to parse backup or schedule object: {0}", ex.Message), System.Net.HttpStatusCode.BadRequest);
+                    info.ReportClientError($"Unable to parse backup or schedule object: {ex.Message}", System.Net.HttpStatusCode.BadRequest);
                 else
-                    info.ReportClientError(string.Format("Unable to save schedule or backup object: {0}", ex.Message), System.Net.HttpStatusCode.InternalServerError);
+                    info.ReportClientError($"Unable to save schedule or backup object: {ex.Message}", System.Net.HttpStatusCode.InternalServerError);
             }
         }
 
diff --git a/Duplicati/Server/WebServer/RESTMethods/BugReport.cs b/Duplicati/Server/WebServer/RESTMethods/BugReport.cs
index 61aef7a55..ca2e82bcf 100644
--- a/Duplicati/Server/WebServer/RESTMethods/BugReport.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/BugReport.cs
@@ -43,7 +43,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
             using(var fs = System.IO.File.OpenRead(tf.Path))
             {
                 info.Response.ContentLength = fs.Length;
-                info.Response.AddHeader("Content-Disposition", string.Format("attachment; filename={0}", filename));
+                info.Response.AddHeader("Content-Disposition", $"attachment; filename={filename}");
                 info.Response.ContentType = "application/octet-stream";
 
                 info.BodyWriter.SetOK();
diff --git a/Duplicati/Server/WebServer/RESTMethods/Filesystem.cs b/Duplicati/Server/WebServer/RESTMethods/Filesystem.cs
index 3c2b25aed..e6ea24c43 100644
--- a/Duplicati/Server/WebServer/RESTMethods/Filesystem.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/Filesystem.cs
@@ -95,7 +95,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
                 }
                 else
                 {
-                    info.ReportClientError(string.Format("No such operation found: {0}", command), System.Net.HttpStatusCode.NotFound);
+                    info.ReportClientError($"No such operation found: {command}", System.Net.HttpStatusCode.NotFound);
                     return;
                 }
             }
diff --git a/Duplicati/Server/WebServer/RESTMethods/HyperV.cs b/Duplicati/Server/WebServer/RESTMethods/HyperV.cs
index b5298eab9..cf3235b2b 100644
--- a/Duplicati/Server/WebServer/RESTMethods/HyperV.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/HyperV.cs
@@ -63,7 +63,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
                     if (foundVMs.Count == 1)
                         info.OutputOK(foundVMs[0].DataPaths.Select(x => new { text = x, id = x, cls = "folder", iconCls = "x-tree-icon-leaf", check = "false", leaf = "true" }).ToList());
                     else
-                        info.ReportClientError(string.Format("Cannot find VM with ID {0}.", key), System.Net.HttpStatusCode.NotFound);
+                        info.ReportClientError($"Cannot find VM with ID {key}.", System.Net.HttpStatusCode.NotFound);
                 }
             }
             catch (Exception ex)
diff --git a/Duplicati/Server/WebServer/RESTMethods/MSSQL.cs b/Duplicati/Server/WebServer/RESTMethods/MSSQL.cs
index 2015fb959..786d4e4df 100644
--- a/Duplicati/Server/WebServer/RESTMethods/MSSQL.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/MSSQL.cs
@@ -61,7 +61,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
                     if (foundDBs.Count == 1)
                         info.OutputOK(foundDBs[0].DataPaths.Select(x => new { text = x, id = x, cls = "folder", iconCls = "x-tree-icon-leaf", check = "false", leaf = "true" }).ToList());
                     else
-                        info.ReportClientError(string.Format("Cannot find DB with ID {0}.", key), System.Net.HttpStatusCode.NotFound);
+                        info.ReportClientError($"Cannot find DB with ID {key}.", System.Net.HttpStatusCode.NotFound);
                 }
             }
             catch (Exception ex)
diff --git a/Duplicati/Server/WebServer/RESTMethods/ServerSettings.cs b/Duplicati/Server/WebServer/RESTMethods/ServerSettings.cs
index 1df9d13cf..849d47545 100644
--- a/Duplicati/Server/WebServer/RESTMethods/ServerSettings.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/ServerSettings.cs
@@ -104,9 +104,9 @@ namespace Duplicati.Server.WebServer.RESTMethods
             catch (Exception ex)
             {
                 if (data == null)
-                    info.ReportClientError(string.Format("Unable to parse data object: {0}", ex.Message), System.Net.HttpStatusCode.BadRequest);
+                    info.ReportClientError($"Unable to parse data object: {ex.Message}", System.Net.HttpStatusCode.BadRequest);
                 else
-                    info.ReportClientError(string.Format("Unable to save settings: {0}", ex.Message), System.Net.HttpStatusCode.InternalServerError);
+                    info.ReportClientError($"Unable to save settings: {ex.Message}", System.Net.HttpStatusCode.InternalServerError);
             }            
         }
 
diff --git a/Duplicati/Server/WebServer/RESTMethods/UISettings.cs b/Duplicati/Server/WebServer/RESTMethods/UISettings.cs
index 9966652c9..c698aace5 100644
--- a/Duplicati/Server/WebServer/RESTMethods/UISettings.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/UISettings.cs
@@ -55,7 +55,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
             }
             catch (Exception ex)
             {
-                info.ReportClientError(string.Format("Unable to parse settings object: {0}", ex.Message), System.Net.HttpStatusCode.BadRequest);
+                info.ReportClientError($"Unable to parse settings object: {ex.Message}", System.Net.HttpStatusCode.BadRequest);
                 return;
             }
 
diff --git a/Duplicati/Server/WebServer/RESTMethods/WebModule.cs b/Duplicati/Server/WebServer/RESTMethods/WebModule.cs
index bf75c7ed1..d19570675 100644
--- a/Duplicati/Server/WebServer/RESTMethods/WebModule.cs
+++ b/Duplicati/Server/WebServer/RESTMethods/WebModule.cs
@@ -26,7 +26,7 @@ namespace Duplicati.Server.WebServer.RESTMethods
             var m = Duplicati.Library.DynamicLoader.WebLoader.Modules.FirstOrDefault(x => x.Key.Equals(key, StringComparison.OrdinalIgnoreCase));
             if (m == null)
             {
-                info.ReportClientError(string.Format("No such command {0}", key), System.Net.HttpStatusCode.NotFound);
+                info.ReportClientError($"No such command {key}", System.Net.HttpStatusCode.NotFound);
                 return;
             }
 
diff --git a/Duplicati/Server/WebServer/Server.cs b/Duplicati/Server/WebServer/Server.cs
index 0ab45ba54..9de03ddf5 100644
--- a/Duplicati/Server/WebServer/Server.cs
+++ b/Duplicati/Server/WebServer/Server.cs
@@ -165,7 +165,7 @@ namespace Duplicati.Server.WebServer
                         server.Start(listenInterface, p, cert, System.Security.Authentication.SslProtocols.Tls11 | System.Security.Authentication.SslProtocols.Tls12, null, false);
 
                     m_server = server;
-                    m_server.ServerName = string.Format("{0} v{1}", Library.AutoUpdater.AutoUpdateSettings.AppName, System.Reflection.Assembly.GetExecutingAssembly().GetName().Version);
+                    m_server.ServerName = $"{Library.AutoUpdater.AutoUpdateSettings.AppName} v{System.Reflection.Assembly.GetExecutingAssembly().GetName().Version}";
                     this.Port = p;
 
                     if (interfacestring !=  Program.DataConnection.ApplicationSettings.ServerListenInterface)
@@ -298,7 +298,7 @@ namespace Duplicati.Server.WebServer
         {
             public override bool Process(HttpServer.IHttpRequest request, HttpServer.IHttpResponse response, HttpServer.Sessions.IHttpSession session)
             {
-                System.Diagnostics.Trace.WriteLine(string.Format("Rejecting request for {0}", request.Uri));
+                System.Diagnostics.Trace.WriteLine($"Rejecting request for {request.Uri}");
                 return false;
             }
         }
diff --git a/Duplicati/Server/WebServer/SynologyAuthenticationHandler.cs b/Duplicati/Server/WebServer/SynologyAuthenticationHandler.cs
index 77fef2a19..348769852 100644
--- a/Duplicati/Server/WebServer/SynologyAuthenticationHandler.cs
+++ b/Duplicati/Server/WebServer/SynologyAuthenticationHandler.cs
@@ -222,7 +222,7 @@ namespace Duplicati.Server.WebServer
             if (!values.ContainsKey("REMOTE_ADDR") || !values.ContainsKey("REMOTE_PORT") || !values.ContainsKey("HTTP_COOKIE"))
                 return null;
             
-            return string.Format("{0}:{1}/{2}?{3}", values["REMOTE_ADDR"], values["REMOTE_PORT"], values["HTTP_COOKIE"], xsrftoken);
+            return $"{values["REMOTE_ADDR"]}:{values["REMOTE_PORT"]}/{values["HTTP_COOKIE"]}?{xsrftoken}";
         }
 
         /// <summary>
@@ -269,7 +269,7 @@ namespace Duplicati.Server.WebServer
                     catch { }
 
                 if (!p.HasExited || (p.ExitCode != exitcode && exitcode != -1))
-                    throw new Exception(string.Format("Exit code was: {0}, stdout: {1}", p.ExitCode, res));
+                    throw new Exception($"Exit code was: {p.ExitCode}, stdout: {res}");
                 return await res;
             }
         }
diff --git a/Duplicati/Service/Runner.cs b/Duplicati/Service/Runner.cs
index 4f2ae0f76..f5e56185f 100644
--- a/Duplicati/Service/Runner.cs
+++ b/Duplicati/Service/Runner.cs
@@ -68,16 +68,16 @@ namespace Duplicati.Service
                 {
                     if (!System.IO.File.Exists(exec))
                     {
-                        m_reportMessage(string.Format("File not found {0}", exec), true);
+                        m_reportMessage($"File not found {exec}", true);
                         return;
                     }
 
                     try
                     {
                         if (!firstRun)
-                            m_reportMessage(string.Format("Attempting to restart server process: {0}", exec), true);
+                            m_reportMessage($"Attempting to restart server process: {exec}", true);
 
-                        m_reportMessage(string.Format("Starting process {0} with cmd args {1}", exec, cmdargs), false);
+                        m_reportMessage($"Starting process {exec} with cmd args {cmdargs}", false);
 
                         var pr = new System.Diagnostics.ProcessStartInfo(exec, cmdargs)
                         {
@@ -112,7 +112,7 @@ namespace Duplicati.Service
                     }
                     catch (Exception ex)
                     {
-                        m_reportMessage(string.Format("Process has failed with error message: {0}", ex), true);
+                        m_reportMessage($"Process has failed with error message: {ex}", true);
 
                         if (firstRun)
                         {
diff --git a/Duplicati/UnitTest/CommandLineOperationsTests.cs b/Duplicati/UnitTest/CommandLineOperationsTests.cs
index a60aa4685..d2584dd81 100644
--- a/Duplicati/UnitTest/CommandLineOperationsTests.cs
+++ b/Duplicati/UnitTest/CommandLineOperationsTests.cs
@@ -128,7 +128,7 @@ namespace Duplicati.UnitTest
 
         private void DoRunCommands(string target)
         {
-            var opts = from n in TestOptions select string.Format("--{0}=\"{1}\"", n.Key, n.Value);
+            var opts = from n in TestOptions select $"--{n.Key}=\"{n.Value}\"";
             var backupargs = (new string[] { "backup", target, DATAFOLDER }.Union(opts)).ToArray();
 
             if (SourceDataFolders == null || SourceDataFolders.Count() < 3)
@@ -148,7 +148,7 @@ namespace Duplicati.UnitTest
                 var size = systemIO.EnumerateFiles(targetfolder, "*", SearchOption.AllDirectories).Select(systemIO.FileLength).Sum();
 
                 ProgressWriteLine("Running backup with {0} data added ...", Duplicati.Library.Utility.Utility.FormatSizeString(size));
-                using (new Library.Logging.Timer(LOGTAG, "BackupWithDataAdded", string.Format("Backup with {0} data added", Duplicati.Library.Utility.Utility.FormatSizeString(size))))
+                using (new Library.Logging.Timer(LOGTAG, "BackupWithDataAdded", $"Backup with {Duplicati.Library.Utility.Utility.FormatSizeString(size)} data added"))
                     Duplicati.CommandLine.Program.RealMain(backupargs);
 
                 ProgressWriteLine("Testing data ...");
@@ -198,7 +198,7 @@ namespace Duplicati.UnitTest
                 ProgressWriteLine("Running backup with changed logfile {0} of {1} ...", i + 1, 5);
                 systemIO.FileCopy(LOGFILE, Path.Combine(SOURCEFOLDER, Path.GetFileName(LOGFILE)), true);
 
-                using (new Library.Logging.Timer(LOGTAG, "BackupWithLogfileChange", string.Format("Backup with logfilechange {0}", i + 1)))
+                using (new Library.Logging.Timer(LOGTAG, "BackupWithLogfileChange", $"Backup with logfilechange {i + 1}"))
                     Duplicati.CommandLine.Program.RealMain(backupargs);
             }
 
diff --git a/Duplicati/UnitTest/Issue1723.cs b/Duplicati/UnitTest/Issue1723.cs
index 91ec9ff16..183edc3d6 100644
--- a/Duplicati/UnitTest/Issue1723.cs
+++ b/Duplicati/UnitTest/Issue1723.cs
@@ -39,7 +39,7 @@ namespace Duplicati.UnitTest
 				Assert.AreEqual(0, r.Warnings.Count());
 				var pr = (Library.Interface.IParsedBackendStatistics)r.BackendStatistics;
 				if (pr.KnownFileSize == 0 || pr.KnownFileCount != 3 || pr.BackupListCount != 1)
-					throw new Exception(string.Format("Failed to get stats from remote backend: {0}, {1}, {2}", pr.KnownFileSize, pr.KnownFileCount, pr.BackupListCount));
+					throw new Exception($"Failed to get stats from remote backend: {pr.KnownFileSize}, {pr.KnownFileCount}, {pr.BackupListCount}");
 			}
 
 
diff --git a/Duplicati/UnitTest/PurgeTesting.cs b/Duplicati/UnitTest/PurgeTesting.cs
index 97954e5a5..bca73159d 100644
--- a/Duplicati/UnitTest/PurgeTesting.cs
+++ b/Duplicati/UnitTest/PurgeTesting.cs
@@ -175,9 +175,9 @@ namespace Duplicati.UnitTest
                 Console.WriteLine("Listing final version information");
 
                 Console.WriteLine("Versions:");
-                Console.WriteLine("  " + string.Join(Environment.NewLine + "  ", filesets.Select(x => string.Format("{0}: {1}, {2} {3}", x.Version, x.Time, x.FileCount, x.FileSizes))));
+                Console.WriteLine("  " + string.Join(Environment.NewLine + "  ", filesets.Select(x => $"{x.Version}: {x.Time}, {x.FileCount} {x.FileSizes}")));
                 Console.WriteLine("Files:");
-                Console.WriteLine("  " + string.Join(Environment.NewLine + "  ", files.Select(x => string.Format("{0}: {1}", x.Path, string.Join(" - ", x.Sizes.Select(y => y.ToString()))))));
+                Console.WriteLine("  " + string.Join(Environment.NewLine + "  ", files.Select(x => $"{x.Path}: {string.Join(" - ", x.Sizes.Select(y => y.ToString()))}")));
 
                 Assert.AreEqual(4, filesets.Length, "Incorrect number of filesets after final backup");
                 Assert.AreEqual(filenames.Count + 1, filecount, "Incorrect number of files after final backup");
diff --git a/Duplicati/UnitTest/SVNCheckoutsTest.cs b/Duplicati/UnitTest/SVNCheckoutsTest.cs
index 77480f291..f3b9cca73 100644
--- a/Duplicati/UnitTest/SVNCheckoutsTest.cs
+++ b/Duplicati/UnitTest/SVNCheckoutsTest.cs
@@ -71,7 +71,7 @@ namespace Duplicati.UnitTest
         public static void RunTest(string[] folders, Dictionary<string, string> options, string target)
         {
             string tempdir = System.IO.Path.Combine(System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location), "tempdir");
-            string logfilename = System.IO.Path.Combine(tempdir, string.Format("unittest-{0}.log", Library.Utility.Utility.SerializeDateTime(DateTime.Now)));
+            string logfilename = System.IO.Path.Combine(tempdir, $"unittest-{Library.Utility.Utility.SerializeDateTime(DateTime.Now)}.log");
 
             try
             {
@@ -97,7 +97,7 @@ namespace Duplicati.UnitTest
                 foreach (var f in folders)
                     foreach (var n in f.Split(new char[] { System.IO.Path.PathSeparator }, StringSplitOptions.RemoveEmptyEntries))
                         if (!System.IO.Directory.Exists(n))
-                            throw new Exception(string.Format("Missing source folder: {0}", n));
+                            throw new Exception($"Missing source folder: {n}");
 
 
                 Duplicati.Library.Utility.TempFolder.SystemTempPath = tempdir;
@@ -219,7 +219,7 @@ namespace Duplicati.UnitTest
                         foreach (Duplicati.Library.Interface.IFileEntry fe in bk.List())
                             if (fe.Size > opts.VolumeSize)
                             {
-                                string msg = string.Format("The file {0} is {1} bytes larger than allowed", fe.Name, fe.Size - opts.VolumeSize);
+                                string msg = $"The file {fe.Name} is {fe.Size - opts.VolumeSize} bytes larger than allowed";
                                 BasicSetupHelper.ProgressWriteLine(msg);
                                 Log.WriteErrorMessage(LOGTAG, "RemoteTargetSize", null, msg);
                             }
@@ -233,7 +233,7 @@ namespace Duplicati.UnitTest
                     {
                         StringBuilder sb = new StringBuilder();
                         sb.AppendLine("Entry count: " + entries.Count.ToString());
-                        sb.Append(string.Format("Found {0} filelists but there were {1} source folders", entries.Count, folders.Length));
+                        sb.Append($"Found {entries.Count} filelists but there were {folders.Length} source folders");
                         throw new Exception("Filename parsing problem, or corrupt storage: " + sb);
                     }
 
@@ -291,7 +291,7 @@ namespace Duplicati.UnitTest
                                             string f = testfiles[j];
 
                                             if (!f.StartsWith(usingFHWithRestore ? fhtempsource : folders[i], Utility.ClientFilenameStringComparison))
-                                                throw new Exception(string.Format("Unexpected file found: {0}, path is not a subfolder for {1}", f, folders[i]));
+                                                throw new Exception($"Unexpected file found: {f}, path is not a subfolder for {folders[i]}");
 
                                             f = f.Substring(Util.AppendDirSeparator(usingFHWithRestore ? fhtempsource : folders[i]).Length);
 
